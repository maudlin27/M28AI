---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 19:23
---
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Config = import('/mods/M28AI/lua/M28Config.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')



--Global variables
bBuildLocationLoopActive = false --true if have a loop that is checking for build locations
bWZBuildLocationLoopActive = false --as above but for water zones
tsBlueprintsBySize = {[1] = 'ueb2101', [2] = 'ueb1101', [3] = 'ueb4302', [6] = 'ueb1201', [8] = 'ueb1301', [9]='xrl0403', [10]='uab0304', [16] = 'xsa0402', [24] = 'uaa0310'} --Blueprints to use when trying to find locations that can buid on for a building of a particular size
tsWZBlueprintsBySize = {[1] = 'ueb2109', [2] = 'ueb4201', [6] = 'ual0401', [8] = 'ura0401', [9]='uel0401', [10]='ueb0103', [14]='ueb0103', [16]='uas0401', [24]='uaa0310'} --Blueprints to use when trying to find locations that can buid on on water for a building/engineer built unit of a particular size
iMaxBuildingSize = 24
--Some blueprints have different skirt size offsets, e.g. naval factories; current solution is to manually note any of the BlueprintsBySize blueprints above and then list alternatives to try
tsExtraBlueprintsToCheck = {['ueb0103'] = {'urb0103', 'xsb0103'},
}
tAllScathis = {} --If a scathis is constructed it gets recorded here (and we then check this for build locations to avoid trying to build on a scathis); for performance reasons will just use a single global table
tiBPByTech = {5,12.5,30, 30}
iCurQueueRefNumber = 0

bActiveDestroyedBuildingLoop = false
tRecentlyDestroyedBuildings = {} --ordered 1, 2,..x
    subrefDestroyedBuildingBlueprint = 'DBP' --blueprint only
    subrefDestroyedBuildingLocation = 'DPS' --'Location, i.e. {xyz}
    subrefDestroyedBuildingTime = 'DTM' --gametimeseconds

--against brain:
--refiEngineerCurUniqueReference - this is also against unit so is declared in below section rather than here

--Against unit varaibles
refiEngineerCurUniqueReference = 'M28EngCurUniqueReference' --Against both aiBrain and engineer; aiBrain stores the xth engineer object its given an action to, so this can be used as a unique reference
refiAssignedAction = 'M28EngAssignedAction' --against Engineer, records the refAction value the engineer was given if it has an active order
reftAssignedReclaimSegments = 'M28EngReclaimSegments' --against engineer, returns {iReclaimSegmentX, iReclaimSegmentZ]}, used when engineer givne a reclaim area order
refbPrimaryBuilder = 'M28EngPrimaryBuilder' --If was the first engineer assigned to build something (and isnt assisting) then this should be true
reftUnitsReclaimingUs = 'M28EngReclaimingUnits' --If have queued up reclaim order on a unit, this will store all units given such an order
reftUnitsWeAreReclaiming = 'M28EngUnitsReclaiming' --If have queued up reclaim order on a unit, this stors against the reclaimer the unit being reclaimed
reftQueuedBuildings = 'M28EngQueuedBuildings' --Whenever issuebuild order is given it should update this
subrefQueueRef = 1 --Unique queue reference number (the same as the ref number given to the land zone)
subrefBuildingID = 2 --Blueprint/UnitId of the building queued
subrefBuildingLocation = 3 --Location the building is to be built at
subrefBuildingRadius = 4 --Size (radius) of the building
subrefPlateauOrZero = 5 --Plateau where hte building is to be built; zero if water zone
subrefLandOrWaterZone = 6 --Land zone where hte building is to be built
refbBuildingExperimental = 'M28EngBuildingExperimental' --True if engineer is building an experimental andh aving itself tracked in the team table for this
refiAssignedActionPriority = 'M28EngPriority' --Priority of the currently assigned action
reftUnitBlacklistSegmentXZ = 'M28UnitBlacklist' --table, ordered 1, 2...', returns {SegmentX, SegmentZ} - contains blacklist details for a unit, used for under construciton experimentals so when construction completes the blacklist status can be cleared

--Shield related variables against a unit
refiFailedShieldBuildDistance = 'M28EngFailedShieldBuildDist' --against a building wanting shielding - records the distance of the closest location that we can build (so can decide if the unit can even be shielded)
refoUnitActivelyShielding = 'M28EngUntActShd' --against the engineer, gives the unit e.g. gameender it is providing special shielding services to
refbActiveUnitShieldingThread = 'M28EngActivShld' --against the gameender/similar unit, true if it has a thread that isa ctively trying to use engineers to protect it
reftEngineersActivelyShielding = 'M28EngActiveEngShd' --against the gameender/similar unit, contains table of all the engineers assigned toa ctively try and protect it



--Actions for engineers (dont have as local variables due to cap on how many local variables we can have)
--Intended actions are those from M27 that havent been integrated yet
refActionBuildMex = 1
refActionBuildHydro = 2
refActionReclaimArea = 3
refActionBuildPower = 4
refActionBuildLandFactory = 5
refActionBuildEnergyStorage = 6
refActionSpare = 7
refActionHasNearbyEnemies = 8
refActionUpgradeBuilding = 9
refActionBuildSecondPower = 10
refActionBuildAirStaging = 11
refActionBuildAirFactory = 12
refActionBuildSMD = 13
refActionBuildMassStorage = 14
refActionBuildT1Radar = 15
refActionBuildT2Radar = 16
refActionBuildT3Radar = 17
refActionAssistSMD = 18
refActionAssistAirFactory = 19
refActionBuildThirdPower = 20
refActionBuildExperimental = 21
refActionReclaimFriendlyUnit = 22
--See below for reclaimenemyunit action
refActionBuildT3MexOverT2 = 23
refActionUpgradeHQ = 24 --Assists an HQ with its upgrade
refActionReclaimTrees = 25
refActionBuildT1Sonar = 26
refActionBuildT2Sonar = 27
refActionAssistNuke = 28
refActionBuildShield = 29
refActionBuildT3ArtiPower = 30
refActionBuildTMD = 31
refActionBuildAA = 32
refActionBuildEmergencyPD = 33 --Indented values below mean not yet got the main code in place
refActionBuildSecondLandFactory = 34
refActionBuildSecondAirFactory = 35
refActionBuildTML = 36
refActionBuildSecondExperimental = 37
refActionLoadOntoTransport = 38
refActionFortifyFirebase = 39
refActionAssistShield = 40
refActionBuildSecondShield = 41
refActionBuildEmergencyArti = 42 --Not yet got the main code in place that M27 used, for now just have basic placeholder that builds T2 the same as a normal building
refActionAssistTML = 43
refActionBuildQuantumGateway = 44
refActionBuildQuantumOptics = 45
refActionBuildHive = 46
refActionSelenMexBuild = 47
refActionBuildSecondTMD = 48
refActionBuildNavalFactory = 49
refActionAssistNavalFactory = 50
refActionNavalSpareAction = 51
refActionBuildWall = 52
refActionBuildT3MexOnly = 53
refActionAssistMexUpgrade = 54
refActionSAMCreep = 55 --Intended to gradually expand SAM coverage for mexes
refActionBuildMassFab = 56
refActionMoveToLandZone = 57
refActionRunToLandZone = 58
refActionMoveToWaterZone = 59
refActionRunToWaterZone = 60
refActionAssistUpgrade = 61
refActionReclaimEnemyUnit = 62
refActionBuildSecondMassStorage = 63
refActionCompletePartBuiltMex = 64
refActionBuildExperimentalNavy = 65
refActionBuildGameEnder = 66
refActionBuildLandExperimental = 67 --e.g. for when building in water
refActionCaptureUnit = 68
refActionRepairUnit = 69 --e.g. can use to repair an underconstruction building
refActionSpecialShieldDefence = 70 --Covers the building of shields, but uses different approach to normal, intended for protecting a game ender from sustained T3 arti fire

--tiEngiActionsThatDontBuild = {refActionReclaimArea, refActionSpare, refActionNavalSpareAction, refActionHasNearbyEnemies, refActionReclaimFriendlyUnit, refActionReclaimTrees, refActionUpgradeBuilding, refActionAssistSMD, refActionAssistTML, refActionAssistMexUpgrade, refActionAssistAirFactory, refActionAssistNavalFactory, refActionUpgradeHQ, refActionAssistNuke, refActionLoadOntoTransport, refActionAssistShield}

tiLastBuildingSizeFromActionForTeam = {} --[x] is the team ref, [y] is the action ref, returns the building size (if there was one), used to help stop logic if we have run out of places to build

--Categories to use where no complex logic required (if it wont always be the same category then add logic to GetCategoryToBuildOrAssistFromAction
tiActionCategory = {
    [refActionBuildMex] = M28UnitInfo.refCategoryT1Mex,
    [refActionBuildHydro] = M28UnitInfo.refCategoryHydro,
    [refActionBuildPower] = M28UnitInfo.refCategoryPower,
    [refActionBuildLandFactory] = M28UnitInfo.refCategoryLandFactory,
    [refActionBuildSecondPower] = M28UnitInfo.refCategoryPower,
    [refActionBuildAirStaging] = M28UnitInfo.refCategoryAirStaging,
    [refActionBuildAirFactory] = M28UnitInfo.refCategoryAirFactory,
    [refActionBuildSecondAirFactory] = M28UnitInfo.refCategoryAirFactory,
    [refActionBuildSMD] = M28UnitInfo.refCategorySMD,
    [refActionBuildMassStorage] = M28UnitInfo.refCategoryMassStorage,
    [refActionBuildT1Radar] = M28UnitInfo.refCategoryT1Radar,
    [refActionBuildT2Radar] = M28UnitInfo.refCategoryT2Radar,
    [refActionBuildT3Radar] = M28UnitInfo.refCategoryT3Radar,
    [refActionAssistSMD] = M28UnitInfo.refCategorySMD,
    [refActionAssistAirFactory] = M28UnitInfo.refCategoryAirFactory,
    [refActionBuildEnergyStorage] = M28UnitInfo.refCategoryEnergyStorage,
    [refActionBuildThirdPower] = M28UnitInfo.refCategoryPower,
    [refActionBuildT1Sonar] = M28UnitInfo.refCategoryT1Sonar,
    [refActionBuildT2Sonar] = M28UnitInfo.refCategoryT2Sonar,
    [refActionBuildShield] = M28UnitInfo.refCategoryFixedShield,
    [refActionBuildSecondShield] = M28UnitInfo.refCategoryFixedShield,
    [refActionBuildNavalFactory] = M28UnitInfo.refCategoryNavalFactory,
    [refActionAssistNavalFactory] = M28UnitInfo.refCategoryNavalFactory,
    [refActionBuildTMD] = M28UnitInfo.refCategoryTMD,
    [refActionBuildAA] = M28UnitInfo.refCategoryStructureAA,
    --refActionBuildEmergencyPD - will use custom code as sometimes want T1 PD
    [refActionBuildEmergencyArti] = M28UnitInfo.refCategoryFixedT2Arti,
    [refActionBuildQuantumGateway] = M28UnitInfo.refCategoryQuantumGateway,
    [refActionBuildSecondLandFactory] = M28UnitInfo.refCategoryLandFactory,
    [refActionBuildTML] = M28UnitInfo.refCategoryTML,
    [refActionAssistShield] = M28UnitInfo.refCategoryFixedShield * categories.TECH3,
    [refActionBuildSecondMassStorage] = M28UnitInfo.refCategoryMassStorage,
    [refActionCompletePartBuiltMex] = M28UnitInfo.refCategoryT1Mex,
    [refActionBuildExperimentalNavy] = categories.NAVAL * categories.EXPERIMENTAL - categories.UNSELECTABLE - categories.UNTARGETABLE,
    [refActionBuildGameEnder] = M28UnitInfo.refCategoryGameEnder,
    [refActionBuildLandExperimental] = M28UnitInfo.refCategoryLandExperimental,
}

tiActionOrder = {
    [refActionBuildMex] = M28Orders.refiOrderIssueBuild,
    [refActionBuildHydro] = M28Orders.refiOrderIssueBuild,
    [refActionBuildPower] = M28Orders.refiOrderIssueBuild,
    [refActionBuildLandFactory] = M28Orders.refiOrderIssueBuild,
    [refActionBuildSecondPower] = M28Orders.refiOrderIssueBuild,
    [refActionBuildAirStaging] = M28Orders.refiOrderIssueBuild,
    [refActionBuildAirFactory] = M28Orders.refiOrderIssueBuild,
    [refActionBuildSecondAirFactory] = M28Orders.refiOrderIssueBuild,
    [refActionBuildEnergyStorage] = M28Orders.refiOrderIssueBuild,
    [refActionMoveToLandZone] = M28Orders.refiOrderIssueMove,
    [refActionRunToLandZone] = M28Orders.refiOrderIssueMove,
    [refActionMoveToWaterZone] = M28Orders.refiOrderIssueMove,
    [refActionRunToWaterZone] = M28Orders.refiOrderIssueMove,
    [refActionReclaimFriendlyUnit] = M28Orders.refiOrderIssueReclaim,
    [refActionAssistUpgrade] = M28Orders.refiOrderIssueGuard,
    [refActionAssistAirFactory] = M28Orders.refiOrderIssueGuard,
    [refActionBuildSMD] = M28Orders.refiOrderIssueBuild,
    [refActionBuildMassStorage] = M28Orders.refiOrderIssueBuild,
    [refActionBuildT1Radar] = M28Orders.refiOrderIssueBuild,
    [refActionBuildT2Radar] = M28Orders.refiOrderIssueBuild,
    [refActionBuildT3Radar] = M28Orders.refiOrderIssueBuild,
    [refActionAssistSMD] = M28Orders.refiOrderIssueGuard,
    [refActionBuildThirdPower] = M28Orders.refiOrderIssueBuild,
    [refActionBuildExperimental] = M28Orders.refiOrderIssueBuild,
    [refActionBuildSecondExperimental] = M28Orders.refiOrderIssueBuild,
    [refActionReclaimArea] = M28Orders.refiOrderIssueReclaim,--will actually have a move order followed by reclaim order
    [refActionBuildT1Sonar] = M28Orders.refiOrderIssueBuild,
    [refActionBuildT2Sonar] = M28Orders.refiOrderIssueBuild,
    [refActionBuildShield] = M28Orders.refiOrderIssueBuild,
    [refActionBuildSecondShield] = M28Orders.refiOrderIssueBuild,
    [refActionBuildNavalFactory] = M28Orders.refiOrderIssueBuild,
    [refActionAssistNavalFactory] = M28Orders.refiOrderIssueGuard,
    [refActionBuildTMD] = M28Orders.refiOrderIssueBuild,
    [refActionBuildAA] = M28Orders.refiOrderIssueBuild,
    [refActionBuildEmergencyPD] = M28Orders.refiOrderIssueBuild,
    [refActionBuildEmergencyArti] = M28Orders.refiOrderIssueBuild,
    [refActionBuildQuantumGateway] = M28Orders.refiOrderIssueBuild,
    [refActionBuildSecondLandFactory] = M28Orders.refiOrderIssueBuild,
    [refActionBuildTML] = M28Orders.refiOrderIssueBuild,
    [refActionLoadOntoTransport] = M28Orders.refiOrderLoadOntoTransport,
    [refActionAssistShield] = M28Orders.refiOrderIssueGuard,
    [refActionReclaimEnemyUnit] = M28Orders.refiOrderIssueReclaim,
    [refActionBuildSecondMassStorage] = M28Orders.refiOrderIssueBuild,
    [refActionCompletePartBuiltMex] = M28Orders.refiOrderIssueBuild,
    [refActionBuildExperimentalNavy] = M28Orders.refiOrderIssueBuild,
    [refActionBuildGameEnder] = M28Orders.refiOrderIssueBuild,
    [refActionBuildLandExperimental] = M28Orders.refiOrderIssueBuild,
    [refActionCaptureUnit] = M28Orders.refiOrderIssueCapture,
    [refActionRepairUnit] = M28Orders.refiOrderIssueRepair,
    [refActionSpecialShieldDefence] = M28Orders.refiOrderIssueBuild, --Sometimes will want to be idle
}

--Adjacent categories to search for for a particular action
tiActionAdjacentCategory = {
    [refActionBuildPower] = M28UnitInfo.refCategoryAirFactory * categories.TECH3 + M28UnitInfo.refCategoryAirFactory * categories.TECH2 + M28UnitInfo.refCategoryT3Radar + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategorySML + M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti * categories.UEF,
    [refActionBuildSecondPower] = M28UnitInfo.refCategoryAirFactory * categories.TECH3 + M28UnitInfo.refCategoryT3Radar + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategorySML + M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti * categories.UEF,
    [refActionBuildThirdPower] = M28UnitInfo.refCategorySML + M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti * categories.UEF,
    [refActionBuildLandFactory] = M28UnitInfo.refCategoryMex,
    [refActionBuildAirFactory] = M28UnitInfo.refCategoryT3Power + M28UnitInfo.refCategoryHydro,
    [refActionBuildSecondAirFactory] = M28UnitInfo.refCategoryT3Power + M28UnitInfo.refCategoryHydro,
    [refActionBuildSMD] = M28UnitInfo.refCategoryT3Power,
    [refActionBuildT1Radar] = M28UnitInfo.refCategoryT1Power,
    [refActionBuildT2Radar] = M28UnitInfo.refCategoryT2Power,
    [refActionBuildT3Radar] = M28UnitInfo.refCategoryT3Power,
}

--Include any actions where we wont be building a category or searching for a category to assist
--The difference between this and tiActionCategory is for buildings where we need special code to determine the category to build, such as emergency PD (T1 vs T2 vs T3)
tbActionsThatDontHaveCategory = {
    [refActionMoveToLandZone] = true,
    [refActionRunToLandZone] = true,
    [refActionMoveToWaterZone] = true,
    [refActionRunToWaterZone] = true,
    [refActionReclaimFriendlyUnit] = true,
    [refActionAssistUpgrade] = true, --need special logic to only identify upgrading units for this
    [refActionReclaimArea] = true,
    [refActionReclaimEnemyUnit] = true,
    [refActionLoadOntoTransport] = true,
    [refActionCaptureUnit] = true,
    [refActionRepairUnit] = true,
    [refActionSpecialShieldDefence] = true,
}

tbIgnoreUnderConstructionActions = { --Any actions that are building something where would by default search for an under construction building should be set to true in this table if we dont want to, e.g. if want to build a second land factory, dont want to end up repairing a factory that is upgrading to a higher tech level; similarly for mex dont want to assist an existing engineer
    [refActionBuildMex] = true,
    [refActionBuildSecondLandFactory] = true,
    [refActionBuildSecondAirFactory] = true,
    [refActionBuildSecondMassStorage] = true,
    [refActionBuildSecondPower] = true,
    [refActionBuildThirdPower] = true,
    [refActionBuildSecondExperimental] = true, --have a manual override for this where we are building t3 arti or g ameender
    [refActionBuildSecondShield] = true,
}

tbIgnoreEngineerAssistance = { --Any actions where we dont want to assist an engineer already constructiong the building should go here; main purpose is building a mex
    [refActionBuildMex] = true,
    [refActionCompletePartBuiltMex] = true,
    [refActionAssistShield] = true,
    [refActionLoadOntoTransport] = true,
}

tbActionsWithFactionSpecificLogic = { --Any actions where it is important to know what factions we have available when deciding what to build
    [refActionBuildExperimental] = true,
    [refActionBuildSecondExperimental] = true,
}




function GetEngineerUniqueCount(oEngineer)
    local iUniqueRef = oEngineer[refiEngineerCurUniqueReference]
    if iUniqueRef == nil then
        local aiBrain = oEngineer:GetAIBrain()
        iUniqueRef = aiBrain[refiEngineerCurUniqueReference] + 1
        aiBrain[refiEngineerCurUniqueReference] = iUniqueRef
        oEngineer[refiEngineerCurUniqueReference] = iUniqueRef
    end
    return iUniqueRef
end

function CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, iOptionalPlateauGroupOrZero, iOptionalLandOrWaterZone, iEngiActionToIgnore, bClearActionsIfNotStartedBuilding, bCheckForQueuedBuildings, bCheckForOverlappingBuildings, bCheckBlacklistIfNoGameEnder)
    --iOptionalPlateauGroupOrZero, iOptionalLandOrWaterZone, iEngiActionToIgnore, bClearActionsIfNotStartedBuilding and bCheckForOverlappingBuildings are optional
    --iOptionalPlateauGroupOrZero and iOptionalLandOrWaterZone: If specified, then will check this zone for queued units, if bCheckForQueuedBuildings is true
    --bCheckBlacklistIfNoGameEnder - will checkblacklist if either this is true, or the zone contains a gameender

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CanBuildAtLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if bDebugMessages == true then
        LOG(sFunctionRef..': About to see if we can build '..(sBlueprintToBuild or 'nil')..' at '..repru(tTargetLocation)..'; iEngiActionToIgnore='..(iEngiActionToIgnore or 'nil')..'; bClearActionsIfNotStartedBuilding='..tostring((bClearActionsIfNotStartedBuilding or false))..'; surface height at target='..GetSurfaceHeight(tTargetLocation[1], tTargetLocation[3])..'; aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation)='..tostring(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation)))
        if sBlueprintToBuild == 'ueb0103' then LOG(sFunctionRef..': Extra check for size 14 - can we build naval fac here? aiBrain:CanBuildStructureAt='..tostring(aiBrain:CanBuildStructureAt('xsb0103', tTargetLocation))) end
    end


    local bCanBuildStructure = false
    if aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation) == true or (EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryHydro, sBlueprintToBuild) and ((EntityCategoryContains(M28UnitInfo.refCategoryMex, sBlueprintToBuild) and M28Conditions.CanBuildOnMexLocation(tTargetLocation)) or EntityCategoryContains(M28UnitInfo.refCategoryHydro, sBlueprintToBuild) and M28Conditions.CanBuildOnHydroLocation(tTargetLocation))) then
        bCanBuildStructure = true
        if tsExtraBlueprintsToCheck[sBlueprintToBuild] then
            for iEntry, sAltBlueprint in tsExtraBlueprintsToCheck[sBlueprintToBuild] do
                if not(aiBrain:CanBuildStructureAt(sAltBlueprint, tTargetLocation)) then
                    bCanBuildStructure = false
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Passed hte basic aiBrain check of whether se can build a structure at the target location, bCheckForQueuedBuildings='..tostring(bCheckForQueuedBuildings or false)..'; bCanBuildStructure after checking alt blueprints='..tostring(bCanBuildStructure)) end
        if bCanBuildStructure then

            local iSkirtSizeRadius = __blueprints[sBlueprintToBuild].Physics.SkirtSizeX * 0.5
            if bCheckForQueuedBuildings == true then
                if iOptionalPlateauGroupOrZero and iOptionalLandOrWaterZone then
                    --local iBuildingSize = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
                    local iBuildingRadius = math.floor(M28UnitInfo.GetBuildingSize(sBlueprintToBuild) * 0.5)
                    local tLZOrWZData, tLZOrWZTeamData
                    if iOptionalPlateauGroupOrZero > 0 then
                        tLZOrWZData  = M28Map.tAllPlateaus[iOptionalPlateauGroupOrZero][M28Map.subrefPlateauLandZones][iOptionalLandOrWaterZone]
                        tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
                    else
                        --Water zone
                        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iOptionalLandOrWaterZone]][M28Map.subrefPondWaterZones][iOptionalLandOrWaterZone]
                        tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][aiBrain.M28Team]
                    end
                    if tLZOrWZData and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefQueuedBuildings]) == false then
                        local iBaseX = math.floor(tTargetLocation[1])
                        local iBaseZ = math.floor(tTargetLocation[3])
                        for iX = iBaseX - iBuildingRadius, iBaseX + iBuildingRadius, 1 do
                            if tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX] then
                                for iZ = iBaseZ - iBuildingRadius, iBaseZ + iBuildingRadius do
                                    if tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX][iZ] then
                                        bCanBuildStructure = false
                                        break
                                    end
                                end
                                if not(bCanBuildStructure) then break end
                            end
                        end
                    end
                else
                    M28Utilities.ErrorHandler('If we want to check for queued buildings then we need to specify the plateau and land zone')
                end
            end
            if bCanBuildStructure then
                --Check in case scathis is blocking us
                if M28Utilities.IsTableEmpty(tAllScathis) == false then
                    for iUnit, oUnit in tAllScathis do
                        if M28Utilities.GetDistanceBetweenPositions(tTargetLocation, oUnit:GetPosition()) < (iSkirtSizeRadius + oUnit:GetBlueprint().Physics.SkirtSizeX * 0.5) then
                            bCanBuildStructure = false
                            if bDebugMessages == true then LOG(sFunctionRef..': Are too close to a scathis so wont build here') end
                            break
                        end
                    end
                end

                if bCanBuildStructure and bCheckForOverlappingBuildings then

                    --Thanks to jip for flagging there's an engine bug where in rare situations units can be built slightly overlapping even if aiBrain:CanBuildStructureAt returns true - comments in the code Jip linked to suggested this is only where a building has upgraded
                    -- compute build locations and issue the capping

                    -- find all units that may prevent us from building
                    local tNearbyStructures = GetUnitsInRect(tTargetLocation[1] - (iSkirtSizeRadius + 4), tTargetLocation[3] - (iSkirtSizeRadius + 4), tTargetLocation[1] + (iSkirtSizeRadius + 4), tTargetLocation[3] + (iSkirtSizeRadius + 4))
                    if M28Utilities.IsTableEmpty(tNearbyStructures) == false then
                        tNearbyStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryUpgraded, tNearbyStructures)
                        local iClosestDistance
                        if M28Utilities.IsTableEmpty(tNearbyStructures) == false then
                            for iStructure, oStructure in tNearbyStructures do
                                if not(oStructure.Dead) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': oStructure='..oStructure.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStructure)..'; position='..repru(oStructure:GetPosition())..'; target location='..repru(tTargetLocation)..'; target building ID='..sBlueprintToBuild..'; 50% of target building skirt size='..iSkirtSizeRadius..'; 50% of oStructure skrit size='..oStructure:GetBlueprint().Physics.SkirtSizeX * 0.5) end
                                    iClosestDistance = math.max(math.abs(oStructure:GetPosition()[1] - tTargetLocation[1]), math.abs(oStructure:GetPosition()[3] - tTargetLocation[3]))
                                    if iClosestDistance < (iSkirtSizeRadius + oStructure:GetBlueprint().Physics.SkirtSizeX * 0.5) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Cant build as iClosestDistance='..iClosestDistance..'which is less than the two skirt sizes') end
                                        bCanBuildStructure = false
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
                if not(bCanBuildStructure) and bDebugMessages == true then LOG(sFunctionRef..': Skirt size is overlaping with a building that could have upgraded so will return false') end
            end
            if bCanBuildStructure and (bCheckBlacklistIfNoGameEnder or M28Team.tTeamData[aiBrain.M28Team][M28Team.refbStartedOnUnitWantingSpecialShielding]) then
                local iPlateau = iOptionalPlateauGroupOrZero
                local iLandZone = iOptionalLandOrWaterZone
                if not(iOptionalLandOrWaterZone) or not(iOptionalPlateauGroupOrZero) then
                    iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                end
                local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                if tLZData[M28Map.subrefBuildLocationBlacklistByPosition][math.floor(tTargetLocation[1])][math.floor(tTargetLocation[3])] then
                    bCanBuildStructure = false
                end
                --Old blacklist approach (commented out)
                --[[if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefBuildLocationBlacklistByPosition]) == false then
                    for iEntry, tBlacklistData in tLZData[M28Map.subrefBuildLocationBlacklist] do
                        local iDistThreshold = tLZData[M28Map.subrefBuildLocationBlacklist][table.getn(tLZData[M28Map.subrefBuildLocationBlacklist])][M28Map.subrefBlacklistSize] + iSkirtSizeRadius
                        if math.abs(tTargetLocation[1] - tBlacklistData[M28Map.subrefBlacklistLocation][1]) <= iDistThreshold and math.abs(tTargetLocation[3] - tBlacklistData[M28Map.subrefBlacklistLocation][3]) <= iDistThreshold then
                            return false
                        end

                    end
                end--]]
            end
        elseif bDebugMessages == true then LOG(sFunctionRef..': If try same size building with different skirt offsets then cant build here')
        end
    elseif bDebugMessages == true then LOG(sFunctionRef..': Cant build structure at the location')
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bCanBuildStructure='..tostring(bCanBuildStructure)) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bCanBuildStructure
end

function CheckIfBuildableLocationsNearPositionStillValid(aiBrain, tLocation, bCheckLastBlacklistEntry, iBuildingRadius)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckIfBuildableLocationsNearPositionStillValid'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Check if the locations near tLocation are still valid - e.g. usually called if we have just built a unit (so unlikely to be valid) or have identified a blacklist location

    if not(aiBrain.M28IsDefeated) then
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tLocation)
        local tLZOrWZData, sBlueprintSizeRef
        if (iLandOrWaterZone or 0) == 0 then
            iLandOrWaterZone = M28Map.GetWaterZoneFromPosition(tLocation)
            if iLandOrWaterZone > 0 then
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                sBlueprintSizeRef = tsWZBlueprintsBySize
                iPlateauOrZero = 0
            end
        else
            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
            sBlueprintSizeRef = tsBlueprintsBySize
        end
        if (iLandOrWaterZone or 0) > 0 then
            local iBaseSegmentX, iBaseSegmentZ = M28Map.GetPathingSegmentFromPosition(tLocation)
            local iAffectedDistanceRadius = iBuildingRadius + iMaxBuildingSize * 0.5
            if bDebugMessages == true then LOG(sFunctionRef..': Want to see if existing build locations are still valid, iAffectedDistanceRadius='..iAffectedDistanceRadius..'; iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Buildable locations before update for size 8=='..(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][8] or 'nil')) end
            CheckIfSegmentsStillBuildable(aiBrain, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, iBaseSegmentX, iBaseSegmentZ, iAffectedDistanceRadius, bCheckLastBlacklistEntry)

            --Search for more building locations for every building where we havent considered the full amount if we havent considered any this cycle
            local iTotalSegmentCount, sBlueprintSizeRef
            if iPlateauOrZero == 0 then
                iTotalSegmentCount = table.getn(tLZOrWZData[M28Map.subrefWZSegments])
                sBlueprintSizeRef = tsWZBlueprintsBySize

            else
                iTotalSegmentCount = tLZOrWZData[M28Map.subrefLZTotalSegmentCount]
                sBlueprintSizeRef = tsBlueprintsBySize
            end
            if (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iBuildingRadius * 2] or 0) <= 10 then
                if (tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] or 0) <= 20 then
                    SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, 10)
                end
            end

            --Update mass storage locations (relevant only for land zones)
            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZMassStorageLocationsAvailable]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': About to update mass storage locations for iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..', tLZOrWZData[M28Map.subrefLZMassStorageLocationsAvailable]='..repru(tLZOrWZData[M28Map.subrefLZMassStorageLocationsAvailable])..'; Nickname of first aiBrain='..M28Overseer.tAllActiveM28Brains[1].Nickname) end
                local aiBrain = M28Overseer.tAllActiveM28Brains[1]
                local function WantToKeep(tArray, iEntry, aiBrain)
                    return aiBrain:CanBuildStructureAt('ueb1106', tArray[iEntry])
                end

                local iRevisedIndex = 1
                local iTableSize = table.getn(tLZOrWZData[M28Map.subrefLZMassStorageLocationsAvailable])

                for iOrigIndex=1, iTableSize do
                    if tLZOrWZData[M28Map.subrefLZMassStorageLocationsAvailable][iOrigIndex] then --Needed as sometimes the last entry is nil
                        if aiBrain.CanBuildStructureAt and aiBrain:CanBuildStructureAt('ueb1106', tLZOrWZData[M28Map.subrefLZMassStorageLocationsAvailable][iOrigIndex]) then
                            --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                            if (iOrigIndex ~= iRevisedIndex) then
                                tLZOrWZData[M28Map.subrefLZMassStorageLocationsAvailable][iRevisedIndex] = tLZOrWZData[M28Map.subrefLZMassStorageLocationsAvailable][iOrigIndex];
                                tLZOrWZData[M28Map.subrefLZMassStorageLocationsAvailable][iOrigIndex] = nil;
                            end
                            iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                        else
                            tLZOrWZData[M28Map.subrefLZMassStorageLocationsAvailable][iOrigIndex] = nil;
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function FindBuildableLocationsForSegment(aiBrain, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, iSegmentX, iSegmentZ)
    --Use if e.g. a building has died nearby and this may now have a greater build range
    --First get a blueprint of the same size (or just use htis if this is a different size)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'FindBuildableLocationsForSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local sBlueprintTable
    if iPlateauOrZero == 0 then sBlueprintTable = tsWZBlueprintsBySize
    else sBlueprintTable = tsBlueprintsBySize
    end
    local tCurPosition = M28Map.GetPositionFromPathingSegments(iSegmentX, iSegmentZ)
    local iHighestCurSize = (tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] or 0)
    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, Time='..GetGameTimeSeconds()..'; Brain='..aiBrain.Nickname..'; iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; iSegmentX='..iSegmentX..'; iSegmentZ='..iSegmentZ..'; iHighestCurSize='..iHighestCurSize) end
    if iHighestCurSize < iMaxBuildingSize then
        for iSize, sGenericBlueprint in sBlueprintTable do

            if iSize > iHighestCurSize then
                --CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, iOptionalPlateauGroupOrZero, iOptionalLandOrWaterZone, iEngiActionToIgnore, bClearActionsIfNotStartedBuilding, bCheckForQueuedBuildings, bCheckForOverlappingBuildings, bCheckBlacklistIfNoGameEnder)
                if CanBuildAtLocation(aiBrain, sGenericBlueprint, tCurPosition,     iPlateauOrZero,             iLandOrWaterZone,           nil,                false,                              false,                  false,                          true) then
                    if not(tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX]) then
                        if not(tLZOrWZData[M28Map.subrefBuildableSizeBySegment]) then tLZOrWZData[M28Map.subrefBuildableSizeBySegment] = {} end
                        tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX] = {}
                    end
                    tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] = iSize
                    if not(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize][iSegmentX][iSegmentZ]) then
                        if not(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize][iSegmentX]) then
                            if not(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize]) then
                                if not(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment]) then
                                    tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment] = {}
                                end
                                tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize] = {}
                            end
                            tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize][iSegmentX] = {}
                        end
                        --Record the count of how many buildable locations we have for this size
                        tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize][iSegmentX][iSegmentZ] = true
                        if not(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]) then
                            if not(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize]) then tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize] = {} end
                            tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] = 1
                            if bDebugMessages == true then LOG(sFunctionRef..': No size previously recorded for iPlateau'..iPlateauOrZero..'Zone '..iLandOrWaterZone..' and size '..iSize..'; recording 1 as we can build at segmentX'..iSegmentX..'Z'..iSegmentZ..'; tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]='..tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]) end
                        else
                            tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] = tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] + 1
                            if bDebugMessages == true then LOG(sFunctionRef..': Increasing the number of entries by 1 for iPlateau'..iPlateauOrZero..'Zone '..iLandOrWaterZone..' and size '..iSize..'; count='..tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]..'as we can build at segmentX'..iSegmentX..'Z'..iSegmentZ) end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Can build at location '..repru(tCurPosition)..' for iSize='..(iSize or 'nil')..'; LZ midpoint='..repru(tLZOrWZData[M28Map.subrefMidpoint])..'; tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]='..(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 'nil')) end
                else
                    --If we cant build this then we cant build anything larger either
                    if bDebugMessages == true then LOG(sFunctionRef..': We cant build at position '..repru(tCurPosition)..' for size '..iSize) end
                    break
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize]='..repru(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize])) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckIfSegmentsStillBuildable(aiBrain, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, iBaseSegmentX, iBaseSegmentZ, iAffectedDistanceRadius, bCheckBlacklistIfNoGameEnder)
    --Use if e.g. a building has just started construction meaning we likely cant build nearby
    --First get a blueprint of the same size (or just use htis if this is a different size)
    --bCheckBlacklistIfNoGameEnder - if true then will check to the blacklist; if false then won't check unless there is a gameender in the zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckIfSegmentsStillBuildable'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iSegmentSearchSize = math.ceil(iAffectedDistanceRadius + iMaxBuildingSize * 0.5 / M28Map.iLandZoneSegmentSize)
    local sBlueprintTable
    if iPlateauOrZero == 0 then sBlueprintTable = tsWZBlueprintsBySize
    else sBlueprintTable = tsBlueprintsBySize
    end
    local iLastValidSize
    local GetPositionFromPathingSegments = M28Map.GetPositionFromPathingSegments
    if bDebugMessages == true then LOG(sFunctionRef..': About to search from SegmentX='..math.max(1, iBaseSegmentX - iSegmentSearchSize)..' to '..math.min(iBaseSegmentX + iSegmentSearchSize, M28Map.iMaxLandSegmentX)..' and Z='..math.max(1, iBaseSegmentZ - iSegmentSearchSize)..' to '..math.min(iBaseSegmentZ + iSegmentSearchSize, M28Map.iMaxLandSegmentZ)) end
    for iSegmentX = math.max(1, iBaseSegmentX - iSegmentSearchSize), math.min(iBaseSegmentX + iSegmentSearchSize, M28Map.iMaxLandSegmentX), 1 do
        for iSegmentZ = math.max(1, iBaseSegmentZ - iSegmentSearchSize), math.min(iBaseSegmentZ + iSegmentSearchSize, M28Map.iMaxLandSegmentZ), 1 do
            if bDebugMessages == true then LOG(sFunctionRef..': iCurSegmentX='..iSegmentX..'Z'..iSegmentZ..'; Buildable size='..(tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] or 0)) end
            if (tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] or 0) > 0 then
                iLastValidSize = nil
                for iSize, sBlueprint in sBlueprintTable do
                    if iSize > (tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] or 0) then
                        break
                    else
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Checking if buildable for iSegmentX='..iSegmentX..'; iSegmentZ='..iSegmentZ..'; iSize='..iSize..'; iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; bCheckBlacklistIfNoGameEnder='..tostring(bCheckBlacklistIfNoGameEnder)..'; Can build here='..tostring(CanBuildAtLocation(aiBrain, sBlueprint, GetPositionFromPathingSegments(iSegmentX, iSegmentZ),     iPlateauOrZero,             iLandOrWaterZone,           nil,                false,                              false,                  false,                          bCheckBlacklistIfNoGameEnder)))
                            --T3 pgen size - show buildable in blue nonbuildable in red
                            if iSize == 8 then
                                local bCanBuild = CanBuildAtLocation(aiBrain, sBlueprint, GetPositionFromPathingSegments(iSegmentX, iSegmentZ),     iPlateauOrZero,             iLandOrWaterZone,           nil,                false,                              false,                  false,                          bCheckBlacklistIfNoGameEnder)
                                if bCanBuild then M28Utilities.DrawLocation(GetPositionFromPathingSegments(iSegmentX, iSegmentZ), 1)
                                else
                                    M28Utilities.DrawLocation(GetPositionFromPathingSegments(iSegmentX, iSegmentZ), 2)
                                end
                            end
                        end
                        if CanBuildAtLocation(aiBrain, sBlueprint, GetPositionFromPathingSegments(iSegmentX, iSegmentZ),     iPlateauOrZero,             iLandOrWaterZone,           nil,                false,                              false,                  false,                          bCheckBlacklistIfNoGameEnder) then
                            --No change needed, location is still valid
                            iLastValidSize = iSize
                        else
                            --Cant build anymore, remove this and any subsequent locations
                            for iRemoveSize, sBlueprint in sBlueprintTable do
                                if iRemoveSize > iLastValidSize then
                                    if tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iRemoveSize][iSegmentX][iSegmentZ] then
                                        tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iRemoveSize][iSegmentX][iSegmentZ] = nil
                                        tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iRemoveSize] = math.max(0, (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iRemoveSize] or 1) - 1)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Just removed recording segmentX'..iSegmentX..'Z'..iSegmentZ..' from being buildable in plateau '..iPlateauOrZero..' Zone '..iLandOrWaterZone..', count by size for this zone for iRemoveSIze '..iRemoveSize..' and iSize='..iSize..'='..tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iRemoveSize]) end
                                    end
                                end
                            end
                            tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] = iLastValidSize
                            if bDebugMessages == true then LOG(sFunctionRef..': Finished removing buildable entries, tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ]='..(tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] or 'nil')..'; tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][8][iSegmentX][iSegmentZ]='..tostring(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][8][iSegmentX][iSegmentZ] or false)..'; iLastValidSize='..(iLastValidSize or 'nil')) end
                            break
                        end
                    end
                end
            end
        end
    end
    if tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][2] <= 0 and tLZOrWZData[M28Map.subrefLZTotalSegmentCount] >= 50 and GetGameTimeSeconds() >= 60 then
        M28Utilities.ErrorHandler('Dont have any locations that even a 2x2 building in P'..(iPlateauOrZero or 'nil')..'Z'..(iLandOrWaterZone or 'nil')..' can build in so likely something has gone wrong, will refresh the build count')
        LOG('Count by size before update='..repru(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize]))
        local iCurCount
        for iSize, sBlueprint in sBlueprintTable do
            iCurCount = 0

            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize]) == false then
                for iSegmentX, tSubtable in tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize] do
                    for iSegmentZ, bValid in tSubtable do
                        iCurCount = iCurCount + 1
                    end
                end
            end
            tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] = iCurCount
        end
        LOG('Count by size after update='..repru(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize]))
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iOptionalMaxSegmentsToConsider)
    --Updates the plateau with a general buildable locations (if there are any) for iLandOrWaterZone
    --Will treat locations immediately adjacent to mexes as being unbuildable, to avoid taking up mass storage positions
    --iOptionalMaxSegmentsToConsider - will stop searching if reach this number of segments
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SearchForBuildableLocationsForLandOrWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tLZOrWZData
    local iSegmentRef
    if iPlateauOrZero == 0 then
        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        iSegmentRef = M28Map.subrefWZSegments
    else
        tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        iSegmentRef = M28Map.subrefLZSegments
    end
    if not(tLZOrWZData) then
        M28Utilities.ErrorHandler('Dont have valid zone, iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil'))
    else
        local iSegmentsToConsider
        if (tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] or 0) >= 50 and GetGameTimeSeconds() >= 60 then
            if not(iOptionalMaxSegmentsToConsider) then iSegmentsToConsider = 3
            else iSegmentsToConsider = math.min(5, iOptionalMaxSegmentsToConsider)
            end
        else
            if M28Overseer.refiRoughTotalUnitsInGame >= 500 then
                iSegmentsToConsider = math.max((iOptionalMaxSegmentsToConsider or 0), 20)
            else
                iSegmentsToConsider = math.max((iOptionalMaxSegmentsToConsider or 0), 50)
            end
        end

        local iTotalSegments = table.getn(tLZOrWZData[iSegmentRef])
        local iSegmentStart = (tLZOrWZData[M28Map.subrefiLastSegmentEntryConsideredForBuilding] or 0) + 1
        if iSegmentStart > iTotalSegments then iSegmentStart = 1 end
        local tSegmentXZ
        local iSegmentEnd = math.min(iTotalSegments, iSegmentStart + iSegmentsToConsider)

        --Cycle through every segment in the land/water zone and see if we can build the desired unit at the segment midpoint
        if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through each segment to check for buildable locations. iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; iOptionalMaxSegmentsToConsider='..(iOptionalMaxSegmentsToConsider or 'nil')..'; iSegmentStart='..iSegmentStart..'; iTotalSegments='..iTotalSegments..'; iSegmentEnd='..iSegmentEnd) end
        for iSegmentCount = iSegmentStart, iSegmentEnd do
            tSegmentXZ = tLZOrWZData[iSegmentRef][iSegmentCount]
            FindBuildableLocationsForSegment(aiBrain, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tSegmentXZ[1], tSegmentXZ[2])
            tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] = (tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] or 0) + 1
        end
        tLZOrWZData[M28Map.subrefiLastSegmentEntryConsideredForBuilding] = iSegmentEnd
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of c ode, LZOrWZData[subrefBuildLocationSegmentCountBySize]='..repru(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize] or {'nil'})..'; tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick]='..(tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetPotentialBuildLocationsNearLocation(aiBrain, tLZOrWZData, iPlateauOrZero, iLandOrWaterZone, iSize)
    --Returns a table of potentail build locations (if there are any) for iSize building in the zone in question
    --If there aren't many build locations then will try searching for more

    if (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 0) < 10 then
        --SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iOptionalMaxSegmentsToConsider)
        SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, nil)
    end
    if (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 0) > 0 then

        local tPotentialLocations = {}
        local GetPositionFromPathingSegments = M28Map.GetPositionFromPathingSegments
        local iCycleSize = 1
        if (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 0) >= 50 then
            iCycleSize = math.ceil((tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 0) / 40)
        end
        local iCurCount = 0
        for iSegmentX, tSubtable in tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize] do
            for iSegmentZ, bInclude in tSubtable do
                iCurCount = iCurCount + 1
                if iCurCount < iCycleSize then
                    iCurCount = iCurCount + 1
                else
                    table.insert(tPotentialLocations, GetPositionFromPathingSegments(iSegmentX, iSegmentZ))
                    iCurCount = 0
                end
            end
        end
        return tPotentialLocations
    end
end

function SearchForBuildableLocationsNearTarget(aiBrain, tLZOrWZData, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, iBaseSegmentX, iBaseSegmentZ, iAffectedDistanceRadius)
    local iDistanceSearchSize = math.max(iAffectedDistanceRadius, 8)
    --local iSegmentSearchSize = math.ceil(iAffectedDistanceRadius + iMaxBuildingSize * 0.5 / M28Map.iLandZoneSegmentSize)
    iSegmentSearchSize = math.ceil(iDistanceSearchSize / M28Map.iLandZoneSegmentSize)
    for iSegmentX = math.max(1, iBaseSegmentX - iSegmentSearchSize), math.min(iBaseSegmentX + iSegmentSearchSize, M28Map.iMaxLandSegmentX), 1 do
        for iSegmentZ = math.max(1, iBaseSegmentZ - iSegmentSearchSize), math.min(iBaseSegmentZ + iSegmentSearchSize, M28Map.iMaxLandSegmentZ), 1 do
            FindBuildableLocationsForSegment(aiBrain, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, iSegmentX, iSegmentZ)
        end
    end
end

function SearchForBuildableLocationsNearDestroyedBuilding(oDestroyedBuilding)
    --Searhces all segments around oDestroyedBuilding in the same land zone, and if we can build in them for a particular size, then records that location as a buildable location for that size for the land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SearchForBuildableLocationsNearDestroyedBuilding'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Cant fork thread as causes error, and need to wait a few seconds for death animation to take effect
    table.insert(tRecentlyDestroyedBuildings, {[subrefDestroyedBuildingBlueprint] = oDestroyedBuilding.UnitId, [subrefDestroyedBuildingLocation] = {oDestroyedBuilding:GetPosition()[1], oDestroyedBuilding:GetPosition()[2], oDestroyedBuilding:GetPosition()[3]}, [subrefDestroyedBuildingTime] = GetGameTimeSeconds()})
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetPotentialAdjacencyLocations(aiBrain, sBlueprintToBuild, tTargetLocation, iMaxAreaToSearch, iCatToBuildBy, oUnitToBuildBy, bStopWhenHaveValidLocation)
    --Returns a table of all locations that are valid buildable locations for sBlueprintToBuild where it will benefit from an adjacencybonus with iCatToBuildBy or oUnitToBuildBy
    --bStopWhenHaveValidLocation - if we are happy to get the first result then this will abort as soon as a valid location is found
    --Returns {} if no valid locations can be found
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPotentialAdjacencyLocations'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tPotentialLocations = {}
    local toPossibleBuildingsToBuildBy = {}
    local iPlateauOrZero, iLandOrWaterZone --Values are set if we have a cat to build by (but need here as refer to again later on)
    local iWaterZone, iPond, sAlliedUnitRef
    local tLZOrWZTeamData
    local tLZOrWZData


    if bDebugMessages == true then LOG(sFunctionRef..': sBLueprintToBuild='..(sBlueprintToBuild or 'nil')..'; tTargetLocation='..repru(tTargetLocation)..'; iMaxAreaToSearch='..iMaxAreaToSearch..'; Is iCatToBuildBy empty='..tostring(iCatToBuildBy == nil)..'; is oUnitToBuildBy empty='..tostring(oUnitToBuildBy == nil)..'; bStopWhenHaveValidLocation='..tostring(bStopWhenHaveValidLocation or false)) end

    if iCatToBuildBy then
        --sBlueprintBuildBy = M28FactoryOverseer.GetBlueprintThatCanBuildOfCategory(aiBrain, iCatToBuildBy, oEngineer)--, false, false)
        iPlateauOrZero, iLandOrWaterZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
        if (iLandOrWaterZone or 0) == 0 then
            iWaterZone = M28Map.GetWaterZoneFromPosition(tTargetLocation)
            iPond = M28Map.tiPondByWaterZone[iWaterZone]
            if iWaterZone > 0 and iPond > 0 then
                iPlateauOrZero = 0
                tLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][aiBrain.M28Team]
                sAlliedUnitRef = M28Map.subrefWZTAlliedUnits
                iLandOrWaterZone = iWaterZone
            end
        else
            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
            tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
            sAlliedUnitRef = M28Map.subrefLZTAlliedUnits
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Have a cat to build by, tTargetLocation='..repru(tTargetLocation)..'; iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Is table of allied units in this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[sAlliedUnitRef]))) end

        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[sAlliedUnitRef]) == false then --Note - LZ and WZ refs use the same reference
            if bDebugMessages == true then LOG(sFunctionRef..': Size of tLZOrWZTeamData[sAlliedUnitRef]='..table.getn(tLZOrWZTeamData[sAlliedUnitRef])..'; iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone) end
            local tRelevantBuildingsInSameLandZone = EntityCategoryFilterDown(iCatToBuildBy, tLZOrWZTeamData[sAlliedUnitRef])
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of releevant buildings empty='..tostring(M28Utilities.IsTableEmpty(tRelevantBuildingsInSameLandZone))) end
            if M28Utilities.IsTableEmpty(tRelevantBuildingsInSameLandZone) == false then
                for iUnit, oUnit in tRelevantBuildingsInSameLandZone do
                    if oUnit:GetAIBrain() == aiBrain then
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering distance between unit of category wanted for adjacency and target location, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Dist='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation)..'; Position='..repru(oUnit:GetPosition())) end
                        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation) <= iMaxAreaToSearch then
                            table.insert(toPossibleBuildingsToBuildBy, oUnit)
                        end
                    end
                end
            end
        end
    elseif oUnitToBuildBy and not(oUnitToBuildBy.Dead) then
        --sBlueprintBuildBy = oUnitToBuildBy.UnitId
        toPossibleBuildingsToBuildBy = {oUnitToBuildBy}
    else M28Utilities.ErrorHandler('No adjacency category or unit specified')
    end

    local bAbort = false
    local iNewBuildingRadius = M28UnitInfo.GetBuildingSize(sBlueprintToBuild) * 0.5
    local iValidLocationCount = 0
    local iValidBuildingCount = 0
    local bHaveValidLocation = false
    local function AddAdjacencyLocationsToPotentialLocations(tAdjacencyBuildingPosition, iAdjacencyBuildingRadius, iNewBuildingRadius)
        local iCurZ, iCurX
        local iCycleSize = math.abs(iAdjacencyBuildingRadius - iNewBuildingRadius)
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tAdjacencyBuildingPosition)
        if iPlateauOrZero > 0 then
            if (iLandOrWaterZone or 0) == 0 then
                iLandOrWaterZone = M28Map.GetWaterZoneFromPosition(tAdjacencyBuildingPosition)
                if iLandOrWaterZone > 0 then
                    iPlateauOrZero = 0
                end
            end
            if iLandOrWaterZone > 0 then
                bHaveValidLocation = false
                if bDebugMessages == true then LOG(sFunctionRef..': tAdjacencyBuildingPosition='..repru(tAdjacencyBuildingPosition)..'; iAdjacencyBuildingRadius='..iAdjacencyBuildingRadius..'; iNewBuildingRadius='..iNewBuildingRadius..'; iCycleSize='..iCycleSize) end

                --First go along top and bottom:
                for iZFactor = -1, 1, 2 do
                    iCurZ = tAdjacencyBuildingPosition[3] + (iAdjacencyBuildingRadius + iNewBuildingRadius) * iZFactor
                    for iCurX = tAdjacencyBuildingPosition[1] - iCycleSize, tAdjacencyBuildingPosition[1] + iCycleSize, 1 do
                        if CanBuildAtLocation(aiBrain, sBlueprintToBuild, { iCurX, 0, iCurZ}, iPlateauOrZero, iLandOrWaterZone, nil, false, true, false, true) then
                            table.insert(tPotentialLocations, {iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ})
                            if bStopWhenHaveValidLocation then bAbort = true break end
                            iValidLocationCount = iValidLocationCount + 1
                            bHaveValidLocation = true
                        end
                    end
                    if bAbort then break end
                end

                --Next go along the sides:
                if not(bAbort) then
                    for iXFactor = -1, 1, 2 do
                        iCurX = tAdjacencyBuildingPosition[1] + (iAdjacencyBuildingRadius + iNewBuildingRadius) * iXFactor
                        for iCurZ = tAdjacencyBuildingPosition[3] - iCycleSize, tAdjacencyBuildingPosition[3] + iCycleSize, 1 do
                            if CanBuildAtLocation(aiBrain, sBlueprintToBuild, { iCurX, 0, iCurZ}, iPlateauOrZero, iLandOrWaterZone, nil, false, true, false, true) then
                                table.insert(tPotentialLocations, {iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ})
                                if bStopWhenHaveValidLocation then bAbort = true break end
                                iValidLocationCount = iValidLocationCount + 1
                                bHaveValidLocation = true
                            end
                        end
                        if bAbort then break end
                    end
                end
            end
        end
    end


    if M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Have possible buildings to build by, so will consider best location') end
        local iAdjacencyBuildingRadius
        for iBuilding, oBuilding in toPossibleBuildingsToBuildBy do
            iAdjacencyBuildingRadius = M28UnitInfo.GetBuildingSize(oBuilding.UnitId) * 0.5
            AddAdjacencyLocationsToPotentialLocations(oBuilding:GetPosition(), iAdjacencyBuildingRadius, iNewBuildingRadius)
            if bHaveValidLocation then
                iValidBuildingCount = iValidBuildingCount + 1
                if iValidBuildingCount >= 3 and iValidLocationCount >= 3 then break end
            end
            if bAbort then break end
        end
    else
        --No nearby buildings of the desired kind - if we want to build BY a mex or hydro then consider unbuilt resource locations, unless we are bulding in a water zone
        if iLandOrWaterZone > 0 then
            local tResourceLocations
            local iAdjacencyBuildingRadius
            if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryMex, iCatToBuildBy, false) then
                tResourceLocations = (tLZOrWZData[M28Map.subrefLZMexLocations] or tLZOrWZData[M28Map.subrefWZMexLocations])
                iAdjacencyBuildingRadius = 1
                if bDebugMessages == true then LOG(sFunctionRef..': Want to build by a mex so recording tResourceLocations based on iPlateauOrZero='..(iPlateauOrZero or 'nil')..' and iLandOrWaterZone='..(iLandOrWaterZone or 'nil')) end
            elseif M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryHydro, iCatToBuildBy, false) then
                tResourceLocations = tLZOrWZData[M28Map.subrefHydroLocations] --we use the same variable for land and water zones
                iAdjacencyBuildingRadius = 3
            end
            if tResourceLocations then
                for iCurResource, tCurResource in tResourceLocations do
                    AddAdjacencyLocationsToPotentialLocations(tCurResource, iAdjacencyBuildingRadius, iNewBuildingRadius)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tPotentialLocations
end

function DrawBlacklistedLocations(tLZData)
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefBuildLocationBlacklistByPosition]) == false then
        for iX, tZ in tLZData[M28Map.subrefBuildLocationBlacklistByPosition] do
            for iZ, bTrue in tZ do
                M28Utilities.DrawLocation({iX, GetSurfaceHeight(iX, iZ), iZ}, 2)
            end
        end
        --Old blacklist approach:
        --[[for iEntry, tBlacklistData in tLZData[M28Map.subrefBuildLocationBlacklist] do
        M28Utilities.DrawLocation(tBlacklistData[M28Map.subrefBlacklistLocation], 2, nil, tBlacklistData[M28Map.subrefBlacklistSize] * 2)
    end--]]
    end
end

function DrawBuildableLocations(tLZOrWZData, iSize)
    LOG('DrawBuildableLocations: Is table of build locations for iSize'..(iSize or 'nil')..'empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize]))..'; buildable location count='..(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 'nil'))
    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize]) == false then
        for iSegmentX, tSubtable in tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize] do
            for iSegmentZ, bValid in tSubtable do
                M28Utilities.DrawLocation(M28Map.GetPositionFromPathingSegments(iSegmentX, iSegmentZ))
                --LOG('DrawBuildableLocations: highest build size for segX='..iSegmentX..'Z'..iSegmentZ..'='..(tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] or 'nil'))
            end
        end
    end
end

function GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerAction, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZTeamData, bCalledFromGetBestLocation, sBlueprintOverride)
    --Returns blueprint and location for oEngineer to build at and returns these or nil if no suitable locations can be found
    --iCatToBuildBy: Optional, specify if want to look for adjacency locations; Note to factor in 50% of the builder's size and 50% of the likely adjacency building size
    --iOptionalEngineerAction - ideally should populate this, will both help with debug and more importantly is used to track building sizes by action so can switch off parts of engineer logic when run out of build space

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBlueprintAndLocationToBuild'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for action (if specified) '..(iOptionalEngineerAction or 'nil')..', Engineer UC='..GetEngineerUniqueCount(oEngineer)..'; Engineer LC='..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Techlevel='..M28UnitInfo.GetUnitTechLevel(oEngineer)..'; tAlternativePositionToLookFrom='..repru(tAlternativePositionToLookFrom or {'nil'})..'; bBuildCheapestStructure='..tostring((bBuildCheapestStructure or false))..'; All blueprints that meet the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild))..'; iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')) end

    --Get the blueprint to build
    --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition, oFactory, bGetSlowest, bGetFastest, iOptionalCategoryThatMustBeAbleToBuild, bGetCheapest)
    local sBlueprintToBuild = sBlueprintOverride or M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oEngineer, false, false, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure)


    if sBlueprintToBuild == nil then
        --Factory specific - retry but removing any tech restrictions on iCategoryToBuild
        if bDebugMessages == true then LOG(sFunctionRef..': sBlueprintToBuild is nil before factory recheck, oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..', bCloseToUnitCap='..tostring(aiBrain[M28Overseer.refbCloseToUnitCap])..'; repru(EntityCategoryGetUnitList(iCategoryToBuild)='..repru(EntityCategoryGetUnitList(iCategoryToBuild))) end
        if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryFactory, iCategoryToBuild) then
            if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryLandFactory, iCategoryToBuild) then
                iCategoryToBuild = M28UnitInfo.refCategoryLandFactory
            elseif M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryAirFactory, iCategoryToBuild) then
                iCategoryToBuild = M28UnitInfo.refCategoryAirFactory
            elseif M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryNavalFactory, iCategoryToBuild) then
                iCategoryToBuild = M28UnitInfo.refCategoryNavalFactory
            end
            sBlueprintToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oEngineer, false, false, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure)
        end
        if not(sBlueprintToBuild) then
            if not(aiBrain[M28Overseer.refbCloseToUnitCap]) then
                M28Utilities.ErrorHandler('sBlueprintToBuild is nil, could happen e.g. if try and get sparky to build sxomething it cant or try to build support factory without the HQ or if unit restrictions are present - refer to log for more details')
                if not(iCategoryToBuild) then LOG(sFunctionRef..': No category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer))
                else
                    LOG(sFunctionRef..': Had category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..'; All blueprints that satisfy the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild))..'; Engineer highest land factory tech='..oEngineer:GetAIBrain()[M28Economy.refiOurHighestLandFactoryTech]..'; bUnitRestrictionsArePresent='..tostring(M28Overseer.bUnitRestrictionsArePresent)..'; Is table of restrictions empty='..tostring(M28Utilities.IsTableEmpty(import("/lua/game.lua").GetRestrictions()))..'; iOptionalEngineerAction='..(iOptionalEngineerAction or 'nil'))
                end
            end

            --If trying to build experimental, then just build any kind of experimental
            if M28Overseer.bUnitRestrictionsArePresent and M28Utilities.DoesCategoryContainCategory(iCategoryToBuild, M28UnitInfo.refCategoryExperimentalLevel) and aiBrain:GetEconomyStoredRatio('MASS') >= 0.35 then
                sBlueprintToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryExperimentalLevel -categories.TRANSPORTATION - categories.TRANSPORTFOCUS, oEngineer, false, false, nil, nil)
                --If we have ended up with a game ender then only proceed if we have sufficient eco
                if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder, sBlueprintToBuild) and M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] < 80 then
                    --If <= 350 mass per sec+45m in gametime, or < 70% mass stored, then dont build
                    local iGrossThreshold = 35
                    if GetGameTimeSeconds() >= 2700 then --45m+ into game
                        iGrossThreshold = math.max(15, iGrossThreshold - 1 * (GetGameTimeSeconds() - 2700) / 180) --Decrease threshold by 10 pass per sec for every 3m after 45m
                    end

                    if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] <= iGrossThreshold or M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamLowestMassPercentStored] <= 0.7 then
                        sBlueprintToBuild = nil
                    end
                end
            end
        end
    end
    if sBlueprintToBuild == nil then
    else

        if iOptionalEngineerAction then
            tiLastBuildingSizeFromActionForTeam[oEngineer:GetAIBrain().M28Team][iOptionalEngineerAction] = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
        end

        --Adjust the search range and record key info needed for the search
        local tEngineerPosition = oEngineer:GetPosition()
        local tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition)
        local tPotentialBuildLocations = {}

        --Increase max area to search if dealing with czar or similarly large unit due to its size
        if __blueprints[sBlueprintToBuild].Physics.SkirtSizeX >= 10 then
            iMaxAreaToSearch = iMaxAreaToSearch * 1.5
            if bDebugMessages == true then LOG(sFunctionRef..': Building a large unit such as a czar, increased iMaxAreaToSearch to '..iMaxAreaToSearch) end
        end
        --Reduce max area to search if dealing with a shield (should already have limited this earlier to some extent so this is more of a redundnacy now, but before we were guessing as to the shield size)
        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
            iMaxAreaToSearch = math.min(iMaxAreaToSearch, (__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) * 0.5)
            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with a shield so reduce max area to search based on half of shield size. iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')..'; shield size='..__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) end
        elseif EntityCategoryContains(M28UnitInfo.refCategoryTMD, sBlueprintToBuild) then
            local iTMDRange = 30
            local oTMDBP = __blueprints[sBlueprintToBuild]
            if M28Utilities.IsTableEmpty(__blueprints[sBlueprintToBuild]) == false then
                for iWeapon, tWeapon in __blueprints[sBlueprintToBuild].Weapon do
                    if tWeapon.MaxRadius then
                        iTMDRange = math.min(iTMDRange, tWeapon.MaxRadius)
                    end
                end
                iMaxAreaToSearch = math.min(iMaxAreaToSearch, math.max(11, iTMDRange * 0.8))
            end
        end

        if not(tTargetLocation) then tTargetLocation = tEngineerPosition end

        --Target location adjustments
        local oClosestUnitToTML
        if EntityCategoryContains(M28UnitInfo.refCategoryTMD, sBlueprintToBuild) then
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]) == false and M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftEnemyTML]) == false then
                local iStartingPlateau, iStartingLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                local iCurDist
                local iClosestDist = 100000
                local oClosestTML
                for iUnit, oUnit in M28Team.tTeamData[aiBrain.M28Team][M28Team.reftEnemyTML] do
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation)
                    if iCurDist < iClosestDist then
                        oClosestTML = oUnit
                        iClosestDist = iCurDist
                    end
                end
                iClosestDist = 100000
                local tClosestTMLLocation = oClosestTML:GetPosition()
                for iUnit, oUnit in tLZTeamData[M28Map.reftUnitsWantingTMD] do
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tClosestTMLLocation, oUnit:GetPosition())
                    if iCurDist < iClosestDist then
                        iClosestDist = iCurDist
                        oClosestUnitToTML = oUnit
                    end
                end
                local iDistToMoveAway = 10
                if EntityCategoryContains(categories.AEON, sBlueprintToBuild) then iDistToMoveAway = 6 end
                tTargetLocation = M28Utilities.MoveInDirection(oClosestUnitToTML:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnitToTML:GetPosition(), tClosestTMLLocation), 10, true, false, true)
                if iStartingPlateau > 0 and iStartingLZ > 0 then
                    --Check the new target location is in the same LZ, if not then change distance to 0
                    local iNewPlateau, iNewLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                    if not(iNewLZ == iStartingLZ) then
                        tTargetLocation = oClosestUnitToTML:GetPosition()
                    end
                end
            end

        end

        if bDebugMessages == true then LOG(sFunctionRef..': sBlueprintToBuild='..(sBlueprintToBuild or 'nil')..'; Location to look from='..repru(tTargetLocation)) end
        --Mex or hydro or mass storage - consider the resource/storage locations
        if EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryHydro + M28UnitInfo.refCategoryMassStorage, sBlueprintToBuild) then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
            local iWaterZone, iPond
            local iPlateauOrZero, iLandOrWaterZone
            local tLZOrWZData
            if bDebugMessages == true then LOG(sFunctionRef..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' is considerinb building mex or hydro '..sBlueprintToBuild..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
            if (iLandZone or 0) == 0 then
                iWaterZone = M28Map.GetWaterZoneFromPosition(tTargetLocation)
                iPond = M28Map.tiPondByWaterZone[iWaterZone]
                if iWaterZone > 0 and iPond > 0 then
                    iPlateauOrZero = 0
                    iLandOrWaterZone = iWaterZone
                    tLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
                end
            else
                tLZOrWZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                iPlateauOrZero = iPlateau
                iLandOrWaterZone = iLandZone
            end
            local tResourceLocations
            if M28Utilities.IsTableEmpty(tLZOrWZData) then M28Utilities.ErrorHandler('Dont have valid water or land zone but are looking to build a resource')
            else
                if EntityCategoryContains(M28UnitInfo.refCategoryMex, sBlueprintToBuild) then
                    tResourceLocations = tLZOrWZData[M28Map.subrefMexUnbuiltLocations]
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to build mex so tResourceLocations for Plateau'..(iPlateau or 'nil')..' LZ '..(iLandZone or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'='..repru(tResourceLocations)) end
                elseif EntityCategoryContains(M28UnitInfo.refCategoryHydro, sBlueprintToBuild) then
                    tResourceLocations = tLZOrWZData[M28Map.subrefHydroUnbuiltLocations]
                elseif EntityCategoryContains(M28UnitInfo.refCategoryMassStorage, sBlueprintToBuild) and not(iWaterZone) then
                    tResourceLocations = tLZOrWZData[M28Map.subrefLZMassStorageLocationsAvailable]
                else M28Utilities.ErrorHandler('Unrecognised resource category')
                end
            end
            if tResourceLocations then
                --Cycle through and include any that are buildable
                local bCheckForQueuedBuildings = true
                --ACU shouldnt check for queued buildings as otherwise it treats its own queued order as meaning it cant build there!
                if EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then bCheckForQueuedBuildings = false end
                for iCurResource, tCurResource in tResourceLocations do
                    if bDebugMessages == true then
                        --CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, iOptionalPlateauGroupOrZero, iOptionalLandOrWaterZone, iEngiActionToIgnore, bClearActionsIfNotStartedBuilding, bCheckForQueuedBuildings, bCheckForOverlappingBuildings)
                        LOG(sFunctionRef..': Checking if can build '..sBlueprintToBuild..' on resource location '..repru(tCurResource)..'; result='..tostring(CanBuildAtLocation(aiBrain, sBlueprintToBuild, tCurResource, iPlateau, iLandZone, nil, false, true, false))..'; will draw locations we can build on in blue, and those we cant in red')
                        if CanBuildAtLocation(aiBrain, sBlueprintToBuild, tCurResource, iPlateauOrZero, iLandOrWaterZone, nil, false, bCheckForQueuedBuildings, false, false, false) then
                            M28Utilities.DrawLocation(tCurResource, 1)
                        else
                            M28Utilities.DrawLocation(tCurResource, 2)
                        end
                    end
                    if CanBuildAtLocation(aiBrain, sBlueprintToBuild, tCurResource, iPlateauOrZero, iLandOrWaterZone, nil, false, bCheckForQueuedBuildings, false, false) then
                        table.insert(tPotentialBuildLocations, tCurResource)
                    end
                end
            end
        else
            --Get adjacency location if we want adjacency
            if iCatToBuildBy or oUnitToBuildBy then
                if bDebugMessages == true then LOG(sFunctionRef..': About to get potential adjacency locations, sBlueprintToBuild='..(sBlueprintToBuild or 'nil')..'; is iCatToBuildBy empty='..tostring(iCatToBuildBy == nil)) end
                tPotentialBuildLocations = GetPotentialAdjacencyLocations(aiBrain, sBlueprintToBuild, tTargetLocation, iMaxAreaToSearch, iCatToBuildBy, oUnitToBuildBy)
                if bDebugMessages == true then LOG(sFunctionRef..': Finished getting potential adjacency locations, sBlueprintToBuild='..sBlueprintToBuild..'; tPotentialBuildLocations='..repru(tPotentialBuildLocations)) end
            end
            if M28Utilities.IsTableEmpty(tPotentialBuildLocations) then
                --use the predefined build locations for the land zoneM28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]M28Map.subrefBuildLocationSegmentCountBySize][iSize]
                local iPlateauOrZero, iLandOrWaterZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                local iPond
                local tLZOrWZData
                if (iLandOrWaterZone or 0) == 0 then
                    iLandOrWaterZone = M28Map.GetWaterZoneFromPosition(tTargetLocation)
                    iPond = M28Map.tiPondByWaterZone[iLandOrWaterZone]
                    tLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                    iPlateauOrZero = 0
                else
                    tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                end
                local iSize = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
                --Game-ender specific logic - use a larger build size
                if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder, sBlueprintToBuild) then
                    --Artillery structures (rapid fire and mavor) - use czar
                    if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalArti - categories.MOBILE, sBlueprintToBuild) then
                        iSize = math.max(iSize, iMaxBuildingSize)
                    else
                        --Yolona, scathis
                        iSize = math.max(iSize, 16)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Are trying to build a gameender, iSize to use='..iSize) end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have searched all segments in the land zone before, tLocation='..repru(tTargetLocation)..'; sBlueprintToBuild='..sBlueprintToBuild..'; iSize='..iSize..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize]='..repru(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize])..'; Segments considered for build locations='..repru(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize])..'; Total segments in LZ (nil if wZ)='..(tLZOrWZData[M28Map.subrefLZTotalSegmentCount] or 'nil')..'; Is table of build locations empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize]))) end
                tPotentialBuildLocations = GetPotentialBuildLocationsNearLocation(aiBrain, tLZOrWZData, iPlateauOrZero, iLandOrWaterZone, iSize)
                if M28Utilities.IsTableEmpty(tPotentialBuildLocations) then
                    if tLZOrWZData[M28Map.subrefLZbCoreBase] then
                        M28Utilities.ErrorHandler('Run out of build locations for iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iSize='..iSize, true)
                        if bDebugMessages == true and not(iPond) then
                            LOG(sFunctionRef..': Will draw affected land zone, and if we have any blacklisted locations will draw in red')
                            M28Map.DrawSpecificLandZone(iPlateauOrZero, iLandOrWaterZone)
                            DrawBlacklistedLocations(tLZOrWZData)
                        end
                        --Treat the closest land zone as core to expand locations to do building going forwards
                        if not(iPond) and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false and tLZOrWZData[M28Map.subrefLZPathingToOtherLandZones][1] then
                            M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][tLZOrWZData[M28Map.subrefLZPathingToOtherLandZones][1][M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefbCoreBaseOverride] = true
                            if bDebugMessages == true then LOG(sFunctionRef..': have made alt LZ'..tLZOrWZData[M28Map.subrefLZPathingToOtherLandZones][1][M28Map.subrefLZNumber]..' a core base now') end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': No adjacency locations or not looking for adjacency; tPotentialBuildLocations based on land zone build locations for iSize='..M28UnitInfo.GetBuildingSize(sBlueprintToBuild)..'='..repru(tPotentialBuildLocations)..'; will draw each location in light blue; Is tPotentialBuildLocations empty='..tostring(M28Utilities.IsTableEmpty(tPotentialBuildLocations)))
                    if M28Utilities.IsTableEmpty(tPotentialBuildLocations) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': Total number of potential build locations='..table.getn(tPotentialBuildLocations)) end
                        for iEntry, tEntry in tPotentialBuildLocations do
                            M28Utilities.DrawLocation(tEntry, 5)
                        end
                    end
                end
            end
        end

        --Pick the preferred build location
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of potential build locations empty='..tostring(M28Utilities.IsTableEmpty(tPotentialBuildLocations))..'; sBlueprintToBuild='..sBlueprintToBuild) end
        if M28Utilities.IsTableEmpty(tPotentialBuildLocations) == false then
            --GetBestBuildLocationForTarget(oEngineer, sBlueprintToBuild, tTargetLocation, tPotentialBuildLocations, iOptionalMaxDistanceFromTargetLocation)
            local tBestLocation = GetBestBuildLocationForTarget(oEngineer, sBlueprintToBuild, tTargetLocation, tPotentialBuildLocations, iMaxAreaToSearch, bCalledFromGetBestLocation)
            if bDebugMessages == true then LOG(sFunctionRef..': Just got best location to build at, tBestLocation='..repru(tBestLocation)) end
            if tBestLocation then
                --TMD check - if too far away to proect the unit we are interested in, then flag that dont want to try building tmd for the unit anymore
                if oClosestUnitToTML then
                    local iCurDist = M28Utilities.GetDistanceBetweenPositions(oClosestUnitToTML:GetPosition(), tBestLocation)
                    if iCurDist >= 30 or (EntityCategoryContains(categories.AEON, sBlueprintToBuild) and iCurDist >= 12.5) then
                        oClosestUnitToTML[M28Building.refbNoNearbyTMDBuildLocations] = true
                    end
                end
                return sBlueprintToBuild, tBestLocation
            else
                if bDebugMessages == true then LOG(sFunctionRef..': We couldnt find any suitable best location for sBlueprintToBuild='..sBlueprintToBuild..'; so will abort') end
            end
        elseif bDebugMessages == true then LOG(sFunctionRef..': No build locations found')
        end
    end
    return nil, nil
end

function GetBestBuildLocationForTarget(oEngineer, sBlueprintToBuild, tTargetLocation, tPotentialBuildLocations, iOptionalMaxDistanceFromTargetLocation, bAlreadyTriedAlternatives)
    --Assumes we have already checked for: Adjacency; In the same land zone; Valid location to build
    --WIll then consider: If engineer can build without moving; How far away it is from the engineer; if it will block mex adjacency, and (if we specify a maximum distance) if it is within the max distance
    --bAlreadyTriedAlternatives - set to true if we have already called this function via this function
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBestBuildLocationForTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iHighestPriority = -100
    local iCurPriority, iCurDistance
    local iBestLocationRef
    local oEngiBP = oEngineer:GetBlueprint()
    local iNewBuildingRadius = M28UnitInfo.GetBuildingSize(sBlueprintToBuild) * 0.5
    local iBuilderRange = (oEngiBP.Economy.MaxBuildDistance or 5) + math.min(oEngiBP.SizeX, oEngiBP.SizeZ) + iNewBuildingRadius - 0.5
    local rBuildAreaRect
    local iMaxRange = iOptionalMaxDistanceFromTargetLocation or 200
    local aiBrain = oEngineer:GetAIBrain()
    local bBuildTowardsHydro = false
    local tLocationToBuildTowards
    local tiClosestDistByPriorityAndCount --[x] is the priority before adjusting for this, returns {iDistance, iCount} where iCount is the number of times this has been updated (as need to increase priority by this to ensure we have a greater uplift than a further away distance)
    local bTryOtherLocationsIfNoneBuildableImmediately = false
    if GetGameTimeSeconds() <= 10 and EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryFactory, sBlueprintToBuild) then
        if not(bAlreadyTriedAlternatives) then
            bTryOtherLocationsIfNoneBuildableImmediately = true
        end
    end
    --Reduce likelihood of units switching build location targets slightly
    local tLastBuildLocationForUnit
    local tLastOrder = oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]]
    if tLastOrder[M28Orders.subrefsOrderBlueprint] and tLastOrder[M28Orders.subrefsOrderBlueprint] == sBlueprintToBuild then tLastBuildLocationForUnit = tLastOrder[M28Orders.subreftOrderPosition] end
    if bDebugMessages == true then
        LOG(sFunctionRef..': iTeam='..aiBrain.M28Team..'; aiBrain='..aiBrain.Nickname..'; Time='..GetGameTimeSeconds()..'; tLastOrder reprs='..reprs(tLastOrder)..'; tLastBuildLocationForUnit if we think it is the same='..repru(tLastBuildLocationForUnit)..'; sBlueprintToBuild='..sBlueprintToBuild..'; Building size of BP to build='..M28UnitInfo.GetBuildingSize(sBlueprintToBuild))
    end

    local bLocationBuildableImmediately
    --Start of game - build factory closer to hydro if possible
    if GetGameTimeSeconds() <= 60 and EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, sBlueprintToBuild) then
        --Do we have hydro in this LZ? dont want to consider if water zone
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
        if (iLandZone or 0) > 0 and iPlateau > 0 then
            local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefHydroUnbuiltLocations]) == false then
                local iClosestHydroDist = 100000
                local iCurDist
                for iEntry, tHydro in tLZData[M28Map.subrefHydroUnbuiltLocations] do
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), tHydro)
                    if iCurDist < iClosestHydroDist then
                        iClosestHydroDist = iCurDist
                        tLocationToBuildTowards = {tHydro[1], tHydro[2], tHydro[3]}
                        bBuildTowardsHydro = true
                    end
                end
            end
        end
    end

    if not(tLocationToBuildTowards) then
        --Build towards the midpoing except for certain unit categories
        if not(EntityCategoryContains(M28UnitInfo.refCategoryPD + M28UnitInfo.refCategoryTMD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild)) then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
            if (iLandZone or 0) > 0 and iPlateau > 0 then
                local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                tLocationToBuildTowards = tLZData[M28Map.subrefMidpoint]
            end
        end
    end
    if tLocationToBuildTowards then tiClosestDistByPriorityAndCount = {} end

    local bCheckForStorageAdjacency = EntityCategoryContains(M28UnitInfo.refCategoryMassStorage, sBlueprintToBuild)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; sBLueprintToBuild='..(sBlueprintToBuild or 'nil')..'; tTargetLocation='..repru(tTargetLocation)..'; tPotentialBuildLocations='..repru(tPotentialBuildLocations)..'; iOptionalMaxDistanceFromTargetLocation='..(iOptionalMaxDistanceFromTargetLocation or 'nil')..'; iMaxRange='..iMaxRange..'; iBuilderRange='..iBuilderRange..'; iNewBuildingRadius='..iNewBuildingRadius..'; bBuildTowardsHydro='..tostring(bBuildTowardsHydro)..'; tLocationToBuildTowards (e.g. for hydro)='..repru(tLocationToBuildTowards)..'; Engineer position='..repru(oEngineer:GetPosition())) end
    for iCurLocation, tCurLocation in tPotentialBuildLocations do
        bLocationBuildableImmediately = true
        iCurPriority = -100
        iCurDistance = M28Utilities.GetDistanceBetweenPositions(tTargetLocation, tCurLocation)
        if bDebugMessages == true then
            LOG(sFunctionRef..': Considering location ref '..iCurLocation..'; tCurLocation='..repru(tCurLocation)..'; iCurDistance='..iCurDistance..'; iMaxRange='..iMaxRange..'; Can we build here='..tostring(oEngineer:GetAIBrain():CanBuildStructureAt(sBlueprintToBuild, tCurLocation)))
            if tLastBuildLocationForUnit then LOG(sFunctionRef..': Rough dist to last build location='..M28Utilities.GetRoughDistanceBetweenPositions(tCurLocation, tLastBuildLocationForUnit)) end
            M28Utilities.DrawLocation(tCurLocation)
        end
        if iCurDistance <= iMaxRange and aiBrain:CanBuildStructureAt(sBlueprintToBuild, tCurLocation) then
            if iCurDistance <= iBuilderRange then
                iCurPriority = iCurPriority + 3
                if bDebugMessages == true then LOG(sFunctionRef..': Within build range so increasing priority by 3') end
            else
                bLocationBuildableImmediately = false
            end
            rBuildAreaRect = Rect(tCurLocation[1] - iNewBuildingRadius, tCurLocation[3] - iNewBuildingRadius, tCurLocation[1] + iNewBuildingRadius, tCurLocation[3] + iNewBuildingRadius)
            if bDebugMessages == true then LOG(sFunctionRef..': Will force debug on whether we have reclaim in rec, do we have reclaim='..tostring(M28Map.GetReclaimInRectangle(1, rBuildAreaRect, true))) end
            if M28Map.GetReclaimInRectangle(1, rBuildAreaRect) == false then
                iCurPriority = iCurPriority + 3
                if bDebugMessages == true then LOG(sFunctionRef..': No reclaim in build area so increasing priority by 3') end
            else
                bLocationBuildableImmediately = false
                if bDebugMessages == true then LOG(sFunctionRef..': Reclaim in build area so not increasing priority') end
            end
            if not(M28Conditions.AreMobileLandUnitsInRect(rBuildAreaRect)) then
                if bDebugMessages == true then LOG(sFunctionRef..': No units in rect so increasing priority by 3') end
                iCurPriority = iCurPriority + 4
            else
                bLocationBuildableImmediately = false
            end
            if iCurDistance <= 50 then
                if iCurDistance <= math.max(10, iBuilderRange - 0.5) then
                    iCurPriority = iCurPriority + 7
                    if bDebugMessages == true then LOG(sFunctionRef..': Location is within 10 so increasing priority by 7') end
                else
                    bLocationBuildableImmediately = false
                    if iCurDistance <= 25 then
                        iCurPriority = iCurPriority + 5
                    else
                        iCurPriority = iCurPriority + 3
                    end
                end
            end
            --General dist adjust
            if iCurDistance >= 15 then
                iCurPriority = iCurPriority - iCurDistance / iMaxRange * 6
            end

            --Adjust if can build immediately
            if bLocationBuildableImmediately then
                iCurPriority = iCurPriority + 1
                if EntityCategoryContains(M28UnitInfo.refCategorySMD + M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryTMD, sBlueprintToBuild) then iCurPriority = iCurPriority + 4 end
            end

            --Adjust if was location of our last build order
            if tLastBuildLocationForUnit and M28Utilities.GetRoughDistanceBetweenPositions(tLastBuildLocationForUnit, tCurLocation) <= 0.75 then
                iCurPriority = iCurPriority + 1
                if bDebugMessages == true then LOG(sFunctionRef..': Are close to our last build order location so increasing priority by 1') end
            end

            --Mass s torage specific - value higher mexes (wont bother with mass fabs)
            if bCheckForStorageAdjacency then
                local rAdjacencyRect = M28Utilities.GetRectAroundLocation(tCurLocation, 2.749) --If changing here also update m28events and m28economy
                local tPotentiallyAdjacentMexes = GetUnitsInRect(rAdjacencyRect)
                local iAdjacencyValue = 0
                local iConstructionFactor
                if M28Utilities.IsTableEmpty(tPotentiallyAdjacentMexes) == false then
                    tPotentiallyAdjacentMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tPotentiallyAdjacentMexes)
                    if M28Utilities.IsTableEmpty(tPotentiallyAdjacentMexes) == false then
                        for iMex, oMex in tPotentiallyAdjacentMexes do
                            if M28Utilities.GetDistanceBetweenPositions(oMex:GetPosition(), tCurLocation) <= 2.25 then
                                if oMex:GetFractionComplete() < 1 then
                                    iConstructionFactor = oMex:GetFractionComplete() * 0.75
                                else
                                    iConstructionFactor = 1
                                end
                                iAdjacencyValue = iAdjacencyValue + (oMex:GetBlueprint().Economy.ProductionPerSecondMass or 0) * iConstructionFactor
                            end
                        end
                    end
                end
                iCurPriority = iCurPriority + iAdjacencyValue
            end



            --Build towards hydro adjust
            if tLocationToBuildTowards then
                local iCurDistTowardsBuildTowards = M28Utilities.GetDistanceBetweenPositions(tCurLocation, tLocationToBuildTowards)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering adjustment for building towards hydro, iCurDistTowardsBuildTowards='..iCurDistTowardsBuildTowards..'; iCurPrioriyt='..iCurPriority..'; tiClosestDistByPriorityAndCount for this priority='..repru(tiClosestDistByPriorityAndCount[iCurPriority])..'; Are we equal or less than this distance='..tostring(iCurDistTowardsBuildTowards <= (tiClosestDistByPriorityAndCount[iCurPriority][1] or 100000))) end
                if iCurDistTowardsBuildTowards <= (tiClosestDistByPriorityAndCount[iCurPriority][1] or 100000) then
                    tiClosestDistByPriorityAndCount[iCurPriority] = {iCurDistTowardsBuildTowards, (tiClosestDistByPriorityAndCount[iCurPriority][2] or 0) + 1}
                    iCurPriority = iCurPriority + tiClosestDistByPriorityAndCount[iCurPriority][2] * 0.1
                    if bBuildTowardsHydro then iCurPriority = iCurPriority + 1 end
                    if bDebugMessages == true then LOG(sFunctionRef..': Increased priority due to being the closest for this base level to hydro, iCurPriority after uplift='..iCurPriority) end
                end
            end
            --NOTE: Dont include adjustments after this poitn, as abovel ogic assumes we have got to the post-modifier priority for buildtowardshydro
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Considering tCurLocation='..repru(tCurLocation)..'; iCurDistance='..iCurDistance..'; iCurPriority='..iCurPriority) end
        if iCurPriority > iHighestPriority then
            iHighestPriority = iCurPriority
            iBestLocationRef = iCurLocation
            if bDebugMessages == true then LOG(sFunctionRef..': Have a new best priority, iHighestPriority='..iHighestPriority) end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished searching, is iBestLocationRef nil='..tostring(iBestLocationRef == nil)..'; Are we trying to build a shield='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild))) end
    if not(iBestLocationRef) and EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
        local tNearbyUnits = GetUnitsInRect(M28Utilities.GetRectAroundLocation(tTargetLocation, 2))
        if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
            for iUnit, oUnit in tNearbyUnits do
                oUnit[refiFailedShieldBuildDistance] = math.max(iOptionalMaxDistanceFromTargetLocation + 1, (oUnit[refiFailedShieldBuildDistance] or 0))
                if bDebugMessages == true then LOG(sFunctionRef..': Set shield failed idstance for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to '..oUnit[refiFailedShieldBuildDistance]) end
            end
        end
    end

    if not(bLocationBuildableImmediately) and bTryOtherLocationsIfNoneBuildableImmediately then
        local tLZTeamData
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
        if (iLandZone or 0) > 0 and iPlateau > 0 then
            local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
            local iTeam = oEngineer:GetAIBrain().M28Team
            tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
        end
        local sRedundantBlueprint, tAltBestLocation = GetBlueprintAndLocationToBuild(aiBrain, oEngineer, nil, nil, iOptionalMaxDistanceFromTargetLocation, nil, tTargetLocation, true, nil, nil, nil, tLZTeamData, true, sBlueprintToBuild)
        if bDebugMessages == true then LOG(sFunctionRef..': tAltBestLocation='..repru(tAltBestLocation)..'; oEngineer:GetPosition='..repru(oEngineer:GetPosition())) end
        if tAltBestLocation and M28Utilities.GetDistanceBetweenPositions(tAltBestLocation, oEngineer:GetPosition()) <= iMaxRange then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return tAltBestLocation
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if iBestLocationRef then return tPotentialBuildLocations[iBestLocationRef]
    else return nil
    end
end





function GetLocationToMoveForConstruction(oUnit, tTargetLocation, sBlueprintID, iBuildDistanceMod, bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation)
    --Gets the location that oBuilder should move to in order to be within range of building on tLocation, factoring in the size of buildingType
    --sBlueprintID - if nil, then will treat the action as having a size of 0
    --iBuildDistanceMod - increase or decrease if want to move closer/further away than build distance would send you; e.g. if want to get 3 inside the build distance, set this to -3
    --Returns nil if no valid location or are in range and bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation is not true

    --Note: Will always try to be a minimum of 1 away


    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetLocationToMoveForConstruction'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local sPathing = M28UnitInfo.GetUnitPathingType(oUnit)
    local iPathingGroupWanted = NavUtils.GetLabel(sPathing, oUnit:GetPosition())

    local tPotentialMoveLocation
    local iAngleFromTargetToBuilder = M28Utilities.GetAngleFromAToB(tTargetLocation, oUnit:GetPosition())
    local iBuildRange = oUnit:GetBlueprint().Economy.MaxBuildDistance
    local iDistanceWantedFromTarget = math.max(1, iBuildRange + (iBuildDistanceMod or 0))
    if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; tTargetLocation='..repru(tTargetLocation)..'; sBlueprintID='..(sBlueprintID or 'nil')..'; iBuildDistanceMod='..(iBuildDistanceMod or 'nil')..'bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation='..tostring(bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation or false)) end
    if not(bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation) then
        --Check if we are in range already
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if we are already in range of the target, distance='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation)..'; iDistanceWantedFromTarget='..iDistanceWantedFromTarget) end
        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation) <= iDistanceWantedFromTarget then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return nil
        end
    end
    if sBlueprintID then iDistanceWantedFromTarget = iDistanceWantedFromTarget + M28UnitInfo.GetBuildingSize(sBlueprintID) * 0.5 end
    for iDistanceToMove = iDistanceWantedFromTarget, 1, -1 do
        tPotentialMoveLocation = M28Utilities.MoveInDirection(tTargetLocation,iAngleFromTargetToBuilder, iDistanceToMove, true, false, true)
        if NavUtils.GetLabel(sPathing, tPotentialMoveLocation) == iPathingGroupWanted then
            if bDebugMessages == true then LOG(sFunctionRef..': Have a valid location engi can move to='..repru(tPotentialMoveLocation)..'; Dist from target='..M28Utilities.GetDistanceBetweenPositions(tPotentialMoveLocation, tTargetLocation)..'; iDistanceToMove='..(iDistanceToMove or 'nil')..'; will check no buildings in a radius of 5 that are blocking this location') end
            local rRectangleToSearch = M28Utilities.GetRectAroundLocation(tPotentialMoveLocation, 5)
            local tBlockingUnits = GetUnitsInRect(rRectangleToSearch)
            local bDontMove = false
            if M28Utilities.IsTableEmpty(tBlockingUnits) == false then
                local tBlockingBuildings = EntityCategoryFilterDown(categories.STRUCTURE, tBlockingUnits)
                local iBlockingSize
                for iBuilding, oBuilding in tBlockingBuildings do
                    iBlockingSize = M28UnitInfo.GetBuildingSize(oBuilding.UnitId) * 0.5
                    local tBuildingPosition = oBuilding:GetPosition()
                    if math.abs(tBuildingPosition[1] - tPotentialMoveLocation[1]) <= iBlockingSize and math.abs(tBuildingPosition[3] - tPotentialMoveLocation[3]) <= iBlockingSize then
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Will be blocked by a building so wont move here')
                            M28Utilities.DrawLocation(tPotentialMoveLocation, 2)
                        end
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return nil
                    end
                end
            end


            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return tPotentialMoveLocation
        elseif bDebugMessages == true then LOG(sFunctionRef..': Cant move to the desired location, will draw in red') M28Utilities.DrawLocation(tPotentialMoveLocation, 2)
        end
        if iDistanceToMove <= 1 then
            if bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return {tTargetLocation[1], tTargetLocation[2], tTargetLocation[3]}
            end
            break
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return nil

    --Below was from M27 - left commented out as might be of use when introduce naval factory logic again
    --[[
tPossibleTarget = M28Map.GetPositionAtOrNearTargetInPathingGroup(tBuilderLocation, tLocation, iDistanceWantedFromTarget, 0, oBuilder, true, true, iMinDistanceFromCurrentBuilderMoveTarget)

--Adjust further for naval factory to facilitate greater cliff-building
if tPossibleTarget and EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, sBlueprintID) then
    --If we move from Possible target towards our currnet position do we come across a cliff very soon?

    local bHaveCliff = false

    local iAngleFromMoveTarget = M28Utilities.GetAngleFromAToB(tPossibleTarget, tBuilderLocation)

    local iMaxCliffSearchRange = 15 + math.floor(iBuildDistance)

    function IsCliffBlockingTarget(tTarget)
        local iDistToMoveTarget = M28Utilities.GetDistanceBetweenPositions(tBuilderLocation, tTarget)
        local tCliffPositionCheck
        if iDistToMoveTarget > 1 then
            for iDistAdjust = 1, math.min(iMaxCliffSearchRange, math.floor(iDistToMoveTarget)) do
                tCliffPositionCheck = M28Utilities.MoveInDirection(tPossibleTarget, iAngleFromMoveTarget, iDistAdjust, true, false)
                if not(NavUtils.GetLabel(sPathing, tCliffPositionCheck) == iEngiPathingGroup) then
                    return true
                end
            end
        end
        return false
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Building naval factory, IsCliffBlockingTarget(tPossibleTarget='..tostring(IsCliffBlockingTarget(tPossibleTarget))..'; tPossibleTarget='..repru(tPossibleTarget)..'; tLocation (of where we want to build)='..repru(tLocation)) end
    if IsCliffBlockingTarget(tPossibleTarget) then
        --Can we get any closer to our build distance if we broaden the angle range?  Also increase the distance slightly
        iDistanceWantedFromTarget = iDistanceWantedFromTarget + 0.1
        local iAngleToEngi = M28Utilities.GetAngleFromAToB(tLocation, tBuilderLocation)
        local tReplacementTarget
        local tPathingPosition
        if bDebugMessages == true then LOG(sFunctionRef..': About to try different positions from tLocation '..repru(tLocation)..' to tBuilderLocation '..repru(tBuilderLocation)..'; Angle to here='..iAngleToEngi..'; iDistanceWantedFromTarget='..iDistanceWantedFromTarget) end
        for iAngleAdjust = 0, 40, 8 do
            for iAngleFactor = -1, 1, 2 do
                --MoveInDirection(tStart, iAngle, iDistance, bKeepInMapBounds, bTravelUnderwater)
                tPathingPosition = M28Utilities.MoveInDirection(tLocation, iAngleToEngi + iAngleAdjust * iAngleFactor, iDistanceWantedFromTarget, true, false)
                if bDebugMessages == true then

                    local iColour = 3
                    if NavUtils.GetLabel(sPathing, tPathingPosition) == iEngiPathingGroup and not(IsCliffBlockingTarget(tPathingPosition)) then iColour = 7 end
                    LOG(sFunctionRef..': Considering tPathingPosition='..repru(tPathingPosition)..'; iAngleAdjust='..iAngleAdjust * iAngleFactor..'; Pathing group='..NavUtils.GetLabel(sPathing, tPathingPosition)..'; Engi pathing group='..iEngiPathingGroup..'; Is cliff blocking target='..tostring(IsCliffBlockingTarget(tPathingPosition))..'; will draw match in white, nonmatch in black. iColour='..iColour..'; Dist from original move target planned='..M28Utilities.GetDistanceBetweenPositions(tPathingPosition, tPossibleTarget))
                    M28Utilities.DrawLocation(tPathingPosition, false, iColour, 200)
                end
                if NavUtils.GetLabel(sPathing, tPathingPosition) == iEngiPathingGroup and not(IsCliffBlockingTarget(tPathingPosition)) then
                    tReplacementTarget = tPathingPosition
                end

                if iAngleAdjust == 0 or tReplacementTarget then break end
            end
            if tReplacementTarget then break end
        end
        if tReplacementTarget then
            if bDebugMessages == true then LOG(sFunctionRef..': Have a replacement position to use') end
            tPossibleTarget = {tReplacementTarget[1], tReplacementTarget[2], tReplacementTarget[3]}

        end
    end
end
--]]
end

function BuildStructureNearLocation(aiBrain, oEngineer, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bLookForPartCompleteBuildings, bLookForQueuedBuildings, oUnitToBuildBy, bNeverBuildRandom, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, iOptionalEngiActionRef)
    --NOT USED? Might be old code copied from M27 that ended up rewriting?

    --Determines the blueprint and location for oEngineer to build at; also returns the location
    --iCatToBuildBy: Optional, specify if want to look for adjacency locations; Note to factor in 50% of the builder's size and 50% of the likely adjacency building size
    --bLookForQueuedBuildings: Optional, if true, then doesnt choose a target if another engineer already has that target function ref assigned to build something
    --Returns nil if dealing with a non-resource based building

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'BuildStructureNearLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Engineer UC='..GetEngineerUniqueCount(oEngineer)..'; Engineer LC='..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Techlevel='..M28UnitInfo.GetUnitTechLevel(oEngineer)..'; tAlternativePositionToLookFrom='..repru(tAlternativePositionToLookFrom or {'nil'})..'; bBuildCheapestStructure='..tostring((bBuildCheapestStructure or false))..'; bNeverBuildRandom='..tostring((bNeverBuildRandom or false))..'; All blueprints that meet the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild))..'; iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')..'; Water zone of position to look from (if any)='..(M28Map.GetWaterZoneFromPosition(tAlternativePositionToLookFrom or oEngineer:GetPosition()) or 'nil')) end


    local bAbortConstruction = false

    --Get the blueprint to build
    --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition, oFactory, bGetSlowest, bGetFastest, iOptionalCategoryThatMustBeAbleToBuild, bGetCheapest)
    local sBlueprintToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oEngineer, false, false, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure)
    local tTargetLocation
    if sBlueprintToBuild == nil then
        if not(aiBrain[M28Overseer.refbCloseToUnitCap]) then
            M28Utilities.ErrorHandler('sBlueprintToBuild is nil, could happen e.g. if try and get sparky to build sxomething it cant - refer to log for more details')
            if not(iCategoryToBuild) then LOG(sFunctionRef..': No category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer))
            else
                LOG(sFunctionRef..': Had category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..'; All blueprints that satisfy the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild)))
            end
        end
    else

        --Adjust the search range and record key info needed for the search
        local tEngineerPosition = oEngineer:GetPosition()
        tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition)
        --Increase max area to search if dealing with czar or similarly large unit due to its size
        if __blueprints[sBlueprintToBuild].Physics.SkirtSizeX >= 10 then
            iMaxAreaToSearch = iMaxAreaToSearch * 1.5
            if bDebugMessages == true then LOG(sFunctionRef..': Building a large unit such as a czar, increased iMaxAreaToSearch to '..iMaxAreaToSearch) end
        end

        --Reduce max area to search if dealing with a shield
        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
            iMaxAreaToSearch = math.min(iMaxAreaToSearch, (__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) * 0.5)
            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with a shield so reduce max area to search based on half of shield size. iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')..'; shield size='..__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) end
        end


        if bDebugMessages == true then LOG(sFunctionRef..': sBlueprintToBuild='..(sBlueprintToBuild or 'nil')..'; Location to look from='..repru(tAlternativePositionToLookFrom or oEngineer:GetPosition())) end
        local sBlueprintBuildBy
        local bFindRandomLocation = false

        if not(tTargetLocation) then tTargetLocation = tEngineerPosition end
        local bFoundEnemyInstead = false

        local sPathing = M28UnitInfo.GetUnitPathingType(oEngineer)
        local iNewBuildingRadius = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)[1] * 0.5
        local iBuilderRange = oEngineer:GetBlueprint().Economy.MaxBuildDistance + math.min(oEngineer:GetBlueprint().SizeX, oEngineer:GetBlueprint().SizeZ)*0.5
        local iDistanceFromStart = M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()])
        local bBuildNearToEnemy = false
        if iDistanceFromStart <= 80 then bBuildNearToEnemy = true end

        --Check we're not trying to buidl a mex or hydro or mass storage or mass fab
        local bMexHydroOrStorage = false
        if EntityCategoryContains(refCategoryMex, sBlueprintToBuild) or EntityCategoryContains(refCategoryHydro, sBlueprintToBuild) or EntityCategoryContains(M28UnitInfo.refCategoryMassStorage + M28UnitInfo.refCategoryMassFab, sBlueprintToBuild)  then
            bMexHydroOrStorage = true
        end


        --If specified, first check if there's an existing part complete building we can help complete instead of starting a new building
        --Check if is an existing building of the type wanted first:
        local oPartCompleteBuilding
        if bLookForPartCompleteBuildings then
            --GetPartCompleteBuilding(aiBrain, oBuilder, iCategoryToBuild, iBuildingSearchRange, iEnemySearchRange)
            --Returns nil if no nearby part complete building
            --iEnemySearchRange: nil if dont care about nearby enemies, otherwise will ignore buildings that have enemies within iEnemySearchRange
            oPartCompleteBuilding = GetPartCompleteBuilding(aiBrain, oEngineer, iCategoryToBuild, iBuilderRange + 15, nil)
        end
        if oPartCompleteBuilding then
            if bDebugMessages == true then LOG(sFunctionRef..': have partcompletebuilding so returning that as the position') end
            tTargetLocation = oPartCompleteBuilding:GetPosition()
        else
            if bDebugMessages == true then
                local sEngUniqueRef = GetEngineerUniqueCount(oEngineer)
                LOG(sFunctionRef..': Eng builder unique ref='..sEngUniqueRef..'; builder range='..iBuilderRange)
            end



            if not(bMexHydroOrStorage) then
                --For non-extraction buildings, if we have specified we want to build adjacent to something then look for nearby buildings that can give us the adjacency wanted
                if iCatToBuildBy or oUnitToBuildBy then
                    local toPossibleBuildingsToBuildBy
                    local iBuildingCount = 0
                    local tPossibleTargets = {}
                    local tBuildingPosition

                    if iCatToBuildBy then
                        --sBlueprintBuildBy = M28FactoryOverseer.GetBlueprintThatCanBuildOfCategory(aiBrain, iCatToBuildBy, oEngineer)--, false, false)

                        toPossibleBuildingsToBuildBy = aiBrain:GetUnitsAroundPoint(iCatToBuildBy, tTargetLocation, iMaxAreaToSearch, 'Ally')
                        local iCurDist
                        local iClosestDist = 100000
                        --ACU specific - cant build by hydro, but might have nearby hydro
                        if bDebugMessages == true then LOG(sFunctionRef..': Engineer position='..repru(oEngineer:GetPosition())..'; tTargetLocation='..repru(tTargetLocation)..'; iMaxAreaToSearch='..iMaxAreaToSearch..'; is toPossibleBuildingsToBuildBy empty='..tostring(M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy))) end
                        if M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy) == false then
                            --Try to build by the closest unit of the category wanted
                            local oClosestBuilding
                            for iUnit, oUnit in  toPossibleBuildingsToBuildBy do
                                if oUnit:GetAIBrain() == aiBrain then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEngineer:GetPosition())
                                    if iCurDist < iClosestDist then
                                        oClosestBuilding = oUnit
                                        iClosestDist = iCurDist
                                    end
                                end
                            end
                            if oClosestBuilding then
                                sBlueprintBuildBy = oClosestBuilding.UnitId
                                if bDebugMessages == true then LOG(sFunctionRef..': Will update sBlueprintBuildBy to be the closest building for adjacency='..oClosestBuilding.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestBuilding)) end
                            end
                        end


                    elseif oUnitToBuildBy then
                        sBlueprintBuildBy = oUnitToBuildBy.UnitId
                        toPossibleBuildingsToBuildBy = {oUnitToBuildBy}
                    else M28Utilities.ErrorHandler('Missing code')
                    end


                    if M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have possible buildings to build by, so will consider best location') end
                        for iBuilding, oBuilding in toPossibleBuildingsToBuildBy do
                            if not(oBuilding.Dead) and oBuilding.GetPosition and oBuilding:GetAIBrain() == aiBrain then
                                tBuildingPosition = oBuilding:GetPosition()
                                if M28Utilities.GetDistanceBetweenPositions(tBuildingPosition, tTargetLocation) <= iMaxAreaToSearch then
                                    iBuildingCount = iBuildingCount + 1
                                    tPossibleTargets[iBuildingCount] = tBuildingPosition
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Found iBuildingCount='..iBuildingCount..' to build by') end
                        if iBuildingCount == 0 then bFindRandomLocation = not(bNeverBuildRandom) end
                    else
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Cant find any buildings for adjacency, getting random location to build unless we want to build by a mex/hydro and have an unbuilt one nearby')
                            local tNearestBuildingOfCategory = aiBrain:GetUnitsAroundPoint(iCatToBuildBy, tTargetLocation, 10000, 'Ally')
                            if M28Utilities.IsTableEmpty(tNearestBuildingOfCategory) then LOG(sFunctionRef..': Dont have any units of the desired category anywhere on map')
                            else
                                local oNearestBuildingOfCategory = M28Utilities.GetNearestUnit(tNearestBuildingOfCategory, oEngineer:GetPosition(), aiBrain)
                                LOG(sFunctionRef..': Nearest unit of desired category is '..oNearestBuildingOfCategory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestBuildingOfCategory)..' which is '..M28Utilities.GetDistanceBetweenPositions(oNearestBuildingOfCategory:GetPosition(), oEngineer:GetPosition())..' away from the engineer')
                            end
                        end
                        bFindRandomLocation = not(bNeverBuildRandom)
                    end

                    --Also check for unbuilt buildings if dealing with a mex or hydro, unless are building a shield
                    local tResourceLocations
                    if not(EntityCategoryContains(categories.SHIELD, sBlueprintToBuild)) then
                        --land factory - say that we're looking for a mex even if cant find one
                        if bDebugMessages == true then LOG(sFunctionRef..': About to check if building early fac and cant find mex/hydro. Does cat to build by contain mex or hydro='..tostring(M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryHydro + M28UnitInfo.refCategoryMex, iCatToBuildBy, false))..'; sBlueprintBuildBy='..(sBlueprintBuildBy or 'nil')..'; Does engi contain tech1 or ACU='..tostring(EntityCategoryContains(categories.TECH1 + categories.COMMAND, oEngineer.UnitId))..'; Does blueprint to build contain factory='..tostring(EntityCategoryContains(categories.FACTORY, sBlueprintToBuild))) end
                        if iCatToBuildBy and not(sBlueprintBuildBy) and EntityCategoryContains(categories.TECH1 + categories.COMMAND, oEngineer.UnitId) and EntityCategoryContains(categories.FACTORY, sBlueprintToBuild) then
                            if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryMex, iCatToBuildBy, false) then
                                sBlueprintBuildBy = 'ueb1103'
                            elseif M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryHydro, iCatToBuildBy, false) then
                                sBlueprintBuildBy = 'ueb1102'
                            end
                        end
                        if sBlueprintBuildBy then
                            if EntityCategoryContains(M28UnitInfo.refCategoryMex, sBlueprintBuildBy) then
                                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                                local iPond, iWaterZone
                                if (iLandZone or 0) == 0 then
                                    iWaterZone = M28Map.GetWaterZoneFromPosition(tTargetLocation)
                                    iPond = M28Map.tiPondByWaterZone[iWaterZone]
                                    tResourceLocations = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefLZMexLocations]
                                else
                                    tResourceLocations = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Will add any mexes within 20 of target location to be considered, tResourceLocations='..repru(tResourceLocations)) end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryHydro, sBlueprintBuildBy) or EntityCategoryContains(M28UnitInfo.refCategoryT2Power, sBlueprintBuildBy) then --Dont want to make this all power, because the adjacency code requires a building size, and only works for a single building size; i.e. if try and get adjacency for t1 power and include hydro locations, then it will think it needs to build within the hydro for adjacency
                                local iPlateau, iZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                                if not(iZone) then M28Utilities.ErrorHandler('Trying to build a hydro but dont have a valid zone') end
                                tResourceLocations = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iZone][M28Map.subrefHydroLocations]
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tResourceLocations) == false then
                        for iResource, tCurResourceLocation in tResourceLocations do
                            iBuildingCount = iBuildingCount + 1
                            tPossibleTargets[iBuildingCount] = tCurResourceLocation
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and build by resource location (mex or hydro); iBuildingCount including these locations='..iBuildingCount..'; table of building locations='..repru(tPossibleTargets)) end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of resource locations empty='..tostring(M28Utilities.IsTableEmpty(tResourceLocations))..'; iBuildingCount='..iBuildingCount) end
                    if iBuildingCount > 0 then
                        --GetBestBuildLocationForTarget(tablePosTarget, sTargetBuildingBPID, sNewBuildingBPID, bCheckValid, aiBrain, bReturnOnlyBestMatch, pBuilderPos, iMaxAreaToSearch, iBuilderRange, bIgnoreOutsideBuildArea, bBetterIfNoReclaim, bPreferCloseToEnemy, bPreferFarFromEnemy, bLookForQueuedBuildings)
                        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build the shield anywhere near the target. iOptionalEngiActionRef='..(iOptionalEngiActionRef or 'nil')) end
                            local bBuildAwayFromEnemy = false
                            if iOptionalEngiActionRef == refActionFortifyFirebase then bBuildAwayFromEnemy = true end
                            tTargetLocation = GetBuildLocationForShield(aiBrain, sBlueprintToBuild, tAlternativePositionToLookFrom, bBuildAwayFromEnemy)
                            if not(tTargetLocation) then bAbortConstruction = true end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': About to call GetBestBuildLocation; iBuildingCount='..iBuildingCount..'; sBlueprintBuildBy='..(sBlueprintBuildBy or 'nil')) end
                            --Go through all possible adjacent build locations identified, and choose the best one
                            tTargetLocation = GetBestBuildLocationForTarget(tPossibleTargets, sBlueprintBuildBy, sBlueprintToBuild, true, aiBrain, true, tTargetLocation, iMaxAreaToSearch, iBuilderRange, false, true, bBuildNearToEnemy, not(bBuildNearToEnemy), bLookForQueuedBuildings)
                            --Double-check the resulting location is valid
                            if M28Utilities.IsTableEmpty(tTargetLocation) == true then
                                if bDebugMessages == true then LOG('Adjacency location is empty, will try finding anywhere to build') end
                                bFindRandomLocation = not(bNeverBuildRandom)
                            else
                                bFindRandomLocation = false
                                if bDebugMessages == true then LOG(sFunctionRef..': Have determined the best build location for target to be '..repru(tTargetLocation)..'; will double-check we can build here') end
                                if not(CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, nil, nil, nil, false, bLookForQueuedBuildings, false, true)) then
                                    --if aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation) == false or not(M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)])) then
                                    M28Utilities.ErrorHandler('Cant build '..sBlueprintToBuild..' on adjacency location tTargetLocation='..repru({tTargetLocation[1], tTargetLocation[2],tTargetLocation[3]}))
                                    bFindRandomLocation = not(bNeverBuildRandom)
                                else
                                    --Check we're within mapBoundary
                                    if bDebugMessages == true then LOG(sFunctionRef..': Cant build at the location; Checking if tTargetLocation '..repru(tTargetLocation)..' is in the playable area '..repru(M28Map.rMapPlayableArea)..' based on building size radius='..iNewBuildingRadius) end
                                    if (tTargetLocation[1] - iNewBuildingRadius) < M28Map.rMapPlayableArea[1] or (tTargetLocation[3] - iNewBuildingRadius) < M28Map.rMapPlayableArea[2] or (tTargetLocation[1] + iNewBuildingRadius) > M28Map.rMapPlayableArea[3] or (tTargetLocation[3] + iNewBuildingRadius) > M28Map.rMapPlayableArea[4] then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Target location isnt in playable area so will find random place to build instead') end
                                        bFindRandomLocation = not(bNeverBuildRandom)
                                        tTargetLocation = tEngineerPosition
                                    end
                                    if bDebugMessages == true then M28Utilities.DrawLocation(tTargetLocation) end
                                end
                            end
                        end
                    else
                        bFindRandomLocation = not(bNeverBuildRandom)
                        if bDebugMessages == true then LOG(sFunctionRef..': Cant find any valid buildings for adjacency') end
                    end
                else
                    --If no was adjacency wanted, then either build at the target location, or find a random location to build (subject to some unit specific points)
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have a category to build by, will look for random location unless current target is valid or we are a shield') end
                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
                        local bBuildAwayFromEnemy = false
                        if iOptionalEngiActionRef == refActionFortifyFirebase then bBuildAwayFromEnemy = true end
                        tTargetLocation = GetBuildLocationForShield(aiBrain, sBlueprintToBuild, tAlternativePositionToLookFrom, bBuildAwayFromEnemy)
                        if tTargetLocation then bFindRandomLocation = false else bFindRandomLocation = not(bNeverBuildRandom) end
                    else
                        bFindRandomLocation = not(bNeverBuildRandom)
                    end
                end
            else
                --Dealing with mex or hydro or storage
                if bDebugMessages == true then LOG(sFunctionRef..': Are trying to build a mex, hydro or storage; tTargetLocation='..repru((tTargetLocation or {}))..'; oEngineer='..GetEngineerUniqueCount(oEngineer)..'; LC='..M28UnitInfo.GetUnitLifetimeCount(oEngineer)) end
                if M28Utilities.IsTableEmpty(tTargetLocation) == true then
                    M28Utilities.ErrorHandler('Trying to build mex, hydro or storage without defined location')
                else
                    if aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation) then --and M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)]) then
                        --Not interested in if other units have queued up, as e.g. might be ACU that can build and is much closer, so just want whichever unit is closest to try and build
                        if bDebugMessages == true then LOG(sFunctionRef..': Can build structure at targetlocation='..repru(tTargetLocation)..'; if are buildling a t1 mex and there is a t3 mex queued up then will ignore though') end
                        --Are we trying to build a T1 mex? If so then only consider if have an order to build T3 mex
                        if EntityCategoryContains(refCategoryT1Mex, sBlueprintToBuild) then
                            local sLocationRef = M28Utilities.ConvertLocationToReference(tTargetLocation)
                            if aiBrain[reftEngineerAssignmentsByLocation][sLocationRef] and M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][sLocationRef][refActionBuildT3MexOverT2]) == false then
                                bAbortConstruction = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Trying to build t1 mex when want to build t3 here') end
                            end
                        end
                    else
                        --Cant build at location, is that because of enemy building blocking it, or we have a part-built building?
                        if bDebugMessages == true then LOG(sFunctionRef..': Are trying to build a mex or hydro or mass storage so cant get a random location, but we cant build a structure at the target') end
                        local tEnemyBuildingAtTarget = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, tTargetLocation, 1, 'Enemy')
                        if M28Utilities.IsTableEmpty(tEnemyBuildingAtTarget) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have enemy buildings around target') end
                            M28PlatoonUtilities.MoveNearConstruction(aiBrain, oEngineer, tTargetLocation, sBlueprintToBuild, 0, false, false, false)
                            for iUnit, oUnit in tEnemyBuildingAtTarget do
                                if oUnit.GetPosition then
                                    IssueReclaim({oEngineer}, oUnit)
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy building is at the target mex/hydro so will try and reclaim that first') end

                            IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                            if bDebugMessages == true then LOG(sFunctionRef..': 1 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation)) end
                            bAbortConstruction = true
                            bFoundEnemyInstead = true

                        else
                            local tAllyBuildingAtTarget = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, tTargetLocation, 1, 'Ally')
                            if M28Utilities.IsTableEmpty(tAllyBuildingAtTarget) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will target the ally building as its part complete') end
                                oPartCompleteBuilding = tAllyBuildingAtTarget[1]
                            else
                                --Are we stopped from building due to reclaim?

                                local tNewBuildingSize = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
                                local fSizeMod = 0.5

                                local rTargetRect = M28Utilities.GetRectAroundLocation(tTargetLocation, tNewBuildingSize[1] * fSizeMod)
                                if bDebugMessages == true then LOG(sFunctionRef..': tTargetLocation='..repru(tTargetLocation)..'; tNewBuildingSize='..repru(tNewBuildingSize)..'; rTargetRect='..repru(rTargetRect)) end
                                --GetReclaimInRectangle(iReturnType, rRectangleToSearch)
                                --iReturnType: 1 = true/false; 2 = number of wrecks; 3 = total mass, 4 = valid wrecks
                                local tReclaimables = M28Map.GetReclaimInRectangle(4, rTargetRect)

                                if M28Utilities.IsTableEmpty(tReclaimables) == false then
                                    for iReclaim, oReclaim in tReclaimables do
                                        --oEngineer:IssueReclaim(oReclaim)
                                        IssueReclaim({oEngineer}, oReclaim)
                                    end
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef..': Reclaim found that is blocking mex or hydro so will reclaim all wrecks in rectangle='..repru(rTargetRect))
                                        M28Utilities.DrawRectangle(rTargetRect, 7, 100)
                                    end

                                    IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                                    if bDebugMessages == true then LOG(sFunctionRef..': 2 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation)) end

                                else
                                    --Are we trying to build a T3 mex? If so then we probably are trying to replace a T2 mex which  can lead to problems with the canbuild check
                                    if iCategoryToBuild == M28UnitInfo.refCategoryT3Mex then
                                        IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef..': Not sure we can build here but will try anyway')
                                            LOG(sFunctionRef..': 3 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation))
                                        end
                                    else
                                        --One likely explanation is that enemy has built on the mex and we cant see the building, in which case we only want to check this for debugging purposes, and proceed with the default action of having hte engineer try to move there
                                        local tUnits = GetUnitsInRect(rTargetRect)
                                        if M28Utilities.IsTableEmpty(tUnits) == true then
                                            M28Utilities.ErrorHandler(sFunctionRef..': Cant build at resource location but no units or reclaim on it, will just try moving near the target instead. sBlueprintToBuild='..sBlueprintToBuild..'; Engineer UC='..GetEngineerUniqueCount(oEngineer)..'; LC='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Location='..repru({tTargetLocation[1], tTargetLocation[2],tTargetLocation[3]})..'; Will draw white circle around the target if in debug mode. CanBuildStructure result='..tostring(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation))..'; Is the table of assigned engineer actions empty='..tostring(M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)])), true)
                                            if bDebugMessages == true then
                                                M28Utilities.DrawLocation(tTargetLocation, nil, 7)
                                                LOG(sFunctionRef..': Cnat build at TargetLocation='..repru(tTargetLocation)..'; RectangleSearched='..repru(rTargetRect))
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will just move to the target location') end
                                        M28PlatoonUtilities.MoveNearConstruction(aiBrain, oEngineer, tTargetLocation, sBlueprintToBuild, 0, false, false, false)
                                        bAbortConstruction = true
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        --Switch to random location if an amphibious unit cant path there and its not a resource based location
        if not(bFindRandomLocation) and not(bAbortConstruction) then -- and not(bMexHydroOrStorage) then
            if not(NavUtils.GetLabel(sPathing, tTargetLocation) == NavUtils.GetLabel(sPathing, oEngineer:GetPosition())) then
                bFindRandomLocation = not(bNeverBuildRandom)
            end
        end

        if bFindRandomLocation and (bMexHydroOrStorage or EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild)) and not(bAbortConstruction) and not(iOptionalEngiActionRef == refActionFortifyFirebase) then
            --Backup - Trying to build a mex or hydro so no point getting random location
            if not(EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild)) then
                M28Utilities.ErrorHandler('Are trying to build in a random place for am ex/hydro/mass storage - figure out why as this shouldnt trigger; Engineer with UC='..GetEngineerUniqueCount(oEngineer)..'='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; trying to build blueprint='..sBlueprintToBuild)
                if bDebugMessages == true then LOG(sFunctionRef..': Trying to build mex or hydro so cant choose a random location') end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Trying to build a shield but couldnt find anywhere to build it so no point building it in the end. iOptionalEngiActionRef='..(iOptionalEngiActionRef or 'nil')) end
            end
            bFindRandomLocation = false
            bAbortConstruction = true
        end

        --Look for a random location if we failed to find a suitable location in the above steps
        if bFindRandomLocation == true and not(bAbortConstruction) then
            if bDebugMessages == true then LOG(sFunctionRef..': Are finding a random location to build unless current location is valid; sBlueprintToBuild='..sBlueprintToBuild..'; iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')) end
            if M28Utilities.IsTableEmpty(tTargetLocation) == true then tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition) end

            --First check in build area for the best location assuming the target location isnt far away
            if M28Utilities.GetDistanceBetweenPositions(tTargetLocation, tEngineerPosition) <= 30 then tTargetLocation = GetBestBuildLocationForTarget(tTargetLocation, nil, sBlueprintToBuild, true, aiBrain, true, tTargetLocation, iMaxAreaToSearch, iBuilderRange, false, true, bBuildNearToEnemy, not(bBuildNearToEnemy), false) end
            if M28Utilities.IsTableEmpty(tTargetLocation) == true or not(CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, nil, nil, nil, false, bLookForQueuedBuildings, true)) then
                --if M28Utilities.IsTableEmpty(tTargetLocation) == true or not(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation)) or not(M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)])) then
                if M28Utilities.IsTableEmpty(tTargetLocation) then tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition) end
                if bDebugMessages == true then
                    LOG(sFunctionRef..' Cant build '..sBlueprintToBuild..'; will try and find a random place to build; target location for random place to build='..repru(tTargetLocation))
                    if iCategoryToBuild == nil then LOG(sFunctionRef..' iCategoryToBuild is nil somehow') end
                end
                --FindRandomPlaceToBuild(aiBrain, oBuilder, tStartPosition, sBlueprintToBuild, iSearchSizeMin, iSearchSizeMax, bForcedDebug)
                local bSuitableForLastSuccessfulLocation = EntityCategoryContains(M28UnitInfo.refCategoryStructure + categories.EXPERIMENTAL - M28UnitInfo.refCategorySatellite - M28UnitInfo.refCategoryFirebaseSuitable, sBlueprintToBuild) and M28Utilities.IsTableEmpty(aiBrain[reftLastSuccessfulLargeBuildingLocation]) == false
                local iSearchCycles = nil
                if bSuitableForLastSuccessfulLocation then iSearchCycles = 3 end
                tTargetLocation = FindRandomPlaceToBuild(aiBrain, oEngineer, (tTargetLocation or tAlternativePositionToLookFrom or tEngineerPosition), sBlueprintToBuild, 2, iMaxAreaToSearch, bDebugMessages, iSearchCycles)
                if M28Utilities.IsTableEmpty(tTargetLocation) == true then
                    --Try searching the last location we built at successfully for a couple of cycles if arent building a firebase unit
                    if bSuitableForLastSuccessfulLocation then
                        tTargetLocation = FindRandomPlaceToBuild(aiBrain, oEngineer, aiBrain[reftLastSuccessfulLargeBuildingLocation], sBlueprintToBuild, 2, iMaxAreaToSearch, false, math.min(3, (iSearchCycles or 3)))
                    end
                    if M28Utilities.IsTableEmpty(tTargetLocation) then
                        LOG(sFunctionRef..': WARNING - couldnt find a random place to build based on position='..repru(tTargetLocation)..'; will abort construction')
                        bAbortConstruction = true
                    end
                elseif bDebugMessages == true then LOG(sFunctionRef..': Found random place to build='..repru(tTargetLocation))
                end
            else if bDebugMessages == true then LOG(sFunctionRef..': No need for random place as current targetlocation is valid, ='..repru(tTargetLocation)) end
            end
        end
        --Only proceed with sending a build order (or repair order for a part complete building) if we had success in the earlier steps
        if bAbortConstruction == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Not aborting function so will try to move near construction if we have a valid location') end
            if M28Utilities.IsTableEmpty(tTargetLocation) == false and sBlueprintToBuild then
                --Adjust Target location if building PD
                if EntityCategoryContains(M28UnitInfo.refCategoryPD, sBlueprintToBuild) then
                    tTargetLocation = AdjustPDBuildLocation(aiBrain, tTargetLocation, sBlueprintToBuild)
                end
                --MoveNearConstruction(aiBrain, oBuilder, tLocation, sBlueprintID, iBuildDistanceMod, bReturnMovePathInstead, bUpdatePlatoonMovePath, bReturnNilIfAlreadyMovingNearConstruction, bReturnMoveLocationifGivenOne)
                local tMoveNearTargetLocation = M28PlatoonUtilities.MoveNearConstruction(aiBrain, oEngineer, tTargetLocation, sBlueprintToBuild, 0, false, false, false, true)
                if oPartCompleteBuilding then
                    if bDebugMessages == true then LOG(sFunctionRef..': Send order for oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to repair '..oPartCompleteBuilding.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPartCompleteBuilding)..' at '..repru(oPartCompleteBuilding:GetPosition())) end

                    IssueRepair({ oEngineer}, oPartCompleteBuilding)
                else
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Send order for oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to build '..sBlueprintToBuild..' at '..repru(tTargetLocation)..'; will draw target location in gold')
                        M28Utilities.DrawLocation(tTargetLocation, nil, 4, 500)
                    end

                    --MAIN ISSUEBUILDMOBILE FOR CONSTRUCTION (i.e. other issuebuilds here are for specific actions)
                    IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                    if bDebugMessages == true then LOG(sFunctionRef..': 4 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation)..' with surface height='..GetSurfaceHeight(tTargetLocation[1], tTargetLocation[3])..'; tMoveNearTargetLocation='..repru(tMoveNearTargetLocation)) end
                end
                if M28Utilities.IsTableEmpty(tMoveNearTargetLocation) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to start thread checking for when the engineer is in build range') end
                    ForkThread(TrackWhenEngineerInBuildRange, oEngineer, tMoveNearTargetLocation, (sBlueprintToBuild or oPartCompleteBuilding.UnitId), tTargetLocation, oPartCompleteBuilding)
                    if sBlueprintToBuild and not(oPartCompleteBuilding) then
                        ForkThread(CheckIfEngineerLikelyStuck, oEngineer, sBlueprintToBuild, tTargetLocation)
                    end

                end
            end
        else
            if bDebugMessages == true then LOG('Warning - couldnt find any places to build after looking randomly nearby, will abort construction. bFoundEnemyInstead='..tostring(bFoundEnemyInstead)) end
            if bDebugMessages == true then
                LOG(sFunctionRef..': Aborted construction, will draw target location in red')
                M28Utilities.DrawLocation(tTargetLocation, nil, 2, 100)
            end
            if not(bMexHydroOrStorage) then tTargetLocation = nil end
        end
    end
    if bDebugMessages == true then
        if sBlueprintToBuild == nil then LOG('sBlueprintToBuild is nil')
        else
            if tTargetLocation then
                LOG(sFunctionRef..': tTargetLocation='..repru(tTargetLocation)..'; aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation)='..tostring(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation))..'; sBlueprintToBuild='..(sBlueprintToBuild or 'nil'))
                if not(bAbortConstruction) then M28Utilities.DrawLocation(tTargetLocation, nil, 7, 100) end --show in white (colour 7)
                LOG(sFunctionRef..': About to list any units in 1x1 rectangle around targetlocation')
                local iSizeAdj = 3
                local rBuildAreaRect = Rect(tTargetLocation[1] - iSizeAdj, tTargetLocation[3] - iSizeAdj, tTargetLocation[1] + iSizeAdj, tTargetLocation[3] + iSizeAdj)
                local tUnitsInRect = GetUnitsInRect(rBuildAreaRect)
                local tsUnitRefs = {}
                if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                    for iUnit, oUnit in tUnitsInRect do
                        table.insert(tsUnitRefs, iUnit, oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
                    end
                end
                LOG('tsUnitRefs='..repru(tsUnitRefs))
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tTargetLocation
end

function GetPartCompleteBuilding(aiBrain, oBuilder, iCategoryToBuild, iBuildingSearchRange)
    --Returns nil if no nearby part complete building
    --iEnemySearchRange: nil if dont care about nearby enemies, otherwise will ignore buildings that have enemies within iEnemySearchRange
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPartCompleteBuilding'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tBuilderPosition = oBuilder:GetPosition()
    local tAllBuildings = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, tBuilderPosition, iBuildingSearchRange, 'Ally')
    local iCurDistanceToBuilder
    local iMinDistanceToBuilder = 10000
    local tBuildingPosition
    local oNearestPartCompleteBuilding
    if M28Utilities.IsTableEmpty(tAllBuildings) == false then
        for iBuilding, oBuilding in tAllBuildings do
            --Dont try and compelte part built shields as may be part built due to special shielding logic
            if oBuilding.GetFractionComplete and oBuilding.GetPosition and oBuilding:GetFractionComplete() < 1 and not(EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oBuilding.UnitId)) then
                local tNearbyEnemies
                tBuildingPosition = oBuilding:GetPosition()
                iCurDistanceToBuilder = M28Utilities.GetDistanceBetweenPositions(tBuildingPosition, tBuilderPosition)
                if iCurDistanceToBuilder < iMinDistanceToBuilder then
                    iMinDistanceToBuilder = iCurDistanceToBuilder
                    oNearestPartCompleteBuilding = oBuilding
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oNearestPartCompleteBuilding
end

function SlowlyRefreshBuildableLandZoneLocations(oOrigBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SlowlyRefreshBuildableLandZoneLocations'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    bBuildLocationLoopActive = true
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iSearchesConsideredThisTick
    local iTicksWaitedThisCycle
    local iSegmentsBeforeWaiting
    if GetGameTimeSeconds() >= 600 or M28Overseer.refiRoughTotalUnitsInGame >= 500 then iSegmentsBeforeWaiting = 16 --Must be a multiple of 2, i.e. 2^x results in this
    else iSegmentsBeforeWaiting = 32
    end
    local aiBrain = oOrigBrain

    --First update every start position that has an M28 brain to make sure we have a decent number of options recorded for a land factory and smaller
    for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
        if bDebugMessages == true then LOG(sFunctionRef..': About to start recording buildable locations for the starting land zone for oBrain='..oBrain.Nickname..'; Index='..oBrain:GetArmyIndex()..'; Start pos='..repru(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])) end
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
        if (iLandZone or 0) > 0 then
                --SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iOptionalMaxSegmentsToConsider)
            SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateau, iLandZone, iSegmentsBeforeWaiting * 10)

            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    end

    while true do
        --Get a new brain if needed
        if aiBrain.M28IsDefeated then
            aiBrain = nil
            for iBrain, oBrain in ArmyBrains do
                if oBrain.M28AI and not(oBrain.M28IsDefeated) then
                    aiBrain = oBrain
                    break
                end
            end
            if not(aiBrain) then
                break
            end
        end

        iTicksWaitedThisCycle = 0
        iSearchesConsideredThisTick = 0

        --Cycle through every plateau
        for iPlateau, tPlateauSubtable in M28Map.tAllPlateaus do
            for iLandZone, tLandZoneInfo in tPlateauSubtable[M28Map.subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Updating for iPlateau='..iPlateau..'; iLandZone='..iLandZone) end
                if tLandZoneInfo[M28Map.subrefBuildLocationsBySizeAndSegment] then
                    if tLandZoneInfo[M28Map.subrefLZTotalSegmentCount] >= 80 or tLandZoneInfo[M28Map.subrefLZMexCount] > 0 then
                        --SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iOptionalMaxSegmentsToConsider)
                        SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateau, iLandZone, iSegmentsBeforeWaiting)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        iTicksWaitedThisCycle = iTicksWaitedThisCycle + 1
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    end
                end
                iTicksWaitedThisCycle = iTicksWaitedThisCycle + 1
            end
        end
        if iTicksWaitedThisCycle < 1000 then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1000 - iTicksWaitedThisCycle)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            iSegmentsBeforeWaiting = math.max(2, iSegmentsBeforeWaiting * 0.5)
        elseif iTicksWaitedThisCycle >= 3000 then
            iSegmentsBeforeWaiting = math.min(64, iSegmentsBeforeWaiting * 2)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordBuildableCoreWaterZoneLocationsNearStartOfGame()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordBuildableCoreWaterZoneLocationsNearStartOfGame'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    bWZBuildLocationLoopActive = true
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iSearchesConsideredThisTick
    local iTicksWaitedThisCycle
    local iSegmentsBeforeWaiting = 16 --Must be a multiple of 2, i.e. 2^x results in this

    local tWZShortlistByWZ = {} --Index is WZ

    local iCurWZ
    local aiBrain
    --Get the naval build locations for each M28 brain to create a shortlist that will be cycled through
    for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
        aiBrain = oBrain
        if M28Utilities.IsTableEmpty(M28Map.tPondDetails) == false then
            for iPond, tPondSubtable in M28Map.tPondDetails do
                if M28Utilities.IsTableEmpty(tPondSubtable[M28Map.subrefBuildLocationByStartPosition]) == false then
                    for iEntry, tPosition in tPondSubtable[M28Map.subrefBuildLocationByStartPosition] do
                        iCurWZ = M28Map.GetWaterZoneFromPosition(tPosition)
                        if (iCurWZ or 0) > 0 then
                            tWZShortlistByWZ[iCurWZ] = true
                        end
                    end
                end
            end
        end
    end
    local tWZShortlist = {}
    if M28Utilities.IsTableEmpty(tWZShortlistByWZ) == false then
        for iWZ, bInclude in tWZShortlistByWZ do
            table.insert(tWZShortlist, iWZ)
        end
    end

    if M28Utilities.IsTableEmpty(tWZShortlist) == false then
        --First ensure we have basic sizes for the WZ and some entries
        for iEntry, iWaterZone in tWZShortlist do
            SearchForBuildableLocationsForLandOrWaterZone(aiBrain, 0, iWaterZone, iSegmentsBeforeWaiting)
        end

        local iTotalCycles = 0

        while iTotalCycles <= 100 do
            iTotalCycles = iTotalCycles + 1
            --Get a new brain if needed
            if aiBrain.M28IsDefeated then
                aiBrain = nil
                for iBrain, oBrain in ArmyBrains do
                    if oBrain.M28AI and not(oBrain.M28IsDefeated) then
                        aiBrain = oBrain
                        break
                    end
                end
                if not(aiBrain) then
                    break
                end
            end

            iTicksWaitedThisCycle = 0
            iSearchesConsideredThisTick = 0

            --Cycle through every entry
            for iEntry, iWaterZone in tWZShortlist do
                        --SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iOptionalMaxSegmentsToConsider)
                SearchForBuildableLocationsForLandOrWaterZone(aiBrain, 0, iWaterZone, iSegmentsBeforeWaiting)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                iTicksWaitedThisCycle = iTicksWaitedThisCycle + 1
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DecideOnExperimentalToBuild(iActionToAssign, aiBrain, tbEngineersOfFactionOrNilIfAlreadyAssigned, tLZOrWZData, tLZOrWZTeamData)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DecideOnExperimentalToBuild'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iFactionRequired
    local iCategoryWanted
    if not(tbEngineersOfFactionOrNilIfAlreadyAssigned) then
        if bDebugMessages == true then LOG(sFunctionRef..': Already have unit under construction so will return experimentallevel') end
        iCategoryWanted = M28UnitInfo.refCategoryExperimentalLevel --Already have the unit under construction
    else
        --Do we have an experimental level unit under construciton in this LZ?
        local tExperimentalsInLZ
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
            tExperimentalsInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryExperimentalLevel, tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits])
            if M28Utilities.IsTableEmpty(tExperimentalsInLZ) == false then
                for iUnit, oUnit in tExperimentalsInLZ do
                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() < 1 and oUnit:GetFractionComplete() > 0.001 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Setting category to experimental level as have part complete experimental') end
                        iCategoryWanted = M28UnitInfo.refCategoryExperimentalLevel
                        break
                    end
                end
            end
        end
        if not(iCategoryWanted) then

            --Land subteam - use aiBrain.M28LandSubteam
            local iSubteamSize =  table.getn(M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subreftoFriendlyM28Brains])
            local iEnemyLandExperimentalCount = table.getn(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftEnemyLandExperimentals])
            local iTeam = aiBrain.M28Team
            local iDistToNearestEnemyBase = M28Utilities.GetDistanceBetweenPositions(tLZOrWZTeamData[M28Map.reftClosestEnemyBase], tLZOrWZData[M28Map.subrefMidpoint])
            local bCanPathByLand
            local bCanPathAmphibiously
            if NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZOrWZData[M28Map.subrefMidpoint]) == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) then
                bCanPathByLand = true
            else bCanPathByLand = false
            end
            if NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, tLZOrWZData[M28Map.subrefMidpoint]) == NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) then
                bCanPathAmphibiously = true
            else bCanPathAmphibiously = false
            end

            --Non-faction specific logic:

            --Initial land experimental (very high priority subject to map)
            local iTeamLandExperimentals = 0
            for iBrain, oBrain in M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subreftoFriendlyM28Brains] do
                iTeamLandExperimentals = iTeamLandExperimentals + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandExperimental)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iTeamLandExperimentals='..iTeamLandExperimentals..'; bCanPathByLand='..tostring(bCanPathByLand)..'; bCanPathAmphibiously='..tostring(bCanPathAmphibiously)) end
            if iTeamLandExperimentals == 0 and bCanPathByLand then
                iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                if bDebugMessages == true then LOG(sFunctionRef..': Is Cybran engineers of faction available='..tostring(tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionCybran] or false)..'; Lifetime land experimental count='..M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandExperimental)) end
                if tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionCybran] then
                    if M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandExperimental) < 2 then
                        iCategoryWanted = M28UnitInfo.refCategoryMonkeylord
                        iFactionRequired = M28UnitInfo.refFactionCybran
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to build a monkeylord') end
                    else
                        iCategoryWanted = M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategoryMonkeylord
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to build a megalith or other land experimental that isnt a monkeylord')
                        end
                    end
                end
            else
                --Consider getting nukes
                if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] then --dont want nuke built too far from base
                    --Do we already have nukes?
                    if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategorySML, tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits])) then
                        --Do teammates have no more than 1 nuke?
                        local iTeamNukes = 0
                        for iBrain, oBrain in M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subreftoFriendlyM28Brains] do
                            iTeamNukes = iTeamNukes + oBrain:GetCurrentUnits(M28UnitInfo.refCategorySML)
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iTeamNukes='..iTeamNukes) end
                        if iTeamNukes <= 1 or (iTeamNukes == 1 and M28Map.iMapSize <= 512) then
                            local iHighestNukeTargetValue = M28Building.GetHighestNukeTargetValue(tLZOrWZData, tLZOrWZTeamData, aiBrain.M28Team)
                            if bDebugMessages == true then LOG(sFunctionRef..': iHighestNukeTargetValue='..iHighestNukeTargetValue..'; Team gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]) end
                            if iHighestNukeTargetValue >= 18000 and (iHighestNukeTargetValue >= 30000 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 750) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to get a nuke') end
                                iCategoryWanted = M28UnitInfo.refCategorySML
                            end
                        end
                    end
                end
            end
            if not(iCategoryWanted) then
                --FACTION SPECIFIC LOGIC

                --UEF EXPERIMENTAL CHOICE
                if tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionUEF] then
                    --Decide between fatboy and novax, or (with v.high eco) mavor
                    iFactionRequired = M28UnitInfo.refFactionUEF
                    local iCurFatboyCount = 0
                    local iCurNovaxCount = 0
                    local iCurT3ArtiCount = 0 --mavor treated as 3 t3 arti
                    --How many fatboys do we have on the subteam already?
                    for iBrain, oBrain in M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subreftoFriendlyM28Brains] do
                        iCurFatboyCount = iCurFatboyCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryFatboy)
                        iCurNovaxCount = iCurNovaxCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryNovaxCentre)
                        iCurT3ArtiCount = iCurT3ArtiCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti) + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryExperimentalArti) * 3
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering UEF specific, iCurFatboyCount='..iCurFatboyCount..'; iCurNovaxCount='..iCurNovaxCount..'; iCurT3AritCount='..iCurT3ArtiCount) end
                    if bCanPathByLand then
                        if iCurFatboyCount == 0 then
                            iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                        elseif iCurNovaxCount == 0 then
                            iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                        elseif iCurFatboyCount < math.max(math.min(3, 1 + iSubteamSize, 1 + iEnemyLandExperimentalCount), iCurT3ArtiCount + math.max(0, iCurT3ArtiCount - 3)) then
                            iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                        else
                            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 80 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 20000 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 110) then
                                iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                            else
                                --Novax or T3 arti
                                if iCurNovaxCount < 3 + iCurT3ArtiCount then
                                    iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                                else
                                    if iDistToNearestEnemyBase <= 750 then
                                        iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                    else
                                        iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                                    end
                                end
                            end
                        end
                    else
                        --Cant path with land - prioritise novax more
                        if iCurFatboyCount == 0 and iEnemyLandExperimentalCount > 0 then
                            iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                        else
                            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 90 then
                                iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                            else
                                --Novax or T3 arti
                                if iCurNovaxCount < 3 + iCurT3ArtiCount then
                                    iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                                else
                                    if iDistToNearestEnemyBase <= 750 then
                                        iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                    else
                                        iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                                    end
                                end
                            end
                        end
                    end
                    --SERAPHIM EXPERIMENTAL CHOICE
                elseif tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionSeraphim] then
                    iFactionRequired = M28UnitInfo.refFactionSeraphim
                    --Build ahwassa if have air contorl or cant path to enemy with land
                    local iGameEnderCount = 0
                    local iAhwassaCount = 0
                    for iBrain, oBrain in M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subreftoFriendlyM28Brains] do
                        iGameEnderCount = iGameEnderCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryGameEnder)
                        iAhwassaCount = iAhwassaCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL)
                    end
                    if not(bCanPathByLand) or M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl] or (not(M28Team.tTeamData[iTeam][M28Team.refbFarBehindOnAir]) and iTeamLandExperimentals >= math.max(1, iEnemyLandExperimentalCount)) or (iTeamLandExperimentals > iEnemyLandExperimentalCount + 2) then
                        if (iGameEnderCount == 0 or iGameEnderCount * 3 <= iAhwassaCount) and (not(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl]) and iDistToNearestEnemyBase >= 300 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 90) then
                            iCategoryWanted = M28UnitInfo.refCategorySML * categories.EXPERIMENTAL
                        else
                            iCategoryWanted = M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL
                        end
                    else
                        --Consider building a yolona instead of a ythotha (or ahwassa instead of either)
                        if iTeamLandExperimentals >= 3 + 3 * (aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti) + iGameEnderCount * 2) and ((iTeamLandExperimentals >= math.max(5, iEnemyLandExperimentalCount + 1) or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandExperimental) >= 3 + iGameEnderCount) or (iGameEnderCount == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 80)) then
                            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 70 and iDistToNearestEnemyBase <= 750 then
                                local iT3ArtiCount = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti)
                                if iAhwassaCount < (iT3ArtiCount + iGameEnderCount * 3) and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL) < 2 + (iT3ArtiCount + iGameEnderCount * 3) then
                                    iCategoryWanted = M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL
                                elseif iT3ArtiCount < 4 then
                                    iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                else
                                    iCategoryWanted = M28UnitInfo.refCategorySML * categories.EXPERIMENTAL
                                end
                            else
                                if iAhwassaCount < iGameEnderCount * 3 and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL) < 2 + iGameEnderCount * 3 then
                                    iCategoryWanted = M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL
                                else
                                    iCategoryWanted = M28UnitInfo.refCategorySML * categories.EXPERIMENTAL
                                end
                            end
                        else
                            --If have 5+ land experimentals then consider an ahwassa even if lack air control
                            if (iAhwassaCount + 1) * 2 + 3 < iTeamLandExperimentals then
                                iCategoryWanted = M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL
                            else
                                iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                                --If have Aeon then get GC in preference to Ythotha
                                if tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionAeon] then iFactionRequired = M28UnitInfo.refFactionAeon end
                            end
                        end
                    end
                elseif tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionCybran] then
                    iFactionRequired = M28UnitInfo.refFactionCybran
                    --If cant path to enemy with amphibious (rather than land) then consider T3 arti
                    if not(bCanPathAmphibiously) or iTeamLandExperimentals >=  math.max(5, iEnemyLandExperimentalCount * 1.25) then
                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 80 and iDistToNearestEnemyBase <= 750 then
                            if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti) < 4 then
                                iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                iFactionRequired = nil
                            else
                                iCategoryWanted = M28UnitInfo.refCategoryExperimentalStructure --i.e. scathis
                            end
                        else
                            iCategoryWanted = M28UnitInfo.refCategoryExperimentalStructure --this includes scathis
                        end
                    else
                        if not(bCanPathByLand) then
                            iCategoryWanted = M28UnitInfo.refCategoryMegalith --megalith has better torps
                        else
                            if iTeamLandExperimentals == 0 then
                                iCategoryWanted = M28UnitInfo.refCategoryMonkeylord
                            else
                                --Get megalith
                                iCategoryWanted = M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategoryMonkeylord --i.e. megalith (but slightly more helpful to mods doing it this way)
                            end
                        end
                    end
                elseif tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionAeon] then
                    iFactionRequired = M28UnitInfo.refFactionAeon
                    if not(bCanPathAmphibiously) or (not(bCanPathByLand) and iDistToNearestEnemyBase >= 350 and iEnemyLandExperimentalCount == 0) or iTeamLandExperimentals >= math.max(5, iEnemyLandExperimentalCount + 1) then
                        if iDistToNearestEnemyBase <= 750 then
                            if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti) < 4 then
                                iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                            else
                                iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                            end
                        else
                            iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                        end
                    else
                        --Build GC
                        iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                        --Dont reset faction requirement as GC is better than most other factions
                    end
                else
                    --Not dealing with standard faction - basic choice between land and T3 arti/experimental structure, since unlikely to have hte logic in place for other units
                    if not(bCanPathAmphibiously) then
                        iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalStructure
                    else
                        --can path to enemy with land
                        local iBaseAdjust = 0
                        if iDistToNearestEnemyBase >= 400 then
                            if iDistToNearestEnemyBase >= 750 then iBaseAdjust = -2
                            else iBaseAdjust = -1
                            end
                        end
                        if iTeamLandExperimentals <= math.max(iEnemyLandExperimentalCount + 2 + iBaseAdjust, 3 + iBaseAdjust) then
                            iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                        else
                            iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalStructure
                        end
                    end
                end
            end
        end
    end
    if not(iCategoryWanted) then iCategoryWanted = M28UnitInfo.refCategoryLandExperimental end --redundancy
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, will list out all blueprints meeting iCategoryWanted. iFactionRequired='..(iFactionRequired or 'nil'))
        local tBlueprints = EntityCategoryGetUnitList(iCategoryWanted)
        LOG('Blueprints='..repru(tBlueprints))
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iCategoryWanted, iFactionRequired
end

function CheckForNearbyEnemies()  end --This is incorporated into available engineers by tech - added to make it easier to locate logic
function FilterToAvailableEngineersByTech(tEngineers, bInCoreZone, tLZData, tLZTeamData, iTeam, iPlateauOrPond, iLandZone, bIsWaterZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'FilterToAvailableEngineersByTech'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..' for iPlateauOrPond='..iPlateauOrPond..'; iLandZone='..iLandZone..'; reprs of tEngineers='..reprs(tEngineers)) end

    --Returns a table of available engineers by tech
    local toAvailableEngineersByTech = {[1]= { },[2]={},[3]={}}
    local toAssignedEngineers = {}
    local bHaveAvailableEngi = false
    local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
    --local tNearbyEnemiesByZone = {}
    local bCheckForEnemies = false
    if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then --M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
        --table.insert(tNearbyEnemiesByZone, tLZTeamData[M28Map.subrefTEnemyUnits])
        bCheckForEnemies = true
    end

    --[[if bIsWaterZone then
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefWZOtherWaterZones]) == false then
            local iAdjWZ
            for _, tWZSubtable in  tLZData[M28Map.subrefWZOtherWaterZones] do
                iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]

                if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                    table.insert(tNearbyEnemiesByZone, M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits])
                    bCheckForEnemies = true
                end
            end
        end
    elseif M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjacentLZ in  tLZData[M28Map.subrefLZAdjacentLandZones] do
            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iAdjacentLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                table.insert(tNearbyEnemiesByZone, M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iAdjacentLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits])
                bCheckForEnemies = true
            end
        end
    end--]]
    --if bDebugMessages == true then LOG(sFunctionRef..': Finished deciding if should check for enemies (based on if enemy threats in this or nearby LZ), bCheckForEnemies='..tostring(bCheckForEnemies)..'; Is table of enemy units for this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))..'; is tNearbyEnemiesByZone empty='..tostring(M28Utilities.IsTableEmpty(tNearbyEnemiesByZone))..'; subrefLZThreatEnemyMobileDFTotalin this LZ='..(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)) end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished deciding if should check for enemies (based on if enemy threats in this or nearby LZ), bCheckForEnemies='..tostring(bCheckForEnemies)..'; If get units aroundpoint with radius of 30 is the table of units empty='..tostring(M28Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategorySubmarine, tLZData[M28Map.subrefMidpoint], 30, 'Enemy')))) end

    local iClosestDistUntilInRangeOfMobileEnemy = 100000
    local iClosestDistUntilInRangeOfStaticEnemy = 100000
    local iNearestReclaimableEnemy = 100000
    local iNearestEnemy = 100000
    local oNearestReclaimableEnemy
    local oNearestEnemy
    local iCurDistToEnemy
    local iCurDistUntilInRange
    local iCurUnitRange
    local bWantEngiToRun
    local bEngiIsUnavailable

    local iLZOrWZToRunTo
    local iThresholdToRunFromMobileEnemies = 35
    if bInCoreZone then iThresholdToRunFromMobileEnemies = 10 end

    local iEnemyUnitSearchRange = iThresholdToRunFromMobileEnemies + math.max(10, (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0), (tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0), (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0), (tLZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0), (tLZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] or 0))

    if tEngineers then
        if bDebugMessages == true then LOG(sFunctionRef..': iEnemyUnitSearchRange='..iEnemyUnitSearchRange..'; iThresholdToRunFromMobileEnemies='..iThresholdToRunFromMobileEnemies) end
        for iEngineer, oEngineer in tEngineers do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering engineer '..(oEngineer.UnitId or 'nil')..'; iEngineer='..iEngineer..' with unit state='..M28UnitInfo.GetUnitState(oEngineer)..'; refiAssignedAction='..(oEngineer[refiAssignedAction] or 'nil')) end
            bWantEngiToRun = false
            bEngiIsUnavailable = false
            if not(oEngineer:IsUnitState('Attached')) and not(oEngineer[M28UnitInfo.refbSpecialMicroActive]) then
                --First check for enemies that we want to run from/take action from
                if bCheckForEnemies then
                    --If engi is building emergency PD or Arti then dont run
                    if not(oEngineer[refiAssignedAction] == refActionBuildEmergencyPD or oEngineer[refiAssignedAction] == refActionBuildEmergencyArti) then
                        --Is the engineer reclaiming, or alternatively building something whose fraction complete is almost done?
                        if not(oEngineer:IsUnitState('Reclaiming') or ((oEngineer:IsUnitState('Repairing') or oEngineer:IsUnitState('Building')) and oEngineer:GetFocusUnit() and oEngineer:GetFocusUnit():GetFractionComplete() >= 0.9 and oEngineer:GetFocusUnit():GetFractionComplete() < 1) or (oEngineer:IsUnitState('Capturing') and oEngineer:GetWorkProgress() >= 0.75)) then
                            local tNearbyEnemiesByZone = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategorySubmarine, oEngineer:GetPosition(), iEnemyUnitSearchRange, 'Enemy')
                            --for iSubtable, tSubtable in tNearbyEnemiesByZone do
                            --if M28Utilities.IsTableEmpty(tSubtable) == false then
                            --for iUnit, oUnit in tSubtable do
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby enemies empty for engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'='..tostring(M28Utilities.IsTableEmpty(tNearbyEnemiesByZone))) end
                            if M28Utilities.IsTableEmpty(tNearbyEnemiesByZone) == false then
                                for iUnit, oUnit in tNearbyEnemiesByZone do
                                    if not(oUnit.Dead) then
                                        iCurUnitRange = (oUnit[M28UnitInfo.refiDFRange] or 0) + (oUnit[M28UnitInfo.refiIndirectRange] or 0)
                                        if bIsWaterZone then iCurUnitRange = math.max(iCurUnitRange, (oUnit[M28UnitInfo.refiAntiNavyRange] or 0)) end
                                        iCurDistToEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEngineer:GetPosition())
                                        if iCurDistToEnemy < iNearestEnemy then
                                            iNearestEnemy = iCurDistToEnemy
                                            oNearestEnemy = oUnit
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurUnitRange='..iCurUnitRange..'; iCurDistToEnemy='..iCurDistToEnemy..'; Is reclaimable='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryReclaimable, oUnit.UnitId))) end
                                        if iCurDistToEnemy < iNearestReclaimableEnemy and EntityCategoryContains(M28UnitInfo.refCategoryReclaimable, oUnit.UnitId) then
                                            iNearestReclaimableEnemy = iCurDistToEnemy
                                            oNearestReclaimableEnemy = oUnit
                                        end
                                        --Ignore land scouts and similar unthreatening units
                                        if iCurUnitRange > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) then
                                            iCurDistUntilInRange = iCurDistToEnemy - iCurUnitRange
                                            if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then
                                                if iCurDistUntilInRange < iClosestDistUntilInRangeOfMobileEnemy then iClosestDistUntilInRangeOfMobileEnemy = iCurDistUntilInRange end
                                            else
                                                if iCurDistUntilInRange < iClosestDistUntilInRangeOfStaticEnemy then iClosestDistUntilInRangeOfStaticEnemy = iCurDistUntilInRange end
                                            end
                                        end
                                    end
                                end
                                --end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Checking for nearby enemies for engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; iNearestReclaimableEnemy='..iNearestReclaimableEnemy..'; iClosestDistUntilInRangeOfStaticEnemy='..iClosestDistUntilInRangeOfStaticEnemy) end

                            if iNearestReclaimableEnemy < 20 and ((iClosestDistUntilInRangeOfStaticEnemy >= 10 and iNearestReclaimableEnemy <= oEngineer:GetBlueprint().Economy.MaxBuildDistance) or iNearestReclaimableEnemy <= (oEngineer:GetBlueprint().Economy.MaxBuildDistance + 7)) then
                                --Reclaim enemy
                                bEngiIsUnavailable = true

                                if oNearestReclaimableEnemy[M28UnitInfo.refbIsCaptureTarget] then
                                    TrackEngineerAction(oEngineer, refActionCaptureUnit, false, 1)
                                    M28Orders.IssueTrackedCapture(oEngineer, oNearestReclaimableEnemy, false, 'CapE')
                                    if bDebugMessages == true then LOG(sFunctionRef..': Told engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to capture enemy unit') end
                                else
                                    TrackEngineerAction(oEngineer, refActionReclaimEnemyUnit, false, 1)
                                    M28Orders.IssueTrackedReclaim(oEngineer, oNearestReclaimableEnemy, false, 'RecE')
                                    if bDebugMessages == true then LOG(sFunctionRef..': Told engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to reclaim enemy unit') end
                                end
                            else
                                --Enemy not close enough to reclaim, do we want to run?
                                if not(tLZTeamData[M28Map.subrefLZbCoreBase]) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Not close enough to reclaim enemy, and not a core LZ, iClosestDistUntilInRangeOfStaticEnemy='..iClosestDistUntilInRangeOfStaticEnemy..'; iClosestDistUntilInRangeOfMobileEnemy='..iClosestDistUntilInRangeOfMobileEnemy..'; iThresholdToRunFromMobileEnemies='..iThresholdToRunFromMobileEnemies) end
                                    if iClosestDistUntilInRangeOfStaticEnemy < 8 or iClosestDistUntilInRangeOfMobileEnemy <= iThresholdToRunFromMobileEnemies then
                                        local tPositionToRunFrom
                                        if oNearestEnemy then tPositionToRunFrom = oNearestEnemy:GetPosition() end
                                        if not(bIsWaterZone) then
                                            iLZOrWZToRunTo =  M28Land.GetLandZoneToRunTo(iTeam, iPlateauOrPond, iLandZone, M28Map.refPathingTypeHover, oEngineer:GetPosition(), tPositionToRunFrom)
                                            if not(iLZOrWZToRunTo == iLandZone) and iLZOrWZToRunTo then --If LZ to run to is same as cur LZ might as well use engineer normally (e.g. might have defences to build)
                                                --Run to the LZ
                                                M28Orders.IssueTrackedMove(oEngineer, M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLZOrWZToRunTo][M28Map.subrefMidpoint], 8, false, 'RunTo'..iLZOrWZToRunTo)
                                                bEngiIsUnavailable = true
                                                TrackEngineerAction(oEngineer, refActionRunToLandZone, false, 1, {iPlateauOrPond, iLZOrWZToRunTo})
                                            end
                                        else
                                            iLZOrWZToRunTo = M28Navy.GetWaterZoneToRunTo(iTeam, iPlateauOrPond, iLandZone, M28Map.refPathingTypeHover, oEngineer:GetPosition(), tPositionToRunFrom)
                                            if not(iLZOrWZToRunTo == iLandZone) then --If LZ to run to is same as cur LZ might as well use engineer normally (e.g. might have defences to build)
                                                --Run to the LZ
                                                M28Orders.IssueTrackedMove(oEngineer, M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iLZOrWZToRunTo][M28Map.subrefMidpoint], 8, false, 'NRunTo'..iLZOrWZToRunTo)
                                                bEngiIsUnavailable = true
                                                TrackEngineerAction(oEngineer, refActionRunToWaterZone, false, 1, nil, iLZOrWZToRunTo)
                                            else
                                                --Consider moving to land zone instead if there is an adjacent LZ
                                                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentLandZones]) == false then
                                                    local tClosestRallyPoint
                                                    local iClosestRallyPointDist = 100000
                                                    local iCurRallyPointDist
                                                    for iEntry, tLZSubtable in tLZData[M28Map.subrefAdjacentLandZones] do
                                                        local tCurRallyPoint = M28Land.GetNearestLandRallyPoint(tLZData, iTeam, tLZSubtable[M28Map.subrefWPlatAndLZNumber][1], tLZSubtable[M28Map.subrefWPlatAndLZNumber][2], nil)
                                                        if tCurRallyPoint then
                                                            iCurRallyPointDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tCurRallyPoint)
                                                            if iCurRallyPointDist < iClosestRallyPointDist then
                                                                tClosestRallyPoint = {tCurRallyPoint[1], tCurRallyPoint[2], tCurRallyPoint[3]}
                                                                iClosestRallyPointDist = iCurRallyPointDist
                                                            end
                                                        end
                                                    end
                                                    if tClosestRallyPoint then
                                                        local iPlateau, iLZToRunTo = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tClosestRallyPoint)
                                                        M28Orders.IssueTrackedMove(oEngineer, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZToRunTo][M28Map.subrefMidpoint], 8, false, 'WLRunTo'..iLZOrWZToRunTo)
                                                        bEngiIsUnavailable = true
                                                        TrackEngineerAction(oEngineer, refActionRunToLandZone, false, 1, {iPlateau, iLZToRunTo})
                                                    end
                                                end
                                            end
                                        end
                                    else
                                        --We arent yet close enough that we want to run so do nothing
                                    end
                                end
                            end
                        end
                    end
                end
            else
                bEngiIsUnavailable = true
            end


            --Finished checking for enemies; now check more generally if engineer is busy
            if not(bEngiIsUnavailable) then
                bEngiIsUnavailable = not(M28Conditions.IsEngineerAvailable(oEngineer))
                if bDebugMessages == true then LOG(sFunctionRef..': Entry in table='..iEngineer..'; Considering if engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' is available, result='..tostring(M28Conditions.IsEngineerAvailable(oEngineer, true))..'; Eng unit state='..M28UnitInfo.GetUnitState(oEngineer)..'; bEngiIsUnavailable='..tostring(bEngiIsUnavailable)) end
            end
            if bEngiIsUnavailable then
                table.insert(toAssignedEngineers, oEngineer)
            else
                --Clear engineer trackers as redundancy in case failed to clear previously
                if oEngineer[refiAssignedAction] then ClearEngineerTracking(oEngineer) end

                table.insert(toAvailableEngineersByTech[M28UnitInfo.GetUnitTechLevel(oEngineer)], oEngineer)
                if bDebugMessages == true then LOG(sFunctionRef..': Just added engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to toAvailableEngineersByTech, Eng tech level='..M28UnitInfo.GetUnitTechLevel(oEngineer)..'; Size of table='..table.getn(toAvailableEngineersByTech[M28UnitInfo.GetUnitTechLevel(oEngineer)])) end
                bHaveAvailableEngi = true
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished recording available engineers, Is tEngineers empty='..tostring(M28Utilities.IsTableEmpty(tEngineers))..'; bHaveAvailableEngi='..tostring(bHaveAvailableEngi)..'; Is toAssignedEngineers empty='..tostring(M28Utilities.IsTableEmpty(toAssignedEngineers))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bHaveAvailableEngi then return toAvailableEngineersByTech, toAssignedEngineers
    else return nil, toAssignedEngineers
    end
end

function GetCategoryToBuildOrAssistFromAction(iActionToAssign, iMinTechLevel, aiBrain, tbEngineersOfFactionOrNilIfAlreadyAssigned, tLZOrWZData, tLZOrWZTeamData)
    --Returns the building category type based on the action; iMinTechLevel is optional; aiBrain is required if dealing with construction of experimental
    --tbEngineersOfFaction is true for each faction that we have an engineer of iMinTechLevel available for, but is nil if we don't need to worry about factions, either due to category or because the unit/building is under construciton already

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetCategoryToBuildOrAssistFromAction'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCategoryToBuild = tiActionCategory[iActionToAssign]
    local iOptionalFactionRequired --Used for certain categories where chocie of category depended on the faction available
    if bDebugMessages == true then LOG(sFunctionRef..': Time of start='..GetGameTimeSeconds()..'; iActionToAssign='..iActionToAssign..'; iMinTechLevel='..iMinTechLevel..'; aiBrain='..aiBrain.Nickname..'; repru(tbEngineersOfFactionOrNilIfAlreadyAssigned)='..repru(tbEngineersOfFactionOrNilIfAlreadyAssigned)..'; Is tbActionsThatDontHaveCategory[iActionToAssign] nil='..tostring(tbActionsThatDontHaveCategory[iActionToAssign] == nil)..'; Is tiActionCategory[iActionToAssign] nil='..tostring(tiActionCategory[iActionToAssign] == nil)) end
    if not(iCategoryToBuild) and not(tbActionsThatDontHaveCategory[iActionToAssign]) then
        if iActionToAssign == refActionBuildEmergencyPD then
            if aiBrain[M28Overseer.refbCloseToUnitCap] then
                if bDebugMessages == true then LOG(sFunctionRef..': Close to unit cap so will get T2PlusPD') end
                iCategoryToBuild = M28UnitInfo.refCategoryT2PlusPD
            else
                if iMinTechLevel > 1 or aiBrain[M28Economy.refiGrossMassBaseIncome] >= 4 or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPD * categories.TECH1) > 0 then
                    --Want to build either T2 or T2+ PD
                    local iT2PD = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPD * categories.TECH2)
                    if iT2PD <= 5 or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPD * categories.TECH3) >= iT2PD then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have 5 or fewer t2 pd so will get more t2 pd') end
                        iCategoryToBuild = M28UnitInfo.refCategoryPD - categories.TECH3
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Have at least 5 T2 PD so will get T2PlusPD') end
                        iCategoryToBuild = M28UnitInfo.refCategoryT2PlusPD
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Have no T1 PD so will get T1 PD') end
                    iCategoryToBuild = M28UnitInfo.refCategoryPD * categories.TECH1
                end
            end
        elseif iActionToAssign == refActionFortifyFirebase then
            M28Utilities.ErrorHandler('Firebase logic not in place')
            --Calculate closest firebase and assume we are trying to build this
            if aiBrain[refiFirebaseBeingFortified] then
                iCategoryToBuild = aiBrain[refiFirebaseCategoryWanted][aiBrain[refiFirebaseBeingFortified]]
                if M28Utilities.IsTableEmpty(iCategoryToBuild, false) then M28Utilities.ErrorHandler('Dont have a category to build for firebase ref '..(aiBrain[refiFirebaseBeingFortified] or 'nil')..'; will just build T2 plus PD')
                    iCategoryToBuild = M28UnitInfo.refCategoryT2PlusPD
                end
            else
                M28Utilities.ErrorHandler('Dont have a firebase to be fortified so will just build T2 plus PD')
                iCategoryToBuild = M28UnitInfo.refCategoryT2PlusPD
            end
        elseif iActionToAssign == refActionBuildExperimental or iActionToAssign == refActionBuildSecondExperimental then
            iCategoryToBuild, iOptionalFactionRequired = DecideOnExperimentalToBuild(iActionToAssign, aiBrain, tbEngineersOfFactionOrNilIfAlreadyAssigned, tLZOrWZData, tLZOrWZTeamData)
        elseif iActionToAssign == refActionBuildShield or iActionToAssign == refActionBuildSecondShield then
            --NOTE: Separately this gets changed to tech3 if need increased range
            if aiBrain[M28Overseer.refbDefendAgainstArti] or aiBrain[M28Overseer.refbCloseToUnitCap] or M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyAirToGroundThreat] >= 12000 then
                iCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.TECH3
            else
                iCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.TECH2
            end
        else
            M28Utilities.ErrorHandler('Need to add code for action='..(iActionToAssign or 'nil'))
        end
    end
    if iCategoryToBuild then
        --Power specific - only build at the minimum tech level, presume this is so if we want to build T1/T2 power while having access to T3 (due to very low power) we can; will therefore add adjustment when looking for part-build buildings to counter this
        if iActionToAssign == refActionBuildPower then
            --Only restrict the power we will build if we have no unit restrictions and/or arent in a campaign
            if not(M28Overseer.bUnitRestrictionsArePresent or M28Map.bIsCampaignMap) then
                iCategoryToBuild = iCategoryToBuild * M28UnitInfo.ConvertTechLevelToCategory(iMinTechLevel)
            end
        else
            if iMinTechLevel > 1 then
                if iMinTechLevel == 3 then iCategoryToBuild = iCategoryToBuild * categories.TECH3 + iCategoryToBuild*categories.EXPERIMENTAL
                else iCategoryToBuild = iCategoryToBuild - categories.TECH1
                end
            end
        end
        --Unit cap - dont build T1 if near cap, and only build experimentals if very near cap
        if aiBrain[M28Overseer.refbCloseToUnitCap] then
            if bDebugMessages == true then LOG(sFunctionRef..': Are close to unit cap, wont build T1 units, does category to build contain only T1 and not HQ or mex='..tostring(M28Utilities.DoesCategoryContainCategory(categories.TECH1, iCategoryToBuild, true))..'; Does it contain HQ or T3 or experimental='..tostring(M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryAllHQFactories + categories.TECH3 + categories.EXPERIMENTAL + M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryPower * categories.TECH2, iCategoryToBuild))) end
            if M28Utilities.DoesCategoryContainCategory(categories.TECH1, iCategoryToBuild, true) and not(M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryAllHQFactories + categories.TECH3 + categories.EXPERIMENTAL + M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryPower * categories.TECH2, iCategoryToBuild)) then
                iCategoryToBuild = nil
            elseif aiBrain[M28Overseer.refiExpectedRemainingCap] < 15 then
                if not(M28Utilities.DoesCategoryContainCategory(categories.TECH3 + categories.EXPERIMENTAL + M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryPower * categories.TECH2, iCategoryToBuild)) then
                    iCategoryToBuild = nil
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is iCategoryToBuild nil after unit cap adjustment='..tostring(iCategoryToBuild == nil)) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iCategoryToBuild, iOptionalFactionRequired
end

function GetEngineersOfTechWanted(iMinTechLevelWanted, toAvailableEngineersByTech)
    local tEngineersOfTechWanted
    if iMinTechLevelWanted == 3 then
        tEngineersOfTechWanted = toAvailableEngineersByTech[3]
    else
        tEngineersOfTechWanted = {}
        if iMinTechLevelWanted == 2 then
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[2]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[2] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[3]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[3] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
        else
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[1]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[1] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[2]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[2] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[3]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[3] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
        end
    end
    return tEngineersOfTechWanted
end

function GetPartCompleteBuildingInZone(iTeam, iPlateauOrPond, iLandOrWaterZone, iCategoryWanted, bIsWaterZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPartCompleteBuildingInZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then
        local tBlueprints = EntityCategoryGetUnitList(iCategoryWanted)
        LOG(sFunctionRef..': Start of code at game time seconds='..GetGameTimeSeconds()..', will list out every blueprint of iCategoryWanted='..reprs(tBlueprints))
    end
    local tLZOrWZTeamData
    local sAlliedUnitRef
    if bIsWaterZone then
        tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
        sAlliedUnitRef = M28Map.subrefWZTAlliedUnits
    else
        tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
        sAlliedUnitRef = M28Map.subrefLZTAlliedUnits
    end
    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[sAlliedUnitRef]) == false then
        local tBuildingsOfCategory = EntityCategoryFilterDown(iCategoryWanted, tLZOrWZTeamData[sAlliedUnitRef])
        if M28Utilities.IsTableEmpty(tBuildingsOfCategory) == false then
            for iUnit, oUnit in tBuildingsOfCategory do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fractino compelte='..oUnit:GetFractionComplete()) end
                if oUnit:GetFractionComplete() < 1 and not(oUnit[M28Building.refoGameEnderBeingShielded]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Found a part complete building, will return this') end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return oUnit
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return nil
end

function RemoveBuildingFromQueuedBuildings(oEngineer, oBuilding)
    --Intended to be called when oEngineer starts building oBuilding
    if M28Utilities.IsTableEmpty(oEngineer[reftQueuedBuildings]) == false then
        for iEntry, tOrderDetails in oEngineer[reftQueuedBuildings] do
            if tOrderDetails[subrefBuildingID] == oBuilding.UnitId and math.abs(oBuilding:GetPosition()[1] - tOrderDetails[subrefBuildingLocation][1]) < 0.5 and math.abs(oBuilding:GetPosition()[3] - tOrderDetails[subrefBuildingLocation][3]) < 0.5 then
                local tLZOrWZTeamData, tLZOrWZData
                if tOrderDetails[subrefPlateauOrZero] == 0 then
                    tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[tOrderDetails[subrefLandOrWaterZone]]][M28Map.subrefPondWaterZones][tOrderDetails[subrefLandOrWaterZone]]
                    tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][oEngineer:GetAIBrain().M28Team]
                else
                    --Dealing with land zone
                    tLZOrWZData = M28Map.tAllPlateaus[tOrderDetails[subrefPlateauOrZero]][M28Map.subrefPlateauLandZones][tOrderDetails[subrefLandOrWaterZone]]
                    tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
                end
                ChangeQueuedLocationsTracker(tOrderDetails[subrefBuildingLocation], tLZOrWZData, tOrderDetails[subrefBuildingRadius], false)
                if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefQueuedBuildings]) == false then
                    for iLZEntry, tLZOrWZOrderDetails in tLZOrWZTeamData[M28Map.subrefQueuedBuildings] do
                        if tLZOrWZOrderDetails[M28Map.subrefQueueRef] == tOrderDetails[subrefQueueRef] then
                            table.remove(tLZOrWZTeamData[M28Map.subrefQueuedBuildings], iLZEntry)
                            break
                        end
                    end
                end

                table.remove(oEngineer[reftQueuedBuildings], iEntry)
                break
            end

        end
    end
end

function RefreshPartBuiltMexList(tLZOrWZTeamData)
    local iRevisedIndex = 1
    local iTableSize = table.getn(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes])

    for iOrigIndex=1, iTableSize do
        if M28UnitInfo.IsUnitValid(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes][iOrigIndex]) and tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes][iOrigIndex]:GetFractionComplete() < 1 then
            --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
            if (iOrigIndex ~= iRevisedIndex) then
                tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes][iRevisedIndex] = tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes][iOrigIndex];
                tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes][iOrigIndex] = nil;
            end
            iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
        else
            tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes][iOrigIndex] = nil;
        end
    end
end

function UpdatePartBuiltListForCompletedMex(oMex)
    if oMex:GetAIBrain().M28AI and oMex:GetFractionComplete() == 1 then
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oMex:GetPosition())
        if iLandZone > 0 then
            RefreshPartBuiltMexList(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oMex:GetAIBrain().M28Team])
        end

    end
end


function RecordPartBuiltMex(oEngineer, oMex)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordPartBuiltMex'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oMex:GetPosition())
    local iWaterZone, iPond
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just started building oMex='..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
    if (iLandZone or 0) == 0 then
        iWaterZone = M28Map.GetWaterZoneFromPosition(oMex:GetPosition())
        iPond = M28Map.tiPondByWaterZone[iWaterZone]
    end
    if iLandZone > 0 or (iWaterZone > 0 and iPond > 0) then
        if oMex:GetAIBrain().M28AI then
            local tLZOrWZTeamData
            if iLandZone > 0 then tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oMex:GetAIBrain().M28Team]
            else tLZOrWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][oMex:GetAIBrain().M28Team]
            end
            if not(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes]) then tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes] = {} end
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes]) then
                if not(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes]) then tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes] = {} end
                table.insert(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes], oMex)
                if bDebugMessages == true then LOG(sFunctionRef..': Added the mex to the table of part built mexes') end
            else
                local bAlreadyInTable = false
                for iUnit, oUnit in tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes] do
                    if oUnit == oMex then bAlreadyInTable = true break end
                end
                if not(bAlreadyInTable) then
                    table.insert(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes], oMex)
                    if bDebugMessages == true then LOG(sFunctionRef..': Mex not already recorded so added to the table of part built mexes') end
                end
            end
        end

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function ClearEngineerTracking(oEngineer)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ClearEngineerTracking'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --Unpause unit if it was paused (redundancy)
    if oEngineer[M28UnitInfo.refbPaused] then M28UnitInfo.PauseOrUnpauseMassUsage(oEngineer, false) end

    oEngineer[refbPrimaryBuilder] = false
    oEngineer[refiAssignedActionPriority] = nil
    oEngineer[refiAssignedAction] = nil

    --Update experimental construction tracking:
    if oEngineer[refbBuildingExperimental] then
        --As backup, also remove any dead engineers from this table
        local iRevisedIndex = 1
        local tArray = M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subreftTeamEngineersBuildingExperimentals]
        local iTableSize = table.getn(tArray)

        for iOrigIndex=1, iTableSize do
            if tArray[iOrigIndex] then
                if oEngineer ~= tArray[iOrigIndex] and M28UnitInfo.IsUnitValid(tArray[iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                    --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                    if (iOrigIndex ~= iRevisedIndex) then
                        tArray[iRevisedIndex] = tArray[iOrigIndex];
                        tArray[iOrigIndex] = nil;
                    end
                    iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                else
                    tArray[iOrigIndex] = nil;
                end
            end
        end

        oEngineer[refbBuildingExperimental] = nil
    end

    --Update details of engineers moving to a plateau
    if oEngineer[M28Land.reftiPlateauAndLZToMoveTo] then
        local tTargetLZTeamData = M28Map.tAllPlateaus[oEngineer[M28Land.reftiPlateauAndLZToMoveTo][1]][M28Map.subrefPlateauLandZones][oEngineer[M28Land.reftiPlateauAndLZToMoveTo][2]][M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
        if tTargetLZTeamData and M28Utilities.IsTableEmpty(tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
            for iUnit, oUnit in tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere] do
                if oUnit == oEngineer then
                    table.remove(tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere][iUnit])
                    break
                end
            end
        end
    end
    oEngineer[M28Land.reftiPlateauAndLZToMoveTo] = nil

    --Clear reclaim assignment tracking
    if oEngineer[reftAssignedReclaimSegments] then
        if bDebugMessages == true then LOG(sFunctionRef..': Engineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; reftAssignedReclaimSegments='..repru(oEngineer[reftAssignedReclaimSegments])) end
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.tReclaimAreas[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]][M28Map.refReclaimSegmentMidpoint])
        if (iLandZone or 0) > 0 then
            local tEngiAssignedByReclaim = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team][M28Map.subrefReclaimAreaAssignmentsBySegment]
            if tEngiAssignedByReclaim and tEngiAssignedByReclaim[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]] then tEngiAssignedByReclaim[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]] = math.max(0, (tEngiAssignedByReclaim[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]] or 0) - 1) end
        elseif (iPlateau or 0) > 0 then
            local iWaterZone = M28Map.GetWaterZoneFromPosition(M28Map.tReclaimAreas[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]][M28Map.refReclaimSegmentMidpoint])
            if (iWaterZone or 0) > 0 then
                local tEngiAssignedByReclaim = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][oEngineer:GetAIBrain().M28Team][M28Map.subrefReclaimAreaAssignmentsBySegment]
                if tEngiAssignedByReclaim and tEngiAssignedByReclaim[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]] then tEngiAssignedByReclaim[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]] = math.max(0, (tEngiAssignedByReclaim[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]] or 0) - 1) end
            end
        end
        oEngineer[reftAssignedReclaimSegments] = nil
    end

    --Clear any queued building orders
    if M28Utilities.IsTableEmpty(oEngineer[reftQueuedBuildings]) == false then
        for iEntry, tOrderDetails in oEngineer[reftQueuedBuildings] do
            local tLZOrWZTeamData, tLZOrWZData
            if tOrderDetails[subrefPlateauOrZero] > 0 then
                tLZOrWZData = M28Map.tAllPlateaus[tOrderDetails[subrefPlateauOrZero]][M28Map.subrefPlateauLandZones][tOrderDetails[subrefLandOrWaterZone]]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
            else
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[tOrderDetails[subrefLandOrWaterZone]]][M28Map.subrefPondWaterZones][tOrderDetails[subrefLandOrWaterZone]]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][oEngineer:GetAIBrain().M28Team]
            end
            ChangeQueuedLocationsTracker(tOrderDetails[subrefBuildingLocation], tLZOrWZData, tOrderDetails[subrefBuildingRadius], false)

            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefQueuedBuildings]) == false then
                for iLZEntry, tLZOrderDetails in tLZOrWZTeamData[M28Map.subrefQueuedBuildings] do
                    if tLZOrderDetails[M28Map.subrefQueueRef] == tOrderDetails[subrefQueueRef] then
                        table.remove(tLZOrWZTeamData[M28Map.subrefQueuedBuildings], iLZEntry)
                        break
                    end
                end
            end
        end
    end
    oEngineer[reftQueuedBuildings] = nil

    --Clear assisting engineers
    if M28Utilities.IsTableEmpty(oEngineer[M28UnitInfo.reftoUnitsAssistingThis]) == false then
        local tEngineersToRemove = {}
        for iAssistingEngineer, oAssistingEngineer in oEngineer[M28UnitInfo.reftoUnitsAssistingThis] do
            if M28UnitInfo.IsUnitValid(oAssistingEngineer) then
                table.insert(tEngineersToRemove, oAssistingEngineer)
            end
        end
        for iAssistingEngineer, oAssistingEngineer in tEngineersToRemove do
            if not(oAssistingEngineer == oEngineer) and not(oEngineer['M28TempClearing']) then
                oEngineer['M28TempClearing'] = true
                M28Orders.IssueTrackedClearCommands(oAssistingEngineer)
                oEngineer['M28TempClearing'] = nil
            end
        end
        oEngineer[M28UnitInfo.reftoUnitsAssistingThis] = nil
    end

    --Clear special shield tracking
    if oEngineer[refoUnitActivelyShielding] then
        if M28UnitInfo.IsUnitValid(oEngineer[refoUnitActivelyShielding]) then
            if M28Utilities.IsTableEmpty(oEngineer[refoUnitActivelyShielding][reftEngineersActivelyShielding]) == false then
                for iRecordedEngi, oRecordedEngi in oEngineer[refoUnitActivelyShielding][reftEngineersActivelyShielding] do
                    if oRecordedEngi == oEngineer then
                        table.remove(oEngineer[refoUnitActivelyShielding][reftEngineersActivelyShielding], iRecordedEngi)
                        break
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(oEngineer[refoUnitActivelyShielding][reftEngineersActivelyShielding]) then
            oEngineer[refoUnitActivelyShielding][reftEngineersActivelyShielding] = nil
        end
        oEngineer[refoUnitActivelyShielding] = nil

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TrackQueuedBuilding(oEngineer, sBuildingID, tBuildLocation)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TrackQueuedBuilding'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time='..GetGameTimeSeconds()..'; oEngineer='..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil')..'; sBuildingID='..(sBuildingID or 'nil')..'; tBuildLocation='..repru(tBuildLocation)) end

    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tBuildLocation)

    if iPlateauOrZero > 0 then
        if (iLandOrWaterZone or 0) == 0 then
            iLandOrWaterZone = M28Map.GetWaterZoneFromPosition(tBuildLocation)
            iPlateauOrZero = 0
        end
        if iLandOrWaterZone > 0 then
            iCurQueueRefNumber = iCurQueueRefNumber + 1
            if not(oEngineer[reftQueuedBuildings]) then oEngineer[reftQueuedBuildings] = {} end
            if bDebugMessages == true then LOG(sFunctionRef..': About to get building size='..(M28UnitInfo.GetBuildingSize(sBuildingID) or 'nil')) end
            local iBuildingRadius = math.floor(M28UnitInfo.GetBuildingSize(sBuildingID) * 0.5)
            table.insert(oEngineer[reftQueuedBuildings], {[subrefQueueRef] = iCurQueueRefNumber, [subrefBuildingID] = sBuildingID, [subrefBuildingLocation] = tBuildLocation, [subrefBuildingRadius] = iBuildingRadius, [subrefPlateauOrZero] = iPlateauOrZero, [subrefLandOrWaterZone] = iLandOrWaterZone})
            local tLZOrWZTeamData, tLZOrWZData
            if iPlateauOrZero > 0 then
                tLZOrWZData  = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
            else
                --Water zone
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][oEngineer:GetAIBrain().M28Team]
            end

            if iPlateauOrZero == 0 then

                tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][oEngineer:GetAIBrain().M28Team]
            else
                tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
            end
            if not(tLZOrWZTeamData[M28Map.subrefQueuedBuildings]) then tLZOrWZTeamData[M28Map.subrefQueuedBuildings] = {} end
            table.insert(tLZOrWZTeamData[M28Map.subrefQueuedBuildings], {[M28Map.subrefQueueRef] = iCurQueueRefNumber, [M28Map.subrefBuildingID] = sBuildingID, [M28Map.subrefBuildingLocation] = tBuildLocation, [M28Map.subrefBuildingRadius] = iBuildingRadius, [M28Map.subrefPrimaryBuilder] = oEngineer})
            --Record the locations as being queued
            ChangeQueuedLocationsTracker(tBuildLocation, tLZOrWZData, iBuildingRadius, true)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ChangeQueuedLocationsTracker(tBuildLocation, tLZOrWZData, iBuildingRadius, bAddToQueue)
    local iBaseX = math.floor(tBuildLocation[1])
    local iBaseZ = math.floor(tBuildLocation[3])
    for iX = iBaseX - iBuildingRadius, iBaseX + iBuildingRadius, 1 do
        if bAddToQueue then
            if not(tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX]) then
                if not(tLZOrWZData[M28Map.subrefQueuedLocationsByPosition]) then tLZOrWZData[M28Map.subrefQueuedLocationsByPosition] = {} end
                tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX] = {}
            end
            for iZ = iBaseZ - iBuildingRadius, iBaseZ + iBuildingRadius do
                tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX][iZ] = true
            end
        else
            if tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX] then
                for iZ = iBaseZ - iBuildingRadius, iBaseZ + iBuildingRadius do
                    tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX][iZ] = nil
                end
            end
        end
    end
end

function TrackEngineerAction(oEngineer, iActionToAssign, bIsPrimaryBuilder, iCurPriority, tOptionalPlatAndLandToMoveTo, vOptionalOtherVariable)
    --bIsPrimaryBuilder - true if engineer will be building the item in question (so false if assisting an engineer or repairing a building or assisting an upgrade or moving somewhere etc.
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TrackEngineerAction'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Special logic (done in a genric way in case end up with more scenarios like this) - if action to assign currnetly is special shield logic and we have a different action to assign then clear engineer tracking (as we have an override that prevents it being cleared via orders)
    if oEngineer[refiAssignedAction] and not(oEngineer[refiAssignedAction] == iActionToAssign) then ClearEngineerTracking(oEngineer) end

    oEngineer[refiAssignedAction] = iActionToAssign
    oEngineer[refbPrimaryBuilder] = (bIsPrimaryBuilder or false)
    oEngineer[refiAssignedActionPriority] = iCurPriority

    --Track experimental construction
    if iActionToAssign == refActionBuildExperimental or iActionToAssign == refActionBuildSecondExperimental or iActionToAssign == refActionBuildGameEnder or iActionToAssign == refActionBuildExperimentalNavy or iActionToAssign == refActionBuildLandExperimental then
        table.insert(M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subreftTeamEngineersBuildingExperimentals], oEngineer)
        oEngineer[refbBuildingExperimental] = true
    else
        oEngineer[refbBuildingExperimental] = nil
    end

    --Track info e.g. for units moving to other plateaus
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
    local tTargetLZTeamData
    if tOptionalPlatAndLandToMoveTo then
        oEngineer[M28Land.reftiPlateauAndLZToMoveTo] = {tOptionalPlatAndLandToMoveTo[1], tOptionalPlatAndLandToMoveTo[2]}
        tTargetLZTeamData = M28Map.tAllPlateaus[tOptionalPlatAndLandToMoveTo[1]][M28Map.subrefPlateauLandZones][tOptionalPlatAndLandToMoveTo[2]][M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
    end
    if vOptionalOtherVariable then
        if iActionToAssign == refActionReclaimArea then
            oEngineer[reftAssignedReclaimSegments] = vOptionalOtherVariable
        elseif iActionToAssign == refActionRunToWaterZone or iActionToAssign == refActionMoveToWaterZone then
            if bDebugMessages == true then LOG(sFunctionRef..': Engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' wants to move to water zone '..vOptionalOtherVariable..'; iCurPriority='..(iCurPriority or 'nil')) end
            oEngineer[M28Land.reftiPlateauAndLZToMoveTo] = nil
            oEngineer[M28Navy.refiWZToMoveTo] = vOptionalOtherVariable
            local iPond = M28Map.tiPondByWaterZone[vOptionalOtherVariable]
            tTargetLZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][vOptionalOtherVariable][M28Map.subrefWZTeamData][oEngineer:GetAIBrain().M28Team]
        else M28Utilities.ErrorHandler('vOptionalOtherVariable is specified but dont know what for, iActionToAssign='..iActionToAssign)
        end
    end

    --Track if we are moving to a land or water zone
    if tTargetLZTeamData then
        if not(tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere]) then tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere] = {} end
        table.insert(tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere], oEngineer)
        --Reduce BP wanted by the LZ, and no longer flag it as wanting BP if this satisfies all its needs
        local iEngiTechLevel = M28UnitInfo.GetUnitTechLevel(oEngineer)
        for iTech = iEngiTechLevel, 1, -1 do
            if tTargetLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                tTargetLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] = tTargetLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] - oEngineer:GetBlueprint().Economy.BuildRate
                local bNoLongerWantBP = false
                if tTargetLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] <= 0 then
                    bNoLongerWantBP = true
                    for iAltTech = iTech, 1, -1 do
                        if tTargetLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iAltTech] > 0 then
                            bNoLongerWantBP = false
                            break
                        end
                    end
                end
                if bNoLongerWantBP then
                    tTargetLZTeamData[M28Map.subrefTbWantBP] = false
                end
                break
            end
        end
    end

    --Track potential blacklist locations for primary engineers - note that more general queued building construction tracking is done via TrackQueuedBuilding based on when an order is given to construct something
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to track engineer for blacklisted locations, Time='..GetGameTimeSeconds()..'; Engineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; bIsPrimaryBuilder='..tostring(bIsPrimaryBuilder or false)..'; oEngineer[M28Orders.refiOrderCount]='..(oEngineer[M28Orders.refiOrderCount] or 'nil')..'; Last order type='..(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] or 'nil')) end
    if bIsPrimaryBuilder and not(tbActionsThatDontHaveCategory[iActionToAssign]) and oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild then
        ForkThread(MonitorEngineerForBlacklistLocation, oEngineer)
    end

    --Unpause engineer
    if oEngineer[M28UnitInfo.refbPaused] then
        M28UnitInfo.PauseOrUnpauseEnergyUsage(oEngineer, false)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' action='..(oEngineer[refiAssignedAction] or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function HaveSameTargetAndNotStartedBuilding(oEngineer, iOrigAction, iOrigQueueRef, sOrigBlueprint, tOrigBuildLocation)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'HaveSameTargetAndNotStartedBuilding'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if bDebugMessages == true then
        if M28UnitInfo.IsUnitValid(oEngineer) then
            LOG(sFunctionRef..': time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..': Engineer is valid, refbPrimaryBuilder='..tostring(oEngineer[refbPrimaryBuilder])..'; Assigned action='..(oEngineer[refiAssignedAction] or 'nil')..'; Engineer unit state='..M28UnitInfo.GetUnitState(oEngineer)..'; Qued buildings queue ref='..(oEngineer[reftQueuedBuildings][1][subrefQueueRef] or 'nil')..'; Last order blueprint='..(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] or 'nil')..'; Last order position='..repru(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition] or {'nil'}))
        else
            LOG(sFunctionRef..': Engineer is no longer valid')
        end
    end
    if M28UnitInfo.IsUnitValid(oEngineer) and oEngineer[refbPrimaryBuilder] and oEngineer[refiAssignedAction] == iOrigAction and not(oEngineer:IsUnitState('Building')) and not(oEngineer:IsUnitState('Repairing')) and oEngineer[reftQueuedBuildings][1][subrefQueueRef] == iOrigQueueRef and sOrigBlueprint == oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] then --and oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition] and M28Utilities.GetDistanceBetweenPositions(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition], tOrigBuildLocation) <= 1 then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    else
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false
    end
end

function ClearBlacklistForUnitConstructed(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ClearBlacklistForUnitConstructed'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is table of blacklists empty='..tostring(M28Utilities.IsTableEmpty(oUnit[reftUnitBlacklistSegmentXZ]))) end
    if M28Utilities.IsTableEmpty(oUnit[reftUnitBlacklistSegmentXZ]) == false then
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
        if iPlateauOrZero and (iLandOrWaterZone or 0) > 0 then
            local tLZOrWZData
            if iPlateauOrZero == 0 then
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
            else
                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
            end
            for iEntry, tiSegmentXZ in oUnit[reftUnitBlacklistSegmentXZ] do
                tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][tiSegmentXZ[1]][tiSegmentXZ[2]] = nil
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished clearing the blacklisted locations, iPlateau='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; repru of blacklisted locations for zone='..repru(tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition])) end
        end
    end
    oUnit[reftUnitBlacklistSegmentXZ] = nil
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedBlacklistReset(tLZOrWZData, iX, iZ, iResetTimeInSeconds, oOptionalUnitToTrack)
    WaitSeconds(iResetTimeInSeconds)
    if not(oOptionalUnitToTrack) or not(M28UnitInfo.IsUnitValid(oOptionalUnitToTrack)) then
        tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][iX][iZ] = nil
    end
end

function RecordBlacklistLocation(tLocation, iRadius, iResetTimeInSeconds, oOptionalUnitToTrack)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordBlacklistLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --oOptionalUnitToTrack - i.e. should have experimental units under construction specified here - if specified, means iresettimeinseconds only triggers if that unit doesnt exist, as a redundancy for if we failed to pickup the event when it died
    --iResetTimeInSeconds - per above, if  oOptionalUnitToTrack is specififed then this only triggers if hte unit no longer exists after waiting iResetTimeInSeconds

    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tLocation)
    if bDebugMessages == true then LOG(sFunctionRef..': Gametimeseconds='..GetGameTimeSeconds()..'; tLocation='..repru(tLocation)..'; iRadius='..(iRadius or 'nil')..'; iResetTimeInSeconds='..(iResetTimeInSeconds or 'nil')..'; oOptionalUnitToTrack='..(oOptionalUnitToTrack.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oOptionalUnitToTrack) or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')) end
    if (iLandOrWaterZone or 0) > 0 then
        local tLZOrWZData
        if iPlateauOrZero == 0 then
            tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        else
            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        end
        if oOptionalUnitToTrack then
            oOptionalUnitToTrack[reftUnitBlacklistSegmentXZ] = {}
        end


        local iBaseX = math.floor(tLocation[1])
        local iBaseZ = math.floor(tLocation[3])
        local iSegmentRadius = math.floor(iRadius / M28Map.iLandZoneSegmentSize)
        for iX = iBaseX - iSegmentRadius, iBaseX + iSegmentRadius do
            for iZ = iBaseZ - iSegmentRadius, iBaseZ + iSegmentRadius do
                if not(tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][iX][iZ]) then
                    if not(tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][iX]) then
                        if not(tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition]) then tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition] = {} end
                        tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][iX] = {}
                    end
                    tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][iX][iZ] = true
                    if (iResetTimeInSeconds or 0) >= 0 then
                        ForkThread(DelayedBlacklistReset, tLZOrWZData, iX, iZ, iResetTimeInSeconds, oOptionalUnitToTrack)
                    end
                    if oOptionalUnitToTrack then
                        table.insert(oOptionalUnitToTrack[reftUnitBlacklistSegmentXZ], {iX, iZ})
                        if bDebugMessages == true then LOG(sFunctionRef..': Added blacklist location for oOptionalUnitToTrack='..oOptionalUnitToTrack.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOptionalUnitToTrack)..'; X'..iX..'Z'..iZ) end
                    end
                else
                    --Already reocrded as a blacklist so wont rerecord/add a new reset to it
                end
            end
        end
        if bDebugMessages == true then
            LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Added location to the blacklist, tLocation='..repru(tLocation)..'; iRadius='..(iRadius or 0)..'; iResetTimeInSeconds='..(iResetTimeInSeconds or 'nil')..'; repru of blacklist locations='..repru(tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition])..'; will draw all blacklisted locations for this LZ')
            DrawBlacklistedLocations(tLZOrWZData)
        end

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MonitorEngineerForBlacklistLocation(oEngineer)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MonitorEngineerForBlacklistLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local sOrigBlueprint = oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint]
    --Only consider engineers with a single queued up building
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; sOrigBlueprint='..(sOrigBlueprint or 'nil')..'; Is table of queued buildings empty='..tostring(M28Utilities.IsTableEmpty(oEngineer[reftQueuedBuildings]))..'; Size of queued buildings table='..table.getn(oEngineer[reftQueuedBuildings] or {})) end
    if sOrigBlueprint and M28Utilities.IsTableEmpty(oEngineer[reftQueuedBuildings]) == false and table.getn(oEngineer[reftQueuedBuildings]) == 1 then
        --Ignore for mexes and hydrocarbons
        if not(EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryHydro, sOrigBlueprint)) then
            local iOrigQueueRef = oEngineer[reftQueuedBuildings][1][subrefQueueRef]
            local sTrackerRef = 'M28Q'..iOrigQueueRef
            if not(oEngineer[sTrackerRef]) then
                oEngineer[sTrackerRef] = true
                local tOrigBuildLocation = {oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition][1], oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition][2], oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition][3]}
                local bCloseToTarget = false
                local iOrigAction = oEngineer[refiAssignedAction]
                local iWaitCount = 0
                local iOrigTime = GetGameTimeSeconds()

                --[[function HaveSameTargetAndNotStartedBuilding()
                if bDebugMessages == true then
                    if M28UnitInfo.IsUnitValid(oEngineer) then
                    --]]
                --LOG('HaveSameTargetAndNotStartedBuilding: time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..': Engineer is valid, refbPrimaryBuilder='..tostring(oEngineer[refbPrimaryBuilder])..'; Assigned action='..(oEngineer[refiAssignedAction] or 'nil')..'; Engineer unit state='..M28UnitInfo.GetUnitState(oEngineer)..'; Qued buildings queue ref='..(oEngineer[reftQueuedBuildings][1][subrefQueueRef] or 'nil')..'; Last order blueprint='..(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] or 'nil')..'; Last order position='..repru(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition] or {'nil'}))
                --[[else
                LOG('HaveSameTargetAndNotStartedBuilding: Engineer is no longer valid')
            end
        end--]]
                --if M28UnitInfo.IsUnitValid(oEngineer) and oEngineer[refbPrimaryBuilder] and oEngineer[refiAssignedAction] == iOrigAction and not(oEngineer:IsUnitState('Building')) and not(oEngineer:IsUnitState('Repairing')) and oEngineer[reftQueuedBuildings][1][subrefQueueRef] == iOrigQueueRef and sOrigBlueprint == oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] and oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition] and M28Utilities.GetDistanceBetweenPositions(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition], tOrigBuildLocation) <= 1 then
                --[[return true
        else
            return false
        end
    end--]]
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitSeconds(10)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if bDebugMessages == true then LOG(sFunctionRef..': time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..': Finished first wait, HaveSameTargetAndNotStartedBuilding='..tostring(HaveSameTargetAndNotStartedBuilding(oEngineer, iOrigAction, iOrigQueueRef, sOrigBlueprint, tOrigBuildLocation))..'; iOrigQueueRef='..repru(iOrigQueueRef or 'nil')..'; tOrigBuildLocation='..repru(tOrigBuildLocation)..'; iOrigAction='..repru(iOrigAction or 'nil')) end

                while HaveSameTargetAndNotStartedBuilding(oEngineer, iOrigAction, iOrigQueueRef, sOrigBlueprint, tOrigBuildLocation) and not(bCloseToTarget) do
                    if bDebugMessages == true then LOG(sFunctionRef..': time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..': bCloseToTarget='..tostring(bCloseToTarget)..'; Dist between engineer pos and orig build location='..M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), tOrigBuildLocation)) end
                    if M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), tOrigBuildLocation) <= 12 then bCloseToTarget = true break
                    else
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitSeconds(10)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        iWaitCount = iWaitCount + 1
                        if iWaitCount >= 20 then break end
                    end
                end
                if bCloseToTarget then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitSeconds(45)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished another wait and are close to target, time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; HaveSameTargetAndNotStartedBuilding()='..tostring(HaveSameTargetAndNotStartedBuilding(oEngineer, iOrigAction, iOrigQueueRef, sOrigBlueprint, tOrigBuildLocation))) end
                    if HaveSameTargetAndNotStartedBuilding(oEngineer, iOrigAction, iOrigQueueRef, sOrigBlueprint, tOrigBuildLocation) then
                        --If there are no mobile units then wait another 30s
                        local bAddToBlacklist = true
                        local iRadius = M28UnitInfo.GetBuildingSize(sOrigBlueprint) * 0.5
                        local rNearbyRect = M28Utilities.GetRectAroundLocation(tOrigBuildLocation, iRadius)
                        local tUnitsInRect = GetUnitsInRect(rNearbyRect)
                        if M28Utilities.IsTableEmpty(tUnitsInRect) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.MOBILE * categories.LAND, tUnitsInRect)) then
                            bAddToBlacklist = false
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitSeconds(30)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                            if HaveSameTargetAndNotStartedBuilding(oEngineer, iOrigAction, iOrigQueueRef, sOrigBlueprint, tOrigBuildLocation) then
                                bAddToBlacklist = true
                            end
                        end
                        if bAddToBlacklist then

                            --Add location to blacklist
                            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tOrigBuildLocation)
                            if bDebugMessages == true then LOG(sFunctionRef..': time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..': Want to add to blacklist, iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; sOrigBlueprint='..sOrigBlueprint) end
                            if iPlateau and iLandZone then
                                RecordBlacklistLocation(tOrigBuildLocation, 1, 480) --i.e. reset after 8 minutes

                                --Prev approach below:
                                --table.insert(tLZData[M28Map.subrefBuildLocationBlacklist], {[M28Map.subrefBlacklistLocation] = tOrigBuildLocation, [M28Map.subrefBlacklistSize] = iRadius, [M28Map.subrefBlacklistType] = M28Map.BlacklistTimeout})

                                --Update existing build locations to remove if they are near here
                                CheckIfBuildableLocationsNearPositionStillValid(oEngineer:GetAIBrain(), tOrigBuildLocation, true, M28UnitInfo.GetBuildingSize(sOrigBlueprint) * 0.5)

                                --Clear this engineer and any assisting engineers (assisting engineers are cleared via ClearEngineerTracking)
                                M28Orders.IssueTrackedClearCommands(oEngineer)
                            end
                        end
                    end
                end
            end
            oEngineer[sTrackerRef] = nil
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetEngineerToReclaimNearbyArea(oEngineer, iPriorityOverride, tLZOrWZTeamData, iPlateauOrPond, iLandOrWaterZone, bWantEnergyNotMass, bOnlyConsiderReclaimInRangeOfEngineer, iMinIndividualValueOverride, bIsWaterZone)
    --Gets engineer to find the nearest unassigned reclaim segment in the land zone that has mass/energy, to move to the middle of it, and reclaim it
    --Factors in how much mass is in the segment and how many engineers have been assigned already and adjusts the chosen segment accordingly
    --bOnlyConsiderReclaimInRangeOfEngineer - if true then will use oEngineer position instead of the midpoint of the reclaim segment that want to target
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetEngineerToReclaimNearbyArea'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iCurPriority = (iPriorityOverride or oEngineer[refiAssignedActionPriority] or 1)
    local tLZOrWZData
    if bIsWaterZone then tLZOrWZData = M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iLandOrWaterZone]
    else tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; iPlateauOrPond='..iPlateauOrPond..'; iLandOrWaterZone='..iLandOrWaterZone..'; bWantEnergyNotMass='..tostring(bWantEnergyNotMass or false)..'; bOnlyConsiderReclaimInRangeOfEngineer='..tostring(bOnlyConsiderReclaimInRangeOfEngineer or false)..'; iMinIndividualValueOverride='..(iMinIndividualValueOverride or 'nil')..'; bIsWaterZone='..tostring(bIsWaterZone or false)) end
    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefReclaimSegments]) == false then
        local iClosestSegmentDist = 100000
        local tiClosestSegmentXZ
        local iCurModDist
        local sTotalReclaimValueRef
        local iReclaimValuePerEngi
        local bGivenOrder = false

        local iMinReclaimIndividualValue = (iMinIndividualValueOverride or 1)


        if bWantEnergyNotMass then
            sTotalReclaimValueRef = M28Map.subrefLZTotalEnergyReclaim
            iReclaimValuePerEngi = 300
        else
            sTotalReclaimValueRef = M28Map.subrefTotalMassReclaim
            iReclaimValuePerEngi = 200
        end

        local oEngBP = oEngineer:GetBlueprint()
        --if oEngBP.Economy.MaxBuildDistance >= 10 then iSegmentSearchSize = math.max(1, math.ceil((oEngBP.Economy.MaxBuildDistance + 2) / math.min(M28Map.iReclaimSegmentSizeX, M28Map.iReclaimSegmentSizeZ))) end
        --local iMoveSpeed = oEngBP.Physics.MaxSpeed
        local iMaxDistanceToEngineer = oEngBP.Economy.MaxBuildDistance + math.min(oEngBP.SizeX, oEngBP.SizeZ) * 0.5 - 0.1
        local bCheckTerrain = false
        if iMaxDistanceToEngineer < math.min(M28Map.iReclaimSegmentSizeX, M28Map.iReclaimSegmentSizeZ) then bCheckTerrain = true end
        local sReclaimTableRef
        if bWantEnergyNotMass then sReclaimTableRef = M28Map.refSegmentReclaimTotalEnergy
        else sReclaimTableRef = M28Map.refReclaimTotalMass
        end

        local bDontConsiderPlayableArea = not(M28Map.bIsCampaignMap)

        if not(bOnlyConsiderReclaimInRangeOfEngineer) then
            for iSegmentCount, tSegmentXZ in tLZOrWZData[M28Map.subrefReclaimSegments] do
                if M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][sReclaimTableRef] >= iMinReclaimIndividualValue then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering reclaim location at position '..repru(M28Map.GetReclaimLocationFromSegment(tSegmentXZ[1], tSegmentXZ[2]))..'; plyaable area='..repru(M28Map.rMapPlayableArea)..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(M28Map.GetReclaimLocationFromSegment(tSegmentXZ[1], tSegmentXZ[2])))..'; bDontConsiderPlayableArea='..tostring(bDontConsiderPlayableArea)) end
                    if bDontConsiderPlayableArea or M28Conditions.IsLocationInPlayableArea(M28Map.GetReclaimLocationFromSegment(tSegmentXZ[1], tSegmentXZ[2])) then
                        iCurModDist = M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), M28Map.GetReclaimLocationFromSegment(tSegmentXZ[1], tSegmentXZ[2]))
                        if iCurModDist > iMaxDistanceToEngineer then
                            if tLZOrWZTeamData[M28Map.subrefReclaimAreaAssignmentsBySegment][tSegmentXZ[1]] and tLZOrWZTeamData[M28Map.subrefReclaimAreaAssignmentsBySegment][tSegmentXZ[1]][tSegmentXZ[2]] and tLZOrWZData[sTotalReclaimValueRef] < (iReclaimValuePerEngi * tLZOrWZTeamData[M28Map.subrefReclaimAreaAssignmentsBySegment][tSegmentXZ[1]][tSegmentXZ[2]]) then
                                iCurModDist = iCurModDist + 60 * tLZOrWZTeamData[M28Map.subrefReclaimAreaAssignmentsBySegment][tSegmentXZ[1]][tSegmentXZ[2]] * iReclaimValuePerEngi / math.max(5, tLZOrWZData[sTotalReclaimValueRef]) --Low priority area
                            end
                        end

                        if iCurModDist < iClosestSegmentDist then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have a new closest dist='..iCurModDist..'; SegmentXZ='..repru(tiClosestSegmentXZ)) end
                            iClosestSegmentDist = iCurModDist
                            tiClosestSegmentXZ = {tSegmentXZ[1], tSegmentXZ[2]}
                        end
                    end
                end
            end
        end

        if tiClosestSegmentXZ or bOnlyConsiderReclaimInRangeOfEngineer then
            --Get reclaim in the segment
            local tTargetPos
            if bOnlyConsiderReclaimInRangeOfEngineer then
                tTargetPos = oEngineer:GetPosition()
            else tTargetPos = M28Map.GetReclaimLocationFromSegment(tiClosestSegmentXZ[1], tiClosestSegmentXZ[2])
            end

            local iCurDistToTargetPos
            if bDebugMessages == true then
                if bOnlyConsiderReclaimInRangeOfEngineer then LOG(sFunctionRef..': Only considering reclaim around the engineer position rather than the wider land zone')
                else
                    LOG(sFunctionRef..': Considering all reclaim in the land zone, Eng build distance='..oEngBP.Economy.MaxBuildDistance..'; SizeX='..oEngBP.SizeX..'; Eng SizeZ='..oEngBP.SizeZ..'; tiClosestSegmentXZ='..repru(tiClosestSegmentXZ)..'; Mass/energy reclaim in this segment (depending on which we are searching for)='..M28Map.tReclaimAreas[tiClosestSegmentXZ[1]][tiClosestSegmentXZ[2]][sReclaimTableRef]..'; searching for energy not mass='..tostring(bWantEnergyNotMass))
                end
            end

            --GetReclaimInRectangle(iReturnType, rRectangleToSearch)
            --    --iReturnType: 1 = true/false; 2 = number of wrecks; 3 = total mass, 4 = valid wrecks
            local rReclaimRectangle = M28Utilities.GetRectAroundLocation(tTargetPos, math.max(M28Map.iReclaimSegmentSizeX * 0.5, iMaxDistanceToEngineer, M28Map.iReclaimSegmentSizeZ * 0.5))
            local tNearbyReclaim = M28Map.GetReclaimInRectangle(4, rReclaimRectangle)
            if bDebugMessages == true then
                local iTargetPosPlateau, iTargetPosLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetPos)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering for iPlateauOrPond='..(iPlateauOrPond or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Engineer='..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil')..'; iMaxDistanceToEngineer='..(iMaxDistanceToEngineer or 'nil')..'; oEngBP.Economy.MaxBuildDistance='..(oEngBP.Economy.MaxBuildDistance or 'nil')..'; Rect='..repru(Rect(tTargetPos[1] - (iMaxDistanceToEngineer or 0), tTargetPos[3] - (iMaxDistanceToEngineer or 0), tTargetPos[1] + (iMaxDistanceToEngineer or 0), tTargetPos[3] + (iMaxDistanceToEngineer or 0)))..'; tiClosestSegmentXZ='..repru(tiClosestSegmentXZ)..'; Is tNearbyReclaim empty='..tostring(M28Utilities.IsTableEmpty(tNearbyReclaim))..'; Total mass recorded against this reclaim segment='..(M28Map.tReclaimAreas[tiClosestSegmentXZ[1]][tiClosestSegmentXZ[2]][M28Map.refReclaimTotalMass] or 'nil')..'; tTargetPos='..repru(tTargetPos)..'; Eng pos='..repru(oEngineer:GetPosition())..'; Target Plateau and LZ='..(iTargetPosPlateau or 'nil')..'-'..(iTargetPosLZ or 0)..'; Reclaim segment='..repru(tiClosestSegmentXZ)..'; rReclaimRectangle='..repru(rReclaimRectangle)..'; M28Map.iReclaimSegmentSizeX='..(M28Map.iReclaimSegmentSizeX or 'nil')..'; iMaxDistanceToEngineer='..(iMaxDistanceToEngineer or 'nil')) end
                M28Utilities.DrawRectangle(rReclaimRectangle, 2, 20)
            end

            if M28Utilities.IsTableEmpty(tNearbyReclaim) == false then
                local oNearestReclaim
                local iNearestReclaim = 10000
                local iNearestReclaimWithAnyValue = 10000
                local oNearestAnyValueReclaim
                local iReclaimRadius

                local iEngiTerrainLabel = NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oEngineer:GetPosition())

                for iReclaim, oReclaim in tNearbyReclaim do
                    --is this valid reclaim within our build area?
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': iReclaim='..iReclaim..'; oReclaim.MaxMassReclaim='..(oReclaim.MaxMassReclaim or 0))
                        if oReclaim.MaxMassReclaim >= 100 or (bWantEnergyNotMass and oReclaim.MaxEnergyReclaim >= 100) then
                            LOG('Large reclaim, repr of all values='..reprs(oReclaim))
                            if oReclaim.GetBlueprint then
                                LOG('oReclaim has a blueprint='..reprs(oReclaim:GetBlueprint()))
                            else LOG('oReclaim doesnt have .GetBlueprint')
                            end
                        end
                    end
                    if oReclaim.CachePosition and ((not(bWantEnergyNotMass) and oReclaim.MaxMassReclaim >= iMinReclaimIndividualValue) or (bWantEnergyNotMass and oReclaim.MaxEnergyReclaim >= iMinReclaimIndividualValue)) and not(oReclaim:BeenDestroyed()) then
                        iReclaimRadius = math.min(oReclaim:GetBlueprint().SizeX, oReclaim:GetBlueprint().SizeZ)*0.5
                        iCurDistToTargetPos = math.max(0, M28Utilities.GetDistanceBetweenPositions(tTargetPos, oReclaim.CachePosition) - iReclaimRadius)
                        --Can we path to it?
                        if iCurDistToTargetPos < iNearestReclaim and (not(bCheckTerrain) or (NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oReclaim.CachePosition) == iEngiTerrainLabel or (iCurDistToTargetPos <= 12 and M28Utilities.GetDistanceBetweenPositions(oReclaim.CachePosition, oEngineer:GetPosition()) <= iReclaimRadius + iMaxDistanceToEngineer))) then
                            iNearestReclaim = iCurDistToTargetPos
                            oNearestReclaim = oReclaim
                        end
                        --Backup e.g. if looking for energy reclaim but only have mass available
                        if not(oNearestReclaim) then
                            if iCurDistToTargetPos < iNearestReclaimWithAnyValue and (oReclaim.MaxMassReclaim or 0) + (oReclaim.MaxEnergyReclaim or 0) > 0 then
                                oNearestAnyValueReclaim = oReclaim
                                iNearestReclaimWithAnyValue = iCurDistToTargetPos
                            end
                        end
                    end
                end
                if not(oNearestReclaim) then
                    oNearestReclaim = oNearestAnyValueReclaim
                    --Check this is in the same zone
                    if oNearestReclaim and bCheckTerrain then
                        if not(NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oNearestReclaim.CachePosition) == NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oEngineer:GetPosition()) and M28Utilities.GetDistanceBetweenPositions(oNearestReclaim.CachePosition, oEngineer:GetPosition()) > iMaxDistanceToEngineer + math.min(oNearestReclaim:GetBlueprint().SizeX, oNearestReclaim:GetBlueprint().SizeZ)*0.5) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Ignoring reclaim as we cant path to it') end
                            oNearestReclaim = nil
                        end
                    end
                end

                if oNearestReclaim then
                    bGivenOrder = true
                    M28Orders.IssueTrackedReclaim(oEngineer, oNearestReclaim, false, 'ReclLZSeg')
                    if bDebugMessages == true then LOG(sFunctionRef..': Will send order to get reclaim at position '..repru(oNearestReclaim.CachePosition)..'; will draw a box around here; oNearestReclaim ID='..(oNearestReclaim.UnitId or 'nil')) M28Utilities.DrawLocation(oNearestReclaim.CachePosition) end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have any reclaim of sufficient value; iMinReclaimIndividualValue='..iMinReclaimIndividualValue) end
                end

            else
                if bDebugMessages == true then LOG(sFunctionRef..' No reclaim in nearby segments') end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': No segments in land zone with sufficient reclaim') end
        end
        if bGivenOrder and not(EntityCategoryContains(categories.COMMAND, oEngineer.UnitId)) then
            TrackEngineerAction(oEngineer, refActionReclaimArea, false, iCurPriority, nil, tiClosestSegmentXZ)
        elseif not(bGivenOrder) then
            --Flag that this zone has failed to find anything for engineers to reclaim, so we limit BP to assign to 5
            tLZOrWZData[M28Map.subrefiTimeFailedToGetReclaim] = GetGameTimeSeconds()
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function FilterEngineersOfTechAndEngiCountForFaction(iOptionalFactionRequired, tEngineersOfTechWanted)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'FilterEngineersOfTechAndEngiCountForFaction'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tEngineersOfFactionAndTechWanted
    tEngineersOfFactionAndTechWanted = {}
    local iRevisedEngiCount = 0
    for iTechEngi, oTechEngi in tEngineersOfTechWanted do
        if M28UnitInfo.GetUnitFaction(oTechEngi) == iOptionalFactionRequired then
            table.insert(tEngineersOfFactionAndTechWanted, oTechEngi)
            iRevisedEngiCount = iRevisedEngiCount + 1
            if bDebugMessages == true then LOG(sFunctionRef..': oTechEngi='..oTechEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTechEngi)..' is the right faction so including in revised list, iRevisedEngiCount='..iRevisedEngiCount) end
        end
    end
    if iRevisedEngiCount == 0 then M28Utilities.ErrorHandler('After filtering to a faction we have no available engineers - this shouldnt be possible') end
    --Now replace original table os we dont have to update below references (do by returning these values now since have moved this logic to a function)
    if bDebugMessages == true then LOG(sFunctionRef..': Finished updating list, iRevisedEngiCount='..iRevisedEngiCount..'; Last engi in list='..(tEngineersOfTechWanted[iEngiCount].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount]) or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tEngineersOfFactionAndTechWanted, iRevisedEngiCount

end

function ActiveShieldMonitor(oUnitToProtect, tLZTeamData, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ActiveShieldMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(oUnitToProtect[refbActiveUnitShieldingThread]) then
        oUnitToProtect[refbActiveUnitShieldingThread] = true
        local iShieldCategoryToBuild
        local iOptionalFactionRequired
        local iEngineerFactionRequired = M28UnitInfo.refCategoryEngineer
        local iTimeOfLastBlockingBuildingCheck
        local iPreviousAction
        local refiShieldActionConstruct = 1
        local refiShieldActionAssist = 2

        if oUnitToProtect[M28Building.refoNearbyFactoryOfFaction] then
            iOptionalFactionRequired = M28UnitInfo.GetUnitFaction(oUnitToProtect[M28Building.refoNearbyFactoryOfFaction])
        end
        if not(iOptionalFactionRequired) then iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield
        else
            if iOptionalFactionRequired == M28UnitInfo.refFactionSeraphim then
                --Does enemy have mavor? if so then want T3 shields not T2
                local bEnemyHasMavor = false
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure]) == false then
                    for iArti, oArti in M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure] do
                        if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalArti * categories.UEF, oArti.UnitId) then
                            bEnemyHasMavor = true
                        end
                    end
                end
                if bEnemyHasMavor then
                    iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.SERAPHIM
                else
                    --If go for T2 shielding then will be quicker to build and cheaper, and still cover the unit provided the shield can absorb a single shot
                    iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.TECH2 * categories.SERAPHIM
                end
                iEngineerFactionRequired = iEngineerFactionRequired * categories.SERAPHIM
            elseif iOptionalFactionRequired == M28UnitInfo.refFactionAeon then
                iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.AEON
                iEngineerFactionRequired = iEngineerFactionRequired * categories.AEON
            elseif iOptionalFactionRequired == M28UnitInfo.refFactionUEF then
                iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.UEF
                iEngineerFactionRequired = iEngineerFactionRequired * categories.UEF
            else
                iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield
            end
        end
        local sLikelyShieldBlueprint = M28Factory.GetMostExpensiveBlueprintOfCategory(iShieldCategoryToBuild)
        local iBlueprintBuildTime = (__blueprints[sLikelyShieldBlueprint].Economy.BuildTime or 1250)

        local aiBrain = oUnitToProtect:GetAIBrain()
        local iTotalAvailableLocations = 0
        for iEntry, tLocation in oUnitToProtect[M28Building.reftLocationsForPriorityShield] do
            iTotalAvailableLocations = iTotalAvailableLocations + 1
            if bDebugMessages == true then
                LOG(sFunctionRef..': Will draw tLocation in reftLocationsForPriorityShield')
                M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tLocation, M28UnitInfo.GetBuildingSize(sLikelyShieldBlueprint) * 0.5), 4, 200)
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop to protect the unit if it is still valid, is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnitToProtect))..'; Unit to protect='..(oUnitToProtect.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitToProtect) or 'nil')) end
        while M28UnitInfo.IsUnitValid(oUnitToProtect) do
            if bDebugMessages == true then LOG(sFunctionRef..': Loop start at time '..GetGameTimeSeconds()..'; Is table of engineers actively shielding empty='..tostring(M28Utilities.IsTableEmpty(oUnitToProtect[reftEngineersActivelyShielding]))) end
            if M28Utilities.IsTableEmpty(oUnitToProtect[reftEngineersActivelyShielding]) == false then
                --Decide what to do with the engineers - first see how many shields we have, and if any are compelted:
                local iConstructedShields = 0
                local iActiveShields = 0
                local iPartConstructedShields = 0
                local oNearestCompletionShield
                local iHighestPartCompleteShield = -0.01 --So a 0% complete building gets included
                local iLowestPartCompleteShield = 1.01
                local oLowestCompletionShield
                local oLastCompletedShield
                local iCurShield, iMaxShield
                local oLowestConstructedShieldHealth
                local iLowestConstructedShieldHealth = 100000
                if bDebugMessages == true then LOG(sFunctionRef..': oUnitToProtect='..oUnitToProtect.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToProtect)..'; Is table of special assigned shields empty='..tostring(M28Utilities.IsTableEmpty(oUnitToProtect[M28Building.reftoSpecialAssignedShields]))) end
                if M28Utilities.IsTableEmpty(oUnitToProtect[M28Building.reftoSpecialAssignedShields]) == false then
                    local tiEntriesToRemove = {}
                    for iShield, oShield in oUnitToProtect[M28Building.reftoSpecialAssignedShields] do
                        if M28UnitInfo.IsUnitValid(oShield) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering assigned shield oShield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; Fraction complete='..oShield:GetFractionComplete()) end
                            if oShield:GetFractionComplete() == 1 then
                                iConstructedShields = iConstructedShields + 1
                                oLastCompletedShield = oShield
                                iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': COnsidering shield health of constructed shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; iCurShield='..iCurShield..'; iMaxShield='..iMaxShield..'; iLowestConstructedShieldHealth='..iLowestConstructedShieldHealth..'; oUnit.MyShield:GetHealth()='..(oShield.MyShield:GetHealth() or 'nil')..'; Shield ratio='..(oShield:GetShieldRatio(false) or 0)..'; IsUp='..tostring(oShield.MyShield:IsUp())..'; IsOn='..tostring(oShield.MyShield:IsOn())..'; Depleted by damage='..tostring(oShield.DepletedByDamage or false)) end
                                if iCurShield > 0 then iActiveShields = iActiveShields + 1 end
                                if iCurShield < iLowestConstructedShieldHealth then
                                    oLowestConstructedShieldHealth = oShield
                                    iLowestConstructedShieldHealth = iCurShield
                                end
                            else
                                iPartConstructedShields = iPartConstructedShields + 1
                                if oShield:GetFractionComplete() > iHighestPartCompleteShield then
                                    iHighestPartCompleteShield = oShield:GetFractionComplete()
                                    oNearestCompletionShield = oShield
                                end
                                if oShield:GetFractionComplete() < iLowestPartCompleteShield then
                                    iLowestPartCompleteShield = oShield:GetFractionComplete()
                                    oLowestCompletionShield = oShield
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Have a part constructed shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' with fraction compelte '..oShield:GetFractionComplete()..'; oNearestCompletionShield='..(oNearestCompletionShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestCompletionShield) or 'nil')) end
                            end
                        else
                            tiEntriesToRemove[iShield] = true
                        end
                    end
                    if M28Utilities.IsTableEmpty(tiEntriesToRemove) == false then
                        for iEntry, bRemove in tiEntriesToRemove do
                            oUnitToProtect[M28Building.reftoSpecialAssignedShields][iEntry] = nil
                        end
                    end
                end

                function ConstructNewShield()
                    --Need to construct a new shield (need to be wanting to do this for at least a tick due to delay in constructionstarting triggering due to forked thread)
                    local tPositionToBuild
                    if bDebugMessages == true then LOG(sFunctionRef..': ConstructNewShield: repru of locations for priority shield='..repru(oUnitToProtect[M28Building.reftLocationsForPriorityShield])..'; sLikelyShieldBlueprint='..(sLikelyShieldBlueprint or 'nil')..'; iPreviousAction='..(iPreviousAction or 'nil')..'; oLowestConstructedShieldHealth='..(oLowestConstructedShieldHealth.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oLowestConstructedShieldHealth) or 'nil')..'; ') end
                    if not(iPreviousAction == refiShieldActionConstruct) then
                        --If previous action was to assist, then clear all engineers to avoid the risk we keep building something we want to be left part complete
                        if iPreviousAction == refiShieldActionAssist then
                            for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                                M28Orders.IssueTrackedClearCommands(oEngineer)
                            end
                        end
                    else
                        for iEntry, tLocation in oUnitToProtect[M28Building.reftLocationsForPriorityShield] do
                            --basic check whether we can build (we should already be able to)
                            if bDebugMessages == true then LOG(sFunctionRef..': Can we build sLikelyShieldBlueprint '..sLikelyShieldBlueprint..' at tLocation '..repru(tLocation)..'='..tostring(aiBrain:CanBuildStructureAt(sLikelyShieldBlueprint, tLocation))) end
                            if aiBrain:CanBuildStructureAt(sLikelyShieldBlueprint, tLocation) then
                                tPositionToBuild = tLocation
                                break
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': tPositionToBuild='..repru(tPositionToBuild)) end
                        if tPositionToBuild then
                            local toEngineersOfWrongFaction = {}
                            local oFirstEngineerOfRightFaction
                            for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Does this contain the required faction='..tostring(EntityCategoryContains(iEngineerFactionRequired, oEngineer.UnitId))) end
                                if EntityCategoryContains(iEngineerFactionRequired, oEngineer.UnitId) then
                                    local sBlueprintToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, iShieldCategoryToBuild, oEngineer, false, false, false, nil, false)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Checking what shields engineer '..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil')..' can build; iOptionalFactionRequired='..(iOptionalFactionRequired or 'nil')..'; Will try and build unit '..sBlueprintToBuild..' at position '..repru(tPositionToBuild)) end
                                    M28Orders.IssueTrackedBuild(oEngineer, tPositionToBuild, sBlueprintToBuild, false, 'SpEBS')
                                    if not(oFirstEngineerOfRightFaction) then oFirstEngineerOfRightFaction = oEngineer end
                                else
                                    table.insert(toEngineersOfWrongFaction, oEngineer)
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Finished telling engineers of right faction to build, Is table of engineers of wrong faction empty='..tostring(M28Utilities.IsTableEmpty(toEngineersOfWrongFaction))) end
                            if M28Utilities.IsTableEmpty(toEngineersOfWrongFaction) == false then
                                if oFirstEngineerOfRightFaction then
                                    for iEngineer, oEngineer in toEngineersOfWrongFaction do
                                        M28Orders.IssueTrackedGuard(oEngineer, oFirstEngineerOfRightFaction, false, 'SpEGE', false)
                                    end
                                end
                            end
                        else
                            M28Utilities.ErrorHandler('We are unable to build at a predefined shield location, will check for small blocking M28 buildings and destroy them', true)
                            --Only search for units that are actually built on the shield location - so e.g. this wont cover if a factory is built where part of the factory covers the shield location
                            local iSearchRadius = M28UnitInfo.GetBuildingSize(sLikelyShieldBlueprint) * 0.5 - 0.49 --even at -0.75 will get units that arent in the build area being included
                            if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through oUnitToProtect[M28Building.reftLocationsForPriorityShield]='..repru(oUnitToProtect[M28Building.reftLocationsForPriorityShield])..'; iSearchRadius='..iSearchRadius..'; iTimeOfLastBlockingBuildingCheck='..(iTimeOfLastBlockingBuildingCheck or 'nil')) end
                            if GetGameTimeSeconds() - (iTimeOfLastBlockingBuildingCheck or -100) >= 5 then
                                iTimeOfLastBlockingBuildingCheck = GetGameTimeSeconds()
                                for iEntry, tLocation in oUnitToProtect[M28Building.reftLocationsForPriorityShield] do
                                    local rShieldAreaRect = M28Utilities.GetRectAroundLocation(tLocation, iSearchRadius)
                                    local tUnitsNearby = GetUnitsInRect(rShieldAreaRect)
                                    local oCurBuildingBP
                                    if M28Utilities.IsTableEmpty(tUnitsNearby) == false then
                                        local tBuildingsNearby = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryFixedShield - M28UnitInfo.refCategoryMex - M28UnitInfo.refCategoryHydro, tUnitsNearby)
                                        if M28Utilities.IsTableEmpty(tBuildingsNearby) == false then
                                            --Do we have a shield near her?
                                            local bNearbyShield = false
                                            local tShieldsNearby = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, tUnitsNearby)
                                            if M28Utilities.IsTableEmpty(tShieldsNearby) == false then
                                                --Redundancy - check if have any shields near here and both dont do the kill logic if we do, and also assign such shields to the game ender
                                                for iShield, oShield in tShieldsNearby do
                                                    if oShield:GetAIBrain().M28AI and oShield:GetAIBrain().M28Team == iTeam then
                                                        if M28Utilities.GetRoughDistanceBetweenPositions(oShield:GetPosition(), tLocation) <= 4 then
                                                            bNearbyShield = true
                                                            if oShield['OnConstructionStarted'] then
                                                                --We for some reason havent assigned this shield against the game ender so will now
                                                                local oFirstEngineer
                                                                for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                                                                    oFirstEngineer = oEngineer
                                                                    break
                                                                end
                                                                ForkThread(AssignShieldToGameEnder, oShield, oFirstEngineer)
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                            if not(bNearbyShield) then
                                                for iBuilding, oBuilding in tBuildingsNearby do
                                                    if oBuilding:GetAIBrain().M28AI and oBuilding:GetAIBrain().M28Team == aiBrain.M28Team then
                                                        oCurBuildingBP = oBuilding:GetBlueprint()
                                                        if (oCurBuildingBP.Economy.BuildCostMass or 0) * oBuilding:GetFractionComplete() <= 5000 then
                                                            --Check the building position and size means it is actually a blocking building
                                                            if oBuilding:GetPosition()[1] >= rShieldAreaRect[1] and oBuilding:GetPosition()[1] <= rShieldAreaRect[3] and oBuilding:GetPosition()[3] >= rShieldAreaRect[2] and oBuilding:GetPosition()[3] <= rShieldAreaRect[2] then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Will destroy blocking building='..oBuilding.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBuilding)..'; Building position='..repru(oBuilding:GetPosition())..'; will draw rectangle that this is within')
                                                                    M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tLocation, iSearchRadius))
                                                                end
                                                                M28Orders.IssueTrackedKillUnit(oBuilding)
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    iPreviousAction =  refiShieldActionConstruct
                end

                function AssistShield(oShield)
                    --Assist this (if bPauseEngineers is true then will make sure every engineer is paused so they dont actually complete it)
                    if oShield:GetFractionComplete() < 1 then
                        if bDebugMessages == true then LOG(sFunctionRef..': AssistShield: Will repair shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' with fraction complete '..oShield:GetFractionComplete()) end
                        for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                            M28Orders.IssueTrackedRepair(oEngineer, oShield, false, 'SpecShR', false)
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': AssistShield: Will assist shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' with fraction complete '..oShield:GetFractionComplete()) end
                        for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Giving guard order to oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer))
                                local oFocusUnit = oEngineer:GetFocusUnit()
                                if oFocusUnit then
                                    LOG(sFunctionRef..': Engineer cur focus unit='..oFocusUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFocusUnit))
                                end
                            end
                            M28Orders.IssueTrackedGuard(oEngineer, oShield, false, 'SpecShG', false)
                        end
                    end
                    iPreviousAction =  refiShieldActionAssist
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Deciding what to do, iConstructedShields='..iConstructedShields..'; iPartConstructedShields='..iPartConstructedShields..'; iHighestPartCompleteShield='..iHighestPartCompleteShield..'; iActiveShields='..iActiveShields..'; iTotalAvailableLocations='..iTotalAvailableLocations) end
                if iConstructedShields == 0 then
                    --Want to build a shield - complete the closest to completion if we have any
                    if oNearestCompletionShield then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to construct a shield, will assist the one nearest completion='..oNearestCompletionShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestCompletionShield)..' fraction complete='..oNearestCompletionShield:GetFractionComplete()) end
                        AssistShield(oNearestCompletionShield)
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to construct a shield, none under construction so will build a new one') end
                        ConstructNewShield()
                    end
                else
                    --We already have 1 constructed shield, want to make sure we have another shield that is closest to completion next
                    --% wanted - if are assigning 500 build power to this, and the shortest BT shield is 1250, then in theory we could end up building the shield in 0.4s, i.e. each tick would be 4%.  In reality this seems unlikely though
                    local iPercentCompleteWanted
                    local iTotalBuildPowerAvailable = 0
                    for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                        iTotalBuildPowerAvailable = iTotalBuildPowerAvailable + oEngineer:GetBlueprint().Economy.BuildRate
                    end
                    if aiBrain.M28AI then
                        iTotalBuildPowerAvailable = iTotalBuildPowerAvailable * M28Team.tTeamData[aiBrain.M28Team][M28Team.refiHighestBrainBuildMultiplier]
                    end
                    --Treat build power as being 50% more than it actually is to give a bit more leeway
                    iPercentCompleteWanted = math.min(0.99, math.max(0.8, 1 - iTotalBuildPowerAvailable * 2.5 / (iBlueprintBuildTime * 10) - 0.002))
                    if iPartConstructedShields > 0 and iHighestPartCompleteShield < iPercentCompleteWanted then
                        --Want to assist existing part complete shield
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to assist existing part complete shield as it isnt near complete yet, iPercentCompleteWanted='..iPercentCompleteWanted..'; oNearestCompletionShield='..oNearestCompletionShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestCompletionShield)..'; Fraction complete='..oNearestCompletionShield:GetFractionComplete()) end
                        AssistShield(oNearestCompletionShield)
                    else
                        --We have at least 1 constructed shield, and at least 1 shield whose % complete is at the level wanted; Therefore we want a 3rd shield that is near-complete constructed
                        if iPartConstructedShields + iConstructedShields < iTotalAvailableLocations then
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to build a new shiled as we have more available locations than we have shields built or started building') end
                            ConstructNewShield()
                        else
                            --Get the lowest complete shield to assist if it needs it
                            if iPartConstructedShields > 0 and (iLowestPartCompleteShield < iPercentCompleteWanted or iActiveShields == 0) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to assist the lowest complete shield as it isnt nearly done, oLowestCompletionShield='..oLowestCompletionShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLowestCompletionShield)..'; Fraction complete='..oLowestCompletionShield:GetFractionComplete()) end
                                AssistShield(oLowestCompletionShield)
                            else
                                --We have 1 complete shield, and all other shield locations have near-complete shields, so dont want to do anything else - have the engineers assist the completed shield
                                if bDebugMessages == true then LOG(sFunctionRef..': Nothing to do so will assist a complete shield, oLastCompletedShield='..oLastCompletedShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLastCompletedShield)) end
                                AssistShield(oLastCompletedShield)
                            end
                        end
                    end
                end

                --Decide whether to ctrlK shield so can start building another
                if iConstructedShields >= math.max(iTotalAvailableLocations, 2) or (iConstructedShields > 1 and iConstructedShields + iPartConstructedShields >= iTotalAvailableLocations and iActiveShields < iConstructedShields) then
                    --CtrlK a completed shield with the lowest shield value
                    if bDebugMessages == true then LOG(sFunctionRef..': iConstructedShields='..iConstructedShields..'; iTotalAvailableLocations='..iTotalAvailableLocations..'; iConstructedShields='..iConstructedShields..'; iPartConstructedShields='..iPartConstructedShields..'; iActiveShields='..iActiveShields..'; iLowestConstructedShieldHealth='..(iLowestConstructedShieldHealth or 'nil')) end
                    M28Orders.IssueTrackedKillUnit(oLowestConstructedShieldHealth)
                end

                --Make sure engineers show the action they have been assigned (as will have had orders cleared from above) - changed so will no longer clear in M28Orders
                --[[local bFirstEngineer = true
                for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                    if not(oEngineer[refiAssignedAction] == refActionSpecialShieldDefence) then
                        TrackEngineerAction(oEngineer, refActionSpecialShieldDefence, bFirstEngineer, iPriorityToUse)
                        if bFirstEngineer then bFirstEngineer = false end
                    end
                end--]]


            else
                if bDebugMessages == true then LOG(sFunctionRef..': Engineers no longer actively shielding, will end the loop at time '..GetGameTimeSeconds()) end
                oUnitToProtect[refbActiveUnitShieldingThread] = false
                break
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code at time '..GetGameTimeSeconds()..'; Is game ender valid='..tostring(M28UnitInfo.IsUnitValid(oUnitToProtect) or false)..'; ActiveShieldMonitoe='..tostring(oUnitToProtect[refbActiveUnitShieldingThread] or false)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AssignEngineerToShieldDefenceDuty(oEngineer, tLZTeamData)
    --Get the highest value unit to defend (for now will only support 1 unit for shield defence duty)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignEngineerToShieldDefenceDuty'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local oUnitToProtect
    local iHighestMassValue = 0
    local iCurMassValue
    for iGameEnder, oGameEnder in tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
        if M28UnitInfo.IsUnitValid(oGameEnder) then
            iCurMassValue = oGameEnder:GetBlueprint().Economy.BuildCostMass * oGameEnder:GetFractionComplete()
            if iCurMassValue > iHighestMassValue then
                iHighestMassValue = iCurMassValue
                oUnitToProtect = oGameEnder
            end
        end
    end
    if not(oUnitToProtect) then
        --Clear engineer actions as we dont have something for them to do after all
        ClearEngineerTracking(oEngineer)
    else
        if not(oUnitToProtect[reftEngineersActivelyShielding]) then oUnitToProtect[reftEngineersActivelyShielding] = {} end
        table.insert(oUnitToProtect[reftEngineersActivelyShielding], oEngineer)
        oEngineer[refoUnitActivelyShielding] = oUnitToProtect
        if not(oUnitToProtect[refbActiveUnitShieldingThread]) then
            ForkThread(ActiveShieldMonitor, oUnitToProtect, tLZTeamData, oEngineer:GetAIBrain().M28Team)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function ConsiderActionToAssign(iActionToAssign, iMinTechWanted, iTotalBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iCurPriority, tLZOrWZData, tLZOrWZTeamData, iTeam, iPlateauOrPond, iLandOrWaterZone, toAvailableEngineersByTech, toAssignedEngineers, bIsWaterZone, iSpecificFactionRequiredOverride, bDontUseLowerTechEngineersToAssist)
    --vOptionalVariable can be a table, nil or a value; used to pass info specific to the action if it needs it
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderActionToAssign'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Dont try getting any mroe BP for htis action if have run out of buildable locations
    local iExpectedBuildingSize = tiLastBuildingSizeFromActionForTeam[iTeam][iActionToAssign]
    if bDebugMessages == true then
        if iExpectedBuildingSize then
            LOG(sFunctionRef..': iExpectedBuildingSize='..(iExpectedBuildingSize or 'nil')..';  tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]='..( tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iExpectedBuildingSize] or 'nil')..'; iMinTechWanted='..(iMinTechWanted or 'nil'))
        else
            LOG(sFunctionRef..': iExpectedBuildingSize is nil,='..(iExpectedBuildingSize or 'nil')..'; iMinTechWanted='..(iMinTechWanted or 'nil'))
        end
    end
    if iExpectedBuildingSize and (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iExpectedBuildingSize] or 0) == 0 then
        if not(iActionToAssign == refActionBuildMex) and not(iActionToAssign == refActionBuildHydro) then
            local iPlateauOrZero

            if bIsWaterZone then iPlateauOrZero = 0 else iPlateauOrZero = iPlateauOrPond end
            if (tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] or 0) < 20 then
                --SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iOptionalMaxSegmentsToConsider)
                SearchForBuildableLocationsForLandOrWaterZone(M28Team.GetFirstActiveM28Brain(iTeam), iPlateauOrZero, iLandOrWaterZone, 20)
            end
            if (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iExpectedBuildingSize] or 0) == 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Setting build power to 0 as no buildable locations, tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick]='..(tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] or 'nil')..'; repru of tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize] for all sizes='..repru(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize])) end
                iTotalBuildPowerWanted = 0
            end
        end
    end

    if iTotalBuildPowerWanted < 0 then M28Utilities.ErrorHandler('Have negative BP wanted')
    elseif iTotalBuildPowerWanted > 0 then
        --Reduce BP for high modifiers where we have at least 50% mass stored and dont have spare engineers
        if iTotalBuildPowerWanted > 60 and M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier] >= 1.5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 and tLZOrWZTeamData[M28Map.subrefTbWantBP] and (tLZOrWZTeamData[M28Map.subrefSpareBPByTech][1] == 0 and tLZOrWZTeamData[M28Map.subrefSpareBPByTech][2] == 0 and tLZOrWZTeamData[M28Map.subrefSpareBPByTech][3] == 0) then
            --Only half BP for building the first power if we have lots of power already
            if not(iActionToAssign == refActionBuildPower) or (iMinTechWanted == 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultipler] * 500) then
                iTotalBuildPowerWanted = iTotalBuildPowerWanted * math.max(1 / M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier], 0.4)
                if bDebugMessages == true then LOG(sFunctionRef..': Halfing build power wanted') end
            end
        end

        --Reclaim specific - limit BP to 5 if we have recenlty failed to find something to reclaim
        if tLZOrWZData[M28Map.subrefiTimeFailedToGetReclaim] and GetGameTimeSeconds() - tLZOrWZData[M28Map.subrefiTimeFailedToGetReclaim] <= 3 then
            if bDebugMessages == true then LOG(sFunctionRef..': Time since last failed to get reclaim for this zone='..GetGameTimeSeconds() - tLZOrWZData[M28Map.subrefiTimeFailedToGetReclaim]..'; BP wanted before limitation='..iTotalBuildPowerWanted..'; will cap at 5') end
            iTotalBuildPowerWanted = math.min(5, iTotalBuildPowerWanted)

        end


        --Experimental specific - Dont want to build if we have other engineers in a different zone building an experimental and we dont have the eco to support multiple ones - instead rely on separate engi transfer and mass transfer logic to get the experimental built
        if (iActionToAssign == refActionBuildExperimental or iActionToAssign == refActionBuildSecondExperimental or iActionToAssign == refActionBuildGameEnder or iActionToAssign == refActionBuildExperimentalNavy or iActionToAssign == refActionBuildLandExperimental) then
            if bDebugMessages == true then LOG(sFunctionRef..': About to remove BP wanted for experimental construction if we already have one under construction nearby that has recently started, or are about to start construction, and we cant support multiple at once, and dont have one in this zone') end
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]) == false and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 400 then
                --Do we have negative mass income, or have less than 70% mass stored? Also only consider for land experimentals (not navy) for now:
                if not(bIsWaterZone) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] < 1 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] < 0.7) then
                    --NOTE: If changing above thresholds then make sure the M28Events OnConstructionStarted is stricter
                    local iSearchRange = math.max(150, 400 - M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass])
                    local iSearchCategory = nil --means will search for everything
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 140 then
                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 280 then
                            iSearchCategory = M28UnitInfo.refCategoryGameEnder
                        else
                            iSearchCategory = M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti
                        end
                    end
                    local bHaveExperimentalForThisLandZone, iOtherLandZonesWithExperimental, iMassToComplete = GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateauOrPond, iLandOrWaterZone, true, iSearchRange, iSearchCategory)
                    if iMassToComplete >= math.max(15000, M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] * 1.25) and not(bHaveExperimentalForThisLandZone) then
                        --Estimate how long it will take to complete if we manage to spend 40% of gross mass on existing experimentals
                        if (iMassToComplete - M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]) / M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 0.4 > 40 then
                            iTotalBuildPowerWanted = 0
                            if bDebugMessages == true then LOG(sFunctionRef..': iMassToComplete='..iMassToComplete..'; Mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; will set BPWanted to 0') end
                        end
                    end
                end
            end
        end
        --Reduce the build power wanted by the existing build power assigned to that action for the LZ, unless bBPIsInAdditionToExisting is true
        local bAlreadyHaveTechLevelWanted = false
        if M28Utilities.IsTableEmpty(toAssignedEngineers) == false and iTotalBuildPowerWanted > 0 then
            for iEngi, oEngi in toAssignedEngineers do
                if not(oEngi[M28UnitInfo.refbSpecialMicroActive]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..': Considering if oEngi '..oEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngi)..' already has iActionToAssign '..iActionToAssign..'; oEngi[refiAssignedAction]='..(oEngi[refiAssignedAction] or 'nil')..'; Engi tech level='..M28UnitInfo.GetUnitTechLevel(oEngi)..'; iMinTechWanted='..iMinTechWanted) end
                    if oEngi[refiAssignedAction] == iActionToAssign then
                        if not(bAlreadyHaveTechLevelWanted) and M28UnitInfo.GetUnitTechLevel(oEngi) >= iMinTechWanted then
                            --Only flag as having min tech level wanted if we will be able to make use of this engineer per the later code
                            if not(tbIgnoreEngineerAssistance[iActionToAssign]) and oEngi[M28Orders.reftiLastOrders] and oEngi[M28Orders.reftiLastOrders][oEngi[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild then
                                bAlreadyHaveTechLevelWanted = true
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Reducing total Build power wanted by '..oEngi:GetBlueprint().Economy.BuildRate..' unless bBPIsInAdditionToExisting is true; bBPIsInAdditionToExisting='..tostring(bBPIsInAdditionToExisting or false)) end
                        if not(bBPIsInAdditionToExisting) then
                            iTotalBuildPowerWanted = iTotalBuildPowerWanted - oEngi:GetBlueprint().Economy.BuildRate
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': About to check if want to lower tech level wanted, bAlreadyHaveTechLevelWanted='..tostring(bAlreadyHaveTechLevelWanted)..'; iMinTechWanted='..iMinTechWanted..'; Is campaign map='..tostring(M28Map.bIsCampaignMap)) end
        if bAlreadyHaveTechLevelWanted and not(bDontUseLowerTechEngineersToAssist) then iMinTechWanted = 1
            --Campaign - might have T3 air fac but not be able to build T3 engineers
        elseif iMinTechWanted > 1 and (M28Map.bIsCampaignMap or M28Overseer.bUnitRestrictionsArePresent) and (iActionToAssign == refActionBuildLandFactory or iActionToAssign == refActionBuildAirFactory or iActionToAssign == refActionBuildPower or iActionToAssign == refActionBuildSecondLandFactory or iActionToAssign == refActionBuildSecondAirFactory) and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
            --Check we have engineers of the relevant tech level to be able to build the factory
            local iEngiCategoryWanted
            if iMinTechWanted >= 3 then iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer * categories.TECH3
            else iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer - categories.TECH1
            end
            local tExistingEngineersOfCategory = EntityCategoryFilterDown(iEngiCategoryWanted, tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits])
            if bDebugMessages == true then LOG(sFunctionRef..': Is tExistingEngineersOfCategory empty='..tostring(M28Utilities.IsTableEmpty(tExistingEngineersOfCategory))) end
            if M28Utilities.IsTableEmpty(tExistingEngineersOfCategory) then
                if bDebugMessages == true then LOG(sFunctionRef..': Will lower min tech level wanted to build a factory due to being a campaign or having unit restrictions') end
                iMinTechWanted = iMinTechWanted - 1
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; iActionToAssign='..iActionToAssign..'; iTeam='..iTeam..'; iPlateauOrPond='..iPlateauOrPond..'; iLandOrWaterZone='..iLandOrWaterZone..'; Have just updated BP wanted for existing engineers with the same action, iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; Is toAvailableEngineersByTech empty='..tostring(M28Utilities.IsTableEmpty(toAvailableEngineersByTech))..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted) end


        --Do we have an engineer of the tech level wanted? First assign any available engineers of the right tech level to the action
        --If we dont have any engineers of the right tech level available, then see if we have an engineer with a lower priority action
        local tEngineersOfTechWanted
        if toAvailableEngineersByTech and iTotalBuildPowerWanted > 0 then tEngineersOfTechWanted = GetEngineersOfTechWanted(iMinTechWanted, toAvailableEngineersByTech) end
        if M28Utilities.IsTableEmpty(toAvailableEngineersByTech) and iTotalBuildPowerWanted > 0 and M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
            --Do we have already assigned engineers with a lower priority that we could use?
            local iEngiCategoryWanted
            if iMinTechWanted <= 1 then iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer
            elseif iMinTechWanted == 2 then iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer * categories.TECH2 + M28UnitInfo.refCategoryEngineer * categories.TECH3
            else iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer * categories.TECH3
            end
            local toAssignedEngisOfTechLevel = EntityCategoryFilterDown(iEngiCategoryWanted, toAssignedEngineers)
            if M28Utilities.IsTableEmpty(toAssignedEngisOfTechLevel) == false then
                tEngineersOfTechWanted = {}
                local iHighestPriorityEngi = iCurPriority
                local oHighestPriorityEngi
                for iEngi, oEngi in toAssignedEngisOfTechLevel do
                    if not(oEngi[refbPrimaryBuilder]) and not(oEngi[refiAssignedAction] == iActionToAssign) and oEngi[refiAssignedActionPriority] > iHighestPriorityEngi and not(oEngi:IsUnitState('Reclaiming')) and not(oEngi:IsUnitState('Attached')) and not(oEngi:IsUnitState('Capturing')) then
                        --Exception for engineers assisting a shield
                        if not(oEngi[refiAssignedAction] == refActionAssistShield) or not(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) then
                            iHighestPriorityEngi = oEngi[refiAssignedActionPriority]
                            oHighestPriorityEngi = oEngi
                        end
                    end
                end
                if oHighestPriorityEngi then
                    table.insert(tEngineersOfTechWanted, oHighestPriorityEngi)
                    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; iMinTechWanted='..iMinTechWanted..'; oHighestPriorityEngi='..oHighestPriorityEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oHighestPriorityEngi)..'; oHighestPriorityEngi action='..(oHighestPriorityEngi[refiAssignedAction] or 'nil')..' with a priority '..(oHighestPriorityEngi[refiAssignedActionPriority] or 'nil')..'; Is primary='..tostring(oHighestPriorityEngi[refbPrimaryBuilder] or false)..'; table size='..table.getn(tEngineersOfTechWanted)) end
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Is tEngineersOfTechWanted empty='..tostring(M28Utilities.IsTableEmpty(tEngineersOfTechWanted))) end
        if M28Utilities.IsTableEmpty(tEngineersOfTechWanted) == false and iTotalBuildPowerWanted > 0 then

            local sOrderRef = 'A'..iActionToAssign..'Pr'..iCurPriority --For debugging - if show unit names then will include this
            local iMaxSearchRange = 180 --Must be bigger than the largest land zone or else units wont be able to build, so can lead to engineers entering a land zone to build and then moving away to a different land zone
            local iEngiCount = table.getn(tEngineersOfTechWanted)
            local iCurEngiTechLevel
            local iCurEngiBuildPower
            local aiBrain = tEngineersOfTechWanted[1]:GetAIBrain()
            local iMinCategoryTechLevel = iMinTechWanted
            --Override tech level if we lack the relevant factory HQ
            if iActionToAssign == refActionBuildLandFactory or iActionToAssign == refActionBuildSecondLandFactory then
                iMinCategoryTechLevel = math.max(1, math.min(iMinTechWanted, (aiBrain[M28Economy.refiOurHighestLandFactoryTech] or 1)))
            elseif iActionToAssign == refActionBuildAirFactory or iActionToAssign == refActionBuildSecondAirFactory then
                iMinCategoryTechLevel = math.max(1, math.min(iMinTechWanted, (aiBrain[M28Economy.refiOurHighestAirFactoryTech] or 1)))
            elseif iActionToAssign == refActionBuildNavalFactory then
                iMinCategoryTechLevel = math.max(1, math.min(iMinTechWanted, (aiBrain[M28Economy.refiOurHighestNavalFactoryTech] or 1)))
            end
            --Check faction available
            local tbEngineersOfFaction
            if tbActionsWithFactionSpecificLogic[iActionToAssign] and not(bAlreadyHaveTechLevelWanted) then
                tbEngineersOfFaction = {}
                for iUnit, oUnit in tEngineersOfTechWanted do
                    tbEngineersOfFaction[M28UnitInfo.GetUnitFaction(oUnit)] = true
                end
            end

            local iCategoryWanted, iOptionalFactionRequired = GetCategoryToBuildOrAssistFromAction(iActionToAssign, iMinCategoryTechLevel, aiBrain, tbEngineersOfFaction, tLZOrWZData, tLZOrWZTeamData)
            --Land and air facs - optional variable can be used to specify max tech level to use
            if vOptionalVariable and (iActionToAssign == refActionBuildAirFactory or iActionToAssign == refActionBuildLandFactory or iActionToAssign == refActionBuildSecondLandFactory or iActionToAssign == refActionBuildSecondLandFactory) and vOptionalVariable >= iMinCategoryTechLevel and (vOptionalVariable == 1 or vOptionalVariable == 2) then
                iCategoryWanted = iCategoryWanted * M28UnitInfo.ConvertTechLevelToCategory(vOptionalVariable)
            end
            if iSpecificFactionRequiredOverride and not(iOptionalFactionRequired) then iOptionalFactionRequired = iSpecificFactionRequiredOverride end

            function UpdateBPTracking()
                iCurEngiTechLevel = M28UnitInfo.GetUnitTechLevel(tEngineersOfTechWanted[iEngiCount])
                iCurEngiBuildPower = tEngineersOfTechWanted[iEngiCount]:GetBlueprint().Economy.BuildRate
                iTotalBuildPowerWanted = iTotalBuildPowerWanted - iCurEngiBuildPower
                if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[iCurEngiTechLevel]) == false then --If we are reassigning an engineer this wont have a value
                    for iEngi, oEngi in toAvailableEngineersByTech[iCurEngiTechLevel] do
                        if oEngi == tEngineersOfTechWanted[iEngiCount] then
                            table.insert(toAssignedEngineers, tEngineersOfTechWanted[iEngiCount])
                            table.remove(toAvailableEngineersByTech[iCurEngiTechLevel], iEngi)
                            break
                        end
                    end
                end

                tEngineersOfTechWanted[iEngiCount] = nil
                iEngiCount = iEngiCount - 1
            end

            if bDebugMessages == true then LOG(sFunctionRef..': iActionToAssign='..iActionToAssign..'; iEngiCount='..iEngiCount..'; Is category watned nil='..tostring(iCategoryWanted == nil)) end


            if iCategoryWanted then
                --Do we have a part complete unit of this category already under construction in this land zone?
                --Building a factory - change whether to search for assistance based on mass stored %; for mass storage instead base the check on how many locations we have as we may be trying to build a second storage
                local bShouldIgnoreUnderConstruction = tbIgnoreUnderConstructionActions[iActionToAssign]
                if iActionToAssign == refActionBuildLandFactory or iActionToAssign == refActionBuildAirFactory then
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 then bShouldIgnoreUnderConstruction = true end
                elseif iActionToAssign == refActionBuildMassStorage and table.getn(M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZMassStorageLocationsAvailable]) >= 5 then bShouldIgnoreUnderConstruction = true
                elseif bShouldIgnoreUnderConstruction and iActionToAssign == refActionBuildSecondExperimental then
                    if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti + M28UnitInfo.refCategoryParagon + M28UnitInfo.refCategorySML * categories.EXPERIMENTAL, iCategoryWanted) then
                        bShouldIgnoreUnderConstruction = false
                    end
                end

                local oBuildingToAssist
                if not(bShouldIgnoreUnderConstruction) then
                    --We adjust power to only consider the min tech levle not higher ones (presumably so we can build t1/t2 power when we have access to t3, if we need more power to build t3); therefore need to take this into account here
                    local iUnderConstructionCategory
                    if iActionToAssign == refActionBuildPower then
                        iUnderConstructionCategory = M28UnitInfo.refCategoryPower - M28UnitInfo.refCategoryHydro
                    else iUnderConstructionCategory = iCategoryWanted
                    end
                    oBuildingToAssist = GetPartCompleteBuildingInZone(iTeam, iPlateauOrPond, iLandOrWaterZone, iUnderConstructionCategory, bIsWaterZone)
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking to see if we have a unit of the desired category. oBuildingToAssist='..(oBuildingToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBuildingToAssist) or 'nil')) end
                end

                if oBuildingToAssist then
                    --Assist the building under construction that has the category we want
                    while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                        if bDebugMessages == true then LOG(sFunctionRef..': Assigning engineer for repair action '..iActionToAssign..'; iEngiCount='..iEngiCount..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted) end
                        M28Orders.IssueTrackedRepair(tEngineersOfTechWanted[iEngiCount], oBuildingToAssist, false, sOrderRef)
                        TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, not(bAlreadyHaveTechLevelWanted), iCurPriority)
                        UpdateBPTracking()
                    end
                else
                    --Dont have any buildings of the type wanted under construction; do we have an engineer already assigned to the same action? If so then assist it
                    local oEngineerToAssist
                    if not(tbIgnoreEngineerAssistance[iActionToAssign]) and M28Utilities.IsTableEmpty(toAssignedEngineers) == false then

                        for iEngi, oEngi in toAssignedEngineers do
                            if oEngi[refiAssignedAction] == iActionToAssign then
                                --Only assist if engi last order was to build
                                if bDebugMessages == true then
                                    if oEngi[M28Orders.reftiLastOrders] then
                                        LOG(sFunctionRef..': Considering if oEngi '..oEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngi)..' can be assisted to build this; tablegetn of last orders='..oEngi[M28Orders.refiOrderCount]..'; reprs of last orders='..reprs(oEngi[M28Orders.reftiLastOrders])..'; refiOrderCount='..oEngi[M28Orders.refiOrderCount]..'; Is the last order to build something='..tostring(oEngi[M28Orders.reftiLastOrders][oEngi[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild))
                                    else
                                        LOG(sFunctionRef..': Considering if oEngi '..oEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngi)..' can be assisted to build this; Engi last orders is nil, reprs='..reprs(oEngi[M28Orders.reftiLastOrders]))
                                    end
                                end
                                if oEngi[M28Orders.reftiLastOrders] and oEngi[M28Orders.reftiLastOrders][oEngi[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild then
                                    if bDebugMessages == true then LOG(sFunctionRef..': We can assist the engineer') end
                                    oEngineerToAssist = oEngi
                                    break
                                end
                            end
                        end
                    end
                    if not(oEngineerToAssist) then
                        --Has a building been queued for this land zone even if we havent found an engineer to assist? (e.g. rare cases where engineer queues order then briefly drops out of the land zone list of engineers)
                        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefQueuedBuildings]) == false and not(bShouldIgnoreUnderConstruction) and not(tbIgnoreEngineerAssistance[iActionToAssign]) then
                            for iEntry, tQueuedDetails in tLZOrWZTeamData[M28Map.subrefQueuedBuildings] do
                                if EntityCategoryContains(iCategoryWanted, tQueuedDetails[M28Map.subrefBuildingID]) and M28UnitInfo.IsUnitValid(tQueuedDetails[M28Map.subrefPrimaryBuilder]) then
                                    oEngineerToAssist = tQueuedDetails[M28Map.subrefPrimaryBuilder]
                                    break
                                end
                            end
                        end
                    end
                    if oEngineerToAssist then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will assign engineers to build, iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                        local tLastOrder = oEngineerToAssist[M28Orders.reftiLastOrders][oEngineerToAssist[M28Orders.refiOrderCount]]
                        local sBlueprintToBuild = tLastOrder[M28Orders.subrefsOrderBlueprint]
                        local tOrderPosition = tLastOrder[M28Orders.subreftOrderPosition]
                        if sBlueprintToBuild and tOrderPosition and EntityCategoryContains(iCategoryWanted, sBlueprintToBuild) then
                            while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                if tEngineersOfTechWanted[iEngiCount]:CanBuild(sBlueprintToBuild) then
                                    --Can build
                                    M28Orders.IssueTrackedBuild(tEngineersOfTechWanted[iEngiCount], tOrderPosition, sBlueprintToBuild, false, sOrderRef..'B')
                                else
                                    --Assist the engineer for lower tech enginers
                                    M28Orders.IssueTrackedGuard(tEngineersOfTechWanted[iEngiCount], oEngineerToAssist, false, sOrderRef..'A')
                                end
                                TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority)
                                UpdateBPTracking()
                            end

                        else
                            --Assist the engineer for all engineers
                            while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                if bDebugMessages == true then LOG(sFunctionRef..': Assigning engineer for assist engineer action '..iActionToAssign..'; iEngiCount='..iEngiCount..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted) end
                                M28Orders.IssueTrackedGuard(tEngineersOfTechWanted[iEngiCount], oEngineerToAssist, false, sOrderRef..'A')
                                TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority)
                                UpdateBPTracking()
                            end
                        end
                    else

                        if tiActionOrder[iActionToAssign] == M28Orders.refiOrderIssueGuard then
                            --Want to assist something, and are just looking for a single predefined category (so dont need the  later on custom logic)
                            local oUnitToAssist
                            local oBackupUnit
                            local sAlliedUnitRef
                            if bIsWaterZone then sAlliedUnitRef = M28Map.subrefWZTAlliedUnits
                            else sAlliedUnitRef = M28Map.subrefLZTAlliedUnits
                            end
                            local tUnitsOfCategoryInLZ = EntityCategoryFilterDown(tiActionCategory[iActionToAssign], tLZOrWZTeamData[sAlliedUnitRef])
                            if M28Utilities.IsTableEmpty(tUnitsOfCategoryInLZ) == false then
                                --Shield assistance - special logic
                                if iActionToAssign == refActionAssistShield then
                                    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftPriorityShieldsToAssist]) then --redundancy
                                        M28Utilities.ErrorHandler('Dont have a priority shield to assist somehow')
                                    else
                                        --Get the shield with the least assistance
                                        local iLowestBPAssisting = 100000
                                        local iCurBPAssisting
                                        for iShield, oShield in tLZOrWZTeamData[M28Map.reftPriorityShieldsToAssist] do
                                            iCurBPAssisting = 0
                                            if M28Utilities.IsTableEmpty(oShield[M28UnitInfo.reftoUnitsAssistingThis]) == false then
                                                for iAssisting, oAssisting in oShield[M28UnitInfo.reftoUnitsAssistingThis] do
                                                    iCurBPAssisting = iCurBPAssisting + (oAssisting:GetBlueprint().Economy.BuildRate or 0)
                                                end
                                            end
                                            if iCurBPAssisting < iLowestBPAssisting then
                                                iLowestBPAssisting = iCurBPAssisting
                                                oUnitToAssist = oShield
                                                if iLowestBPAssisting == 0 then break end
                                            end
                                        end
                                    end
                                else
                                    for iUnit, oUnit in tUnitsOfCategoryInLZ do
                                        if oUnit:GetWorkProgress() > 0 then
                                            oUnitToAssist = oUnit
                                        else
                                            oBackupUnit = oUnitToAssist
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to assist unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with work progress '..oUnit:GetWorkProgress()) end
                                    end
                                    if not(oUnitToAssist) then oUnitToAssist = oBackupUnit end
                                end
                            end
                            if M28UnitInfo.IsUnitValid(oUnitToAssist) then
                                while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                    if bDebugMessages == true then LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to assist unit '..oUnitToAssist.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToAssist)) end
                                    M28Orders.IssueTrackedGuard(tEngineersOfTechWanted[iEngiCount], oUnitToAssist, false, sOrderRef)
                                    TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority)
                                    UpdateBPTracking()
                                end
                            else
                                --Dont have anything to assist
                                if bDebugMessages == true then LOG(sFunctionRef..': Cant assist the desired category so will stop trying to assist it and reduce build power required') end
                                iTotalBuildPowerWanted = 0
                            end

                        else
                            --No building under construciton, and no existing engineer to assist - assign engineers to build instead

                            --Do we need a specific faction? If so then filter available engineers to just these
                            if iOptionalFactionRequired then tEngineersOfTechWanted, iEngiCount = FilterEngineersOfTechAndEngiCountForFaction(iOptionalFactionRequired, tEngineersOfTechWanted) end

                            if iEngiCount > 0 then
                                --Building power - if we get to T3, have at least 750 gross energy per tick, and have an action to build second power, then change building power normally so it builds separately to building second power
                                if iActionToAssign == refActionBuildThirdPower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 1000 then
                                    tbIgnoreUnderConstructionActions[refActionBuildPower] = true
                                end
                                local oFirstEngineer = tEngineersOfTechWanted[iEngiCount]
                                local sBlueprint, tBuildLocation
                                local iAdjacencyCategory
                                if bDebugMessages == true then LOG(sFunctionRef..': About to get the blueprint and build location, oFirstEngineer='..oFirstEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFirstEngineer)) end
                                if iActionToAssign == refActionBuildShield or iActionToAssign == refActionBuildSecondShield then
                                    GetMaxShieldSearchRangeForEngineer(oFirstEngineer, iCategoryWanted)
                                    sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted, iMaxSearchRange, tiActionAdjacentCategory[iActionToAssign], vOptionalVariable:GetPosition(), false, nil, nil, false, tLZOrWZTeamData)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished getting blueprint and build location for shield, sBlueprint='..(sBlueprint or 'nil')..'; tBuildLocation='..repru(tBuildLocation)..'; vOptionalVariable='..(vOptionalVariable.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(vOptionalVariable) or 'nil')..'; iMaxSearchRange='..iMaxSearchRange) end
                                elseif vOptionalVariable and iActionToAssign == refActionBuildEmergencyPD then
                                    sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted, iMaxSearchRange, tiActionAdjacentCategory[iActionToAssign], vOptionalVariable, false, nil, nil, false, tLZOrWZTeamData)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have just tried to get location for PD, vOptionalVariable='..repru(vOptionalVariable)..'; sBlueprint='..(sBlueprint or 'nil')..'; tBuildLocation='..repru(tBuildLocation))
                                        M28Utilities.DrawLocation(tBuildLocation)
                                    end
                                elseif vOptionalVariable and iActionToAssign == refActionBuildTMD then
                                    --Build near the unit we want to protect (get blueprint will also factor in maxsearchrange based on the TMD range)
                                    if vOptionalVariable.UnitId then
                                        sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted, iMaxSearchRange, tiActionAdjacentCategory[iActionToAssign], vOptionalVariable:GetPosition(), false, nil, nil, false, tLZOrWZTeamData)
                                    elseif M28Utilities.IsTableEmpty(vOptionalVariable) == false then
                                        sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted, iMaxSearchRange, tiActionAdjacentCategory[iActionToAssign], vOptionalVariable, false, nil, nil, false, tLZOrWZTeamData)
                                    else
                                        M28Utilities.ErrorHandler('Trying to build TMD without a unit or location')
                                    end
                                else
                                    iAdjacencyCategory = tiActionAdjacentCategory[iActionToAssign]
                                    if not(iAdjacencyCategory) and (iActionToAssign == refActionBuildExperimental or iActionToAssign == refActionBuildSecondExperimental) then
                                        if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti * categories.STRUCTURE + M28UnitInfo.refCategorySML, iCategoryWanted) then
                                            iAdjacencyCategory = M28UnitInfo.refCategoryT3Power
                                        end
                                    end
                                    sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted, iMaxSearchRange, iAdjacencyCategory, nil, false, nil, nil, false, tLZOrWZTeamData)
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Just got blueprint and location to build for oFirstEngineer='..oFirstEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFirstEngineer)..'; iActionTOAssign='..iActionToAssign..'; sBlueprint='..(sBlueprint or 'nil')..'; tBuildLocation='..repru(tBuildLocation)..'; Is tiActionAdjacentCategory[iActionToAssign] nil='..tostring(tiActionAdjacentCategory[iActionToAssign] == nil)) end
                                if sBlueprint then
                                    local tMoveLocation
                                    while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Assigning engineer for building action '..iActionToAssign..'; iEngiCount='..iEngiCount..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; tiActionOrder[iActionToAssign]='..(tiActionOrder[iActionToAssign] or 'nil')..'; sBlueprint='..sBlueprint..'; tBuildLocation='..repru(tBuildLocation)..'; Eng cur state='..M28UnitInfo.GetUnitState(tEngineersOfTechWanted[iEngiCount])) end
                                        --Is our order to build or assist?
                                        if tiActionOrder[iActionToAssign] then
                                            if tiActionOrder[iActionToAssign] == M28Orders.refiOrderIssueBuild then
                                                tMoveLocation = GetLocationToMoveForConstruction(tEngineersOfTechWanted[iEngiCount], tBuildLocation, sBlueprint, 0, false)
                                                if tMoveLocation then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Telling engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to move to '..repru(tMoveLocation)..' and then build '..sBlueprint..' and '..repru(tBuildLocation)) end
                                                    M28Orders.IssueTrackedMoveAndBuild(tEngineersOfTechWanted[iEngiCount], tBuildLocation, sBlueprint, tMoveLocation, 1, false, sOrderRef)
                                                else
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Telling engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to build '..sBlueprint..' at '..repru(tBuildLocation)) end
                                                    M28Orders.IssueTrackedBuild(tEngineersOfTechWanted[iEngiCount], tBuildLocation, sBlueprint, false, sOrderRef)
                                                end
                                                TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, true, iCurPriority)
                                                UpdateBPTracking()
                                                --Mex specific - build a separate unit
                                                if iActionToAssign == refActionBuildMex and iTotalBuildPowerWanted > 0 and iEngiCount > 0 then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Were building a mex at tBuildLocation='..repru(tBuildLocation)..'; however have already assigned an engineer and have more to assign, so will build at a different mex now') end
                                                    sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted, iMaxSearchRange, iAdjacencyCategory, nil, false, nil, nil, false, tLZOrWZTeamData)
                                                    if bDebugMessages == true then LOG(sFunctionRef..': New mex build location='..repru(tBuildLocation)) end
                                                end
                                            else
                                                M28Utilities.ErrorHandler('Need to add code for actions that dont involve building, ActionToAssign='..iActionToAssign..'; order ref='..(tiActionOrder[iActionToAssign] or 'nil'))
                                            end
                                        else
                                            M28Utilities.ErrorHandler('Missing action order type for iActionToAssign '..iActionToAssign)
                                        end
                                    end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': Cant build the desired category so will stop trying to build it and reduce build power required') end
                                    iTotalBuildPowerWanted = 0
                                end
                            else
                                iTotalBuildPowerWanted = 0
                                if iOptionalFactionRequired then
                                    if not(tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted]) then tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted] = {} end
                                    tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted][iOptionalFactionRequired] = true
                                end
                            end
                        end
                    end
                end
            else --Dont have a category to search for
                --Order specific logic
                if iActionToAssign == refActionMoveToLandZone then
                    local iTargetLZ
                    local iPlateauToMoveTo
                    if bIsWaterZone then
                        iTargetLZ = vOptionalVariable[2]
                        iPlateauToMoveTo = vOptionalVariable[1]
                    else
                        iTargetLZ = vOptionalVariable
                        iPlateauToMoveTo = iPlateauOrPond
                    end
                    local tTargetLZ = M28Map.tAllPlateaus[iPlateauToMoveTo][M28Map.subrefPlateauLandZones][iTargetLZ]


                    sOrderRef = sOrderRef..'TLZ='..iTargetLZ
                    if M28Utilities.IsTableEmpty(tTargetLZ) then
                        M28Utilities.ErrorHandler('Invalid LZ  for moving to, iPlateauOrPOND='..iPlateauOrPond..'; iPlateauToMoveTo='..(iPlateauToMoveTo or 'nil')..'; will do reprs of iTargetLZ in log')
                        LOG(sFunctionRef..': Invalid LZ for moving to, iPlateauOrPond='..(iPlateauOrPond or 'nil')..'; iTargetLZ='..reprs(iTargetLZ)..'; vOptionalVariable='..reprs(vOptionalVariable))
                    else
                        local tMoveLocation = tTargetLZ[M28Map.subrefMidpoint]
                        while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to move to iPlateauOrPond '..iPlateauOrPond..'; iTargetLZ='..iTargetLZ)
                            end
                            M28Orders.IssueTrackedMove(tEngineersOfTechWanted[iEngiCount], tMoveLocation, 5, false, sOrderRef)
                            TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, {iPlateauToMoveTo, iTargetLZ})
                            UpdateBPTracking()
                        end
                    end
                elseif iActionToAssign == refActionMoveToWaterZone then
                    local iTargetWZ = vOptionalVariable
                    local iPond = M28Map.tiPondByWaterZone[iTargetWZ]
                    local tTargetWZ = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iTargetWZ]
                    sOrderRef = sOrderRef..'TWZ='..iTargetWZ
                    if M28Utilities.IsTableEmpty(tTargetWZ) then
                        M28Utilities.ErrorHandler('Invalid WZ  for moving to, iPlateauOrPond='..iPlateauOrPond..'; will do reprs of iTargetWZ in log')
                        LOG(sFunctionRef..': iTargetWZ='..reprs(iTargetWZ))
                    else
                        local tMoveLocation = tTargetWZ[M28Map.subrefMidpoint]
                        while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to move to iPlateauOrPond '..iPlateauOrPond..'; iTargetWZ='..iTargetWZ..'; iPond='..iPond)
                            end
                            M28Orders.IssueTrackedMove(tEngineersOfTechWanted[iEngiCount], tMoveLocation, 5, false, sOrderRef)
                            TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, nil, iTargetWZ)
                            UpdateBPTracking()
                        end
                    end
                elseif iActionToAssign == refActionAssistUpgrade then
                    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefActiveUpgrades]) then
                        M28Utilities.ErrorHandler('Trying to assist upgrade but there are none for this LZ')
                    else
                        local iBestProgress = 0
                        local oBestProgress
                        local iCurProgress
                        for iUnit, oUnit in tLZOrWZTeamData[M28Map.subrefActiveUpgrades] do
                            if M28UnitInfo.IsUnitValid(oUnit) and oUnit.GetWorkProgress then
                                iCurProgress = (oUnit:GetWorkProgress() or 0)
                                if iCurProgress > iBestProgress then
                                    iBestProgress = iCurProgress
                                    oBestProgress = oUnit
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iBestProgress='..iBestProgress..'; Is oBestProgress valid='..tostring(M28UnitInfo.IsUnitValid(oBestProgress))..'; Best progress ID='..(oBestProgress.UnitId or 'nil')..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                        if oBestProgress then
                            while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                if bDebugMessages == true then LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to assist unit '..oBestProgress.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestProgress)) end
                                M28Orders.IssueTrackedGuard(tEngineersOfTechWanted[iEngiCount], oBestProgress, false, sOrderRef)
                                TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority)
                                UpdateBPTracking()
                            end
                        end
                    end
                elseif iActionToAssign == refActionReclaimArea then
                    local bWantEnergyNotMass = vOptionalVariable
                    while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                        if bDebugMessages == true then LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to reclaim nearby, iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                        --GetEngineerToReclaimNearbyArea(oEngineer,                       iPriorityOverride,   tLZOrWZTeamData, iPlateauOrPondOrPond, iLandOrWaterZone, bWantEnergyNotMass, bOnlyConsiderReclaimInRangeOfEngineer, iMinIndividualValueOverride, bIsWaterZone)
                        GetEngineerToReclaimNearbyArea(tEngineersOfTechWanted[iEngiCount], iCurPriority, tLZOrWZTeamData, iPlateauOrPond,           iLandOrWaterZone,      bWantEnergyNotMass, false, nil, bIsWaterZone)
                        UpdateBPTracking()
                    end
                elseif iActionToAssign == refActionReclaimFriendlyUnit or iActionToAssign == refActionReclaimEnemyUnit then
                    --Search for nearest unit in LZ units to be reclaimed
                    local iNearestUnitDist = 10000
                    local oNearestUnit
                    local iCurDist

                    local tUnitsToReclaim = vOptionalVariable or tLZOrWZTeamData[M28Map.subreftoUnitsToReclaim]

                    if M28Utilities.IsTableEmpty(tUnitsToReclaim) then
                        M28Utilities.ErrorHandler('Want to reclaim a unit but no units in LZ to reclaim')
                    else
                        while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                            if bDebugMessages == true then LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to move to iPlateauOrPond '..iPlateauOrPond) end


                            local bAreDeadUnits = false
                            for iUnit, oUnit in tUnitsToReclaim do
                                if M28UnitInfo.IsUnitValid(oUnit) then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tEngineersOfTechWanted[iEngiCount]:GetPosition(), oUnit:GetPosition())
                                    if iCurDist < iNearestUnitDist then
                                        iNearestUnitDist = iCurDist
                                        oNearestUnit = oUnit
                                    end
                                else
                                    --Have dead units in the list of units to reclaim, so need to update the table
                                    if not(bAreDeadUnits) then
                                        bAreDeadUnits = true
                                        ForkThread(M28Economy.RefreshUnitsToReclaim, iTeam, iPlateauOrPond, iLandOrWaterZone)
                                    end
                                end
                            end

                            if oNearestUnit then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to reclaim oNearestUnit='..oNearestUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestUnit)) end
                                M28Orders.IssueTrackedReclaim(tEngineersOfTechWanted[iEngiCount], oNearestUnit, false, 'RecObs')
                                TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority)
                                UpdateBPTracking()
                            else
                                break
                            end
                        end
                    end
                elseif iActionToAssign == refActionLoadOntoTransport then
                    if iTotalBuildPowerWanted > 0 and iEngiCount > 0 then
                        --Load onto first transport in LZ needing engis (max 1 engi per transport)
                        for iTransport, oTransport in tLZOrWZTeamData[M28Map.reftoTransportsWaitingForEngineers] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Trying to load engi into transport, iEngiCount='..iEngiCount..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; oTransport='..oTransport.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTransport)..'; Engineer='..(tEngineersOfTechWanted[iEngiCount].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount]) or 'nil')..'; Transport engis wanted='..oTransport[M28Air.refiEngisWanted]..'; Transport cargo capacity='..M28Air.GetTransportEngiCargoAndRemainingCapacity(oTransport, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech])) end
                            M28Orders.IssueTrackedTransportLoad(tEngineersOfTechWanted[iEngiCount], oTransport, false, sOrderRef, false)
                            TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority)
                            UpdateBPTracking()
                            if bDebugMessages == true then LOG(sFunctionRef..': Post sending order to load onto transport, iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                            if iEngiCount <= 0 or iTotalBuildPowerWanted <= 0 then
                                break
                            end
                        end
                    end
                elseif iActionToAssign == refActionCaptureUnit then
                    local oUnitToCapture = vOptionalVariable
                    if bDebugMessages == true then LOG(sFunctionRef..': oUnitToCapture='..oUnitToCapture.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToCapture)..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                    while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                        if bDebugMessages == true then LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to capture unit '..oUnitToCapture.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToCapture)..'; iEngiCount='..iEngiCount) end
                        M28Orders.IssueTrackedCapture(tEngineersOfTechWanted[iEngiCount], oUnitToCapture, false, 'Cap', false)
                        TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority)
                        UpdateBPTracking()
                    end
                elseif iActionToAssign == refActionRepairUnit then
                    local oUnitToRepair = vOptionalVariable
                    while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                        if bDebugMessages == true then LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to repair nearby unit '..oUnitToRepair.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToRepair)..', iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                        M28Orders.IssueTrackedRepair(tEngineersOfTechWanted[iEngiCount], oUnitToRepair, false, 'Rep', false)
                        TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority)
                        UpdateBPTracking()
                    end
                elseif iActionToAssign == refActionSpecialShieldDefence then
                    --Get list of units in zone that want defence and get the best faction they think is available
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of units for special shield protection empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]))) end
                    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) then
                        M28Utilities.ErrorHandler('Are trying to do special shield protection but have no units wanting it')
                    else
                        for iUnit, oUnit in tLZOrWZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
                            if oUnit[M28Building.refoNearbyFactoryOfFaction] then
                                iOptionalFactionRequired = M28UnitInfo.GetUnitFaction(oUnit)
                                break
                            end
                        end
                        if iOptionalFactionRequired then tEngineersOfTechWanted, iEngiCount = FilterEngineersOfTechAndEngiCountForFaction(iOptionalFactionRequired, tEngineersOfTechWanted) end
                        if iEngiCount > 0 then
                            while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                AssignEngineerToShieldDefenceDuty(tEngineersOfTechWanted[iEngiCount], tLZOrWZTeamData)
                                if bDebugMessages == true then LOG(sFunctionRef..': Have just assigned engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to do special shield protection logic, will now update tracking of that engineer') end
                                --TRACKING NOTE - this will get cleared so the ActiveShieldMonitor will then impute backup values - i.e. changes made to below are unlikely to have an effect
                                TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority)
                                UpdateBPTracking()
                            end
                        else
                            iTotalBuildPowerWanted = 0
                            if iOptionalFactionRequired then
                                --Flag that we need engineers of the desired faction
                                if not(tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted]) then tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted] = {} end
                                tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted][iOptionalFactionRequired] = true
                            end
                        end
                    end

                else
                    if not(aiBrain[M28Overseer.refbCloseToUnitCap]) then
                        M28Utilities.ErrorHandler('Unrecognised order, need to add logic, iActionToAssign='..(iActionToAssign or 'nil'))
                    end
                    iTotalBuildPowerWanted = 0
                end
            end
        end

        --If we still have build power we want to assign, record in the land zone
        if bDebugMessages == true then LOG(sFunctionRef..': About to update BP wanted for iPlateauOrPond'..iPlateauOrPond..'; iLandOrWaterZone='..iLandOrWaterZone..'; iTeam='..iTeam..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; tLZBuildPowerByTechWanted before update='..repru(tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted])) end
        if iTotalBuildPowerWanted > 0 and not(bDontIncreaseLZBPWanted) then tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iMinTechWanted] = (tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iMinTechWanted] or 0) + iTotalBuildPowerWanted end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    for iTech = 3, 1, -1 do
        if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[iTech]) == false then
            return iTech
        end
    end
    return 0
end

function UpdateSpareEngineerNumber(tLZOrWZTeamData, toAvailableEngineersByTech)
    --Intended to be called after running all engineer builder logic for the LZ
    tLZOrWZTeamData[M28Map.subrefSpareBPByTech] = {[1]=0, [2]=0,[3]=0}
    local iTotalBP
    for iTech = 1, 3, 1 do
        if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[iTech]) == false then
            iTotalBP = 0
            for iUnit, oUnit in toAvailableEngineersByTech[iTech] do
                iTotalBP = iTotalBP + oUnit:GetBlueprint().Economy.BuildRate
                if M28Config.M28ShowUnitNames then M28Orders.UpdateUnitNameForOrder(oUnit, 'Idle') end
            end
            tLZOrWZTeamData[M28Map.subrefSpareBPByTech][iTech] = iTotalBP
        end
    end
end

function GetBPToAssignToSMD(iPlateau, iLandZone, iTeam, tLZTeamData, bCoreZone, bHaveLowMass, bWantMorePower)
    --Returns BP to assign, and whether it should be assigned to assist the SMD (returns true) rather than building a new SMD
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPToAssignToSMD'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iBPWanted = 0
    local bAssistSMD = false
    --Does this LZ have enough value?
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want SMD for iPlateau '..iPlateau..'; iLandZone '..iLandZone..'; LZ building vlaue='..(tLZTeamData[M28Map.subrefLZSValue] or 'nil')) end
    if tLZTeamData[M28Map.subrefLZSValue] >= 11000 then
        local tSMD = EntityCategoryFilterDown(M28UnitInfo.refCategorySMD, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        local iSMDsWeHave = 0
        local iSMDsWithNoMissiles = 0
        if M28Utilities.IsTableEmpty(tSMD) == false then
            for iSMDNumber, oSMD in tSMD do
                --Check we've completed construction
                if bDebugMessages == true then LOG(sFunctionRef .. ': Have an SMD '..oSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSMD)..', will check if its completed construction; fraction complete='..oSMD:GetFractionComplete()..'; Ammo count='..oSMD:GetTacticalSiloAmmoCount()..'; oSMD[M28Building.refbMissileRecentlyBuilt]='..tostring(oSMD[M28Building.refbMissileRecentlyBuilt] or false)) end
                if M28UnitInfo.IsUnitValid(oSMD) and oSMD:GetFractionComplete() == 1 then
                    iSMDsWeHave = iSMDsWeHave + 1
                    if oSMD.GetTacticalSiloAmmoCount and oSMD:GetTacticalSiloAmmoCount() < 1 and not (oSMD[M28Building.refbMissileRecentlyBuilt]) then
                        iSMDsWithNoMissiles = iSMDsWithNoMissiles + 1
                        if bDebugMessages == true then LOG(sFunctionRef..': SMD has no missile, iSMDsWithNoMissiles='..iSMDsWithNoMissiles) end
                    end
                end
            end
        end
        local iEnemyNukes = 0 --Cant use table.getn
        local iEnemyBattleshipNukes = 0
        local iEnemyNormalNukes = 0
        local bEnemyNukeNotConstructed = true
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false then
            for iNuke, oNuke in M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers] do
                if EntityCategoryContains(categories.BATTLESHIP, oNuke.UnitId) then
                    iEnemyBattleshipNukes = iEnemyBattleshipNukes + 1
                else
                    iEnemyNormalNukes = iEnemyNormalNukes + 1
                end
                if oNuke:GetFractionComplete() >= 0.95 then
                    bEnemyNukeNotConstructed = false
                end
            end
        elseif bDebugMessages == true then
            LOG(sFunctionRef .. ': No SML detected but will build SMD anyway as a precaution as we have a good economy')
        end
        iEnemyNukes = math.max(iEnemyNormalNukes, iEnemyBattleshipNukes, 1) --Redundancy - if table isnt empty enemy must have at least one, and will assume they have 1 if we are building as a precaution
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': iSMDsWeHave=' .. iSMDsWeHave .. '; iEnemyNukes=' .. iEnemyNukes )
            if iEnemyNukes > 1 then
                LOG(sFunctionRef .. ': Will now list out each nuke unit ID')
                for iNuke, oNuke in M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers] do
                    LOG(sFunctionRef .. ': iNuke=' .. iNuke .. '; oNuke=' .. oNuke.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oNuke))
                end
            end
        end
        local iSMDWanted = math.min(4, iEnemyNukes, math.max(1, math.floor((M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) / 5)))
        if bHaveLowMass then
            iSMDWanted = math.min(3, iEnemyNukes * 2 / 3, iSMDWanted)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iSMDsWeHave='..iSMDsWeHave..'; iSMDWanted='..iSMDWanted..'; iSMDsWithNoMissiles='..iSMDsWithNoMissiles) end
        if iSMDsWeHave < iSMDWanted or iSMDsWithNoMissiles > 0 then
            if bHaveLowMass or iSMDsWeHave > 0 then iBPWanted = 150
            elseif bWantMorePower then iBPWanted = 225
            else iBPWanted = 300 end
            if not(bCoreZone) then iBPWanted = iBPWanted * 0.5 end
        end
        if iSMDsWithNoMissiles > 0 then
            bAssistSMD = true
            iBPWanted = math.max(150, iBPWanted * 3)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iBPWanted='..(iBPWanted or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBPWanted, bAssistSMD
end

function GetBPToAssignToMassStorage(iPlateau, iLandZone, iTeam, tLZTeamData, bCoreZone, bHaveLowMass, bWantMorePower)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPToAssignToMassStorage'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iBPWanted = 0
    --Are all mexes in the LZ at T2+ or do we have any T3 mexes in the LZ?
    if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; T2+T3 mex count='..tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3]..'; T1 mex count='..tLZTeamData[M28Map.subrefMexCountByTech][1]..'; Is table of mass storage locations to build empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMassStorageLocationsAvailable]))..'; Size of mex table='..table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations])) end
    if tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 and (tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 or tLZTeamData[M28Map.subrefMexCountByTech][2] >= 4) then
        --Do we have empty locations for mass storage?
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMassStorageLocationsAvailable]) == false then
            --Do we have really low power?
            if not(bWantMorePower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] < 0.5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < 0) then

                iBPWanted = 10
                if not (bHaveLowMass) or tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 then
                    iBPWanted = iBPWanted + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
                    if not (bWantMorePower) then
                        iBPWanted = iBPWanted + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2
                    end
                else
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 50 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0 then
                        iBPWanted = iBPWanted + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 0.5
                    end
                end
            elseif tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 50 then
                iBPWanted = 5
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iBPWanted='..iBPWanted) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBPWanted
end

function GetBPToAssignToAssistUpgrade(tLZTeamData, iTeam, bCoreZone, bHaveLowMass, bWantMorePower)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPToAssignToAssistUpgrade'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iBPWanted = 0

    if bDebugMessages == true then LOG(sFunctionRef..': Considering if any active upgrades we want to assist; Is table of upgrades empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then
        if not(bWantMorePower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] < 0.8 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < 7) then
            if bCoreZone then iBPWanted = 5 end

            if not (bHaveLowMass) then
                iBPWanted = iBPWanted + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2
                if not (bWantMorePower) then
                    iBPWanted = iBPWanted + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2
                end
            else
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 50 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0 then
                    iBPWanted = iBPWanted + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
                end
            end
            if not(bCoreZone) and iBPWanted > 5 then iBPWanted = math.min(25, iBPWanted * 0.5) end
        end
        --Increase assistance if we have lots of upgrades
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] >= 0.95 then
            if table.getn(tLZTeamData[M28Map.subrefActiveUpgrades]) >= 3 then iBPWanted = iBPWanted * 2
            elseif table.getn(tLZTeamData[M28Map.subrefActiveUpgrades]) == 2 then iBPWanted = iBPWanted * 1.25
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef .. ': iBPWanted=' .. iBPWanted) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBPWanted
end

function GetBPForShieldAssistance(tLZTeamData, iTeam)
    --Assist shields to defend against arti
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPForShieldAssistance'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iBPWanted = 0
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for game time='..GetGameTimeSeconds()..'; Are we defending against arti='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti])) end
    if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] then
        M28Building.RecordPriorityShields(iTeam, tLZTeamData)
        if bDebugMessages == true then LOG(sFunctionRef..': Is the table of priority shields empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]))) end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]) == false then
            local iEnemyT3ArtiValue = 0
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure]) == false then
                for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure] do
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        if EntityCategoryContains(M28UnitInfo.refCategoryNovaxCentre, oUnit.UnitId) then
                            if oUnit:GetFractionComplete() >= 0.5 then
                                iEnemyT3ArtiValue = iEnemyT3ArtiValue + 0.5
                            else
                                iEnemyT3ArtiValue = iEnemyT3ArtiValue + 0.25
                            end

                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, oUnit.UnitId) then
                            if oUnit:GetFractionComplete() >= 0.5 then
                                iEnemyT3ArtiValue = iEnemyT3ArtiValue + 1
                            else
                                if oUnit:GetFractionComplete() >= 0.25 then
                                    iEnemyT3ArtiValue = iEnemyT3ArtiValue + 0.5
                                else
                                    iEnemyT3ArtiValue = iEnemyT3ArtiValue + 0.25
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is the table of enemy arti empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure]))..'; iEnemyT3ArtiValue='..iEnemyT3ArtiValue..'; number of priority shields for thie LZ='..table.getn(tLZTeamData[M28Map.reftPriorityShieldsToAssist])) end
            iBPWanted = table.getn(tLZTeamData[M28Map.reftPriorityShieldsToAssist]) * math.max(120, math.min(780, (360 * iEnemyT3ArtiValue)))
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iBPWanted='..iBPWanted) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBPWanted
end

function GetBPMinTechAndUnitForFixedShields(tLZTeamData, iTeam, bCoreZone, bHaveLowMass, bWantMorePower, bConsideringSecondShield, iLandZoneRef)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPMinTechAndUnitForFixedShields'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iBPWanted = 0
    local iTechLevelWanted = 2
    local oUnitToShield
    local iHighestMassValue = 0
    local iHighMassThreshold = 15000
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; Is table of units wanting fixed shields empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitWantingFixedShield]))..'; bConsideringSecondShield='..tostring(bConsideringSecondShield or false)) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitWantingFixedShield]) == false then
        --Early in a campaign (less than 20m in) - dont get shield if dont have good mass
        local bGetShield = true
        if M28Map.bIsCampaignMap and bHaveLowMass and GetGameTimeSeconds() <= 1200 then --First 20m
            --Does enemy have a >=60% complete arti, and game is at least 10m old?
            if GetGameTimeSeconds() >= 600 then
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoT3Arti]) == false then
                    for iArti, oArti in M28Team.tTeamData[iTeam][M28Team.subreftoT3Arti] do
                        if oArti:GetFractionComplete() >= 0.6 then
                            --Want to get shield
                            break
                        end
                        bGetShield = false
                    end
                else
                    bGetShield = false
                end
            else
                bGetShield = false
            end
        end
        if bGetShield then

            --Shield the highest value unit in this LZ that wants a shield
            if bConsideringSecondShield then iHighestMassValue = iHighMassThreshold end --will only try shielding if we have very high value target (e.g. t3 arti or experimental) that is unshielded
            local iCurMass
            for iUnit, oUnit in tLZTeamData[M28Map.reftoLZUnitWantingFixedShield] do
                iCurMass = oUnit:GetBlueprint().Economy.BuildCostMass
                if iCurMass > iHighestMassValue then
                    --Check we are likely to be able ot build a shield nearby
                    if (oUnit[refiFailedShieldBuildDistance] or 0) <= 17 then --Cybran ED4 has a readius of 17
                        iHighestMassValue = iCurMass
                        oUnitToShield = oUnit
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurMass='..iCurMass..'; iHighestMassValue='..iHighestMassValue..'; Failed shield build distance='..(oUnit[refiFailedShieldBuildDistance] or 0)) end
            end
            if oUnitToShield then
                if iHighestMassValue >= iHighMassThreshold or M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 12000 then
                    iTechLevelWanted = 3
                    --Think have logic elsewhere which will make a T3 shield be built if nowhere for T2 shield that will cover it

                end
                iBPWanted = 210
                if bCoreZone or iHighestMassValue >= 25000 then iBPWanted = iBPWanted + 60 end
                if bWantMorePower then iBPWanted = iBPWanted * 0.75 end
                if bHaveLowMass then iBPWanted = iBPWanted * 0.75 end
                if bDebugMessages == true then LOG(sFunctionRef..': Have a unit to shield, bCoreZone='..tostring(bCoreZone or false)..'; M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or false)..'; bWantMorePower='..tostring(bWantMorePower)..'; bHaveLowMass='..tostring(bHaveLowMass)..'; iBPWanted='..iBPWanted) end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': oUnitToShield='..(oUnitToShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitToShield) or 'nil')..'; iBPWanted='..iBPWanted..'; iTechLevelWanted='..iTechLevelWanted..'; iHighestMassValue='..iHighestMassValue) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBPWanted, iTechLevelWanted, oUnitToShield
end

function GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateau, iLandZone, bOptionalReturnMassToCompleteOtherZoneUnderConstruction, iOptionalSearchRange, iOptionalCategoryFilter)
    --returns two variables, the first is true/false if iLandZone has a queued experimental to build; the second is the number of other land zones for iTeam that have queued experimentals to build
    --Optional variables are all for if bOptionalReturnMassToCompleteOtherZoneUnderConstruction is true:
        --will return the amount of mass needed to complete all under construction experimentals in other zones
        --Will only include those within iOptionalSearchRange
        --And also only if they meet any category specified by iOptionalCategoryFilter (will include everything if nil)
    local bHaveExperimentalForThisLandZone = false
    local iOtherLandZonesWithExperimental = 0
    local iMassToComplete
    if bOptionalReturnMassToCompleteOtherZoneUnderConstruction then iMassToComplete = 0 end

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]) == false then
        local tiPlateauAndLZBuildingExperimental = {}
        local toUnderConstructionExperimentalsInOtherZonesByUnitRef = {}
        local iCurPlateau, iCurLZ
        for iEngi, oEngi in M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals] do
            if M28UnitInfo.IsUnitValid(oEngi) and oEngi[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam] then
                iCurPlateau = oEngi[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1]
                iCurLZ = oEngi[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]
                if bOptionalReturnMassToCompleteOtherZoneUnderConstruction then --Check if want to include this
                    if not(iCurLZ == iLandZone and iPlateau == iCurPlateau) then
                        local oCurExperimental = oEngi:GetFocusUnit()
                        if oCurExperimental and oCurExperimental:GetFractionComplete() < 1 then
                            if not(iOptionalCategoryFilter) or EntityCategoryContains(iOptionalCategoryFilter, oCurExperimental.UnitId) then
                                if not(toUnderConstructionExperimentalsInOtherZonesByUnitRef[oCurExperimental.EntityId]) then
                                    toUnderConstructionExperimentalsInOtherZonesByUnitRef[oCurExperimental.EntityId] = oCurExperimental
                                end
                            end
                        end
                    end
                end
                if not(tiPlateauAndLZBuildingExperimental[iCurPlateau]) then tiPlateauAndLZBuildingExperimental[iCurPlateau] = {} end
                tiPlateauAndLZBuildingExperimental[iCurPlateau][iCurLZ] = (tiPlateauAndLZBuildingExperimental[iCurPlateau][iCurLZ] or 0) + 1
            end
        end
        if M28Utilities.IsTableEmpty(tiPlateauAndLZBuildingExperimental) == false then
            for iAssignedPlateau, tEngineersByLZ in tiPlateauAndLZBuildingExperimental do
                for iAssignedLZ, iEngineersAssigned in tEngineersByLZ do
                    if iPlateau == iAssignedPlateau and iLandZone == iAssignedLZ then
                        bHaveExperimentalForThisLandZone = true
                    else
                        iOtherLandZonesWithExperimental = iOtherLandZonesWithExperimental + 1
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(toUnderConstructionExperimentalsInOtherZonesByUnitRef) == false then
            local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
            for iUnit, oUnit in toUnderConstructionExperimentalsInOtherZonesByUnitRef do
                if not(iOptionalSearchRange) or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= iOptionalSearchRange then
                    iMassToComplete = iMassToComplete + (oUnit:GetBlueprint().Economy.BuildCostMass or 0) * (1 - oUnit:GetFractionComplete())
                end
            end
        end
    end
    return bHaveExperimentalForThisLandZone, iOtherLandZonesWithExperimental, iMassToComplete
end

function GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, iAdjLZ, iPathingRef, iHighestTechEngiAvailable, bNearbyZone, bIslandPathing, bRequireUnbuiltMexes)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPByTechWantedForAlternativeLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tiBPWantedByTech
    local tAltLZ = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
    local tAltLZTeamData = tAltLZ[M28Map.subrefLZTeamData][iTeam]
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Does iAdjLZ '..iAdjLZ..' for plateau '..iPlateau..' want BP='..tostring(tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP])..'; bIslandPathing='..tostring(bIslandPathing or false)..'; base tLZData[M28Map.subrefLZIslandRef]='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..'; iAdjLZ tAltLZ[M28Map.subrefLZIslandRef]='..(tAltLZ[M28Map.subrefLZIslandRef] or 'nil')..'; Is table of unbuilt mexes empty='..tostring(M28Utilities.IsTableEmpty(tAltLZ[M28Map.subrefMexUnbuiltLocations]))..'; bRequireUnbuiltMexes='..tostring(bRequireUnbuiltMexes or false)) end
    if not(bRequireUnbuiltMexes) or (M28Utilities.IsTableEmpty(tAltLZ[M28Map.subrefMexUnbuiltLocations]) == false and (not(tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase]) or M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subrefLZTAlliedUnits]) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryEngineer, tAltLZTeamData[M28Map.subrefLZTAlliedUnits])))) then
        local iTotalBPWanted = 0
        --Do we need unbuilt mexes?


        --Does the LZ want BP?
        if tAltLZTeamData[M28Map.subrefTbWantBP] or bIslandPathing then
            --Do we have engis of the right tech level to give to the LZ? (ignore this check if we are trying to move engineers to an island for which the closest LZ doesnt want engineers
            local bHaveSufficientTech = false
            if tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP] then
                for iTech = 1, iHighestTechEngiAvailable, 1 do
                    if (tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][iTech] or 0) > 0 then
                        bHaveSufficientTech = true
                        break
                    end
                end
            end

            if bHaveSufficientTech or (bIslandPathing and not(tLZData[M28Map.subrefLZIslandRef] == tAltLZ[M28Map.subrefLZIslandRef])) then
                --Would we path through any dangerous LZs?
                if M28Land.IsLandZonePathSafe(iPlateau, tLZData, iTeam, iPathingRef, bIslandPathing) then
                    tiBPWantedByTech = {[1]=0,[2]=0,[3]=0}
                    if not(bIslandPathing) or bHaveSufficientTech then
                        for iTech = 1, iHighestTechEngiAvailable, 1 do
                            if (tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][iTech] or 0) > 0 then
                                tiBPWantedByTech[iTech] = tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][iTech]
                                iTotalBPWanted = iTotalBPWanted + tiBPWantedByTech[iTech]
                            end
                        end
                    else
                        for iEntry, iIslandLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][tAltLZ[M28Map.subrefLZIslandRef]] do
                            local tAltLZ = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iIslandLZ]
                            if tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP] and M28Utilities.IsTableEmpty(tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEngineersTravelingHere]) then
                                for iTech = 1, iHighestTechEngiAvailable, 1 do
                                    if (tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][iTech] or 0) > 0 then
                                        tiBPWantedByTech[iTech] = tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][iTech]
                                        iTotalBPWanted = iTotalBPWanted + tiBPWantedByTech[iTech]
                                        if iTotalBPWanted >= math.min(25, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tAltLZ[M28Map.subrefLZIslandRef]] * 5) then
                                            break
                                        end
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if iIslandLZ '..iIslandLZ..' wants BP='..tostring(tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP])..'; Island mex count='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tAltLZ[M28Map.subrefLZIslandRef]]..'; LZ mex count='..tAltLZ[M28Map.subrefLZMexCount]..'; iTotalBPWanted after considering this islandLZ='..iTotalBPWanted) end
                        end
                    end
                end
            end
        end



        --Override - for core land zones dont want any BP from a non-adjacent zone in certain cases
        if bIslandPathing or (not(bNearbyZone) and tiBPWantedByTech and tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase]) then

            local iBPToAssign

            if bIslandPathing then
                iBPToAssign = math.min(iTotalBPWanted, 25, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tAltLZ[M28Map.subrefLZIslandRef]] * 5)
            else
                if M28Utilities.IsTableEmpty(tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEngineersTravelingHere]) then
                    iBPToAssign = math.max(5, iTotalBPWanted - 3 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]])
                else
                    iBPToAssign = math.max(0, iTotalBPWanted - 3 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]])
                end
            end
            if iBPToAssign < iTotalBPWanted then
                local iBPToIgnore = iTotalBPWanted - iBPToAssign
                local iCurBPToIgnore
                local iRevisedBPWanted = 0
                for iTech, iBuildPowerWanted in tiBPWantedByTech do
                    iCurBPToIgnore = math.min(iBuildPowerWanted, iBPToIgnore)
                    tiBPWantedByTech[iTech] = tiBPWantedByTech[iTech] - iCurBPToIgnore
                    iBPToIgnore = iBPToIgnore - iCurBPToIgnore
                    iRevisedBPWanted = iRevisedBPWanted + tiBPWantedByTech[iTech]
                end
                if iRevisedBPWanted == 0 then
                    tiBPWantedByTech = nil
                    if bDebugMessages == true then LOG(sFunctionRef..': Have reduced BP wanted by tech for iAdjZone='..iAdjLZ..'; iTotalBPWanted='..iTotalBPWanted..'; iRevisedBPWanted='..iRevisedBPWanted) end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iAdjLZ='..iAdjLZ..'; tiBPWantedByTech='..repru(tiBPWantedByTech)) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tiBPWantedByTech
end

function GetEngisWantedForTransports(tLZTeamData)
    local iTransports = table.getn(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers])
    local iEngisWanted = 0
    for iEntry = iTransports, 1, -1 do
        if not(M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers][iEntry])) or (tLZTeamData[M28Map.reftoTransportsWaitingForEngineers][iEntry][M28Air.refiEngisWanted] or 0) <= 0 then
            table.remove(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers], iEntry)
        else
            iEngisWanted = iEngisWanted + tLZTeamData[M28Map.reftoTransportsWaitingForEngineers][iEntry][M28Air.refiEngisWanted]
        end
    end
    return iEngisWanted
end

function GetZoneAndFactionForPriorityEngineerTravel(tBaseLZTeamData, iTeam, iBaseLandZone, iBasePlateau)
    local iZoneWantingEngineer, iFactionWanted
    for iFactory, oFactory in tBaseLZTeamData[M28Map.reftFactoriesWantedForEngineers] do
        if M28Utilities.IsTableEmpty(oFactory[M28Building.reftoUnitsWantingFactoryEngineers]) == false then
            --Do we already have at least 3 engineers of this factory's faction in the zone that the gameender is in?
            local iFactionRef = M28UnitInfo.GetUnitFaction(oFactory)
            for iUnit, oUnit in oFactory[M28Building.reftoUnitsWantingFactoryEngineers] do
                if M28UnitInfo.IsUnitValid(oUnit) then
                    local iGameEnderPlateau, iGameEnderZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                    local tLZTeamData = M28Map.tAllPlateaus[iGameEnderPlateau][M28Map.subrefPlateauLandZones][iGameEnderZone][M28Map.subrefLZTeamData][iTeam]
                    if tLZTeamData[M28Map.subreftbBPByFactionWanted][iFactionRef] then
                        if  iBasePlateau == iGameEnderPlateau and not(iGameEnderZone == iBaseLandZone) then
                            --How many T3 engineers of this faction do we have traveling to this zone already?
                            local iEngiCatWanted = M28UnitInfo.refCategoryEngineer * categories.TECH3
                            if iFactionRef == M28UnitInfo.refFactionUEF then iEngiCatWanted = iEngiCatWanted * categories.UEF
                            elseif iFactionRef == M28UnitInfo.refFactionAeon then iEngiCatWanted = iEngiCatWanted * categories.AEON
                            elseif iFactionRef == M28UnitInfo.refFactionCybran then iEngiCatWanted = iEngiCatWanted * categories.CYBRAN
                            elseif iFactionRef == M28UnitInfo.refFactionSeraphim then iEngiCatWanted = iEngiCatWanted * categories.SERAPHIM
                            end
                            local iEngisAlreadyTraveling = 0
                            --Want at least 3 enginers traveling of the desired tech level
                            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
                                for iEngi, oEngi in  tLZTeamData[M28Map.subrefTEngineersTravelingHere] do
                                    if M28UnitInfo.IsUnitValid(oEngi) and EntityCategoryContains(iEngiCatWanted, oEngi.UnitId) then
                                        iEngisAlreadyTraveling = iEngisAlreadyTraveling + 1
                                    end
                                end
                            end
                            if iEngisAlreadyTraveling < 3 then
                                iZoneWantingEngineer = iGameEnderZone
                                iFactionWanted = iFactionRef
                                break
                            end
                        end
                    end
                end
            end
        end
        if iZoneWantingEngineer then break end
    end
    return iZoneWantingEngineer, iFactionWanted
end

function GetPDThreatAboveRangeThresholdAlongPath(iPlateau, iLandZone, tLZData, tLZTeamData, iTeam, iRangeThreshold, tTarget)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPDThreatAboveRangeThresholdAlongPath'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; iRangeThreshold='..iRangeThreshold..'; tTarget='..repru(tTarget)..'; Dist from target to LZ mid='..M28Utilities.GetDistanceBetweenPositions(tTarget, tLZData[M28Map.subrefMidpoint])) end
    local iCurPDThreat = 0
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
            if iRange >= iRangeThreshold then
                iCurPDThreat = iCurPDThreat + iThreat
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPDThreat for just this zone='..iCurPDThreat) end
    local iTargetPlateauOrZero, iTargetLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tTarget)
    if bDebugMessages == true then LOG(sFunctionRef..': iTargetLandZone='..(iTargetLandZone or 'nil')..'; iTargetPlateauOrZero='..(iTargetPlateauOrZero or 'nil')) end
    if iTargetLandZone > 0 and iTargetPlateauOrZero == iPlateau and not(iTargetLandZone == iLandZone) then
        --ACU is in a different land zone
        if bDebugMessages == true then LOG(sFunctionRef..': Table of land zone path from start to target='..repru(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath])) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath]) == false then
            for iEntry, iAdjLZ in  tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath] do
                if not(iAdjLZ == iLandZone) then
                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
                        for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                            if iRange >= iRangeThreshold then
                                iCurPDThreat = iCurPDThreat + iThreat
                            end
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPDThreat after factoring in adjacent zones='..iCurPDThreat) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iCurPDThreat
end

function GetClosestMobileTMLIfWantMoreTMD(iTeam, tLZTeamData)
    --Assumes we have already confirmed there are enemy mobile tml on the enemy team
    --Dont bother trying to get TMD if enemy has units in this zone
    --NOTE: After drafting this decided to use a different approach to tracking mobile TML
    M28Utilities.ErrorHandler('Obsolete never tested code')
    local oMobileTMLToDefendAgainst
    if (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) == 0 and (tLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) == 0 then

        local iZoneTMDCount = 0
        local tZoneTMD = EntityCategoryFilterDown(M28UnitInfo.refCategoryTMD, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        if M28Utilities.IsTableEmpty(tZoneTMD) == false then
            for iUnit, oUnit in tZoneTMD do
                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then iZoneTMDCount = iZoneTMDCount + 1 end
            end
        end
        if iZoneTMDCount < 4 or (iZoneTMDCount < 16 and tLZTeamData[M28Map.subrefLZSValue] > iZoneTMDCount * 800) then
            --Get the closest enemy TML to midpoint
            local iCurDist
            local iClosestDist = 100000
            local oClosestUnit
            local tMidpoint = tLZTeamData[M28Map.subrefMidpoint]
            for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyMobileTML] do
                iCurDist = M28Utilities.GetDistanceBetweenPositions(tMidpoint, oUnit:GetPosition()) - math.max((oUnit[M28UnitInfo.refiManualRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0))
                if iCurDist < iClosestDist then
                    iClosestDist = iCurDist
                    oClosestUnit = oUnit
                end
            end
            if iClosestDist <= 50 then
                oMobileTMLToDefendAgainst = oClosestUnit
            end

        end
    end
    return oMobileTMLToDefendAgainst
end

function ConsiderCoreBaseLandZoneEngineerAssignment(tLZTeamData, iTeam, iPlateau, iLandZone, tEngineers)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderCoreBaseLandZoneEngineerAssignment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --For land zones in the core base
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local toAvailableEngineersByTech, toAssignedEngineers = FilterToAvailableEngineersByTech(tEngineers, true, tLZData, tLZTeamData, iTeam, iPlateau, iLandZone)
    tLZTeamData[M28Map.subrefTBuildPowerByTechWanted] = {[1]=0,[2]=0,[3]=0}
    if bDebugMessages == true then LOG(sFunctionRef..': Have just reset BPByTech to 0 for Plateau'..iPlateau..'; LZ='..iLandZone..'; repru='..repru(tLZTeamData[M28Map.subrefTBuildPowerByTechWanted])) end
    --local iCurCondition = 0
    local iCurPriority = 0
    local iHighestTechEngiAvailable
    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
    local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)
    local bWantMorePower = M28Conditions.WantMorePower(iTeam)
    local bWantMoreFactories = M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone)
    local iBPWanted
    local iActiveMexUpgrades = M28Conditions.GetActiveMexUpgrades(tLZTeamData)
    local iNearbyEnemyAirToGroundThreat = tLZTeamData[M28Map.refiEnemyAirToGroundThreat]
    --For now only do land zone not water zone given water zone includes torp bombers
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
            iNearbyEnemyAirToGroundThreat = iNearbyEnemyAirToGroundThreat + tLZTeamData[M28Map.refiEnemyAirToGroundThreat]
        end
    end

    function HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist)
        --Done as subfunction for convenience so can just note the key values for the action in question and add on the others that wont change
        --vOptionalVariable can be used for action specific information to save having to recalculate the same thing - could be a table, nil, or a value
        ConsiderActionToAssign(iActionToAssign, math.max(1, iMinTechLevelWanted), iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iCurPriority, tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, toAvailableEngineersByTech, toAssignedEngineers, false, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist)
    end

    if bDebugMessages == true then
        LOG(sFunctionRef..': About to consider what actions we want to give engineers for iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iTeam='..(iTeam or 'nil')..'; bHaveLowMass='..tostring(bHaveLowMass or false)..'; Team gross mass='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] or 'nil')..'; Lowest mass % stored='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] or 'nil')..'; Team mass stored='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] or 'nil')..'; Team net mass='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] or 'nil')..'; Team gross mass='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] or 'nil'))
        LOG(sFunctionRef..': Repeat of log but without the nil backups to help identify errors, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Team gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Lowest mass % stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; Team mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Team net mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]..'; Team gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass])
    end
    local iMinTechLevelForPower = 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 then
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 22 then iMinTechLevelForPower = 1
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 110 then iMinTechLevelForPower = 2
        else iMinTechLevelForPower = M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': iMinTechLevelForPower='..iMinTechLevelForPower..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end

    --Higher priority than low power - if we need to rush T3 AA due to enemy having T3 air and us not having good enoguh AA force
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] <= 3000 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 then
        --Get AirAA threat for the likely subteam in here
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
            local aiBrain
            for iUnit, oUnit in tLZTeamData[M28Map.subrefLZTAlliedUnits] do
                if oUnit:GetAIBrain().M28AI then
                    aiBrain = oUnit:GetAIBrain()
                    break
                end
            end
            if M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiOurAirAAThreat] <= 1200 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirAA * categories.TECH3) == 0 then
                --Do we have any T3 AA here already?
                local tExistingAirAA = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructureAA * categories.TECH3, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                local bAlreadyHaveT3AA = false
                if M28Utilities.IsTableEmpty(tExistingAirAA) == false then
                    for iUnit, oUnit in tExistingAirAA do
                        if oUnit:GetFractionComplete() >= 1 then
                            bAlreadyHaveT3AA = true
                            break
                        end
                    end
                end
                if not(bAlreadyHaveT3AA) then
                    iBPWanted = 30
                    if not(bHaveLowPower) then iBPWanted = 90 end
                    HaveActionToAssign(refActionBuildAA, 3, iBPWanted)
                    if bDebugMessages == true then LOG(sFunctionRef..': T3 AA builder - iBPWanted='..iBPWanted) end
                end
            end
        end
    end

    --First T2 PD emergency builder if we have no T2 PD and nearby enemy threat
    --Approaching enemy guncom - prioritise upgrades if dont have T2, if do have T2 then get T2 PD
    iCurPriority = iCurPriority + 1
    local oNearestEnemy
    local iApproachingACUThreat, tNearestEnemyACU = M28Conditions.GetThreatOfApproachingEnemyACUsAndNearestACU(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if emergency PD is needed, iApproachingACUThreat='..iApproachingACUThreat) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 25 and ((iApproachingACUThreat > 0 and M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU]) or (tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false)) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 then
        --We have T2 (or only need T1 due to enemy not having gun), so want to build PD
        local iRangeThreshold = 35 --Range of Aeon guncom
        local iCurPDThreat = 0
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                if iRange >= iRangeThreshold then
                    iCurPDThreat = iCurPDThreat + iThreat
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': We have T2 or better, iCurPDThreat='..iCurPDThreat..'; iAppraochingACUThreat='..iApproachingACUThreat) end
        if iCurPDThreat <= 470 then
            iBPWanted = 40
            if not(bHaveLowMass) and not(bHaveLowPower) then iBPWanted = 80 end
            local tTargetBuildLocation
            if tNearestEnemyACU then
                tTargetBuildLocation = GetStartSearchPositionForEmergencyPD(tNearestEnemyACU, tLZData[M28Map.subrefMidpoint], iPlateau, iLandZone)
            else
                local tEnemiesToConsider = {}
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                    for iUnit, oUnit in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            table.insert(tEnemiesToConsider, oUnit)
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tEnemiesToConsider) == false then
                    if not(oNearestEnemy) then oNearestEnemy = M28Utilities.GetNearestUnit(tLZTeamData[M28Map.reftoNearestDFEnemies], tLZData[M28Map.subrefMidpoint], true, M28Map.refPathingTypeLand) end
                    if oNearestEnemy then --factors in if can path to enemy by land
                        if bDebugMessages == true then LOG(sFunctionRef..': oNearestEnemy='..(oNearestEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemy) or 'nil')..'; tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint])) end
                        tTargetBuildLocation = GetStartSearchPositionForEmergencyPD(oNearestEnemy:GetPosition(), tLZData[M28Map.subrefMidpoint], iPlateau, iLandZone)
                    end
                end
                if not(oNearestEnemy) then iBPWanted = 0 end
            end
            if iBPWanted > 0 and tTargetBuildLocation then

                HaveActionToAssign(refActionBuildEmergencyPD, 2, iBPWanted, tTargetBuildLocation)
                if bDebugMessages == true then LOG(sFunctionRef..': Will build emergency T2 PD') end
            end
        end
    end

    --Start of game or low power - build hydro if one nearby, otherwise build pgen
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 10 then
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroLocations]) == false then
            --Norush check
            if bDebugMessages == true then LOG(sFunctionRef..': CHecking if hydro prevented by norush, M28Overseer.bNoRushActive='..tostring(M28Overseer.bNoRushActive or false)..'; M28Conditions.NoRushPreventingHydro(tLZTeamData)='..tostring(M28Conditions.NoRushPreventingHydro(tLZTeamData) or false)) end
            if M28Overseer.bNoRushActive and M28Conditions.NoRushPreventingHydro(tLZData) then
                HaveActionToAssign(refActionBuildPower, 1, 10)
            else

                if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..':  Will try and build a hydro') end
                HaveActionToAssign(refActionBuildHydro, 1, 10)
            end
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..': Will try and build PGens') end
            HaveActionToAssign(refActionBuildPower, 1, 5)
        end
    else
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations]) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Have at least 10 energy income on the team, cHecking if hydro prevented by norush, M28Overseer.bNoRushActive='..tostring(M28Overseer.bNoRushActive or false)..'; M28Conditions.NoRushPreventingHydro(tLZTeamData)='..tostring(M28Conditions.NoRushPreventingHydro(tLZTeamData) or false)) end
            if M28Overseer.bNoRushActive and M28Conditions.NoRushPreventingHydro(tLZData) then
                HaveActionToAssign(refActionBuildPower, 1, 10)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': WIll try to build hydro') end
                HaveActionToAssign(refActionBuildHydro, 1, 10)
            end
            --Make sure we have 1 power of the cur tech level provided dont have low mass
        elseif bHaveLowPower or (not(bHaveLowMass) and bWantMorePower and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < (30 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] + 160 * math.max(0, (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] - 2))) * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultipler]) then
            --Exception if recently built power and have nearby enemies (so can e.g. do things like PD)
            if iNearbyEnemyAirToGroundThreat == 0 and (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) == 0 and not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.35 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 3 then
                iBPWanted = 4 * tiBPByTech[iMinTechLevelForPower]
                if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                    iBPWanted = 3 * tiBPByTech[iMinTechLevelForPower]
                else
                    iBPWanted = 4 * tiBPByTech[iMinTechLevelForPower]
                end
            else
                if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.03 then
                    iBPWanted = tiBPByTech[iMinTechLevelForPower]
                else
                    iBPWanted = 2 * tiBPByTech[iMinTechLevelForPower]
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Start of game Want more power, iBPWanted='..iBPWanted) end
            HaveActionToAssign(refActionBuildPower, iMinTechLevelForPower, iBPWanted)

        end
    end

    --Being bombed or have large air force in our core base - need AA if dont have any fixed AA (see a bit later on for high priority AA builder when under air attack if already have 1 fixed AA)
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 or iNearbyEnemyAirToGroundThreat >= 500 or tLZTeamData[M28Map.refiEnemyAirAAThreat] >= 500 then
        --Do we already have fixed AA in this LZ?
        local iAACategory = M28UnitInfo.refCategoryStructureAA
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then iAACategory = iAACategory * categories.TECH3 end
        local tExistingFixedAA = EntityCategoryFilterDown(iAACategory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        local bHaveFixedAA = false
        if M28Utilities.IsTableEmpty(tExistingFixedAA) == false then
            for iUnit, oUnit in tExistingFixedAA do
                if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have fixed AA, considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                if oUnit:GetFractionComplete() then bHaveFixedAA = true break end
            end
        end
        if not(bHaveFixedAA) then
            iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
            if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 or iNearbyEnemyAirToGroundThreat >= 500 then iBPWanted = iBPWanted * 2 end
            if not(bHaveLowPower) then
                if not(bHaveLowMass) then iBPWanted = iBPWanted * 4
                else iBPWanted = iBPWanted * 2
                end
            end
            HaveActionToAssign(refActionBuildAA, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted)
            if bDebugMessages == true then LOG(sFunctionRef..': AA builder if no fixed AA: iBPWanted='..iBPWanted..'; iNearbyEnemyAirToGroundThreat='..iNearbyEnemyAirToGroundThreat..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; subrefiAlliedGroundAAThreat='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]) end
        end
    end

    --Protect game-ender or similar high avlue target (very high priority on assumption if we have built such a unit we shouldnt have to worry about lack of resources for this
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Want to assign units to active shield protection, will list out each unit for this zone that wants active protection')
            for iUnit, oUnit in tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
                LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Mass cost='..oUnit:GetBlueprint().Economy.BuildCostMass)
            end
        end
        if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] then
            iBPWanted = 500
        else
            iBPWanted = 100
        end


        if bDebugMessages == true then LOG(sFunctionRef..': Special shield defence action iBPWanted='..iBPWanted) end

        --Only use T3 engineers (even if we already have t3 engineers assigned) as want to make sure we can quickly get good concentrated build power
        --function HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist)
        HaveActionToAssign(refActionSpecialShieldDefence, 3, iBPWanted,         nil,                nil,                    nil,                        nil,                            true)
    end

    --Start of game - if low power and dont ahve 12 gross energy yet, then ahve 1 engi on tree reclaim duty
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Early game tree reclaim: bHaveLowPower='..tostring(bHaveLowPower)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Want to relcaim energy nt mass='..tostring(M28Conditions.WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone))) end
    if bHaveLowPower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 12 and M28Conditions.WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone) then
        HaveActionToAssign(refActionReclaimArea, 1, 5, true)
    end

    --Unclaimed mex in the zone
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then
        LOG(sFunctionRef..': Considering if unbuilt or part build mexes in t his LZ, is subrefMexUnbuiltLocations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]))..'; Is subreftoPartBuiltMexes empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes])))
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) == false then
            LOG(sFunctionRef..': Size of unbuilt locations table='..table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]))
        end
    end
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) == false then
        iBPWanted = math.max(5, table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) * 2.5)
        if bHaveLowPower and not(bHaveLowMass) and iBPWanted > 10 then
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= 0.25 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 then
                iBPWanted = 10
            elseif iBPWanted > 20 and iBPWanted >= tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2 then
                iBPWanted = 20
            end
        end
        HaveActionToAssign(refActionBuildMex, 1, iBPWanted)
    elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
        --Do we have no engineers assigned to building a mex?
        local bHaveEngisBuilding = false
        if bDebugMessages == true then LOG(sFunctionRef..': Have part built mexes, is toAssignedEngineers empty='..tostring(M28Utilities.IsTableEmpty(toAssignedEngineers))) end
        if M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
            for iEngi, oEngi in toAssignedEngineers do
                if oEngi[refiAssignedAction] == refActionBuildMex then
                    bHaveEngisBuilding = true
                    break
                end
            end
        end
        if not(bHaveEngisBuilding) then
            --Refresh list of mexes
            RefreshPartBuiltMexList(tLZTeamData)
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
                HaveActionToAssign(refActionCompletePartBuiltMex, 1, 5)
            end
        end
    end

    --Very High priority factory if we have fewer than 4 (or if lwoer thre number of mexes in the LZ or small map and signif mass stored) and is a smaller map - takes priority over mex expansion
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want v.high priority factory builder, mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; bWantMoreFactories='..tostring(bWantMoreFactories)..'; Team gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; GameTime='..GetGameTimeSeconds()) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 11 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 100 and bWantMoreFactories and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1 and (GetGameTimeSeconds() >= 200 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1.5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or M28Map.iMapSize <= 256) then
        local iFactoriesInLZ = 0
        local tFactoriesInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        if M28Utilities.IsTableEmpty(tFactoriesInLZ) == false then iFactoriesInLZ = table.getn(tFactoriesInLZ) end
        if bDebugMessages == true then LOG(sFunctionRef..': iFactoriesInLZ='..iFactoriesInLZ..'; LZ mex count='..tLZData[M28Map.subrefLZMexCount]..'; M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]='..M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) end
        local iFactoryAdjust = 0
        if M28Map.iMapSize <= 256 then
            iFactoryAdjust = math.min(3,M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] / 100)
        end
        if iFactoriesInLZ < iFactoryAdjust + math.max(2 , math.min(4, tLZData[M28Map.subrefLZMexCount] + 1, 10 * M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) then
            iBPWanted = 5
            if not(bHaveLowMass) then iBPWanted = iBPWanted * 2.5 end
            if not(bHaveLowPower) then iBPWanted = iBPWanted * 2.5 end
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build factory, iBPWanted='..iBPWanted) end
            local bWantAirNotLand
            if iFactoriesInLZ == 0 then bWantAirNotLand = false
            else bWantAirNotLand = M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)
            end
            local iFactoryAction
            if bWantAirNotLand then iFactoryAction = refActionBuildAirFactory
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Want to build land factory not air factory1') end
                iFactoryAction = refActionBuildLandFactory
            end
            if bHaveLowPower and bWantAirNotLand then iBPWanted = iBPWanted * 0.5 end

            HaveActionToAssign(iFactoryAction, 1, iBPWanted)
        end
    end

    --Need SMD as enemy has nuke launcher
    iCurPriority = iCurPriority + 1

    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; About to consider if want SMD, is table of enemy nukes empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false then
        local bAssistSMD = false
        iBPWanted, bAssistSMD = GetBPToAssignToSMD(iPlateau, iLandZone, iTeam, tLZTeamData, true, bHaveLowMass, bWantMorePower)
        if bDebugMessages == true then LOG(sFunctionRef..': iBPWanted for SMD='..(iBPWanted or 'nil')..'; bAssistSMD='..tostring(bAssistSMD or false)) end
        if iBPWanted > 0 then
            if bAssistSMD then
                if bDebugMessages == true then LOG(sFunctionRef..': Will assist existing SMD') end
                HaveActionToAssign(refActionAssistSMD, 1, iBPWanted)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Want to build SMD, iCurPrioriyt='..iCurPriority) end
                HaveActionToAssign(refActionBuildSMD, 3, iBPWanted)
            end
        end
    end

    --Transports waiting for engineers
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; Is table of transports waiting for engineers empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers]) == false then
        --Check the table is still valid
        local iEngisWantedForTransports = GetEngisWantedForTransports(tLZTeamData)
        if bDebugMessages == true then LOG(sFunctionRef..': iEngisWantedForTransports after refresh='..iEngisWantedForTransports) end
        if iEngisWantedForTransports > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': want engineers to load onto transport') end
            --iActionToAssign,      iMinTechLevelWanted, i  BuildPowerWanted,                                                                       vOptionalVariable,  bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting
            --BP wanted - engineers already attached shouldn't be treated as available, however want BP wanted to be total not additional to avoid multiple unattached engineers being given the same order
            HaveActionToAssign(refActionLoadOntoTransport, 1, iEngisWantedForTransports * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]], nil, false,false) --Max 5 BP to make sure we only try loading 1 engi at a time
        end
    end

    --Zones wanting specific faction engineers (e.g. for shielding game ender)
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftFactoriesWantedForEngineers]) == false then
        local iZoneWantingEngineersOfFaction, iFactionWanted = GetZoneAndFactionForPriorityEngineerTravel(tLZTeamData, iTeam, iLandZone, iPlateau)
        if iZoneWantingEngineersOfFaction and iFactionWanted then
            HaveActionToAssign(refActionMoveToLandZone, 3, 90, iZoneWantingEngineersOfFaction, true, false, iFactionWanted)
        end
    end

    --Units needing air staging
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': About to check if we need air staging for core zone, Time='..GetGameTimeSeconds()..'; Time of last shortage='..(M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastAirStagingShortage] or 'nil')) end
    if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastAirStagingShortage] or 0) <= 1.1 then
        --Limit of 3 air staging in a LZ
        local tExistingAirStaging = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirStaging, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        local iExistingAirStaging = 0
        local oExistingM28Brain
        if M28Utilities.IsTableEmpty(tExistingAirStaging) == false then
            for iStaging, oStaging in tExistingAirStaging do
                if oStaging:GetFractionComplete() == 1 and oStaging:GetAIBrain().M28AI then
                    oExistingM28Brain = oStaging:GetAIBrain()
                    iExistingAirStaging = iExistingAirStaging + 1
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iExistingAirStaging='..iExistingAirStaging..'; bHaveLowMass='..tostring(bHaveLowMass)) end
        if iExistingAirStaging <= 1 or (iExistingAirStaging < 3 and not(bHaveLowMass)) or (iExistingAirStaging < 8 and oExistingM28Brain and oExistingM28Brain:GetCurrentUnits(M28UnitInfo.refCategoryAllNonExpAir) >= 50 * iExistingAirStaging) then
            iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
            if not(bHaveLowMass) then iBPWanted = iBPWanted * 2 end
            HaveActionToAssign(refActionBuildAirStaging, 1, iBPWanted, nil, false)
            if bDebugMessages == true then LOG(sFunctionRef..': Have flagged we want air staging with iBPWanted='..iBPWanted) end
        end
    end


    --Shielding in a high mass scenario
    iCurPriority = iCurPriority + 1
    if (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 500 then

        local iBPWanted, iTechLevelWanted, oUnitToShield = GetBPMinTechAndUnitForFixedShields(tLZTeamData, iTeam, true, bHaveLowMass, bWantMorePower, false, iLandZone)
        if iBPWanted > 0 then
            iBPWanted = math.min(iBPWanted, 40)

            HaveActionToAssign(refActionBuildShield, iTechLevelWanted, iBPWanted, oUnitToShield)
            if bDebugMessages == true then LOG(sFunctionRef..': High priority shield builder, iBPWanted='..iBPWanted) end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Dont want to assign any BP to high priority shield builder') end
        end
    end

    --Adjacent zones wanting mexes:
    iCurPriority = iCurPriority + 1
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS) Adjacent LZ that wants engineers (only chekc if we have available engineers)
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have available engineers to send to another LZ. GetHighestTechEngiAvailable='..GetHighestTechEngiAvailable(toAvailableEngineersByTech)) end
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    local iNearbyZonesWantingEngineers = 0
    local iPrevEngisAvailable
    local tLZWantingBPConsidered = {}
    local iAdjLZ
    if iHighestTechEngiAvailable > 0 then
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
            for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                if tPathingDetails[M28Map.subrefLZTravelDist] <= tLZData[M28Map.subrefLZFurthestAdjacentLandZoneTravelDist] then
                    iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                    tLZWantingBPConsidered[iAdjLZ] = true

                    local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, iAdjLZ, iPathingRef, iHighestTechEngiAvailable, true, false, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                    if tiBPByTechWanted then
                        for iTech = 1, iHighestTechEngiAvailable, 1 do
                            if tiBPByTechWanted[iTech] > 0 then
                                iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                iBPWanted = iNearbyZonesWantingEngineers * 5 + tiBPByTechWanted[iTech]
                                HaveActionToAssign(refActionMoveToLandZone, iTech, iBPWanted, iAdjLZ, true)
                                if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                    iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                end

                                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                if bDebugMessages == true then LOG(sFunctionRef..': Want iBPWanted='..iBPWanted..' to go to iAdjLZ='..iAdjLZ..'; iNearbyZonesWantingEngineers='..iNearbyZonesWantingEngineers..'; iHighestTechEngiAvailable='..iHighestTechEngiAvailable) end
                                if iHighestTechEngiAvailable == 0 then break end
                            end
                        end
                    end
                    if iHighestTechEngiAvailable == 0 then break end
                end
            end
        end
    end

    iCurPriority = iCurPriority + 1
    --If have adjacent waterzone that has unbuilt mexes or is a core WZ, wants engineers and has no combat threat then assign engi
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have adjacent WZ that wants engineer for unbuilt mexes or core WZ, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
    if iHighestTechEngiAvailable > 0 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
        local iCurWZ, iCurPond
        local iBPAlreadyAssigned = 0
        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
            iCurWZ = tSubtable[M28Map.subrefAWZRef]
            iCurPond = M28Map.tiPondByWaterZone[iCurWZ]
            local tWZData = M28Map.tPondDetails[iCurPond][M28Map.subrefPondWaterZones][iCurWZ]
            local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
            --Use similar logic to minor land zone to avoid unintended consequences
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iCurWZ='..iCurWZ..'; Core base='..tostring(tWZTeamData[M28Map.subrefWZbCoreBase] or false)..'; tWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation]='..tostring(tWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation])..'; Does it have an empty table of unbuilt mex locations='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]))) end
            if tWZTeamData[M28Map.subrefWZbCoreBase] or M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]) == false then

                if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to send engineers to an adjaent water zone, iCurWZ='..iCurWZ..'; tWZTeamData[M28Map.subrefTbWantBP]='..tostring(tWZTeamData[M28Map.subrefTbWantBP] or false)) end
                if tWZTeamData[M28Map.subrefTbWantBP] and tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 10 then
                    iBPWanted = 5
                    if tWZTeamData[M28Map.subrefTbWantBP] then
                        iBPWanted = math.min(40, math.max(tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]], tWZTeamData[M28Map.subrefTBuildPowerByTechWanted][1]))
                    end

                    HaveActionToAssign(refActionMoveToWaterZone, 1, iBPWanted + iBPAlreadyAssigned, iCurWZ, true)
                    iBPAlreadyAssigned = iBPAlreadyAssigned + iBPWanted
                    if bDebugMessages == true then LOG(sFunctionRef..': Tried to send engineers to iCurWZ '..iCurWZ..'; iBPWanted='..iBPWanted..'; iBPAlreadyAssigned='..iBPAlreadyAssigned) end
                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                    if iHighestTechEngiAvailable == 0 or iBPAlreadyAssigned >= tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 3 then break end
                end
            end

        end
    end

    --High priority reclaim if are low on mass or energy
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we will want to reclaim mass in LZ, bHaveLowMass='..tostring(bHaveLowMass)..'; tLZData[M28Map.subrefTotalMassReclaim]='..tLZData[M28Map.subrefTotalMassReclaim]) end
    if bHaveLowMass and tLZData[M28Map.subrefTotalMassReclaim] >= 50 then
        if bDebugMessages == true then LOG(sFunctionRef..': High priority reclaim, Total mass in Plateau '..iPlateau..' LZ '..iLandZone..'='..tLZData[M28Map.subrefTotalMassReclaim]) end
        HaveActionToAssign(refActionReclaimArea, 1, math.min(40, math.max(5, tLZData[M28Map.subrefTotalMassReclaim] / 50)), false)
    elseif M28Conditions.WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone) then
        HaveActionToAssign(refActionReclaimArea, 1, 5, true)
    end

    --TMD (including vs mobile ACUs with TML upgrade)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Considering if we want to get TMD; is table of units wanting TMD empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]) == false then
        local oUnitWantingTMD = M28Building.GetUnitWantingTMD(tLZData, tLZTeamData)
        if oUnitWantingTMD then
            iBPWanted = 40
            if not(bHaveLowMass) and not(bHaveLowPower) then iBPWanted = 70 end
            HaveActionToAssign(refActionBuildTMD, 2, iBPWanted, oUnitWantingTMD)
        end
    end

    --Approaching enemy guncom - prioritise upgrades if dont have T2, if do have T2 then get T2 PD
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if emergency PD is needed, iApproachingACUThreat='..iApproachingACUThreat) end
    if iApproachingACUThreat > 0 then
        --Do we have T2 (or a teammate has t3)?
        local bHaveSufficientTech = false
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then bHaveSufficientTech = true
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 then
            local tT2PlusFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory - categories.TECH1, tLZTeamData[M28Map.subrefLZTAlliedUnits])
            if M28Utilities.IsTableEmpty(tT2PlusFactories) == false then
                for iUnit, oUnit in tT2PlusFactories do
                    if oUnit:GetFractionComplete() >= 1 and oUnit:GetAIBrain().M28AI then
                        bHaveSufficientTech = true
                        break
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveSufficientTech='..tostring(bHaveSufficientTech)) end
        if not(bHaveSufficientTech) and (M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 4) then
            --Do we have an active factory upgrade?
            local bHaveActiveHQUpgrade = false
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then
                for iUpgrade, oUpgrade in tLZTeamData[M28Map.subrefActiveUpgrades] do
                    if EntityCategoryContains(M28UnitInfo.refCategoryFactory, oUpgrade.UnitId) then
                        bHaveActiveHQUpgrade = true
                        break
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bHaveActiveHQUpgrade='..tostring(bHaveActiveHQUpgrade)) end
            if bHaveActiveHQUpgrade then
                iBPWanted = 20
                if not(bHaveLowPower) and not(bHaveLowMass) then iBPWanted = 40 end
                HaveActionToAssign(refActionAssistUpgrade, 1, iBPWanted)
                if bDebugMessages == true then LOG(sFunctionRef..': We have an active HQ upgrade so will assist this') end
            else
                --We need a priority upgrade
                local tExistingT1LandFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory * categories.TECH1, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                if M28Utilities.IsTableEmpty(tExistingT1LandFactories) == false then
                    --Get factory with lowest fraction complete
                    local oFactoryToUpgrade
                    local iLowestWorkProgress = 1
                    for iFactory, oFactory in tExistingT1LandFactories do
                        if M28UnitInfo.IsUnitValid(oFactory) and oFactory:GetFractionComplete() then
                            if (oFactory:GetWorkProgress() or 0) < iLowestWorkProgress then
                                oFactoryToUpgrade = oFactory
                                iLowestWorkProgress = (oFactory:GetWorkProgress() or 0)
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Have searched for t1 land factories to upgrade, is oFactoryToUpgrade valid='..tostring(M28UnitInfo.IsUnitValid(oFactoryToUpgrade))) end
                    if oFactoryToUpgrade then
                        if bDebugMessages == true then LOG(sFunctionRef..': Doign priority upgrade for oFactoryToUpgrade='..oFactoryToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactoryToUpgrade)..' due to appraoching enemy ACU') end
                        M28Economy.UpgradeUnit(oFactoryToUpgrade, true)
                    end
                end
            end
        else
            --We have T2 tech (or only need T1 due to enemy not having gun), so want to build PD
            local iRangeThreshold = 35 --Range of Aeon guncom
            if not(bHaveSufficientTech) then iRangeThreshold = 1 end
            --Increase PD threat if enemy is in another zone that has PD in it
            local iCurPDThreat = GetPDThreatAboveRangeThresholdAlongPath(iPlateau, iLandZone, tLZData, tLZTeamData, iTeam, iRangeThreshold, tNearestEnemyACU)
            local iACUPlateauOrZero, iACULandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tNearestEnemyACU)
            if iACULandZone > 0 and iACUPlateauOrZero == iPlateau and not(iACULandZone == iLandZone) then
                --ACU is in a different land zone
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iACULandZone]][M28Map.subrefLZPath]) == false then
                    for iEntry, iAdjLZ in  tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iACULandZone]][M28Map.subrefLZPath] do
                        if not(iAdjLZ == iLandZone) then
                            local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                            if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
                                for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                                    if iRange >= iRangeThreshold then
                                        iCurPDThreat = iCurPDThreat + iThreat
                                    end
                                end
                            end
                        end
                    end
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': We have T2 or better or want T1 PD for nongun ACU, iCurPDThreat='..iCurPDThreat..'; iAppraochingACUThreat='..iApproachingACUThreat..'; bHaveSufficientTech='..tostring(bHaveSufficientTech)) end
            if (bHaveSufficientTech or iCurPDThreat == 0) and (iCurPDThreat <= math.max(1200, iApproachingACUThreat * 1.75) or (iCurPDThreat <= 2400 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 200 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0))) then
                iBPWanted = 40
                if not(bHaveLowMass) and not(bHaveLowPower) then iBPWanted = 80 end
                local tTargetBuildLocation
                if tNearestEnemyACU then
                    tTargetBuildLocation = GetStartSearchPositionForEmergencyPD(tNearestEnemyACU, tLZData[M28Map.subrefMidpoint], iPlateau, iLandZone)
                end
                local iPDTechLevelWanted = 2
                if not(bHaveSufficientTech) then iPDTechLevelWanted = 1 end
                HaveActionToAssign(refActionBuildEmergencyPD, iPDTechLevelWanted, iBPWanted, tTargetBuildLocation)
                if bDebugMessages == true then LOG(sFunctionRef..': Will build emergency PD, iPDTechLevelWanted='..iPDTechLevelWanted) end
            end
        end
    end

    --Nearby enemy ground threat and we dont already have at least 2 T2 PD
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if want emergency PD for normal ground threat, tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Is table of nearest DF enemies empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]))) end
    if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
        --Get existing T2 PD threat
        local iCurPDThreat = 0
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                iCurPDThreat = iCurPDThreat + iThreat
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iCurPDThreat='..iCurPDThreat..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end
        if iCurPDThreat <= 1000 and (iCurPDThreat == 0 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] > 1) then
            --Get nearby enemy threat, but only for adjacent LZs
            local iEnemyThreat = tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                for iEntry, tAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                    iEnemyThreat = iEnemyThreat + (tAltLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iEnemyThreat='..iEnemyThreat) end
            if iCurPDThreat < iEnemyThreat * 3 then
                --Are the enemies in an adjacent zone with none in this zone? if so factor in PD in that zone as well
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) then
                    local iCurDist
                    local iClosestDist = 100000
                    local oClosestUnit
                    for iUnit, oUnit in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oClosestUnit = oUnit
                            end
                        end
                    end
                    if oClosestUnit and iClosestDist >= 50 then
                        iCurPDThreat = GetPDThreatAboveRangeThresholdAlongPath(iPlateau, iLandZone, tLZData, tLZTeamData, iTeam, 1, oClosestUnit:GetPosition())
                    end
                end
                if iCurPDThreat < iEnemyThreat * 3 then

                    iBPWanted = 40
                    if not(bHaveLowMass) and not(bHaveLowPower) then iBPWanted = 80 end
                    local tEnemiesToConsider = {}
                    local oNearestEnemy
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                        for iUnit, oUnit in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                            if M28UnitInfo.IsUnitValid(oUnit) then
                                table.insert(tEnemiesToConsider, oUnit)
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tEnemiesToConsider) == false then
                        if not(oNearestEnemy) then oNearestEnemy = M28Utilities.GetNearestUnit(tLZTeamData[M28Map.reftoNearestDFEnemies], tLZData[M28Map.subrefMidpoint], true, M28Map.refPathingTypeLand) end
                        if oNearestEnemy then
                            local tTargetBuildLocation = GetStartSearchPositionForEmergencyPD(oNearestEnemy:GetPosition(), tLZData[M28Map.subrefMidpoint], iPlateau, iLandZone)
                            local iMinTechWanted = 1
                            if iCurPDThreat > 0 then iMinTechWanted = 2 end
                            HaveActionToAssign(refActionBuildEmergencyPD, iMinTechWanted, iBPWanted, tTargetBuildLocation)
                            if bDebugMessages == true then LOG(sFunctionRef..': Will build emergency PD to stop enemy ground threat, iMinTechWanted='..iMinTechWanted) end
                        end
                    end
                end
            end
        end
    end

    --Extra (second) shielding in a high mass scenario - will only try to shield t3 arti/game ender
    iCurPriority = iCurPriority + 1
    if (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 500 then

        local iBPWanted, iTechLevelWanted, oUnitToShield = GetBPMinTechAndUnitForFixedShields(tLZTeamData, iTeam, true, bHaveLowMass, bWantMorePower, true, iLandZone)
        if iBPWanted > 0 then
            iBPWanted = math.min(iBPWanted, 40)

            HaveActionToAssign(refActionBuildSecondShield, iTechLevelWanted, iBPWanted, oUnitToShield)
            if bDebugMessages == true then LOG(sFunctionRef..': Second shield builder, iBPWanted='..iBPWanted..'; iLandZone='..iLandZone) end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Dont want to assign any BP to second shield builder, LZ='..iLandZone) end
        end
    end


    --Preemptive fixed AA if we have T2+ air fac and no fixed T2+ ground AA and dont have much MAA threat here either
    --Also includes T3 SAM preemptive builder in greater numbers if we lack air control and have at least 10 mass per tick and not low mass
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want fixed AA due to haveing T2+ air, iCurPriority='..iCurPriority..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]..'; tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 2 and tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < 800 * (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] - 1) then
        --Do we already have fixed AA in this LZ?
        local iAACategory = M28UnitInfo.refCategoryStructureAA - categories.TECH1
        if M28Team.subrefiHighestFriendlyFactoryTech >= 3 then iAACategory = iAACategory * categories.TECH3 end
        local tExistingFixedAA = EntityCategoryFilterDown(iAACategory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        local bHaveFixedAA = false
        if M28Utilities.IsTableEmpty(tExistingFixedAA) == false then
            for iUnit, oUnit in tExistingFixedAA do
                if oUnit:GetFractionComplete() then bHaveFixedAA = true break end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveFixedAA='..tostring(bHaveFixedAA)) end
        if not(bHaveFixedAA) then
            iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
            if iNearbyEnemyAirToGroundThreat > 0 then iBPWanted = iBPWanted * 2 end
            if not(bHaveLowPower) then
                if not(bHaveLowMass) then iBPWanted = iBPWanted * 3
                else iBPWanted = iBPWanted * 1.5
                end
            end
            HaveActionToAssign(refActionBuildAA, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted)
            if bDebugMessages == true then LOG(sFunctionRef..': T2 plus preemptive AA builder, iBPWanted='..iBPWanted) end
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 and not(bHaveLowMass) and not(M28Team.tTeamData[iTeam][M28Team.refbHaveAirControl]) and table.getn(tExistingFixedAA) < 4 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 then
            if bDebugMessages == true then LOG(sFunctionRef..': Want to get T3 AA preemptively') end
            HaveActionToAssign(refActionBuildAA, 3, 30)
        end
    end

    --Second power builder to help scale power late game if high on mass
    iCurPriority = iCurPriority + 1
    if bWantMorePower and not(bHaveLowMass) and ((M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 0) >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 * (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 1)) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 120 * (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 1) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0) * 1.25 then
        iBPWanted = tiBPByTech[(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 1)] * 10
        --reduce BP wanted if dont have massive amount of mass
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] <= 5000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 25 then iBPWanted = iBPWanted * 0.6 end
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 500 then
            iBPWanted = iBPWanted * 0.5 --i.e. want to have construction started so primary power builder can build sooner but not as worried about building this really fast
        end
        HaveActionToAssign(refActionBuildSecondPower, (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 1), iBPWanted)
        if bDebugMessages == true then LOG(sFunctionRef..': Want to build second power due to lots of mass and having recently needed more energy for air production') end
    end

    --Similar to above but for third power with slightly greater mass threshold, and only for very high mass and energy incomes, and only if have stalled for power in last 60s
    iCurPriority = iCurPriority + 1
    if bWantMorePower and not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 8000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 60 and (GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or 0) <= 60 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0) * 1.1) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 0) >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 1500 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0) * 1.25 then
        iBPWanted = 325 --10 T3 engis
        --reduce BP wanted if dont have massive amount of mass
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] <= 15000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 80 then iBPWanted = 150 end
        HaveActionToAssign(refActionBuildThirdPower, 3, iBPWanted)
        if bDebugMessages == true then LOG(sFunctionRef..': Want to build second power due to lots of mass and having recently needed more energy for air production') end
    end

    --Assist air fac if at T2
    iCurPriority = iCurPriority + 1
    if not(bWantMorePower) and (not(bHaveLowMass) or bWantMoreFactories) then
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 2 then
            --Check we have more power than when we last were unable to build air units
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] > (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0) * 1.25 then
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
                    local tT2PlusAirFacsInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory * M28UnitInfo.ConvertTechLevelToCategory(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]), tLZTeamData[M28Map.subrefLZTAlliedUnits])
                    if M28Utilities.IsTableEmpty(   tT2PlusAirFacsInLZ) == false then
                        if bHaveLowMass then iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2
                        else
                            iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 4
                            if not(bWantMorePower) then iBPWanted = iBPWanted * 2 end
                        end
                        HaveActionToAssign(refActionAssistAirFactory, 1, iBPWanted)
                    end
                end
            end
        end
    end

    --High priority factories
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to build a factory, bWantMoreFactories='..tostring(bWantMoreFactories)..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Mass % stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; Highest tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end
    if bWantMoreFactories and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 11 and (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 and GetGameTimeSeconds() <= 600 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.05) or (M28Map.iMapSize <= 256 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 150 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0)))) then
        if (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 0) > 0 then
            if bHaveLowMass then iBPWanted =  tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2
            else iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 4
            end
        else
            iBPWanted = 5
        end

        local bWantAirNotLand = M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)
        local iFactoryAction
        if bWantAirNotLand then iFactoryAction = refActionBuildAirFactory
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Want to build land factory not air factory2') end
            iFactoryAction = refActionBuildLandFactory
        end
        if bHaveLowPower and bWantAirNotLand then iBPWanted = iBPWanted * 0.5 end
        if bDebugMessages == true then LOG(sFunctionRef..': Wnat to build a factory, iBPWanted='..iBPWanted) end
        HaveActionToAssign(iFactoryAction, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted, nil)
    end


    --High priority islands (early-game expansion)
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS)
    iCurPriority = iCurPriority + 1
    local iBPAlreadyTraveling = 0
    GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if bDebugMessages == true then LOG(sFunctionRef..': Core LZ considering engis for islands, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Time='..GetGameTimeSeconds()) end
    if iHighestTechEngiAvailable > 0 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of pathing to other islands empty='..tostring(tLZData[M28Map.subrefLZPathingToOtherIslands])) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
            local iDistanceThreshold = math.max(125, M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) * 0.502)
            if bDebugMessages == true then LOG(sFunctionRef..': iDistanceThreshold='..iDistanceThreshold) end

            for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..'; Travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; tPathingData[M28Map.subrefIslandClosestLZRef]='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; Are there enemies in this or adjacnet LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                if tPathingData[M28Map.subrefIslandTravelDist] > iDistanceThreshold then break
                else
                    --Are there enemies in the target LZ?
                    local tIslandLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]]
                    if tPathingData[M28Map.subrefIslandClosestLZRef] and M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefMexUnbuiltLocations]) == false and (tIslandLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] or 0) == 0 then
                        local iEnemyThreatNearby = 0
                        if tIslandLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                            if M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                    iEnemyThreatNearby = iEnemyThreatNearby + (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..'; iEnemyThreatNearby='..iEnemyThreatNearby) end
                        if iEnemyThreatNearby <= 10 then
                            local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, tPathingData[M28Map.subrefIslandClosestLZRef], iEntry, iHighestTechEngiAvailable, false, true)
                            if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                            if tiBPByTechWanted then
                                --Is it either a minor zone, or a core zone that either wants lots of BP or doesnt have any engineers traveling to it?
                                for iTech = 1, iHighestTechEngiAvailable, 1 do
                                    if tiBPByTechWanted[iTech] > 0 then
                                        iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                        iBPWanted = iBPAlreadyTraveling + 5
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and assign an engineer to go to tPathingData[M28Map.subrefIslandClosestLZRef]='..tPathingData[M28Map.subrefIslandClosestLZRef]..'; BP wanted='..iBPWanted..'; iTech='..iTech..'; iPrevEngisAvailable='..iPrevEngisAvailable) end
                                        HaveActionToAssign(refActionMoveToLandZone, iTech, iBPWanted, tPathingData[M28Map.subrefIslandClosestLZRef], true)
                                        if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                            iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                            iBPAlreadyTraveling = iBPAlreadyTraveling + tiBPByTech[iTech]
                                        end

                                        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                        if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable after this='..iHighestTechEngiAvailable) end
                                        if iHighestTechEngiAvailable == 0 then break end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    --TML if enemy has vulnerable units
    iCurPriority = iCurPriority + 1
    if iHighestTechEngiAvailable >= 2 and not(bHaveLowPower) then
        iBPWanted = GetBPToAssignToBuildingTML(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam, bHaveLowMass)
        if iBPWanted > 0 then
            HaveActionToAssign(refActionBuildTML, 2, iBPWanted)
        end
    end



    --Energy storage once have eco to support it
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; Considering building energy storage, Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; Have low power='..tostring(bHaveLowPower)..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount]='..M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount]..'; Enemy unit with highest health='..M28Team.tTeamData[iTeam][M28Team.refiEnemyHighestMobileLandHealth]) end
    if not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] <= 7 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 1 + M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] * 5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 30 + M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] * 20 and (((M28Map.bIsCampaignMap or (GetGameTimeSeconds() >= 600 and M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] == 0)) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1 + 0.25 * M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount]) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2.5 + 0.25 * M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount])) then
        --Do we have enough storage to 1-shot any enemy unit?
        if M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] < math.max(1, math.ceil((M28Team.tTeamData[iTeam][M28Team.refiEnemyHighestMobileLandHealth] / 0.9 - 1000) / (0.25 * M28Building.iEnergyStorageExpectedCapacity))) then
            --Is the number of storage in this LZ <= lowest storage count?
            local toStorageInThisLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryEnergyStorage, tLZTeamData[M28Map.subrefLZTAlliedUnits])
            local iStorageInThisLZ
            if M28Utilities.IsTableEmpty(toStorageInThisLZ) == false then
                iStorageInThisLZ = table.getn(toStorageInThisLZ)
            else
                iStorageInThisLZ = 0
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iStorageInThisLZ='..iStorageInThisLZ) end
            if iStorageInThisLZ <= M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to get storage, Is tEngineers[1] valid='..tostring(M28UnitInfo.IsUnitValid(tEngineers[1]))) end
                iBPWanted = 5
                if not(bHaveLowMass) then iBPWanted = 20 end
                HaveActionToAssign(refActionBuildEnergyStorage, 1, iBPWanted)
            end
        end
    end

    --Shielding
    iCurPriority = iCurPriority + 1
    local iTechlevelWanted, oUnitToShield
    iBPWanted, iTechLevelWanted, oUnitToShield = GetBPMinTechAndUnitForFixedShields(tLZTeamData, iTeam, true, bHaveLowMass, bWantMorePower, false, iLandZone)
    if iBPWanted > 0 then
        if bDebugMessages == true then LOG(sFunctionRef..': Want to build a shield, iBPWanted='..iBPWanted..'; bHaveLowMass='..tostring(bHaveLowMass)..'; bWantMorePower='..tostring(bWantMorePower)..'; oUnitToShield='..oUnitToShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToShield)..'; iTechLevelWanted='..iTechLevelWanted) end
        HaveActionToAssign(refActionBuildShield, iTechLevelWanted, iBPWanted, oUnitToShield)
    end

    --AA including SAMs
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Do we want more airaa? iNearbyEnemyAirToGroundThreat='..iNearbyEnemyAirToGroundThreat..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]) end
    if iNearbyEnemyAirToGroundThreat > 0 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= math.max(tLZTeamData[M28Map.subrefLZThreatAllyGroundAA], 800) then
        local iGroundAAThreatWanted
        if M28Team.tTeamData[iTeam][M28Team.refbHaveAirControl] then
            iGroundAAThreatWanted = M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.4 + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.15
        elseif M28Team.tTeamData[iTeam][M28Team.refbFarBehindOnAir] then
            iGroundAAThreatWanted = M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.8 + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.3
            if M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] >= 2000 then iGroundAAThreatWanted = iGroundAAThreatWanted + math.min(M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.15, M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat]) end
        else
            iGroundAAThreatWanted = M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.6 + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.225
            if M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] >= 2000 then iGroundAAThreatWanted = iGroundAAThreatWanted + math.min(M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.1, M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat]) end
        end
        iGroundAAThreatWanted = math.max(iNearbyEnemyAirToGroundThreat * 2, iNearbyEnemyAirToGroundThreat + iGroundAAThreatWanted)
        --Cap Ground AA at equiv of 3 T2 flak if no enemy air to ground threat in this zone, and we arent at T3
        if iGroundAAThreatWanted >= 2400 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) then
            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 then
                iGroundAAThreatWanted = 2400
            else
                --At T3 - reduce the amount of fixed AA wanted slightly for very high threat values (i.e. >= 10 SAM equivalent)
                if iGroundAAThreatWanted >= 16000 then
                    if iGroundAAThreatWanted >= 30000 then
                        iGroundAAThreatWanted = 16000 + 14000 * 0.75 + (iGroundAAThreatWanted - 30000) * 0.5
                    else
                        iGroundAAThreatWanted = 16000 + (iGroundAAThreatWanted - 16000) * 0.75
                    end
                end

                --Campaign maps - further reduce amount earlier into the game
                if M28Map.bIsCampaignMap and iGroundAAThreatWanted >= 8000 and (bHaveLowMass or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.4) and (tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] >= math.max(20000, 1000 * M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) or GetGameTimeSeconds() <= 15 * 60) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= math.max(20, tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] / 1000)) then
                    iGroundAAThreatWanted = math.min((iGroundAAThreatWanted - 8000) * 0.25 + 8000, 12000)
                end
            end
        end
        --= M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]
        if tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < iGroundAAThreatWanted or (tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] <= 1600 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 or (tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < 1200 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2) or tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < 120)) then
            --Do we already have fixed AA in this LZ?
            local iAACategory = M28UnitInfo.refCategoryStructureAA
            if M28Team.subrefiHighestFriendlyFactoryTech >= 3 then iAACategory = iAACategory * categories.TECH3 end
            local tExistingFixedAA = EntityCategoryFilterDown(iAACategory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
            if M28Utilities.IsTableEmpty(tExistingFixedAA) or tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < math.max(1500 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech], tLZTeamData[M28Map.refiEnemyAirToGroundThreat] * 3 + tLZTeamData[M28Map.refiEnemyAirAAThreat], iGroundAAThreatWanted) then
                --Cap amount of SAMs if we dont have all T3 mexes in the zone and have low mass
                if not(bHaveLowMass and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) and tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] >= 6000 and (tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][1]) > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] > 15 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                    iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
                    if iNearbyEnemyAirToGroundThreat > 0 then iBPWanted = iBPWanted * 2 end
                    if not(bHaveLowPower) then
                        if not(bHaveLowMass) then iBPWanted = iBPWanted * 4
                        else iBPWanted = iBPWanted * 2
                        end
                    end
                    HaveActionToAssign(refActionBuildAA, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted)
                    if bDebugMessages == true then LOG(sFunctionRef..': WIll build more AA, iBPWanted='..iBPWanted) end
                end
            end
        end
    end

    --Reclaim specific units
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if have units to reclaim, is table empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoUnitsToReclaim]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoUnitsToReclaim]) == false then
        local bObjectiveToReclaim = false
        if M28Map.bIsCampaignMap then
            for iUnit, oUnit in tLZTeamData[M28Map.subreftoUnitsToReclaim] do
                if oUnit[M28UnitInfo.refbIsReclaimTarget] then bObjectiveToReclaim = true break end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Want to try and reclaim, bObjectiveToReclaim='..tostring(bObjectiveToReclaim)) end
        HaveActionToAssign(refActionReclaimFriendlyUnit, 1, math.max(10, 10 * table.getn(tLZTeamData[M28Map.subreftoUnitsToReclaim])), nil, not(bObjectiveToReclaim))
    end

    --T2 arti if enemy has sniper bots or fatboy, or a firebase that threatens this zone
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want emergency T2 arti, iCurPriority='..iCurPriority..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]..'; Friendly tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Is table of pathing to other zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]))..'; Is tLZTeamData[M28Map.subreftEnemyFirebasesInRange] empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 5 then
        local iRangeThreshold = 65
        local iEnemyLongRangeThreat = 0
        local iSearchRange = 300
        local iBestEnemyRange = 0
        local iCurDFThreat, iCurIFThreat
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of firebases in range empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]))) end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
            for iFirebase, tPlateauAndZone in tLZTeamData[M28Map.subreftEnemyFirebasesInRange] do
                iEnemyLongRangeThreat = iEnemyLongRangeThreat + math.max(1500, (M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefThreatEnemyStructureTotalMass] or 0))
                if bDebugMessages == true then LOG(sFunctionRef..': iEnemyLongRangeThreat after increasing for firebase in tPlateauAndZone '..repru(tPlateauAndZone)..'='..iEnemyLongRangeThreat) end
            end
        end
        --Only consider enemy long range threat in adjacent zones - if already in this zone then presumably too close for arti to help that much
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
            for iEntry, tSubtable in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                if tSubtable[M28Map.subrefLZTravelDist] > iSearchRange then break
                else
                    local iAltLZ = tSubtable[M28Map.subrefLZNumber]
                    local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAltLZ][M28Map.subrefLZTeamData][iTeam]
                    iCurDFThreat = 0
                    iCurIFThreat = 0
                    if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) == false then
                        for iRange, iThreat in tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] do
                            if iRange >= iRangeThreshold then
                                iCurDFThreat = iCurDFThreat + iThreat
                                iBestEnemyRange = math.max(iBestEnemyRange, iRange)
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange]) == false then
                        for iRange, iThreat in tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] do
                            if iRange >= iRangeThreshold then
                                iCurIFThreat = iCurIFThreat + iThreat
                                iBestEnemyRange = math.max(iBestEnemyRange, iRange)
                            end
                        end
                    end
                    iEnemyLongRangeThreat = iEnemyLongRangeThreat + math.max(iCurIFThreat, iCurDFThreat)
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering iAltLZ='..iAltLZ..'; iCurIFThreat='..iCurIFThreat..'; iCurDFThreat='..iCurDFThreat..'; iEnemyLongRnageThreat='..iEnemyLongRangeThreat..'; tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]='..repru(tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange])..'; tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange]='..repru(tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange])) end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iEnemyLongRangeThreat after checking all zones within dist threshold='..iEnemyLongRangeThreat) end
        if iEnemyLongRangeThreat >= 750 then
            --What is our long range threat that equals their range?
            iCurDFThreat = 0
            iCurIFThreat = 0
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
                for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                    if iRange >= iEnemyLongRangeThreat then iCurDFThreat = iCurDFThreat + iThreat end
                end
            end
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange]) == false then
                for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] do
                    if iRange >= iEnemyLongRangeThreat then iCurIFThreat = iCurIFThreat + iThreat end
                end
            end
            local iThreatWanted = iEnemyLongRangeThreat * 1.5 - iCurDFThreat - iCurIFThreat
            if bDebugMessages == true then LOG(sFunctionRef..': iCurDFThreat='..iCurDFThreat..'; iCurIFThreat='..iCurIFThreat..'; iThreatWanted='..iThreatWanted) end
            if iThreatWanted >= 500 then
                --Get friendly T2 arti threat
                local iT2ArtiThreat = 0
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
                    local tT2Arti = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                    if M28Utilities.IsTableEmpty(tT2Arti) == false then
                        iT2ArtiThreat = M28UnitInfo.GetCombatThreatRating(tT2Arti, false, true) --Will be 60% of mass cost per getcombatthreatrating
                    end
                end
                iThreatWanted = iThreatWanted - iT2ArtiThreat
                if bDebugMessages == true then LOG(sFunctionRef..': iT2ArtiThreat='..iT2ArtiThreat..'; iThreatWanted='..iThreatWanted) end
                if iThreatWanted >= 500 then
                    if iThreatWanted <= 4000 then
                        iBPWanted = math.min(120, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 10)
                    else
                        --Presumably up against a fatboy so need T2 arti asap
                        iBPWanted = math.min(240, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 10)
                    end
                    if bHaveLowMass or bHaveLowPower then iBPWanted = iBPWanted * 0.5 end
                    HaveActionToAssign(refActionBuildEmergencyArti, 2, iBPWanted)
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to build emergency arti, iBPWanted='..iBPWanted) end
                end
            end

        end
    end

    --More power
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': More power builder, bHaveLowMass='..tostring(bHaveLowMass)..'; bWantMorePower='..tostring(bWantMorePower)..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Highest friendly factory tech='..(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 'nil')) end
    if not(bHaveLowMass) and bWantMorePower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 11 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 0) > 0 then
        iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 5
        if bDebugMessages == true then LOG(sFunctionRef..': Want more power, iCurPriority='..iCurPriority..'; iBPWanted='..iBPWanted) end
        HaveActionToAssign(refActionBuildPower, iMinTechLevelForPower, iBPWanted)
    end

    --Shield assistance
    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPForShieldAssistance(tLZTeamData, iTeam)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionAssistShield, 1, iBPWanted)
    end

    --Higher priority mass storage if we have T3 in the LZ and available storage locations
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 11 and (tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][2] >= 4) and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 then
        iBPWanted = GetBPToAssignToMassStorage(iPlateau, iLandZone, iTeam, tLZTeamData, true, bHaveLowMass, bWantMorePower)
        if iBPWanted > 0 then
            HaveActionToAssign(refActionBuildMassStorage, 1, iBPWanted)
        end
    end

    --Factory builder ahead of assisting upgrades for if we have low mass stored but lots of mexes upgrading in this LZ, and are at T3
    iCurPriority = iCurPriority + 1
    if iActiveMexUpgrades >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.01 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0 and table.getn(tLZTeamData[M28Map.subrefActiveUpgrades]) >= 3 then
        if bHaveLowPower then iBPWanted = tiBPByTech[3] * 3
        else iBPWanted = tiBPByTech[3] * 5
        end
        local bWantAirNotLand = M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)
        local iFactoryAction
        if bWantAirNotLand then iFactoryAction = refActionBuildAirFactory
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Want to build land factory not air factory3') end
            iFactoryAction = refActionBuildLandFactory
        end
        if bHaveLowPower and bWantAirNotLand then iBPWanted = iBPWanted * 0.5 end

        HaveActionToAssign(iFactoryAction, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted, nil)
    end

    --Preemptive SMD
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; About to consider if want SMD, is table of enemy nukes empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]))..'; tLZTeamData[M28Map.subrefLZSValue]='..tLZTeamData[M28Map.subrefLZSValue]..'; Lifetime T3 nonstructure count='..M28Conditions.GetTeamLifetimeBuildCount(iTeam, categories.TECH3 - categories.STRUCTURE)) end
    if tLZTeamData[M28Map.subrefLZSValue] >= 20000 and not(bHaveLowPower) and (tLZTeamData[M28Map.subrefLZSValue] >= 30000 or not(bHaveLowMass)) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then
        --Only build SMD if we have built a lot of T3 units or have built experimentals or have very high eco
        if tLZTeamData[M28Map.subrefLZSValue] >= 45000 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 30 or M28Conditions.GetTeamLifetimeBuildCount(iTeam, categories.TECH3 - categories.STRUCTURE) >= 20 then
            --Also require several T3 mexes
            if (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 or (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1 and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 25)) then
                local bAssistSMD = false
                iBPWanted, bAssistSMD = GetBPToAssignToSMD(iPlateau, iLandZone, iTeam, tLZTeamData, false, bHaveLowMass, bWantMorePower)
                if iBPWanted > 0 and not(bAssistSMD) then --Since htis is precautionary not worried about rushing the SMD
                    HaveActionToAssign(refActionBuildSMD, 3, iBPWanted)
                end
            end
        end
    end

    --Build multiple land factories if have lots of mass stored (higher priority)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want high priority second factory builder, bHaveLowMass='..tostring(bHaveLowMass)..'; bHaveLowPower='..tostring(bHaveLowPower)..'; bWantMoreFactories='..tostring(bWantMoreFactories)..'; iActiveMexUpgrades='..iActiveMexUpgrades..'; Mass % stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; Friendly highest land fac tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]..'; Team net mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) end
    if not(bHaveLowMass) and not(bHaveLowPower) and bWantMoreFactories and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 11 and (iActiveMexUpgrades >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.25) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3 or iActiveMexUpgrades >= 4) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 1 or iActiveMexUpgrades >= 4) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.45 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= math.min(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 0.25, 8)) then

        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.55 then iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]] * 4
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0 then iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]] * 2
        else iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]]
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Have lots of mass so want to build more than one factory at once as high priority, iBPWanted='..iBPWanted) end
        if not(M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)) then
            HaveActionToAssign(refActionBuildSecondLandFactory, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech], iBPWanted)
        end
    end

    --Second mass storage if we have T3 mex in this LZ and 5+ mass storage locations
    iCurPriority = iCurPriority + 1
    if (tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][2] >= 4) and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 then
        iBPWanted = GetBPToAssignToMassStorage(iPlateau, iLandZone, iTeam, tLZTeamData, true, bHaveLowMass, bWantMorePower)
        if iBPWanted > 0 then
            if table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMassStorageLocationsAvailable]) >= 5 then
                HaveActionToAssign(refActionBuildSecondMassStorage, 1, iBPWanted)
            end
        end
    end

    --Assist upgrades:
    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPToAssignToAssistUpgrade(tLZTeamData, iTeam, true, bHaveLowMass, bWantMorePower)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionAssistUpgrade, 1, iBPWanted)
    end

    --Build mass storage if we have T2+ mexes
    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPToAssignToMassStorage(iPlateau, iLandZone, iTeam, tLZTeamData, true, bHaveLowMass, bWantMorePower)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionBuildMassStorage, 1, iBPWanted)
    end


    --Lower priority mass reclaim
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.35 and tLZData[M28Map.subrefTotalMassReclaim] >= 5 then
        if bDebugMessages == true then LOG(sFunctionRef..': Lower priority reclaim, Total mass in Plateau '..iPlateau..' LZ '..iLandZone..'='..tLZData[M28Map.subrefTotalMassReclaim]) end
        HaveActionToAssign(refActionReclaimArea, 1, math.min(100, math.max(5, tLZData[M28Map.subrefTotalMassReclaim] / 50)), false)
    end

    --Radar (not high priority)
    iCurPriority = iCurPriority + 1
    if not(bHaveLowPower) and not (M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmni]) then
        --T1 radar
        if tLZTeamData[M28Map.refiRadarCoverage] <= 50 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 25 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2.5 then
            --Check we dont already have t1 radar in the land zone
            if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryT1Radar, tLZTeamData[M28Map.subrefLZTAlliedUnits])) then
                iBPWanted = 5
                if not(bHaveLowMass) then iBPWanted = 15 end
                HaveActionToAssign(refActionBuildT1Radar, 1, iBPWanted)
            end
        end

        --T2 radar
        iCurPriority = iCurPriority + 1
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if want T2 radar, tLZTeamData[M28Map.refiRadarCoverage]='..tLZTeamData[M28Map.refiRadarCoverage]..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]) end
        if tLZTeamData[M28Map.refiRadarCoverage] <= 130 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 100 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 5 then
            --Check we dont already have t2 radar in the land zone
            if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryT2Radar, tLZTeamData[M28Map.subrefLZTAlliedUnits])) then
                iBPWanted = 20
                if not(bHaveLowMass) then iBPWanted = 60 end
                HaveActionToAssign(refActionBuildT2Radar, 2, iBPWanted)
            end
        end

        --T3 radar
        iCurPriority = iCurPriority + 1
        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to build T3 radar, tLZTeamData[M28Map.refiRadarCoverage]='..tLZTeamData[M28Map.refiRadarCoverage]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Closest enemy base dist to midpoint='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase])..'; tLZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
        if tLZTeamData[M28Map.refiRadarCoverage] <= 300 and ((M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 500 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 200) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 350 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 100 and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryMobileLand * categories.TECH3 - M28UnitInfo.refCategoryEngineer) >= 40) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 and (M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase]) > tLZTeamData[M28Map.refiRadarCoverage] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20) then
            --Require T3 mexes before building T3 radar
            if tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 or (tLZTeamData[M28Map.subrefMexCountByTech][3] == 1 and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][1] == 0) then
                iBPWanted = 30
                if not(bHaveLowMass) then iBPWanted = 100 end
                if bDebugMessages == true then LOG(sFunctionRef..': Will build T3 radar, iBPWanted='..iBPWanted..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]) end
                HaveActionToAssign(refActionBuildT3Radar, 3, iBPWanted)
            end
        end
    end

    --Air fac and second air fac ahead of land experimental if enemy has significant air to ground threat, for larger maps
    iCurPriority = iCurPriority + 1
    if M28Map.iMapSize > 512 and (M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeAir] or 0) < 8 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 + (M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeAir] or 0) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 and M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone) then
        if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) then
            iBPWanted = 40
            if not(bHaveLowMass) then iBPWanted = 80 end
            HaveActionToAssign(refActionBuildAirFactory, 3, iBPWanted)
            if not(bHaveLowMass) and not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 10000 and not(M28Conditions.TeamHasAirControl(iTeam)) then
                HaveActionToAssign(refActionBuildSecondAirFactory, 3, iBPWanted)
            end
        end
    end

    --Land experimental if lots of mass or have built lots of T3 units
    iCurPriority = iCurPriority + 1
    local bExperimentalsBuiltInThisLZ, iExperimentalsBuiltInOtherLZ = GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateau, iLandZone)
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; iCurPriority='..iCurPriority..'; bExperimentalsBuiltInThisLZ='..tostring(bExperimentalsBuiltInThisLZ)..'; iExperimentalsBuiltInOtherLZ='..iExperimentalsBuiltInOtherLZ..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; M28Team.tTeamData[iTeam][M28Team.refbBuiltLotsOfT3Combat]='..tostring(M28Team.tTeamData[iTeam][M28Team.refbBuiltLotsOfT3Combat] or false)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and (
            (bExperimentalsBuiltInThisLZ or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] > 7) and
                    ((M28Team.tTeamData[iTeam][M28Team.refbBuiltLotsOfT3Combat] and (bExperimentalsBuiltInThisLZ or iExperimentalsBuiltInOtherLZ == 0)) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 8000 + 8000 * iExperimentalsBuiltInOtherLZ or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] > 16 + iExperimentalsBuiltInOtherLZ * 30))
                    or GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] or -1000) <= 60) then

        iBPWanted = 100 --No point trying to build an experimental with less build power
        if not(bHaveLowPower) then
            iBPWanted = iBPWanted * 1.5
            --BP wanted: e.g. monkeylord will cost 0.07 mass per tick for 1 BP; so if want to spend approx 50% of mass on the experimental, then for every 1 mass per tick generated, would want roughly 7 build power
            if not(bHaveLowMass) then iBPWanted = math.max(iBPWanted * 1.5, (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] - iExperimentalsBuiltInOtherLZ * 25 - 10) * 5) end
        end

        HaveActionToAssign(refActionBuildExperimental, 3, iBPWanted)

        --Also want more BP than what we have regardless if have lots of mass stored and experimental is being built
        if bDebugMessages == true then LOG(sFunctionRef..': Have just had action to build experimental with iBPWanted='..iBPWanted..'; If lots of mass stored will increase BP assigned to experimental, bExperimentalsBuiltInThisLZ='..tostring(bExperimentalsBuiltInThisLZ)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; bHaveLowPower='..tostring(bHaveLowPower)) end
        if bExperimentalsBuiltInThisLZ and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.6 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 20000) and not(bHaveLowPower) then
            --Want 60 extra BP vs what we have already assigned
            iBPWanted = 60
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.8 or not(bWantMorePower) then iBPWanted = 120 end
            HaveActionToAssign(refActionBuildExperimental, 3, iBPWanted, nil, false, true)
        end

    end

    --Build multiple land factories if have lots of mass stored (lower priority)
    iCurPriority = iCurPriority + 1
    if not(bHaveLowMass) and not(bHaveLowPower) and bWantMoreFactories and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 then
        if bDebugMessages == true then LOG(sFunctionRef..': Have lots of mass so want to build more than one factory at once (lower priority)') end

        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.7 then iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 7
        else iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 5
        end
        if not(M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)) then --factors in things like if we are on the same plateau
            HaveActionToAssign(refActionBuildSecondLandFactory, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech], tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 5)
        end
    end



    --Lower priority land zones wanting engineers:
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS) Other non adjacent LZ on this plateau that wants engineers (low priority) - prioritise those nearest this zone
    iCurPriority = iCurPriority + 1
    iBPAlreadyTraveling = 0
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then
        if M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
            for iEngi, oEngi in toAssignedEngineers do
                if oEngi[refiAssignedAction] == refActionMoveToLandZone then
                    iBPAlreadyTraveling = iBPAlreadyTraveling + oEngi:GetBlueprint().Economy.BuildRate
                end
            end
        end

        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
            for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                if iBPAlreadyTraveling > 0 or not(tLZWantingBPConsidered[iAdjLZ]) then
                    tLZWantingBPConsidered[iAdjLZ] = true
                    local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, iAdjLZ, iPathingRef, iHighestTechEngiAvailable, false)
                    if tiBPByTechWanted then
                        --Is it either a minor zone, or a core zone that either wants lots of BP or doesnt have any engineers traveling to it?
                        for iTech = 1, iHighestTechEngiAvailable, 1 do
                            if tiBPByTechWanted[iTech] > 0 then
                                iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                iBPWanted = iBPAlreadyTraveling + 5
                                if bDebugMessages == true then LOG(sFunctionRef..': Will try and assign an engineer to go to iAdjLZ='..iAdjLZ..'; BP wanted='..iBPWanted..'; iTech='..iTech..'; iPrevEngisAvailable='..iPrevEngisAvailable) end
                                HaveActionToAssign(refActionMoveToLandZone, iTech, iBPWanted, iAdjLZ, true)
                                if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                    iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                    iBPAlreadyTraveling = iBPAlreadyTraveling + tiBPByTech[iTech]
                                end

                                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable after this='..iHighestTechEngiAvailable) end
                                if iHighestTechEngiAvailable == 0 then break end
                            end
                        end
                    end
                end
                if iHighestTechEngiAvailable == 0 then break end
            end
        end
    end

    --Islands wanting engineers (provided there are no enemy naval units in an adjacent naval zone)
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Core LZ considering engis for islands, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Time='..GetGameTimeSeconds()) end
    if iHighestTechEngiAvailable > 0 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of pathing to other islands empty='..tostring(tLZData[M28Map.subrefLZPathingToOtherIslands])) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
            local iDistanceThreshold = math.max(125, M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) * 0.6)
            if bDebugMessages == true then LOG(sFunctionRef..': iDistanceThreshold='..iDistanceThreshold) end
            local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
            for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..'; Travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; tPathingData[M28Map.subrefIslandClosestLZRef]='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; Are there enemies in this or adjacnet LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                if tPathingData[M28Map.subrefIslandTravelDist] > iDistanceThreshold then break
                else
                    --Are there enemies in the target LZ?
                    if tPathingData[M28Map.subrefIslandClosestLZRef] then
                        local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]]
                        if bDebugMessages == true then LOG(sFunctionRef..': Are there enemies in the land zone or adjacent='..tostring(tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Is the midpoint in the playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]))) end
                        if not(tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                            --Can we reach the island?
                            if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]) then

                                local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, tPathingData[M28Map.subrefIslandClosestLZRef], iEntry, iHighestTechEngiAvailable, false, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                                if tiBPByTechWanted then
                                    --Is it either a minor zone, or a core zone that either wants lots of BP or doesnt have any engineers traveling to it?
                                    for iTech = 1, iHighestTechEngiAvailable, 1 do
                                        if tiBPByTechWanted[iTech] > 0 then
                                            iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                            iBPWanted = iBPAlreadyTraveling + 5
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will try and assign an engineer to go to tPathingData[M28Map.subrefIslandClosestLZRef]='..tPathingData[M28Map.subrefIslandClosestLZRef]..'; BP wanted='..iBPWanted..'; iTech='..iTech..'; iPrevEngisAvailable='..iPrevEngisAvailable) end
                                            HaveActionToAssign(refActionMoveToLandZone, iTech, iBPWanted, tPathingData[M28Map.subrefIslandClosestLZRef], true)
                                            if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                                iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                                iBPAlreadyTraveling = iBPAlreadyTraveling + tiBPByTech[iTech]
                                            end

                                            iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                            if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable after this='..iHighestTechEngiAvailable) end
                                            if iHighestTechEngiAvailable == 0 then break end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    --Quantum gateway for high AiX modifier and campaign, once we are at T3 mexes for the LZ
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to build quantum gateway, MexCountByTech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; bHaveLowPower='..tostring(bHaveLowPower)..'; mass storage locations empty?='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMassStorageLocationsAvailable]))..'; mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]) end
    if not(bHaveLowPower) and (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 or (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 11) or (M28Map.bIsCampaignMap and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 13))
            and (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 6 or (tLZTeamData[M28Map.subrefMexCountByTech][2] == 0 and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0))
            and (M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMassStorageLocationsAvailable]) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 or (M28Map.bIsCampaignMap and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 14))
            and (M28Map.bIsCampaignMap or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 0 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 30) then
        --Are we in campaign (where ecoing more important) or AiX 1.2+?
        local iHighestCheatModifier = 1
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                if oBrain.CheatEnabled then
                    iHighestCheatModifier = tonumber(ScenarioInfo.Options.CheatMult or 1.5)
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bIsCampaignMap='..tostring(M28Map.bIsCampaignMap)..'; iHighestCheatModifier='..iHighestCheatModifier) end
        if M28Map.bIsCampaignMap or iHighestCheatModifier >= 1.2 or (M28Map.iMapSize >= 1024 and not(bHaveLowMass) and tLZTeamData[M28Map.subrefMexCountByTech][3] >= tLZData[M28Map.subrefLZMexCount]) then
            iBPWanted = 20
            if not(bHaveLowMass) then iBPWanted = 80 end
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build a quantum gateway') end
            --Do we already have a quantum gateway in this land zone?
            local iCurQuantumGateways = 0
            local tQuantumGateways = EntityCategoryFilterDown(M28UnitInfo.refCategoryQuantumGateway, tLZTeamData[M28Map.subrefLZTAlliedUnits])
            if M28Utilities.IsTableEmpty( tQuantumGateways) == false then
                for iUnit, oUnit in tQuantumGateways do
                    if oUnit:GetFractionComplete() >= 1 then
                        iCurQuantumGateways = iCurQuantumGateways + 1
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iCurQuantumGateways='..iCurQuantumGateways) end
            --Get 1 quantumn gateway (or 2+ if we have 1.5+ AiX modifier)
            if iCurQuantumGateways == 0 or (iCurQuantumGateways < 3 and M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultipler] >= 1.4 and iCurQuantumGateways < 0.4 + M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultipler]) then
                HaveActionToAssign(refActionBuildQuantumGateway, 3, iBPWanted)
                if bDebugMessages == true then LOG(sFunctionRef..': Will try and assign '..iBPWanted..' to building a quantum gateway') end
            end
        end
    end

    --Low mass - mass fabs (number depends on AiX modifier)


    --Second experimental builder (for very high mass scenarios)
    iCurPriority = iCurPriority + 1
    if not(bHaveLowMass) and not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 8 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 5000 then
        --Want 30 extra BP vs what we have already assigned to both normal and second experimental builders
        iBPWanted = 30
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.8 or not(bWantMorePower) then iBPWanted = iBPWanted * 2 end
        --HaveActionToAssign(iActionToAssign,           iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting)
        HaveActionToAssign(refActionBuildExperimental,   3,                       iBPWanted,      nil,                false, true)
        if bDebugMessages == true then LOG(sFunctionRef..': Will flag that we want a second experimental to be built, additional iBPWanted='..iBPWanted) end
        HaveActionToAssign(refActionBuildSecondExperimental, 3,                     iBPWanted,      nil,                false,                      true)
    end

    --Assist upgrade even if resources aren't great
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] >= 0.95 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 20 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > 0 then
        HaveActionToAssign(refActionAssistUpgrade, 1, 10, false, false)
    end


    --Units to capture
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]) == false then
        --Refresh the list
        local iCaptureCount = table.getn(tLZData[M28Map.subreftoUnitsToCapture])
        for iCurCount = iCaptureCount, 1, -1 do
            if not(M28UnitInfo.IsUnitValid(tLZData[M28Map.subreftoUnitsToCapture][iCurCount])) then
                table.remove(tLZData[M28Map.subreftoUnitsToCapture], iCurCount)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Have units to capture for zone '..iLandZone..' after freshing them is table empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]))) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]) == false then
            local oUnitToCapture = M28Utilities.GetNearestUnit(tLZData[M28Map.subreftoUnitsToCapture], tLZData[M28Map.subrefMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': Unit to cpature='..oUnitToCapture.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToCapture)) end
            HaveActionToAssign(refActionCaptureUnit, 1, 25, oUnitToCapture)
        end
    end

    --Units to repair
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToRepair]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Have units to repair for zone '..iLandZone..' is table empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToRepair]))) end

        if M28Conditions.IsTableOfUnitsStillValid(tLZData[M28Map.subreftoUnitsToRepair], true) then
            local oUnitToTarget = M28Utilities.GetNearestUnit(tLZData[M28Map.subreftoUnitsToRepair], tLZData[M28Map.subrefMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': Unit to repair='..oUnitToTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToTarget)) end
            HaveActionToAssign(refActionRepairUnit, 1, 5, oUnitToTarget)
        end

    end

    --Game ender builder (in addition to normal experimental builders) - intended for extreme scenarios where overflowing lots of mass, or where are in campaign, at unit cap and have decent eco
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to build gameender, bHaveLowPower='..tostring(bHaveLowPower)..'; M28Team.tTeamData[iTeam][M28Team.refiLowestUnitCapAdjustmentLevel]='..(M28Team.tTeamData[iTeam][M28Team.refiLowestUnitCapAdjustmentLevel] or 'nil')..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Gameender count='..M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount]) end
    if not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= 3 and (
            (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 95 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.55 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 20 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 10000)
                    or (M28Map.bIsCampaignMap and ((M28Team.tTeamData[iTeam][M28Team.refiLowestUnitCapAdjustmentLevel] or 100) <= 2 or (not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 60 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 30 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) then
        local bAlreadyHaveGameEnderUnderConstruction = false
        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        if bDebugMessages == true then LOG(sFunctionRef..': About to check for nearby gameenders for team '..(iTeam or 'nil')..'; First active M28brain aibrain='..(aiBrain.Nickanme or 'nil')..'; LZ midpoint='..repru(tLZData[M28Map.subrefMidpoint])) end
        local tNearbyGameEnders = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryGameEnder, tLZData[M28Map.subrefMidpoint], 1000, 'Ally')
        local iCompletedGameEnders = 0
        if M28Utilities.IsTableEmpty(tNearbyGameEnders) == false then
            for iExperimental, oExperimental in tNearbyGameEnders do
                if oExperimental:GetFractionComplete() < 1 then
                    --Is this gameender in a different zone?
                    local iGameEnderPlateau, iGameEnderZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oExperimental:GetPosition())
                    if not(iGameEnderZone == iLandZone and iGameEnderPlateau == iPlateau) then
                        bAlreadyHaveGameEnderUnderConstruction = true
                    end
                else
                    iCompletedGameEnders = iCompletedGameEnders + 1
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bAlreadyHaveGameEnderUnderConstruction='..tostring(bAlreadyHaveGameEnderUnderConstruction or false)) end
        if not(bAlreadyHaveGameEnderUnderConstruction) then
            iBPWanted = 45
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 125 then iBPWanted = 90 end
            if iCompletedGameEnders < 1 then
                HaveActionToAssign(refActionBuildGameEnder, 3,                     iBPWanted,      nil,                false,                      true)
                if bDebugMessages == true then LOG(sFunctionRef..': iBPWanted for gameender='..iBPWanted) end
            else
                --Consider getting land experimental instead unless we have large number already
                local iCompletedLandExperimentals = 0
                local tNearbyLandExperimentals = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandExperimental, tLZData[M28Map.subrefMidpoint], 1000, 'Ally')
                if M28Utilities.IsTableEmpty(tNearbyLandExperimentals) == false then
                    for iUnit, oUnit in tNearbyLandExperimentals do
                        if oUnit:GetFractionComplete() >= 1 then
                            iCompletedLandExperimentals = iCompletedLandExperimentals + 1
                        end
                    end
                end
                local iLandExpeimentalsWantedPerGameEnder = 1
                if NavUtils.GetLabel(M28Map.refPathingTypeHover, tLZTeamData[M28Map.reftClosestEnemyBase]) == NavUtils.GetLabel(M28Map.refPathingTypeHover, tLZData[M28Map.subrefMidpoint]) then iLandExpeimentalsWantedPerGameEnder = 5 end
                if bDebugMessages == true then LOG(sFunctionRef..': Deciding if want gameender or land experimental, iCompletedLandExperimentals='..iCompletedLandExperimentals..'; iCompletedGameEnders='..iCompletedGameEnders..'; iLandExpeimentalsWantedPerGameEnder='..iLandExpeimentalsWantedPerGameEnder) end
                if iCompletedLandExperimentals < iCompletedGameEnders * iLandExpeimentalsWantedPerGameEnder then
                    HaveActionToAssign(refActionBuildLandExperimental, 3,                     iBPWanted,      nil,                false,                      true)
                else
                    HaveActionToAssign(refActionBuildGameEnder, 3,                     iBPWanted,      nil,                false,                      true)
                end
            end
        end
    end

    --Low priority island support - will consider further away distances tahn before, up to a distance of 400, and only if the island wants T1 engineer BP

    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Low priority core zone island engi support logic, iHighestTechEngiAvailable='..iHighestTechEngiAvailable) end
    if iHighestTechEngiAvailable > 0 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if iHighestTechEngiAvailable > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': is pathing to other islands empty='..tostring( M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]))) end
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; tLZTeamData[M28Map.reftClosestEnemyBase]='..repru(tLZTeamData[M28Map.reftClosestEnemyBase])..'; tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint])) end
                local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)

                for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering island '..tPathingData[M28Map.subrefIslandNumber]..' for lower priority travel; travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; Closest LZ ref='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; are enemies in this or adjacent LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                    if tPathingData[M28Map.subrefIslandTravelDist] > 400 then break
                    else
                        --Are there enemies in the target LZ?

                        if tPathingData[M28Map.subrefIslandClosestLZRef] then
                            local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]]
                            if not(tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbDangerousEnemiesInThisLZ]) then
                                --Can we reach the island?
                                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]) then
                                    --Are there enemies in an adjacent LZ
                                    local iAdjacentEnemyThreat = 0
                                    if tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                                        if M28Utilities.IsTableEmpty(tAdjLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                            for _, iAdjToAdjLZ in tAdjLZData[M28Map.subrefLZAdjacentLandZones] do
                                                local tAdjToAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjToAdjLZ]
                                                iAdjacentEnemyThreat = iAdjacentEnemyThreat + tAdjToAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal]
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': iAdjacentEnemyThreat='..iAdjacentEnemyThreat) end
                                    if iAdjacentEnemyThreat < 10 then

                                        local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, tPathingData[M28Map.subrefIslandClosestLZRef], iEntry, iHighestTechEngiAvailable, false, true)
                                        if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                                        if (tiBPByTechWanted[1] or 0) > 0 then
                                            HaveActionToAssign(refActionMoveToLandZone, 1, 5, tPathingData[M28Map.subrefIslandClosestLZRef], true)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Finished trying to give order for engi to move to the island LZ '..tPathingData[M28Map.subrefIslandClosestLZRef]) end
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    --Build more air factories if close to overflowing mass and dont have low power (e.g. to help in campaign and unit restriction scenarios where land factories arent an option)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether want a low priority air factory if overflowing mass, bHaveLowMass='..tostring(bHaveLowMass)..'; bHaveLowPower='..tostring(bHaveLowPower)..'; Lowest mass% stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; Land facotyr lifetime count='..M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandFactory)..'; Want more factories='..tostring(M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone))..'; want air instead of land fac='..tostring(M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData))) end
    if not(bHaveLowMass) and not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.6 and M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone) then
        if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) or ((M28Map.bIsCampaignMap or M28Overseer.bUnitRestrictionsArePresent) and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandFactory) <= 1) then
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build another air factory as low priority action due to mass overflow') end
            iBPWanted = 3 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
            HaveActionToAssign(refActionBuildAirFactory, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted, nil)
        end
    end

    --Build second air factories if really close to overflowing mass and dont have low power (e.g. to help in campaign and unit restriction scenarios where land factories arent an option)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether want a low priority air factory if overflowing mass, bHaveLowMass='..tostring(bHaveLowMass)..'; bHaveLowPower='..tostring(bHaveLowPower)..'; Lowest mass% stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; Land facotyr lifetime count='..M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandFactory)..'; Want more factories='..tostring(M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone))..'; want air instead of land fac='..tostring(M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData))) end
    if not(bHaveLowMass) and not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.8 and M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 1 then
        if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) or ((M28Map.bIsCampaignMap or M28Overseer.bUnitRestrictionsArePresent) and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandFactory) <= 1) then
            iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]]
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build another air factory as low priority action due to mass overflow, iBPWanted='..iBPWanted..'; Highest air fac tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]) end
            HaveActionToAssign(refActionBuildSecondAirFactory, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted, nil)
        end
    end

    --Check for any part constructed buildings in this zone if we have available engineers
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then
        local tBuildings = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        if M28Utilities.IsTableEmpty(tBuildings) == false then
            for iUnit, oUnit in tBuildings do
                --Dont assist a part built shield as it may be for special shielding logic
                if oUnit:GetFractionComplete() < 1 and not(EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oUnit.UnitId)) then
                    HaveActionToAssign(refActionRepairUnit, 1, 5, oUnit)
                    break
                end
            end
        end
    end


    --SPARE ENGINEER ACTIONS----->
    UpdateSpareEngineerNumber(tLZTeamData, toAvailableEngineersByTech)

    --Spare engi - assist any upgrading unit
    iCurPriority = iCurPriority + 1
    if iHighestTechEngiAvailable > 0 then
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then
            HaveActionToAssign(refActionAssistUpgrade, 1, 1000, nil, true)
            iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        end
    end

    --Spare engi - reclaim area
    iCurPriority = iCurPriority + 1 --do this after each action
    if iHighestTechEngiAvailable > 0 then
        if tLZData[M28Map.subrefTotalMassReclaim] >= 20 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.6 then
            local bWantEnergy = false
            HaveActionToAssign(refActionReclaimArea, 1, 500, bWantEnergy, true)
            iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        end
    end

    --Spare engi - assist under construction building if we dont have low mass or energy
    iCurPriority = iCurPriority + 1
    if iHighestTechEngiAvailable > 0 and not(bHaveLowMass) and not(bHaveLowPower) then
        --Dont assist part complete shields due to risk we are using for active shielding
        local oBuildingToAssist = GetPartCompleteBuildingInZone(iTeam, iPlateau, iLandZone, M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryExperimentalLevel - M28UnitInfo.refCategoryFixedShield, false)
        if oBuildingToAssist then
            HaveActionToAssign(refActionRepairUnit, 1, 100000, oBuildingToAssist, true)
        end
    end

    --Localised mex upgrade logic (this is in addition to centralised logic) - intended for games on larger maps - but only if no enemies in adjacent zone
    if bDebugMessages == true then LOG(sFunctionRef..': Considering engineer based mex upgrade logic for zone '..iLandZone..', bHaveLowPower='..tostring(bHaveLowPower)..'; mex count by tech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; Map size='..M28Map.iMapSize..'; Enemies in adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Is Active upgrades in this LZ table empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]))..'; Team gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Is table of mexes on team empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]))..'; Team factory tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end
    if (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 100 or not(bHaveLowPower)) and iActiveMexUpgrades == 0 and (tLZTeamData[M28Map.subrefMexCountByTech][1] + tLZTeamData[M28Map.subrefMexCountByTech][2] > 0) and M28Map.iMapSize >= 256 and (not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) or (not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 5) and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 8) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 or not(bHaveLowMass) or tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][1] > 0)) then
        --Do we have T3 factory (or T2 if we have t1 mexes) and either we aren't mass stalling, or we have no mex upgrades at a team level?
        if bDebugMessages == true then LOG(sFunctionRef..': Passed initial checks, checking further') end
        if (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 or (tLZTeamData[M28Map.subrefMexCountByTech][1] > 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2)) and (not(bHaveLowMass) or not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) or tLZTeamData[M28Map.subrefMexCountByTech][1] > 0 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20) then
            --Find a mex to upgrade - first try T1 mexes
            local tPotentialMexes
            if tLZTeamData[M28Map.subrefMexCountByTech][1] then
                tPotentialMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryT1Mex, tLZTeamData[M28Map.subrefLZTAlliedUnits])
            else
                tPotentialMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryT2Mex + M28UnitInfo.refCategoryT1Mex, tLZTeamData[M28Map.subrefLZTAlliedUnits])
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of potential mexes empty='..tostring(M28Utilities.IsTableEmpty(tPotentialMexes))) end
            if M28Utilities.IsTableEmpty(tPotentialMexes) == false then
                for iMex, oMex in tPotentialMexes do
                    if oMex:GetFractionComplete() >= 1 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will upgrade mex '..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)) end
                        M28Economy.UpgradeUnit(oMex, true)
                        break
                    end
                end
            end

        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tLZTeamData[M28Map.subrefTBuildPowerByTechWanted] before general adjustments='..repru(tLZTeamData[M28Map.subrefTBuildPowerByTechWanted])..'; tLZTeamData[M28Map.subrefSpareBPByTech]='..repru(tLZTeamData[M28Map.subrefSpareBPByTech])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end
function ConsiderMinorLandZoneEngineerAssignment(tLZTeamData, iTeam, iPlateau, iLandZone, tEngineers)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderMinorLandZoneEngineerAssignment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --if bDebugMessages == true then M28Map.DrawSpecificLandZone(iPlateau, iLandZone, 1) end
    local iBPWanted
    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
    local bWantMorePower = M28Conditions.WantMorePower(iTeam)
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]

    local iNearbyEnemyAirToGroundThreat = tLZTeamData[M28Map.refiEnemyAirToGroundThreat]
    --For now only do land zone not water zone given water zone includes torp bombers
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
            iNearbyEnemyAirToGroundThreat = iNearbyEnemyAirToGroundThreat + tLZTeamData[M28Map.refiEnemyAirToGroundThreat]
        end
    end


    local toAvailableEngineersByTech, toAssignedEngineers = FilterToAvailableEngineersByTech(tEngineers, false, tLZData, tLZTeamData, iTeam, iPlateau, iLandZone)
    tLZTeamData[M28Map.subrefTBuildPowerByTechWanted] = {[1]=0,[2]=0,[3]=0}
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Non core LZ - Have just reset BPByTech to 0 for Plateau'..iPlateau..'; LZ='..iLandZone..'; repru='..repru(tLZTeamData[M28Map.subrefTBuildPowerByTechWanted])..'; subrefLZCoreExpansion='..tostring(tLZTeamData[M28Map.subrefLZCoreExpansion] or false)..'; subrefbCoreBaseOverride='..tostring(tLZTeamData[M28Map.subrefbCoreBaseOverride] or false)) end
    --local iCurCondition = 0
    local iCurPriority = 0

    function HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist)
        --Done as subfunction for convenience so can just note the key values for the action in question and add on the others that wont change
        ConsiderActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iCurPriority, tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, toAvailableEngineersByTech, toAssignedEngineers, false, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist)
    end


    --Land fac if this is an island with no core LZs - also set this as the primary if no such LZ
    iCurPriority = iCurPriority + 1
    local iHighestTechEngiAvailable
    local bExpansionOnSameIslandAsBase = false
    if tLZTeamData[M28Map.subrefLZCoreExpansion] == nil or (tLZTeamData[M28Map.subrefLZExpansionOverride] and not(tLZTeamData[M28Map.subrefLZCoreExpansion])) then
        bExpansionOnSameIslandAsBase = false
        if tLZData[M28Map.subrefLZIslandRef] == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestFriendlyBase]) then bExpansionOnSameIslandAsBase = true end
        if tLZData[M28Map.subrefLZMexCount] > 0 and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tLZData[M28Map.subrefLZIslandRef]] >= 3 and not(bExpansionOnSameIslandAsBase) then
            iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
            if iHighestTechEngiAvailable > 0 then
                local bHaveCoreLZ = false
                for iEntry, iIslandLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][tLZData[M28Map.subrefLZIslandRef]] do
                    if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iIslandLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] or M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iIslandLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZCoreExpansion] then
                        bHaveCoreLZ = true
                        break
                    end
                end
                if not(bHaveCoreLZ) or tLZTeamData[M28Map.subrefLZExpansionOverride] then
                    --Build a land factory
                    tLZTeamData[M28Map.subrefLZCoreExpansion] = true
                else
                    tLZTeamData[M28Map.subrefLZCoreExpansion] = false
                end
            end
        else
            if tLZTeamData[M28Map.subrefLZExpansionOverride] then
                tLZTeamData[M28Map.subrefLZCoreExpansion] = true
            else
                tLZTeamData[M28Map.subrefLZCoreExpansion] = false
            end
        end
    end
    local iFactoriesWanted = 0
    local iExistingLandFactory = 0
    if tLZTeamData[M28Map.subrefLZCoreExpansion] then
        local tExistingLandFactory = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        local bExistingFactoryIsComplete = false
        if M28Utilities.IsTableEmpty(tExistingLandFactory) == false then
            iExistingLandFactory = table.getn(tExistingLandFactory)
            for iUnit, oUnit in tExistingLandFactory do
                if oUnit:GetFractionComplete() == 1 then
                    bExistingFactoryIsComplete = true
                    if M28UnitInfo.GetUnitTechLevel(oUnit) >= 2 then
                        iExistingLandFactory = iExistingLandFactory + 1
                    end
                end
            end
        end
        iFactoriesWanted = math.min(4, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tLZData[M28Map.subrefLZIslandRef]] - 2)
        if bExpansionOnSameIslandAsBase then iFactoriesWanted = math.max(1, math.min(4, iFactoriesWanted, tLZData[M28Map.subrefLZMexCount] - 2)) end
        if not(bWantMorePower) and not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 then
            iFactoriesWanted = iFactoriesWanted + 1
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.8 then iFactoriesWanted = iFactoriesWanted * 2 end
        end
        if iFactoriesWanted > 2 then
            --Does enemy have any units/threats on this island within a certain range?
            local bEnemyHasDangerousUnitsOnIsland = tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]
            if not(bEnemyHasDangerousUnitsOnIsland) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                local iAdjLZ
                for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                    iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; Travel dist='..tPathingDetails[M28Map.subrefLZTravelDist]..'; Does it want DF support='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport])) end
                    if tPathingDetails[M28Map.subrefLZTravelDist] < 275 then
                        local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]='..tostring(tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])) end
                        if tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] then
                            bEnemyHasDangerousUnitsOnIsland = true
                            break
                        end
                    end
                end
            end
            if not(bEnemyHasDangerousUnitsOnIsland) then
                if iFactoriesWanted > 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.8 then
                    iFactoriesWanted = 3
                else
                    iFactoriesWanted = 2
                end
            end
        end
        if bHaveLowMass then iFactoriesWanted = math.max(1, math.floor(iFactoriesWanted * 0.5)) end
        if bDebugMessages == true then LOG(sFunctionRef..': iFactoriesWanted after adjusting for enemy units='..iFactoriesWanted..'; iExistingLandFactory='..iExistingLandFactory) end
        if iExistingLandFactory < iFactoriesWanted then
            local bWantAirNotLand = M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)
            local iFactoryAction
            if bWantAirNotLand then iFactoryAction = refActionBuildAirFactory
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Want to build land factory not air factory4') end
                iFactoryAction = refActionBuildLandFactory
            end
            iBPWanted = 10
            if bExistingFactoryIsComplete then iBPWanted = 5 end
            local iMaxTechLevelIfAny
            if iExistingLandFactory == 0 then iMaxTechLevelIfAny = 1 end
            HaveActionToAssign(iFactoryAction, 1, iBPWanted, iMaxTechLevelIfAny)
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': About to consider what actions we want to give engineers for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; Is table of unbuilt mex locations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]))..'; Is table of part complete mexes empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]))) end
    --Unclaimed mex high priority
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': We have unbuilt mex locations for this land zone, locations='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations])) end
        HaveActionToAssign(refActionBuildMex, 1, 5)
    end

    --AA if enemy has air to ground threat
    if bDebugMessages == true then LOG(sFunctionRef..': High priority AA builder: iNearbyEnemyAirToGroundThreat='..iNearbyEnemyAirToGroundThreat..'; enemy air to ground threat='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Enemy AirAA threat='..tLZTeamData[M28Map.refiEnemyAirAAThreat]) end
    iCurPriority = iCurPriority + 1
    if iNearbyEnemyAirToGroundThreat > 0 or tLZTeamData[M28Map.refiEnemyAirAAThreat] >= 500 then
        --Do we already have fixed AA in this LZ?
        local iAACategory = M28UnitInfo.refCategoryStructureAA
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then iAACategory = iAACategory * categories.TECH3 end
        local tExistingFixedAA = EntityCategoryFilterDown(iAACategory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        local bHaveFixedAA = false
        if M28Utilities.IsTableEmpty(tExistingFixedAA) == false then
            for iUnit, oUnit in tExistingFixedAA do
                if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have fixed AA, considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                if oUnit:GetFractionComplete() then bHaveFixedAA = true break end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveFixedAA='..tostring(bHaveFixedAA)..'; Enemy air to ground threat='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Ally groundAA threat='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]) end
        if not(bHaveFixedAA) or iNearbyEnemyAirToGroundThreat > tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] then
            iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
            if iNearbyEnemyAirToGroundThreat > 0 then iBPWanted = iBPWanted * 2 end
            if not(M28Conditions.HaveLowPower(iTeam)) then
                if not(bHaveLowMass) then iBPWanted = iBPWanted * 4
                else iBPWanted = iBPWanted * 2
                end
            end
            local bIncreaseBPWanted = false
            local iT2PlusMex = 0
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefMexCountByTech]) == false then
                for iTech, iCount in tLZTeamData[M28Map.subrefMexCountByTech] do
                    if iTech > 1 then iT2PlusMex = iT2PlusMex + iCount end
                end
            end
            if iT2PlusMex > 0 then  bIncreaseBPWanted = true end
            --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted,                                          iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting)
            HaveActionToAssign(refActionBuildAA, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted     , nil,              true)
            if bDebugMessages == true then LOG(sFunctionRef..': Minor Zone AA builder if no fixed AA: iBPWanted='..iBPWanted..'; iNearbyEnemyAirToGroundThreat='..iNearbyEnemyAirToGroundThreat..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; subrefiAlliedGroundAAThreat='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]..'; iT2PlusMex='..iT2PlusMex..'; bIncreaseBPWanted='..tostring(bIncreaseBPWanted)) end
        end
    end

    --Protect game-ender or similar high avlue target (very high priority on assumption if we have built such a unit we shouldnt have to worry about lack of resources for this
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Want to assign units to active shield protection, will list out each unit for this zone that wants active protection')
            for iUnit, oUnit in tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
                LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Mass cost='..oUnit:GetBlueprint().Economy.BuildCostMass)
            end
        end
        if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] then
            iBPWanted = 500
        else
            iBPWanted = 100
        end


        if bDebugMessages == true then LOG(sFunctionRef..': Special shield defence action iBPWanted='..iBPWanted) end

        --Only use T3 engineers (even if we already have t3 engineers assigned) as want to make sure we can quickly get good concentrated build power
        --function HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist)
        HaveActionToAssign(refActionSpecialShieldDefence, 3, iBPWanted,         nil,                nil,                    nil,                        nil,                            true)
    end

    --Assign more BP to factories
    iCurPriority = iCurPriority + 1
    if iExistingLandFactory < iFactoriesWanted then
        iBPWanted = 10
        if not(bHaveLowMass) then iBPWanted = math.min(30, 3 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]) end
        local bWantAirNotLand = M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)
        local iFactoryAction
        if bWantAirNotLand then iFactoryAction = refActionBuildAirFactory
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Want to build land factory not air factory5') end
            iFactoryAction = refActionBuildLandFactory
        end
        HaveActionToAssign(iFactoryAction, 1, iBPWanted, nil)
    end

    --Unclaimed mex in the zone
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': We have unbuilt mex locations for this land zone, locations='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations])) end
        HaveActionToAssign(refActionBuildMex, 1, math.max(5, table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) * 2.5))
    elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
        --Do we have no engineers assigned to building a mex?
        local bHaveEngisBuilding = false
        if M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
            for iEngi, oEngi in toAssignedEngineers do
                if oEngi[refiAssignedAction] == refActionBuildMex then
                    bHaveEngisBuilding = true
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of assigned engineers empty='..tostring(M28Utilities.IsTableEmpty(toAssignedEngineers))..'; bHaveEngisBuilding='..tostring(bHaveEngisBuilding)) end
        if not(bHaveEngisBuilding) then
            --Refresh list of mexes
            RefreshPartBuiltMexList(tLZTeamData)
            if bDebugMessages == true then LOG(sFunctionRef..': Refreshed part built mex list, is table of part built mexes empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]))) end
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
                HaveActionToAssign(refActionCompletePartBuiltMex, 1, 5)
                if bDebugMessages == true then LOG(sFunctionRef..': Will get engi to complete part built mex') end
            end
        end
    end

    --Zones wanting specific faction engineers (e.g. for shielding game ender)
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftFactoriesWantedForEngineers]) == false then
        local iZoneWantingEngineersOfFaction, iFactionWanted = GetZoneAndFactionForPriorityEngineerTravel(tLZTeamData, iTeam, iLandZone, iPlateau)
        if iZoneWantingEngineersOfFaction and iFactionWanted then
            HaveActionToAssign(refActionMoveToLandZone, 3, 90, iZoneWantingEngineersOfFaction, true, false, iFactionWanted)
        end
    end

    --High priority reclaim if are low on mass or energy
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then
        LOG(sFunctionRef..': Considering if we want high priority reclaim, bHaveLowMass='..tostring(bHaveLowMass)..'; tLZData[M28Map.subrefTotalMassReclaim]='..(tLZData[M28Map.subrefTotalMassReclaim] or 'nil'))
        --M28Land.DrawReclaimSegmentsInLandZone(iPlateau, iLandZone)
    end
    if bHaveLowMass and tLZData[M28Map.subrefTotalMassReclaim] >= 50 then
        local iReclaimFactor = 60
        if GetGameTimeSeconds() <= 540 then iReclaimFactor = 90 end
        iBPWanted = math.min(40, math.max(5, tLZData[M28Map.subrefTotalMassReclaim] / iReclaimFactor))
        if iBPWanted > 15 and GetGameTimeSeconds() <= 540 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 then
            iBPWanted = math.min(iBPWanted, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * 15)
        end
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then iBPWanted = math.max(5, iBPWanted * 0.6) end
        if bDebugMessages == true then LOG(sFunctionRef..': Higher priority reclaim, Total mass in Plateau '..iPlateau..' LZ '..iLandZone..'='..tLZData[M28Map.subrefTotalMassReclaim]) end
        HaveActionToAssign(refActionReclaimArea, 1, iBPWanted, false)
        if bDebugMessages == true then LOG(sFunctionRef..': Have just tried assigning action to reclaim area') end
    elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= 0.7 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 80 and tLZData[M28Map.subrefLZTotalEnergyReclaim] >= 100 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < 2 then
        HaveActionToAssign(refActionReclaimArea, 1, 5, true)
    end


    --TMD - TML (including mobile ACUs with TML upgrade)
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]) == false then
        iBPWanted = 30
        if not(bHaveLowMass) then iBPWanted = 50 end
        if bDebugMessages == true then LOG(sFunctionRef..': We have untis wanting TMD in LZ '..iLandZone..'; will list out each unit')
            for iUnit, oUnit in tLZTeamData[M28Map.reftUnitsWantingTMD] do
                LOG(sFunctionRef..': Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Unit position='..repru(oUnit:GetPosition()))
            end
        end
        --Get the unit closest to the nearest enemy base to protect first
        local oUnitWantingTMD = M28Building.GetUnitWantingTMD(tLZData, tLZTeamData)
        if oUnitWantingTMD then
            HaveActionToAssign(refActionBuildTMD, 2, iBPWanted,  oUnitWantingTMD)
        end
    end

    --Reclaim specific units
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if have units to reclaim, is table empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoUnitsToReclaim]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoUnitsToReclaim]) == false then
        local bObjectiveToReclaim = false
        if M28Map.bIsCampaignMap then
            for iUnit, oUnit in tLZTeamData[M28Map.subreftoUnitsToReclaim] do
                if oUnit[M28UnitInfo.refbIsReclaimTarget] then bObjectiveToReclaim = true break end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Want to reclaim friendly unit, bObjectiveToReclaim='..tostring(bObjectiveToReclaim)) end
        HaveActionToAssign(refActionReclaimFriendlyUnit, 1, math.max(5, 5 * table.getn(tLZTeamData[M28Map.subreftoUnitsToReclaim])), nil, not(bObjectiveToReclaim))
    end

    --Unclaimed hydro in the zone (and we have less than 4k power in our team)
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 400 and M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': We have unbuilt hydro locations for this land zone, locations='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations])) end
        HaveActionToAssign(refActionBuildHydro, 1, 10)
    end

    --SMD if very high value and enemy has nukes
    if tLZTeamData[M28Map.subrefLZSValue] >= 60000 or (tLZTeamData[M28Map.subrefLZSValue] >= 20000 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false) then
        --Make sure we have at least 2 T3 mex in this zone (or no T2 and T1 mexes)
        if tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 or (tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10) then

            local bAssistSMD = false
            iBPWanted, bAssistSMD = GetBPToAssignToSMD(iPlateau, iLandZone, iTeam, tLZTeamData, false, bHaveLowMass, bWantMorePower)
            if iBPWanted > 0 then
                if bAssistSMD then
                    HaveActionToAssign(refActionAssistSMD, 1, iBPWanted)
                else
                    HaveActionToAssign(refActionBuildSMD, 3, iBPWanted)
                end
            end
        end
    end

    --TML (will only trigger atm for core expansions)
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefLZCoreExpansion] then --Redundancy - getbptoassign function also includes this condition; however might be faster by having ith ere as an excluding factor?
        iBPWanted = GetBPToAssignToBuildingTML(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam, bHaveLowMass)
        if iBPWanted > 0 then
            HaveActionToAssign(refActionBuildTML, 2, iBPWanted)
        end
    end

    --Shielding
    iCurPriority = iCurPriority + 1
    local iTechlevelWanted, oUnitToShield
    iBPWanted, iTechlevelWanted, oUnitToShield = GetBPMinTechAndUnitForFixedShields(tLZTeamData, iTeam, false, bHaveLowMass, bWantMorePower, false, iLandZone)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionBuildShield, iTechLevelWanted, iBPWanted, oUnitToShield)
        if bDebugMessages == true then LOG(sFunctionRef..': Have just tried to assign an action to shield unit '..oUnitToShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToShield)) end
    end

    --Units to capture
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of units to capture empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]))) end
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]) == false then
        --Refresh the list
        local iCaptureCount = table.getn(tLZData[M28Map.subreftoUnitsToCapture])
        for iCurCount = iCaptureCount, 1, -1 do
            if not(M28UnitInfo.IsUnitValid(tLZData[M28Map.subreftoUnitsToCapture][iCurCount])) then
                table.remove(tLZData[M28Map.subreftoUnitsToCapture], iCurCount)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Have units to capture for zone '..iLandZone..' after freshing them is table empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]))) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]) == false then
            local oUnitToCapture = M28Utilities.GetNearestUnit(tLZData[M28Map.subreftoUnitsToCapture], tLZData[M28Map.subrefMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': Unit to cpature='..oUnitToCapture.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToCapture)) end
            HaveActionToAssign(refActionCaptureUnit, 1, 25, oUnitToCapture)
        end
    end

    --Units to repair
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToRepair]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Have units to repair for zone '..iLandZone..' is table empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToRepair]))) end
        if M28Conditions.IsTableOfUnitsStillValid(tLZData[M28Map.subreftoUnitsToRepair], true) then
            local oUnitToTarget = M28Utilities.GetNearestUnit(tLZData[M28Map.subreftoUnitsToRepair], tLZData[M28Map.subrefMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': Unit to repair='..oUnitToTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToTarget)) end
            HaveActionToAssign(refActionRepairUnit, 1, 5, oUnitToTarget)
        end
    end

    --Shield assistance
    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPForShieldAssistance(tLZTeamData, iTeam)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionAssistShield, 1, iBPWanted)
    end

    iCurPriority = iCurPriority + 1
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS) Adjacent LZ that wants engineers and has unbuilt mexes (only chekc if we have available engineers)
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have available engineers to send to another LZ. GetHighestTechEngiAvailable='..GetHighestTechEngiAvailable(toAvailableEngineersByTech)) end
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    local iNearbyZonesWantingEngineers = 0
    local iPrevEngisAvailable
    local tLZWantingBPConsidered = {}
    local iAdjLZ
    if iHighestTechEngiAvailable > 0 then
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
            for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                if tPathingDetails[M28Map.subrefLZTravelDist] <= tLZData[M28Map.subrefLZFurthestAdjacentLandZoneTravelDist] then
                    iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]

                    --tLZWantingBPConsidered[iAdjLZ] = true --Are now adding in the condition that the zone has unbuilt mexes
                    --Require unbuilt mexes:
                    local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, iAdjLZ, iPathingRef, iHighestTechEngiAvailable, true, false, true)
                    if tiBPByTechWanted then
                        for iTech = 1, iHighestTechEngiAvailable, 1 do
                            if tiBPByTechWanted[iTech] > 0 then
                                iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                HaveActionToAssign(refActionMoveToLandZone, iTech, iNearbyZonesWantingEngineers * 5 + tiBPByTechWanted[iTech], iAdjLZ, true)
                                if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                    iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                end

                                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                if iHighestTechEngiAvailable == 0 then break end
                            end
                        end
                    end
                    if iHighestTechEngiAvailable == 0 then break end
                else
                    break --Table shoudl be sorted closest first so if we are too far away now the later entries should be ignored
                end
            end
        end
    end

    iCurPriority = iCurPriority + 1
    --If have adjacent waterzone that has unbuilt mexes, wants engineers and has no combat threat then assign engi
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; Checking if adjacent water zones that want engis to build mexes, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
    if iHighestTechEngiAvailable > 0 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
        local iCurWZ, iCurPond
        local iBPAlreadyAssigned = 0
        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
            --Use similar logic to core land zone to avoid unintended consequences
            iCurWZ = tSubtable[M28Map.subrefAWZRef]
            iCurPond = M28Map.tiPondByWaterZone[iCurWZ]
            local tWZData = M28Map.tPondDetails[iCurPond][M28Map.subrefPondWaterZones][iCurWZ]
            if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent water zone iCurWZ='..iCurWZ..'; iCurPond='..iCurPond..'; Is table of unbuilt mex locations empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]))) end
            local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
            if tWZTeamData[M28Map.subrefWZbCoreBase] or M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]) == false then

                if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to send engineers to an adjaent water zone, iCurWZ='..iCurWZ..'; tWZTeamData[M28Map.subrefTbWantBP]='..tostring(tWZTeamData[M28Map.subrefTbWantBP] or false)) end
                if tWZTeamData[M28Map.subrefTbWantBP] and tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 10 then
                    iBPWanted = 5
                    if tWZTeamData[M28Map.subrefTbWantBP] then
                        iBPWanted = math.min(50, math.max(tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]], tWZTeamData[M28Map.subrefTBuildPowerByTechWanted][1]))
                    end
                    HaveActionToAssign(refActionMoveToWaterZone, 1, iBPWanted + iBPAlreadyAssigned, iCurWZ, true)
                    iBPAlreadyAssigned = iBPAlreadyAssigned + iBPWanted
                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                    if iHighestTechEngiAvailable == 0 or iBPAlreadyAssigned >= tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 3 then break end
                end
            end
        end
    end

    --High priority islands (early-game expansion)
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS)
    iCurPriority = iCurPriority + 1
    local iBPAlreadyTraveling = 0
    GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if bDebugMessages == true then LOG(sFunctionRef..': Core LZ considering engis for islands, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Time='..GetGameTimeSeconds()) end
    if iHighestTechEngiAvailable > 0 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of pathing to other islands empty='..tostring(tLZData[M28Map.subrefLZPathingToOtherIslands])) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
            local iDistanceThreshold = math.max(125, M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) * 0.502)
            if bDebugMessages == true then LOG(sFunctionRef..': iDistanceThreshold='..iDistanceThreshold) end

            for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..'; Travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; tPathingData[M28Map.subrefIslandClosestLZRef]='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; Are there enemies in this or adjacnet LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                if tPathingData[M28Map.subrefIslandTravelDist] > iDistanceThreshold then break
                else
                    --Are there enemies in the target LZ?
                    local tIslandLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]]
                    if tPathingData[M28Map.subrefIslandClosestLZRef] and M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefMexUnbuiltLocations]) == false and not(tIslandLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                        local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, tPathingData[M28Map.subrefIslandClosestLZRef], iEntry, iHighestTechEngiAvailable, false, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                        if tiBPByTechWanted then
                            --Is it either a minor zone, or a core zone that either wants lots of BP or doesnt have any engineers traveling to it?
                            for iTech = 1, iHighestTechEngiAvailable, 1 do
                                if tiBPByTechWanted[iTech] > 0 then
                                    iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                    iBPWanted = iBPAlreadyTraveling + 5
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and assign an engineer to go to tPathingData[M28Map.subrefIslandClosestLZRef]='..tPathingData[M28Map.subrefIslandClosestLZRef]..'; BP wanted='..iBPWanted..'; iTech='..iTech..'; iPrevEngisAvailable='..iPrevEngisAvailable) end
                                    HaveActionToAssign(refActionMoveToLandZone, iTech, iBPWanted, tPathingData[M28Map.subrefIslandClosestLZRef], true)
                                    if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                        iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                        iBPAlreadyTraveling = iBPAlreadyTraveling + tiBPByTech[iTech]
                                    end

                                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                    if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable after this='..iHighestTechEngiAvailable) end
                                    if iHighestTechEngiAvailable == 0 then break end
                                end
                            end
                        end
                    end
                end
            end
        end
    end


    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPToAssignToAssistUpgrade(tLZTeamData, iTeam, false, bHaveLowMass, bWantMorePower)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionAssistUpgrade, 1, iBPWanted)
    end

    --Build mass storage if we have T2+ mexes
    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPToAssignToMassStorage(iPlateau, iLandZone, iTeam, tLZTeamData, true, bHaveLowMass, bWantMorePower)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionBuildMassStorage, 1, iBPWanted)
    end

    --Lower priority mass reclaim
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.35 and tLZData[M28Map.subrefTotalMassReclaim] >= 5 then
        local iReclaimFactor = 75
        if GetGameTimeSeconds() <= 540 then iReclaimFactor = 125 end
        iBPWanted = math.min(40, math.max(5, tLZData[M28Map.subrefTotalMassReclaim] / iReclaimFactor))
        if iBPWanted > 15 and GetGameTimeSeconds() <= 540 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 then
            iBPWanted = math.min(iBPWanted, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * 10)
        end
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then iBPWanted = math.max(5, iBPWanted * 0.6) end

        if bDebugMessages == true then LOG(sFunctionRef..': Lower priority reclaim, Total mass in Plateau '..iPlateau..' LZ '..iLandZone..'='..tLZData[M28Map.subrefTotalMassReclaim]) end
        HaveActionToAssign(refActionReclaimArea, 1, math.min(100, math.max(5, iBPWanted)), false)
    end

    --SAMs for minor zones
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefLZSValue] >= 1500 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and (tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] > 0 or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 1000 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3) then
        local iGroundAAWanted = math.max(1600, M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.2)
        if (not(M28Team.tTeamData[iTeam][M28Team.refbHaveAirControl] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 8) or (not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20 and M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] >= 2000)) and tLZTeamData[M28Map.subrefLZSValue] >= 1500 then
            iGroundAAWanted = math.max(3200, M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.25 + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.05)
        end
        if iGroundAAWanted > math.max(7000, tLZTeamData[M28Map.subrefLZSValue] * 0.5) then
            iGroundAAWanted = math.max(7000, math.min(iGroundAAWanted, tLZTeamData[M28Map.subrefLZSValue] * 0.5, 4000 * tLZTeamData[M28Map.subrefMexCountByTech][3]  + 1000 * tLZTeamData[M28Map.subrefMexCountByTech][2]))
        end

        if tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < iGroundAAWanted then
            --Do we already have fixed AA in this LZ?
            local iAACategory = M28UnitInfo.refCategoryStructureAA
            if M28Team.subrefiHighestFriendlyFactoryTech >= 3 then iAACategory = iAACategory * categories.TECH3 end
            local tExistingFixedAA = EntityCategoryFilterDown(iAACategory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
            --Max of 1 sam per 1 T3 mex (approx), more if we have large gunship threat and lack air control
            if M28Utilities.IsTableEmpty(tExistingFixedAA) or tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < math.max(iNearbyEnemyAirToGroundThreat * 2, iGroundAAWanted) then
                --Further cap on number of SAMs
                if not(bHaveLowMass and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) and tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] >= 6000 and (tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][1]) > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] > 15 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                    iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
                    if iNearbyEnemyAirToGroundThreat > 0 then iBPWanted = iBPWanted * 2 end
                    if not(M28Conditions.HaveLowPower(iTeam)) then
                        if not(bHaveLowMass) then iBPWanted = iBPWanted * 4
                        else iBPWanted = iBPWanted * 2
                        end
                    end
                    HaveActionToAssign(refActionBuildAA, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted)
                    if bDebugMessages == true then LOG(sFunctionRef..': Wnat more AA for minor zone, iBPWanted='..iBPWanted) end
                end
            end
        end
    end

    --Lower priority LZs wanting engineers:
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS) Other non adjacent LZ on this plateau that wants engineers (low priority) - prioritise those nearest this zone
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
            for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                if not(tLZWantingBPConsidered[iAdjLZ]) then
                    tLZWantingBPConsidered[iAdjLZ] = true
                    local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, iAdjLZ, iPathingRef, iHighestTechEngiAvailable, false)
                    if tiBPByTechWanted then
                        for iTech = 1, iHighestTechEngiAvailable, 1 do
                            if tiBPByTechWanted[iTech] > 0 then
                                iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                HaveActionToAssign(refActionMoveToLandZone, iTech, (iNearbyZonesWantingEngineers + 1) * 5, iAdjLZ, true)
                                if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                    iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                end

                                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                if iHighestTechEngiAvailable == 0 then break end
                            end
                        end
                    end
                end
                if iHighestTechEngiAvailable == 0 then break end
            end
        end
    end

    --Islands wanting engineers (provided we dont have adjacent naval threats)
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': About to check if minor LZ wants to send engis to an island, iHighestTechEngiAvailable='..iHighestTechEngiAvailable) end
    local iIslandDistanceThreshold
    if iHighestTechEngiAvailable > 0 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
        if bDebugMessages == true then LOG(sFunctionRef..': is pathing to other islands empty='..tostring( M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]))) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; tLZTeamData[M28Map.reftClosestEnemyBase]='..repru(tLZTeamData[M28Map.reftClosestEnemyBase])..'; tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint])) end
            iIslandDistanceThreshold = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) * 0.6
            if M28Map.bIsCampaignMap then iIslandDistanceThreshold = iIslandDistanceThreshold * 1.5 end
            if bDebugMessages == true then LOG(sFunctionRef..': Will search for islands, iIslandDistanceThreshold='..iIslandDistanceThreshold) end

            for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering island '..tPathingData[M28Map.subrefIslandNumber]..'; travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; Closest LZ ref='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; are enemies in this or adjacent LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                if tPathingData[M28Map.subrefIslandTravelDist] > iIslandDistanceThreshold then break
                else
                    --Are there enemies in the target LZ?
                    if tPathingData[M28Map.subrefIslandClosestLZRef] and not(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                        local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, tPathingData[M28Map.subrefIslandClosestLZRef], iEntry, iHighestTechEngiAvailable, false, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                        if tiBPByTechWanted then
                            --Is it either a minor zone, or a core zone that either wants lots of BP or doesnt have any engineers traveling to it?
                            for iTech = 1, iHighestTechEngiAvailable, 1 do
                                if tiBPByTechWanted[iTech] > 0 then
                                    iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                    HaveActionToAssign(refActionMoveToLandZone, iTech, math.max((iNearbyZonesWantingEngineers + 1) * 5, tiBPByTechWanted[iTech]), tPathingData[M28Map.subrefIslandClosestLZRef], true)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished trying to give order for engi to move to the island LZ, table.getn(toAvailableEngineersByTech[iTech])='..table.getn(toAvailableEngineersByTech[iTech])..'; iPrevEngisAvailable='..iPrevEngisAvailable) end
                                    if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                        iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                    end

                                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                    if iHighestTechEngiAvailable == 0 then break end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    --If have are overflowing mass and have high income, energy, and are at T3, and this zone has mexes and no enemy units then get land factories if <=2, or an experimental otherwise
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3 and not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 750 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 30 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.6 then
        --We need at least 1 T3 mex in the zone and no enemy units
        if tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) then
            local iExistingFactories = 0
            local tExistingLandFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
            if M28Utilities.IsTableEmpty(tExistingLandFactories) == false then
                iExistingFactories = table.getn(tExistingLandFactories)
            end
            if iExistingFactories < 2 then
                --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting)
                if bDebugMessages == true then LOG(sFunctionRef..': Want to build land factory as only have 1 factory') end
                HaveActionToAssign(refActionBuildLandFactory, 1, 40)
            else
                --Build land experimental if enemy base is pathable by land from here and we have high gross mass
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 60 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 6 then
                    if (NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) or 0) == (NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint]) or -1) then
                        HaveActionToAssign(refActionBuildLandExperimental, 3, 60, nil, false, true)
                    else
                        HaveActionToAssign(refActionBuildExperimental, 3, 60, nil, false, true)
                    end
                end
            end
        end
    end

    --If still have an engineer available and have an adjacent LZ that wants BP and doesnt have any enemies in that LZ specifically (even if there might be in an adjacent one) then send engineer
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then

        if bDebugMessages == true then LOG(sFunctionRef..': Table of adjacnet LZs='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones])) end
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
            local iBPAlreadyTraveling = 0
            if M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
                for iEngi, oEngi in toAssignedEngineers do
                    if oEngi[refiAssignedAction] == refActionMoveToLandZone then
                        iBPAlreadyTraveling = iBPAlreadyTraveling + oEngi:GetBlueprint().Economy.BuildRate
                    end
                end
            end

            for _, iAdjLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; Does it want BP='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP])..'; Combat threat='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal]) end
                if not(tLZWantingBPConsidered[iAdjLZ]) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP] and (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][1] or 0) > 0 and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] == 0 then
                    HaveActionToAssign(refActionMoveToLandZone, 1, iBPAlreadyTraveling + 5, iAdjLZ, true)
                    iBPAlreadyTraveling = iBPAlreadyTraveling + 5
                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                    if iHighestTechEngiAvailable == 0 then break end
                end
            end
        end
    end


    --Adjacent water zones that want an engineer
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have adjacent WZ that wants engineer, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
    if iHighestTechEngiAvailable > 0 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
        local iCurWZ
        local iCurPond
        local bWantBPOfOurTech
        local iMinTechWanted = 1
        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
            iCurWZ = tSubtable[M28Map.subrefAWZRef]
            iCurPond = M28Map.tiPondByWaterZone[iCurWZ]
            local tWZTeamData = M28Map.tPondDetails[iCurPond][M28Map.subrefPondWaterZones][iCurWZ][M28Map.subrefWZTeamData][iTeam]
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to send engineers to an adjaent water zone, iCurWZ='..iCurWZ..'; tWZTeamData[M28Map.subrefTbWantBP]='..tostring(tWZTeamData[M28Map.subrefTbWantBP] or false)) end
            if tWZTeamData[M28Map.subrefTbWantBP] then
                bWantBPOfOurTech = false
                for iTech = iHighestTechEngiAvailable, 1, -1 do
                    if tWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                        bWantBPOfOurTech = true
                        iMinTechWanted = iTech
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': bWantBPOfOurTech='..tostring(bWantBPOfOurTech)) end
                if bWantBPOfOurTech then
                    HaveActionToAssign(refActionMoveToWaterZone, iMinTechWanted, math.min(tiBPByTech[iMinTechWanted] * 2, 50), iCurWZ, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': have tried to send BP of '..(tiBPByTech[iMinTechWanted] * 2)..' to iCurWZ '..iCurWZ) end
                    break
                end
            end
            if bWantBPOfOurTech then break end
        end
    end

    --Extra (second) shielding in a high mass scenario - will only try to shield t3 arti/game ender
    iCurPriority = iCurPriority + 1
    if (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 500 then
        local iBPWanted, iTechLevelWanted, oUnitToShield = GetBPMinTechAndUnitForFixedShields(tLZTeamData, iTeam, true, bHaveLowMass, bWantMorePower, true, iLandZone)
        if iBPWanted > 0 then
            iBPWanted = math.min(iBPWanted, 40)

            HaveActionToAssign(refActionBuildSecondShield, iTechLevelWanted, iBPWanted, oUnitToShield)
            if bDebugMessages == true then LOG(sFunctionRef..': High priority shield builder, iBPWanted='..iBPWanted) end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Dont want to assign any BP to high priority shield builder') end
        end
    end

    --Dont have low mass and have a navla fac in a WZ that wants more BP and is near enough for engineers to be sent to assist, then send BP here


    --Low priority power builder if we have lots of mass and dont have much power
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 75 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < math.max(250, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.5) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 20) then
        local iMinTechLevelForPower = 1
        --[[if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 then
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 22 then iMinTechLevelForPower = 1
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 110 then iMinTechLevelForPower = 2
        end
    end--]]
        HaveActionToAssign(refActionBuildPower, iMinTechLevelForPower, tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 6)
    end

    --Low priority air staging, if we have T3 mex, decent intel coverage, no nearby enemies, and need air staging
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': About to check if we need air staging for core zone, Time='..GetGameTimeSeconds()..'; Time of last shortage='..(M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastAirStagingShortage] or 'nil')) end
    if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastAirStagingShortage] or 0) <= 1.1 and not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and (tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][2] >= 3) and tLZTeamData[M28Map.refiRadarCoverage] >= 100 then
        local tExistingAirStaging = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirStaging, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        local iExistingAirStaging = 0
        if M28Utilities.IsTableEmpty(tExistingAirStaging) == false then
            for iStaging, oStaging in tExistingAirStaging do
                if oStaging:GetFractionComplete() == 1 and oStaging:GetAIBrain().M28AI then
                    iExistingAirStaging = iExistingAirStaging + 1
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iExistingAirStaging='..iExistingAirStaging..'; bHaveLowMass='..tostring(bHaveLowMass)) end
        if iExistingAirStaging < 1 then
            iBPWanted = 5
            if not(bHaveLowMass) then iBPWanted = iBPWanted * 2 end
            HaveActionToAssign(refActionBuildAirStaging, 1, iBPWanted, nil, false)
            if bDebugMessages == true then LOG(sFunctionRef..': Have flagged we want air staging for minor zone with iBPWanted='..iBPWanted) end
        end
    end

    --Low priority T2 radar creep
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': T2 radar creep - bHaveLowMass='..tostring(bHaveLowMass)..'; bWantMorePower='..tostring(bWantMorePower)..'; Radar coverage='..tLZTeamData[M28Map.refiRadarCoverage]..'; Map size='..M28Map.iMapSize..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; tLZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
    if not(bHaveLowMass) and not(bWantMorePower) and tLZTeamData[M28Map.refiRadarCoverage] < 100 and M28Map.iMapSize > 512 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 18 and (tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][2] >= 2) then
        --Check we dont have any radar here already (redundancy for radar coverage)
        local tExistingRadar = EntityCategoryFilterDown(M28UnitInfo.refCategoryRadar, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        local bHaveRadar = false
        if M28Utilities.IsTableEmpty(tExistingRadar) == false then
            for iUnit, oUnit in tExistingRadar do
                if oUnit:GetFractionComplete() >= 1 then
                    bHaveRadar = true
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveRadar='..tostring(bHaveRadar)) end
        if not(bHaveRadar) then
            HaveActionToAssign(refActionBuildT2Radar, 2, 10)
        end
    end

    --Low priority air staging builder (max of 1) for expansion bases
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefLZCoreExpansion] and not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastAirStagingShortage] or -100) <= 2 and tLZTeamData[M28Map.subrefLZSValue] >= 400 and not(bHaveLowMass) and not(M28Conditions.HaveLowPower(iTeam)) then
        local bHaveAirStaging = false
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
            local tAirStaging = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirStaging, tLZTeamData[M28Map.subrefLZTAlliedUnits])
            if M28Utilities.IsTableEmpty(tAirStaging) == false then
                for iUnit, oUnit in tAirStaging do
                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then bHaveAirStaging = true break end
                end
            end
        end
        if not(bHaveAirStaging) then
            HaveActionToAssign(refActionBuildAirStaging, 1, 10)
        end
    end


    --If still have an engineer available and there is reclaim in the LZ of any kind, and we arent overflowing, then reclaim
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.8 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] < 0.9 then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if iHighestTechEngiAvailable > 0 then
            if tLZData[M28Map.subrefTotalMassReclaim] >= 5 then
                if bDebugMessages == true then LOG(sFunctionRef..': Lower priority reclaim, Total mass in Plateau '..iPlateau..' LZ '..iLandZone..'='..tLZData[M28Map.subrefTotalMassReclaim]) end
                HaveActionToAssign(refActionReclaimArea, 1, 100, false, true)
            end
        end
    end

    --Check for any part constructed buildings in this zone if we either have available engineers, or no engineers at all
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if M28Utilities.IsTableEmpty(tEngineers) or iHighestTechEngiAvailable > 0 then
        local tBuildings = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        if M28Utilities.IsTableEmpty(tBuildings) == false then
            for iUnit, oUnit in tBuildings do
                --Dont assist part complete shields as may be for special shielding logic
                if oUnit:GetFractionComplete() < 1 and not(EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oUnit.UnitId)) then
                    HaveActionToAssign(refActionRepairUnit, 1, 5, oUnit)
                    break
                end
            end
        end
    end

    --Spare engi - assist any upgrading unit
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then
            HaveActionToAssign(refActionAssistUpgrade, 1, 1000, false, true)
        end
    end

    --Low priority island support - will consider further away distances tahn before, up to a distance of 400, and only if the island wants T1 engineer BP
    if iHighestTechEngiAvailable > 0 and (iIslandDistanceThreshold or 0) > 0 and iIslandDistanceThreshold <= 400 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if iHighestTechEngiAvailable > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': is pathing to other islands empty='..tostring( M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]))) end
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; tLZTeamData[M28Map.reftClosestEnemyBase]='..repru(tLZTeamData[M28Map.reftClosestEnemyBase])..'; tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint])) end

                if bDebugMessages == true then LOG(sFunctionRef..': Will search for islands, iIslandDistanceThreshold='..iIslandDistanceThreshold) end

                for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering island '..tPathingData[M28Map.subrefIslandNumber]..' for lower priority travel; travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; Closest LZ ref='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; are enemies in this or adjacent LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                    if tPathingData[M28Map.subrefIslandTravelDist] > iIslandDistanceThreshold then --Have already considered islands with a shorter travel distance above
                        if tPathingData[M28Map.subrefIslandTravelDist] > 400 then break --Too far to try and travel by engineer
                        else
                            --Are there enemies in the target LZ?
                            if tPathingData[M28Map.subrefIslandClosestLZRef] and not(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                                local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, tPathingData[M28Map.subrefIslandClosestLZRef], iEntry, iHighestTechEngiAvailable, false, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                                if (tiBPByTechWanted[1] or 0) > 0 then
                                    HaveActionToAssign(refActionMoveToLandZone, 1, 5, tPathingData[M28Map.subrefIslandClosestLZRef], true)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished trying to give order for engi to move to the island LZ '..tPathingData[M28Map.subrefIslandClosestLZRef]) end
                                    break
                                end
                            end
                        end
                    end
                end
            end
        end
    end


    --Do we have stuff to reclaim in this LZ and arent about to overflow mass? Decided to leave this out as looks like it can do more harm than good
    --[[iCurPriority = iCurPriority + 1
iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
if iHighestTechEngiAvailable > 0 and tLZData[M28Map.subrefTotalMassReclaim] >= 5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.6 then
    HaveActionToAssign(refActionReclaimArea, 1, math.min(100, math.max(10, tLZData[M28Map.subrefTotalMassReclaim] / 10)), false, true)
end--]]



    UpdateSpareEngineerNumber(tLZTeamData, toAvailableEngineersByTech)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function ConsiderWaterZoneEngineerAssignment(tWZTeamData, iTeam, iPond, iWaterZone, tEngineers)
    --Called from ConsiderLandOrWaterZoneEngineerAssignment
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderWaterZoneEngineerAssignment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iBPWanted
    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
    local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)
    local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
    local iHighestTechEngiAvailable
    local iExistingWaterFactory = 0
    if tWZTeamData[M28Map.subrefWZbCoreBase] then
        local tExistingWaterFactory = EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subrefWZTAlliedUnits])
        if M28Utilities.IsTableEmpty(tExistingWaterFactory) == false then
            iExistingWaterFactory = table.getn(tExistingWaterFactory)
        end
    end

    local toAvailableEngineersByTech, toAssignedEngineers = FilterToAvailableEngineersByTech(tEngineers, false, tWZData, tWZTeamData, iTeam, iPond, iWaterZone, true)
    tWZTeamData[M28Map.subrefTBuildPowerByTechWanted] = { [1] = 0, [2] = 0, [3] = 0 }
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Time=' .. GetGameTimeSeconds() .. '; iPond=' .. iPond .. '; iWaterZone=' .. iWaterZone .. '; tWZTeamData[M28Map.subrefWZbCoreBase]=' .. tostring(tWZTeamData[M28Map.subrefWZbCoreBase] or false) .. '; iExistingWaterFactory=' .. (iExistingWaterFactory or 'nil') .. '; Have just reset BPByTech to 0 for Pond' .. iPond .. '; WZ=' .. iWaterZone .. '; repru=' .. repru(tWZTeamData[M28Map.subrefTBuildPowerByTechWanted]) .. '; bHaveLowMass=' .. tostring(bHaveLowMass or false) .. '; bHaveLowPower=' .. tostring(bHaveLowPower or false))
    end
    --local iCurCondition = 0
    local iCurPriority = 0

    function HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted)
        --Done as subfunction for convenience so can just note the key values for the action in question and add on the others that wont change
        ConsiderActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iCurPriority, tWZData, tWZTeamData, iTeam, iPond, iWaterZone, toAvailableEngineersByTech, toAssignedEngineers, true, iOptionalSpecificFactionWanted)
    end

    --High priority hydro if we have low energy and water zone start
    iCurPriority = iCurPriority + 1
    if tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] and M28Utilities.IsTableEmpty(tWZData[M28Map.subrefHydroUnbuiltLocations]) == false then
        iBPWanted = 5
        if bHaveLowPower or not (bHaveLowMass) then
            iBPWanted = 10
            if table.getn(tWZData[M28Map.subrefHydroUnbuiltLocations]) >= 2 then
                iBPWanted = 15
            end
        end
        HaveActionToAssign(refActionBuildHydro, 1, iBPWanted)
    end

    --Higih priority mex if we have water zone start
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]) == false and tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': We want to build a mex asap as we have unbuilt locations and have started in water')
        end
        HaveActionToAssign(refActionBuildMex, 1, math.max(5, table.getn(tWZData[M28Map.subrefMexUnbuiltLocations]) * 2.5))
    end


    --Naval fac if this is a core WZ and we dont have any, with eco condition
    iCurPriority = iCurPriority + 1
    --Commented out as need logic for identifying build locations first
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': About to see if we want to build a naval factory, is this a core WZ base=' .. tostring(tWZTeamData[M28Map.subrefWZbCoreBase]) .. '; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass])
    end
    if (tWZTeamData[M28Map.subrefWZbCoreBase] and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 4 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or M28Map.bIsCampaignMap and not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2.5 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3)) or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
        --Is this a priority pond for our team to expand to?
        if bDebugMessages == true then LOG(sFunctionRef..': M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]]='..(M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]] or 'nil')) end
        if (M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]] or 0) > 0 or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
            local iFactoriesWanted = 1
            --if bHaveLowMass then iFactoriesWanted = math.max(1, iFactoriesWanted * 0.5) end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': iFactoriesWanted=' .. iFactoriesWanted .. '; iExistingWaterFactory=' .. iExistingWaterFactory)
            end
            if iExistingWaterFactory < iFactoriesWanted then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': We want to build a naval factory')
                end
                HaveActionToAssign(refActionBuildNavalFactory, 1, 30, nil)
            end
        end
    end

    if bDebugMessages == true then
        LOG(sFunctionRef .. ': About to consider what actions we want to give engineers for iPond=' .. iPond .. '; iWaterZone=' .. iWaterZone .. '; iTeam=' .. iTeam .. '; Is table of unbuilt mex locations empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations])) .. '; Is table of part complete mexes empty=' .. tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoPartBuiltMexes])))
    end

    --Emergency AA
    iCurPriority = iCurPriority + 1
    if (tWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) > (tWZTeamData[M28Map.subrefWZThreatAlliedAA] or 0) * 0.25 and (tWZTeamData[M28Map.subrefWZbCoreBase] or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) then
        iBPWanted = 25
        if not (bHaveLowMass) and not (bHaveLowPower) then
            iBPWanted = 50
        end
        HaveActionToAssign(refActionBuildAA, math.max(1, (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] or 1)), iBPWanted)
    end

    --Unclaimed mex in the zone
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering if unbuilt or part build mexes in t his WZ ' .. iWaterZone .. ', is subrefMexUnbuiltLocations empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations])) .. '; Is subreftoPartBuiltMexes empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subreftoPartBuiltMexes])) .. '; Is table of mex locations empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZMexLocations])) .. '; Enemy combat threat=' .. tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal])
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]) == false then
            LOG(sFunctionRef .. ': Size of unbuilt locations table=' .. table.getn(tWZData[M28Map.subrefMexUnbuiltLocations]))
        end
    end
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]) == false then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': We want to build a mex as we have unbuilt locations')
        end
        HaveActionToAssign(refActionBuildMex, 1, math.max(5, table.getn(tWZData[M28Map.subrefMexUnbuiltLocations]) * 2.5))
    elseif M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
        --Do we have no engineers assigned to building a mex?
        local bHaveEngisBuilding = false
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Have part built mexes, is toAssignedEngineers empty=' .. tostring(M28Utilities.IsTableEmpty(toAssignedEngineers)))
        end
        if M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
            for iEngi, oEngi in toAssignedEngineers do
                if oEngi[refiAssignedAction] == refActionBuildMex then
                    bHaveEngisBuilding = true
                    break
                end
            end
        end
        if not (bHaveEngisBuilding) then
            --Refresh list of mexes
            RefreshPartBuiltMexList(tWZTeamData)
            if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
                HaveActionToAssign(refActionCompletePartBuiltMex, 1, 5)
            end
        end
    elseif M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZMexLocations]) == false then
        --Does the enemy have mexes in this WZ but doesnt have combat threat? If so then try and reclaim
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Checking if enemy has any mexes in this WZ, Is table of enemey units empty=' .. tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits])) .. '; Enemy combat threat=' .. tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal])
        end
        if tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 15 and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
            local tEnemyMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tWZTeamData[M28Map.subrefTEnemyUnits])
            if bDebugMessages == true then
                LOG(sFunctionRef .. 'Is table of enemy mexes empty=' .. tostring(M28Utilities.IsTableEmpty(tEnemyMexes)))
            end
            if M28Utilities.IsTableEmpty(tEnemyMexes) == false then
                HaveActionToAssign(refActionReclaimEnemyUnit, 1, 5, tEnemyMexes)
            end
        end
    end


    --Lower priority mass reclaim where will request engineers to reclaim
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.35 and tWZData[M28Map.subrefTotalMassReclaim] >= 5 then
        local iReclaimFactor = 75
        if GetGameTimeSeconds() <= 540 then
            iReclaimFactor = 125
        end
        iBPWanted = math.min(40, math.max(5, tWZData[M28Map.subrefTotalMassReclaim] / iReclaimFactor))
        if iBPWanted > 15 and GetGameTimeSeconds() <= 540 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 then
            iBPWanted = math.min(iBPWanted, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * 10)
        end
        if tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then
            iBPWanted = math.max(5, iBPWanted * 0.6)
        end

        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Lower priority reclaim, Total mass in Pond ' .. iPond .. ' WZ ' .. iWaterZone .. '=' .. tWZData[M28Map.subrefTotalMassReclaim])
        end
        HaveActionToAssign(refActionReclaimArea, 1, math.min(100, math.max(5, iBPWanted)), false, false)
    end

    --Unclaimed hydro
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefHydroUnbuiltLocations]) == false then
        iBPWanted = 10
        if table.getn(tWZData[M28Map.subrefHydroUnbuiltLocations]) >= 2 then
            iBPWanted = 20
        end
        HaveActionToAssign(refActionBuildHydro, 1, iBPWanted)
    end

    --Extra naval facs if need build power and dont have low mass and have positive net energy income
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': About to see if we want to build a naval factory, is this a core WZ base=' .. tostring(tWZTeamData[M28Map.subrefWZbCoreBase]) .. '; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] .. '; bHaveLowMass=' .. tostring(bHaveLowMass) .. '; bWantBP=' .. tostring(tWZTeamData[M28Map.subrefTbWantBP]))
    end
    if (not (bHaveLowMass) or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) and (not (bHaveLowPower) or (tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > 1 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or -100) >= 10)) and ((tWZTeamData[M28Map.subrefWZbCoreBase] and (tWZTeamData[M28Map.subrefTbWantBP] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 10000) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 6 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) or (tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 4 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and (tWZTeamData[M28Map.subrefTbWantBP] or not (bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 12 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]))) then
        if (M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]] or 0) > 0 or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
            local iMaxFactories = 2
            if tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
                iMaxFactories = math.min(8, math.max(2, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / 2))
            end
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 100 then
                iMaxFactories = 3
            end

            --if bHaveLowMass then iFactoriesWanted = math.max(1, iFactoriesWanted * 0.5) end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': iMaxFactories=' .. iMaxFactories .. '; iExistingWaterFactory=' .. iExistingWaterFactory)
            end
            if iExistingWaterFactory < iMaxFactories then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Lower priority builder - We want to build a naval factory')
                end
                HaveActionToAssign(refActionBuildNavalFactory, 1, 30, nil)
            end
        end
    end

    --Build sonar if no nearby enemies and lack decent coverage and have decent eco
    iCurPriority = iCurPriority + 1
    --Coverage set at 100, as can have large water zones, with sonar built on edge, meaning T2 sonar doesnt even give 100 coverage of its own midpoint
    if tWZTeamData[M28Map.refiSonarCoverage] <= 100 and not (bHaveLowMass) and not (bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 and tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] == 0 and not (M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmni]) then
        local iGrossMassWanted = 6
        local iGrossEnergyWanted = 125
        iBPWanted = 15
        if not (tWZTeamData[M28Map.subrefWZbCoreBase]) then
            iGrossMassWanted = iGrossMassWanted * 2
            iGrossEnergyWanted = iGrossEnergyWanted * 2
        else
            iBPWanted = 40
        end
        if tWZTeamData[M28Map.refiSonarCoverage] == 0 then
            iGrossMassWanted = iGrossMassWanted * 0.8
            iGrossEnergyWanted = iGrossEnergyWanted * 0.8
            if M28Map.bIsCampaignMap and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 then
                iGrossMassWanted = iGrossMassWanted * 0.7
                iGrossEnergyWanted = iGrossEnergyWanted * 0.7
            end
        end
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= iGrossMassWanted and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= iGrossEnergyWanted then
            --Check we dont have any T2+ sonar in this WZ as sometimes water zones are so big that they dont get great coverage from sonar
            local tFriendlySonar
            if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTAlliedUnits]) == false then
                tFriendlySonar = EntityCategoryFilterDown(M28UnitInfo.refCategorySonar, tWZTeamData[M28Map.subrefWZTAlliedUnits])
            end
            if M28Utilities.IsTableEmpty(tFriendlySonar) then
                --Build t1 sonar if enemy has enemies in adjacent WZ or we have reached 400 gross mass income, T2 if no enemies in this or adjacent
                if not (tWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 40 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 750) then
                    HaveActionToAssign(refActionBuildT2Sonar, 2, iBPWanted, false, false)
                elseif tWZTeamData[M28Map.refiSonarCoverage] <= 10 then
                    HaveActionToAssign(refActionBuildT1Sonar, 1, 5, false, false)
                end
            end
        end
    end

    --Experimental naval unit for very high mass levels (higher priority than naval fac assist so engis stop assisting naval fac and start building this)

    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Experimental navy builder - core base=' .. tostring(tWZTeamData[M28Map.subrefWZbCoreBase]) .. '; bHaveLowMass=' .. tostring(bHaveLowMass) .. '; Low power=' .. tostring(bHaveLowPower) .. '; Mass%=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] .. '; Gross mass=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] .. '; Net mass=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] .. '; Naval tehc=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] .. '; Enemies in adjacent QZ=' .. tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) .. '; Ally combat total=' .. tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal])
    end
    if tWZTeamData[M28Map.subrefWZbCoreBase] and not (bHaveLowMass) and not (bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 35 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 5 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > -1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 80)) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] >= 3 and (not (tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) or (tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= 8000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.7)) then
        --Likely have the eco to get an experimental naval unit, check if we have a lifetime build count of at least 2 T3 naval units
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Think we have enough eco for experimental navy builder, lifetime battleship count=' .. M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryBattleship))
        end
        if M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryBattleship) >= 2 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.8 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 100) then
            --Cap experimentals to 2 if there are no enemy naval targets (increase cap if about to overflow mass)
            local iCurNavalExperimentals = 0
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    iCurNavalExperimentals = iCurNavalExperimentals + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryAllNavy * categories.EXPERIMENTAL)
                end
            end
            local iExperimentalsWanted = 4
            if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastNoSurfaceCombatTargetByPond][iPond] or -100) <= 30 then
                iExperimentalsWanted = 2
            end
            if iCurNavalExperimentals >= iExperimentalsWanted then
                local iCurLandExperimentals = 0
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        iCurLandExperimentals = iCurLandExperimentals + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandExperimental)
                    end
                end
                iExperimentalsWanted = math.max(iExperimentalsWanted, iCurLandExperimentals)
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': iCurLandExperimentals=' .. iCurLandExperimentals)
                end
            end
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.9 then
                iExperimentalsWanted = iExperimentalsWanted * 1.5
            end
            if iCurNavalExperimentals < iExperimentalsWanted then
                iBPWanted = 45
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.6 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 10 then
                    iBPWanted = 90
                end
                HaveActionToAssign(refActionBuildExperimentalNavy, 3, iBPWanted, false, false, true)
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Want experimental naval unit, iBPWanted=' .. iBPWanted)
                end
            end
        end
    end

    --Send engineer to a land zone adjacent to this that wants support and lacks factories
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    local iLZSentTo = 0
    if bDebugMessages == true then LOG(sFunctionRef .. ': About to see if have adjacent land zones wanting engineers, iHighestTechEngiAvailable=' .. iHighestTechEngiAvailable..'; Is table of adjacent LZs empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]))) end
    if iHighestTechEngiAvailable > 0 then
        --Do we haev adjacent land zone wanting engineer?
        local iMinTechWanted        = 1
        local bWantBPOfOurTech
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
            for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                local iPlateau = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                local iLandZone = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent LZ '..(iLandZone or 'nil')..' on plateau '..(iPlateau or 'nil')..'; Does this LZ want BP='..tostring(tLZTeamData[M28Map.subrefTbWantBP])..'; Dangerous enemies in this LZ='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])..'; Allied untis in this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]))) end
                if tLZTeamData[M28Map.subrefTbWantBP] and not (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subrefLZTAlliedUnits]))) then
                    bWantBPOfOurTech = false
                    for iTech = iHighestTechEngiAvailable, 1, -1 do
                        if tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                            bWantBPOfOurTech = true
                            iMinTechWanted = iTech
                        end
                    end
                    if bWantBPOfOurTech then
                        --For now to keep things simple will ignore minimum engineer tech requirements
                        iLZSentTo = iLZSentTo + 1
                        if bDebugMessages == true then LOG(sFunctionRef..': About to try and send engineers to iLandZOne '..(iLandZone or 'nil')..'; iPlateau='..(iPlateau or 'nil')) end
                        --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted,            vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted)
                        HaveActionToAssign(refActionMoveToLandZone, iMinTechWanted, 10 * 2 * iLZSentTo, {iPlateau, iLandZone}, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have flagged we want to send BP of '..10 * 2 * iLZSentTo..' to land zone '..iLandZone) end
                    end
                end
            end
        end
    end


    --Send engineer to a water zone near this that wants support, or alternatively a land zone adjacent to that water zone that wants support
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': About to check if have adjacent water zones wanting engineers, iHighestTechEngiAvailable=' .. iHighestTechEngiAvailable)
    end
    if iHighestTechEngiAvailable > 0 then
        local bWantBPOfOurTech
        local iMinTechWanted       = 1
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
            for iEntry, tSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                local iAdjWZ = tSubtable[M28Map.subrefWZAWZRef]
                local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
                local tAltWZTeamData = tAltWZData[M28Map.subrefWZTeamData][iTeam]
                local bWZOrAdjacentLZWantsEngineers
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Considering iAdjWZ=' .. iAdjWZ .. '; tAltWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]=' .. tostring(tAltWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] or false) .. '; tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]=' .. (tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0) .. '; tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. (tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) .. '; tAltWZTeamData[M28Map.subrefTbWantBP]=' .. tostring(tAltWZTeamData[M28Map.subrefTbWantBP]) .. '; WZ table of unclaimed mexes is empty=' .. tostring(M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefMexUnbuiltLocations])) .. '; WZ table of unbuilt hydro is empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefHydroUnbuiltLocations]))..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subrefTEnemyUnits])))
                end
                if (not (tAltWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) or (tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= math.min(6000, math.max(100, tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 0.75)) or (tAltWZTeamData[M28Map.subrefWZbCoreBase] and M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subrefTEnemyUnits]) and M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.reftLZEnemyAirUnits]) and (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20)))) then
                    --WZ is safe to go to, does the WZ want engineers and/or does it have an adjacent LZ that wants engineers?
                    bWZOrAdjacentLZWantsEngineers = tAltWZTeamData[M28Map.subrefTbWantBP]
                    bWantBPOfOurTech = false
                    if bWZOrAdjacentLZWantsEngineers then
                        for iTech = iHighestTechEngiAvailable, 1, -1 do
                            if tAltWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                bWantBPOfOurTech = true
                                iMinTechWanted = iTech
                            end
                        end
                    end

                    if not (bWantBPOfOurTech) and M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefAdjacentLandZones]) == false then

                        for iEntry, tSubtable in tAltWZData[M28Map.subrefAdjacentLandZones] do
                            local iPlateau = tSubtable[1]
                            local iLandZone = tSubtable[2]
                            local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                            if tLZTeamData[M28Map.subrefTbWantBP] and not (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subrefLZTAlliedUnits]))) then
                                bWantBPOfOurTech = false
                                for iTech = iHighestTechEngiAvailable, 1, -1 do
                                    if tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                        bWantBPOfOurTech = true
                                        iMinTechWanted = iTech
                                    end
                                end
                                if bWantBPOfOurTech then
                                    bWZOrAdjacentLZWantsEngineers = true
                                    break
                                end
                            end
                        end
                    end
                    if bWZOrAdjacentLZWantsEngineers then
                        iLZSentTo = iLZSentTo + 1
                        HaveActionToAssign(refActionMoveToWaterZone, iMinTechWanted, 10 * 2 * iLZSentTo, iAdjWZ, true)
                        if iLZSentTo >= 4 then break end
                    end
                end
            end
        end
    end

    --Naval fac if this is a core WZ and we dont have any, but have engineers available, or we have lots of mass stored
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then
        if tWZTeamData[M28Map.subrefWZbCoreBase] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 4 then
            if (M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]] or 0) > 0 or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
                local iFactoriesWanted = 1
                if not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 then
                    iFactoriesWanted = 2
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.7 then iFactoriesWanted = 3 end
                end
                --if bHaveLowMass then iFactoriesWanted = math.max(1, iFactoriesWanted * 0.5) end
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': iFactoriesWanted=' .. iFactoriesWanted .. '; iExistingWaterFactory=' .. iExistingWaterFactory)
                end
                if iExistingWaterFactory < iFactoriesWanted then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Later naval fac builder We want to build a naval factory')
                    end
                    HaveActionToAssign(refActionBuildNavalFactory, 1, 30, nil)
                end
            end
        end
    end

    --Assist naval factory based on average mass income of team
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to assist naval fac, core base='..tostring(tWZTeamData[M28Map.subrefWZbCoreBase])..'; iExistingWaterFactory='..iExistingWaterFactory..'; Is table of naval factories empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subrefWZTAlliedUnits])))) end
    if tWZTeamData[M28Map.subrefWZbCoreBase] and iExistingWaterFactory > 0 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subrefWZTAlliedUnits])) == false then
        --e.g. 1 BP building a frigate uses 0.2 mass per second, or 0.02 mass per tick; if want 40% of team mass income spent on navy, then want to assign 20 BP per 1 mass per tick (i.e. 20 BP per 10 mass per sec)
        iBPWanted = math.min(1000, (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) * 20)
        if not (bHaveLowMass) and not (bHaveLowPower) then
            iBPWanted = iBPWanted * 1.5
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 then iBPWanted = iBPWanted * 1.5 end
        elseif bHaveLowMass and M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] then
            iBPWanted = iBPWanted * 0.7
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Want to assist naval fac, iBPWanted='..iBPWanted) end
        HaveActionToAssign(refActionAssistNavalFactory, 1, iBPWanted, false, false)
    end

    --Preemptive AA builder if we are at T3 and have decent mass income, and have friendly units in the WZ or intel coverage, and no enemy units
    iCurPriority = iCurPriority + 1
    if not (bHaveLowMass) and not (bHaveLowPower) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] or 1) >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 then
        --Build AA if we have <1.5k AA threat
        local iAAThreatWanted = 1500
        if tWZTeamData[M28Map.subrefWZbCoreBase] or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
            iAAThreatWanted = 3000
        end
        if tWZTeamData[M28Map.subrefWZThreatAlliedAA] < iAAThreatWanted then
            if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) and ((tWZTeamData[M28Map.refiSonarCoverage] or 0) > 20 or M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTAlliedUnits]) == false) then
                iBPWanted = 50
                if tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then
                    iBPWanted = 25
                end
                HaveActionToAssign(refActionBuildAA, 3, iBPWanted)
            end
        end
    end

    --Build land experimentals in water if v.high mass
    iCurPriority = iCurPriority + 1
    if not (bHaveLowMass) and not (bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.8 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] or 1) >= 3 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 40 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.9 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20)) then
        local iT3AndExperimentalNavy = 0
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                iT3AndExperimentalNavy = iT3AndExperimentalNavy + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryAllNavy * categories.EXPERIMENTAL + M28UnitInfo.refCategoryAllNavy * categories.TECH3)
            end
        end
        if iT3AndExperimentalNavy >= 4 then
            iBPWanted = 45
            HaveActionToAssign(refActionBuildLandExperimental, 3, iBPWanted, false, false, true)
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Want experimental naval unit, iBPWanted=' .. iBPWanted)
            end
        end
    end

    --Units to capture
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subreftoUnitsToCapture]) == false then
        --Refresh the list
        local iCaptureCount = table.getn(tWZData[M28Map.subreftoUnitsToCapture])
        for iCurCount = iCaptureCount, 1, -1 do
            if not (M28UnitInfo.IsUnitValid(tWZData[M28Map.subreftoUnitsToCapture][iCurCount])) then
                table.remove(tWZData[M28Map.subreftoUnitsToCapture], iCurCount)
            end
        end
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subreftoUnitsToCapture]) == false then
            local oUnitToCapture = M28Utilities.GetNearestUnit(tWZData[M28Map.subreftoUnitsToCapture], tWZData[M28Map.subrefMidpoint])
            HaveActionToAssign(refActionCaptureUnit, 1, 25, oUnitToCapture)
        end
    end

    --Units to repair
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subreftoUnitsToRepair]) == false then
        --Refresh the list
        local iUnitCount = table.getn(tWZData[M28Map.subreftoUnitsToRepair])
        for iCurCount = iUnitCount, 1, -1 do
            if not(M28UnitInfo.IsUnitValid(tWZData[M28Map.subreftoUnitsToRepair][iCurCount])) then
                table.remove(tWZData[M28Map.subreftoUnitsToRepair], iCurCount)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Have units to repair for water zone '..iWaterZone..' after freshing them is table empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subreftoUnitsToRepair]))) end
        if M28Conditions.IsTableOfUnitsStillValid(tLZData[M28Map.subreftoUnitsToRepair], true) then
            local oUnitToTarget = M28Utilities.GetNearestUnit(tWZData[M28Map.subreftoUnitsToRepair], tWZData[M28Map.subrefMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': Unit to repair='..oUnitToTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToTarget)) end
            HaveActionToAssign(refActionRepairUnit, 1, 5, oUnitToTarget)
        end
    end

    --Lower priority sending engineeres to other land and water zones
    --Send engineer to a land zone adjacent to this that wants support and lacks factories
    iCurPriority = iCurPriority + 1
    if iHighestTechEngiAvailable > 0 then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if bDebugMessages == true then LOG(sFunctionRef .. ': Lower priority About to see if have adjacent land zones wanting engineers, iHighestTechEngiAvailable=' .. iHighestTechEngiAvailable..'; Is table of adjacent LZs empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]))) end
        if iHighestTechEngiAvailable > 0 then
            --Do we haev adjacent land zone wanting engineer?
            local bWantBPOfOurTech
            local iMinTechWanted = 1

            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
                for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                    local iPlateau = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                    local iLandZone = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                    local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent LZ '..(iLandZone or 'nil')..' on plateau '..(iPlateau or 'nil')..'; Does this LZ want BP='..tostring(tLZTeamData[M28Map.subrefTbWantBP])..'; Dangerous enemies in this LZ='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])..'; Allied untis in this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]))) end
                    if tLZTeamData[M28Map.subrefTbWantBP] and not (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) then
                        bWantBPOfOurTech = false
                        for iTech = iHighestTechEngiAvailable, 1, -1 do
                            if tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                bWantBPOfOurTech = true
                                iMinTechWanted = iTech
                            end
                        end
                        if bWantBPOfOurTech then
                            --For now to keep things simple will ignore minimum engineer tech requirements
                            iLZSentTo = iLZSentTo + 1
                            if bDebugMessages == true then LOG(sFunctionRef..': About to try and send engineers to iLandZOne '..(iLandZone or 'nil')..'; iPlateau='..(iPlateau or 'nil')) end
                            --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted,            vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted)
                            HaveActionToAssign(refActionMoveToLandZone, iMinTechWanted, 10 * 2 * iLZSentTo, {iPlateau, iLandZone}, true)
                            if bDebugMessages == true then LOG(sFunctionRef..': Have flagged we want to send BP of '..10 * 2 * iLZSentTo..' to land zone '..iLandZone) end
                        end
                    end
                end
            end
        end
    end


    --Send engineer to a water zone near this that wants support, or alternatively a land zone adjacent to that water zone that wants support
    iCurPriority = iCurPriority + 1
    if iHighestTechEngiAvailable > 0 then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Lower priority About to check if have adjacent water zones wanting engineers, iHighestTechEngiAvailable=' .. iHighestTechEngiAvailable)
        end
        if iHighestTechEngiAvailable > 0 then
            local bWantBPOfOurTech
            local iMinTechWanted = 1
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                for iEntry, tSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                    local iAdjWZ = tSubtable[M28Map.subrefWZAWZRef]
                    local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
                    local tAltWZTeamData = tAltWZData[M28Map.subrefWZTeamData][iTeam]
                    local bWZOrAdjacentLZWantsEngineers
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Considering iAdjWZ=' .. iAdjWZ .. '; tAltWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]=' .. tostring(tAltWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] or false) .. '; tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]=' .. (tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0) .. '; tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. (tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) .. '; tAltWZTeamData[M28Map.subrefTbWantBP]=' .. tostring(tAltWZTeamData[M28Map.subrefTbWantBP]) .. '; WZ table of unclaimed mexes is empty=' .. tostring(M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefMexUnbuiltLocations])) .. '; WZ table of unbuilt hydro is empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefHydroUnbuiltLocations]))..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subrefTEnemyUnits])))
                    end
                    if (not (tAltWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) or (tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= math.min(6000, math.max(100, tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 0.75)) or (tAltWZTeamData[M28Map.subrefWZbCoreBase] and M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subrefTEnemyUnits]) and M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.reftLZEnemyAirUnits]) and (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20)))) then
                        --WZ is safe to go to, does the WZ want engineers and/or does it have an adjacent LZ that wants engineers?
                        bWZOrAdjacentLZWantsEngineers = tAltWZTeamData[M28Map.subrefTbWantBP]
                        bWantBPOfOurTech = false
                        if bWZOrAdjacentLZWantsEngineers then

                            for iTech = iHighestTechEngiAvailable, 1, -1 do
                                if tAltWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                    bWantBPOfOurTech = true
                                    iMinTechWanted = iTech
                                end
                            end
                        end
                        if not (bWantBPOfOurTech) and M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefAdjacentLandZones]) == false then

                            for iEntry, tSubtable in tAltWZData[M28Map.subrefAdjacentLandZones] do
                                local iPlateau = tSubtable[1]
                                local iLandZone = tSubtable[2]
                                local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                                if tLZTeamData[M28Map.subrefTbWantBP] and not (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) then
                                    bWantBPOfOurTech = false
                                    for iTech = iHighestTechEngiAvailable, 1, -1 do
                                        if tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                            bWantBPOfOurTech = true
                                            iMinTechWanted = iTech
                                        end
                                    end
                                    if bWantBPOfOurTech then
                                        bWZOrAdjacentLZWantsEngineers = true
                                        break
                                    end
                                end
                            end
                        end
                        if bWZOrAdjacentLZWantsEngineers and bWantBPOfOurTech then
                            iLZSentTo = iLZSentTo + 1
                            HaveActionToAssign(refActionMoveToWaterZone, iMinTechWanted, 10 * 2 * iLZSentTo, iAdjWZ, true)
                            if iLZSentTo >= 4 then break end
                        end
                    end
                end
            end
        end
    end

    --spare engis - If still have an engineer available and there is reclaim in the WZ of any kind, and we arent overflowing, then reclaim (but dont request engineers for this)
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.8 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] < 0.9 then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': iCurPriority=' .. iCurPriority .. '; considering if want to reclaim in the WZ, iHighestTechEngiAvailable=' .. iHighestTechEngiAvailable .. '; tWZData[M28Map.subrefTotalMassReclaim]=' .. (tWZData[M28Map.subrefTotalMassReclaim] or 0))
        end
        if iHighestTechEngiAvailable > 0 then
            if tWZData[M28Map.subrefTotalMassReclaim] >= 5 then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Will tell engineer to get lower priority reclaim, Total mass in pond ' .. iPond .. ' WZ ' .. iWaterZone .. '=' .. tWZData[M28Map.subrefTotalMassReclaim])
                end
                HaveActionToAssign(refActionReclaimArea, 1, 100, false, true)
            end
        end
    end

    --Spare engis - assist naval factory if dont ahve low mass
    iCurPriority = iCurPriority + 1
    if not (bHaveLowMass) and iExistingWaterFactory > 0 then
        --+5 BP a time assigned to naval factory
        HaveActionToAssign(refActionAssistNavalFactory, 1, 5, false, true, true)
    end

    UpdateSpareEngineerNumber(tWZTeamData, toAvailableEngineersByTech)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function ConsiderLandOrWaterZoneEngineerAssignment(tLZOrWZTeamData, iTeam, iPlateauOrPond, iLandOrWaterZone, tEngineers, bIsWaterZone)
    --tEngineers might be empty if e.g. we just want to record how much build power the land zone wants
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderLandOrWaterZoneEngineerAssignment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Start of code, iTeam=' .. iTeam .. '; iPlateauOrPond=' .. iPlateauOrPond .. '; iLandOrWaterZone=' .. iLandOrWaterZone .. '; is tEngineers empty=' .. tostring(M28Utilities.IsTableEmpty(tEngineers)) .. '; Is this a core base LZ=' .. tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or false) .. '; bIsWaterZone=' .. tostring(bIsWaterZone or false)..'; tLZOrWZTeamData[M28Map.subrefTbWantBP] before reset='..tostring(tLZOrWZTeamData[M28Map.subrefTbWantBP] or false))
    end

    --First clear any faction requests (will set to true again if we want to build something and dont have an engineer of the right faction for it)
    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted]) == false then
        for iFaction, bWantEngineers in tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted] do
            tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted][iFaction] = false
        end
    end

    if bIsWaterZone then
        ConsiderWaterZoneEngineerAssignment(tLZOrWZTeamData, iTeam, iPlateauOrPond, iLandOrWaterZone, tEngineers, bIsWaterZone)
    elseif tLZOrWZTeamData[M28Map.subrefLZbCoreBase] then
        ConsiderCoreBaseLandZoneEngineerAssignment(tLZOrWZTeamData, iTeam, iPlateauOrPond, iLandOrWaterZone, tEngineers)
    else
        --Not dealing with a core base
        ConsiderMinorLandZoneEngineerAssignment(tLZOrWZTeamData, iTeam, iPlateauOrPond, iLandOrWaterZone, tEngineers)
    end

    tLZOrWZTeamData[M28Map.subrefTbWantBP] = false --set to true later if any BP wanted
    --Reduce BP wanted by any engineers assigned to this LZ from another LZ
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Checking if engineers already assigned here, Is table of traveling engis empty=' .. tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere])) .. '; BP wanted pre update for traveling engis=' .. repru(tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted]))
    end
    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
        --Make sure the list of units traveling here is still accurate
        function KeepCurEntry(tArray, iEntry)
            if M28UnitInfo.IsUnitValid(tArray[iEntry]) then
                if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, tArray[iEntry].UnitId) then
                    if (tArray[iEntry][refiAssignedAction] == refActionRunToLandZone or tArray[iEntry][refiAssignedAction] == refActionMoveToLandZone) and tArray[iEntry][M28Land.reftiPlateauAndLZToMoveTo][2] == iLandOrWaterZone then
                        return true
                    elseif (tArray[iEntry][refiAssignedAction] == refActionMoveToWaterZone or tArray[iEntry][refiAssignedAction] == refActionRunToWaterZone) and tArray[iEntry][M28Navy.refiWZToMoveTo] == iLandOrWaterZone then
                        return true
                    else
                        return false

                    end
                else
                    --Not an engineer so dont remove from the table of traveling units as only concerned with removing engineers no longer assigned to do this
                    return true
                end
            else
                return false
            end
        end

        M28Utilities.RemoveEntriesFromArrayBasedOnCondition(tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere], KeepCurEntry)
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
            local tTravelingEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere])
            local iCurEngiTechLevel
            if M28Utilities.IsTableEmpty(tTravelingEngineers) == false then
                for iUnit, oUnit in tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere] do
                    --Refresh list of traveling engineers in case it is invalid

                    if M28UnitInfo.IsUnitValid(oUnit) then
                        --Is the engi still actually travelling here?
                        iCurEngiTechLevel = M28UnitInfo.GetUnitTechLevel(oUnit)
                        for iTech = iCurEngiTechLevel, 1, -1 do
                            if tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] = tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] - oUnit:GetBlueprint().Economy.BuildRate
                                break
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': BP wanted after updating for traveling engineers=' .. repru(tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted]))
            end
        end
    end

    --Cap BP wanted for non-core LZs and all WZs if enemies in the zone or adjacent
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering capping engis wnated for noncore zones; tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil') .. '; tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]=' .. tostring(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or false))
    end
    if not (tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and not (tLZOrWZTeamData[M28Map.subrefWZbCoreBase]) then
        local iBPCap
        if (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) > 10 or (bIsWaterZone and tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 10) then
            iBPCap = 0
            --Clear any engineers already traveling here
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Setting BP cap to 0 and clearing engineers traveling here')
            end
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
                local tTravelingEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere])
                if M28Utilities.IsTableEmpty(tTravelingEngineers) == false then
                    for iEngi, oEngi in tTravelingEngineers do
                        M28Orders.IssueTrackedClearCommands(oEngi)
                    end
                end
            end
        elseif tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] then
            iBPCap = 5
        end
        if iBPCap then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': have iBPCap of ' .. iBPCap .. '; so will limit BP wanted for this LZ')
            end
            for iTech = 1, 3 do
                if tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > iBPCap then
                    tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] = iBPCap
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if zone wants BP for any tech level 1-3, tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted]='..repru(tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted])) end
    for iTech = 1, 3 do
        if tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': Zone wants BP so setting flag to true') end
            tLZOrWZTeamData[M28Map.subrefTbWantBP] = true
            break
        end
    end
    --Clear the BP wanted flag if this is a pacifist zone
    if M28Overseer.bPacifistModeActive and tLZOrWZTeamData[M28Map.subrefTbWantBP] then
        local tLZOrWZData
        if bIsWaterZone then
            tLZOrWZData = M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        else
            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        end
        if tLZOrWZData[M28Map.subrefbPacifistArea] then
            tLZOrWZTeamData[M28Map.subrefTbWantBP] = false
            for iTech = 1, 3 do
                tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] = 0
            end
        end
    end

    --Clear any BP wanted if norush active and dealing with a non-core LZ outside any M28 norush raidius
    if M28Overseer.bNoRushActive and M28Overseer.iNoRushTimer - GetGameTimeSeconds() > 30 and tLZOrWZTeamData[M28Map.subrefTbWantBP] and not (tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and not (tLZOrWZTeamData[M28Map.subrefWZbCoreBase]) then
        local tLZOrWZData
        if bIsWaterZone then
            tLZOrWZData = M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        else
            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        end
        if M28Utilities.GetDistanceBetweenPositions(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], tLZOrWZData[M28Map.subrefMidpoint]) > M28Overseer.iNoRushRange then
            for iTech = 1, 3 do
                tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] = 0
            end
            tLZOrWZTeamData[M28Map.subrefTbWantBP] = false
            if bDebugMessages == true then LOG(sFunctionRef..': No rush override - clearing any BP wanted') end
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Finished updating the BP wanted for this land or water zone '..iLandOrWaterZone..'; iPlateauOrPond='..iPlateauOrPond..'; tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted]=' .. repru(tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted]) .. '; tLZOrWZTeamData[M28Map.subrefTbWantBP]=' .. tostring(tLZOrWZTeamData[M28Map.subrefTbWantBP]))
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckDestroyedBuildingLocations()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckDestroyedBuildingLocations'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iLastEntryToRemove
    local aiBrain
    for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
        aiBrain = oBrain
        if not(oBrain.M28IsDefeated) then
            break
        end
    end

    for iEntry, tSubtable in tRecentlyDestroyedBuildings do
        --As a rough test, in sandbox it looked like an Aeon T2 shield took about 3.5s to complete, so will go with 3.9s to be safe
        if GetGameTimeSeconds() - tSubtable[subrefDestroyedBuildingTime] >= 3.9 then
            iLastEntryToRemove = iEntry
            local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tSubtable[subrefDestroyedBuildingLocation])
            local tLZOrWZData
            local tZoneBySegmentRef
            local tBlueprintSizeTableRef
            if iPlateauOrZero > 0 then
                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                tZoneBySegmentRef = M28Map.tLandZoneBySegment
                tBlueprintSizeTableRef = tsBlueprintsBySize
            elseif iPlateauOrZero == 0 then
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                tZoneBySegmentRef = M28Map.tWaterZoneBySegment
                tBlueprintSizeTableRef = tsWZBlueprintsBySize
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iENtry='..iEntry..'; repru='..repru(tSubtable)) end
            if iLandOrWaterZone > 0 then
                local iBuildingSize = M28UnitInfo.GetBuildingSize(tSubtable[subrefDestroyedBuildingBlueprint])
                local iBaseSegmentX, iBaseSegmentZ = M28Map.GetPathingSegmentFromPosition(tSubtable[subrefDestroyedBuildingLocation])
                --local iAffectedDistanceRadius = math.min(math.max(iBuildingSize, 8), iBuildingSize * 0.5 + iMaxBuildingSize * 0.5)

                if aiBrain then
                    SearchForBuildableLocationsNearTarget(aiBrain, tLZOrWZData, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, iBaseSegmentX, iBaseSegmentZ, iBuildingSize * 0.5)

                    --Record any mass storage locations
                    if iPlateauOrZero > 0 then
                        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZMexLocations]) == false then
                            local bHaveNearbyMex = false
                            local iPotentialStorageDistance = iBuildingSize * 0.5 + 3
                            for iMex, tMex in tLZOrWZData[M28Map.subrefLZMexLocations] do
                                if M28Utilities.GetRoughDistanceBetweenPositions(tMex, tSubtable[subrefDestroyedBuildingLocation]) <= iPotentialStorageDistance then
                                    bHaveNearbyMex = true
                                    break
                                end
                            end
                            if bHaveNearbyMex then
                                M28Map.RecordAvailableMassStorageLocationsForLandZone(iPlateauOrZero, iLandOrWaterZone)
                            end
                        end
                    end
                else
                    M28Utilities.ErrorHandler('No longer have M28 brain')
                end
            end
        else
            iLastEntryToRemove = iEntry - 1
            break
        end
    end
    if iLastEntryToRemove > 0 then
        for iEntry = iLastEntryToRemove, 1, -1 do
            table.remove(tRecentlyDestroyedBuildings, iEntry)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DestroyedBuildingLocationMonitor()
    if not(bActiveDestroyedBuildingLoop) then
        while M28Utilities.bM28AIInGame do
            WaitTicks(1)
            if M28Utilities.IsTableEmpty(tRecentlyDestroyedBuildings) == false then
                ForkThread(CheckDestroyedBuildingLocations)
            end
        end
    end
end

function EngineerInitialisation(aiBrain)
    --Variable declaration
    aiBrain[refiEngineerCurUniqueReference] = 0

    if not (bBuildLocationLoopActive) then
        ForkThread(SlowlyRefreshBuildableLandZoneLocations, aiBrain)
        ForkThread(DestroyedBuildingLocationMonitor)
    end
    if not (bWZBuildLocationLoopActive) then
        ForkThread(RecordBuildableCoreWaterZoneLocationsNearStartOfGame)
    end
end

function GetBPToAssignToBuildingTML(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam, bHaveLowMass)
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPToAssignToBuildingTML'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iBPWanted = 0
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': TIme=' .. GetGameTimeSeconds() .. ' iPlateau=' .. iPlateau .. '; bHaveLowMass=' .. tostring(bHaveLowMass) .. '; Is core base=' .. tostring(tLZTeamData[M28Map.subrefLZbCoreBase]) .. '; is core expansion=' .. tostring(tLZTeamData[M28Map.subrefLZCoreExpansion]) .. '; iLandZone=' .. iLandZone)
    end
    if tLZTeamData[M28Map.subrefLZbCoreBase] or (tLZTeamData[M28Map.subrefLZCoreExpansion] and not (bHaveLowMass)) then
        --Make sure we have recorded pathing in a straight line for this zone (will only run if table is empty)
        M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint])

        if bDebugMessages == true then
            LOG(sFunctionRef .. ': M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] .. '; Is table of pathing to other LZ and WZ empty=' .. tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance])))
        end
        --Decided to remove the check about max enemy tech, as they may have T2 mexes but T1 units, and performance isn't as big a concern early-game anyway
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
            --Do we have any TML in this LZ already?
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Do we already have TML in this LZ? Is table of TML empty=' .. tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryTML, tLZTeamData[M28Map.subrefLZTAlliedUnits]))))
            end
            if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryTML, tLZTeamData[M28Map.subrefLZTAlliedUnits])) then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': About to cycle through every land zone and consider targets')
                end
                for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Zone ' .. tSubtable[M28Map.subrefiLandOrWaterZoneRef] .. ' is distance ' .. tSubtable[M28Map.subrefiDistance] .. ' away')
                    end
                    if tSubtable[M28Map.subrefiDistance] <= M28Building.iTMLMissileRange then
                        if not (tSubtable[M28Map.subrefbIsWaterZone]) then
                            local tAltLZTeamData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]][M28Map.subrefLZTeamData][iTeam]
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Considering enemy zone ' .. tSubtable[M28Map.subrefiLandOrWaterZoneRef] .. '; Is table of enemy TMD empty=' .. tostring(M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoEnemyTMD])) .. '; is talbe of enemy potential targets empty=' .. tostring(M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoEnemyTMD])))
                            end
                            if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoEnemyTMD]) == false then
                                --Refresh the table
                                local iLastEntry = table.getn(tAltLZTeamData[M28Map.subreftoEnemyTMD])
                                for iCurEntry = iLastEntry, 1, -1 do
                                    if not (M28UnitInfo.IsUnitValid(tAltLZTeamData[M28Map.subreftoEnemyTMD][iCurEntry])) then
                                        table.remove(tAltLZTeamData[M28Map.subreftoEnemyTMD], iCurEntry)
                                    end
                                end
                                if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoEnemyTMD]) == false then
                                    break
                                end
                            end
                            if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets]) == false then
                                --Refresh the list of potential targets
                                local iLastEntry = table.getn(tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets])
                                for iCurEntry = iLastEntry, 1, -1 do
                                    if not (M28UnitInfo.IsUnitValid(tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets][iCurEntry])) then
                                        table.remove(tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets], iCurEntry)
                                    end
                                end
                                if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets]) == false then
                                    iBPWanted = 40
                                    if not (bHaveLowMass) then
                                        iBPWanted = 80
                                    end
                                    break
                                end
                            end
                        end
                    else
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Remaining zones out of range so will abort')
                        end
                        break
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBPWanted
end

function GetStartSearchPositionForEmergencyPD(tTargetBuildLocation, tLZMidpoint, iPlateau, iLandZone)
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetStartSearchPositionForEmergencyPD'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iAngleFromTargetToMidpoint = M28Utilities.GetAngleFromAToB(tTargetBuildLocation, tLZMidpoint)
    local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(tTargetBuildLocation, tLZMidpoint)
    local iDistToMove = math.max(25, iDistToTarget * 0.6)
    if iDistToTarget - iDistToMove >= 60 then
        iDistToMove = iDistToTarget - 60
    end
    local tTargetLocation = M28Utilities.MoveInDirection(tTargetBuildLocation, iAngleFromTargetToMidpoint, iDistToMove, true, false, true)
    --Adjust if we end up out of the zone
    local iTargetPlateau, iTargetLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Time ' .. GetGameTimeSeconds() .. '; First position with iDistToMove=' .. iDistToMove .. '=' .. repru(tTargetLocation) .. '; tLZMidpoint=' .. repru(tLZMidpoint) .. '; tTargetBuildLocation=' .. repru(tTargetBuildLocation) .. '; Dist to midpoint=' .. M28Utilities.GetDistanceBetweenPositions(tTargetBuildLocation, tLZMidpoint) .. '; Dist to original target=' .. M28Utilities.GetDistanceBetweenPositions(tTargetBuildLocation, tTargetLocation) .. '; iTargetPlateau=' .. (iTargetPlateau or 'nil') .. '; iTargetLandZone=' .. (iTargetLandZone or 'nil'))
    end
    while not (iLandZone == iTargetLandZone) do
        iDistToMove = iDistToMove + 5
        if iDistToMove > iDistToTarget then
            tTargetLocation = tLZMidpoint
            break
        end
        tTargetLocation = M28Utilities.MoveInDirection(tTargetBuildLocation, iAngleFromTargetToMidpoint, iDistToMove, true, false, true)
        iTargetPlateau, iTargetLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
    end

    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Time=' .. GetGameTimeSeconds() .. '; tTargetBuildLocation=' .. repru(tTargetBuildLocation) .. '; tLZMidpoint=' .. repru(tLZMidpoint) .. '; iAngleFromTargetToMidpoint=' .. iAngleFromTargetToMidpoint .. '; iDistToTarget=' .. iDistToTarget .. '; iDistToMove=' .. iDistToMove .. '; tTargetLocation=' .. repru(tTargetLocation))
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tTargetLocation
end

function GetMaxShieldSearchRangeForEngineer(oFirstEngineer, iCategoryWanted)
    --Sets max search range to ensure we dont go outside the max shield radius available to oFirstEngineer
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetMaxShieldSearchRangeForEngineer'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tsAvailableBlueprints = M28Factory.GetBlueprintThatCanBuildOfCategory(oFirstEngineer:GetAIBrain(), iCategoryWanted, oFirstEngineer)
    local iMaxSearchRange = 10 --Default in case something goes wrong
    if M28Utilities.IsTableEmpty(tsAvailableBlueprints) == false then
        for iShield, sShield in tsAvailableBlueprints do
            iMaxSearchRange = math.max(iMaxSearchRange, (__blueprints[sShield].ShieldSize or 0) * 0.5)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iMaxSearchRange
end

function ClearEngineersBuildingUnit(oEngineer, oJustBuilt)
    --Note - oJustBuilt can also be a unit under construction (e.g. if we want to cancel construction and reclaim it)
    local iAction = oEngineer[refiAssignedAction]
    if tiActionOrder[iAction] == M28Orders.refiOrderIssueBuild and not (tbIgnoreEngineerAssistance[iAction]) then
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oEngineer:GetPosition())
        if (iLandOrWaterZone or 0) > 0 then
            local tLZOrWZTeamData
            local aiBrain = oEngineer:GetAIBrain()
            local iTeam = aiBrain.M28Team
            if iPlateauOrZero == 0 then
                tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
            else
                tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
            end
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
                local tAllEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits])
                if M28Utilities.IsTableEmpty(tAllEngineers) == false then
                    for iUnit, oUnit in tAllEngineers do
                        if M28UnitInfo.IsUnitValid(oUnit) and oUnit[refiAssignedAction] == iAction and not (oUnit:IsUnitState('Reclaiming')) then
                            local tLastOrder = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]]
                            if (M28Utilities.IsTableEmpty(tLastOrder[M28Orders.subreftOrderPosition]) == false and M28Utilities.GetDistanceBetweenPositions(tLastOrder[M28Orders.subreftOrderPosition], oJustBuilt:GetPosition()) <= 1) or tLastOrder[M28Orders.subrefoOrderUnitTarget] == oJustBuilt then
                                M28Orders.IssueTrackedClearCommands(oUnit)
                            end
                        end
                    end
                end
            end

        end
    end

end

function ClearEngineersWhoseTargetIsNowBlockedByUnitConstructionStarted(oEngineer, oConstruction)
    --Idea is to prevent scenarios where two units get queued orders for the same location - once construction is started for one, it wont be possible for the other
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ClearEngineersWhoseTargetIsNowBlockedByUnitConstructionStarted'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iAction = oEngineer[refiAssignedAction]
    if tiActionOrder[iAction] == M28Orders.refiOrderIssueBuild then
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oConstruction:GetPosition())
        if (iLandOrWaterZone or 0) > 0 then
            local tLZOrWZTeamData
            local aiBrain = oEngineer:GetAIBrain()
            local iTeam = aiBrain.M28Team
            if iPlateauOrZero == 0 then
                tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
            else
                tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
            end
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
                local tAllEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits])
                if M28Utilities.IsTableEmpty(tAllEngineers) == false then
                    local iBuildingSizeRadius = M28UnitInfo.GetBuildingSize(oConstruction.UnitId) * 0.5
                    local iQueuedBuildingSizeRadius
                    for iUnit, oUnit in tAllEngineers do
                        if M28UnitInfo.IsUnitValid(oUnit) and oUnit[refiAssignedAction] and not (oUnit[refiAssignedAction] == iAction) and not (oUnit:IsUnitState('Reclaiming')) and tiActionOrder[oUnit[refiAssignedAction]] == M28Orders.refiOrderIssueBuild then
                            local tLastOrder = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]]
                            if tLastOrder[M28Orders.subrefsOrderBlueprint] then
                                if M28Utilities.IsTableEmpty(tLastOrder[M28Orders.subreftOrderPosition]) == false then
                                    iQueuedBuildingSizeRadius = M28UnitInfo.GetBuildingSize(tLastOrder[M28Orders.subrefsOrderBlueprint]) * 0.5
                                    if M28Utilities.GetRoughDistanceBetweenPositions(tLastOrder[M28Orders.subreftOrderPosition], oConstruction:GetPosition()) < iBuildingSizeRadius + iQueuedBuildingSizeRadius then
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Clearing engineer ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. ' as it has a queued order ' .. reprs(tLastOrder) .. ' that is blocked by oConstruction=' .. oConstruction.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oConstruction.UnitId))
                                        end
                                        M28Orders.IssueTrackedClearCommands(oUnit)
                                    end
                                end
                            end
                        end
                    end
                end
            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function ConsiderDestroyingLowTechEngineers(oJustBuilt)
    --Intended late game where lots of low tech engis in a core base
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderDestroyingLowTechEngineers'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain = oJustBuilt:GetAIBrain()
    local iCurEngineers = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer)
    if iCurEngineers >= 100 then
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oJustBuilt:GetPosition())
        if (iLandOrWaterZone or 0) > 0 then
            local tLZOrWZTeamData
            local iTeam = aiBrain.M28Team
            if iPlateauOrZero == 0 then
                tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
            else
                tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
            end
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
                local tT1AndT2EngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer * categories.TECH1 + M28UnitInfo.refCategoryEngineer * categories.TECH2, tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits])
                if M28Utilities.IsTableEmpty(tT1AndT2EngineersInZone) == false then
                    local iT1AndT2EngineersInZone = table.getn(tT1AndT2EngineersInZone)
                    if iT1AndT2EngineersInZone >= 10 or (iCurEngineers >= 150 and iT1AndT2EngineersInZone >= 4) then
                        local tT3EngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer * categories.TECH3, tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits])

                        if M28Utilities.IsTableEmpty(tT3EngineersInZone) == false then
                            local iT3EngineersInZone = table.getn(tT3EngineersInZone)
                            if iT3EngineersInZone >= 40 then
                                --Ctrl-K up to 3 engineers
                                local iEngineersKilled = 0
                                local tT1Engineers = EntityCategoryFilterDown(categories.TECH1, tT1AndT2EngineersInZone)
                                local iT1Count = 0
                                function KillEngineerIfSufficientlyIdle(oEngi)
                                    if not (oEngi[refbPrimaryBuilder]) and not (oEngi:IsUnitState('Building')) and not (oEngi:IsUnitState('Reclaiming')) and not (oEngi:IsUnitState('Capturing')) and not (oEngi:IsUnitState('Repairing')) then
                                        if bDebugMessages == true then LOG(sFunctionRef .. ': Just given order to kill unit ' .. oEngi.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oEngi) .. ' as have oto many engis in this zone') end
                                        M28Orders.IssueTrackedKillUnit(oEngi)
                                        iEngineersKilled = iEngineersKilled + 1
                                    end
                                end
                                if M28Utilities.IsTableEmpty(tT1Engineers) == false then
                                    for iUnit, oUnit in tT1Engineers do
                                        KillEngineerIfSufficientlyIdle(oUnit)
                                        if iEngineersKilled >= 3 then
                                            break
                                        end
                                    end
                                end
                                if iEngineersKilled < 3 then
                                    local tT2Engineers = EntityCategoryFilterDown(categories.TECH2, tT1AndT2EngineersInZone)
                                    if M28Utilities.IsTableEmpty(tT2Engineers) == false then
                                        for iUnit, oUnit in tT2Engineers do
                                            KillEngineerIfSufficientlyIdle(oUnit)
                                            if iEngineersKilled >= 3 then
                                                break
                                            end
                                        end
                                    end
                                end

                            end
                        end
                    end
                end
            end
        end
    end
end

function RecordUnitAsCaptureTarget(oUnit, bOptionalOnlyRecordIfSameUnitIdInCaptureList)
    --bOptionalOnlyRecordIfSameUnitIdInCaptureList - true if we only want to record oUnit if a unit with the same .UnitId is in the zone as a capture target - i.e. intended where a unit is captured that can be captured back
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordUnitAsCaptureTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
    local tLZOrWZData
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..';  oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; Unit position='..repru(oUnit:GetPosition())..'; Unit owner='..oUnit:GetAIBrain().Nickname) end
    if iLandOrWaterZone > 0 then
        if iPlateauOrZero == 0 then
            tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        else
            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        end
        --If this was called via onunitcaptured then want to check if the same unitid was recorded in a table of capture targets:
        local bWantToCaptureUnit = not(bOptionalOnlyRecordIfSameUnitIdInCaptureList)
        if bOptionalOnlyRecordIfSameUnitIdInCaptureList then
            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subreftoUnitsToCapture]) == false then
                for iCaptureTarget, oCaptureTarget in tLZOrWZData[M28Map.subreftoUnitsToCapture] do
                    if oCaptureTarget.UnitId == oUnit.UnitId then
                        bWantToCaptureUnit = true
                        break
                    end
                end
            end
        end

        --Check we havent already recorded this unit
        if bWantToCaptureUnit and oUnit[M28UnitInfo.refbIsCaptureTarget] and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subreftoUnitsToCapture]) == false then
            for iRecordedUnit, oRecordedUnit in tLZOrWZData[M28Map.subreftoUnitsToCapture] do
                if oRecordedUnit == oUnit then
                    bWantToCaptureUnit = false
                    break
                end
            end
        end

        --Record unit against zone as a capture target and flag so we dont try and reclaim it
        if bDebugMessages == true then LOG(sFunctionRef..': bWantToCaptureUnit='..tostring(bWantToCaptureUnit)..'; oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')) end
        if bWantToCaptureUnit then
            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subreftoUnitsToCapture]) then tLZOrWZData[M28Map.subreftoUnitsToCapture] = {} end
            table.insert(tLZOrWZData[M28Map.subreftoUnitsToCapture], oUnit)
            oUnit[M28UnitInfo.refbIsCaptureTarget] = true
            if bDebugMessages == true then LOG(sFunctionRef..': Added unit to table of units to capture') end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckForSpecialCampaignCaptureTargets()
    --Called whenever we get a new objective or the map size changes, as a basic way of checking for extra objectives that dont use the normal objective function
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckForSpecialCampaignCaptureTargets'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --FA M6 - check for control centre building
    if bDebugMessages == true then LOG(sFunctionRef..': is ControlCentreBldg nil='..tostring(ScenarioInfo.ControlCenterBldg == nil)) end
    if ScenarioInfo.ControlCenterBldg then
        local oControlCentre = ScenarioInfo.ControlCenterBldg
        if bDebugMessages == true then LOG(sFunctionRef..': oControlCentre='..(oControlCentre.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oControlCentre) or 'nil')..'; Is capturable='..tostring(oControlCentre:IsCapturable())..'; refbIsCaptureTarget='..tostring(oControlCentre[M28UnitInfo.refbIsCaptureTarget] or false)) end
        if M28UnitInfo.IsUnitValid(oControlCentre) and oControlCentre:IsCapturable() then
            --Have we already recorded as a capturable target?
            if not(oControlCentre[M28UnitInfo.refbIsCaptureTarget]) then
                --Get first M28 brain in game
                local oFirstM28Brain
                if M28Utilities.IsTableEmpty(M28Overseer.tAllActiveM28Brains) == false then
                    for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                        if oBrain.M28AI then
                            oFirstM28Brain = oBrain
                            break
                        end
                    end
                end
                if oFirstM28Brain and not(IsAlly(oFirstM28Brain:GetArmyIndex(), oControlCentre:GetAIBrain():GetArmyIndex())) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will call logic to record control centre as a capture target') end
                    RecordUnitAsCaptureTarget(oControlCentre)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end