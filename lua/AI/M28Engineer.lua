---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 19:23
---
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Config = import('/mods/M28AI/lua/M28Config.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')



--Global variables
bBuildLocationLoopActive = false --true if have a loop that is checking for build locations
bWZBuildLocationLoopActive = false --as above but for water zones
tsBlueprintsBySize = {[1] = 'ueb2101', [2] = 'ueb1101', [3] = 'ueb4302', [6] = 'ueb1201', [8] = 'ueb1301', [9]='xrl0403', [10]='uab0304', [16] = 'xsa0402', [24] = 'uaa0310'} --Blueprints to use when trying to find locations that can buid on for a building of a particular size
tsWZBlueprintsBySize = {[1] = 'ueb2109', [2] = 'ueb4201', [6] = 'ual0401', [8] = 'ura0401', [9]='uel0401', [10]='ueb0103', [14]='ueb0103', [16]='uas0401', [24]='uaa0310'} --Blueprints to use when trying to find locations that can buid on on water for a building/engineer built unit of a particular size
iMaxBuildingSize = 24
--Some blueprints have different skirt size offsets, e.g. naval factories; current solution is to manually note any of the BlueprintsBySize blueprints above and then list alternatives to try
tsExtraBlueprintsToCheck = {['ueb0103'] = {'urb0103', 'xsb0103'},
}
tAllScathis = {} --If a scathis is constructed it gets recorded here (and we then check this for build locations to avoid trying to build on a scathis); for performance reasons will just use a single global table
tiBPByTech = {[0]=5,[1]=5,[2]=12.5,[3]=30, [4]=30}
iCurQueueRefNumber = 0

bActiveDestroyedBuildingLoop = false
tRecentlyDestroyedBuildings = {} --ordered 1, 2,..x
    subrefDestroyedBuildingBlueprint = 'DBP' --blueprint only
    subrefDestroyedBuildingLocation = 'DPS' --'Location, i.e. {xyz}
    subrefDestroyedBuildingTime = 'DTM' --gametimeseconds

--against brain:
--refiEngineerCurUniqueReference - this is also against unit so is declared in below section rather than here

--Against unit varaibles
refiEngineerCurUniqueReference = 'M28EngCurUniqueReference' --Against both aiBrain and engineer; aiBrain stores the xth engineer object its given an action to, so this can be used as a unique reference
refiAssignedAction = 'M28EngAssignedAction' --against Engineer, records the refAction value the engineer was given if it has an active order
reftAssignedReclaimSegments = 'M28EngReclaimSegments' --against engineer, returns {iReclaimSegmentX, iReclaimSegmentZ]}, used when engineer givne a reclaim area order
refbPrimaryBuilder = 'M28EngPrimaryBuilder' --If was the first engineer assigned to build something (and isnt assisting) then this should be true
refbHasSpareAction = 'M28EngSpareA' --true if engineer has spare action, nil or false if it doesnt
reftUnitsReclaimingUs = 'M28EngReclaimingUnits' --If have queued up reclaim order on a unit, this will store all units given such an order
reftUnitsWeAreReclaiming = 'M28EngUnitsReclaiming' --If have queued up reclaim order on a unit, this stors against the reclaimer the unit being reclaimed
reftQueuedBuildings = 'M28EngQueuedBuildings' --Whenever issuebuild order is given it should update this
subrefQueueRef = 1 --Unique queue reference number (the same as the ref number given to the land zone)
subrefBuildingID = 2 --Blueprint/UnitId of the building queued
subrefBuildingLocation = 3 --Location the building is to be built at
subrefBuildingRadius = 4 --Size (radius) of the building
subrefPlateauOrZero = 5 --Plateau where hte building is to be built; zero if water zone
subrefLandOrWaterZone = 6 --Land zone where hte building is to be built
refbBuildingExperimental = 'M28EngBuildingExperimental' --True if engineer is building an experimental andh aving itself tracked in the team table for this
refiAssignedActionPriority = 'M28EngPriority' --Priority of the currently assigned action
reftUnitBlacklistSegmentXZ = 'M28UnitBlacklist' --table, ordered 1, 2...', returns {SegmentX, SegmentZ} - contains blacklist details for a unit, used for under construciton experimentals so when construction completes the blacklist status can be cleared

--Shield related variables against a unit
refiFailedShieldBuildDistance = 'M28EngFailedShieldBuildDist' --against a building wanting shielding - records the distance of the closest location that we can build (so can decide if the unit can even be shielded)
refiFailedShieldConstructionCount = 'M28EngFailedShdCnt' --Number of times we have tried to get a build locatino to cover this unit and failed
refoUnitActivelyShielding = 'M28EngUntActShd' --against the engineer, gives the unit e.g. gameender it is providing special shielding services to
refbActiveUnitShieldingThread = 'M28EngActivShld' --against the gameender/similar unit, true if it has a thread that isa ctively trying to use engineers to protect it
reftEngineersActivelyShielding = 'M28EngActiveEngShd' --against the gameender/similar unit, contains table of all the engineers assigned toa ctively try and protect it
refbDontIncludeAsPartCompleteBuildingForConstruction = 'M28EngActiveShdD' --True if shield is being used for active special shielding defence - i.e. will check for this flag to make sure a normal build shield action doenst assist it
refiTimeOfLastShieldRepairOrder = 'M28EngTimeLastOrd' --For units that are repairing, dont want to reissue the same order multiple times


--Actions for engineers (dont have as local variables due to cap on how many local variables we can have)
--Intended actions are those from M27 that havent been integrated yet
refActionBuildMex = 1
refActionBuildHydro = 2
refActionReclaimArea = 3
refActionBuildPower = 4
refActionBuildLandFactory = 5
refActionBuildEnergyStorage = 6
refActionSpare = 7
refActionHasNearbyEnemies = 8
refActionUpgradeBuilding = 9
refActionBuildSecondPower = 10
refActionBuildAirStaging = 11
refActionBuildAirFactory = 12
refActionBuildSMD = 13
refActionBuildMassStorage = 14
refActionBuildT1Radar = 15
refActionBuildT2Radar = 16
refActionBuildT3Radar = 17
refActionAssistSMD = 18
refActionAssistAirFactory = 19
refActionBuildThirdPower = 20
refActionBuildExperimental = 21
refActionReclaimFriendlyUnit = 22
--See below for reclaimenemyunit action
refActionBuildT3MexOverT2 = 23
refActionUpgradeHQ = 24 --Assists an HQ with its upgrade
refActionReclaimTrees = 25
refActionBuildT1Sonar = 26
refActionBuildT2Sonar = 27
refActionAssistNuke = 28
refActionBuildShield = 29
refActionBuildT3ArtiPower = 30
refActionBuildTMD = 31
refActionBuildAA = 32
refActionBuildEmergencyPD = 33 --Indented values below mean not yet got the main code in place
refActionBuildSecondLandFactory = 34
refActionBuildSecondAirFactory = 35
refActionBuildTML = 36
refActionBuildSecondExperimental = 37
refActionLoadOntoTransport = 38
refActionFortifyFirebase = 39
refActionAssistShield = 40
refActionBuildSecondShield = 41
refActionBuildEmergencyArti = 42 --Not yet got the main code in place that M27 used, for now just have basic placeholder that builds T2 the same as a normal building
refActionAssistTML = 43
refActionBuildQuantumGateway = 44
refActionBuildQuantumOptics = 45
refActionBuildHive = 46
refActionSelenMexBuild = 47
refActionBuildSecondTMD = 48
refActionBuildNavalFactory = 49
refActionAssistNavalFactory = 50
refActionNavalSpareAction = 51
refActionBuildWall = 52 --E.g. for building walls around T1 PD
refActionBuildT3MexOnly = 53
refActionAssistMexUpgrade = 54
refActionSAMCreep = 55 --Intended to gradually expand SAM coverage for mexes
refActionBuildMassFab = 56 --For T2 mass fabs to be built by mass storage
refActionMoveToLandZone = 57
refActionRunToLandZone = 58
refActionMoveToWaterZone = 59
refActionRunToWaterZone = 60
refActionAssistUpgrade = 61
refActionReclaimEnemyUnit = 62
refActionBuildSecondMassStorage = 63
refActionCompletePartBuiltMex = 64
refActionBuildExperimentalNavy = 65
refActionBuildGameEnder = 66
refActionBuildLandExperimental = 67 --e.g. for when building in water
refActionCaptureUnit = 68
refActionRepairUnit = 69 --e.g. can use to repair an underconstruction building
refActionSpecialShieldDefence = 70 --Covers the building of shields, but uses different approach to normal, intended for protecting a game ender from sustained T3 arti fire
refActionBuildT3MassFab = 71 --Just for building t3 mass fab

--tiEngiActionsThatDontBuild = {refActionReclaimArea, refActionSpare, refActionNavalSpareAction, refActionHasNearbyEnemies, refActionReclaimFriendlyUnit, refActionReclaimTrees, refActionUpgradeBuilding, refActionAssistSMD, refActionAssistTML, refActionAssistMexUpgrade, refActionAssistAirFactory, refActionAssistNavalFactory, refActionUpgradeHQ, refActionAssistNuke, refActionLoadOntoTransport, refActionAssistShield}

tiLastBuildingSizeFromActionForTeam = {} --[x] is the team ref, [y] is the action ref, returns the building size (if there was one), used to help stop logic if we have run out of places to build

--Categories to use where no complex logic required (if it wont always be the same category then add logic to GetCategoryToBuildOrAssistFromAction
tiActionCategory = {
    [refActionBuildMex] = M28UnitInfo.refCategoryT1Mex,
    [refActionBuildHydro] = M28UnitInfo.refCategoryHydro,
    [refActionBuildPower] = M28UnitInfo.refCategoryPower - categories.NAVAL, --some mods like xtremewars add a naval power building
    [refActionBuildLandFactory] = M28UnitInfo.refCategoryLandFactory,
    [refActionBuildSecondPower] = M28UnitInfo.refCategoryPower - categories.NAVAL,
    [refActionBuildAirStaging] = M28UnitInfo.refCategoryAirStaging,
    [refActionBuildAirFactory] = M28UnitInfo.refCategoryAirFactory,
    [refActionBuildSecondAirFactory] = M28UnitInfo.refCategoryAirFactory,
    [refActionBuildSMD] = M28UnitInfo.refCategorySMD,
    [refActionBuildMassStorage] = M28UnitInfo.refCategoryMassStorage,
    [refActionBuildT1Radar] = M28UnitInfo.refCategoryT1Radar,
    [refActionBuildT2Radar] = M28UnitInfo.refCategoryT2Radar,
    [refActionBuildT3Radar] = M28UnitInfo.refCategoryT3Radar,
    [refActionAssistSMD] = M28UnitInfo.refCategorySMD,
    [refActionAssistAirFactory] = M28UnitInfo.refCategoryAirFactory,
    [refActionBuildEnergyStorage] = M28UnitInfo.refCategoryEnergyStorage,
    [refActionBuildThirdPower] = M28UnitInfo.refCategoryPower - categories.NAVAL,
    [refActionBuildT1Sonar] = M28UnitInfo.refCategoryT1Sonar,
    [refActionBuildT2Sonar] = M28UnitInfo.refCategoryT2Sonar,
    [refActionBuildShield] = M28UnitInfo.refCategoryFixedShield,
    [refActionBuildSecondShield] = M28UnitInfo.refCategoryFixedShield,
    [refActionBuildNavalFactory] = M28UnitInfo.refCategoryNavalFactory,
    [refActionAssistNavalFactory] = M28UnitInfo.refCategoryNavalFactory,
    [refActionBuildTMD] = M28UnitInfo.refCategoryTMD,
    [refActionBuildAA] = M28UnitInfo.refCategoryStructureAA,
    --refActionBuildEmergencyPD - will use custom code as sometimes want T1 PD
    [refActionBuildEmergencyArti] = M28UnitInfo.refCategoryFixedT2Arti,
    [refActionBuildQuantumGateway] = M28UnitInfo.refCategoryQuantumGateway,
    [refActionBuildSecondLandFactory] = M28UnitInfo.refCategoryLandFactory,
    [refActionBuildTML] = M28UnitInfo.refCategoryTML,
    [refActionAssistShield] = M28UnitInfo.refCategoryFixedShield * categories.TECH3,
    [refActionBuildSecondMassStorage] = M28UnitInfo.refCategoryMassStorage,
    [refActionCompletePartBuiltMex] = M28UnitInfo.refCategoryT1Mex,
    [refActionBuildExperimentalNavy] = categories.NAVAL * categories.EXPERIMENTAL - categories.UNSELECTABLE - categories.UNTARGETABLE,
    [refActionBuildGameEnder] = M28UnitInfo.refCategoryGameEnder,
    [refActionBuildLandExperimental] = M28UnitInfo.refCategoryLandExperimental,
    [refActionBuildWall] = M28UnitInfo.refCategoryWall,
    [refActionBuildT3MassFab] = M28UnitInfo.refCategoryMassFab * categories.TECH3,
}

tiActionOrder = {
    [refActionBuildMex] = M28Orders.refiOrderIssueBuild,
    [refActionBuildHydro] = M28Orders.refiOrderIssueBuild,
    [refActionBuildPower] = M28Orders.refiOrderIssueBuild,
    [refActionBuildLandFactory] = M28Orders.refiOrderIssueBuild,
    [refActionBuildSecondPower] = M28Orders.refiOrderIssueBuild,
    [refActionBuildAirStaging] = M28Orders.refiOrderIssueBuild,
    [refActionBuildAirFactory] = M28Orders.refiOrderIssueBuild,
    [refActionBuildSecondAirFactory] = M28Orders.refiOrderIssueBuild,
    [refActionBuildEnergyStorage] = M28Orders.refiOrderIssueBuild,
    [refActionMoveToLandZone] = M28Orders.refiOrderIssueMove,
    [refActionRunToLandZone] = M28Orders.refiOrderIssueMove,
    [refActionMoveToWaterZone] = M28Orders.refiOrderIssueMove,
    [refActionRunToWaterZone] = M28Orders.refiOrderIssueMove,
    [refActionReclaimFriendlyUnit] = M28Orders.refiOrderIssueReclaim,
    [refActionAssistUpgrade] = M28Orders.refiOrderIssueGuard,
    [refActionAssistAirFactory] = M28Orders.refiOrderIssueGuard,
    [refActionBuildSMD] = M28Orders.refiOrderIssueBuild,
    [refActionBuildMassStorage] = M28Orders.refiOrderIssueBuild,
    [refActionBuildT1Radar] = M28Orders.refiOrderIssueBuild,
    [refActionBuildT2Radar] = M28Orders.refiOrderIssueBuild,
    [refActionBuildT3Radar] = M28Orders.refiOrderIssueBuild,
    [refActionAssistSMD] = M28Orders.refiOrderIssueGuard,
    [refActionBuildThirdPower] = M28Orders.refiOrderIssueBuild,
    [refActionBuildExperimental] = M28Orders.refiOrderIssueBuild,
    [refActionBuildSecondExperimental] = M28Orders.refiOrderIssueBuild,
    [refActionReclaimArea] = M28Orders.refiOrderIssueReclaim,--will actually have a move order followed by reclaim order
    [refActionBuildT1Sonar] = M28Orders.refiOrderIssueBuild,
    [refActionBuildT2Sonar] = M28Orders.refiOrderIssueBuild,
    [refActionBuildShield] = M28Orders.refiOrderIssueBuild,
    [refActionBuildSecondShield] = M28Orders.refiOrderIssueBuild,
    [refActionBuildNavalFactory] = M28Orders.refiOrderIssueBuild,
    [refActionAssistNavalFactory] = M28Orders.refiOrderIssueGuard,
    [refActionBuildTMD] = M28Orders.refiOrderIssueBuild,
    [refActionBuildAA] = M28Orders.refiOrderIssueBuild,
    [refActionBuildEmergencyPD] = M28Orders.refiOrderIssueBuild,
    [refActionBuildEmergencyArti] = M28Orders.refiOrderIssueBuild,
    [refActionBuildQuantumGateway] = M28Orders.refiOrderIssueBuild,
    [refActionBuildSecondLandFactory] = M28Orders.refiOrderIssueBuild,
    [refActionBuildTML] = M28Orders.refiOrderIssueBuild,
    [refActionLoadOntoTransport] = M28Orders.refiOrderLoadOntoTransport, --sometimes will be a move order
    [refActionAssistShield] = M28Orders.refiOrderIssueGuard,
    [refActionReclaimEnemyUnit] = M28Orders.refiOrderIssueReclaim,
    [refActionBuildSecondMassStorage] = M28Orders.refiOrderIssueBuild,
    [refActionCompletePartBuiltMex] = M28Orders.refiOrderIssueBuild,
    [refActionBuildExperimentalNavy] = M28Orders.refiOrderIssueBuild,
    [refActionBuildGameEnder] = M28Orders.refiOrderIssueBuild,
    [refActionBuildLandExperimental] = M28Orders.refiOrderIssueBuild,
    [refActionCaptureUnit] = M28Orders.refiOrderIssueCapture,
    [refActionRepairUnit] = M28Orders.refiOrderIssueRepair,
    [refActionSpecialShieldDefence] = M28Orders.refiOrderIssueBuild, --Sometimes will want to be idle
    [refActionBuildWall] = M28Orders.refiOrderIssueBuild,
    [refActionBuildT3MassFab] = M28Orders.refiOrderIssueBuild,
}

--Adjacent categories to search for for a particular action
tiActionAdjacentCategory = {
    [refActionBuildPower] = M28UnitInfo.refCategoryAirFactory * categories.TECH3 + M28UnitInfo.refCategoryAirFactory * categories.TECH2 + M28UnitInfo.refCategoryT3Radar + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategorySML + M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti * categories.UEF + M28UnitInfo.refCategoryMassFab * categories.TECH3,
    [refActionBuildSecondPower] = M28UnitInfo.refCategoryAirFactory * categories.TECH3 + M28UnitInfo.refCategoryT3Radar + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategorySML + M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti * categories.UEF + M28UnitInfo.refCategoryMassFab * categories.TECH3,
    [refActionBuildThirdPower] = M28UnitInfo.refCategorySML + M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti * categories.UEF + M28UnitInfo.refCategoryMassFab * categories.TECH3,
    [refActionBuildLandFactory] = M28UnitInfo.refCategoryMex,
    [refActionBuildAirFactory] = M28UnitInfo.refCategoryT3Power + M28UnitInfo.refCategoryHydro,
    [refActionBuildSecondAirFactory] = M28UnitInfo.refCategoryT3Power + M28UnitInfo.refCategoryHydro,
    [refActionBuildSMD] = M28UnitInfo.refCategoryT3Power,
    [refActionBuildT1Radar] = M28UnitInfo.refCategoryT1Power,
    [refActionBuildT2Radar] = M28UnitInfo.refCategoryT2Power,
    [refActionBuildT3Radar] = M28UnitInfo.refCategoryT3Power,
    [refActionBuildT3MassFab] = M28UnitInfo.refCategoryT3Power,
}

--Include any actions where we wont be building a category or searching for a category to assist
--The difference between this and tiActionCategory is for buildings where we need special code to determine the category to build, such as emergency PD (T1 vs T2 vs T3)
tbActionsThatDontHaveCategory = {
    [refActionMoveToLandZone] = true,
    [refActionRunToLandZone] = true,
    [refActionMoveToWaterZone] = true,
    [refActionRunToWaterZone] = true,
    [refActionReclaimFriendlyUnit] = true,
    [refActionAssistUpgrade] = true, --need special logic to only identify upgrading units for this
    [refActionReclaimArea] = true,
    [refActionReclaimEnemyUnit] = true,
    [refActionLoadOntoTransport] = true,
    [refActionCaptureUnit] = true,
    [refActionRepairUnit] = true,
    [refActionSpecialShieldDefence] = true,
}

tiIgnoreUnderConstructionThreshold = { --specify the number of under construction units to ignore, e.g. if set as 1, then if we only have 1 under construction we will build a new one, but if we have 2+ we will assist an under construction one (picking one that is less well complete)
    [refActionBuildMex] = 100,
    [refActionBuildSecondLandFactory] = 1,
    [refActionBuildSecondAirFactory] = 1,
    [refActionBuildSecondMassStorage] = 1,
    [refActionBuildSecondPower] = 1,
    [refActionBuildThirdPower] = 2,
    [refActionBuildSecondExperimental] = 1, --have a manual override for this where we are building t3 arti or g ameender
    [refActionBuildSecondShield] = 1,
}

tbIgnoreEngineerAssistance = { --Any actions where we dont want to assist an engineer already constructiong the building should go here; main purpose is building a mex
    [refActionBuildMex] = true,
    [refActionCompletePartBuiltMex] = true,
    [refActionAssistShield] = true,
    [refActionLoadOntoTransport] = true,
    [refActionBuildWall] = true,
}

tbActionsWithFactionSpecificLogic = { --Any actions where it is important to know what factions we have available when deciding what to build
    [refActionBuildExperimental] = true,
    [refActionBuildSecondExperimental] = true,
}




function GetEngineerUniqueCount(oEngineer)
    local iUniqueRef = oEngineer[refiEngineerCurUniqueReference]
    if iUniqueRef == nil then
        local aiBrain = oEngineer:GetAIBrain()
        iUniqueRef = aiBrain[refiEngineerCurUniqueReference] + 1
        aiBrain[refiEngineerCurUniqueReference] = iUniqueRef
        oEngineer[refiEngineerCurUniqueReference] = iUniqueRef
    end
    return iUniqueRef
end

function CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, iOptionalPlateauGroupOrZero, iOptionalLandOrWaterZone, iEngiActionToIgnore, bClearActionsIfNotStartedBuilding, bCheckForQueuedBuildings, bCheckForOverlappingBuildings, bCheckBlacklistIfNoGameEnder)
    --iOptionalPlateauGroupOrZero, iOptionalLandOrWaterZone, iEngiActionToIgnore, bClearActionsIfNotStartedBuilding and bCheckForOverlappingBuildings are optional
    --iOptionalPlateauGroupOrZero and iOptionalLandOrWaterZone: If specified, then will check this zone for queued units, if bCheckForQueuedBuildings is true
    --bCheckBlacklistIfNoGameEnder - will checkblacklist if either this is true, or the zone contains a gameender

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CanBuildAtLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then
        LOG(sFunctionRef..': About to see if we can build '..(sBlueprintToBuild or 'nil')..' at '..repru(tTargetLocation)..'; iEngiActionToIgnore='..(iEngiActionToIgnore or 'nil')..'; bClearActionsIfNotStartedBuilding='..tostring((bClearActionsIfNotStartedBuilding or false))..'; surface height at target='..GetSurfaceHeight(tTargetLocation[1], tTargetLocation[3])..'; aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation)='..tostring(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation)))
        if sBlueprintToBuild == 'ueb0103' then LOG(sFunctionRef..': Extra check for size 14 - can we build naval fac here? aiBrain:CanBuildStructureAt='..tostring(aiBrain:CanBuildStructureAt('xsb0103', tTargetLocation))) end
    end


    local bCanBuildStructure = false
    if aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation) == true or (EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryHydro, sBlueprintToBuild) and ((EntityCategoryContains(M28UnitInfo.refCategoryMex, sBlueprintToBuild) and M28Conditions.CanBuildOnMexLocation(tTargetLocation)) or EntityCategoryContains(M28UnitInfo.refCategoryHydro, sBlueprintToBuild) and M28Conditions.CanBuildOnHydroLocation(tTargetLocation))) then
        bCanBuildStructure = true
        if tsExtraBlueprintsToCheck[sBlueprintToBuild] then
            for iEntry, sAltBlueprint in tsExtraBlueprintsToCheck[sBlueprintToBuild] do
                if not(aiBrain:CanBuildStructureAt(sAltBlueprint, tTargetLocation)) then
                    bCanBuildStructure = false
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Passed hte basic aiBrain check of whether se can build a structure at the target location, bCheckForQueuedBuildings='..tostring(bCheckForQueuedBuildings or false)..'; bCanBuildStructure after checking alt blueprints='..tostring(bCanBuildStructure)) end
        if bCanBuildStructure then

            local iSkirtSizeRadius = __blueprints[sBlueprintToBuild].Physics.SkirtSizeX * 0.5
            if bCheckForQueuedBuildings == true then
                if bDebugMessages == true then LOG(sFunctionRef..': Checking for queued buildings, iOptionalPlateauGroupOrZero='..(iOptionalPlateauGroupOrZero or 'nil')..'; iOptionalLandOrWaterZone='..(iOptionalLandOrWaterZone or 'nil')) end
                if iOptionalPlateauGroupOrZero and iOptionalLandOrWaterZone then
                    --local iBuildingSize = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
                    local iBuildingRadius = math.floor(M28UnitInfo.GetBuildingSize(sBlueprintToBuild) * 0.5)
                    local tLZOrWZData, tLZOrWZTeamData
                    if iOptionalPlateauGroupOrZero > 0 then
                        tLZOrWZData  = M28Map.tAllPlateaus[iOptionalPlateauGroupOrZero][M28Map.subrefPlateauLandZones][iOptionalLandOrWaterZone]
                        tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
                    else
                        --Water zone
                        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iOptionalLandOrWaterZone]][M28Map.subrefPondWaterZones][iOptionalLandOrWaterZone]
                        tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][aiBrain.M28Team]
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of queued buildings empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefQueuedBuildings]))..'; iBuildingRadius='..iBuildingRadius..'; tTargetLocation='..repru(tTargetLocation)..'; reprs of table='..reprs(tLZOrWZData[M28Map.subrefQueuedLocationsByPosition])) end
                    if tLZOrWZData and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefQueuedBuildings]) == false then
                        local iBaseX = math.floor(tTargetLocation[1])
                        local iBaseZ = math.floor(tTargetLocation[3])
                        local iBuildingRadiusAdjust = math.ceil(iBuildingRadius)
                        for iX = iBaseX - iBuildingRadiusAdjust, iBaseX + iBuildingRadiusAdjust, 1 do
                            if tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX] then
                                if bDebugMessages == true then LOG(sFunctionRef..': Table of queued locations for iX '..iX..'='..reprs(tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX])..'; iBaseZ='..iBaseZ..'; iBuildingRadiusAdjust='..iBuildingRadiusAdjust) end
                                for iZ = iBaseZ - iBuildingRadiusAdjust, iBaseZ + iBuildingRadiusAdjust do
                                    if tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX][iZ] then
                                        bCanBuildStructure = false
                                        break
                                    end
                                end
                                if not(bCanBuildStructure) then break end
                            end
                        end
                    end
                else
                    M28Utilities.ErrorHandler('If we want to check for queued buildings then we need to specify the plateau and land zone')
                end
            end
            if bCanBuildStructure then
                --Check in case scathis is blocking us
                if M28Utilities.IsTableEmpty(tAllScathis) == false then
                    for iUnit, oUnit in tAllScathis do
                        if M28Utilities.GetDistanceBetweenPositions(tTargetLocation, oUnit:GetPosition()) < (iSkirtSizeRadius + oUnit:GetBlueprint().Physics.SkirtSizeX * 0.5) then
                            bCanBuildStructure = false
                            if bDebugMessages == true then LOG(sFunctionRef..': Are too close to a scathis so wont build here') end
                            break
                        end
                    end
                end

                if bCanBuildStructure and bCheckForOverlappingBuildings then

                    --Thanks to jip for flagging there's an engine bug where in rare situations units can be built slightly overlapping even if aiBrain:CanBuildStructureAt returns true - comments in the code Jip linked to suggested this is only where a building has upgraded
                    -- compute build locations and issue the capping

                    -- find all units that may prevent us from building
                    local tNearbyStructures = GetUnitsInRect(tTargetLocation[1] - (iSkirtSizeRadius + 4), tTargetLocation[3] - (iSkirtSizeRadius + 4), tTargetLocation[1] + (iSkirtSizeRadius + 4), tTargetLocation[3] + (iSkirtSizeRadius + 4))
                    if M28Utilities.IsTableEmpty(tNearbyStructures) == false then
                        tNearbyStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryUpgraded, tNearbyStructures)
                        local iClosestDistance
                        if M28Utilities.IsTableEmpty(tNearbyStructures) == false then
                            for iStructure, oStructure in tNearbyStructures do
                                if not(oStructure.Dead) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': oStructure='..oStructure.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStructure)..'; position='..repru(oStructure:GetPosition())..'; target location='..repru(tTargetLocation)..'; target building ID='..sBlueprintToBuild..'; 50% of target building skirt size='..iSkirtSizeRadius..'; 50% of oStructure skrit size='..oStructure:GetBlueprint().Physics.SkirtSizeX * 0.5) end
                                    iClosestDistance = math.max(math.abs(oStructure:GetPosition()[1] - tTargetLocation[1]), math.abs(oStructure:GetPosition()[3] - tTargetLocation[3]))
                                    if iClosestDistance < (iSkirtSizeRadius + oStructure:GetBlueprint().Physics.SkirtSizeX * 0.5) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Cant build as iClosestDistance='..iClosestDistance..'which is less than the two skirt sizes') end
                                        bCanBuildStructure = false
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
                if not(bCanBuildStructure) and bDebugMessages == true then LOG(sFunctionRef..': Skirt size is overlaping with a building that could have upgraded so will return false') end
            end
            if bCanBuildStructure and (bCheckBlacklistIfNoGameEnder or M28Team.tTeamData[aiBrain.M28Team][M28Team.refbStartedOnUnitWantingSpecialShielding]) then
                local iPlateau = iOptionalPlateauGroupOrZero
                local iLandZone = iOptionalLandOrWaterZone
                if not(iOptionalLandOrWaterZone) or not(iOptionalPlateauGroupOrZero) then
                    iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                end
                local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                if bDebugMessages == true then LOG(sFunctionRef..': Checking against blacklist for the floor of target location and in the building radius, is blacklist nil for floor='..tostring(tLZData[M28Map.subrefBuildLocationBlacklistByPosition][math.floor(tTargetLocation[1])][math.floor(tTargetLocation[3])] == nil)..'; FloorX='..math.floor(tTargetLocation[1])..'; FloorZ='..math.floor(tTargetLocation[3])) end
                local iFloorX = math.floor(tTargetLocation[1])
                local iFloorZ = math.floor(tTargetLocation[3])
                for iBlacklistX = iFloorX - iSkirtSizeRadius, iFloorX + iSkirtSizeRadius do
                    if tLZData[M28Map.subrefBuildLocationBlacklistByPosition][iBlacklistX] then
                        for iBlacklistZ = iFloorZ - iSkirtSizeRadius, iFloorZ + iSkirtSizeRadius do
                            if tLZData[M28Map.subrefBuildLocationBlacklistByPosition][iBlacklistX][iBlacklistZ] then
                                bCanBuildStructure = false
                                break
                            end
                        end
                        if not(bCanBuildStructure) then break end
                    end
                end
                --Approach for v18 and earlier
                --[[if tLZData[M28Map.subrefBuildLocationBlacklistByPosition][math.floor(tTargetLocation[1])][math.floor(tTargetLocation[3])] then
                    bCanBuildStructure = false
                end--]]
                --Even older blacklist approach (commented out) - from a while before v18, not sure when
                --[[if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefBuildLocationBlacklistByPosition]) == false then
                    for iEntry, tBlacklistData in tLZData[M28Map.subrefBuildLocationBlacklist] do
                        local iDistThreshold = tLZData[M28Map.subrefBuildLocationBlacklist][table.getn(tLZData[M28Map.subrefBuildLocationBlacklist])][M28Map.subrefBlacklistSize] + iSkirtSizeRadius
                        if math.abs(tTargetLocation[1] - tBlacklistData[M28Map.subrefBlacklistLocation][1]) <= iDistThreshold and math.abs(tTargetLocation[3] - tBlacklistData[M28Map.subrefBlacklistLocation][3]) <= iDistThreshold then
                            return false
                        end

                    end
                end--]]
            end
        elseif bDebugMessages == true then LOG(sFunctionRef..': If try same size building with different skirt offsets then cant build here')
        end
    elseif bDebugMessages == true then LOG(sFunctionRef..': Cant build structure at the location')
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bCanBuildStructure='..tostring(bCanBuildStructure)) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bCanBuildStructure
end

function CheckIfBuildableLocationsNearPositionStillValid(aiBrain, tLocation, bCheckLastBlacklistEntry, iBuildingRadius)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckIfBuildableLocationsNearPositionStillValid'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Check if the locations near tLocation are still valid - e.g. usually called if we have just built a unit (so unlikely to be valid) or have identified a blacklist location



    if not(aiBrain.M28IsDefeated) then
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tLocation)
        local tLZOrWZData, sBlueprintSizeRef
        if (iLandOrWaterZone or 0) == 0 then
            iLandOrWaterZone = M28Map.GetWaterZoneFromPosition(tLocation)
            if iLandOrWaterZone > 0 then
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                sBlueprintSizeRef = tsWZBlueprintsBySize
                iPlateauOrZero = 0
            end
        else
            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
            sBlueprintSizeRef = tsBlueprintsBySize
        end
        if (iLandOrWaterZone or 0) > 0 then
            local iBaseSegmentX, iBaseSegmentZ = M28Map.GetPathingSegmentFromPosition(tLocation)
            local iAffectedDistanceRadius = iBuildingRadius + iMaxBuildingSize * 0.5
            if bDebugMessages == true then
                LOG(sFunctionRef..': Want to see if existing build locations are still valid, iAffectedDistanceRadius='..iAffectedDistanceRadius..'; iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Buildable locations before update for size 8=='..(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][8] or 'nil')..'; bCheckLastBlacklistEntry='..tostring(bCheckLastBlacklistEntry or false))
            end
            CheckIfSegmentsStillBuildable(aiBrain, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, iBaseSegmentX, iBaseSegmentZ, iAffectedDistanceRadius, bCheckLastBlacklistEntry)

            --Search for more building locations for every building where we havent considered the full amount if we havent considered any this cycle
            local iTotalSegmentCount, sBlueprintSizeRef
            if iPlateauOrZero == 0 then
                iTotalSegmentCount = table.getn(tLZOrWZData[M28Map.subrefWZSegments])
                sBlueprintSizeRef = tsWZBlueprintsBySize

            else
                iTotalSegmentCount = tLZOrWZData[M28Map.subrefLZTotalSegmentCount]
                sBlueprintSizeRef = tsBlueprintsBySize
            end
            if (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iBuildingRadius * 2] or 0) <= 10 then
                if (tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] or 0) <= 20 then
                    SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, 10)
                end
            end

            --Update mass storage locations
            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': About to update mass storage locations for iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..', tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable]='..repru(tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable])..'; Nickname of first aiBrain='..M28Overseer.tAllActiveM28Brains[1].Nickname) end
                local aiBrain = M28Overseer.tAllActiveM28Brains[1]
                local function WantToKeep(tArray, iEntry, aiBrain)
                    return aiBrain:CanBuildStructureAt('ueb1106', tArray[iEntry])
                end

                local iRevisedIndex = 1
                local iTableSize = table.getn(tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable])

                for iOrigIndex=1, iTableSize do
                    if tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable][iOrigIndex] then --Needed as sometimes the last entry is nil
                        if aiBrain.CanBuildStructureAt and aiBrain:CanBuildStructureAt('ueb1106', tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable][iOrigIndex]) then
                            --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                            if (iOrigIndex ~= iRevisedIndex) then
                                tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable][iRevisedIndex] = tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable][iOrigIndex];
                                tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable][iOrigIndex] = nil;
                            end
                            iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                        else
                            tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable][iOrigIndex] = nil;
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function FindBuildableLocationsForSegment(aiBrain, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, iSegmentX, iSegmentZ)
    --Use if e.g. a building has died nearby and this may now have a greater build range
    --First get a blueprint of the same size (or just use htis if this is a different size)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'FindBuildableLocationsForSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local sBlueprintTable
    if iPlateauOrZero == 0 then sBlueprintTable = tsWZBlueprintsBySize
    else sBlueprintTable = tsBlueprintsBySize
    end
    if bDebugMessages == true then LOG(sFunctionRef..': iSegmentX='..(iSegmentX or 'nil')..'; iSegmentZ='..(iSegmentZ or 'nil')) end
    local tCurPosition = M28Map.GetPositionFromPathingSegments(iSegmentX, iSegmentZ)
    local iHighestCurSize = (tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] or 0)
    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, Time='..GetGameTimeSeconds()..'; Brain='..aiBrain.Nickname..'; iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; iSegmentX='..iSegmentX..'; iSegmentZ='..iSegmentZ..'; iHighestCurSize='..iHighestCurSize) end
    if iHighestCurSize < iMaxBuildingSize then
        for iSize, sGenericBlueprint in sBlueprintTable do

            if iSize > iHighestCurSize then
                --CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, iOptionalPlateauGroupOrZero, iOptionalLandOrWaterZone, iEngiActionToIgnore, bClearActionsIfNotStartedBuilding, bCheckForQueuedBuildings, bCheckForOverlappingBuildings, bCheckBlacklistIfNoGameEnder)
                if CanBuildAtLocation(aiBrain, sGenericBlueprint, tCurPosition,     iPlateauOrZero,             iLandOrWaterZone,           nil,                false,                              false,                  false,                          true) then
                    if not(tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX]) then
                        if not(tLZOrWZData[M28Map.subrefBuildableSizeBySegment]) then tLZOrWZData[M28Map.subrefBuildableSizeBySegment] = {} end
                        tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX] = {}
                    end
                    tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] = iSize
                    if not(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize][iSegmentX][iSegmentZ]) then
                        if not(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize][iSegmentX]) then
                            if not(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize]) then
                                if not(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment]) then
                                    tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment] = {}
                                end
                                tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize] = {}
                            end
                            tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize][iSegmentX] = {}
                        end
                        --Record the count of how many buildable locations we have for this size
                        tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize][iSegmentX][iSegmentZ] = true
                        if not(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]) then
                            if not(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize]) then tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize] = {} end
                            tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] = 1
                            if bDebugMessages == true then LOG(sFunctionRef..': No size previously recorded for iPlateau'..iPlateauOrZero..'Zone '..iLandOrWaterZone..' and size '..iSize..'; recording 1 as we can build at segmentX'..iSegmentX..'Z'..iSegmentZ..'; tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]='..tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]) end
                        else
                            tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] = tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] + 1
                            if bDebugMessages == true then LOG(sFunctionRef..': Increasing the number of entries by 1 for iPlateau'..iPlateauOrZero..'Zone '..iLandOrWaterZone..' and size '..iSize..'; count='..tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]..'as we can build at segmentX'..iSegmentX..'Z'..iSegmentZ) end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Can build at location '..repru(tCurPosition)..' for iSize='..(iSize or 'nil')..'; LZ midpoint='..repru(tLZOrWZData[M28Map.subrefMidpoint])..'; tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]='..(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 'nil')) end
                else
                    --If we cant build this then we cant build anything larger either
                    if bDebugMessages == true then LOG(sFunctionRef..': We cant build at position '..repru(tCurPosition)..' for size '..iSize) end
                    break
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize]='..repru(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize])) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckIfSegmentsStillBuildable(aiBrain, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, iBaseSegmentX, iBaseSegmentZ, iAffectedDistanceRadius, bCheckBlacklistIfNoGameEnder)
    --Use if e.g. a building has just started construction meaning we likely cant build nearby
    --First get a blueprint of the same size (or just use htis if this is a different size)
    --bCheckBlacklistIfNoGameEnder - if true then will check to the blacklist; if false then won't check unless there is a gameender in the zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckIfSegmentsStillBuildable'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iSegmentSearchSize = math.ceil(iAffectedDistanceRadius + iMaxBuildingSize * 0.5 / M28Map.iLandZoneSegmentSize)
    local sBlueprintTable
    if iPlateauOrZero == 0 then sBlueprintTable = tsWZBlueprintsBySize
    else sBlueprintTable = tsBlueprintsBySize
    end
    local iLastValidSize
    local GetPositionFromPathingSegments = M28Map.GetPositionFromPathingSegments
    if bDebugMessages == true then LOG(sFunctionRef..': About to search from SegmentX='..math.max(1, iBaseSegmentX - iSegmentSearchSize)..' to '..math.min(iBaseSegmentX + iSegmentSearchSize, M28Map.iMaxLandSegmentX)..' and Z='..math.max(1, iBaseSegmentZ - iSegmentSearchSize)..' to '..math.min(iBaseSegmentZ + iSegmentSearchSize, M28Map.iMaxLandSegmentZ)) end
    for iSegmentX = math.max(1, iBaseSegmentX - iSegmentSearchSize), math.min(iBaseSegmentX + iSegmentSearchSize, M28Map.iMaxLandSegmentX), 1 do
        for iSegmentZ = math.max(1, iBaseSegmentZ - iSegmentSearchSize), math.min(iBaseSegmentZ + iSegmentSearchSize, M28Map.iMaxLandSegmentZ), 1 do
            if bDebugMessages == true then LOG(sFunctionRef..': iCurSegmentX='..iSegmentX..'Z'..iSegmentZ..'; Buildable size='..(tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] or 0)) end
            if (tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] or 0) > 0 then
                iLastValidSize = nil
                for iSize, sBlueprint in sBlueprintTable do
                    if iSize > (tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] or 0) then
                        break
                    else
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Checking if buildable for iSegmentX='..iSegmentX..'; iSegmentZ='..iSegmentZ..'; iSize='..iSize..'; iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; bCheckBlacklistIfNoGameEnder='..tostring(bCheckBlacklistIfNoGameEnder)..'; Can build here='..tostring(CanBuildAtLocation(aiBrain, sBlueprint, GetPositionFromPathingSegments(iSegmentX, iSegmentZ),     iPlateauOrZero,             iLandOrWaterZone,           nil,                false,                              false,                  false,                          bCheckBlacklistIfNoGameEnder)))
                            --T3 pgen size - show buildable in blue nonbuildable in red
                            if iSize == 8 then
                                local bCanBuild = CanBuildAtLocation(aiBrain, sBlueprint, GetPositionFromPathingSegments(iSegmentX, iSegmentZ),     iPlateauOrZero,             iLandOrWaterZone,           nil,                false,                              false,                  false,                          bCheckBlacklistIfNoGameEnder)
                                if bCanBuild then M28Utilities.DrawLocation(GetPositionFromPathingSegments(iSegmentX, iSegmentZ), 1)
                                else
                                    M28Utilities.DrawLocation(GetPositionFromPathingSegments(iSegmentX, iSegmentZ), 2)
                                end
                            end
                        end
                        if CanBuildAtLocation(aiBrain, sBlueprint, GetPositionFromPathingSegments(iSegmentX, iSegmentZ),     iPlateauOrZero,             iLandOrWaterZone,           nil,                false,                              false,                  false,                          bCheckBlacklistIfNoGameEnder) then
                            --No change needed, location is still valid
                            iLastValidSize = iSize
                        else
                            --Cant build anymore, remove this and any subsequent locations
                            for iRemoveSize, sBlueprint in sBlueprintTable do
                                if iRemoveSize > iLastValidSize then
                                    if tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iRemoveSize][iSegmentX][iSegmentZ] then
                                        tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iRemoveSize][iSegmentX][iSegmentZ] = nil
                                        tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iRemoveSize] = math.max(0, (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iRemoveSize] or 1) - 1)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Just removed recording segmentX'..iSegmentX..'Z'..iSegmentZ..' from being buildable in plateau '..iPlateauOrZero..' Zone '..iLandOrWaterZone..', count by size for this zone for iRemoveSIze '..iRemoveSize..' and iSize='..iSize..'='..tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iRemoveSize]) end
                                    end
                                end
                            end
                            tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] = iLastValidSize
                            if bDebugMessages == true then LOG(sFunctionRef..': Finished removing buildable entries, tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ]='..(tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] or 'nil')..'; tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][8][iSegmentX][iSegmentZ]='..tostring(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][8][iSegmentX][iSegmentZ] or false)..'; iLastValidSize='..(iLastValidSize or 'nil')) end
                            break
                        end
                    end
                end
            end
        end
    end
    if tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][2] <= 0 and tLZOrWZData[M28Map.subrefLZTotalSegmentCount] >= 50 and GetGameTimeSeconds() >= 60 then
        M28Utilities.ErrorHandler('Dont have any locations that even a 2x2 building in P'..(iPlateauOrZero or 'nil')..'Z'..(iLandOrWaterZone or 'nil')..' can build in so likely something has gone wrong, will refresh the build count')
        LOG('Count by size before update='..repru(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize]))
        local iCurCount
        for iSize, sBlueprint in sBlueprintTable do
            iCurCount = 0

            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize]) == false then
                for iSegmentX, tSubtable in tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize] do
                    for iSegmentZ, bValid in tSubtable do
                        iCurCount = iCurCount + 1
                    end
                end
            end
            tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] = iCurCount
        end
        LOG('Count by size after update='..repru(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize]))
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iOptionalMaxSegmentsToConsider)
    --Updates the plateau with a general buildable locations (if there are any) for iLandOrWaterZone
    --Will treat locations immediately adjacent to mexes as being unbuildable, to avoid taking up mass storage positions
    --iOptionalMaxSegmentsToConsider - will stop searching if reach this number of segments
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SearchForBuildableLocationsForLandOrWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tLZOrWZData
    local iSegmentRef
    if iPlateauOrZero == 0 then
        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        iSegmentRef = M28Map.subrefWZSegments
    else
        tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        iSegmentRef = M28Map.subrefLZSegments
    end
    if not(tLZOrWZData) then
        M28Utilities.ErrorHandler('Dont have valid zone, iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil'))
    else
        local iSegmentsToConsider
        if (tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] or 0) >= 50 and GetGameTimeSeconds() >= 60 then
            if not(iOptionalMaxSegmentsToConsider) then
                iSegmentsToConsider = 3
                if iPlateauOrZero == 0 then iSegmentsToConsider = 6
                else iSegmentsToConsider = 3
                end
            else
                if GetGameTimeSeconds() >= 150 and (GetGameTimeSeconds() >= 900 or M28Overseer.refiRoughTotalUnitsInGame >= 500) then
                    if iPlateauOrZero == 0 then
                        iSegmentsToConsider = math.min(10, math.floor(iOptionalMaxSegmentsToConsider))
                    else
                        iSegmentsToConsider = math.min(5, math.floor(iOptionalMaxSegmentsToConsider))
                    end
                else
                    if iPlateauOrZero == 0 then
                        iSegmentsToConsider = math.max(10, math.floor(iOptionalMaxSegmentsToConsider))
                    else
                        iSegmentsToConsider = math.max(5, math.floor(iOptionalMaxSegmentsToConsider))
                    end
                end
            end
        else
            if M28Overseer.refiRoughTotalUnitsInGame >= 500 then
                iSegmentsToConsider = math.max(math.floor((iOptionalMaxSegmentsToConsider or 0)), 20)
            else
                iSegmentsToConsider = math.max(math.floor((iOptionalMaxSegmentsToConsider or 0)), 50)
            end
        end

        local iTotalSegments = table.getn(tLZOrWZData[iSegmentRef])
        local iSegmentStart = math.floor((tLZOrWZData[M28Map.subrefiLastSegmentEntryConsideredForBuilding] or 0) + 1)
        if iSegmentStart > iTotalSegments then iSegmentStart = 1 end
        local tSegmentXZ
        local iSegmentEnd = math.floor(math.min(iTotalSegments, iSegmentStart + iSegmentsToConsider))

        --Cycle through every segment in the land/water zone and see if we can build the desired unit at the segment midpoint
        if bDebugMessages == true then
            LOG(sFunctionRef..': About to cycle through each segment to check for buildable locations. iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; iOptionalMaxSegmentsToConsider='..(iOptionalMaxSegmentsToConsider or 'nil')..'; iSegmentStart='..iSegmentStart..'; iTotalSegments='..iTotalSegments..'; iSegmentEnd='..iSegmentEnd)
            if iPlateauOrZero == 0 then
                LOG(sFunctionRef..': Dealing with water zone, subrefWZSegments count='..table.getn(tLZOrWZData[M28Map.subrefWZSegments])..'MinSegX='..tLZOrWZData[M28Map.subrefWZMinSegX]..' Z'..tLZOrWZData[M28Map.subrefWZMinSegZ]..'; MaxX='..tLZOrWZData[M28Map.subrefWZMaxSegX]..' Z'..tLZOrWZData[M28Map.subrefWZMaxSegZ])
            end
        end
        for iSegmentCount = iSegmentStart, iSegmentEnd do
            tSegmentXZ = tLZOrWZData[iSegmentRef][iSegmentCount]
            if bDebugMessages == true then LOG(sFunctionRef..': About to find buildable locations for segment X'..(tSegmentXZ[1] or 'nil')..' Z'..(tSegmentXZ[2] or 'nil')..'; iSegmentCount='..(iSegmentCount or 'nil')..'; iSegmentStart='..(iSegmentStart or 'nil')..'; iSegmentEnd='..(iSegmentEnd or 'nil')) end
            FindBuildableLocationsForSegment(aiBrain, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tSegmentXZ[1], tSegmentXZ[2])
            tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] = (tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] or 0) + 1
        end
        tLZOrWZData[M28Map.subrefiLastSegmentEntryConsideredForBuilding] = iSegmentEnd
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of c ode, LZOrWZData[subrefBuildLocationSegmentCountBySize]='..repru(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize] or {'nil'})..'; tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick]='..(tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetPotentialBuildLocationsNearLocation(aiBrain, tLZOrWZData, iPlateauOrZero, iLandOrWaterZone, iSize, iOptionalMaxCycleSize)
    --Returns a table of potentail build locations (if there are any) for iSize building in the zone in question
    --If there aren't many build locations then will try searching for more

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPotentialBuildLocationsNearLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bDontCheckForNoRush = not(M28Overseer.bNoRushActive)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Time='..GetGameTimeSeconds()..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iSize='..iSize..'; tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]='..(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 0)..'; Midpoint in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tLZOrWZData[M28Map.subrefMidpoint]))) end
    if (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 0) < 10 or (M28Map.bIsCampaignMap and iSize >= 14) or (iOptionalMaxCycleSize or 100) <= 20 then
        --SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iOptionalMaxSegmentsToConsider)
        SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, nil)
    end
    if (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 0) > 0 then

        local tPotentialLocations = {}
        local GetPositionFromPathingSegments = M28Map.GetPositionFromPathingSegments
        local iCycleSize = 1
        if (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 0) >= 50 then
            iCycleSize = math.ceil((tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 0) / 40)
            --Water zones are larger so can run more of a risk of not finding the right location with too large a cycle size
            if iCycleSize >= 30 then
                if iPlateauOrZero == 0 then
                    iCycleSize = math.max(30, math.ceil(iCycleSize * 0.6))
                else
                    iCycleSize = math.max(30, math.ceil(iCycleSize * 0.8))
                end
            end
        end
        if iOptionalMaxCycleSize then iCycleSize = math.min(iOptionalMaxCycleSize, iOptionalMaxCycleSize) end
        local iCurCount = 0
        for iSegmentX, tSubtable in tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize] do
            for iSegmentZ, bInclude in tSubtable do
                iCurCount = iCurCount + 1
                if iCurCount < iCycleSize then
                    iCurCount = iCurCount + 1
                else
                    if bDontCheckForNoRush or M28Conditions.IsLocationInNoRushArea(GetPositionFromPathingSegments(iSegmentX, iSegmentZ)) then
                        table.insert(tPotentialLocations, GetPositionFromPathingSegments(iSegmentX, iSegmentZ))
                        iCurCount = 0
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': About to return tPotentialLocations with a size of '..table.getn(tPotentialLocations)..'; iCycleSize='..iCycleSize..'; Size of buidlable locations in total='..tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return tPotentialLocations
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Didnt find any build locations for size '..iSize) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SearchForBuildableLocationsNearTarget(aiBrain, tLZOrWZData, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, iBaseSegmentX, iBaseSegmentZ, iAffectedDistanceRadius)
    local iDistanceSearchSize = math.max(iAffectedDistanceRadius, 8)
    --local iSegmentSearchSize = math.ceil(iAffectedDistanceRadius + iMaxBuildingSize * 0.5 / M28Map.iLandZoneSegmentSize)
    iSegmentSearchSize = math.ceil(iDistanceSearchSize / M28Map.iLandZoneSegmentSize)
    for iSegmentX = math.max(1, iBaseSegmentX - iSegmentSearchSize), math.min(iBaseSegmentX + iSegmentSearchSize, M28Map.iMaxLandSegmentX), 1 do
        for iSegmentZ = math.max(1, iBaseSegmentZ - iSegmentSearchSize), math.min(iBaseSegmentZ + iSegmentSearchSize, M28Map.iMaxLandSegmentZ), 1 do
            FindBuildableLocationsForSegment(aiBrain, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, iSegmentX, iSegmentZ)
        end
    end
end

function SearchForBuildableLocationsNearDestroyedBuilding(oDestroyedBuilding)
    --Searhces all segments around oDestroyedBuilding in the same land zone, and if we can build in them for a particular size, then records that location as a buildable location for that size for the land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SearchForBuildableLocationsNearDestroyedBuilding'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Cant fork thread as causes error, and need to wait a few seconds for death animation to take effect
    table.insert(tRecentlyDestroyedBuildings, {[subrefDestroyedBuildingBlueprint] = oDestroyedBuilding.UnitId, [subrefDestroyedBuildingLocation] = {oDestroyedBuilding:GetPosition()[1], oDestroyedBuilding:GetPosition()[2], oDestroyedBuilding:GetPosition()[3]}, [subrefDestroyedBuildingTime] = GetGameTimeSeconds()})
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetPotentialAdjacencyLocations(aiBrain, sBlueprintToBuild, tTargetLocation, iMaxAreaToSearch, iCatToBuildBy, oUnitToBuildBy, bStopWhenHaveValidLocation)
    --Returns a table of all locations that are valid buildable locations for sBlueprintToBuild where it will benefit from an adjacencybonus with iCatToBuildBy or oUnitToBuildBy
    --bStopWhenHaveValidLocation - if we are happy to get the first result then this will abort as soon as a valid location is found
    --Returns {} if no valid locations can be found
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPotentialAdjacencyLocations'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tPotentialLocations = {}
    local toPossibleBuildingsToBuildBy = {}
    local iPlateauOrZero, iLandOrWaterZone --Values are set if we have a cat to build by (but need here as refer to again later on)
    local iWaterZone, iPond, sAlliedUnitRef
    local tLZOrWZTeamData
    local tLZOrWZData


    if bDebugMessages == true then LOG(sFunctionRef..': sBLueprintToBuild='..(sBlueprintToBuild or 'nil')..'; tTargetLocation='..repru(tTargetLocation)..'; iMaxAreaToSearch='..iMaxAreaToSearch..'; Is iCatToBuildBy empty='..tostring(iCatToBuildBy == nil)..'; is oUnitToBuildBy empty='..tostring(oUnitToBuildBy == nil)..'; bStopWhenHaveValidLocation='..tostring(bStopWhenHaveValidLocation or false)) end

    if iCatToBuildBy then
        --sBlueprintBuildBy = M28FactoryOverseer.GetBlueprintThatCanBuildOfCategory(aiBrain, iCatToBuildBy, oEngineer)--, false, false)
        iPlateauOrZero, iLandOrWaterZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
        if (iLandOrWaterZone or 0) == 0 then
            iWaterZone = M28Map.GetWaterZoneFromPosition(tTargetLocation)
            iPond = M28Map.tiPondByWaterZone[iWaterZone]
            if iWaterZone > 0 and iPond > 0 then
                iPlateauOrZero = 0
                tLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][aiBrain.M28Team]
                sAlliedUnitRef = M28Map.subreftoLZOrWZAlliedUnits
                iLandOrWaterZone = iWaterZone
            end
        else
            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
            tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
            sAlliedUnitRef = M28Map.subreftoLZOrWZAlliedUnits
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Have a cat to build by, tTargetLocation='..repru(tTargetLocation)..'; iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Is table of allied units in this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[sAlliedUnitRef]))) end

        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[sAlliedUnitRef]) == false then --Note - LZ and WZ refs use the same reference
            if bDebugMessages == true then LOG(sFunctionRef..': Size of tLZOrWZTeamData[sAlliedUnitRef]='..table.getn(tLZOrWZTeamData[sAlliedUnitRef])..'; iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone) end
            local tRelevantBuildingsInSameLandZone = EntityCategoryFilterDown(iCatToBuildBy, tLZOrWZTeamData[sAlliedUnitRef])
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of releevant buildings empty='..tostring(M28Utilities.IsTableEmpty(tRelevantBuildingsInSameLandZone))) end
            if M28Utilities.IsTableEmpty(tRelevantBuildingsInSameLandZone) == false then
                for iUnit, oUnit in tRelevantBuildingsInSameLandZone do
                    if oUnit:GetAIBrain() == aiBrain then
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering distance between unit of category wanted for adjacency and target location, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Dist='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation)..'; Position='..repru(oUnit:GetPosition())) end
                        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation) <= iMaxAreaToSearch then
                            table.insert(toPossibleBuildingsToBuildBy, oUnit)
                        end
                    end
                end
            end
        end
    elseif oUnitToBuildBy and not(oUnitToBuildBy.Dead) then
        --sBlueprintBuildBy = oUnitToBuildBy.UnitId
        toPossibleBuildingsToBuildBy = {oUnitToBuildBy}
    else M28Utilities.ErrorHandler('No adjacency category or unit specified')
    end

    local bAbort = false
    local iNewBuildingRadius = M28UnitInfo.GetBuildingSize(sBlueprintToBuild) * 0.5
    local iValidLocationCount = 0
    local iValidBuildingCount = 0
    local bHaveValidLocation = false
    local bDontCheckForNoRush = not(M28Overseer.bNoRushActive)
    local function AddAdjacencyLocationsToPotentialLocations(tAdjacencyBuildingPosition, iAdjacencyBuildingRadius, iNewBuildingRadius)
        local iCurZ, iCurX
        local iCycleSize = math.abs(iAdjacencyBuildingRadius - iNewBuildingRadius)
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tAdjacencyBuildingPosition)
        if iPlateauOrZero > 0 then
            if (iLandOrWaterZone or 0) == 0 then
                iLandOrWaterZone = M28Map.GetWaterZoneFromPosition(tAdjacencyBuildingPosition)
                if iLandOrWaterZone > 0 then
                    iPlateauOrZero = 0
                end
            end
            if iLandOrWaterZone > 0 then
                bHaveValidLocation = false
                if bDebugMessages == true then LOG(sFunctionRef..': tAdjacencyBuildingPosition='..repru(tAdjacencyBuildingPosition)..'; iAdjacencyBuildingRadius='..iAdjacencyBuildingRadius..'; iNewBuildingRadius='..iNewBuildingRadius..'; iCycleSize='..iCycleSize) end

                --First go along top and bottom:
                for iZFactor = -1, 1, 2 do
                    iCurZ = tAdjacencyBuildingPosition[3] + (iAdjacencyBuildingRadius + iNewBuildingRadius) * iZFactor
                    for iCurX = tAdjacencyBuildingPosition[1] - iCycleSize, tAdjacencyBuildingPosition[1] + iCycleSize, 1 do
                        if CanBuildAtLocation(aiBrain, sBlueprintToBuild, { iCurX, 0, iCurZ}, iPlateauOrZero, iLandOrWaterZone, nil, false, true, false, true) then
                            if bDontCheckForNoRush or M28Conditions.IsLocationInNoRushArea({iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ}) then
                                table.insert(tPotentialLocations, {iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ})
                                if bStopWhenHaveValidLocation then bAbort = true break end
                                iValidLocationCount = iValidLocationCount + 1
                                bHaveValidLocation = true
                            end
                        end
                    end
                    if bAbort then break end
                end

                --Next go along the sides:
                if not(bAbort) then
                    for iXFactor = -1, 1, 2 do
                        iCurX = tAdjacencyBuildingPosition[1] + (iAdjacencyBuildingRadius + iNewBuildingRadius) * iXFactor
                        for iCurZ = tAdjacencyBuildingPosition[3] - iCycleSize, tAdjacencyBuildingPosition[3] + iCycleSize, 1 do
                            if CanBuildAtLocation(aiBrain, sBlueprintToBuild, { iCurX, 0, iCurZ}, iPlateauOrZero, iLandOrWaterZone, nil, false, true, false, true) then
                                if bDontCheckForNoRush or M28Conditions.IsLocationInNoRushArea({iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ}) then
                                    table.insert(tPotentialLocations, {iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ})
                                    if bStopWhenHaveValidLocation then bAbort = true break end
                                    iValidLocationCount = iValidLocationCount + 1
                                    bHaveValidLocation = true
                                end
                            end
                        end
                        if bAbort then break end
                    end
                end
            end
        end
    end


    if M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Have possible buildings to build by, so will consider best location') end
        local iAdjacencyBuildingRadius
        for iBuilding, oBuilding in toPossibleBuildingsToBuildBy do
            iAdjacencyBuildingRadius = M28UnitInfo.GetBuildingSize(oBuilding.UnitId) * 0.5
            AddAdjacencyLocationsToPotentialLocations(oBuilding:GetPosition(), iAdjacencyBuildingRadius, iNewBuildingRadius)
            if bHaveValidLocation then
                iValidBuildingCount = iValidBuildingCount + 1
                if iValidBuildingCount >= 3 and iValidLocationCount >= 3 then break end
            end
            if bAbort then break end
        end
    else
        --No nearby buildings of the desired kind - if we want to build BY a mex or hydro then consider unbuilt resource locations, unless we are bulding in a water zone
        if iLandOrWaterZone > 0 then
            local tResourceLocations
            local iAdjacencyBuildingRadius
            if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryMex, iCatToBuildBy, false) then
                tResourceLocations = (tLZOrWZData[M28Map.subrefLZMexLocations] or tLZOrWZData[M28Map.subrefWZMexLocations])
                iAdjacencyBuildingRadius = 1
                if bDebugMessages == true then LOG(sFunctionRef..': Want to build by a mex so recording tResourceLocations based on iPlateauOrZero='..(iPlateauOrZero or 'nil')..' and iLandOrWaterZone='..(iLandOrWaterZone or 'nil')) end
            elseif M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryHydro, iCatToBuildBy, false) then
                tResourceLocations = tLZOrWZData[M28Map.subrefHydroLocations] --we use the same variable for land and water zones
                iAdjacencyBuildingRadius = 3
            end
            if tResourceLocations then
                for iCurResource, tCurResource in tResourceLocations do
                    AddAdjacencyLocationsToPotentialLocations(tCurResource, iAdjacencyBuildingRadius, iNewBuildingRadius)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tPotentialLocations
end

function DrawBlacklistedLocations(tLZData)
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefBuildLocationBlacklistByPosition]) == false then
        for iX, tZ in tLZData[M28Map.subrefBuildLocationBlacklistByPosition] do
            for iZ, bTrue in tZ do
                M28Utilities.DrawLocation({iX, GetSurfaceHeight(iX, iZ), iZ}, 2)
            end
        end
        --Old blacklist approach:
        --[[for iEntry, tBlacklistData in tLZData[M28Map.subrefBuildLocationBlacklist] do
        M28Utilities.DrawLocation(tBlacklistData[M28Map.subrefBlacklistLocation], 2, nil, tBlacklistData[M28Map.subrefBlacklistSize] * 2)
    end--]]
    end
end

function DrawBuildableLocations(tLZOrWZData, iSize)
    LOG('DrawBuildableLocations: Is table of build locations for iSize'..(iSize or 'nil')..'empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize]))..'; buildable location count='..(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 'nil'))
    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize]) == false then
        for iSegmentX, tSubtable in tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize] do
            for iSegmentZ, bValid in tSubtable do
                M28Utilities.DrawLocation(M28Map.GetPositionFromPathingSegments(iSegmentX, iSegmentZ))
                --LOG('DrawBuildableLocations: highest build size for segX='..iSegmentX..'Z'..iSegmentZ..'='..(tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] or 'nil'))
            end
        end
    end
end

function GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerAction, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bNotYetUsedLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData, bCalledFromGetBestLocation, sBlueprintOverride)
    --Returns blueprint and location for oEngineer to build at and returns these or nil if no suitable locations can be found
    --iCatToBuildBy: Optional, specify if want to look for adjacency locations; Note to factor in 50% of the builder's size and 50% of the likely adjacency building size
    --iOptionalEngineerAction - ideally should populate this, will both help with debug and more importantly is used to track building sizes by action so can switch off parts of engineer logic when run out of build space

    --NOTE: bNotYetUsedLookForQueuedBuildings isn't currently used (instead we just use bCheckForQueuedBuildings for mexes and always set it to true)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBlueprintAndLocationToBuild'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for action (if specified) '..(iOptionalEngineerAction or 'nil')..', Engineer UC='..GetEngineerUniqueCount(oEngineer)..'; Engineer ID and LC='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Techlevel='..M28UnitInfo.GetUnitTechLevel(oEngineer)..'; tAlternativePositionToLookFrom='..repru(tAlternativePositionToLookFrom or {'nil'})..'; bBuildCheapestStructure='..tostring((bBuildCheapestStructure or false))..'; All blueprints that meet the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild))..'; iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')..'; Time='..GetGameTimeSeconds()..'; Engineer brain='..oEngineer:GetAIBrain().Nickname) end
    local bDontCheckForNoRush = not(M28Overseer.bNoRushActive)

    --Get the blueprint to build
                                                            --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition, oFactory, bGetSlowest, bGetFastest, bGetCheapest,             iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
    local sBlueprintToBuild = sBlueprintOverride or M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oEngineer, false,          false,      bBuildCheapestStructure, iOptionalCategoryForStructureToBuild)


    if sBlueprintToBuild == nil then
        --Factory specific - retry but removing any tech restrictions on iCategoryToBuild
        if bDebugMessages == true then LOG(sFunctionRef..': sBlueprintToBuild is nil before factory recheck, oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..', bCloseToUnitCap='..tostring(aiBrain[M28Overseer.refbCloseToUnitCap])..'; repru(EntityCategoryGetUnitList(iCategoryToBuild)='..repru(EntityCategoryGetUnitList(iCategoryToBuild))) end
        if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryFactory, iCategoryToBuild) then
            if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryLandFactory, iCategoryToBuild) then
                iCategoryToBuild = M28UnitInfo.refCategoryLandFactory
            elseif M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryAirFactory, iCategoryToBuild) then
                iCategoryToBuild = M28UnitInfo.refCategoryAirFactory
            elseif M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryNavalFactory, iCategoryToBuild) then
                iCategoryToBuild = M28UnitInfo.refCategoryNavalFactory
            end
            --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition, oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
            sBlueprintToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oEngineer, false,          false, bBuildCheapestStructure, iOptionalCategoryForStructureToBuild)
        end
        if not(sBlueprintToBuild) then
            if not(aiBrain[M28Overseer.refbCloseToUnitCap]) and not(M28Map.bIsCampaignMap) and not(M28Overseer.bUnitRestrictionsArePresent) then
                M28Utilities.ErrorHandler('sBlueprintToBuild is nil, could happen e.g. if try and get sparky to build sxomething it cant or try to build support factory without the HQ or if unit restrictions are present - refer to log for more details')
                if not(iCategoryToBuild) then LOG(sFunctionRef..': No category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer))
                else
                    LOG(sFunctionRef..': Had category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..'; All blueprints that satisfy the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild))..'; Engineer highest land factory tech='..oEngineer:GetAIBrain()[M28Economy.refiOurHighestLandFactoryTech]..'; bUnitRestrictionsArePresent='..tostring(M28Overseer.bUnitRestrictionsArePresent)..'; Is table of restrictions empty='..tostring(M28Utilities.IsTableEmpty(import("/lua/game.lua").GetRestrictions()))..'; iOptionalEngineerAction='..(iOptionalEngineerAction or 'nil'))
                end
            end

            --If trying to build experimental, then just build any kind of experimental
            if M28Overseer.bUnitRestrictionsArePresent and M28Utilities.DoesCategoryContainCategory(iCategoryToBuild, M28UnitInfo.refCategoryExperimentalLevel) and aiBrain:GetEconomyStoredRatio('MASS') >= 0.35 then
                --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition,                                                                                                   oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
                sBlueprintToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryExperimentalLevel -categories.TRANSPORTATION - categories.TRANSPORTFOCUS - categories.NAVAL, oEngineer, false,        false,          nil,        nil)
                --If we have ended up with a game ender then only proceed if we have sufficient eco
                if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder, sBlueprintToBuild) and M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] < 80 then
                    --If <= 350 mass per sec+45m in gametime, or < 70% mass stored, then dont build
                    local iGrossThreshold = 35
                    if GetGameTimeSeconds() >= 2700 then --45m+ into game
                        iGrossThreshold = math.max(15, iGrossThreshold - 1 * (GetGameTimeSeconds() - 2700) / 180) --Decrease threshold by 10 pass per sec for every 3m after 45m
                    end

                    if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] <= iGrossThreshold or M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamLowestMassPercentStored] <= 0.7 then
                        sBlueprintToBuild = nil
                    end
                end
            end
        end
    end

    if sBlueprintToBuild == nil then
        if bDebugMessages == true then LOG(sFunctionRef..': Finished trying to get blueprint to build, but unable to find one') end
    else
        if iOptionalEngineerAction then
            tiLastBuildingSizeFromActionForTeam[oEngineer:GetAIBrain().M28Team][iOptionalEngineerAction] = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
        end

        --Adjust the search range and record key info needed for the search
        local tEngineerPosition = oEngineer:GetPosition()
        local tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition)
        local tPotentialBuildLocations = {}

        --Increase max area to search if dealing with czar or similarly large unit due to its size
        if __blueprints[sBlueprintToBuild].Physics.SkirtSizeX >= 10 then
            iMaxAreaToSearch = iMaxAreaToSearch * 1.5
            if bDebugMessages == true then LOG(sFunctionRef..': Building a large unit such as a czar, increased iMaxAreaToSearch to '..iMaxAreaToSearch) end
        end
        --Reduce max area to search if dealing with a shield (should already have limited this earlier to some extent so this is more of a redundnacy now, but before we were guessing as to the shield size)
        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
            iMaxAreaToSearch = math.min(iMaxAreaToSearch, (__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) * 0.5)
            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with a shield so reduce max area to search based on half of shield size. iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')..'; shield size='..__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) end
        elseif EntityCategoryContains(M28UnitInfo.refCategoryTMD, sBlueprintToBuild) then
            local iTMDRange = 30
            local oTMDBP = __blueprints[sBlueprintToBuild]
            if M28Utilities.IsTableEmpty(__blueprints[sBlueprintToBuild]) == false then
                for iWeapon, tWeapon in __blueprints[sBlueprintToBuild].Weapon do
                    if tWeapon.MaxRadius then
                        iTMDRange = math.min(iTMDRange, tWeapon.MaxRadius)
                    end
                end
                iMaxAreaToSearch = math.min(iMaxAreaToSearch, math.max(11, iTMDRange * 0.8))
            end
        end


        if M28Utilities.IsTableEmpty(tTargetLocation) then tTargetLocation = tEngineerPosition end
        if bDebugMessages == true then LOG(sFunctionRef..': finishrd checking if tTargetLocation is valid, tTargetLocation='..repru(tTargetLocation)..'; tEngineerPosition='..repru(tEngineerPosition)..'; is engineer valid='..tostring(M28UnitInfo.IsUnitValid(oEngineer))..'; sBlueprintToBuild='..sBlueprintToBuild) end

        --Target location adjustments
        local oClosestUnitToTML
        if EntityCategoryContains(M28UnitInfo.refCategoryTMD, sBlueprintToBuild) then
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]) == false and M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftEnemyTML]) then
                local iStartingPlateau, iStartingLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                local iCurDist
                local iClosestDist = 100000
                local oClosestTML
                for iUnit, oUnit in M28Team.tTeamData[aiBrain.M28Team][M28Team.reftEnemyTML] do
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation)
                    if iCurDist < iClosestDist then
                        oClosestTML = oUnit
                        iClosestDist = iCurDist
                    end
                end
                iClosestDist = 100000
                local tClosestTMLLocation = oClosestTML:GetPosition()
                for iUnit, oUnit in tLZTeamData[M28Map.reftUnitsWantingTMD] do
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tClosestTMLLocation, oUnit:GetPosition())
                    if iCurDist < iClosestDist then
                        iClosestDist = iCurDist
                        oClosestUnitToTML = oUnit
                    end
                end
                local iDistToMoveAway = 10
                if EntityCategoryContains(categories.AEON, sBlueprintToBuild) then iDistToMoveAway = 6 end
                if bDebugMessages == true then LOG(sFunctionRef..': Updating target location for oClosestUnitToTML at position '..repru(oClosestUnitToTML:GetPosition())..'; oClosestUnitToTML='..oClosestUnitToTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestUnitToTML)..'; oClosestTML='..oClosestTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestTML)..'; TML position='..repru(oClosestTML:GetPosition())..'; Closest unit to TML position='..repru(oClosestUnitToTML:GetPosition())) end
                tTargetLocation = M28Utilities.MoveInDirection(oClosestUnitToTML:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnitToTML:GetPosition(), tClosestTMLLocation), 10, true, false, true)
                if iStartingPlateau > 0 and iStartingLZ > 0 then
                    --Check the new target location is in the same LZ, if not then change distance to 0
                    local iNewPlateau, iNewLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                    if not(iNewLZ == iStartingLZ) then
                        tTargetLocation = oClosestUnitToTML:GetPosition()
                    end
                end
            end

        end

        if bDebugMessages == true then LOG(sFunctionRef..': sBlueprintToBuild='..(sBlueprintToBuild or 'nil')..'; Location to look from='..repru(tTargetLocation)) end
        --Mex or hydro or mass storage - consider the resource/storage locations
        if EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryHydro + M28UnitInfo.refCategoryMassStorage, sBlueprintToBuild) then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
            local iWaterZone, iPond
            local iPlateauOrZero, iLandOrWaterZone
            local tLZOrWZData
            if bDebugMessages == true then LOG(sFunctionRef..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' is considerinb building mex or hydro '..sBlueprintToBuild..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
            if (iLandZone or 0) == 0 then
                iWaterZone = M28Map.GetWaterZoneFromPosition(tTargetLocation)
                iPond = M28Map.tiPondByWaterZone[iWaterZone]
                if iWaterZone > 0 and iPond > 0 then
                    iPlateauOrZero = 0
                    iLandOrWaterZone = iWaterZone
                    tLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
                end
            else
                tLZOrWZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                iPlateauOrZero = iPlateau
                iLandOrWaterZone = iLandZone
            end
            local tResourceLocations
            if M28Utilities.IsTableEmpty(tLZOrWZData) then M28Utilities.ErrorHandler('Dont have valid water or land zone but are looking to build a resource')
            else
                if EntityCategoryContains(M28UnitInfo.refCategoryMex, sBlueprintToBuild) then
                    tResourceLocations = tLZOrWZData[M28Map.subrefMexUnbuiltLocations]
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to build mex so tResourceLocations for Plateau'..(iPlateau or 'nil')..' LZ '..(iLandZone or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'='..repru(tResourceLocations)) end
                elseif EntityCategoryContains(M28UnitInfo.refCategoryHydro, sBlueprintToBuild) then
                    tResourceLocations = tLZOrWZData[M28Map.subrefHydroUnbuiltLocations]
                elseif EntityCategoryContains(M28UnitInfo.refCategoryMassStorage, sBlueprintToBuild) then
                    tResourceLocations = tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable]
                else M28Utilities.ErrorHandler('Unrecognised resource category')
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished getting resource locations, tResourceLocations='..repru(tResourceLocations)) end
            if tResourceLocations then
                --Cycle through and include any that are buildable
                local bCheckForQueuedBuildings = true
                --ACU shouldnt check for queued buildings as otherwise it treats its own queued order as meaning it cant build there!
                if EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then bCheckForQueuedBuildings = false end
                local tBackupResourceLocation
                for iCurResource, tCurResource in tResourceLocations do
                    if bDebugMessages == true then
                        --CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, iOptionalPlateauGroupOrZero, iOptionalLandOrWaterZone, iEngiActionToIgnore, bClearActionsIfNotStartedBuilding, bCheckForQueuedBuildings, bCheckForOverlappingBuildings)
                        LOG(sFunctionRef..': Checking if can build '..sBlueprintToBuild..' on resource location '..repru(tCurResource)..'; result='..tostring(CanBuildAtLocation(aiBrain, sBlueprintToBuild, tCurResource, iPlateau, iLandZone, nil, false, true, false))..'; Can we build just using the brain function check='..tostring(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tCurResource))..'; Is table of units in rect around tCurResource empty='..tostring(M28Utilities.IsTableEmpty(GetUnitsInRect(M28Utilities.GetRectAroundLocation(tCurResource, 0.49))))..'; will draw locations we can build on in blue, and those we cant in red. bCheckForQueuedBuildings='..tostring(bCheckForQueuedBuildings or false))
                        if CanBuildAtLocation(aiBrain, sBlueprintToBuild, tCurResource, iPlateauOrZero, iLandOrWaterZone, nil, false, bCheckForQueuedBuildings, false, false, false) then
                            M28Utilities.DrawLocation(tCurResource, 1)
                        else
                            M28Utilities.DrawLocation(tCurResource, 2)
                        end
                    end
                    if CanBuildAtLocation(aiBrain, sBlueprintToBuild, tCurResource, iPlateauOrZero, iLandOrWaterZone, nil, false, bCheckForQueuedBuildings, false, false) then
                        if bDontCheckForNoRush or M28Conditions.IsLocationInNoRushArea(tCurResource) then
                            table.insert(tPotentialBuildLocations, tCurResource)
                        end
                    elseif not(tBackupResourceLocation) and aiBrain:CanBuildStructureAt(sBlueprintToBuild, tCurResource) then
                        tBackupResourceLocation = {tCurResource[1], tCurResource[2], tCurResource[3]}
                    end
                end
                --Backup - sometimes (very rarely) we might have 1 engineer trying to build a mex, aibrain shows it as able to build, but hte main canbuildatlocation doesnt; this will add the first such location as somewhere to build if otherwise we wouldnt build anywhere despite having unbuilt locations
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if need backup location, tBackupResourceLocation='..repru(tBackupResourceLocation)..'; tPotentialBuildLocations='..repru(tPotentialBuildLocations)..'; Is tPotentialBuildLocations empty='..tostring(M28Utilities.IsTableEmpty(tPotentialBuildLocations))) end
                if tBackupResourceLocation and M28Utilities.IsTableEmpty(tPotentialBuildLocations) then
                    table.insert(tPotentialBuildLocations, tBackupResourceLocation)
                    if bDebugMessages == true then LOG(sFunctionRef..': Relying on backup location') end
                end
            end
        else
            --Get adjacency location if we want adjacency
            if iCatToBuildBy or oUnitToBuildBy then
                if bDebugMessages == true then LOG(sFunctionRef..': About to get potential adjacency locations, sBlueprintToBuild='..(sBlueprintToBuild or 'nil')..'; is iCatToBuildBy empty='..tostring(iCatToBuildBy == nil)) end
                tPotentialBuildLocations = GetPotentialAdjacencyLocations(aiBrain, sBlueprintToBuild, tTargetLocation, iMaxAreaToSearch, iCatToBuildBy, oUnitToBuildBy)
                if bDebugMessages == true then LOG(sFunctionRef..': Finished getting potential adjacency locations, sBlueprintToBuild='..sBlueprintToBuild..'; tPotentialBuildLocations='..repru(tPotentialBuildLocations)) end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': is tPotentialBuildLocations empty='..tostring(M28Utilities.IsTableEmpty(tPotentialBuildLocations))..'; tTargetLocation='..repru(tTargetLocation)) end
            if M28Utilities.IsTableEmpty(tPotentialBuildLocations) then
                --Shield specific - dont want to try searching further away
                if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) and iMaxAreaToSearch and tAlternativePositionToLookFrom then
                    --Try a more precise search around the target
                    local iMaxSegmentAdjust = math.floor(iMaxAreaToSearch * 0.7 / M28Map.iLandZoneSegmentSize) --70% due to diagonals
                    if bDebugMessages == true then LOG(sFunctionRef..': Trying to build shield, sBlueprintToBuild='..sBlueprintToBuild..'; iMaxSegmentAdjust='..iMaxSegmentAdjust..'; iMaxAreaToSearch='..iMaxAreaToSearch) end
                    if iMaxSegmentAdjust >= 1 then
                        local iBaseSegmentX, iBaseSegmentZ = M28Map.GetPathingSegmentFromPosition(tAlternativePositionToLookFrom)

                        local iSizeWanted = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
                        tPotentialBuildLocations = {}
                        if bDebugMessages == true then LOG(sFunctionRef..': Trying to build a shield so dont want to search further afaield, will do detailed check around target instead, iSizeWanted='..iSizeWanted..'; iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ) end
                        for iCurSegmentX = math.max(1, iBaseSegmentX - iMaxSegmentAdjust), iBaseSegmentX + iMaxSegmentAdjust, 1 do
                            for iCurSegmentZ = math.max(1, iBaseSegmentZ - iMaxSegmentAdjust), iBaseSegmentZ + iMaxSegmentAdjust, 1 do
                                if bDebugMessages == true then LOG(sFunctionRef..': Max size for Cur SegmentX'..iCurSegmentX..'Z'..iCurSegmentZ..'='.. (tLZData[M28Map.subrefBuildableSizeBySegment][iCurSegmentX][iCurSegmentZ] or 0)) end
                                if (tLZData[M28Map.subrefBuildableSizeBySegment][iCurSegmentX][iCurSegmentZ] or 0) >= iSizeWanted then
                                    table.insert(tPotentialBuildLocations, M28Map.GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ))
                                    if bDebugMessages == true then LOG(sFunctionRef..': Found a segment where the highest size should be enough for a shield, will add to potential build locations') end
                                end
                            end
                        end
                    end
                else
                    --use the predefined build locations for the land zoneM28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]M28Map.subrefBuildLocationSegmentCountBySize][iSize]
                    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                    local iPond
                    local tLZOrWZData
                    if (iLandOrWaterZone or 0) == 0 then
                        iLandOrWaterZone = M28Map.GetWaterZoneFromPosition(tTargetLocation)
                        if iLandOrWaterZone then
                            iPond = M28Map.tiPondByWaterZone[iLandOrWaterZone]
                            tLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                            iPlateauOrZero = 0
                        else
                            iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tTargetLocation)
                            if iPlateauOrZero == 0 and (iLandOrWaterZone or 0) > 0 then
                                iPond = M28Map.tiPondByWaterZone[iLandOrWaterZone]
                                tLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                            end
                        end
                    else
                        tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                    end
                    local iSize = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
                    --Game-ender specific logic - use a larger build size
                    if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder, sBlueprintToBuild) then
                        --Artillery structures (rapid fire and mavor) - use czar
                        if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalArti - categories.MOBILE, sBlueprintToBuild) then
                            iSize = math.max(iSize, iMaxBuildingSize)
                        else
                            --Yolona, scathis
                            iSize = math.max(iSize, 16)
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Are trying to build a gameender, iSize to use='..iSize) end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, sBlueprintToBuild) then
                        local tAlliedUnits = tLZOrWZData[M28Map.subrefWZTeamData][aiBrain.M28Team][M28Map.subreftoLZOrWZAlliedUnits]
                        if M28Utilities.IsTableEmpty(tAlliedUnits) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tAlliedUnits)) == false then
                            iSize = math.max(iSize, 16) --Czar can be built on cliffs where naval units cant be, hence do size 16 which is tempest
                            if bDebugMessages == true then LOG(sFunctionRef..': Are trying to build a 2nd or more naval factory so increasing size wanted for the naval factory to '..iSize) end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Dont have any naval fac in this WZ, is tAlliedUnits empty='..tostring(M28Utilities.IsTableEmpty(tAlliedUnits))..'; iSize='..iSize..'; aiBrain='..aiBrain.Nickname..'; Highest naval fac='..(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyNavalFactoryTech] or 'nil')) end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have searched all segments in the land zone before, tLocation='..repru(tTargetLocation)..'; sBlueprintToBuild='..sBlueprintToBuild..'; iSize='..iSize..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize]='..repru(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize])..'; Segments considered for build locations='..repru(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize])..'; Total segments in LZ (nil if wZ)='..(tLZOrWZData[M28Map.subrefLZTotalSegmentCount] or 'nil')..'; Is table of build locations empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize]))) end
                    local iCycleSizeLimit
                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield * categories.TECH3, sBlueprintToBuild) and (M28Map.bIsCampaignMap or not(M28Overseer.refbCloseToUnitCap)) then iCycleSizeLimit = 4 end
                    --GetPotentialBuildLocationsNearLocation(aiBrain, tLZOrWZData, iPlateauOrZero, iLandOrWaterZone, iSize, iOptionalMaxCycleSize)
                    tPotentialBuildLocations = GetPotentialBuildLocationsNearLocation(aiBrain, tLZOrWZData, iPlateauOrZero, iLandOrWaterZone, iSize, iCycleSizeLimit)
                    if M28Utilities.IsTableEmpty(tPotentialBuildLocations) and bDontCheckForNoRush then
                        if tLZOrWZData[M28Map.subrefLZbCoreBase] then
                            M28Utilities.ErrorHandler('Run out of build locations for iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iSize='..iSize, true)
                            if bDebugMessages == true and not(iPond) then
                                LOG(sFunctionRef..': Will draw affected land zone, and if we have any blacklisted locations will draw in red')
                                M28Map.DrawSpecificLandZone(iPlateauOrZero, iLandOrWaterZone)
                                DrawBlacklistedLocations(tLZOrWZData)
                            end
                            --Treat the closest land zone as core to expand locations to do building going forwards
                            if not(iPond) and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false and tLZOrWZData[M28Map.subrefLZPathingToOtherLandZones][1] then
                                M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][tLZOrWZData[M28Map.subrefLZPathingToOtherLandZones][1][M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefbCoreBaseOverride] = true
                                if bDebugMessages == true then LOG(sFunctionRef..': have made alt LZ'..tLZOrWZData[M28Map.subrefLZPathingToOtherLandZones][1][M28Map.subrefLZNumber]..' a core base now') end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': No adjacency locations or not looking for adjacency; tPotentialBuildLocations based on land zone build locations for iSize='..iSize..'; Blueprint size='..M28UnitInfo.GetBuildingSize(sBlueprintToBuild)..'='..repru(tPotentialBuildLocations)..'; will draw each location in light blue; Is tPotentialBuildLocations empty='..tostring(M28Utilities.IsTableEmpty(tPotentialBuildLocations)))
                        if M28Utilities.IsTableEmpty(tPotentialBuildLocations) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': Total number of potential build locations='..table.getn(tPotentialBuildLocations)) end
                            for iEntry, tEntry in tPotentialBuildLocations do
                                M28Utilities.DrawLocation(tEntry, 5)
                            end
                        end
                    end
                end
            end
        end

        --Pick the preferred build location
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of potential build locations empty='..tostring(M28Utilities.IsTableEmpty(tPotentialBuildLocations))..'; sBlueprintToBuild='..sBlueprintToBuild..'; iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')) end
        if M28Utilities.IsTableEmpty(tPotentialBuildLocations) == false then
            --GetBestBuildLocationForTarget(oEngineer, sBlueprintToBuild, tTargetLocation, tPotentialBuildLocations, iOptionalMaxDistanceFromTargetLocation)
            local tBestLocation = GetBestBuildLocationForTarget(oEngineer, sBlueprintToBuild, tTargetLocation, tPotentialBuildLocations, iMaxAreaToSearch, bCalledFromGetBestLocation)
            if bDebugMessages == true then LOG(sFunctionRef..': Just got best location to build at, tBestLocation='..repru(tBestLocation)) end
            if tBestLocation then
                --TMD check - if too far away to proect the unit we are interested in, then flag that dont want to try building tmd for the unit anymore
                if oClosestUnitToTML then
                    local iCurDist = M28Utilities.GetDistanceBetweenPositions(oClosestUnitToTML:GetPosition(), tBestLocation)
                    if bDebugMessages == true then LOG(sFunctionRef..': Are getting best location for TMD so will check if this best location is too far away, iCurDist='..iCurDist..'; sBlueprintToBuild='..sBlueprintToBuild) end
                    if iCurDist >= 30 or (EntityCategoryContains(categories.AEON, sBlueprintToBuild) and iCurDist >= 12.5) then
                        oClosestUnitToTML[M28Building.refbNoNearbyTMDBuildLocations] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Flagging that we dont think there are nearby TMD locations for oClosestUnitToTML='..oClosestUnitToTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestUnitToTML)..'; If location is really far away then will clear altogether') end
                        if iCurDist >= 40 then
                            --Dont bother trying to build as so far away may be of no use
                            tBestLocation = nil
                        end
                    end
                end
                return sBlueprintToBuild, tBestLocation
            else
                if bDebugMessages == true then LOG(sFunctionRef..': We couldnt find any suitable best location for sBlueprintToBuild='..sBlueprintToBuild..'; so will abort') end
            end
        elseif bDebugMessages == true then LOG(sFunctionRef..': No build locations found')
        end
    end
    return sBlueprintToBuild, nil
end

function ResetFailedShieldBuildDistance(oUnit, iDelayInSeconds)
    WaitSeconds(iDelayInSeconds)
    if M28UnitInfo.IsUnitValid(oUnit) then
        oUnit[refiFailedShieldBuildDistance] = nil
    end
end

function GetBestBuildLocationForTarget(oEngineer, sBlueprintToBuild, tTargetLocation, tPotentialBuildLocations, iOptionalMaxDistanceFromTargetLocation, bAlreadyTriedAlternatives)
    --Assumes we have already checked for: Adjacency; In the same land zone; Valid location to build
    --WIll then consider: If engineer can build without moving; How far away it is from the engineer; if it will block mex adjacency, and (if we specify a maximum distance) if it is within the max distance
    --bAlreadyTriedAlternatives - set to true if we have already called this function via this function
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBestBuildLocationForTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iHighestPriority = -1000
    local iCurPriority, iCurDistance
    local iBestLocationRef
    local oEngiBP = oEngineer:GetBlueprint()
    local iNewBuildingRadius = M28UnitInfo.GetBuildingSize(sBlueprintToBuild) * 0.5
    local iBuilderRange = (oEngiBP.Economy.MaxBuildDistance or 5) + math.min(oEngiBP.SizeX, oEngiBP.SizeZ) + iNewBuildingRadius - 0.5
    local rBuildAreaRect
    local iMaxRange = iOptionalMaxDistanceFromTargetLocation or 200
    local aiBrain = oEngineer:GetAIBrain()
    local bBuildTowardsHydro = false
    local tLocationToBuildTowards
    local tiClosestDistByPriorityAndCount --[x] is the priority before adjusting for this, returns {iDistance, iCount} where iCount is the number of times this has been updated (as need to increase priority by this to ensure we have a greater uplift than a further away distance)
    local bTryOtherLocationsIfNoneBuildableImmediately = false
    local bTryAndBuildAtlantis = false
    if EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, sBlueprintToBuild) then bTryAndBuildAtlantis = true end

    if GetGameTimeSeconds() <= 10 and EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryFactory, sBlueprintToBuild) then
        if not(bAlreadyTriedAlternatives) then
            bTryOtherLocationsIfNoneBuildableImmediately = true
        end
    end
    --Reduce likelihood of units switching build location targets slightly
    local tLastBuildLocationForUnit
    local tLastOrder = oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]]
    if tLastOrder[M28Orders.subrefsOrderBlueprint] and tLastOrder[M28Orders.subrefsOrderBlueprint] == sBlueprintToBuild then tLastBuildLocationForUnit = tLastOrder[M28Orders.subreftOrderPosition] end
    if bDebugMessages == true then
        local iEngineerSegmentX, iEngineerSegmentZ = M28Map.GetPathingSegmentFromPosition(oEngineer:GetPosition())
        LOG(sFunctionRef..': iTeam='..aiBrain.M28Team..'; aiBrain='..aiBrain.Nickname..'; Time='..GetGameTimeSeconds()..'; tLastOrder reprs='..reprs(tLastOrder)..'; tLastBuildLocationForUnit if we think it is the same='..repru(tLastBuildLocationForUnit)..'; sBlueprintToBuild='..sBlueprintToBuild..'; Building size of BP to build='..M28UnitInfo.GetBuildingSize(sBlueprintToBuild)..'; Engineer position='..repru(oEngineer:GetPosition())..'; Dist to target='..M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), tTargetLocation)..'; iEngineerSegmentX='..iEngineerSegmentX..'Z='..iEngineerSegmentZ)
    end

    local bLocationBuildableImmediately, bBestLocationBuildableImmediately
    local bDontCheckPlayableArea = false
    if M28Map.bIsCampaignMap then
        bDontCheckPlayableArea = true
        if M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.rebTeamOnlyHasCampaignAI] then bDontCheckPlayableArea = false end
    end
    --Start of game - build factory closer to hydro if possible
    if GetGameTimeSeconds() <= 60 and EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, sBlueprintToBuild) then
        --Do we have hydro in this LZ? dont want to consider if water zone
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
        if (iLandZone or 0) > 0 and iPlateau > 0 then
            local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefHydroUnbuiltLocations]) == false then
                local iClosestHydroDist = 100000
                local iCurDist
                for iEntry, tHydro in tLZData[M28Map.subrefHydroUnbuiltLocations] do
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), tHydro)
                    if iCurDist < iClosestHydroDist then
                        iClosestHydroDist = iCurDist
                        tLocationToBuildTowards = {tHydro[1], tHydro[2], tHydro[3]}
                        bBuildTowardsHydro = true
                    end
                end
            end
        end
    end

    if not(tLocationToBuildTowards) then
        --Build towards the midpoing except for certain unit categories
        if not(EntityCategoryContains(M28UnitInfo.refCategoryPD + M28UnitInfo.refCategoryTMD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild)) then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
            if (iLandZone or 0) > 0 and iPlateau > 0 then
                local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                tLocationToBuildTowards = tLZData[M28Map.subrefMidpoint]
            end
        end
    end
    if tLocationToBuildTowards then tiClosestDistByPriorityAndCount = {} end

    local bCheckForStorageAdjacency = EntityCategoryContains(M28UnitInfo.refCategoryMassStorage, sBlueprintToBuild)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; sBLueprintToBuild='..(sBlueprintToBuild or 'nil')..'; tTargetLocation='..repru(tTargetLocation)..'; tPotentialBuildLocations='..repru(tPotentialBuildLocations)..'; iOptionalMaxDistanceFromTargetLocation='..(iOptionalMaxDistanceFromTargetLocation or 'nil')..'; iMaxRange='..iMaxRange..'; iBuilderRange='..iBuilderRange..'; iNewBuildingRadius='..iNewBuildingRadius..'; bBuildTowardsHydro='..tostring(bBuildTowardsHydro)..'; tLocationToBuildTowards (e.g. for hydro)='..repru(tLocationToBuildTowards)..'; Engineer position='..repru(oEngineer:GetPosition())) end
    --local tiTopThreeLocationRefs = {}
    --local tiTopThreePriorities = {-100, -100, -100}
    --local iPriorityValueOfNoUnits = 1 --i.e. priority adjust if no units in build area
    --local iMaxRanking = table.getn(tiTopThreePriorities)
    for iCurLocation, tCurLocation in tPotentialBuildLocations do
        if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tCurLocation) then
            bLocationBuildableImmediately = true
            iCurPriority = -100
            iCurDistance = M28Utilities.GetDistanceBetweenPositions(tTargetLocation, tCurLocation)
            if bDebugMessages == true then
                LOG(sFunctionRef..': Considering location ref '..iCurLocation..'; tCurLocation='..repru(tCurLocation)..'; iCurDistance='..iCurDistance..'; iMaxRange='..iMaxRange..'; Can we build here='..tostring(oEngineer:GetAIBrain():CanBuildStructureAt(sBlueprintToBuild, tCurLocation)))
                if tLastBuildLocationForUnit then LOG(sFunctionRef..': Rough dist to last build location='..M28Utilities.GetRoughDistanceBetweenPositions(tCurLocation, tLastBuildLocationForUnit)) end
                M28Utilities.DrawLocation(tCurLocation)
            end
            if aiBrain:CanBuildStructureAt(sBlueprintToBuild, tCurLocation) then
                if iCurDistance <= iMaxRange then
                    if iCurDistance <= iBuilderRange then
                        iCurPriority = iCurPriority + 3
                        if bDebugMessages == true then LOG(sFunctionRef..': Within build range so increasing priority by 3') end
                    else
                        bLocationBuildableImmediately = false
                    end
                    rBuildAreaRect = Rect(tCurLocation[1] - iNewBuildingRadius, tCurLocation[3] - iNewBuildingRadius, tCurLocation[1] + iNewBuildingRadius, tCurLocation[3] + iNewBuildingRadius)
                    if bDebugMessages == true then LOG(sFunctionRef..': Will force debug on whether we have reclaim in rec, do we have reclaim='..tostring(M28Map.GetReclaimInRectangle(1, rBuildAreaRect, true))) end
                    if M28Map.GetReclaimInRectangle(1, rBuildAreaRect) == false then --Less of an issue now that FAF clears trees that are in the way (but still relevant for rocks and tree groups)
                        iCurPriority = iCurPriority + 2
                        if bDebugMessages == true then LOG(sFunctionRef..': No reclaim in build area so increasing priority by 2') end
                    else
                        bLocationBuildableImmediately = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Reclaim in build area so not increasing priority') end
                    end
                    if not(M28Conditions.AreMobileLandUnitsInRect(rBuildAreaRect)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': No units in rect so increasing priority by 4') end
                        iCurPriority = iCurPriority + 4
                    else
                        bLocationBuildableImmediately = false
                        if iCurDistance <= iBuilderRange then iCurPriority = iCurPriority + 2 end
                    end
                    if iCurDistance <= 50 then
                        if iCurDistance <= math.max(10, iBuilderRange - 0.5) then
                            iCurPriority = iCurPriority + 7
                            if bDebugMessages == true then LOG(sFunctionRef..': Location is within 10 so increasing priority by 7') end
                        else
                            bLocationBuildableImmediately = false
                            if iCurDistance <= 15 then
                                iCurPriority = iCurPriority + 6
                            elseif iCurDistance <= 25 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Location within 25 so increasing priority by 5') end
                                iCurPriority = iCurPriority + 5
                            else
                                iCurPriority = iCurPriority + 3
                            end
                        end
                    end
                    --General dist adjust
                    if iCurDistance >= 15 then
                        iCurPriority = iCurPriority - iCurDistance / iMaxRange * 6
                    end

                    --Adjust if can build immediately
                    if bLocationBuildableImmediately then
                        iCurPriority = iCurPriority + 1
                        if EntityCategoryContains(M28UnitInfo.refCategorySMD + M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryTMD, sBlueprintToBuild) then iCurPriority = iCurPriority + 4 end
                    end

                    --Naval fac specifically - want a bit more space to build - can we build atlantis both here and 2 to the left and right?
                    if bTryAndBuildAtlantis and aiBrain:CanBuildStructureAt('ues0401', tCurLocation) then
                        iCurPriority = iCurPriority + 10
                        if bDebugMessages == true then LOG(sFunctionRef..': Can build atlantis here so increasing prioriyt, will increase more if can build to left and right') end

                        if aiBrain:CanBuildStructureAt('ues0401', {tCurLocation[1] - 3, tCurLocation[2], tCurLocation[3]}) then iCurPriority = iCurPriority + 10 end
                        if aiBrain:CanBuildStructureAt('ues0401', {tCurLocation[1] + 3, tCurLocation[2], tCurLocation[3]}) then iCurPriority = iCurPriority + 10 end
                    end

                    --Adjust if was location of our last build order
                    if tLastBuildLocationForUnit and M28Utilities.GetRoughDistanceBetweenPositions(tLastBuildLocationForUnit, tCurLocation) <= 0.75 then
                        iCurPriority = iCurPriority + 1
                        if bDebugMessages == true then LOG(sFunctionRef..': Are close to our last build order location so increasing priority by 1') end
                    end

                    --Mass s torage specific - value higher mexes (wont bother with mass fabs)
                    if bCheckForStorageAdjacency then
                        local rAdjacencyRect = M28Utilities.GetRectAroundLocation(tCurLocation, 2.749) --If changing here also update m28events and m28economy
                        local tPotentiallyAdjacentMexes = GetUnitsInRect(rAdjacencyRect)
                        local iAdjacencyValue = 0
                        local iConstructionFactor
                        if M28Utilities.IsTableEmpty(tPotentiallyAdjacentMexes) == false then
                            tPotentiallyAdjacentMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tPotentiallyAdjacentMexes)
                            if M28Utilities.IsTableEmpty(tPotentiallyAdjacentMexes) == false then
                                for iMex, oMex in tPotentiallyAdjacentMexes do
                                    if M28Utilities.GetDistanceBetweenPositions(oMex:GetPosition(), tCurLocation) <= 2.25 then
                                        if oMex:GetFractionComplete() < 1 then
                                            iConstructionFactor = oMex:GetFractionComplete() * 0.75
                                        else
                                            iConstructionFactor = 1
                                        end
                                        iAdjacencyValue = iAdjacencyValue + (oMex:GetBlueprint().Economy.ProductionPerSecondMass or 0) * iConstructionFactor
                                    end
                                end
                            end
                        end
                        iCurPriority = iCurPriority + iAdjacencyValue
                    end



                    --Build towards hydro adjust
                    if tLocationToBuildTowards then
                        local iCurDistTowardsBuildTowards = M28Utilities.GetDistanceBetweenPositions(tCurLocation, tLocationToBuildTowards)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering adjustment for building towards hydro, iCurDistTowardsBuildTowards='..iCurDistTowardsBuildTowards..'; iCurPrioriyt='..iCurPriority..'; tiClosestDistByPriorityAndCount for this priority='..repru(tiClosestDistByPriorityAndCount[iCurPriority])..'; Are we equal or less than this distance='..tostring(iCurDistTowardsBuildTowards <= (tiClosestDistByPriorityAndCount[iCurPriority][1] or 100000))) end
                        if iCurDistTowardsBuildTowards <= (tiClosestDistByPriorityAndCount[iCurPriority][1] or 100000) then
                            tiClosestDistByPriorityAndCount[iCurPriority] = {iCurDistTowardsBuildTowards, (tiClosestDistByPriorityAndCount[iCurPriority][2] or 0) + 1}
                            iCurPriority = iCurPriority + tiClosestDistByPriorityAndCount[iCurPriority][2] * 0.1
                            if bBuildTowardsHydro then iCurPriority = iCurPriority + 1 end
                            if bDebugMessages == true then LOG(sFunctionRef..': Increased priority due to being the closest for this base level to hydro or zone midpoint, iCurPriority after uplift='..iCurPriority) end
                        end
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Not within max range, so will just try and pick the closest location within range') end
                    --Not within range, so have priority factor in range so at least we pick the cloesst to being in range
                    iCurPriority = iCurPriority - 5 - 1 * iCurDistance / 1000
                end
            else
                iCurPriority = iCurPriority - 100
                --NOTE: Dont include adjustments after this poitn, as abovel ogic assumes we have got to the post-modifier priority for buildtowardshydro
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering tCurLocation='..repru(tCurLocation)..'; iCurDistance='..iCurDistance..'; iCurPriority='..iCurPriority) end
            --[[ Started drafting code below so we would only check for units in rec for the top 3 entries, but decided to scrap as already checking for htis above via M28Conditions check for mobile units
            --Only record if is top priority, or close enough to top priority that positions might change after factoring in units in rectangle
            if iCurPriority > tiTopThreePriorities[iMaxRanking] and iCurPriority + iPriorityValueOfNoUnits > tiTopThreePriorities[1] then
                for iCurRanking = 1, iMaxRanking, 1 do
                    if iCurPriority > tiTopThreePriorities[iCurRanking] then
                        --Reorder existing entries
                        if iCurRanking < iMaxRanking then
                            for iRanking = iMaxRanking, iCurRanking + 1, -1 do
                                tiTopThreePriorities[iRanking] = tiTopThreePriorities[iRanking - 1]
                                tiTopThreeLocationRefs[iRanking] = tiTopThreeLocationRefs[iRanking - 1]
                            end
                        end
                        tiTopThreePriorities[iCurRanking] = iCurPriority
                        tiTopThreeLocationRefs[iCurRanking] = iCurLocation
                        break
                    end
                end
            end--]]
            if iCurPriority > iHighestPriority then
                iHighestPriority = iCurPriority
                iBestLocationRef = iCurLocation
                bBestLocationBuildableImmediately = bLocationBuildableImmediately
                if bDebugMessages == true then LOG(sFunctionRef..': Have a new best priority, iHighestPriority='..iHighestPriority) end
            end
        end
    end
    --Adjust priorities for units in rect

    --[[if tiTopThreeLocationRefs[2] then
        local iCurPriority
        local bDontHaveUnitsInBuildArea
        for iEntry, iRef in tiTopThreeLocationRefs do
            iCurPriority = tiTopThreePriorities[iEntry]
            bDontHaveUnitsInBuildArea = true
            local tNearbyUnits = GetUnitsInRect(M28Utilities.GetRectAroundLocation(tTargetLocation, iNewBuildingRadius - 0.5))
            if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                bDontHaveUnitsInBuildArea = false
            end
            if bDebugMessages == true then
                LOG(sFunctionRef..': bDontHaveUnitsInBuildArea='..tostring(bDontHaveUnitsInBuildArea)..'; iEntry='..iEntry..'; Priority before='..tiTopThreePriorities[iEntry]..'; iPriorityValueOfNoUnits='..iPriorityValueOfNoUnits)
                M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tTargetLocation, iNewBuildingRadius - 0.5), 3, 50, nil)
            end
            if bDontHaveUnitsInBuildArea then
                tiTopThreePriorities[iEntry] = tiTopThreePriorities[iEntry] + iPriorityValueOfNoUnits
            end
        end
    end

    iHighestPriority = tiTopThreePriorities[1]
    iBestLocationRef = tiTopThreeLocationRefs[1]--]]

    if bDebugMessages == true then

        LOG(sFunctionRef..': Finished searching, is iBestLocationRef nil='..tostring(iBestLocationRef == nil)..'; Are we trying to build a shield='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild))..'; iHighestPriority='..(iHighestPriority or 'nil'))
        if iBestLocationRef then
            local tCurLocation = tPotentialBuildLocations[iBestLocationRef]
            local rBuildAreaRect = Rect(tCurLocation[1] - iNewBuildingRadius, tCurLocation[3] - iNewBuildingRadius, tCurLocation[1] + iNewBuildingRadius, tCurLocation[3] + iNewBuildingRadius)
            local tUnitsInBuildArea = GetUnitsInRect(rBuildAreaRect)
            LOG(sFunctionRef..': Best location='..repru(tPotentialBuildLocations[iBestLocationRef])..'; Are there mobile units in this rect='..tostring(M28Conditions.AreMobileLandUnitsInRect(rBuildAreaRect))..'; is tUnitsInBuildArea empty='..tostring(M28Utilities.IsTableEmpty(tUnitsInBuildArea))..'; Will draw build area rect')
            if tUnitsInBuildArea then
                for iUnit, oUnit in tUnitsInBuildArea do
                    LOG(sFunctionRef..': Unit in build area: iUnit='..iUnit..'; Unit ID and LC='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit is mobile land='..tostring(EntityCategoryContains(categories.MOBILE * categories.LAND, oUnit.UnitId)))
                end
            end
            M28Utilities.DrawRectangle(rBuildAreaRect, 3)
        end
    end
    if not(iBestLocationRef) and EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
        local tNearbyUnits = GetUnitsInRect(M28Utilities.GetRectAroundLocation(tTargetLocation, 2))
        if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
            for iUnit, oUnit in tNearbyUnits do
                oUnit[refiFailedShieldBuildDistance] = math.max(iOptionalMaxDistanceFromTargetLocation + 1, (oUnit[refiFailedShieldBuildDistance] or 0))
                --Reset this after 6 minutes (we might have more buildable areas open up)
                ForkThread(ResetFailedShieldBuildDistance, oUnit, 360)
                if bDebugMessages == true then LOG(sFunctionRef..': Set shield failed idstance for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to '..oUnit[refiFailedShieldBuildDistance]) end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': bBestLocationBuildableImmediately='..tostring(bBestLocationBuildableImmediately)..'; bTryOtherLocationsIfNoneBuildableImmediately='..tostring(bTryOtherLocationsIfNoneBuildableImmediately or false)) end
    if not(bBestLocationBuildableImmediately) and bTryOtherLocationsIfNoneBuildableImmediately then
        local tLZTeamData, tLZData
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
        if (iLandZone or 0) > 0 and iPlateau > 0 then
            tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
            local iTeam = oEngineer:GetAIBrain().M28Team
            tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
        end
        --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerAction, iCategoryToBuild, iMaxAreaToSearch,                  iCatToBuildBy, tAlternativePositionToLookFrom, bNotYetUsedLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData, bCalledFromGetBestLocation, sBlueprintOverride)
        local sRedundantBlueprint, tAltBestLocation = GetBlueprintAndLocationToBuild(aiBrain, oEngineer, nil,                        nil,           iOptionalMaxDistanceFromTargetLocation, nil,        tTargetLocation,                true,                               nil,            nil,                                nil,                    tLZData, tLZTeamData,   true,                   sBlueprintToBuild)
        if bDebugMessages == true then LOG(sFunctionRef..': tAltBestLocation='..repru(tAltBestLocation)..'; oEngineer:GetPosition='..repru(oEngineer:GetPosition())) end
        if tAltBestLocation and M28Utilities.GetDistanceBetweenPositions(tAltBestLocation, oEngineer:GetPosition()) <= iMaxRange then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return tAltBestLocation
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tPotentialBuildLocations[iBestLocationRef]='..repru(tPotentialBuildLocations[iBestLocationRef])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if iBestLocationRef then return tPotentialBuildLocations[iBestLocationRef]
    else return nil
    end
end





function GetLocationToMoveForConstruction(oUnit, tTargetLocation, sBlueprintID, iBuildDistanceMod, bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation)
    --Gets the location that oBuilder should move to in order to be within range of building on tLocation, factoring in the size of buildingType
    --sBlueprintID - if nil, then will treat the action as having a size of 0
    --iBuildDistanceMod - increase or decrease if want to move closer/further away than build distance would send you; e.g. if want to get 3 inside the build distance, set this to -3
    --Returns nil if no valid location or are in range and bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation is not true

    --Note: Will always try to be a minimum of 1 away


    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetLocationToMoveForConstruction'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local sPathing = M28UnitInfo.GetUnitPathingType(oUnit)
    local iPathingGroupWanted = NavUtils.GetLabel(sPathing, oUnit:GetPosition())

    local tPotentialMoveLocation
    if bDebugMessages == true then LOG(sFunctionRef..': Start, time='..GetGameTimeSeconds()..'; tTargetLocatino='..repru(tTargetLocation)..'; Unit position='..repru(oUnit:GetPosition())..'; sBlueprintID='..(sBlueprintID or 'nil')..'; oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')) end
    local iAngleFromTargetToBuilder = M28Utilities.GetAngleFromAToB(tTargetLocation, oUnit:GetPosition())
    local iBuildRange = oUnit:GetBlueprint().Economy.MaxBuildDistance
    local iDistanceWantedFromTarget = math.max(1, iBuildRange + (iBuildDistanceMod or 0))
    local oBlueprint
    local iBuildingRadius = 0
    if sBlueprintID then
        oBlueprint = __blueprints[sBlueprintID]
        if oBlueprint then
            iBuildingRadius = math.min(oBlueprint.Physics.SkirtSizeX, oBlueprint.Physics.SkirtSizeZ) - 0.01
        end
    end
    iDistanceWantedFromTarget = iDistanceWantedFromTarget + iBuildingRadius

    if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; tTargetLocation='..repru(tTargetLocation)..'; sBlueprintID='..(sBlueprintID or 'nil')..'; iBuildDistanceMod='..(iBuildDistanceMod or 'nil')..'bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation='..tostring(bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation or false)) end
    if not(bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation) then
        --Check if we are in range already
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if we are already in range of the target, distance='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation)..'; iDistanceWantedFromTarget='..iDistanceWantedFromTarget..'; iBuildingRadius='..iBuildingRadius) end
        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation) <= iDistanceWantedFromTarget then
            if bDebugMessages == true then LOG(sFunctionRef..': Target location is already in range') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return nil
        end
    end

    for iDistanceToMove = iDistanceWantedFromTarget, 1, -1 do
        tPotentialMoveLocation = M28Utilities.MoveInDirection(tTargetLocation,iAngleFromTargetToBuilder, iDistanceToMove, true, false, true)
        if NavUtils.GetLabel(sPathing, tPotentialMoveLocation) == iPathingGroupWanted then
            if bDebugMessages == true then LOG(sFunctionRef..': Have a valid location engi can move to='..repru(tPotentialMoveLocation)..'; Dist from target='..M28Utilities.GetDistanceBetweenPositions(tPotentialMoveLocation, tTargetLocation)..'; iDistanceToMove='..(iDistanceToMove or 'nil')..'; will check no buildings in a radius of 5 that are blocking this location') end
            local rRectangleToSearch = M28Utilities.GetRectAroundLocation(tPotentialMoveLocation, 5)
            local tBlockingUnits = GetUnitsInRect(rRectangleToSearch)
            local bDontMove = false
            if M28Utilities.IsTableEmpty(tBlockingUnits) == false then
                local tBlockingBuildings = EntityCategoryFilterDown(categories.STRUCTURE, tBlockingUnits)
                local iBlockingSize
                for iBuilding, oBuilding in tBlockingBuildings do
                    iBlockingSize = M28UnitInfo.GetBuildingSize(oBuilding.UnitId) * 0.5
                    local tBuildingPosition = oBuilding:GetPosition()
                    if math.abs(tBuildingPosition[1] - tPotentialMoveLocation[1]) <= iBlockingSize and math.abs(tBuildingPosition[3] - tPotentialMoveLocation[3]) <= iBlockingSize then
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Will be blocked by a building so wont move here')
                            M28Utilities.DrawLocation(tPotentialMoveLocation, 2)
                        end
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return nil
                    end
                end
            end


            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return tPotentialMoveLocation
        elseif bDebugMessages == true then LOG(sFunctionRef..': Cant move to the desired location, will draw in red') M28Utilities.DrawLocation(tPotentialMoveLocation, 2)
        end
        if iDistanceToMove <= 1 then
            if bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return {tTargetLocation[1], tTargetLocation[2], tTargetLocation[3]}
            end
            break
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return nil

    --Below was from M27 - left commented out as might be of use when introduce naval factory logic again
    --[[
tPossibleTarget = M28Map.GetPositionAtOrNearTargetInPathingGroup(tBuilderLocation, tLocation, iDistanceWantedFromTarget, 0, oBuilder, true, true, iMinDistanceFromCurrentBuilderMoveTarget)

--Adjust further for naval factory to facilitate greater cliff-building
if tPossibleTarget and EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, sBlueprintID) then
    --If we move from Possible target towards our currnet position do we come across a cliff very soon?

    local bHaveCliff = false

    local iAngleFromMoveTarget = M28Utilities.GetAngleFromAToB(tPossibleTarget, tBuilderLocation)

    local iMaxCliffSearchRange = 15 + math.floor(iBuildDistance)

    function IsCliffBlockingTarget(tTarget)
        local iDistToMoveTarget = M28Utilities.GetDistanceBetweenPositions(tBuilderLocation, tTarget)
        local tCliffPositionCheck
        if iDistToMoveTarget > 1 then
            for iDistAdjust = 1, math.min(iMaxCliffSearchRange, math.floor(iDistToMoveTarget)) do
                tCliffPositionCheck = M28Utilities.MoveInDirection(tPossibleTarget, iAngleFromMoveTarget, iDistAdjust, true, false)
                if not(NavUtils.GetLabel(sPathing, tCliffPositionCheck) == iEngiPathingGroup) then
                    return true
                end
            end
        end
        return false
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Building naval factory, IsCliffBlockingTarget(tPossibleTarget='..tostring(IsCliffBlockingTarget(tPossibleTarget))..'; tPossibleTarget='..repru(tPossibleTarget)..'; tLocation (of where we want to build)='..repru(tLocation)) end
    if IsCliffBlockingTarget(tPossibleTarget) then
        --Can we get any closer to our build distance if we broaden the angle range?  Also increase the distance slightly
        iDistanceWantedFromTarget = iDistanceWantedFromTarget + 0.1
        local iAngleToEngi = M28Utilities.GetAngleFromAToB(tLocation, tBuilderLocation)
        local tReplacementTarget
        local tPathingPosition
        if bDebugMessages == true then LOG(sFunctionRef..': About to try different positions from tLocation '..repru(tLocation)..' to tBuilderLocation '..repru(tBuilderLocation)..'; Angle to here='..iAngleToEngi..'; iDistanceWantedFromTarget='..iDistanceWantedFromTarget) end
        for iAngleAdjust = 0, 40, 8 do
            for iAngleFactor = -1, 1, 2 do
                --MoveInDirection(tStart, iAngle, iDistance, bKeepInMapBounds, bTravelUnderwater)
                tPathingPosition = M28Utilities.MoveInDirection(tLocation, iAngleToEngi + iAngleAdjust * iAngleFactor, iDistanceWantedFromTarget, true, false)
                if bDebugMessages == true then

                    local iColour = 3
                    if NavUtils.GetLabel(sPathing, tPathingPosition) == iEngiPathingGroup and not(IsCliffBlockingTarget(tPathingPosition)) then iColour = 7 end
                    LOG(sFunctionRef..': Considering tPathingPosition='..repru(tPathingPosition)..'; iAngleAdjust='..iAngleAdjust * iAngleFactor..'; Pathing group='..NavUtils.GetLabel(sPathing, tPathingPosition)..'; Engi pathing group='..iEngiPathingGroup..'; Is cliff blocking target='..tostring(IsCliffBlockingTarget(tPathingPosition))..'; will draw match in white, nonmatch in black. iColour='..iColour..'; Dist from original move target planned='..M28Utilities.GetDistanceBetweenPositions(tPathingPosition, tPossibleTarget))
                    M28Utilities.DrawLocation(tPathingPosition, false, iColour, 200)
                end
                if NavUtils.GetLabel(sPathing, tPathingPosition) == iEngiPathingGroup and not(IsCliffBlockingTarget(tPathingPosition)) then
                    tReplacementTarget = tPathingPosition
                end

                if iAngleAdjust == 0 or tReplacementTarget then break end
            end
            if tReplacementTarget then break end
        end
        if tReplacementTarget then
            if bDebugMessages == true then LOG(sFunctionRef..': Have a replacement position to use') end
            tPossibleTarget = {tReplacementTarget[1], tReplacementTarget[2], tReplacementTarget[3]}

        end
    end
end
--]]
end

function BuildStructureNearLocation(aiBrain, oEngineer, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bLookForPartCompleteBuildings, bLookForQueuedBuildings, oUnitToBuildBy, bNeverBuildRandom, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, iOptionalEngiActionRef)
    --NOT USED? Might be old code copied from M27 that ended up rewriting?

    --Determines the blueprint and location for oEngineer to build at; also returns the location
    --iCatToBuildBy: Optional, specify if want to look for adjacency locations; Note to factor in 50% of the builder's size and 50% of the likely adjacency building size
    --bLookForQueuedBuildings: Optional, if true, then doesnt choose a target if another engineer already has that target function ref assigned to build something
    --Returns nil if dealing with a non-resource based building

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'BuildStructureNearLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Engineer UC='..GetEngineerUniqueCount(oEngineer)..'; Engineer LC='..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Techlevel='..M28UnitInfo.GetUnitTechLevel(oEngineer)..'; tAlternativePositionToLookFrom='..repru(tAlternativePositionToLookFrom or {'nil'})..'; bBuildCheapestStructure='..tostring((bBuildCheapestStructure or false))..'; bNeverBuildRandom='..tostring((bNeverBuildRandom or false))..'; All blueprints that meet the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild))..'; iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')..'; Water zone of position to look from (if any)='..(M28Map.GetWaterZoneFromPosition(tAlternativePositionToLookFrom or oEngineer:GetPosition()) or 'nil')) end


    local bAbortConstruction = false

    --Get the blueprint to build
                                    --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition, oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
    local sBlueprintToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oEngineer, false,        false,  bBuildCheapestStructure, iOptionalCategoryForStructureToBuild)
    local tTargetLocation
    if sBlueprintToBuild == nil then
        if not(aiBrain[M28Overseer.refbCloseToUnitCap]) then
            M28Utilities.ErrorHandler('sBlueprintToBuild is nil, could happen e.g. if try and get sparky to build sxomething it cant - refer to log for more details')
            if not(iCategoryToBuild) then LOG(sFunctionRef..': No category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer))
            else
                LOG(sFunctionRef..': Had category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..'; All blueprints that satisfy the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild)))
            end
        end
    else

        --Adjust the search range and record key info needed for the search
        local tEngineerPosition = oEngineer:GetPosition()
        tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition)
        --Increase max area to search if dealing with czar or similarly large unit due to its size
        if __blueprints[sBlueprintToBuild].Physics.SkirtSizeX >= 10 then
            iMaxAreaToSearch = iMaxAreaToSearch * 1.5
            if bDebugMessages == true then LOG(sFunctionRef..': Building a large unit such as a czar, increased iMaxAreaToSearch to '..iMaxAreaToSearch) end
        end

        --Reduce max area to search if dealing with a shield
        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
            iMaxAreaToSearch = math.min(iMaxAreaToSearch, (__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) * 0.5)
            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with a shield so reduce max area to search based on half of shield size. iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')..'; shield size='..__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) end
        end


        if bDebugMessages == true then LOG(sFunctionRef..': sBlueprintToBuild='..(sBlueprintToBuild or 'nil')..'; Location to look from='..repru(tAlternativePositionToLookFrom or oEngineer:GetPosition())) end
        local sBlueprintBuildBy
        local bFindRandomLocation = false

        if not(tTargetLocation) then tTargetLocation = tEngineerPosition end
        local bFoundEnemyInstead = false

        local sPathing = M28UnitInfo.GetUnitPathingType(oEngineer)
        local iNewBuildingRadius = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)[1] * 0.5
        local iBuilderRange = oEngineer:GetBlueprint().Economy.MaxBuildDistance + math.min(oEngineer:GetBlueprint().SizeX, oEngineer:GetBlueprint().SizeZ)*0.5
        local iDistanceFromStart = M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()])
        local bBuildNearToEnemy = false
        if iDistanceFromStart <= 80 then bBuildNearToEnemy = true end

        --Check we're not trying to buidl a mex or hydro or mass storage or mass fab
        local bMexHydroOrStorage = false
        if EntityCategoryContains(refCategoryMex, sBlueprintToBuild) or EntityCategoryContains(refCategoryHydro, sBlueprintToBuild) or EntityCategoryContains(M28UnitInfo.refCategoryMassStorage + M28UnitInfo.refCategoryMassFab, sBlueprintToBuild)  then
            bMexHydroOrStorage = true
        end


        --If specified, first check if there's an existing part complete building we can help complete instead of starting a new building
        --Check if is an existing building of the type wanted first:
        local oPartCompleteBuilding
        if bLookForPartCompleteBuildings then
            --GetPartCompleteBuilding(aiBrain, oBuilder, iCategoryToBuild, iBuildingSearchRange, iEnemySearchRange)
            --Returns nil if no nearby part complete building
            --iEnemySearchRange: nil if dont care about nearby enemies, otherwise will ignore buildings that have enemies within iEnemySearchRange
            oPartCompleteBuilding = GetPartCompleteBuilding(aiBrain, oEngineer, iCategoryToBuild, iBuilderRange + 15, nil)
        end
        if oPartCompleteBuilding then
            if bDebugMessages == true then LOG(sFunctionRef..': have partcompletebuilding so returning that as the position') end
            tTargetLocation = oPartCompleteBuilding:GetPosition()
        else
            if bDebugMessages == true then
                local sEngUniqueRef = GetEngineerUniqueCount(oEngineer)
                LOG(sFunctionRef..': Eng builder unique ref='..sEngUniqueRef..'; builder range='..iBuilderRange)
            end



            if not(bMexHydroOrStorage) then
                --For non-extraction buildings, if we have specified we want to build adjacent to something then look for nearby buildings that can give us the adjacency wanted
                if iCatToBuildBy or oUnitToBuildBy then
                    local toPossibleBuildingsToBuildBy
                    local iBuildingCount = 0
                    local tPossibleTargets = {}
                    local tBuildingPosition

                    if iCatToBuildBy then
                        toPossibleBuildingsToBuildBy = aiBrain:GetUnitsAroundPoint(iCatToBuildBy, tTargetLocation, iMaxAreaToSearch, 'Ally')
                        local iCurDist
                        local iClosestDist = 100000
                        --ACU specific - cant build by hydro, but might have nearby hydro
                        if bDebugMessages == true then LOG(sFunctionRef..': Engineer position='..repru(oEngineer:GetPosition())..'; tTargetLocation='..repru(tTargetLocation)..'; iMaxAreaToSearch='..iMaxAreaToSearch..'; is toPossibleBuildingsToBuildBy empty='..tostring(M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy))) end
                        if M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy) == false then
                            --Try to build by the closest unit of the category wanted
                            local oClosestBuilding
                            for iUnit, oUnit in  toPossibleBuildingsToBuildBy do
                                if oUnit:GetAIBrain() == aiBrain then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEngineer:GetPosition())
                                    if iCurDist < iClosestDist then
                                        oClosestBuilding = oUnit
                                        iClosestDist = iCurDist
                                    end
                                end
                            end
                            if oClosestBuilding then
                                sBlueprintBuildBy = oClosestBuilding.UnitId
                                if bDebugMessages == true then LOG(sFunctionRef..': Will update sBlueprintBuildBy to be the closest building for adjacency='..oClosestBuilding.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestBuilding)) end
                            end
                        end


                    elseif oUnitToBuildBy then
                        sBlueprintBuildBy = oUnitToBuildBy.UnitId
                        toPossibleBuildingsToBuildBy = {oUnitToBuildBy}
                    else M28Utilities.ErrorHandler('Missing code')
                    end


                    if M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have possible buildings to build by, so will consider best location') end
                        for iBuilding, oBuilding in toPossibleBuildingsToBuildBy do
                            if not(oBuilding.Dead) and oBuilding.GetPosition and oBuilding:GetAIBrain() == aiBrain then
                                tBuildingPosition = oBuilding:GetPosition()
                                if M28Utilities.GetDistanceBetweenPositions(tBuildingPosition, tTargetLocation) <= iMaxAreaToSearch then
                                    iBuildingCount = iBuildingCount + 1
                                    tPossibleTargets[iBuildingCount] = tBuildingPosition
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Found iBuildingCount='..iBuildingCount..' to build by') end
                        if iBuildingCount == 0 then bFindRandomLocation = not(bNeverBuildRandom) end
                    else
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Cant find any buildings for adjacency, getting random location to build unless we want to build by a mex/hydro and have an unbuilt one nearby')
                            local tNearestBuildingOfCategory = aiBrain:GetUnitsAroundPoint(iCatToBuildBy, tTargetLocation, 10000, 'Ally')
                            if M28Utilities.IsTableEmpty(tNearestBuildingOfCategory) then LOG(sFunctionRef..': Dont have any units of the desired category anywhere on map')
                            else
                                local oNearestBuildingOfCategory = M28Utilities.GetNearestUnit(tNearestBuildingOfCategory, oEngineer:GetPosition(), aiBrain)
                                LOG(sFunctionRef..': Nearest unit of desired category is '..oNearestBuildingOfCategory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestBuildingOfCategory)..' which is '..M28Utilities.GetDistanceBetweenPositions(oNearestBuildingOfCategory:GetPosition(), oEngineer:GetPosition())..' away from the engineer')
                            end
                        end
                        bFindRandomLocation = not(bNeverBuildRandom)
                    end

                    --Also check for unbuilt buildings if dealing with a mex or hydro, unless are building a shield
                    local tResourceLocations
                    if not(EntityCategoryContains(categories.SHIELD, sBlueprintToBuild)) then
                        --land factory - say that we're looking for a mex even if cant find one
                        if bDebugMessages == true then LOG(sFunctionRef..': About to check if building early fac and cant find mex/hydro. Does cat to build by contain mex or hydro='..tostring(M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryHydro + M28UnitInfo.refCategoryMex, iCatToBuildBy, false))..'; sBlueprintBuildBy='..(sBlueprintBuildBy or 'nil')..'; Does engi contain tech1 or ACU='..tostring(EntityCategoryContains(categories.TECH1 + categories.COMMAND, oEngineer.UnitId))..'; Does blueprint to build contain factory='..tostring(EntityCategoryContains(categories.FACTORY, sBlueprintToBuild))) end
                        if iCatToBuildBy and not(sBlueprintBuildBy) and EntityCategoryContains(categories.TECH1 + categories.COMMAND, oEngineer.UnitId) and EntityCategoryContains(categories.FACTORY, sBlueprintToBuild) then
                            if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryMex, iCatToBuildBy, false) then
                                sBlueprintBuildBy = 'ueb1103'
                            elseif M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryHydro, iCatToBuildBy, false) then
                                sBlueprintBuildBy = 'ueb1102'
                            end
                        end
                        if sBlueprintBuildBy then
                            if EntityCategoryContains(M28UnitInfo.refCategoryMex, sBlueprintBuildBy) then
                                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                                local iPond, iWaterZone
                                if (iLandZone or 0) == 0 then
                                    iWaterZone = M28Map.GetWaterZoneFromPosition(tTargetLocation)
                                    iPond = M28Map.tiPondByWaterZone[iWaterZone]
                                    tResourceLocations = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefLZMexLocations]
                                else
                                    tResourceLocations = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Will add any mexes within 20 of target location to be considered, tResourceLocations='..repru(tResourceLocations)) end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryHydro, sBlueprintBuildBy) or EntityCategoryContains(M28UnitInfo.refCategoryT2Power, sBlueprintBuildBy) then --Dont want to make this all power, because the adjacency code requires a building size, and only works for a single building size; i.e. if try and get adjacency for t1 power and include hydro locations, then it will think it needs to build within the hydro for adjacency
                                local iPlateau, iZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                                if not(iZone) then M28Utilities.ErrorHandler('Trying to build a hydro but dont have a valid zone') end
                                tResourceLocations = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iZone][M28Map.subrefHydroLocations]
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tResourceLocations) == false then
                        for iResource, tCurResourceLocation in tResourceLocations do
                            iBuildingCount = iBuildingCount + 1
                            tPossibleTargets[iBuildingCount] = tCurResourceLocation
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and build by resource location (mex or hydro); iBuildingCount including these locations='..iBuildingCount..'; table of building locations='..repru(tPossibleTargets)) end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of resource locations empty='..tostring(M28Utilities.IsTableEmpty(tResourceLocations))..'; iBuildingCount='..iBuildingCount) end
                    if iBuildingCount > 0 then
                        --GetBestBuildLocationForTarget(tablePosTarget, sTargetBuildingBPID, sNewBuildingBPID, bCheckValid, aiBrain, bReturnOnlyBestMatch, pBuilderPos, iMaxAreaToSearch, iBuilderRange, bIgnoreOutsideBuildArea, bBetterIfNoReclaim, bPreferCloseToEnemy, bPreferFarFromEnemy, bLookForQueuedBuildings)
                        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build the shield anywhere near the target. iOptionalEngiActionRef='..(iOptionalEngiActionRef or 'nil')) end
                            local bBuildAwayFromEnemy = false
                            if iOptionalEngiActionRef == refActionFortifyFirebase then bBuildAwayFromEnemy = true end
                            tTargetLocation = GetBuildLocationForShield(aiBrain, sBlueprintToBuild, tAlternativePositionToLookFrom, bBuildAwayFromEnemy)
                            if not(tTargetLocation) then bAbortConstruction = true end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': About to call GetBestBuildLocation; iBuildingCount='..iBuildingCount..'; sBlueprintBuildBy='..(sBlueprintBuildBy or 'nil')) end
                            --Go through all possible adjacent build locations identified, and choose the best one
                            tTargetLocation = GetBestBuildLocationForTarget(tPossibleTargets, sBlueprintBuildBy, sBlueprintToBuild, true, aiBrain, true, tTargetLocation, iMaxAreaToSearch, iBuilderRange, false, true, bBuildNearToEnemy, not(bBuildNearToEnemy), bLookForQueuedBuildings)
                            --Double-check the resulting location is valid
                            if M28Utilities.IsTableEmpty(tTargetLocation) == true then
                                if bDebugMessages == true then LOG('Adjacency location is empty, will try finding anywhere to build') end
                                bFindRandomLocation = not(bNeverBuildRandom)
                            else
                                bFindRandomLocation = false
                                if bDebugMessages == true then LOG(sFunctionRef..': Have determined the best build location for target to be '..repru(tTargetLocation)..'; will double-check we can build here') end
                                if not(CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, nil, nil, nil, false, bLookForQueuedBuildings, false, true)) then
                                    --if aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation) == false or not(M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)])) then
                                    M28Utilities.ErrorHandler('Cant build '..sBlueprintToBuild..' on adjacency location tTargetLocation='..repru({tTargetLocation[1], tTargetLocation[2],tTargetLocation[3]}))
                                    bFindRandomLocation = not(bNeverBuildRandom)
                                else
                                    --Check we're within mapBoundary
                                    if bDebugMessages == true then LOG(sFunctionRef..': Cant build at the location; Checking if tTargetLocation '..repru(tTargetLocation)..' is in the playable area '..repru(M28Map.rMapPlayableArea)..' based on building size radius='..iNewBuildingRadius) end
                                    if (tTargetLocation[1] - iNewBuildingRadius) < M28Map.rMapPlayableArea[1] or (tTargetLocation[3] - iNewBuildingRadius) < M28Map.rMapPlayableArea[2] or (tTargetLocation[1] + iNewBuildingRadius) > M28Map.rMapPlayableArea[3] or (tTargetLocation[3] + iNewBuildingRadius) > M28Map.rMapPlayableArea[4] then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Target location isnt in playable area so will find random place to build instead') end
                                        bFindRandomLocation = not(bNeverBuildRandom)
                                        tTargetLocation = tEngineerPosition
                                    end
                                    if bDebugMessages == true then M28Utilities.DrawLocation(tTargetLocation) end
                                end
                            end
                        end
                    else
                        bFindRandomLocation = not(bNeverBuildRandom)
                        if bDebugMessages == true then LOG(sFunctionRef..': Cant find any valid buildings for adjacency') end
                    end
                else
                    --If no was adjacency wanted, then either build at the target location, or find a random location to build (subject to some unit specific points)
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have a category to build by, will look for random location unless current target is valid or we are a shield') end
                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
                        local bBuildAwayFromEnemy = false
                        if iOptionalEngiActionRef == refActionFortifyFirebase then bBuildAwayFromEnemy = true end
                        tTargetLocation = GetBuildLocationForShield(aiBrain, sBlueprintToBuild, tAlternativePositionToLookFrom, bBuildAwayFromEnemy)
                        if tTargetLocation then bFindRandomLocation = false else bFindRandomLocation = not(bNeverBuildRandom) end
                    else
                        bFindRandomLocation = not(bNeverBuildRandom)
                    end
                end
            else
                --Dealing with mex or hydro or storage
                if bDebugMessages == true then LOG(sFunctionRef..': Are trying to build a mex, hydro or storage; tTargetLocation='..repru((tTargetLocation or {}))..'; oEngineer='..GetEngineerUniqueCount(oEngineer)..'; LC='..M28UnitInfo.GetUnitLifetimeCount(oEngineer)) end
                if M28Utilities.IsTableEmpty(tTargetLocation) == true then
                    M28Utilities.ErrorHandler('Trying to build mex, hydro or storage without defined location')
                else
                    if aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation) then --and M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)]) then
                        --Not interested in if other units have queued up, as e.g. might be ACU that can build and is much closer, so just want whichever unit is closest to try and build
                        if bDebugMessages == true then LOG(sFunctionRef..': Can build structure at targetlocation='..repru(tTargetLocation)..'; if are buildling a t1 mex and there is a t3 mex queued up then will ignore though') end
                        --Are we trying to build a T1 mex? If so then only consider if have an order to build T3 mex
                        if EntityCategoryContains(refCategoryT1Mex, sBlueprintToBuild) then
                            local sLocationRef = M28Utilities.ConvertLocationToReference(tTargetLocation)
                            if aiBrain[reftEngineerAssignmentsByLocation][sLocationRef] and M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][sLocationRef][refActionBuildT3MexOverT2]) == false then
                                bAbortConstruction = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Trying to build t1 mex when want to build t3 here') end
                            end
                        end
                    else
                        --Cant build at location, is that because of enemy building blocking it, or we have a part-built building?
                        if bDebugMessages == true then LOG(sFunctionRef..': Are trying to build a mex or hydro or mass storage so cant get a random location, but we cant build a structure at the target') end
                        local tEnemyBuildingAtTarget = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, tTargetLocation, 1, 'Enemy')
                        if M28Utilities.IsTableEmpty(tEnemyBuildingAtTarget) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have enemy buildings around target') end
                            M28PlatoonUtilities.MoveNearConstruction(aiBrain, oEngineer, tTargetLocation, sBlueprintToBuild, 0, false, false, false)
                            for iUnit, oUnit in tEnemyBuildingAtTarget do
                                if oUnit.GetPosition then
                                    IssueReclaim({oEngineer}, oUnit)
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy building is at the target mex/hydro so will try and reclaim that first') end

                            IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                            if bDebugMessages == true then LOG(sFunctionRef..': 1 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation)) end
                            bAbortConstruction = true
                            bFoundEnemyInstead = true

                        else
                            local tAllyBuildingAtTarget = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, tTargetLocation, 1, 'Ally')
                            if M28Utilities.IsTableEmpty(tAllyBuildingAtTarget) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will target the ally building as its part complete') end
                                oPartCompleteBuilding = tAllyBuildingAtTarget[1]
                            else
                                --Are we stopped from building due to reclaim?

                                local tNewBuildingSize = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
                                local fSizeMod = 0.5

                                local rTargetRect = M28Utilities.GetRectAroundLocation(tTargetLocation, tNewBuildingSize[1] * fSizeMod)
                                if bDebugMessages == true then LOG(sFunctionRef..': tTargetLocation='..repru(tTargetLocation)..'; tNewBuildingSize='..repru(tNewBuildingSize)..'; rTargetRect='..repru(rTargetRect)) end
                                --GetReclaimInRectangle(iReturnType, rRectangleToSearch)
                                --iReturnType: 1 = true/false; 2 = number of wrecks; 3 = total mass, 4 = valid wrecks
                                local tReclaimables = M28Map.GetReclaimInRectangle(4, rTargetRect)

                                if M28Utilities.IsTableEmpty(tReclaimables) == false then
                                    for iReclaim, oReclaim in tReclaimables do
                                        --oEngineer:IssueReclaim(oReclaim)
                                        IssueReclaim({oEngineer}, oReclaim)
                                    end
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef..': Reclaim found that is blocking mex or hydro so will reclaim all wrecks in rectangle='..repru(rTargetRect))
                                        M28Utilities.DrawRectangle(rTargetRect, 7, 100)
                                    end

                                    IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                                    if bDebugMessages == true then LOG(sFunctionRef..': 2 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation)) end

                                else
                                    --Are we trying to build a T3 mex? If so then we probably are trying to replace a T2 mex which  can lead to problems with the canbuild check
                                    if iCategoryToBuild == M28UnitInfo.refCategoryT3Mex then
                                        IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef..': Not sure we can build here but will try anyway')
                                            LOG(sFunctionRef..': 3 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation))
                                        end
                                    else
                                        --One likely explanation is that enemy has built on the mex and we cant see the building, in which case we only want to check this for debugging purposes, and proceed with the default action of having hte engineer try to move there
                                        local tUnits = GetUnitsInRect(rTargetRect)
                                        if M28Utilities.IsTableEmpty(tUnits) == true then
                                            M28Utilities.ErrorHandler(sFunctionRef..': Cant build at resource location but no units or reclaim on it, will just try moving near the target instead. sBlueprintToBuild='..sBlueprintToBuild..'; Engineer UC='..GetEngineerUniqueCount(oEngineer)..'; LC='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Location='..repru({tTargetLocation[1], tTargetLocation[2],tTargetLocation[3]})..'; Will draw white circle around the target if in debug mode. CanBuildStructure result='..tostring(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation))..'; Is the table of assigned engineer actions empty='..tostring(M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)])), true)
                                            if bDebugMessages == true then
                                                M28Utilities.DrawLocation(tTargetLocation, nil, 7)
                                                LOG(sFunctionRef..': Cnat build at TargetLocation='..repru(tTargetLocation)..'; RectangleSearched='..repru(rTargetRect))
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will just move to the target location') end
                                        M28PlatoonUtilities.MoveNearConstruction(aiBrain, oEngineer, tTargetLocation, sBlueprintToBuild, 0, false, false, false)
                                        bAbortConstruction = true
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        --Switch to random location if an amphibious unit cant path there and its not a resource based location
        if not(bFindRandomLocation) and not(bAbortConstruction) then -- and not(bMexHydroOrStorage) then
            if not(NavUtils.GetLabel(sPathing, tTargetLocation) == NavUtils.GetLabel(sPathing, oEngineer:GetPosition())) then
                bFindRandomLocation = not(bNeverBuildRandom)
            end
        end

        if bFindRandomLocation and (bMexHydroOrStorage or EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild)) and not(bAbortConstruction) and not(iOptionalEngiActionRef == refActionFortifyFirebase) then
            --Backup - Trying to build a mex or hydro so no point getting random location
            if not(EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild)) then
                M28Utilities.ErrorHandler('Are trying to build in a random place for am ex/hydro/mass storage - figure out why as this shouldnt trigger; Engineer with UC='..GetEngineerUniqueCount(oEngineer)..'='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; trying to build blueprint='..sBlueprintToBuild)
                if bDebugMessages == true then LOG(sFunctionRef..': Trying to build mex or hydro so cant choose a random location') end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Trying to build a shield but couldnt find anywhere to build it so no point building it in the end. iOptionalEngiActionRef='..(iOptionalEngiActionRef or 'nil')) end
            end
            bFindRandomLocation = false
            bAbortConstruction = true
        end

        --Look for a random location if we failed to find a suitable location in the above steps
        if bFindRandomLocation == true and not(bAbortConstruction) then
            if bDebugMessages == true then LOG(sFunctionRef..': Are finding a random location to build unless current location is valid; sBlueprintToBuild='..sBlueprintToBuild..'; iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')) end
            if M28Utilities.IsTableEmpty(tTargetLocation) == true then tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition) end

            --First check in build area for the best location assuming the target location isnt far away
            if M28Utilities.GetDistanceBetweenPositions(tTargetLocation, tEngineerPosition) <= 30 then tTargetLocation = GetBestBuildLocationForTarget(tTargetLocation, nil, sBlueprintToBuild, true, aiBrain, true, tTargetLocation, iMaxAreaToSearch, iBuilderRange, false, true, bBuildNearToEnemy, not(bBuildNearToEnemy), false) end
            if M28Utilities.IsTableEmpty(tTargetLocation) == true or not(CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, nil, nil, nil, false, bLookForQueuedBuildings, true)) then
                --if M28Utilities.IsTableEmpty(tTargetLocation) == true or not(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation)) or not(M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)])) then
                if M28Utilities.IsTableEmpty(tTargetLocation) then tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition) end
                if bDebugMessages == true then
                    LOG(sFunctionRef..' Cant build '..sBlueprintToBuild..'; will try and find a random place to build; target location for random place to build='..repru(tTargetLocation))
                    if iCategoryToBuild == nil then LOG(sFunctionRef..' iCategoryToBuild is nil somehow') end
                end
                --FindRandomPlaceToBuild(aiBrain, oBuilder, tStartPosition, sBlueprintToBuild, iSearchSizeMin, iSearchSizeMax, bForcedDebug)
                local bSuitableForLastSuccessfulLocation = EntityCategoryContains(M28UnitInfo.refCategoryStructure + categories.EXPERIMENTAL - M28UnitInfo.refCategorySatellite - M28UnitInfo.refCategoryFirebaseSuitable, sBlueprintToBuild) and M28Utilities.IsTableEmpty(aiBrain[reftLastSuccessfulLargeBuildingLocation]) == false
                local iSearchCycles = nil
                if bSuitableForLastSuccessfulLocation then iSearchCycles = 3 end
                tTargetLocation = FindRandomPlaceToBuild(aiBrain, oEngineer, (tTargetLocation or tAlternativePositionToLookFrom or tEngineerPosition), sBlueprintToBuild, 2, iMaxAreaToSearch, bDebugMessages, iSearchCycles)
                if M28Utilities.IsTableEmpty(tTargetLocation) == true then
                    --Try searching the last location we built at successfully for a couple of cycles if arent building a firebase unit
                    if bSuitableForLastSuccessfulLocation then
                        tTargetLocation = FindRandomPlaceToBuild(aiBrain, oEngineer, aiBrain[reftLastSuccessfulLargeBuildingLocation], sBlueprintToBuild, 2, iMaxAreaToSearch, false, math.min(3, (iSearchCycles or 3)))
                    end
                    if M28Utilities.IsTableEmpty(tTargetLocation) then
                        LOG(sFunctionRef..': WARNING - couldnt find a random place to build based on position='..repru(tTargetLocation)..'; will abort construction')
                        bAbortConstruction = true
                    end
                elseif bDebugMessages == true then LOG(sFunctionRef..': Found random place to build='..repru(tTargetLocation))
                end
            else if bDebugMessages == true then LOG(sFunctionRef..': No need for random place as current targetlocation is valid, ='..repru(tTargetLocation)) end
            end
        end
        --Only proceed with sending a build order (or repair order for a part complete building) if we had success in the earlier steps
        if bAbortConstruction == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Not aborting function so will try to move near construction if we have a valid location') end
            if M28Utilities.IsTableEmpty(tTargetLocation) == false and sBlueprintToBuild then
                --Adjust Target location if building PD
                if EntityCategoryContains(M28UnitInfo.refCategoryPD, sBlueprintToBuild) then
                    tTargetLocation = AdjustPDBuildLocation(aiBrain, tTargetLocation, sBlueprintToBuild)
                end
                --MoveNearConstruction(aiBrain, oBuilder, tLocation, sBlueprintID, iBuildDistanceMod, bReturnMovePathInstead, bUpdatePlatoonMovePath, bReturnNilIfAlreadyMovingNearConstruction, bReturnMoveLocationifGivenOne)
                local tMoveNearTargetLocation = M28PlatoonUtilities.MoveNearConstruction(aiBrain, oEngineer, tTargetLocation, sBlueprintToBuild, 0, false, false, false, true)
                if oPartCompleteBuilding then
                    if bDebugMessages == true then LOG(sFunctionRef..': Send order for oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to repair '..oPartCompleteBuilding.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPartCompleteBuilding)..' at '..repru(oPartCompleteBuilding:GetPosition())) end

                    IssueRepair({ oEngineer}, oPartCompleteBuilding)
                else
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Send order for oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to build '..sBlueprintToBuild..' at '..repru(tTargetLocation)..'; will draw target location in gold')
                        M28Utilities.DrawLocation(tTargetLocation, nil, 4, 500)
                    end

                    --MAIN ISSUEBUILDMOBILE FOR CONSTRUCTION (i.e. other issuebuilds here are for specific actions)
                    IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                    if bDebugMessages == true then LOG(sFunctionRef..': 4 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation)..' with surface height='..GetSurfaceHeight(tTargetLocation[1], tTargetLocation[3])..'; tMoveNearTargetLocation='..repru(tMoveNearTargetLocation)) end
                end
                if M28Utilities.IsTableEmpty(tMoveNearTargetLocation) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to start thread checking for when the engineer is in build range') end
                    ForkThread(TrackWhenEngineerInBuildRange, oEngineer, tMoveNearTargetLocation, (sBlueprintToBuild or oPartCompleteBuilding.UnitId), tTargetLocation, oPartCompleteBuilding)
                    if sBlueprintToBuild and not(oPartCompleteBuilding) then
                        ForkThread(CheckIfEngineerLikelyStuck, oEngineer, sBlueprintToBuild, tTargetLocation)
                    end

                end
            end
        else
            if bDebugMessages == true then LOG('Warning - couldnt find any places to build after looking randomly nearby, will abort construction. bFoundEnemyInstead='..tostring(bFoundEnemyInstead)) end
            if bDebugMessages == true then
                LOG(sFunctionRef..': Aborted construction, will draw target location in red')
                M28Utilities.DrawLocation(tTargetLocation, nil, 2, 100)
            end
            if not(bMexHydroOrStorage) then tTargetLocation = nil end
        end
    end
    if bDebugMessages == true then
        if sBlueprintToBuild == nil then LOG('sBlueprintToBuild is nil')
        else
            if tTargetLocation then
                LOG(sFunctionRef..': tTargetLocation='..repru(tTargetLocation)..'; aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation)='..tostring(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation))..'; sBlueprintToBuild='..(sBlueprintToBuild or 'nil'))
                if not(bAbortConstruction) then M28Utilities.DrawLocation(tTargetLocation, nil, 7, 100) end --show in white (colour 7)
                LOG(sFunctionRef..': About to list any units in 1x1 rectangle around targetlocation')
                local iSizeAdj = 3
                local rBuildAreaRect = Rect(tTargetLocation[1] - iSizeAdj, tTargetLocation[3] - iSizeAdj, tTargetLocation[1] + iSizeAdj, tTargetLocation[3] + iSizeAdj)
                local tUnitsInRect = GetUnitsInRect(rBuildAreaRect)
                local tsUnitRefs = {}
                if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                    for iUnit, oUnit in tUnitsInRect do
                        table.insert(tsUnitRefs, iUnit, oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
                    end
                end
                LOG('tsUnitRefs='..repru(tsUnitRefs))
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tTargetLocation
end

function GetPartCompleteBuilding(aiBrain, oBuilder, iCategoryToBuild, iBuildingSearchRange)
    --Returns nil if no nearby part complete building
    --iEnemySearchRange: nil if dont care about nearby enemies, otherwise will ignore buildings that have enemies within iEnemySearchRange
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPartCompleteBuilding'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tBuilderPosition = oBuilder:GetPosition()
    local tAllBuildings = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, tBuilderPosition, iBuildingSearchRange, 'Ally')
    local iCurDistanceToBuilder
    local iMinDistanceToBuilder = 10000
    local tBuildingPosition
    local oNearestPartCompleteBuilding
    if M28Utilities.IsTableEmpty(tAllBuildings) == false then
        for iBuilding, oBuilding in tAllBuildings do
            --Dont try and compelte part built shields as may be part built due to special shielding logic
            if oBuilding.GetFractionComplete and oBuilding.GetPosition and oBuilding:GetFractionComplete() < 1 and not(EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oBuilding.UnitId)) then
                local tNearbyEnemies
                tBuildingPosition = oBuilding:GetPosition()
                iCurDistanceToBuilder = M28Utilities.GetDistanceBetweenPositions(tBuildingPosition, tBuilderPosition)
                if iCurDistanceToBuilder < iMinDistanceToBuilder then
                    iMinDistanceToBuilder = iCurDistanceToBuilder
                    oNearestPartCompleteBuilding = oBuilding
                end
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oNearestPartCompleteBuilding
end

function SlowlyRefreshBuildableLandZoneLocations(oOrigBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SlowlyRefreshBuildableLandZoneLocations'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    bBuildLocationLoopActive = true
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iSearchesConsideredThisTick
    local iTicksWaitedThisCycle
    local iSegmentsBeforeWaiting
    if GetGameTimeSeconds() >= 600 or M28Overseer.refiRoughTotalUnitsInGame >= 500 then iSegmentsBeforeWaiting = 16 --Must be a multiple of 2, i.e. 2^x results in this
    else iSegmentsBeforeWaiting = 32
    end
    local aiBrain = oOrigBrain

    --First update every start position that has an M28 brain to make sure we have a decent number of options recorded for a land factory and smaller
    for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
        if bDebugMessages == true then LOG(sFunctionRef..': About to start recording buildable locations for the starting land zone for oBrain='..oBrain.Nickname..'; Index='..oBrain:GetArmyIndex()..'; Start pos='..repru(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])) end
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
        if (iLandZone or 0) > 0 then
                --SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iOptionalMaxSegmentsToConsider)
            SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateau, iLandZone, iSegmentsBeforeWaiting * 10)

            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    end

    while true do
        --Get a new brain if needed
        if aiBrain.M28IsDefeated then
            aiBrain = nil
            for iBrain, oBrain in ArmyBrains do
                if oBrain.M28AI and not(oBrain.M28IsDefeated) then
                    aiBrain = oBrain
                    break
                end
            end
            if not(aiBrain) then
                break
            end
        end

        iTicksWaitedThisCycle = 0
        iSearchesConsideredThisTick = 0

        --Cycle through every plateau
        for iPlateau, tPlateauSubtable in M28Map.tAllPlateaus do
            for iLandZone, tLandZoneInfo in tPlateauSubtable[M28Map.subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Updating for iPlateau='..iPlateau..'; iLandZone='..iLandZone) end
                if tLandZoneInfo[M28Map.subrefBuildLocationsBySizeAndSegment] then
                    if tLandZoneInfo[M28Map.subrefLZTotalSegmentCount] >= 80 or tLandZoneInfo[M28Map.subrefLZMexCount] > 0 then
                        --SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iOptionalMaxSegmentsToConsider)
                        SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateau, iLandZone, iSegmentsBeforeWaiting)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        iTicksWaitedThisCycle = iTicksWaitedThisCycle + 1
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    end
                end
                iTicksWaitedThisCycle = iTicksWaitedThisCycle + 1
            end
        end
        if iTicksWaitedThisCycle < 1000 then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1000 - iTicksWaitedThisCycle)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            iSegmentsBeforeWaiting = math.max(2, iSegmentsBeforeWaiting * 0.5)
        elseif iTicksWaitedThisCycle >= 3000 then
            iSegmentsBeforeWaiting = math.min(64, iSegmentsBeforeWaiting * 2)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordBuildableCoreWaterZoneLocationsNearStartOfGame()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordBuildableCoreWaterZoneLocationsNearStartOfGame'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    bWZBuildLocationLoopActive = true
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iSearchesConsideredThisTick
    local iTicksWaitedThisCycle
    local iSegmentsBeforeWaiting = 16 --Must be a multiple of 2, i.e. 2^x results in this

    local tWZShortlistByWZ = {} --Index is WZ

    local iCurWZ
    local aiBrain
    --Get the naval build locations for each M28 brain to create a shortlist that will be cycled through
    for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
        aiBrain = oBrain
        if M28Utilities.IsTableEmpty(M28Map.tPondDetails) == false then
            for iPond, tPondSubtable in M28Map.tPondDetails do
                if M28Utilities.IsTableEmpty(tPondSubtable[M28Map.subrefBuildLocationByStartPosition]) == false then
                    for iEntry, tPosition in tPondSubtable[M28Map.subrefBuildLocationByStartPosition] do
                        iCurWZ = M28Map.GetWaterZoneFromPosition(tPosition)
                        if (iCurWZ or 0) > 0 then
                            tWZShortlistByWZ[iCurWZ] = true
                        end
                    end
                end
            end
        end
    end
    local tWZShortlist = {}
    if M28Utilities.IsTableEmpty(tWZShortlistByWZ) == false then
        for iWZ, bInclude in tWZShortlistByWZ do
            table.insert(tWZShortlist, iWZ)
        end
    end

    if M28Utilities.IsTableEmpty(tWZShortlist) == false then
        --First ensure we have basic sizes for the WZ and some entries
        for iEntry, iWaterZone in tWZShortlist do
            SearchForBuildableLocationsForLandOrWaterZone(aiBrain, 0, iWaterZone, iSegmentsBeforeWaiting)
        end

        local iTotalCycles = 0

        while iTotalCycles <= 100 do
            iTotalCycles = iTotalCycles + 1
            --Get a new brain if needed
            if aiBrain.M28IsDefeated then
                aiBrain = nil
                for iBrain, oBrain in ArmyBrains do
                    if oBrain.M28AI and not(oBrain.M28IsDefeated) then
                        aiBrain = oBrain
                        break
                    end
                end
                if not(aiBrain) then
                    break
                end
            end

            iTicksWaitedThisCycle = 0
            iSearchesConsideredThisTick = 0

            --Cycle through every entry
            for iEntry, iWaterZone in tWZShortlist do
                        --SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iOptionalMaxSegmentsToConsider)
                SearchForBuildableLocationsForLandOrWaterZone(aiBrain, 0, iWaterZone, iSegmentsBeforeWaiting)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                iTicksWaitedThisCycle = iTicksWaitedThisCycle + 1
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DecideOnExperimentalToBuild(iActionToAssign, aiBrain, tbEngineersOfFactionOrNilIfAlreadyAssigned, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iLandOrWaterZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DecideOnExperimentalToBuild'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iFactionRequired
    local iCategoryWanted
    if not(tbEngineersOfFactionOrNilIfAlreadyAssigned) then
        if bDebugMessages == true then LOG(sFunctionRef..': Already have unit under construction so will return experimentallevel') end
        iCategoryWanted = M28UnitInfo.refCategoryExperimentalLevel --Already have the unit under construction
    else
        --Do we have an experimental level unit under construciton in this LZ?
        local tExperimentalsInLZ
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            tExperimentalsInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryExperimentalLevel, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tExperimentalsInLZ) == false then
                for iUnit, oUnit in tExperimentalsInLZ do
                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() < 1 and oUnit:GetFractionComplete() > 0.001 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Setting category to experimental level as have part complete experimental') end
                        iCategoryWanted = M28UnitInfo.refCategoryExperimentalLevel
                        break
                    end
                end
            end
        end
        if not(iCategoryWanted) then
            if bDebugMessages == true then LOG(sFunctionRef..': Deciding on what experimental to construct, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; Time='..GetGameTimeSeconds()..'; Team mass income='..M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass]) end
            --Land subteam - use aiBrain.M28LandSubteam
            local iSubteamSize =  table.getn(M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subreftoFriendlyM28Brains])
            local iEnemyLandExperimentalCount = table.getn(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftEnemyLandExperimentals])
            local bEnemyHasFatboys = false
            if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFatboy, M28Team.tTeamData[aiBrain.M28Team][M28Team.reftEnemyLandExperimentals])) == false then
                bEnemyHasFatboys = true
            end
            local iTeam = aiBrain.M28Team
            local iDistToNearestEnemyBase = M28Utilities.GetDistanceBetweenPositions(tLZOrWZTeamData[M28Map.reftClosestEnemyBase], tLZOrWZData[M28Map.subrefMidpoint])
            local bCanPathByLand
            local bCanPathAmphibiously
            if NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZOrWZData[M28Map.subrefMidpoint]) == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) then
                bCanPathByLand = true
            else bCanPathByLand = false
            end
            if NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, tLZOrWZData[M28Map.subrefMidpoint]) == NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) then
                bCanPathAmphibiously = true
            else bCanPathAmphibiously = false
            end

            --Non-faction specific logic:

            --Initial land experimental (very high priority subject to map)
            local iTeamLandExperimentals = 0
            for iBrain, oBrain in M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subreftoFriendlyM28Brains] do
                iTeamLandExperimentals = iTeamLandExperimentals + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandExperimental)
            end

            if iTeamLandExperimentals >= 1 or M28Team.tTeamData[iTeam][M28Team.subrefiOurBomberThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] >= 7000 or M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandExperimental) >= 2 then
                --Factor in experimentals under construction (as no longer a high priority to build land experimentals)
                local bHaveExperimentalForThisLandZone, iOtherLandZonesWithExperimental, iMassToComplete = GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateauOrZero, iLandOrWaterZone, false, nil, M28UnitInfo.refCategoryLandExperimental)
                iTeamLandExperimentals = iTeamLandExperimentals + iOtherLandZonesWithExperimental
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iTeamLandExperimentals='..iTeamLandExperimentals..'; bCanPathByLand='..tostring(bCanPathByLand)..'; bCanPathAmphibiously='..tostring(bCanPathAmphibiously)) end
            if iTeamLandExperimentals == 0 and bCanPathByLand then
                iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                if bDebugMessages == true then LOG(sFunctionRef..': Is Cybran engineers of faction available='..tostring(tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionCybran] or false)..'; Lifetime land experimental count='..M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandExperimental)) end
                if tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionCybran] then
                    if M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandExperimental) < 2 then
                        iCategoryWanted = M28UnitInfo.refCategoryMonkeylord
                        iFactionRequired = M28UnitInfo.refFactionCybran
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to build a monkeylord') end
                    else
                        iCategoryWanted = M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategoryMonkeylord
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to build a megalith or other land experimental that isnt a monkeylord')
                        end
                    end
                end
            else
                --Consider getting nukes
                if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] then --dont want nuke built too far from base
                    --Do we already have nukes?
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of nukes in this zone empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategorySML, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))) end
                    if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategorySML, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) then
                        --Do teammates have no more than 1 nuke?
                        local iTeamNukes = 0
                        for iBrain, oBrain in M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subreftoFriendlyM28Brains] do
                            iTeamNukes = iTeamNukes + oBrain:GetCurrentUnits(M28UnitInfo.refCategorySML)
                            --Treat us as having more nukes if we have an experimental nuke
                            if iTeamNukes > 0 and oBrain:GetFactionIndex() == M28UnitInfo.refFactionSeraphim then iTeamNukes = iTeamNukes + oBrain:GetCurrentUnits(M28UnitInfo.refCategorySML * categories.EXPERIMENTAL) * 2 end
                        end
                        local bHaveExperimentalForThisLandZone, iOtherLandZonesWithExperimental, iMassToComplete = GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateauOrZero, iLandOrWaterZone, false, nil, M28UnitInfo.refCategorySML)
                        if bDebugMessages == true then LOG(sFunctionRef..': iTeamNukes based on getcurrentunits='..iTeamNukes..'; iOtherLandZonesWithExperimental='..iOtherLandZonesWithExperimental) end
                        iTeamNukes = iTeamNukes + iOtherLandZonesWithExperimental

                        if bDebugMessages == true then LOG(sFunctionRef..': iTeamNukes after update='..iTeamNukes) end
                        if (iTeamNukes == 0 or (iOtherLandZonesWithExperimental == 0 and iTeamNukes == 1 and M28Map.iMapSize > 512 and M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 3)) and (not(tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionSeraphim]) or M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] == 1 or M28Map.bIsCampaignMap or M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL) == 0) then
                            local iHighestNukeTargetValue = M28Building.GetHighestNukeTargetValue(tLZOrWZData, tLZOrWZTeamData, aiBrain.M28Team)
                            if bDebugMessages == true then LOG(sFunctionRef..': iHighestNukeTargetValue='..iHighestNukeTargetValue..'; Team gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]) end
                            if iHighestNukeTargetValue >= 18000 and (iHighestNukeTargetValue >= 30000 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 750) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to get a normal nuke') end
                                iCategoryWanted = M28UnitInfo.refCategorySML - categories.EXPERIMENTAL
                            end
                        end
                    end
                end
            end
            if not(iCategoryWanted) then
                --Check if we have gameender under construction anywhere, and if we want to consider another
                local bDontConsiderGameEnderInMostCases = false
                local bHaveExperimentalForThisLandZone, iOtherLandZonesWithExperimental, iMassToComplete = GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateauOrZero, iLandOrWaterZone, false, nil, M28UnitInfo.refCategoryGameEnder)
                if iOtherLandZonesWithExperimental > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 400 and iMassToComplete <= M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] * 3 then
                    bDontConsiderGameEnderInMostCases = true
                end


                --FACTION SPECIFIC LOGIC

                --UEF EXPERIMENTAL CHOICE
                if tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionUEF] then
                    --Decide between fatboy and novax, or (with v.high eco) mavor
                    iFactionRequired = M28UnitInfo.refFactionUEF
                    local iCurFatboyCount = 0
                    local iCurNovaxCount = 0
                    local iCurT3ArtiCount = 0 --mavor treated as 3 t3 arti
                    --How many fatboys do we have on the subteam already?
                    for iBrain, oBrain in M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subreftoFriendlyM28Brains] do
                        iCurFatboyCount = iCurFatboyCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryFatboy)
                        iCurNovaxCount = iCurNovaxCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryNovaxCentre)
                        iCurT3ArtiCount = iCurT3ArtiCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti) + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryExperimentalArti) * 3
                    end
                    local bWantNovaxInsteadOfArti = false
                    if iCurNovaxCount == 0 and not(import("/lua/game.lua").IsRestricted('xeb2402', aiBrain:GetArmyIndex())) and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryNovaxCentre) <= 2 then
                        bWantNovaxInsteadOfArti = true
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering UEF specific, iCurFatboyCount='..iCurFatboyCount..'; iCurNovaxCount='..iCurNovaxCount..'; iCurT3AritCount='..iCurT3ArtiCount) end
                    if bCanPathByLand then
                        if bEnemyHasFatboys and iCurNovaxCount == 0 then
                            iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                        elseif iCurFatboyCount == 0 then
                            iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                            --Game-ender for late game scenarios where enemy has their own arti and as a team we have already tried building a number of experimentals
                        elseif not(bDontConsiderGameEnderInMostCases) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 170 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 200 and iCurT3ArtiCount == 0  and iTeamLandExperimentals >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] >= 12000 and M28Map.iMapSize >= 512 and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryGameEnder) == 0 and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryExperimentalLevel) >= 2 * (1.5 + M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                            if bWantNovaxInsteadOfArti then iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                            else iCategoryWanted =  M28UnitInfo.refCategoryExperimentalArti
                            end
                        elseif iCurNovaxCount == 0 then
                            iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                        elseif iCurFatboyCount < math.min(5, math.max(math.min(3, 1 + iSubteamSize, 1 + iEnemyLandExperimentalCount), iCurT3ArtiCount + math.max(0, iCurT3ArtiCount - 3))) then
                            iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                        else
                            if not(bDontConsiderGameEnderInMostCases) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 80 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 20000 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 110) then
                                --Get gameender, unless we already have lots of T3 arti in which case consider getting more novaxes (since might be on a more spread out map)
                                if iCurT3ArtiCount < 3 then
                                    if bWantNovaxInsteadOfArti then iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                                    else iCategoryWanted =  M28UnitInfo.refCategoryExperimentalArti
                                    end
                                elseif iCurNovaxCount < iCurT3ArtiCount then
                                    iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                                else
                                    iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                                end
                            else
                                --Novax or T3 arti
                                if iCurNovaxCount < 3 + iCurT3ArtiCount then
                                    iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                                else
                                    if iDistToNearestEnemyBase <= 750 then
                                        iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                    else
                                        iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                                    end
                                end
                            end
                        end
                    else
                        --Cant path with land - prioritise novax more
                        if iCurFatboyCount == 0 and iEnemyLandExperimentalCount > 0 then
                            iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                        else
                            if not(bDontConsiderGameEnderInMostCases) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 90 then
                                --Get gameender, unless we already have lots of T3 arti in which case consider getting more novaxes (since might be on a more spread out map)
                                if iCurT3ArtiCount < 3 then
                                    if bWantNovaxInsteadOfArti then iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                                    else iCategoryWanted =  M28UnitInfo.refCategoryExperimentalArti
                                    end
                                elseif iCurNovaxCount < iCurT3ArtiCount then
                                    iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                                else
                                    iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                                end
                            else
                                --Novax or T3 arti
                                if iCurNovaxCount < 3 + iCurT3ArtiCount then
                                    iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                                else
                                    if iDistToNearestEnemyBase <= 750 then
                                        iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                    else
                                        iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                                    end
                                end
                            end
                        end
                    end
                    --SERAPHIM EXPERIMENTAL CHOICE
                elseif tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionSeraphim] then
                    iFactionRequired = M28UnitInfo.refFactionSeraphim
                    --Build ahwassa if have air contorl or cant path to enemy with land
                    local iGameEnderCount = 0
                    local iAhwassaCount = 0
                    for iBrain, oBrain in M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subreftoFriendlyM28Brains] do
                        iGameEnderCount = iGameEnderCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryGameEnder)
                        iAhwassaCount = iAhwassaCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL)
                    end
                    if not(bCanPathByLand) or M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl] or (not(M28Team.tTeamData[iTeam][M28Team.refbFarBehindOnAir]) and iTeamLandExperimentals >= math.max(1, iEnemyLandExperimentalCount)) or (iTeamLandExperimentals > iEnemyLandExperimentalCount + 2) then
                        if not(bDontConsiderGameEnderInMostCases) and ((iAhwassaCount > 0 or M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL) >= 2) and (iGameEnderCount == 0 or iGameEnderCount * 3 <= iAhwassaCount) and (not(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl]) and iDistToNearestEnemyBase >= 300 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 90)) then
                            iCategoryWanted = M28UnitInfo.refCategorySML * categories.EXPERIMENTAL
                        else
                            iCategoryWanted = M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL
                        end
                    else
                        --Consider building a yolona instead of a ythotha (or ahwassa instead of either)
                        if iTeamLandExperimentals >= 3 + 3 * (aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti) + iGameEnderCount * 2) and ((iTeamLandExperimentals >= math.max(5, iEnemyLandExperimentalCount + 1) or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandExperimental) >= 3 + iGameEnderCount) or (iGameEnderCount == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 80)) then
                            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 70 and iDistToNearestEnemyBase <= 750 then
                                local iT3ArtiCount = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti)
                                if not(bDontConsiderGameEnderInMostCases) and iAhwassaCount < (iT3ArtiCount + iGameEnderCount * 3) and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL) < 2 + (iT3ArtiCount + iGameEnderCount * 3) then
                                    iCategoryWanted = M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL
                                elseif iT3ArtiCount < 4 then
                                    iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                else
                                    iCategoryWanted = M28UnitInfo.refCategorySML * categories.EXPERIMENTAL
                                end
                            else
                                if bDontConsiderGameEnderInMostCases or (iAhwassaCount < 1 + iGameEnderCount * 3 and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL) <= 2 + iGameEnderCount * 3) then
                                    iCategoryWanted = M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL
                                else
                                    iCategoryWanted = M28UnitInfo.refCategorySML * categories.EXPERIMENTAL
                                end
                            end
                        else
                            --If have 5+ land experimentals then consider an ahwassa even if lack air control
                            if (iAhwassaCount + 1) * 2 + 3 < iTeamLandExperimentals then
                                iCategoryWanted = M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL
                            else
                                iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                                --If have Aeon then get GC in preference to Ythotha
                                if tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionAeon] then iFactionRequired = M28UnitInfo.refFactionAeon end
                            end
                        end
                    end
                elseif tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionCybran] then
                    iFactionRequired = M28UnitInfo.refFactionCybran
                    --If cant path to enemy with amphibious (rather than land) then consider T3 arti
                    local iCurAirExperimentals = 0
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        iCurAirExperimentals = iCurAirExperimentals + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryGunship * categories.EXPERIMENTAL + M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL + M28UnitInfo.refCategoryCzar)
                    end
                    local bAirExpForThisZone, iOtherLandZonesWithAirExperimental, AiriMassToComplete = GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateauOrZero, iLandOrWaterZone, false, nil, M28UnitInfo.refCategoryGunship * categories.EXPERIMENTAL + M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL + M28UnitInfo.refCategoryCzar)
                    iCurAirExperimentals = iCurAirExperimentals + iOtherLandZonesWithAirExperimental

                    if not(bCanPathAmphibiously) or ((not(bDontConsiderGameEnderInMostCases) or iDistToNearestEnemyBase <= 750) and iTeamLandExperimentals + iCurAirExperimentals * 1.25 >=  math.max(5, iEnemyLandExperimentalCount * 1.25)) then
                        if iDistToNearestEnemyBase <= 750 and (bDontConsiderGameEnderInMostCases or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 80 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then

                            if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti) < 4 then
                                iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                iFactionRequired = nil
                            else
                                iCategoryWanted = M28UnitInfo.refCategoryExperimentalStructure --i.e. scathis
                            end
                        else
                            iCategoryWanted = M28UnitInfo.refCategoryExperimentalStructure --this includes scathis
                        end
                    else
                        --Consider air experimental in some rarer cases late game
                        local bGetAirExperimentalInstead = false
                        if (bEnemyHasFatboys and iTeamLandExperimentals >= 1) or (iTeamLandExperimentals >= 2 and (iTeamLandExperimentals >= 5 or (iTeamLandExperimentals >= 3 and (M28Conditions.TeamHasAirControl(iTeam) or M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat] >= 10000)) or (iTeamLandExperimentals <= 2 and (M28Conditions.TeamHasAirControl(iTeam) and M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat] >= 10000)))) then
                            if iCurAirExperimentals == 0 or (bEnemyHasFatboys and (iCurAirExperimentals <= math.max(1, iTeamLandExperimentals) or iCurAirExperimentals * 10000 < M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat])) or (iCurAirExperimentals * 2.5 < iTeamLandExperimentals and (iCurAirExperimentals + 1) * 10000 < M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat]) then
                                bGetAirExperimentalInstead = true
                            end
                        end
                        if bGetAirExperimentalInstead then
                            iCategoryWanted = M28UnitInfo.refCategoryGunship * categories.EXPERIMENTAL + M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL
                        elseif not(bCanPathByLand) then
                            iCategoryWanted = M28UnitInfo.refCategoryMegalith --megalith has better torps
                        else
                            if iTeamLandExperimentals == 0 then
                                iCategoryWanted = M28UnitInfo.refCategoryMonkeylord
                            else
                                --Get megalith
                                iCategoryWanted = M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategoryMonkeylord --i.e. megalith (but slightly more helpful to mods doing it this way)
                            end
                        end
                    end
                elseif tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionAeon] then
                    iFactionRequired = M28UnitInfo.refFactionAeon
                    local iCurAirExperimentals = 0
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        iCurAirExperimentals = iCurAirExperimentals + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryGunship * categories.EXPERIMENTAL + M28UnitInfo.refCategoryCzar)
                    end
                    local bAirExpForThisZone, iOtherLandZonesWithAirExperimental, AiriMassToComplete = GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateauOrZero, iLandOrWaterZone, false, nil, M28UnitInfo.refCategoryGunship * categories.EXPERIMENTAL + M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL + M28UnitInfo.refCategoryCzar)
                    iCurAirExperimentals = iCurAirExperimentals + iOtherLandZonesWithAirExperimental

                    local iEnemyT3ArtiEquivalent = M28Conditions.GetT3ArtiEquivalent(iTeam, 0.4, 3, true, nil)
                    local iFriendlyGameEnderUnderConstruction = M28Conditions.GetNumberOfUnderConstructionUnitsOfCategoryInOtherZones(tLZOrWZTeamData, iTeam, M28UnitInfo.refCategoryGameEnder)

                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1000 and iCurAirExperimentals + iTeamLandExperimentals > (iFriendlyGameEnderUnderConstruction + iEnemyT3ArtiEquivalent/3) then
                        iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                    elseif not(bCanPathAmphibiously) or (not(bCanPathByLand) and iDistToNearestEnemyBase >= 350 and iEnemyLandExperimentalCount == 0) or ((not(bDontConsiderGameEnderInMostCases) or iDistToNearestEnemyBase <= 750) and iTeamLandExperimentals + iCurAirExperimentals * 1.6 >= math.max(5, iEnemyLandExperimentalCount + 1)) then
                        if iDistToNearestEnemyBase <= 750 then
                            if iEnemyT3ArtiEquivalent < 4 then
                                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1000 then iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                                else iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                end
                            else
                                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= math.max(275, 110 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and iEnemyT3ArtiEquivalent <= 1.4 and iFriendlyGameEnderUnderConstruction == 0 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will get paragon1; gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; iEnemyT3ArtiEquivalent='..iEnemyT3ArtiEquivalent..'; iFriendlyGameEnderUnderConstruction='..iFriendlyGameEnderUnderConstruction) end
                                    iCategoryWanted = M28UnitInfo.refCategoryParagon
                                else
                                    iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                                end
                            end
                        else
                            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= math.max(275, 110 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and iEnemyT3ArtiEquivalent <= 1.4 and iFriendlyGameEnderUnderConstruction == 0 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to get paragon2; gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; iEnemyT3ArtiEquivalent='..iEnemyT3ArtiEquivalent..'; iFriendlyGameEnderUnderConstruction='..iFriendlyGameEnderUnderConstruction) end
                                iCategoryWanted = M28UnitInfo.refCategoryParagon
                            else
                                iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                            end
                        end
                    else
                        --Consider air experimental in some rarer cases late game
                        local bGetAirExperimentalInstead = false
                        if (bEnemyHasFatboys and iTeamLandExperimentals >= 1) or (iTeamLandExperimentals >= 2 and (iTeamLandExperimentals >= 5 or (iTeamLandExperimentals >= 3 and (M28Conditions.TeamHasAirControl(iTeam) or M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat] >= 10000)) or (iTeamLandExperimentals <= 2 and (M28Conditions.TeamHasAirControl(iTeam) and M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat] >= 10000)))) then
                            if iCurAirExperimentals == 0 or (bEnemyHasFatboys and (iCurAirExperimentals <= math.max(1, iTeamLandExperimentals) or iCurAirExperimentals * 10000 < M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat])) or  (iCurAirExperimentals * 2.5 < iTeamLandExperimentals and (iCurAirExperimentals + 1) * 10000 < M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat]) then
                                bGetAirExperimentalInstead = true
                            end
                        end
                        if bGetAirExperimentalInstead then
                            iCategoryWanted = M28UnitInfo.refCategoryGunship * categories.EXPERIMENTAL + M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL + M28UnitInfo.refCategoryCzar
                        else
                            --Build GC or paragon
                            if ((iTeamLandExperimentals >= 5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 70) or (iTeamLandExperimentals >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 80 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= math.max(275, 110 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and iEnemyT3ArtiEquivalent <= 1.4 and iFriendlyGameEnderUnderConstruction == 0 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will get paragon3 due to lots of friendly land experimentals; gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; iEnemyT3ArtiEquivalent='..iEnemyT3ArtiEquivalent..'; iFriendlyGameEnderUnderConstruction='..iFriendlyGameEnderUnderConstruction..'; iTeamLandExperimentals='..iTeamLandExperimentals) end
                                iCategoryWanted = M28UnitInfo.refCategoryParagon
                            else
                                iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                            end
                            --Dont reset faction requirement as GC is better than most other factions
                        end
                    end
                else
                    --Not dealing with standard faction - basic choice between land and T3 arti/experimental structure, since unlikely to have hte logic in place for other units
                    if not(bCanPathAmphibiously) then
                        iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalStructure
                    else
                        --can path to enemy with land
                        local iBaseAdjust = 0
                        if iDistToNearestEnemyBase >= 400 then
                            if iDistToNearestEnemyBase >= 750 then iBaseAdjust = -2
                            else iBaseAdjust = -1
                            end
                        end
                        if iTeamLandExperimentals <= math.max(iEnemyLandExperimentalCount + 2 + iBaseAdjust, 3 + iBaseAdjust) then
                            iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                        else
                            iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalStructure
                        end
                    end
                end
            end
        end
    end
    if not(iCategoryWanted) then iCategoryWanted = M28UnitInfo.refCategoryLandExperimental end --redundancy
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, will list out all blueprints meeting iCategoryWanted. iFactionRequired='..(iFactionRequired or 'nil'))
        local tBlueprints = EntityCategoryGetUnitList(iCategoryWanted)
        LOG('Blueprints='..repru(tBlueprints))
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iCategoryWanted, iFactionRequired
end

function MonitorToReissueReclaimOrder(oEngineer, oNearestReclaimableEnemy, iDistanceToReissue, iTicksToCheck)
    --Call vai fork thread, intended so e.g. when engineer is approaching an enemy to reclaim, it will start reclaiming hte moment the enemy gets within reclaim range
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MonitorToReissueReclaimOrder'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iRemainingTicksToWait = iTicksToCheck
    local iCurDist
    local iEngineerActionRequired = oEngineer[refiAssignedAction]
    local iEngineerPriorityRequired = oEngineer[refiAssignedActionPriority]

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to reclaim enemy '..oNearestReclaimableEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestReclaimableEnemy)..'; iDistanceToReissue='..iDistanceToReissue..'; iTicksToCheck='..iTicksToCheck..'; Time='..GetGameTimeSeconds()) end
    while iRemainingTicksToWait > 0 do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        iRemainingTicksToWait = iRemainingTicksToWait - 1
        --Abort if either unit is invalid, engineer is already reclaiming, or engineer appears to have orders changed (vai cahnge in priority or action)
        if bDebugMessages == true then
            LOG(sFunctionRef..': iRemainingTicksToWait='..iRemainingTicksToWait..'; TIme='..GetGameTimeSeconds()..'; Is engi valid='..tostring(M28UnitInfo.IsUnitValid(oEngineer))..'; Is nearest reclaimable enemy valid='..tostring(M28UnitInfo.IsUnitValid(oNearestReclaimableEnemy))..'; Engi action='..(oEngineer[refiAssignedAction] or 'nil')..'; Engi priority='..(oEngineer[refiAssignedActionPriority] or 'nil'))
            if M28UnitInfo.IsUnitValid(oEngineer) and M28UnitInfo.IsUnitValid(oNearestReclaimableEnemy) then
                LOG(sFunctionRef..': Dist from engi to nearest enemy='..M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), oNearestReclaimableEnemy:GetPosition())..'; Engi state='..M28UnitInfo.GetUnitState(oEngineer))
            end
        end
        if M28UnitInfo.IsUnitValid(oEngineer) and M28UnitInfo.IsUnitValid(oNearestReclaimableEnemy) and not(oEngineer:IsUnitState('Reclaiming')) and oEngineer[refiAssignedAction] == iEngineerActionRequired and oEngineer[refiAssignedActionPriority] == iEngineerPriorityRequired then
            iCurDist = M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), oNearestReclaimableEnemy:GetPosition())
            if iCurDist <= iDistanceToReissue then
                if bDebugMessages == true then LOG(sFunctionRef..': Engineer is close to target so will issue a reclaim order') end
                M28Orders.IssueTrackedReclaim(oEngineer, oNearestReclaimableEnemy, false, 'ReclByT', false)
                break --Dont want to risk clearing engineer every tick and never reclaiming
            end
        else
            break
        end

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function CheckForNearbyEnemies()  end --This is incorporated into available engineers by tech - added to make it easier to locate logic
function FilterToAvailableEngineersByTech(tEngineers, bInCoreZone, tLZData, tLZTeamData, iTeam, iPlateauOrPond, iLandZone, bIsWaterZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'FilterToAvailableEngineersByTech'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..' for iPlateauOrPond='..iPlateauOrPond..'; iLandZone='..iLandZone..'; reprs of tEngineers='..reprs(tEngineers)) end

    --Returns a table of available engineers by tech
    local toAvailableEngineersByTech = {[1]= { },[2]={},[3]={}}
    local toAssignedEngineers = {}
    local bHaveAvailableEngi = false
    local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
    --local tNearbyEnemiesByZone = {}
    local bCheckForEnemies = false
    if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then --M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
        --table.insert(tNearbyEnemiesByZone, tLZTeamData[M28Map.subrefTEnemyUnits])
        bCheckForEnemies = true
    end

    --[[if bIsWaterZone then
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefWZOtherWaterZones]) == false then
            local iAdjWZ
            for _, tWZSubtable in  tLZData[M28Map.subrefWZOtherWaterZones] do
                iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]

                if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                    table.insert(tNearbyEnemiesByZone, M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits])
                    bCheckForEnemies = true
                end
            end
        end
    elseif M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjacentLZ in  tLZData[M28Map.subrefLZAdjacentLandZones] do
            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iAdjacentLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                table.insert(tNearbyEnemiesByZone, M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iAdjacentLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits])
                bCheckForEnemies = true
            end
        end
    end--]]
    --if bDebugMessages == true then LOG(sFunctionRef..': Finished deciding if should check for enemies (based on if enemy threats in this or nearby LZ), bCheckForEnemies='..tostring(bCheckForEnemies)..'; Is table of enemy units for this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))..'; is tNearbyEnemiesByZone empty='..tostring(M28Utilities.IsTableEmpty(tNearbyEnemiesByZone))..'; subrefLZThreatEnemyMobileDFTotalin this LZ='..(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)) end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished deciding if should check for enemies (based on if enemy threats in this or nearby LZ), bCheckForEnemies='..tostring(bCheckForEnemies)..'; If get units aroundpoint with radius of 30 is the table of units empty='..tostring(M28Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategorySubmarine, tLZData[M28Map.subrefMidpoint], 30, 'Enemy')))) end

    local iClosestDistUntilInRangeOfMobileEnemy = 100000
    local iClosestDistUntilInRangeOfStaticEnemy = 100000
    local iNearestReclaimableEnemy = 100000
    local iNearestReclaimableDangerousEnemy = 100000
    local oNearestReclaimableDangerousEnemy
    local iNearestEnemy = 100000
    local oNearestReclaimableEnemy
    local oNearestEnemy
    local iCurDistToEnemy
    local iCurDistUntilInRange
    local iCurUnitRange
    local bWantEngiToRun
    local bEngiIsUnavailable

    local iLZOrWZToRunTo
    local iThresholdToRunFromMobileEnemies = 35
    if bInCoreZone then iThresholdToRunFromMobileEnemies = 10 end

    local iEnemyUnitSearchRange = iThresholdToRunFromMobileEnemies + math.max(10, (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0), (tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0), (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0), (tLZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0), (tLZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] or 0))

    local bCheckForReclaim
    if (tLZData[M28Map.subrefTotalSignificantMassReclaim] or 0) >= 20 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 8 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.1 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] <= 300 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.35)) then
        bCheckForReclaim = true
    end

    if tEngineers then
        local bCheckForWallsToReclaim = false
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of wall segments empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPlayerWallSegments]))) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPlayerWallSegments]) == false then
            if table.getn(tLZData[M28Map.subrefLZPlayerWallSegments]) >= 10 then
                bCheckForWallsToReclaim = true
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Size of wall segment table='..table.getn(tLZData[M28Map.subrefLZPlayerWallSegments])..'; bCheckForWallsToReclaim='..tostring(bCheckForWallsToReclaim or false)) end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iEnemyUnitSearchRange='..iEnemyUnitSearchRange..'; iThresholdToRunFromMobileEnemies='..iThresholdToRunFromMobileEnemies..'; Time='..GetGameTimeSeconds()) end
        for iEngineer, oEngineer in tEngineers do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering engineer '..(oEngineer.UnitId or 'nil')..'; iEngineer='..iEngineer..' with unit state='..M28UnitInfo.GetUnitState(oEngineer)..'; refiAssignedAction='..(oEngineer[refiAssignedAction] or 'nil')..'; oEngineer[M28UnitInfo.refbSpecialMicroActive]='..tostring(oEngineer[M28UnitInfo.refbSpecialMicroActive] or false)..'; refiGameTimeToResetMicroActive='..(oEngineer[M28UnitInfo.refiGameTimeToResetMicroActive] or 'nil')) end
            bWantEngiToRun = false
            bEngiIsUnavailable = false
            if not(oEngineer:IsUnitState('Attached')) and not(oEngineer[M28UnitInfo.refbSpecialMicroActive]) and not(oEngineer:IsUnitState('Capturing')) then
                --First check for enemies that we want to run from/take action from
                if bCheckForEnemies or bCheckForWallsToReclaim then
                    local bReclaimingDangerousEnemy = false
                    iNearestReclaimableEnemy = 10000
                    iNearestReclaimableDangerousEnemy = 10000
                    iClosestDistUntilInRangeOfMobileEnemy = 10000
                    iClosestDistUntilInRangeOfStaticEnemy = 10000
                    oNearestReclaimableDangerousEnemy = nil
                    oNearestReclaimableEnemy = nil
                    oNearestEnemy = nil

                    --If engi is building emergency PD or Arti then dont run
                    if not(oEngineer[refiAssignedAction] == refActionBuildEmergencyPD or oEngineer[refiAssignedAction] == refActionBuildEmergencyArti or oEngineer[refiAssignedAction] == refActionBuildWall) then
                        --Is the engineer reclaiming an engineer or combat unit, or alternatively building something whose fraction complete is almost done?
                        if oEngineer:IsUnitState('Reclaiming') then
                            local oReclaimTarget = oEngineer:GetFocusUnit()
                            if oReclaimTarget and not(oReclaimTarget.Dead) and ((oReclaimTarget[M28UnitInfo.refiCombatRange] or 0) > 0 or EntityCategoryContains(categories.RECLAIM, oReclaimTarget.UnitId)) then
                                bReclaimingDangerousEnemy = true
                            end
                        end
                        if not(bReclaimingDangerousEnemy or ((oEngineer:IsUnitState('Repairing') or oEngineer:IsUnitState('Building')) and oEngineer:GetFocusUnit() and oEngineer:GetFocusUnit():GetFractionComplete() >= 0.9 and oEngineer:GetFocusUnit():GetFractionComplete() < 1) or (oEngineer:IsUnitState('Capturing') and oEngineer:GetWorkProgress() >= 0.75)) then
                            local tNearbyEnemiesByZone = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategorySubmarine, oEngineer:GetPosition(), iEnemyUnitSearchRange, 'Enemy')
                            --for iSubtable, tSubtable in tNearbyEnemiesByZone do
                            --if M28Utilities.IsTableEmpty(tSubtable) == false then
                            --for iUnit, oUnit in tSubtable do
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby enemies empty for engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'='..tostring(M28Utilities.IsTableEmpty(tNearbyEnemiesByZone))) end
                            if M28Utilities.IsTableEmpty(tNearbyEnemiesByZone) == false then
                                for iUnit, oUnit in tNearbyEnemiesByZone do
                                    --It's not possible to reclaim an under construction building
                                    if not(oUnit.Dead) and (oUnit:GetFractionComplete() == 1 or not(oUnit:IsBeingBuilt())) then
                                        iCurUnitRange = (oUnit[M28UnitInfo.refiDFRange] or 0) + (oUnit[M28UnitInfo.refiIndirectRange] or 0)
                                        if bIsWaterZone then iCurUnitRange = math.max(iCurUnitRange, (oUnit[M28UnitInfo.refiAntiNavyRange] or 0)) end
                                        iCurDistToEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEngineer:GetPosition())
                                        if iCurDistToEnemy < iNearestEnemy then
                                            iNearestEnemy = iCurDistToEnemy
                                            oNearestEnemy = oUnit
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurUnitRange='..iCurUnitRange..'; iCurDistToEnemy='..iCurDistToEnemy..'; Is reclaimable='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryReclaimable, oUnit.UnitId))) end
                                        if iCurDistToEnemy < iNearestReclaimableDangerousEnemy and EntityCategoryContains(M28UnitInfo.refCategoryReclaimable, oUnit.UnitId) then
                                            if oUnit[M28UnitInfo.refiCombatRange] > 0 or EntityCategoryContains(categories.RECLAIM, oUnit.UnitId) then
                                                --Dangerous enemy
                                                iNearestReclaimableDangerousEnemy = iCurDistToEnemy
                                                oNearestReclaimableDangerousEnemy = oUnit
                                            end
                                            if iCurDistToEnemy < iNearestReclaimableEnemy then
                                                iNearestReclaimableEnemy = iCurDistToEnemy
                                                oNearestReclaimableEnemy = oUnit
                                            end
                                        end
                                        --Ignore land scouts and similar unthreatening units
                                        if iCurUnitRange > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) then
                                            iCurDistUntilInRange = iCurDistToEnemy - iCurUnitRange
                                            if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then
                                                if iCurDistUntilInRange < iClosestDistUntilInRangeOfMobileEnemy then iClosestDistUntilInRangeOfMobileEnemy = iCurDistUntilInRange end
                                            else
                                                if iCurDistUntilInRange < iClosestDistUntilInRangeOfStaticEnemy then iClosestDistUntilInRangeOfStaticEnemy = iCurDistUntilInRange end
                                            end
                                        end
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': Unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' is dead or is being built (cant reclaim under construction units), is table of g etguards empty='..tostring(M28Utilities.IsTableEmpty(oUnit:GetGuards()))) end
                                    end
                                end
                                --end
                            end
                            --Consider reclaiming wall segment instead
                            if bDebugMessages == true then LOG(sFunctionRef..': bCheckForWallsToReclaim='..tostring(bCheckForWallsToReclaim or false)..'; iNearestReclaimableEnemy='..(iNearestReclaimableEnemy or 'nil')..'; iClosestDistUntilInRangeOfStaticEnemy='..(iClosestDistUntilInRangeOfStaticEnemy or 'nil')..'; iClosestDistUntilInRangeOfMobileEnemy='..(iClosestDistUntilInRangeOfMobileEnemy or 'nil')) end
                            if bCheckForWallsToReclaim and (iNearestReclaimableEnemy or 100) >= 10 and (iClosestDistUntilInRangeOfStaticEnemy or 100) >= 8 and (iClosestDistUntilInRangeOfMobileEnemy or 100) >= 10 then
                                local iEngiIndex = oEngineer:GetAIBrain():GetArmyIndex()
                                for iUnit, oUnit in tLZData[M28Map.subrefLZPlayerWallSegments] do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering wall '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Dist to engi='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEngineer:GetPosition())..'; Is enemy='..tostring(IsEnemy(iEngiIndex, oUnit:GetAIBrain():GetArmyIndex()))) end
                                    if M28UnitInfo.IsUnitValid(oUnit) and IsEnemy(iEngiIndex, oUnit:GetAIBrain():GetArmyIndex()) then
                                        iCurDistToEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEngineer:GetPosition())
                                        if iCurDistToEnemy < (iNearestReclaimableEnemy or 10000) then
                                            iNearestReclaimableEnemy = iCurDistToEnemy
                                            oNearestReclaimableEnemy = oUnit
                                        end
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Checking for nearby enemies for engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; iNearestReclaimableEnemy='..iNearestReclaimableEnemy..'; iClosestDistUntilInRangeOfStaticEnemy='..iClosestDistUntilInRangeOfStaticEnemy..'; Core base='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase] or false)..'; Core expansion='..tostring(tLZTeamData[M28Map.subrefLZCoreExpansion] or false)) end
                            local iEngiBuildDistance = oEngineer:GetBlueprint().Economy.MaxBuildDistance
                            if iNearestReclaimableEnemy < 20 and ((iClosestDistUntilInRangeOfStaticEnemy >= 10 and iNearestReclaimableEnemy <= iEngiBuildDistance) or iNearestReclaimableEnemy <= (iEngiBuildDistance + 7) or (iNearestReclaimableEnemy <= iEngiBuildDistance + 14 and (tLZTeamData[M28Map.subrefLZbCoreBase] or tLZTeamData[M28Map.subrefLZCoreExpansion]))) then
                                --Reclaim enemy
                                --Switch the target to the nearest dangerous enemy if it is in our build range
                                if iNearestReclaimableDangerousEnemy < iEngiBuildDistance and oNearestReclaimableDangerousEnemy then
                                    oNearestReclaimableEnemy = oNearestReclaimableDangerousEnemy
                                end
                                bEngiIsUnavailable = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Will reclaim or capture unit, is capture target='..tostring(oNearestReclaimableEnemy[M28UnitInfo.refbIsCaptureTarget])..'; Is oNearestReclaimableEnemy valid='..tostring(M28UnitInfo.IsUnitValid(oNearestReclaimableEnemy))) end
                                if oNearestReclaimableEnemy[M28UnitInfo.refbIsCaptureTarget] then
                                    TrackEngineerAction(oEngineer, refActionCaptureUnit, false, 1)
                                    --Dont capture if already capturing (redundancy)
                                    if not(oEngineer:IsUnitState('Capturing')) then
                                        M28Orders.IssueTrackedCapture(oEngineer, oNearestReclaimableEnemy, false, 'CapE')
                                        if bDebugMessages == true then LOG(sFunctionRef..': Told engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to capture enemy unit') end
                                    end
                                else
                                    TrackEngineerAction(oEngineer, refActionReclaimEnemyUnit, false, 1)
                                    M28Orders.IssueTrackedReclaim(oEngineer, oNearestReclaimableEnemy, false, 'RecE')
                                    if bDebugMessages == true then LOG(sFunctionRef..': Told engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to reclaim enemy unit '..oNearestReclaimableEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestReclaimableEnemy)..'; Is getguards empty='..tostring(M28Utilities.IsTableEmpty(oNearestReclaimableEnemy:GetGuards()))..'; Unit:IsBeingBuilt()='..tostring(oNearestReclaimableEnemy:IsBeingBuilt())) end
                                    --Monitor every tick for the next 9 ticks to see if enemy gets in-range
                                    local oEnemyBP = oNearestReclaimableEnemy:GetBlueprint()
                                    local iDistanceUntilInRange = iEngiBuildDistance + math.min(oEnemyBP.Physics.SkirtSizeX, oEnemyBP.Physics.SkirtSizeZ) * 0.5
                                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if we want to monitor reclaim distance, iDistanceUntilInRange='..iDistanceUntilInRange..'; iNearestReclaimableEnemy='..iNearestReclaimableEnemy..'; Speed of us and them='..(oEnemyBP.Physics.MaxSpeed or 0) + oEngineer:GetBlueprint().Physics.MaxSpeed) end
                                    if iNearestReclaimableEnemy > iDistanceUntilInRange and iNearestReclaimableEnemy - iDistanceUntilInRange <= (oEnemyBP.Physics.MaxSpeed or 0) + oEngineer:GetBlueprint().Physics.MaxSpeed + 0.2 then
                                        ForkThread(MonitorToReissueReclaimOrder, oEngineer, oNearestReclaimableEnemy, iDistanceUntilInRange, 9)
                                    end
                                end
                            else
                                --Enemy not close enough to reclaim, do we want to run?
                                if not(tLZTeamData[M28Map.subrefLZbCoreBase]) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Not close enough to reclaim enemy, and not a core LZ, iClosestDistUntilInRangeOfStaticEnemy='..iClosestDistUntilInRangeOfStaticEnemy..'; iClosestDistUntilInRangeOfMobileEnemy='..iClosestDistUntilInRangeOfMobileEnemy..'; iThresholdToRunFromMobileEnemies='..iThresholdToRunFromMobileEnemies) end
                                    if iClosestDistUntilInRangeOfStaticEnemy < 8 or iClosestDistUntilInRangeOfMobileEnemy <= iThresholdToRunFromMobileEnemies then
                                        local tPositionToRunFrom
                                        if oNearestEnemy then tPositionToRunFrom = oNearestEnemy:GetPosition() end
                                        if not(bIsWaterZone) then
                                            iLZOrWZToRunTo =  M28Land.GetLandZoneToRunTo(iTeam, iPlateauOrPond, iLandZone, M28Map.refPathingTypeHover, oEngineer:GetPosition(), tPositionToRunFrom)
                                            if not(iLZOrWZToRunTo == iLandZone) and iLZOrWZToRunTo then --If LZ to run to is same as cur LZ might as well use engineer normally (e.g. might have defences to build)
                                                --Run to the LZ
                                                M28Orders.IssueTrackedMove(oEngineer, M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLZOrWZToRunTo][M28Map.subrefMidpoint], 8, false, 'RunTo'..iLZOrWZToRunTo)
                                                bEngiIsUnavailable = true
                                                TrackEngineerAction(oEngineer, refActionRunToLandZone, false, 1, {iPlateauOrPond, iLZOrWZToRunTo})
                                            end
                                        else
                                            iLZOrWZToRunTo = M28Navy.GetWaterZoneToRunTo(iTeam, iPlateauOrPond, iLandZone, M28Map.refPathingTypeHover, oEngineer:GetPosition(), tPositionToRunFrom)
                                            if not(iLZOrWZToRunTo == iLandZone) then --If LZ to run to is same as cur LZ might as well use engineer normally (e.g. might have defences to build)
                                                --Run to the LZ
                                                M28Orders.IssueTrackedMove(oEngineer, M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iLZOrWZToRunTo][M28Map.subrefMidpoint], 8, false, 'NRunTo'..iLZOrWZToRunTo)
                                                bEngiIsUnavailable = true
                                                TrackEngineerAction(oEngineer, refActionRunToWaterZone, false, 1, nil, iLZOrWZToRunTo)
                                            else
                                                --Consider moving to land zone instead if there is an adjacent LZ
                                                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentLandZones]) == false then
                                                    local tClosestRallyPoint
                                                    local iClosestRallyPointDist = 100000
                                                    local iCurRallyPointDist
                                                    for iEntry, tLZSubtable in tLZData[M28Map.subrefAdjacentLandZones] do
                                                        local tCurRallyPoint = M28Land.GetNearestLandRallyPoint(tLZData, iTeam, tLZSubtable[M28Map.subrefWPlatAndLZNumber][1], tLZSubtable[M28Map.subrefWPlatAndLZNumber][2], nil)
                                                        if tCurRallyPoint then
                                                            iCurRallyPointDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tCurRallyPoint)
                                                            if iCurRallyPointDist < iClosestRallyPointDist then
                                                                tClosestRallyPoint = {tCurRallyPoint[1], tCurRallyPoint[2], tCurRallyPoint[3]}
                                                                iClosestRallyPointDist = iCurRallyPointDist
                                                            end
                                                        end
                                                    end
                                                    if tClosestRallyPoint then
                                                        local iPlateau, iLZToRunTo = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tClosestRallyPoint)
                                                        M28Orders.IssueTrackedMove(oEngineer, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZToRunTo][M28Map.subrefMidpoint], 8, false, 'WLRunTo'..iLZOrWZToRunTo)
                                                        bEngiIsUnavailable = true
                                                        TrackEngineerAction(oEngineer, refActionRunToLandZone, false, 1, {iPlateau, iLZToRunTo})
                                                    end
                                                end
                                            end
                                        end
                                    else
                                        --We arent yet close enough that we want to run so do nothing
                                    end
                                end
                            end
                        end
                    end
                end
            else
                bEngiIsUnavailable = true
            end


            --Finished checking for enemies; now check more generally if engineer is busy
            if not(bEngiIsUnavailable) then
                bEngiIsUnavailable = not(M28Conditions.IsEngineerAvailable(oEngineer))
                if bDebugMessages == true then LOG(sFunctionRef..': Entry in table='..iEngineer..'; Considering if engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' is available, result='..tostring(M28Conditions.IsEngineerAvailable(oEngineer, true))..'; Eng unit state='..M28UnitInfo.GetUnitState(oEngineer)..'; bEngiIsUnavailable='..tostring(bEngiIsUnavailable)) end
                if bCheckForReclaim then
                    if not(bEngiIsUnavailable) then
                        if M28ACU.ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrPond, iLandZone, tLZData, tLZTeamData, oEngineer, true, 20) then
                            bEngiIsUnavailable = true
                        end
                    elseif oEngineer:IsUnitState('Moving') and oEngineer[refiAssignedAction] == refActionMoveToLandZone then
                        --Engineer is already busy; exception if engineer is traveling to another zone where want to reissue its old order after issuing a reclaim order
                        if M28ACU.ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrPond, iLandZone, tLZData, tLZTeamData, oEngineer, true, 50) then
                            bEngiIsUnavailable = true
                        end
                    end
                end
            end
            if bEngiIsUnavailable then
                table.insert(toAssignedEngineers, oEngineer)
            else
                --Clear engineer trackers as redundancy in case failed to clear previously
                if oEngineer[refiAssignedAction] then ClearEngineerTracking(oEngineer) end

                table.insert(toAvailableEngineersByTech[M28UnitInfo.GetUnitTechLevel(oEngineer)], oEngineer)
                if bDebugMessages == true then LOG(sFunctionRef..': Just added engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to toAvailableEngineersByTech, Eng tech level='..M28UnitInfo.GetUnitTechLevel(oEngineer)..'; Size of table='..table.getn(toAvailableEngineersByTech[M28UnitInfo.GetUnitTechLevel(oEngineer)])) end
                bHaveAvailableEngi = true
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished recording available engineers, Is tEngineers empty='..tostring(M28Utilities.IsTableEmpty(tEngineers))..'; bHaveAvailableEngi='..tostring(bHaveAvailableEngi)..'; Is toAssignedEngineers empty='..tostring(M28Utilities.IsTableEmpty(toAssignedEngineers))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bHaveAvailableEngi then return toAvailableEngineersByTech, toAssignedEngineers
    else return nil, toAssignedEngineers
    end
end

function GetCategoryToBuildOrAssistFromAction(iActionToAssign, iMinTechLevel, aiBrain, tbEngineersOfFactionOrNilIfAlreadyAssigned, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iLandOrWaterZone)
    --Returns the building category type based on the action; iMinTechLevel is optional; aiBrain is required if dealing with construction of experimental
    --tbEngineersOfFaction is true for each faction that we have an engineer of iMinTechLevel available for, but is nil if we don't need to worry about factions, either due to category or because the unit/building is under construciton already

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetCategoryToBuildOrAssistFromAction'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iCategoryToBuild = tiActionCategory[iActionToAssign]
    local iOptionalFactionRequired --Used for certain categories where chocie of category depended on the faction available
    if bDebugMessages == true then LOG(sFunctionRef..': Time of start='..GetGameTimeSeconds()..'; iActionToAssign='..iActionToAssign..'; iMinTechLevel='..iMinTechLevel..'; aiBrain='..aiBrain.Nickname..'; repru(tbEngineersOfFactionOrNilIfAlreadyAssigned)='..repru(tbEngineersOfFactionOrNilIfAlreadyAssigned)..'; Is tbActionsThatDontHaveCategory[iActionToAssign] nil='..tostring(tbActionsThatDontHaveCategory[iActionToAssign] == nil)..'; Is tiActionCategory[iActionToAssign] nil='..tostring(tiActionCategory[iActionToAssign] == nil)) end
    --Manual adjustments to default category
    if iActionToAssign == refActionBuildGameEnder then
        if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] >= 750 then
            iCategoryToBuild = iCategoryToBuild - M28UnitInfo.refCategoryParagon
        end
    end
    if not(iCategoryToBuild) and not(tbActionsThatDontHaveCategory[iActionToAssign]) then
        if iActionToAssign == refActionBuildEmergencyPD then
            if aiBrain[M28Overseer.refbCloseToUnitCap] then
                if bDebugMessages == true then LOG(sFunctionRef..': Close to unit cap so will get T2PlusPD') end
                iCategoryToBuild = M28UnitInfo.refCategoryT2PlusPD
            else
                if iMinTechLevel > 1 or (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 and (aiBrain[M28Economy.refiGrossMassBaseIncome] >= 4 or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPD * categories.TECH1) > 0)) then
                    --Want to build either T2 or T2+ PD
                    local iT2PD = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPD * categories.TECH2)
                    if iT2PD <= 5 or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPD * categories.TECH3) >= iT2PD then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have 5 or fewer t2 pd so will get more t2 pd') end
                        iCategoryToBuild = M28UnitInfo.refCategoryPD - categories.TECH3
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Have at least 5 T2 PD so will get T2PlusPD') end
                        iCategoryToBuild = M28UnitInfo.refCategoryT2PlusPD
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Have no T1 PD so will get T1 PD') end
                    iCategoryToBuild = M28UnitInfo.refCategoryPD * categories.TECH1
                end
            end
        elseif iActionToAssign == refActionFortifyFirebase then
            M28Utilities.ErrorHandler('Firebase logic not in place')
            --Calculate closest firebase and assume we are trying to build this
            if aiBrain[refiFirebaseBeingFortified] then
                iCategoryToBuild = aiBrain[refiFirebaseCategoryWanted][aiBrain[refiFirebaseBeingFortified]]
                if M28Utilities.IsTableEmpty(iCategoryToBuild, false) then M28Utilities.ErrorHandler('Dont have a category to build for firebase ref '..(aiBrain[refiFirebaseBeingFortified] or 'nil')..'; will just build T2 plus PD')
                    iCategoryToBuild = M28UnitInfo.refCategoryT2PlusPD
                end
            else
                M28Utilities.ErrorHandler('Dont have a firebase to be fortified so will just build T2 plus PD')
                iCategoryToBuild = M28UnitInfo.refCategoryT2PlusPD
            end
        elseif iActionToAssign == refActionBuildExperimental or iActionToAssign == refActionBuildSecondExperimental then
            iCategoryToBuild, iOptionalFactionRequired = DecideOnExperimentalToBuild(iActionToAssign, aiBrain, tbEngineersOfFactionOrNilIfAlreadyAssigned, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iLandOrWaterZone)
        elseif iActionToAssign == refActionBuildShield or iActionToAssign == refActionBuildSecondShield then
            --NOTE: Separately this gets changed to tech3 if need increased range
            if M28Map.bIsCampaignMap then iCategoryToBuild = M28UnitInfo.refCategoryFixedShield
            elseif iMinTechLevel == 2 and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false and not(aiBrain[M28Overseer.refbDefendAgainstArti]) and not(aiBrain[M28Overseer.refbCloseToUnitCap]) then
                iCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.TECH2
            elseif iMinTechLevel >= 3 or aiBrain[M28Overseer.refbDefendAgainstArti] or aiBrain[M28Overseer.refbCloseToUnitCap] or M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyAirToGroundThreat] >= 12000 then
                iCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.TECH3
            else
                iCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.TECH2
            end
        else
            M28Utilities.ErrorHandler('Need to add code for action='..(iActionToAssign or 'nil'))
        end
    end
    if iCategoryToBuild then
        --Power specific - only build at the minimum tech level, presume this is so if we want to build T1/T2 power while having access to T3 (due to very low power) we can; will therefore add adjustment when looking for part-build buildings to counter this
        if iActionToAssign == refActionBuildPower then
            --Only restrict the power we will build if we have no unit restrictions and/or arent in a campaign
            if not(M28Overseer.bUnitRestrictionsArePresent or M28Map.bIsCampaignMap) then
                iCategoryToBuild = iCategoryToBuild * M28UnitInfo.ConvertTechLevelToCategory(iMinTechLevel)
            end
        else
            if iMinTechLevel > 1 then
                if iMinTechLevel == 3 then iCategoryToBuild = iCategoryToBuild * categories.TECH3 + iCategoryToBuild*categories.EXPERIMENTAL
                else iCategoryToBuild = iCategoryToBuild - categories.TECH1
                end
            end
        end
        --Unit cap - dont build T1 if near cap, and only build experimentals if very near cap
        if aiBrain[M28Overseer.refbCloseToUnitCap] then
            if bDebugMessages == true then LOG(sFunctionRef..': Are close to unit cap, wont build T1 units, does category to build contain only T1 and not HQ or mex='..tostring(M28Utilities.DoesCategoryContainCategory(categories.TECH1, iCategoryToBuild, true))..'; Does it contain HQ or T3 or experimental='..tostring(M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryAllHQFactories + categories.TECH3 + categories.EXPERIMENTAL + M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryPower * categories.TECH2, iCategoryToBuild))) end
            if M28Utilities.DoesCategoryContainCategory(categories.TECH1  - M28UnitInfo.refCategoryAirStaging - M28UnitInfo.refCategoryT1Mex, iCategoryToBuild, true) and not(M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryAllHQFactories + categories.TECH3 + categories.EXPERIMENTAL + M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryPower * categories.TECH2, iCategoryToBuild)) then
                iCategoryToBuild = nil
            elseif aiBrain[M28Overseer.refiExpectedRemainingCap] < 15 then
                if not(M28Utilities.DoesCategoryContainCategory(categories.TECH3 + categories.EXPERIMENTAL + M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryPower * categories.TECH2, iCategoryToBuild)) then
                    iCategoryToBuild = nil
                end
            elseif (M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] or 0) <= 1 and aiBrain:GetCurrentUnits(iCategoryToBuild) >= 100 then
                if M28Utilities.DoesCategoryContainCategory(categories.TECH3 + categories.EXPERIMENTAL + M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryPower * categories.TECH2, iCategoryToBuild) and aiBrain:GetCurrentUnits(iCategoryToBuild) > 150 then
                    --Do nothing
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Have lots of the target category to build so wont build any more') end
                    iCategoryToBuild = nil
                end

            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is iCategoryToBuild nil after unit cap adjustment='..tostring(iCategoryToBuild == nil)) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iCategoryToBuild, iOptionalFactionRequired
end

function GetEngineersOfTechWanted(iMinTechLevelWanted, toAvailableEngineersByTech)
    local tEngineersOfTechWanted
    if iMinTechLevelWanted == 3 then
        tEngineersOfTechWanted = toAvailableEngineersByTech[3]
    else
        tEngineersOfTechWanted = {}
        if iMinTechLevelWanted == 2 then
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[2]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[2] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[3]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[3] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
        else
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[1]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[1] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[2]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[2] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[3]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[3] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
        end
    end
    return tEngineersOfTechWanted
end

function GetPartCompleteBuildingInZone(iTeam, iPlateauOrPond, iLandOrWaterZone, iCategoryWanted, bIsWaterZone, iConstructionCountToIgnore)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPartCompleteBuildingInZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iValidCount = 0

    if bDebugMessages == true then
        local tBlueprints = EntityCategoryGetUnitList(iCategoryWanted)
        LOG(sFunctionRef..': Start of code at game time seconds='..GetGameTimeSeconds()..', will list out every blueprint of iCategoryWanted='..reprs(tBlueprints)..'; iPlateauOrPond='..iPlateauOrPond)
    end
    local tLZOrWZTeamData
    local sAlliedUnitRef
    if bIsWaterZone then
        tLZOrWZTeamData = M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
        sAlliedUnitRef = M28Map.subreftoLZOrWZAlliedUnits
    else
        tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
        sAlliedUnitRef = M28Map.subreftoLZOrWZAlliedUnits
    end
    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[sAlliedUnitRef]) == false then
        local tBuildingsOfCategory = EntityCategoryFilterDown(iCategoryWanted, tLZOrWZTeamData[sAlliedUnitRef])
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of buildings of category empty='..tostring(M28Utilities.IsTableEmpty(tBuildingsOfCategory))) end
        if M28Utilities.IsTableEmpty(tBuildingsOfCategory) == false then
            for iUnit, oUnit in tBuildingsOfCategory do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fractino compelte='..oUnit:GetFractionComplete()..'; oUnit[refbDontIncludeAsPartCompleteBuildingForConstruction]='..tostring(oUnit[refbDontIncludeAsPartCompleteBuildingForConstruction] or false)) end
                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() < 1 and not(oUnit[M28Building.refoGameEnderBeingShielded]) and not(oUnit[refbDontIncludeAsPartCompleteBuildingForConstruction]) then
                    --If upgrading a factory then assist this unless we have high mass and dont have low power
                    if not(oUnit:IsUnitState('BeingUpgraded')) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.2 or M28Conditions.HaveLowPower(iTeam) or (table.getn(tBuildingsOfCategory) >= 4 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 or iCategoryWanted == M28UnitInfo.refCategoryLandFactory)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Found a part complete building '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()..', will return this') end
                        if (iConstructionCountToIgnore or 0) <= iValidCount then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return oUnit
                        else
                            iValidCount = iValidCount + 1
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return nil
end

function RemoveBuildingFromQueuedBuildings(oEngineer, oBuilding)
    --Intended to be called when oEngineer starts building oBuilding
    if M28Utilities.IsTableEmpty(oEngineer[reftQueuedBuildings]) == false then
        for iEntry, tOrderDetails in oEngineer[reftQueuedBuildings] do
            if tOrderDetails[subrefBuildingID] == oBuilding.UnitId and math.abs(oBuilding:GetPosition()[1] - tOrderDetails[subrefBuildingLocation][1]) < 0.5 and math.abs(oBuilding:GetPosition()[3] - tOrderDetails[subrefBuildingLocation][3]) < 0.5 then
                local tLZOrWZTeamData, tLZOrWZData
                if tOrderDetails[subrefPlateauOrZero] == 0 then
                    tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[tOrderDetails[subrefLandOrWaterZone]]][M28Map.subrefPondWaterZones][tOrderDetails[subrefLandOrWaterZone]]
                    tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][oEngineer:GetAIBrain().M28Team]
                else
                    --Dealing with land zone
                    tLZOrWZData = M28Map.tAllPlateaus[tOrderDetails[subrefPlateauOrZero]][M28Map.subrefPlateauLandZones][tOrderDetails[subrefLandOrWaterZone]]
                    tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
                end
                ChangeQueuedLocationsTracker(tOrderDetails[subrefBuildingLocation], tLZOrWZData, tOrderDetails[subrefBuildingRadius], false)
                if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefQueuedBuildings]) == false then
                    for iLZEntry, tLZOrWZOrderDetails in tLZOrWZTeamData[M28Map.subrefQueuedBuildings] do
                        if tLZOrWZOrderDetails[M28Map.subrefQueueRef] == tOrderDetails[subrefQueueRef] then
                            table.remove(tLZOrWZTeamData[M28Map.subrefQueuedBuildings], iLZEntry)
                            break
                        end
                    end
                end

                table.remove(oEngineer[reftQueuedBuildings], iEntry)
                break
            end

        end
    end
end

function RefreshPartBuiltMexList(tLZOrWZTeamData)
    local iRevisedIndex = 1
    local iTableSize = table.getn(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes])

    for iOrigIndex=1, iTableSize do
        if M28UnitInfo.IsUnitValid(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes][iOrigIndex]) and tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes][iOrigIndex]:GetFractionComplete() < 1 then
            --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
            if (iOrigIndex ~= iRevisedIndex) then
                tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes][iRevisedIndex] = tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes][iOrigIndex];
                tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes][iOrigIndex] = nil;
            end
            iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
        else
            tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes][iOrigIndex] = nil;
        end
    end
end

function UpdatePartBuiltListForCompletedMex(oMex)
    if oMex:GetAIBrain().M28AI and oMex:GetFractionComplete() == 1 then
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oMex:GetPosition())
        if iLandZone > 0 then
            RefreshPartBuiltMexList(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oMex:GetAIBrain().M28Team])
        end

    end
end


function RecordPartBuiltMex(oEngineer, oMex)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordPartBuiltMex'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oMex:GetPosition())
    local iWaterZone, iPond
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just started building oMex='..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
    if (iLandZone or 0) == 0 then
        iWaterZone = M28Map.GetWaterZoneFromPosition(oMex:GetPosition())
        iPond = M28Map.tiPondByWaterZone[iWaterZone]
    end
    if iLandZone > 0 or (iWaterZone > 0 and iPond > 0) then
        if oMex:GetAIBrain().M28AI then
            local tLZOrWZTeamData
            if iLandZone > 0 then tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oMex:GetAIBrain().M28Team]
            else tLZOrWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][oMex:GetAIBrain().M28Team]
            end
            if not(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes]) then tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes] = {} end
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes]) then
                if not(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes]) then tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes] = {} end
                table.insert(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes], oMex)
                if bDebugMessages == true then LOG(sFunctionRef..': Added the mex to the table of part built mexes') end
            else
                local bAlreadyInTable = false
                for iUnit, oUnit in tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes] do
                    if oUnit == oMex then bAlreadyInTable = true break end
                end
                if not(bAlreadyInTable) then
                    table.insert(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes], oMex)
                    if bDebugMessages == true then LOG(sFunctionRef..': Mex not already recorded so added to the table of part built mexes') end
                end
            end
        end

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function ClearEngineerTracking(oEngineer)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ClearEngineerTracking'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Unpause unit if it was paused (redundancy)
    if oEngineer[M28UnitInfo.refbPaused] then M28UnitInfo.PauseOrUnpauseMassUsage(oEngineer, false) end

    --Reset stuck count
    oEngineer[M28Conditions.refiEngineerStuckCheckCount] = 0

    oEngineer[refbPrimaryBuilder] = false
    oEngineer[refiAssignedActionPriority] = nil
    oEngineer[refiAssignedAction] = nil
    oEngineer[refbHasSpareAction] = nil

    --Update experimental construction tracking:
    if oEngineer[refbBuildingExperimental] then
        --As backup, also remove any dead engineers from this table
        local iRevisedIndex = 1
        local tArray = M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subreftTeamEngineersBuildingExperimentals]
        local iTableSize = table.getn(tArray)

        for iOrigIndex=1, iTableSize do
            if tArray[iOrigIndex] then
                if oEngineer ~= tArray[iOrigIndex] and M28UnitInfo.IsUnitValid(tArray[iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                    --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                    if (iOrigIndex ~= iRevisedIndex) then
                        tArray[iRevisedIndex] = tArray[iOrigIndex];
                        tArray[iOrigIndex] = nil;
                    end
                    iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                else
                    tArray[iOrigIndex] = nil;
                end
            end
        end

        oEngineer[refbBuildingExperimental] = nil
    end

    --Update details of engineers moving to a plateau
    if oEngineer[M28Land.reftiPlateauAndLZToMoveTo] then
        local tTargetLZTeamData = M28Map.tAllPlateaus[oEngineer[M28Land.reftiPlateauAndLZToMoveTo][1]][M28Map.subrefPlateauLandZones][oEngineer[M28Land.reftiPlateauAndLZToMoveTo][2]][M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
        if tTargetLZTeamData and M28Utilities.IsTableEmpty(tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
            for iUnit, oUnit in tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere] do
                if oUnit == oEngineer then
                    table.remove(tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere][iUnit])
                    break
                end
            end
        end
    end
    oEngineer[M28Land.reftiPlateauAndLZToMoveTo] = nil

    --Clear reclaim assignment tracking
    if oEngineer[reftAssignedReclaimSegments] then
        if bDebugMessages == true then LOG(sFunctionRef..': Engineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; reftAssignedReclaimSegments='..repru(oEngineer[reftAssignedReclaimSegments])) end
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.tReclaimAreas[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]][M28Map.refReclaimSegmentMidpoint])
        if (iLandZone or 0) > 0 then
            local tEngiAssignedByReclaim = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team][M28Map.subrefReclaimAreaAssignmentsBySegment]
            if tEngiAssignedByReclaim and tEngiAssignedByReclaim[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]] then tEngiAssignedByReclaim[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]] = math.max(0, (tEngiAssignedByReclaim[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]] or 0) - 1) end
        elseif (iPlateau or 0) > 0 then
            local iWaterZone = M28Map.GetWaterZoneFromPosition(M28Map.tReclaimAreas[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]][M28Map.refReclaimSegmentMidpoint])
            if (iWaterZone or 0) > 0 then
                local tEngiAssignedByReclaim = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][oEngineer:GetAIBrain().M28Team][M28Map.subrefReclaimAreaAssignmentsBySegment]
                if tEngiAssignedByReclaim and tEngiAssignedByReclaim[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]] then tEngiAssignedByReclaim[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]] = math.max(0, (tEngiAssignedByReclaim[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]] or 0) - 1) end
            end
        end
        oEngineer[reftAssignedReclaimSegments] = nil
    end

    --Clear any queued building orders
    if M28Utilities.IsTableEmpty(oEngineer[reftQueuedBuildings]) == false then
        for iEntry, tOrderDetails in oEngineer[reftQueuedBuildings] do
            local tLZOrWZTeamData, tLZOrWZData
            if tOrderDetails[subrefPlateauOrZero] > 0 then
                tLZOrWZData = M28Map.tAllPlateaus[tOrderDetails[subrefPlateauOrZero]][M28Map.subrefPlateauLandZones][tOrderDetails[subrefLandOrWaterZone]]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
            else
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[tOrderDetails[subrefLandOrWaterZone]]][M28Map.subrefPondWaterZones][tOrderDetails[subrefLandOrWaterZone]]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][oEngineer:GetAIBrain().M28Team]
            end
            ChangeQueuedLocationsTracker(tOrderDetails[subrefBuildingLocation], tLZOrWZData, tOrderDetails[subrefBuildingRadius], false)

            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefQueuedBuildings]) == false then
                for iLZEntry, tLZOrderDetails in tLZOrWZTeamData[M28Map.subrefQueuedBuildings] do
                    if tLZOrderDetails[M28Map.subrefQueueRef] == tOrderDetails[subrefQueueRef] then
                        table.remove(tLZOrWZTeamData[M28Map.subrefQueuedBuildings], iLZEntry)
                        break
                    end
                end
            end
        end
    end
    oEngineer[reftQueuedBuildings] = nil

    --Clear assisting engineers
    if M28Utilities.IsTableEmpty(oEngineer[M28UnitInfo.reftoUnitsAssistingThis]) == false then
        local tEngineersToRemove = {}
        for iAssistingEngineer, oAssistingEngineer in oEngineer[M28UnitInfo.reftoUnitsAssistingThis] do
            if M28UnitInfo.IsUnitValid(oAssistingEngineer) then
                table.insert(tEngineersToRemove, oAssistingEngineer)
            end
        end
        for iAssistingEngineer, oAssistingEngineer in tEngineersToRemove do
            if not(oAssistingEngineer == oEngineer) and not(oEngineer['M28TempClearing']) then
                oEngineer['M28TempClearing'] = true
                M28Orders.IssueTrackedClearCommands(oAssistingEngineer)
                oEngineer['M28TempClearing'] = nil
            end
        end
        oEngineer[M28UnitInfo.reftoUnitsAssistingThis] = nil
    end

    --Clear special shield tracking
    if oEngineer[refoUnitActivelyShielding] then
        if M28UnitInfo.IsUnitValid(oEngineer[refoUnitActivelyShielding]) then
            if M28Utilities.IsTableEmpty(oEngineer[refoUnitActivelyShielding][reftEngineersActivelyShielding]) == false then
                for iRecordedEngi, oRecordedEngi in oEngineer[refoUnitActivelyShielding][reftEngineersActivelyShielding] do
                    if oRecordedEngi == oEngineer then
                        table.remove(oEngineer[refoUnitActivelyShielding][reftEngineersActivelyShielding], iRecordedEngi)
                        break
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(oEngineer[refoUnitActivelyShielding][reftEngineersActivelyShielding]) then
            oEngineer[refoUnitActivelyShielding][reftEngineersActivelyShielding] = nil
        end
        oEngineer[refoUnitActivelyShielding] = nil

    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TrackQueuedBuilding(oEngineer, sBuildingID, tBuildLocation)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TrackQueuedBuilding'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time='..GetGameTimeSeconds()..'; oEngineer='..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil')..'; sBuildingID='..(sBuildingID or 'nil')..'; tBuildLocation='..repru(tBuildLocation)..'; iCurQueueRefNumber='..iCurQueueRefNumber) end

    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tBuildLocation)

    if iPlateauOrZero > 0 then
        if (iLandOrWaterZone or 0) == 0 then
            iLandOrWaterZone = M28Map.GetWaterZoneFromPosition(tBuildLocation)
            iPlateauOrZero = 0
        end
        if iLandOrWaterZone > 0 then
            iCurQueueRefNumber = iCurQueueRefNumber + 1
            if not(oEngineer[reftQueuedBuildings]) then oEngineer[reftQueuedBuildings] = {} end
            if bDebugMessages == true then LOG(sFunctionRef..': About to get building size='..(M28UnitInfo.GetBuildingSize(sBuildingID) or 'nil')) end
            local iBuildingRadius = math.floor(M28UnitInfo.GetBuildingSize(sBuildingID) * 0.5)
            table.insert(oEngineer[reftQueuedBuildings], {[subrefQueueRef] = iCurQueueRefNumber, [subrefBuildingID] = sBuildingID, [subrefBuildingLocation] = tBuildLocation, [subrefBuildingRadius] = iBuildingRadius, [subrefPlateauOrZero] = iPlateauOrZero, [subrefLandOrWaterZone] = iLandOrWaterZone})
            local tLZOrWZTeamData, tLZOrWZData
            if iPlateauOrZero > 0 then
                tLZOrWZData  = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
            else
                --Water zone
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][oEngineer:GetAIBrain().M28Team]
            end

            if iPlateauOrZero == 0 then

                tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][oEngineer:GetAIBrain().M28Team]
            else
                tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
            end
            if not(tLZOrWZTeamData[M28Map.subrefQueuedBuildings]) then tLZOrWZTeamData[M28Map.subrefQueuedBuildings] = {} end
            table.insert(tLZOrWZTeamData[M28Map.subrefQueuedBuildings], {[M28Map.subrefQueueRef] = iCurQueueRefNumber, [M28Map.subrefBuildingID] = sBuildingID, [M28Map.subrefBuildingLocation] = tBuildLocation, [M28Map.subrefBuildingRadius] = iBuildingRadius, [M28Map.subrefPrimaryBuilder] = oEngineer})
            --Record the locations as being queued
            ChangeQueuedLocationsTracker(tBuildLocation, tLZOrWZData, iBuildingRadius, true)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ChangeQueuedLocationsTracker(tBuildLocation, tLZOrWZData, iBuildingRadius, bAddToQueue)
    local iBaseX = math.floor(tBuildLocation[1])
    local iBaseZ = math.floor(tBuildLocation[3])
    for iX = iBaseX - iBuildingRadius, iBaseX + iBuildingRadius, 1 do
        if bAddToQueue then
            if not(tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX]) then
                if not(tLZOrWZData[M28Map.subrefQueuedLocationsByPosition]) then tLZOrWZData[M28Map.subrefQueuedLocationsByPosition] = {} end
                tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX] = {}
            end
            for iZ = iBaseZ - iBuildingRadius, iBaseZ + iBuildingRadius do
                tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX][iZ] = true
            end
        else
            if tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX] then
                for iZ = iBaseZ - iBuildingRadius, iBaseZ + iBuildingRadius do
                    tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX][iZ] = nil
                end
            end
        end
    end
end

function TrackEngineerAction(oEngineer, iActionToAssign, bIsPrimaryBuilder, iCurPriority, tOptionalPlatAndLandToMoveTo, vOptionalOtherVariable, bMarkAsSpare)
    --bIsPrimaryBuilder - true if engineer will be building the item in question (so false if assisting an engineer or repairing a building or assisting an upgrade or moving somewhere etc.
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TrackEngineerAction'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Special logic (done in a genric way in case end up with more scenarios like this) - if action to assign currnetly is special shield logic and we have a different action to assign then clear engineer tracking (as we have an override that prevents it being cleared via orders)
    if oEngineer[refiAssignedAction] and not(oEngineer[refiAssignedAction] == iActionToAssign) then ClearEngineerTracking(oEngineer) end

    oEngineer[refiAssignedAction] = iActionToAssign
    oEngineer[refbPrimaryBuilder] = (bIsPrimaryBuilder or false)
    oEngineer[refiAssignedActionPriority] = iCurPriority
    oEngineer[refbHasSpareAction] = bMarkAsSpare

    --Track experimental construction
    if iActionToAssign == refActionBuildExperimental or iActionToAssign == refActionBuildSecondExperimental or iActionToAssign == refActionBuildGameEnder or iActionToAssign == refActionBuildExperimentalNavy or iActionToAssign == refActionBuildLandExperimental then
        table.insert(M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subreftTeamEngineersBuildingExperimentals], oEngineer)
        oEngineer[refbBuildingExperimental] = true
    else
        oEngineer[refbBuildingExperimental] = nil
    end

    --Track info e.g. for units moving to other plateaus
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
    local tTargetLZTeamData
    if tOptionalPlatAndLandToMoveTo then
        oEngineer[M28Land.reftiPlateauAndLZToMoveTo] = {tOptionalPlatAndLandToMoveTo[1], tOptionalPlatAndLandToMoveTo[2]}
        tTargetLZTeamData = M28Map.tAllPlateaus[tOptionalPlatAndLandToMoveTo[1]][M28Map.subrefPlateauLandZones][tOptionalPlatAndLandToMoveTo[2]][M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
    end
    if vOptionalOtherVariable then
        if iActionToAssign == refActionReclaimArea then
            oEngineer[reftAssignedReclaimSegments] = vOptionalOtherVariable
        elseif iActionToAssign == refActionRunToWaterZone or iActionToAssign == refActionMoveToWaterZone then
            if bDebugMessages == true then LOG(sFunctionRef..': Engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' wants to move to water zone '..vOptionalOtherVariable..'; iCurPriority='..(iCurPriority or 'nil')) end
            oEngineer[M28Land.reftiPlateauAndLZToMoveTo] = nil
            oEngineer[M28Navy.refiWZToMoveTo] = vOptionalOtherVariable
            local iPond = M28Map.tiPondByWaterZone[vOptionalOtherVariable]
            tTargetLZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][vOptionalOtherVariable][M28Map.subrefWZTeamData][oEngineer:GetAIBrain().M28Team]
        else M28Utilities.ErrorHandler('vOptionalOtherVariable is specified but dont know what for, iActionToAssign='..iActionToAssign)
        end
    end

    --Track if we are moving to a land or water zone
    if tTargetLZTeamData then
        if not(tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere]) then tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere] = {} end
        table.insert(tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere], oEngineer)
        --Reduce BP wanted by the LZ, and no longer flag it as wanting BP if this satisfies all its needs
        local iEngiTechLevel = M28UnitInfo.GetUnitTechLevel(oEngineer)
        for iTech = iEngiTechLevel, 1, -1 do
            if tTargetLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                tTargetLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] = tTargetLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] - oEngineer:GetBlueprint().Economy.BuildRate
                local bNoLongerWantBP = false
                if tTargetLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] <= 0 then
                    bNoLongerWantBP = true
                    for iAltTech = iTech, 1, -1 do
                        if tTargetLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iAltTech] > 0 then
                            bNoLongerWantBP = false
                            break
                        end
                    end
                end
                if bNoLongerWantBP then
                    tTargetLZTeamData[M28Map.subrefTbWantBP] = false
                end
                break
            end
        end
    end

    --Track potential blacklist locations for primary engineers - note that more general queued building construction tracking is done via TrackQueuedBuilding based on when an order is given to construct something
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to track engineer for blacklisted locations, Time='..GetGameTimeSeconds()..'; Engineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; bIsPrimaryBuilder='..tostring(bIsPrimaryBuilder or false)..'; oEngineer[M28Orders.refiOrderCount]='..(oEngineer[M28Orders.refiOrderCount] or 'nil')..'; Last order type='..(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] or 'nil')) end
    if bIsPrimaryBuilder and not(tbActionsThatDontHaveCategory[iActionToAssign]) and oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild then
        ForkThread(MonitorEngineerForBlacklistLocation, oEngineer)
    end

    --Unpause engineer
    if oEngineer[M28UnitInfo.refbPaused] then
        M28UnitInfo.PauseOrUnpauseEnergyUsage(oEngineer, false)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' action='..(oEngineer[refiAssignedAction] or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function HaveSameTargetAndNotStartedBuilding(oEngineer, iOrigAction, iOrigQueueRef, sOrigBlueprint, tOrigBuildLocation)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'HaveSameTargetAndNotStartedBuilding'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if bDebugMessages == true then
        if M28UnitInfo.IsUnitValid(oEngineer) then
            LOG(sFunctionRef..': time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..': Engineer is valid, refbPrimaryBuilder='..tostring(oEngineer[refbPrimaryBuilder])..'; Assigned action='..(oEngineer[refiAssignedAction] or 'nil')..'; Engineer unit state='..M28UnitInfo.GetUnitState(oEngineer)..'; Qued buildings queue ref='..(oEngineer[reftQueuedBuildings][1][subrefQueueRef] or 'nil')..'; Last order blueprint='..(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] or 'nil')..'; Last order position='..repru(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition] or {'nil'}))
        else
            LOG(sFunctionRef..': Engineer is no longer valid')
        end
    end
    if M28UnitInfo.IsUnitValid(oEngineer) and oEngineer[refbPrimaryBuilder] and oEngineer[refiAssignedAction] == iOrigAction and not(oEngineer:IsUnitState('Building')) and not(oEngineer:IsUnitState('Repairing')) and oEngineer[reftQueuedBuildings][1][subrefQueueRef] == iOrigQueueRef and sOrigBlueprint == oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] then --and oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition] and M28Utilities.GetDistanceBetweenPositions(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition], tOrigBuildLocation) <= 1 then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    else
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false
    end
end

function ClearBlacklistForUnitConstructed(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ClearBlacklistForUnitConstructed'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is table of blacklists empty='..tostring(M28Utilities.IsTableEmpty(oUnit[reftUnitBlacklistSegmentXZ]))) end
    if M28Utilities.IsTableEmpty(oUnit[reftUnitBlacklistSegmentXZ]) == false then
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
        if iPlateauOrZero and (iLandOrWaterZone or 0) > 0 then
            local tLZOrWZData
            if iPlateauOrZero == 0 then
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
            else
                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
            end
            for iEntry, tiSegmentXZ in oUnit[reftUnitBlacklistSegmentXZ] do
                if tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][tiSegmentXZ[1]][tiSegmentXZ[2]] then tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][tiSegmentXZ[1]][tiSegmentXZ[2]] = nil end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished clearing the blacklisted locations, iPlateau='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; repru of blacklisted locations for zone='..repru(tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition])) end
        end
    end
    oUnit[reftUnitBlacklistSegmentXZ] = nil
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedBlacklistReset(tLZOrWZData, iX, iZ, iResetTimeInSeconds, oOptionalUnitToTrack)
    WaitSeconds(iResetTimeInSeconds)
    if not(oOptionalUnitToTrack) or not(M28UnitInfo.IsUnitValid(oOptionalUnitToTrack)) then
        tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][iX][iZ] = nil
    end
end

function RecordBlacklistLocation(tLocation, iRadius, iResetTimeInSeconds, oOptionalUnitToTrack)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordBlacklistLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --oOptionalUnitToTrack - i.e. should have experimental units under construction specified here - if specified, means iresettimeinseconds only triggers if that unit doesnt exist, as a redundancy for if we failed to pickup the event when it died
    --iResetTimeInSeconds - per above, if  oOptionalUnitToTrack is specififed then this only triggers if hte unit no longer exists after waiting iResetTimeInSeconds

    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tLocation)
    if bDebugMessages == true then LOG(sFunctionRef..': Gametimeseconds='..GetGameTimeSeconds()..'; tLocation='..repru(tLocation)..'; iRadius='..(iRadius or 'nil')..'; iResetTimeInSeconds='..(iResetTimeInSeconds or 'nil')..'; oOptionalUnitToTrack='..(oOptionalUnitToTrack.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oOptionalUnitToTrack) or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')) end
    if (iLandOrWaterZone or 0) > 0 then
        local tLZOrWZData
        if iPlateauOrZero == 0 then
            tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        else
            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        end
        if oOptionalUnitToTrack then
            oOptionalUnitToTrack[reftUnitBlacklistSegmentXZ] = {}
        end


        local iBaseX = math.floor(tLocation[1])
        local iBaseZ = math.floor(tLocation[3])
        local iSegmentRadius = math.floor(iRadius / M28Map.iLandZoneSegmentSize)
        if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through every position for iSegmentRadius='..iSegmentRadius..'; iBaseX='..iBaseX..'; iBaseZ='..iBaseZ) end
        for iX = iBaseX - iSegmentRadius, iBaseX + iSegmentRadius do
            for iZ = iBaseZ - iSegmentRadius, iBaseZ + iSegmentRadius do
                if not(tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][iX][iZ]) then
                    if not(tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][iX]) then
                        if not(tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition]) then tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition] = {} end
                        tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][iX] = {}
                    end
                    tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][iX][iZ] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Added blacklist to location iX='..iX..'; iZ='..iZ..'; iResetTimeInSeconds='..(iResetTimeInSeconds or 'nil')) end
                    if (iResetTimeInSeconds or 0) >= 0 then
                        ForkThread(DelayedBlacklistReset, tLZOrWZData, iX, iZ, iResetTimeInSeconds, oOptionalUnitToTrack)
                    end
                    if oOptionalUnitToTrack then
                        table.insert(oOptionalUnitToTrack[reftUnitBlacklistSegmentXZ], {iX, iZ})
                        if bDebugMessages == true then LOG(sFunctionRef..': Added blacklist location for oOptionalUnitToTrack='..oOptionalUnitToTrack.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOptionalUnitToTrack)..'; X'..iX..'Z'..iZ) end
                    end
                else
                    --Already reocrded as a blacklist so wont rerecord/add a new reset to it
                end
            end
        end
        if bDebugMessages == true then
            LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Added location to the blacklist, tLocation='..repru(tLocation)..'; iRadius='..(iRadius or 0)..'; iResetTimeInSeconds='..(iResetTimeInSeconds or 'nil')..'; repru of blacklist locations='..repru(tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition])..'; will draw all blacklisted locations for this LZ')
            DrawBlacklistedLocations(tLZOrWZData)
        end

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MonitorEngineerForBlacklistLocation(oEngineer)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MonitorEngineerForBlacklistLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local sOrigBlueprint = oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint]
    --Only consider engineers with a single queued up building
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; sOrigBlueprint='..(sOrigBlueprint or 'nil')..'; Is table of queued buildings empty='..tostring(M28Utilities.IsTableEmpty(oEngineer[reftQueuedBuildings]))..'; Size of queued buildings table='..table.getn(oEngineer[reftQueuedBuildings] or {})) end
    if sOrigBlueprint and M28Utilities.IsTableEmpty(oEngineer[reftQueuedBuildings]) == false and table.getn(oEngineer[reftQueuedBuildings]) == 1 then
        --Ignore for mexes and hydrocarbons
        if not(EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryHydro, sOrigBlueprint)) then
            local iOrigQueueRef = oEngineer[reftQueuedBuildings][1][subrefQueueRef]
            local sTrackerRef = 'M28Q'..iOrigQueueRef
            if not(oEngineer[sTrackerRef]) then
                oEngineer[sTrackerRef] = true
                local tOrigBuildLocation = {oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition][1], oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition][2], oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition][3]}
                local bCloseToTarget = false
                local iOrigAction = oEngineer[refiAssignedAction]
                local iWaitCount = 0
                local iOrigTime = GetGameTimeSeconds()

                --[[function HaveSameTargetAndNotStartedBuilding()
                if bDebugMessages == true then
                    if M28UnitInfo.IsUnitValid(oEngineer) then
                    --]]
                --LOG('HaveSameTargetAndNotStartedBuilding: time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..': Engineer is valid, refbPrimaryBuilder='..tostring(oEngineer[refbPrimaryBuilder])..'; Assigned action='..(oEngineer[refiAssignedAction] or 'nil')..'; Engineer unit state='..M28UnitInfo.GetUnitState(oEngineer)..'; Qued buildings queue ref='..(oEngineer[reftQueuedBuildings][1][subrefQueueRef] or 'nil')..'; Last order blueprint='..(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] or 'nil')..'; Last order position='..repru(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition] or {'nil'}))
                --[[else
                LOG('HaveSameTargetAndNotStartedBuilding: Engineer is no longer valid')
            end
        end--]]
                --if M28UnitInfo.IsUnitValid(oEngineer) and oEngineer[refbPrimaryBuilder] and oEngineer[refiAssignedAction] == iOrigAction and not(oEngineer:IsUnitState('Building')) and not(oEngineer:IsUnitState('Repairing')) and oEngineer[reftQueuedBuildings][1][subrefQueueRef] == iOrigQueueRef and sOrigBlueprint == oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] and oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition] and M28Utilities.GetDistanceBetweenPositions(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition], tOrigBuildLocation) <= 1 then
                --[[return true
        else
            return false
        end
    end--]]
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitSeconds(10)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if bDebugMessages == true then LOG(sFunctionRef..': time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..': Finished first wait, HaveSameTargetAndNotStartedBuilding='..tostring(HaveSameTargetAndNotStartedBuilding(oEngineer, iOrigAction, iOrigQueueRef, sOrigBlueprint, tOrigBuildLocation))..'; iOrigQueueRef='..repru(iOrigQueueRef or 'nil')..'; tOrigBuildLocation='..repru(tOrigBuildLocation)..'; iOrigAction='..repru(iOrigAction or 'nil')) end

                while HaveSameTargetAndNotStartedBuilding(oEngineer, iOrigAction, iOrigQueueRef, sOrigBlueprint, tOrigBuildLocation) and not(bCloseToTarget) do
                    if bDebugMessages == true then LOG(sFunctionRef..': time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..': bCloseToTarget='..tostring(bCloseToTarget)..'; Dist between engineer pos and orig build location='..M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), tOrigBuildLocation)) end
                    if M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), tOrigBuildLocation) <= 12 then bCloseToTarget = true break
                    else
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitSeconds(10)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        iWaitCount = iWaitCount + 1
                        if iWaitCount >= 20 then break end
                    end
                end
                if bCloseToTarget then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitSeconds(45)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished another wait and are close to target, time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; HaveSameTargetAndNotStartedBuilding()='..tostring(HaveSameTargetAndNotStartedBuilding(oEngineer, iOrigAction, iOrigQueueRef, sOrigBlueprint, tOrigBuildLocation))) end
                    if HaveSameTargetAndNotStartedBuilding(oEngineer, iOrigAction, iOrigQueueRef, sOrigBlueprint, tOrigBuildLocation) then
                        --If there are no mobile units then wait another 30s
                        local bAddToBlacklist = true
                        local iRadius = M28UnitInfo.GetBuildingSize(sOrigBlueprint) * 0.5
                        local rNearbyRect = M28Utilities.GetRectAroundLocation(tOrigBuildLocation, iRadius)
                        local tUnitsInRect = GetUnitsInRect(rNearbyRect)
                        if M28Utilities.IsTableEmpty(tUnitsInRect) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.MOBILE * categories.LAND, tUnitsInRect)) then
                            bAddToBlacklist = false
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitSeconds(30)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                            if HaveSameTargetAndNotStartedBuilding(oEngineer, iOrigAction, iOrigQueueRef, sOrigBlueprint, tOrigBuildLocation) then
                                bAddToBlacklist = true
                            end
                        end
                        if bAddToBlacklist then

                            --Add location to blacklist
                            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tOrigBuildLocation)
                            if bDebugMessages == true then LOG(sFunctionRef..': time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..': Want to add to blacklist, iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; sOrigBlueprint='..sOrigBlueprint) end
                            if iPlateau and iLandZone then
                                RecordBlacklistLocation(tOrigBuildLocation, 1, 480) --i.e. reset after 8 minutes

                                --Prev approach below:
                                --table.insert(tLZData[M28Map.subrefBuildLocationBlacklist], {[M28Map.subrefBlacklistLocation] = tOrigBuildLocation, [M28Map.subrefBlacklistSize] = iRadius, [M28Map.subrefBlacklistType] = M28Map.BlacklistTimeout})

                                --Update existing build locations to remove if they are near here
                                CheckIfBuildableLocationsNearPositionStillValid(oEngineer:GetAIBrain(), tOrigBuildLocation, true, M28UnitInfo.GetBuildingSize(sOrigBlueprint) * 0.5)

                                --Clear this engineer and any assisting engineers (assisting engineers are cleared via ClearEngineerTracking)
                                M28Orders.IssueTrackedClearCommands(oEngineer)
                            end
                        end
                    end
                end
            end
            oEngineer[sTrackerRef] = nil
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetEngineerToReclaimNearbyArea(oEngineer, iPriorityOverride, tLZOrWZTeamData, iPlateauOrPond, iLandOrWaterZone, bWantEnergyNotMass, bOnlyConsiderReclaimInRangeOfEngineer, iMinIndividualValueOverride, bIsWaterZone)
    --Gets engineer to find the nearest unassigned reclaim segment in the land zone that has mass/energy, to move to the middle of it, and reclaim it
    --Factors in how much mass is in the segment and how many engineers have been assigned already and adjusts the chosen segment accordingly
    --bOnlyConsiderReclaimInRangeOfEngineer - if true then will use oEngineer position instead of the midpoint of the reclaim segment that want to target
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetEngineerToReclaimNearbyArea'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iCurPriority = (iPriorityOverride or oEngineer[refiAssignedActionPriority] or 1)
    local tLZOrWZData
    if bIsWaterZone then tLZOrWZData = M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iLandOrWaterZone]
    else tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; iPlateauOrPond='..iPlateauOrPond..'; iLandOrWaterZone='..iLandOrWaterZone..'; bWantEnergyNotMass='..tostring(bWantEnergyNotMass or false)..'; bOnlyConsiderReclaimInRangeOfEngineer='..tostring(bOnlyConsiderReclaimInRangeOfEngineer or false)..'; iMinIndividualValueOverride='..(iMinIndividualValueOverride or 'nil')..'; bIsWaterZone='..tostring(bIsWaterZone or false)..'; Total mass in zone='..tLZOrWZData[M28Map.subrefTotalMassReclaim]..'; Total significant mass='..tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim]) end
    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefReclaimSegments]) == false then
        local iClosestSegmentDist = 100000
        local tiClosestSegmentXZ
        local iCurModDist
        local sTotalReclaimValueRef
        local iReclaimValuePerEngi
        local bGivenOrder = false
        local oNearestReclaim

        local iMinSignifSegmentValue = 0
        local bDontCheckSignificantValue = true
        local bReduceModDistIfSignificantMass = false
        if not(bOnlyConsiderReclaimInRangeOfEngineer) and not(bWantEnergyNotMass) then
            if tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim] >= 500 then
                iMinSignifSegmentValue = M28Map.iSignificantMassThreshold --10 (as of v43)
                bDontCheckSignificantValue = false
            elseif tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim] > 0 then
                bReduceModDistIfSignificantMass = true
            end
        end

        local iMinReclaimIndividualValue = (iMinIndividualValueOverride or 1)


        if bWantEnergyNotMass then
            sTotalReclaimValueRef = M28Map.subrefLZTotalEnergyReclaim
            iReclaimValuePerEngi = 300
        else
            sTotalReclaimValueRef = M28Map.subrefTotalMassReclaim
            iReclaimValuePerEngi = 200
        end

        local oEngBP = oEngineer:GetBlueprint()
        --if oEngBP.Economy.MaxBuildDistance >= 10 then iSegmentSearchSize = math.max(1, math.ceil((oEngBP.Economy.MaxBuildDistance + 2) / math.min(M28Map.iReclaimSegmentSizeX, M28Map.iReclaimSegmentSizeZ))) end
        --local iMoveSpeed = oEngBP.Physics.MaxSpeed
        local iMaxDistanceToEngineer = oEngBP.Economy.MaxBuildDistance + math.min(oEngBP.SizeX, oEngBP.SizeZ) * 0.5 - 0.1
        local bCheckTerrain = false
        if iMaxDistanceToEngineer < math.min(M28Map.iReclaimSegmentSizeX, M28Map.iReclaimSegmentSizeZ) then bCheckTerrain = true end
        local sReclaimTableRef
        if bWantEnergyNotMass then sReclaimTableRef = M28Map.refSegmentReclaimTotalEnergy
        else sReclaimTableRef = M28Map.refReclaimHighestIndividualMassReclaim --M28Map.refReclaimTotalMass
        end

        local bDontConsiderPlayableArea = not(M28Map.bIsCampaignMap)

        if not(bOnlyConsiderReclaimInRangeOfEngineer) then
            for iSegmentCount, tSegmentXZ in tLZOrWZData[M28Map.subrefReclaimSegments] do
                if M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][sReclaimTableRef] >= iMinReclaimIndividualValue and (bDontCheckSignificantValue or M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][M28Map.refReclaimTotalSignificantMass] >= iMinSignifSegmentValue) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering reclaim location at position '..repru(M28Map.GetReclaimLocationFromSegment(tSegmentXZ[1], tSegmentXZ[2]))..'; plyaable area='..repru(M28Map.rMapPlayableArea)..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(M28Map.GetReclaimLocationFromSegment(tSegmentXZ[1], tSegmentXZ[2])))..'; bDontConsiderPlayableArea='..tostring(bDontConsiderPlayableArea)..'; Mass reclaim in segment='..(M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][M28Map.refReclaimTotalMass] or 'nil')..'; Signif mass in segment='..(M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][M28Map.refReclaimTotalSignificantMass] or 'nil')) end
                    if bDontConsiderPlayableArea or M28Conditions.IsLocationInPlayableArea(M28Map.GetReclaimLocationFromSegment(tSegmentXZ[1], tSegmentXZ[2])) then
                        iCurModDist = M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), M28Map.GetReclaimLocationFromSegment(tSegmentXZ[1], tSegmentXZ[2]))
                        if iCurModDist > iMaxDistanceToEngineer then
                            if tLZOrWZTeamData[M28Map.subrefReclaimAreaAssignmentsBySegment][tSegmentXZ[1]] and tLZOrWZTeamData[M28Map.subrefReclaimAreaAssignmentsBySegment][tSegmentXZ[1]][tSegmentXZ[2]] and tLZOrWZData[sTotalReclaimValueRef] < (iReclaimValuePerEngi * tLZOrWZTeamData[M28Map.subrefReclaimAreaAssignmentsBySegment][tSegmentXZ[1]][tSegmentXZ[2]]) then
                                iCurModDist = iCurModDist + 60 * tLZOrWZTeamData[M28Map.subrefReclaimAreaAssignmentsBySegment][tSegmentXZ[1]][tSegmentXZ[2]] * iReclaimValuePerEngi / math.max(5, tLZOrWZData[sTotalReclaimValueRef]) --Low priority area
                            end
                        end
                        if bReduceModDistIfSignificantMass and M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][M28Map.refReclaimTotalSignificantMass] > 0 then iCurModDist = iCurModDist * 0.5 end --Prioritise locations with significant reclaim over those without

                        if iCurModDist < iClosestSegmentDist then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have a new closest dist='..iCurModDist..'; SegmentXZ='..repru(tSegmentXZ)) end
                            iClosestSegmentDist = iCurModDist
                            tiClosestSegmentXZ = {tSegmentXZ[1], tSegmentXZ[2]}
                        end
                    end
                end
            end
        end

        if tiClosestSegmentXZ or bOnlyConsiderReclaimInRangeOfEngineer then
            --Get reclaim in the segment
            local tTargetPos
            if bOnlyConsiderReclaimInRangeOfEngineer then
                tTargetPos = oEngineer:GetPosition()
            else tTargetPos = M28Map.GetReclaimLocationFromSegment(tiClosestSegmentXZ[1], tiClosestSegmentXZ[2])
            end

            local iCurDistToTargetPos
            if bDebugMessages == true then
                if bOnlyConsiderReclaimInRangeOfEngineer then LOG(sFunctionRef..': Only considering reclaim around the engineer position rather than the wider land zone')
                else
                    LOG(sFunctionRef..': Considering all reclaim in the land zone, Eng build distance='..oEngBP.Economy.MaxBuildDistance..'; SizeX='..oEngBP.SizeX..'; Eng SizeZ='..oEngBP.SizeZ..'; tiClosestSegmentXZ='..repru(tiClosestSegmentXZ)..'; Mass/energy reclaim in this segment (depending on which we are searching for)='..M28Map.tReclaimAreas[tiClosestSegmentXZ[1]][tiClosestSegmentXZ[2]][sReclaimTableRef]..'; searching for energy not mass='..tostring(bWantEnergyNotMass))
                end
            end

            --GetReclaimInRectangle(iReturnType, rRectangleToSearch)
            --    --iReturnType: 1 = true/false; 2 = number of wrecks; 3 = total mass, 4 = valid wrecks
            local rReclaimRectangle
            if bOnlyConsiderReclaimInRangeOfEngineer then rReclaimRectangle = M28Utilities.GetRectAroundLocation(tTargetPos, math.max(M28Map.iReclaimSegmentSizeX * 0.5, iMaxDistanceToEngineer, M28Map.iReclaimSegmentSizeZ * 0.5))
            else rReclaimRectangle = M28Map.GetReclaimSegmentRectangle(tiClosestSegmentXZ[1], tiClosestSegmentXZ[2], iMaxDistanceToEngineer)
            end
            local tNearbyReclaim = M28Map.GetReclaimInRectangle(4, rReclaimRectangle)
            if bDebugMessages == true then
                local iTargetPosPlateau, iTargetPosLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetPos)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering for iPlateauOrPond='..(iPlateauOrPond or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Engineer='..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil')..'; iMaxDistanceToEngineer='..(iMaxDistanceToEngineer or 'nil')..'; oEngBP.Economy.MaxBuildDistance='..(oEngBP.Economy.MaxBuildDistance or 'nil')..'; tiClosestSegmentXZ='..repru(tiClosestSegmentXZ)..'; Is tNearbyReclaim empty='..tostring(M28Utilities.IsTableEmpty(tNearbyReclaim))..'; Total mass recorded against this reclaim segment='..(M28Map.tReclaimAreas[tiClosestSegmentXZ[1]][tiClosestSegmentXZ[2]][M28Map.refReclaimTotalMass] or 'nil')..'; tTargetPos='..repru(tTargetPos)..'; Eng pos='..repru(oEngineer:GetPosition())..'; Target Plateau and LZ='..(iTargetPosPlateau or 'nil')..'-'..(iTargetPosLZ or 0)..'; Reclaim segment='..repru(tiClosestSegmentXZ)..'; rReclaimRectangle='..repru(rReclaimRectangle)..'; M28Map.iReclaimSegmentSizeX='..(M28Map.iReclaimSegmentSizeX or 'nil')..'; iMaxDistanceToEngineer='..(iMaxDistanceToEngineer or 'nil')) end
                M28Utilities.DrawRectangle(rReclaimRectangle, 2, 20)
            end

            if M28Utilities.IsTableEmpty(tNearbyReclaim) == false then
                local iNearestReclaim = 10000
                local iNearestReclaimWithAnyValue = 10000
                local oNearestAnyValueReclaim
                local iReclaimRadius

                local iEngiTerrainLabel = NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oEngineer:GetPosition())

                for iReclaim, oReclaim in tNearbyReclaim do
                    --is this valid reclaim within our build area?
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': iReclaim='..iReclaim..'; oReclaim.MaxMassReclaim='..(oReclaim.MaxMassReclaim or 0))
                        if oReclaim.MaxMassReclaim >= 100 or (bWantEnergyNotMass and oReclaim.MaxEnergyReclaim >= 100) then
                            LOG('Large reclaim, repr of all values='..reprs(oReclaim))
                            if oReclaim.GetBlueprint then
                                LOG('oReclaim has a blueprint='..reprs(oReclaim:GetBlueprint()))
                            else LOG('oReclaim doesnt have .GetBlueprint')
                            end
                        end
                    end
                    if oReclaim.CachePosition and ((not(bWantEnergyNotMass) and oReclaim.MaxMassReclaim >= iMinReclaimIndividualValue) or (bWantEnergyNotMass and oReclaim.MaxEnergyReclaim >= iMinReclaimIndividualValue)) and not(oReclaim:BeenDestroyed()) then
                        iReclaimRadius = math.min(oReclaim:GetBlueprint().SizeX, oReclaim:GetBlueprint().SizeZ)*0.5
                        iCurDistToTargetPos = math.max(0, M28Utilities.GetDistanceBetweenPositions(tTargetPos, oReclaim.CachePosition) - iReclaimRadius)
                        --Can we path to it?
                        if iCurDistToTargetPos < iNearestReclaim and (not(bCheckTerrain) or (NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oReclaim.CachePosition) == iEngiTerrainLabel or (iCurDistToTargetPos <= 12 and M28Utilities.GetDistanceBetweenPositions(oReclaim.CachePosition, oEngineer:GetPosition()) <= iReclaimRadius + iMaxDistanceToEngineer))) then
                            iNearestReclaim = iCurDistToTargetPos
                            oNearestReclaim = oReclaim
                        end
                        --Backup e.g. if looking for energy reclaim but only have mass available
                        if not(oNearestReclaim) then
                            if iCurDistToTargetPos < iNearestReclaimWithAnyValue and (oReclaim.MaxMassReclaim or 0) + (oReclaim.MaxEnergyReclaim or 0) > 0 then
                                oNearestAnyValueReclaim = oReclaim
                                iNearestReclaimWithAnyValue = iCurDistToTargetPos
                            end
                        end
                    end
                end
                if not(oNearestReclaim) then
                    oNearestReclaim = oNearestAnyValueReclaim
                    --Check this is in the same zone
                    if oNearestReclaim and bCheckTerrain then
                        if not(NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oNearestReclaim.CachePosition) == NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oEngineer:GetPosition()) and M28Utilities.GetDistanceBetweenPositions(oNearestReclaim.CachePosition, oEngineer:GetPosition()) > iMaxDistanceToEngineer + math.min(oNearestReclaim:GetBlueprint().SizeX, oNearestReclaim:GetBlueprint().SizeZ)*0.5) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Ignoring reclaim as we cant path to it') end
                            oNearestReclaim = nil
                        end
                    end
                end

                if oNearestReclaim then
                    if oEngineer:IsUnitState('Capturing') then M28Utilities.ErrorHandler('Are aborting an engineer that was capturing and telling it to reclaim instead', true, true) end
                    bGivenOrder = true
                    M28Orders.IssueTrackedReclaim(oEngineer, oNearestReclaim, false, 'ReclLZSeg')
                    if bDebugMessages == true then LOG(sFunctionRef..': Will send order to get reclaim at position '..repru(oNearestReclaim.CachePosition)..'; will draw a box around here; oNearestReclaim ID='..(oNearestReclaim.UnitId or 'nil')..'; mass value='..(oNearestReclaim.MaxMassReclaim or 'nil')) M28Utilities.DrawLocation(oNearestReclaim.CachePosition) end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have any reclaim of sufficient value; iMinReclaimIndividualValue='..iMinReclaimIndividualValue) end
                end

            else
                if bDebugMessages == true then LOG(sFunctionRef..' No reclaim in nearby segments, will update the reclaim in this segment if engi isnt range restricted') end
                if not(bOnlyConsiderReclaimInRangeOfEngineer) and tiClosestSegmentXZ then
                    if bDebugMessages == true then LOG(sFunctionRef..': Total mass pre update='..M28Map.tReclaimAreas[tiClosestSegmentXZ[1]][tiClosestSegmentXZ[2]][M28Map.refReclaimTotalMass]) end
                    M28Map.UpdateReclaimDataNearSegments(tiClosestSegmentXZ[1], tiClosestSegmentXZ[2], 0)
                    if bDebugMessages == true then LOG(sFunctionRef..': Total mass post update='..M28Map.tReclaimAreas[tiClosestSegmentXZ[1]][tiClosestSegmentXZ[2]][M28Map.refReclaimTotalMass]) end
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': No segments in land zone with sufficient reclaim') end
        end
        if bGivenOrder and not(EntityCategoryContains(categories.COMMAND, oEngineer.UnitId)) then
            TrackEngineerAction(oEngineer, refActionReclaimArea, false, iCurPriority, nil, tiClosestSegmentXZ)
        elseif not(bGivenOrder) then
            --Flag that this zone has failed to find anything for engineers to reclaim, so we limit BP to assign to 5
            tLZOrWZData[M28Map.subrefiTimeFailedToGetReclaim] = GetGameTimeSeconds()
            --If there is a valid reclaim nearby (it just is too low value) then also give order to reclaim this
            if oNearestReclaim and not(oEngineer:IsUnitState('Capturing')) then
                M28Orders.IssueTrackedReclaim(oEngineer, oNearestReclaim, false, 'ReclBLZSeg')
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function FilterEngineersOfTechAndEngiCountForFaction(iOptionalFactionRequired, tEngineersOfTechWanted)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'FilterEngineersOfTechAndEngiCountForFaction'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tEngineersOfFactionAndTechWanted
    tEngineersOfFactionAndTechWanted = {}
    local iRevisedEngiCount = 0
    for iTechEngi, oTechEngi in tEngineersOfTechWanted do
        if M28UnitInfo.GetUnitFaction(oTechEngi) == iOptionalFactionRequired then
            table.insert(tEngineersOfFactionAndTechWanted, oTechEngi)
            iRevisedEngiCount = iRevisedEngiCount + 1
            if bDebugMessages == true then LOG(sFunctionRef..': oTechEngi='..oTechEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTechEngi)..' is the right faction so including in revised list, iRevisedEngiCount='..iRevisedEngiCount) end
        end
    end
    if iRevisedEngiCount == 0 then M28Utilities.ErrorHandler('After filtering to a faction we have no available engineers - this shouldnt be possible') end
    --Now replace original table os we dont have to update below references (do by returning these values now since have moved this logic to a function)
    if bDebugMessages == true then LOG(sFunctionRef..': Finished updating list, iRevisedEngiCount='..iRevisedEngiCount..'; Last engi in list='..(tEngineersOfTechWanted[iEngiCount].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount]) or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tEngineersOfFactionAndTechWanted, iRevisedEngiCount

end

function ActiveShieldMonitor(oUnitToProtect, tLZTeamData, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ActiveShieldMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if not(oUnitToProtect[refbActiveUnitShieldingThread]) then
        oUnitToProtect[refbActiveUnitShieldingThread] = true
        local iShieldCategoryToBuild
        local iOptionalFactionRequired
        local iEngineerFactionRequired = M28UnitInfo.refCategoryEngineer
        local iTimeOfLastBlockingBuildingCheck
        local iPreviousAction
        local refiShieldActionConstruct = 1
        local refiShieldActionAssist = 2

        if oUnitToProtect[M28Building.refoNearbyFactoryOfFaction] then
            iOptionalFactionRequired = M28UnitInfo.GetUnitFaction(oUnitToProtect[M28Building.refoNearbyFactoryOfFaction])
        end
        if not(iOptionalFactionRequired) then iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield
        else
            if iOptionalFactionRequired == M28UnitInfo.refFactionSeraphim then
                --Does enemy have mavor? if so then want T3 shields not T2
                local bEnemyHasMavor = false
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure]) == false then
                    for iArti, oArti in M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure] do
                        if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalArti * categories.UEF, oArti.UnitId) then
                            bEnemyHasMavor = true
                        end
                    end
                end
                if bEnemyHasMavor then
                    iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.SERAPHIM
                else
                    --If go for T2 shielding then will be quicker to build and cheaper, and still cover the unit provided the shield can absorb a single shot
                    iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.TECH2 * categories.SERAPHIM
                end
                iEngineerFactionRequired = iEngineerFactionRequired * categories.SERAPHIM  - categories.EXPERIMENTAL
            elseif iOptionalFactionRequired == M28UnitInfo.refFactionAeon then
                iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.AEON - categories.EXPERIMENTAL
                iEngineerFactionRequired = iEngineerFactionRequired * categories.AEON
            elseif iOptionalFactionRequired == M28UnitInfo.refFactionUEF then
                iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.UEF  - categories.EXPERIMENTAL
                iEngineerFactionRequired = iEngineerFactionRequired * categories.UEF
            else
                iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield
            end
        end
        local sLikelyShieldBlueprint = M28Factory.GetMostExpensiveBlueprintOfCategory(iShieldCategoryToBuild)
        local iBlueprintBuildTime = (__blueprints[sLikelyShieldBlueprint].Economy.BuildTime or 1250)

        local aiBrain = oUnitToProtect:GetAIBrain()
        local iTotalAvailableLocations = 0
        for iEntry, tLocation in oUnitToProtect[M28Building.reftLocationsForPriorityShield] do
            iTotalAvailableLocations = iTotalAvailableLocations + 1
            if bDebugMessages == true then
                LOG(sFunctionRef..': Will draw tLocation in reftLocationsForPriorityShield')
                M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tLocation, M28UnitInfo.GetBuildingSize(sLikelyShieldBlueprint) * 0.5), 4, 200)
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop to protect the unit if it is still valid, is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnitToProtect))..'; Unit to protect='..(oUnitToProtect.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitToProtect) or 'nil')) end
        while M28UnitInfo.IsUnitValid(oUnitToProtect) do
            if bDebugMessages == true then LOG(sFunctionRef..': Loop start at time '..GetGameTimeSeconds()..'; Is table of engineers actively shielding empty='..tostring(M28Utilities.IsTableEmpty(oUnitToProtect[reftEngineersActivelyShielding]))) end
            if M28Utilities.IsTableEmpty(oUnitToProtect[reftEngineersActivelyShielding]) == false then
                --Decide what to do with the engineers - first see how many shields we have, and if any are compelted:
                local iConstructedShields = 0
                local iActiveShields = 0
                local iPartConstructedShields = 0
                local oNearestCompletionShield
                local iHighestPartCompleteShield = -0.01 --So a 0% complete building gets included
                local iLowestPartCompleteShield = 1.01
                local oLowestCompletionShield
                local oLastCompletedShield
                local iCurShield, iMaxShield
                local oLowestConstructedShieldHealth
                local oHighestConstructedShieldHealth
                local iLowestConstructedShieldHealth = 100000
                local iHighestConstructedShieldHealthPercent = 0
                if bDebugMessages == true then LOG(sFunctionRef..': oUnitToProtect='..oUnitToProtect.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToProtect)..'; Is table of special assigned shields empty='..tostring(M28Utilities.IsTableEmpty(oUnitToProtect[M28Building.reftoSpecialAssignedShields]))) end
                if M28Utilities.IsTableEmpty(oUnitToProtect[M28Building.reftoSpecialAssignedShields]) == false then
                    local tiEntriesToRemove = {}
                    for iShield, oShield in oUnitToProtect[M28Building.reftoSpecialAssignedShields] do
                        if M28UnitInfo.IsUnitValid(oShield) then
                            if not(oShield[refbDontIncludeAsPartCompleteBuildingForConstruction]) then
                                oShield[refbDontIncludeAsPartCompleteBuildingForConstruction] = true

                                --Clear any assisting or building engineers who dont have the special shield action (to avoid a unit that is constructing a shield using this)
                                local tGuardingEngineers = oShield:GetGuards()
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of guarding engineers empty='..tostring(M28Utilities.IsTableEmpty(tGuardingEngineers))) end
                                if M28Utilities.IsTableEmpty(tGuardingEngineers) == false then
                                    for iGuard, oGuard in tGuardingEngineers do
                                        if not(oGuard[refiAssignedAction] == refActionSpecialShieldDefence) then
                                            M28Orders.IssueTrackedClearCommands(oGuard)
                                        end
                                    end
                                end
                                --Also check every engineer in this zone
                                local tEngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                if M28Utilities.IsTableEmpty(tEngineersInZone) == false then
                                    for iPotentialEngineer, oPotentialEngineer in tEngineersInZone do
                                        if M28UnitInfo.IsUnitValid(oPotentialEngineer) then
                                            if oPotentialEngineer[refiAssignedAction] == refActionBuildShield or oPotentialEngineer[refiAssignedAction] == refActionBuildSecondShield or oPotentialEngineer[refiAssignedAction] == refActionAssistShield then
                                                if bDebugMessages == true then LOG(sFunctionRef..': have engineer with action '..oPotentialEngineer[refiAssignedAction]..'; Engineer='..oPotentialEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPotentialEngineer)..'; Focus unit='..(oPotentialEngineer:GetFocusUnit().UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oPotentialEngineer:GetFocusUnit()) or 'nil')) end
                                                if oPotentialEngineer:GetFocusUnit()[refbDontIncludeAsPartCompleteBuildingForConstruction] or oPotentialEngineer:GetFocusUnit()[refiAssignedAction] == refActionSpecialShieldDefence then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will clear engineer orders') end
                                                    M28Orders.IssueTrackedClearCommands(oPotentialEngineer)
                                                end
                                            end
                                        end
                                    end
                                end
                                --Check shield isnt on a priority list to assist
                                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]) == false then
                                    for iCurShieldEntry = table.getn(tLZTeamData[M28Map.reftPriorityShieldsToAssist]), 1, -1 do
                                        if tLZTeamData[M28Map.reftPriorityShieldsToAssist][iCurShieldEntry][refbDontIncludeAsPartCompleteBuildingForConstruction] then
                                            table.remove(tLZTeamData[M28Map.reftPriorityShieldsToAssist], iCurShieldEntry)
                                        end
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering assigned shield oShield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; Fraction complete='..oShield:GetFractionComplete()) end
                            if oShield:GetFractionComplete() == 1 then
                                iConstructedShields = iConstructedShields + 1
                                oLastCompletedShield = oShield
                                iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': COnsidering shield health of constructed shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; iCurShield='..iCurShield..'; iMaxShield='..iMaxShield..'; iLowestConstructedShieldHealth='..iLowestConstructedShieldHealth..'; oUnit.MyShield:GetHealth()='..(oShield.MyShield:GetHealth() or 'nil')..'; Shield ratio='..(oShield:GetShieldRatio(false) or 0)..'; IsUp='..tostring(oShield.MyShield:IsUp())..'; IsOn='..tostring(oShield.MyShield:IsOn())..'; Depleted by damage='..tostring(oShield.DepletedByDamage or false)) end
                                if iCurShield > 0 then iActiveShields = iActiveShields + 1 end
                                if iCurShield < iLowestConstructedShieldHealth then
                                    oLowestConstructedShieldHealth = oShield
                                    iLowestConstructedShieldHealth = iCurShield
                                end
                                if (iCurShield / iMaxShield) > iHighestConstructedShieldHealthPercent then
                                    iHighestConstructedShieldHealthPercent = (iCurShield / iMaxShield)
                                    oHighestConstructedShieldHealth = oShield
                                end
                            else
                                iPartConstructedShields = iPartConstructedShields + 1
                                if oShield:GetFractionComplete() > iHighestPartCompleteShield then
                                    iHighestPartCompleteShield = oShield:GetFractionComplete()
                                    oNearestCompletionShield = oShield
                                end
                                if oShield:GetFractionComplete() < iLowestPartCompleteShield then
                                    iLowestPartCompleteShield = oShield:GetFractionComplete()
                                    oLowestCompletionShield = oShield
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Have a part constructed shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' with fraction compelte '..oShield:GetFractionComplete()..'; oNearestCompletionShield='..(oNearestCompletionShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestCompletionShield) or 'nil')) end
                            end
                        else
                            tiEntriesToRemove[iShield] = true
                        end
                    end
                    if M28Utilities.IsTableEmpty(tiEntriesToRemove) == false then
                        for iEntry, bRemove in tiEntriesToRemove do
                            oUnitToProtect[M28Building.reftoSpecialAssignedShields][iEntry] = nil
                        end
                    end
                end

                function ConstructNewShield()
                    local bProceededWithConstruction = false
                    --Need to construct a new shield (need to be wanting to do this for at least a tick due to delay in constructionstarting triggering due to forked thread)
                    local tPositionToBuild
                    local tAltPositionToBuild
                    local iActionGiven
                    if bDebugMessages == true then LOG(sFunctionRef..': ConstructNewShield: repru of locations for priority shield='..repru(oUnitToProtect[M28Building.reftLocationsForPriorityShield])..'; sLikelyShieldBlueprint='..(sLikelyShieldBlueprint or 'nil')..'; iPreviousAction='..(iPreviousAction or 'nil')..'; oLowestConstructedShieldHealth='..(oLowestConstructedShieldHealth.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oLowestConstructedShieldHealth) or 'nil')..'; ') end

                    for iEntry, tLocation in oUnitToProtect[M28Building.reftLocationsForPriorityShield] do
                        --basic check whether we can build (we should already be able to)
                        if bDebugMessages == true then LOG(sFunctionRef..': Can we build sLikelyShieldBlueprint '..sLikelyShieldBlueprint..' at tLocation '..repru(tLocation)..'='..tostring(aiBrain:CanBuildStructureAt(sLikelyShieldBlueprint, tLocation))) end
                        if aiBrain:CanBuildStructureAt(sLikelyShieldBlueprint, tLocation) then
                            if tPositionToBuild then
                                tAltPositionToBuild = tLocation
                                break
                            else
                                tPositionToBuild = tLocation
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': tPositionToBuild='..repru(tPositionToBuild)) end
                    if tPositionToBuild then
                        local toEngineersOfWrongFaction = {}
                        local oFirstEngineerOfRightFaction
                        local iEngineerBuildOrderCount = 0
                        for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Does this contain the required faction='..tostring(EntityCategoryContains(iEngineerFactionRequired, oEngineer.UnitId))) end
                            if EntityCategoryContains(iEngineerFactionRequired, oEngineer.UnitId) then
                                iEngineerBuildOrderCount = iEngineerBuildOrderCount + 1
                                                                    --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition, oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
                                local sBlueprintToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, iShieldCategoryToBuild, oEngineer, false,  false,          false,          nil,                                false)
                                if bDebugMessages == true then LOG(sFunctionRef..': Checking what shields engineer '..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil')..' can build; iOptionalFactionRequired='..(iOptionalFactionRequired or 'nil')..'; Will try and build unit '..sBlueprintToBuild..' at position '..repru(tPositionToBuild)) end
                                --Have the 4th engineer try to build in the alt location, so if the main location is blocked we may still get construction started
                                if iEngineerBuildOrderCount == 4 and tAltPositionToBuild then
                                    M28Orders.IssueTrackedBuild(oEngineer, tAltPositionToBuild, sBlueprintToBuild, false, 'SpAEBS')
                                else
                                    M28Orders.IssueTrackedBuild(oEngineer, tPositionToBuild, sBlueprintToBuild, false, 'SpEBS')
                                end
                                iActionGiven = refiShieldActionConstruct
                                bProceededWithConstruction = true

                                if not(oFirstEngineerOfRightFaction) then oFirstEngineerOfRightFaction = oEngineer end
                            else
                                table.insert(toEngineersOfWrongFaction, oEngineer)
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished telling engineers of right faction to build, Is table of engineers of wrong faction empty='..tostring(M28Utilities.IsTableEmpty(toEngineersOfWrongFaction))..'; bProceededWithConstruction='..tostring(bProceededWithConstruction)..'; Is oFirstEngineerOfRightFaction nil='..tostring(oFirstEngineerOfRightFaction == nil)) end
                        if M28Utilities.IsTableEmpty(toEngineersOfWrongFaction) == false then
                            if not(oFirstEngineerOfRightFaction) then
                                local bBuildAnyShield = false
                                if bDebugMessages == true then LOG(sFunctionRef..': Do we want to build a shield with wrong faction? Engineers of wrong faction='..table.getn(toEngineersOfWrongFaction)..'; iActiveShields='..iActiveShields..'; oUnitToProtect:GetFractionComplete()='..oUnitToProtect:GetFractionComplete()..'; iHighestConstructedShieldHealthPercent='..iHighestConstructedShieldHealthPercent..'; iConstructedShields='..iConstructedShields) end
                                if (table.getn(toEngineersOfWrongFaction) >= 5 or (iActiveShields == 0 and oUnitToProtect:GetFractionComplete() >= 0.2) or (iHighestConstructedShieldHealthPercent <= 0.5 and iConstructedShields >= 2)) then
                                    if iConstructedShields + iPartConstructedShields <= 1 then bBuildAnyShield = true
                                    elseif iConstructedShields >= 2 and iHighestConstructedShieldHealthPercent <= 0.8 then
                                        bBuildAnyShield = true
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': bBuildAnyShield='..tostring(bBuildAnyShield)) end
                                    if bBuildAnyShield then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have so many engineers of the wrong faction that will just try and get them to build a shield') end
                                        for iEngineer, oEngineer in toEngineersOfWrongFaction do
                                                                                --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition,                                   oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
                                            local sBlueprintToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryFixedShield * categories.TECH3, oEngineer, false,       false,          false,      nil,                                 false)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Checking what shields engineer '..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil')..' can build as backup as dont have right faction; iOptionalFactionRequired='..(iOptionalFactionRequired or 'nil')..'; Will try and build unit '..(sBlueprintToBuild or 'nil')..' at position '..repru(tPositionToBuild)) end
                                            if sBlueprintToBuild then
                                                M28Orders.IssueTrackedBuild(oEngineer, tPositionToBuild, sBlueprintToBuild, false, 'SBkEBS')
                                                iActionGiven = refiShieldActionConstruct
                                            end
                                        end
                                        bProceededWithConstruction = true
                                    end
                                end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Will get engineers to assist the one doing the construction') end
                                for iEngineer, oEngineer in toEngineersOfWrongFaction do
                                    --if not(oEngineer == oFirstEngineerOfRightFaction) then
                                    M28Orders.IssueTrackedGuard(oEngineer, oFirstEngineerOfRightFaction, false, 'SpEGE', false)
                                    --end
                                    iActionGiven = refiShieldActionConstruct
                                end
                            end
                        end
                    else
                        M28Utilities.ErrorHandler('We are unable to build at a predefined shield location, will check for small blocking M28 buildings and destroy them', true)
                        --Only search for units that are actually built on the shield location - so e.g. this wont cover if a factory is built where part of the factory covers the shield location
                        local iSearchRadius = M28UnitInfo.GetBuildingSize(sLikelyShieldBlueprint) * 0.5 - 0.49 --even at -0.75 will get units that arent in the build area being included
                        if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through oUnitToProtect[M28Building.reftLocationsForPriorityShield]='..repru(oUnitToProtect[M28Building.reftLocationsForPriorityShield])..'; iSearchRadius='..iSearchRadius..'; iTimeOfLastBlockingBuildingCheck='..(iTimeOfLastBlockingBuildingCheck or 'nil')) end
                        if GetGameTimeSeconds() - (iTimeOfLastBlockingBuildingCheck or -100) >= 5 then
                            iTimeOfLastBlockingBuildingCheck = GetGameTimeSeconds()
                            for iEntry, tLocation in oUnitToProtect[M28Building.reftLocationsForPriorityShield] do
                                local rShieldAreaRect = M28Utilities.GetRectAroundLocation(tLocation, iSearchRadius)
                                local tUnitsNearby = GetUnitsInRect(rShieldAreaRect)
                                local oCurBuildingBP
                                if M28Utilities.IsTableEmpty(tUnitsNearby) == false then
                                    local tBuildingsNearby = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryFixedShield - M28UnitInfo.refCategoryMex - M28UnitInfo.refCategoryHydro, tUnitsNearby)
                                    if M28Utilities.IsTableEmpty(tBuildingsNearby) == false then
                                        --Do we have a shield near her?
                                        local bNearbyShield = false
                                        local tShieldsNearby = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, tUnitsNearby)
                                        if M28Utilities.IsTableEmpty(tShieldsNearby) == false then
                                            --Redundancy - check if have any shields near here and both dont do the kill logic if we do, and also assign such shields to the game ender
                                            for iShield, oShield in tShieldsNearby do
                                                if oShield:GetAIBrain().M28AI and oShield:GetAIBrain().M28Team == iTeam then
                                                    if M28Utilities.GetRoughDistanceBetweenPositions(oShield:GetPosition(), tLocation) <= 4 then
                                                        bNearbyShield = true
                                                        if oShield['OnConstructionStarted'] then
                                                            --We for some reason havent assigned this shield against the game ender so will now
                                                            local oFirstEngineer
                                                            for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                                                                oFirstEngineer = oEngineer
                                                                break
                                                            end
                                                            ForkThread(AssignShieldToGameEnder, oShield, oFirstEngineer)
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                        if not(bNearbyShield) then
                                            for iBuilding, oBuilding in tBuildingsNearby do
                                                if oBuilding:GetAIBrain().M28AI and oBuilding:GetAIBrain().M28Team == aiBrain.M28Team then
                                                    oCurBuildingBP = oBuilding:GetBlueprint()
                                                    if (oCurBuildingBP.Economy.BuildCostMass or 0) * oBuilding:GetFractionComplete() <= 5000 then
                                                        --Check the building position and size means it is actually a blocking building
                                                        if oBuilding:GetPosition()[1] >= rShieldAreaRect[1] and oBuilding:GetPosition()[1] <= rShieldAreaRect[3] and oBuilding:GetPosition()[3] >= rShieldAreaRect[2] and oBuilding:GetPosition()[3] <= rShieldAreaRect[2] then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Will destroy blocking building='..oBuilding.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBuilding)..'; Building position='..repru(oBuilding:GetPosition())..'; will draw rectangle that this is within')
                                                                M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tLocation, iSearchRadius))
                                                            end
                                                            M28Orders.IssueTrackedKillUnit(oBuilding)
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    if iActionGiven then
                        iPreviousAction =  iActionGiven
                    end
                    return bProceededWithConstruction
                end

                function AssistShield(oShield)
                    --Assist this (if bPauseEngineers is true then will make sure every engineer is paused so they dont actually complete it)
                    if oShield:GetFractionComplete() < 1 then
                        if bDebugMessages == true then LOG(sFunctionRef..': AssistShield: Will repair shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' with fraction complete '..oShield:GetFractionComplete()) end
                        for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                            --Issue where engineers are given repair order but do nothing - will try adding small delay in case issue is being given same order every tick
                            if GetGameTimeSeconds() - (oEngineer[refiTimeOfLastShieldRepairOrder] or -10) < 1 and oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefoOrderUnitTarget] == oShield then
                                if bDebugMessages == true then LOG(sFunctionRef..': It has been less than 1s since we last gave order to repair') end
                            else
                                oEngineer[refiTimeOfLastShieldRepairOrder] = GetGameTimeSeconds()
                                if bDebugMessages == true then LOG(sFunctionRef..': Engineer unit state='..M28UnitInfo.GetUnitState(oEngineer)..'; Is state repairing='..tostring(oEngineer:IsUnitState('Repairing'))..'; Engineer work progress='..(oEngineer:GetWorkProgress() or 'nil')) end
                                M28Orders.IssueTrackedRepair(oEngineer, oShield, false, 'SpecShR', false)
                            end
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': AssistShield: Will assist shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' with fraction complete '..oShield:GetFractionComplete()) end
                        for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Giving guard order to oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer))
                                local oFocusUnit = oEngineer:GetFocusUnit()
                                if oFocusUnit then
                                    LOG(sFunctionRef..': Engineer cur focus unit='..oFocusUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFocusUnit))
                                end
                            end
                            M28Orders.IssueTrackedGuard(oEngineer, oShield, false, 'SpecShG', false)
                        end
                    end
                    iPreviousAction =  refiShieldActionAssist
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Deciding what to do, iConstructedShields='..iConstructedShields..'; iPartConstructedShields='..iPartConstructedShields..'; iHighestPartCompleteShield='..iHighestPartCompleteShield..'; iActiveShields='..iActiveShields..'; iTotalAvailableLocations='..iTotalAvailableLocations) end
                if iConstructedShields == 0 then
                    --Want to build a shield - complete the closest to completion if we have any
                    if oNearestCompletionShield then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to construct a shield, will assist the one nearest completion='..oNearestCompletionShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestCompletionShield)..' fraction complete='..oNearestCompletionShield:GetFractionComplete()) end
                        AssistShield(oNearestCompletionShield)
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to construct a shield, none under construction so will build a new one') end
                        ConstructNewShield()
                    end
                else
                    --We already have 1 constructed shield, want to make sure we have another shield that is closest to completion next
                    --% wanted - if are assigning 500 build power to this, and the shortest BT shield is 1250, then in theory we could end up building the shield in 0.4s, i.e. each tick would be 4%.  In reality this seems unlikely though
                    local iPercentCompleteWanted
                    local iTotalBuildPowerAvailable = 0
                    for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                        iTotalBuildPowerAvailable = iTotalBuildPowerAvailable + oEngineer:GetBlueprint().Economy.BuildRate
                    end
                    if aiBrain.M28AI then
                        iTotalBuildPowerAvailable = iTotalBuildPowerAvailable * M28Team.tTeamData[aiBrain.M28Team][M28Team.refiHighestBrainBuildMultiplier]
                    end
                    --Treat build power as being 50% more than it actually is to give a bit more leeway
                    iPercentCompleteWanted = math.min(0.99, math.max(0.8, 1 - iTotalBuildPowerAvailable * 2.5 / (iBlueprintBuildTime * 10) - 0.002))
                    if iPartConstructedShields > 0 and iHighestPartCompleteShield < iPercentCompleteWanted then
                        --Want to assist existing part complete shield
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to assist existing part complete shield as it isnt near complete yet, iPercentCompleteWanted='..iPercentCompleteWanted..'; oNearestCompletionShield='..oNearestCompletionShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestCompletionShield)..'; Fraction complete='..oNearestCompletionShield:GetFractionComplete()) end
                        AssistShield(oNearestCompletionShield)
                    else
                        --We have at least 1 constructed shield, and at least 1 shield whose % complete is at the level wanted; Therefore we want a 3rd shield that is near-complete constructed
                        if iPartConstructedShields + iConstructedShields < iTotalAvailableLocations and ConstructNewShield() then
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to build a new shiled as we have more available locations than we have shields built or started building') end
                        else
                            --Get the lowest complete shield to assist if it needs it
                            if iPartConstructedShields > 0 and (iLowestPartCompleteShield < iPercentCompleteWanted or iActiveShields == 0) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to assist the lowest complete shield as it isnt nearly done, oLowestCompletionShield='..oLowestCompletionShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLowestCompletionShield)..'; Fraction complete='..oLowestCompletionShield:GetFractionComplete()) end
                                AssistShield(oLowestCompletionShield)
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Checking if weant to ctrlK a shield, iPartConstructedShields='..iPartConstructedShields..'; iConstructedShields='..iConstructedShields) end
                                if iPartConstructedShields == 0 and iConstructedShields >= 2 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to ctrlK a shield so can rebuild') end
                                    if oLowestConstructedShieldHealth then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will ctrlK shield '..oLowestConstructedShieldHealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLowestConstructedShieldHealth)) end
                                        M28Orders.IssueTrackedKillUnit(oLowestConstructedShieldHealth)
                                        --Clear assisting engineers in case they are assisting a part-complete shield that we want to stop
                                        if iPreviousAction == refiShieldActionAssist then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Previous action was to assist shield so will clear all engineerse that have a previous action being to assist a shield so they dont finish a part complete shield') end
                                            for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                                                M28Orders.IssueTrackedClearCommands(oEngineer)
                                            end
                                        end
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': Unable to find shield to kill so will default to assisting last compelted shield') end
                                        AssistShield(oLastCompletedShield)
                                    end
                                else
                                    --We have 1 complete shield, and all other shield locations have near-complete shields, so dont want to do anything else - have the engineers assist the completed shield
                                    if bDebugMessages == true then LOG(sFunctionRef..': Nothing to do so will assist a complete shield, oLastCompletedShield='..oLastCompletedShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLastCompletedShield)) end
                                    AssistShield(oLastCompletedShield)
                                end
                            end
                        end
                    end
                end

                --Decide whether to ctrlK shield so can start building another
                if iConstructedShields >= math.max(iTotalAvailableLocations, 2) or (iConstructedShields > 1 and iConstructedShields + iPartConstructedShields >= iTotalAvailableLocations and iActiveShields < iConstructedShields) then
                    --CtrlK a completed shield with the lowest shield value
                    if bDebugMessages == true then LOG(sFunctionRef..': iConstructedShields='..iConstructedShields..'; iTotalAvailableLocations='..iTotalAvailableLocations..'; iConstructedShields='..iConstructedShields..'; iPartConstructedShields='..iPartConstructedShields..'; iActiveShields='..iActiveShields..'; iLowestConstructedShieldHealth='..(iLowestConstructedShieldHealth or 'nil')) end
                    M28Orders.IssueTrackedKillUnit(oLowestConstructedShieldHealth)
                end

                --Make sure engineers show the action they have been assigned (as will have had orders cleared from above) - changed so will no longer clear in M28Orders
                --[[local bFirstEngineer = true
                for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                    if not(oEngineer[refiAssignedAction] == refActionSpecialShieldDefence) then
                        TrackEngineerAction(oEngineer, refActionSpecialShieldDefence, bFirstEngineer, iPriorityToUse)
                        if bFirstEngineer then bFirstEngineer = false end
                    end
                end--]]


            else
                if bDebugMessages == true then LOG(sFunctionRef..': Engineers no longer actively shielding, will end the loop at time '..GetGameTimeSeconds()) end
                oUnitToProtect[refbActiveUnitShieldingThread] = false
                break
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code at time '..GetGameTimeSeconds()..'; Is game ender valid='..tostring(M28UnitInfo.IsUnitValid(oUnitToProtect) or false)..'; ActiveShieldMonitoe='..tostring(oUnitToProtect[refbActiveUnitShieldingThread] or false)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AssignEngineerToShieldDefenceDuty(oEngineer, tLZTeamData)
    --Get the highest value unit to defend (for now will only support 1 unit for shield defence duty)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignEngineerToShieldDefenceDuty'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local oUnitToProtect
    local iHighestMassValue = 0
    local iCurMassValue
    for iGameEnder, oGameEnder in tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
        if M28UnitInfo.IsUnitValid(oGameEnder) then
            iCurMassValue = oGameEnder:GetBlueprint().Economy.BuildCostMass * oGameEnder:GetFractionComplete()
            if iCurMassValue > iHighestMassValue then
                iHighestMassValue = iCurMassValue
                oUnitToProtect = oGameEnder
            end
        end
    end
    if not(oUnitToProtect) then
        --Clear engineer actions as we dont have something for them to do after all
        ClearEngineerTracking(oEngineer)
    else
        if not(oUnitToProtect[reftEngineersActivelyShielding]) then oUnitToProtect[reftEngineersActivelyShielding] = {} end
        table.insert(oUnitToProtect[reftEngineersActivelyShielding], oEngineer)
        oEngineer[refoUnitActivelyShielding] = oUnitToProtect
        if not(oUnitToProtect[refbActiveUnitShieldingThread]) then
            ForkThread(ActiveShieldMonitor, oUnitToProtect, tLZTeamData, oEngineer:GetAIBrain().M28Team)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function ConsiderActionToAssign(iActionToAssign, iMinTechWanted, iTotalBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iCurPriority, tLZOrWZData, tLZOrWZTeamData, iTeam, iPlateauOrPond, iLandOrWaterZone, toAvailableEngineersByTech, toAssignedEngineers, bIsWaterZone, iSpecificFactionRequiredOverride, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
    --vOptionalVariable can be a table, nil or a value; used to pass info specific to the action if it needs it
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderActionToAssign'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Dont try getting any mroe BP for htis action if have run out of buildable locations
    local iExpectedBuildingSize = tiLastBuildingSizeFromActionForTeam[iTeam][iActionToAssign]
    if bDebugMessages == true then
        if iExpectedBuildingSize then
            LOG(sFunctionRef..': iExpectedBuildingSize='..(iExpectedBuildingSize or 'nil')..';  tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]='..( tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iExpectedBuildingSize] or 'nil')..'; iMinTechWanted='..(iMinTechWanted or 'nil'))
        else
            LOG(sFunctionRef..': iExpectedBuildingSize is nil,='..(iExpectedBuildingSize or 'nil')..'; iMinTechWanted='..(iMinTechWanted or 'nil'))
        end
    end
    local iPlateauOrZero
    if bIsWaterZone then iPlateauOrZero = 0 else iPlateauOrZero = iPlateauOrPond end

    if iExpectedBuildingSize and (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iExpectedBuildingSize] or 0) == 0 then
        if not(iActionToAssign == refActionBuildMex) and not(iActionToAssign == refActionBuildHydro) then

            if (tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] or 0) < 20 then
                --SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iOptionalMaxSegmentsToConsider)
                SearchForBuildableLocationsForLandOrWaterZone(M28Team.GetFirstActiveM28Brain(iTeam), iPlateauOrZero, iLandOrWaterZone, 20)
            end
            if (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iExpectedBuildingSize] or 0) == 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Setting build power to 0 as no buildable locations, tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick]='..(tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] or 'nil')..'; repru of tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize] for all sizes='..repru(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize])) end
                iTotalBuildPowerWanted = 0
            end
        end
    end

    if iTotalBuildPowerWanted < 0 then M28Utilities.ErrorHandler('Have negative BP wanted')
    elseif iTotalBuildPowerWanted > 0 then
        --Reduce BP for high modifiers where we have at least 50% mass stored and dont have spare engineers
        if iTotalBuildPowerWanted > 60 and M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier] >= 1.5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 and tLZOrWZTeamData[M28Map.subrefTbWantBP] and (tLZOrWZTeamData[M28Map.subrefSpareBPByTech][1] == 0 and tLZOrWZTeamData[M28Map.subrefSpareBPByTech][2] == 0 and tLZOrWZTeamData[M28Map.subrefSpareBPByTech][3] == 0) then
            --Only half BP for building the first power if we have lots of power already
            if not(iActionToAssign == refActionLoadOntoTransport) and (not(iActionToAssign == refActionBuildPower) or (iMinTechWanted == 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultipler] * 500)) then
                iTotalBuildPowerWanted = iTotalBuildPowerWanted * math.max(1 / M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier], 0.4)
                if bDebugMessages == true then LOG(sFunctionRef..': Halfing build power wanted') end
            end
        end

        --Reclaim specific - limit BP to 5 if we have recenlty failed to find something to reclaim
        if (iActionToAssign == refActionReclaimArea or iActionToAssign == refActionReclaimTrees) and tLZOrWZData[M28Map.subrefiTimeFailedToGetReclaim] and GetGameTimeSeconds() - tLZOrWZData[M28Map.subrefiTimeFailedToGetReclaim] <= 3 then
            if bDebugMessages == true then LOG(sFunctionRef..': Time since last failed to get reclaim for this zone='..GetGameTimeSeconds() - tLZOrWZData[M28Map.subrefiTimeFailedToGetReclaim]..'; BP wanted before limitation='..iTotalBuildPowerWanted..'; will cap at 5') end
            iTotalBuildPowerWanted = math.min(5, iTotalBuildPowerWanted)
        end


        --Experimental specific - Dont want to build if we have other engineers in a different zone building an experimental and we dont have the eco to support multiple ones - instead rely on separate engi transfer and mass transfer logic to get the experimental built
        if (iActionToAssign == refActionBuildExperimental or iActionToAssign == refActionBuildSecondExperimental or iActionToAssign == refActionBuildGameEnder or iActionToAssign == refActionBuildExperimentalNavy or iActionToAssign == refActionBuildLandExperimental) then
            if bDebugMessages == true then LOG(sFunctionRef..': About to remove BP wanted for experimental construction if we already have one under construction nearby that has recently started, or are about to start construction, and we cant support multiple at once, and dont have one in this zone') end
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]) == false and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 400 then
                --Do we have negative mass income, or have less than 70% mass stored? Also only consider for land experimentals (not navy) for now:
                if not(bIsWaterZone) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] < 1 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] < 0.7) then
                    --NOTE: If changing above thresholds then make sure the M28Events OnConstructionStarted is stricter
                    local iSearchRange = math.max(150, 400 - M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass])
                    local iSearchCategory = nil --means will search for everything
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 140 then
                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 280 then
                            iSearchCategory = M28UnitInfo.refCategoryGameEnder
                        else
                            iSearchCategory = M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti
                        end
                    end
                    local bHaveExperimentalForThisLandZone, iOtherLandZonesWithExperimental, iMassToComplete = GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateauOrPond, iLandOrWaterZone, true, iSearchRange, iSearchCategory)
                    if iMassToComplete >= math.max(15000, M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] * 1.25) and not(bHaveExperimentalForThisLandZone) then
                        --Estimate how long it will take to complete if we manage to spend 40% of gross mass on existing experimentals
                        if (iMassToComplete - M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]) / M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 0.4 > 40 then
                            iTotalBuildPowerWanted = 0
                            if bDebugMessages == true then LOG(sFunctionRef..': iMassToComplete='..iMassToComplete..'; Mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; will set BPWanted to 0') end
                        end
                    end
                end
            end
        end
        --Reduce the build power wanted by the existing build power assigned to that action for the LZ, unless bBPIsInAdditionToExisting is true or bMarkAsSpare is true
        local bAlreadyHaveTechLevelWanted = false
        if M28Utilities.IsTableEmpty(toAssignedEngineers) == false and iTotalBuildPowerWanted > 0 and not(bMarkAsSpare) then
            for iEngi, oEngi in toAssignedEngineers do
                if not(oEngi[M28UnitInfo.refbSpecialMicroActive]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..': Considering if oEngi '..oEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngi)..' already has iActionToAssign '..iActionToAssign..'; oEngi[refiAssignedAction]='..(oEngi[refiAssignedAction] or 'nil')..'; Engi tech level='..M28UnitInfo.GetUnitTechLevel(oEngi)..'; iMinTechWanted='..iMinTechWanted) end
                    if oEngi[refiAssignedAction] == iActionToAssign then
                        if not(bAlreadyHaveTechLevelWanted) and M28UnitInfo.GetUnitTechLevel(oEngi) >= iMinTechWanted then
                            --Only flag as having min tech level wanted if we will be able to make use of this engineer per the later code
                            if not(tbIgnoreEngineerAssistance[iActionToAssign]) and oEngi[M28Orders.reftiLastOrders] and oEngi[M28Orders.reftiLastOrders][oEngi[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild then
                                bAlreadyHaveTechLevelWanted = true
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Reducing total Build power wanted by '..oEngi:GetBlueprint().Economy.BuildRate..' unless bBPIsInAdditionToExisting is true; bBPIsInAdditionToExisting='..tostring(bBPIsInAdditionToExisting or false)) end
                        if not(bBPIsInAdditionToExisting) then
                            iTotalBuildPowerWanted = iTotalBuildPowerWanted - oEngi:GetBlueprint().Economy.BuildRate
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': About to check if want to lower tech level wanted, bAlreadyHaveTechLevelWanted='..tostring(bAlreadyHaveTechLevelWanted)..'; iMinTechWanted='..iMinTechWanted..'; Is campaign map='..tostring(M28Map.bIsCampaignMap)) end
        if bAlreadyHaveTechLevelWanted and not(bDontUseLowerTechEngineersToAssist) then iMinTechWanted = 1
            --Campaign - might have T3 air fac but not be able to build T3 engineers
        elseif iMinTechWanted > 1 and (M28Map.bIsCampaignMap or M28Overseer.bUnitRestrictionsArePresent) and (iActionToAssign == refActionBuildLandFactory or iActionToAssign == refActionBuildAirFactory or iActionToAssign == refActionBuildPower or iActionToAssign == refActionBuildSecondLandFactory or iActionToAssign == refActionBuildSecondAirFactory) and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            --Check we have engineers of the relevant tech level to be able to build the factory
            local iEngiCategoryWanted
            if iMinTechWanted >= 3 then iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer * categories.TECH3
            else iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer - categories.TECH1
            end
            local tExistingEngineersOfCategory = EntityCategoryFilterDown(iEngiCategoryWanted, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if bDebugMessages == true then LOG(sFunctionRef..': Is tExistingEngineersOfCategory empty='..tostring(M28Utilities.IsTableEmpty(tExistingEngineersOfCategory))) end
            if M28Utilities.IsTableEmpty(tExistingEngineersOfCategory) then
                if bDebugMessages == true then LOG(sFunctionRef..': Will lower min tech level wanted to build a factory due to being a campaign or having unit restrictions') end
                iMinTechWanted = iMinTechWanted - 1
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; iActionToAssign='..iActionToAssign..'; iTeam='..iTeam..'; iPlateauOrPond='..iPlateauOrPond..'; iLandOrWaterZone='..iLandOrWaterZone..'; Have just updated BP wanted for existing engineers with the same action, iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; Is toAvailableEngineersByTech empty='..tostring(M28Utilities.IsTableEmpty(toAvailableEngineersByTech))..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted) end


        --Do we have an engineer of the tech level wanted? First assign any available engineers of the right tech level to the action
        --If we dont have any engineers of the right tech level available, then see if we have an engineer with a lower priority action
        local tEngineersOfTechWanted
        if toAvailableEngineersByTech and iTotalBuildPowerWanted > 0 then tEngineersOfTechWanted = GetEngineersOfTechWanted(iMinTechWanted, toAvailableEngineersByTech) end
        if M28Utilities.IsTableEmpty(toAvailableEngineersByTech) and iTotalBuildPowerWanted > 0 and M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
            local bConsiderRetreatingEngineers = false
            if iActionToAssign == refActionBuildEmergencyPD and (tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or (tLZOrWZTeamData[M28Map.subrefLZCoreExpansion] and (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) < (tLZOrWZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0))) then
                bConsiderRetreatingEngineers = true
            end
            --Do we have already assigned engineers with a lower priority that we could use?
            local iEngiCategoryWanted
            if iMinTechWanted <= 1 then iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer
            elseif iMinTechWanted == 2 then iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer * categories.TECH2 + M28UnitInfo.refCategoryEngineer * categories.TECH3
            else iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer * categories.TECH3
            end
            local toAssignedEngisOfTechLevel = EntityCategoryFilterDown(iEngiCategoryWanted, toAssignedEngineers)
            if M28Utilities.IsTableEmpty(toAssignedEngisOfTechLevel) == false then
                tEngineersOfTechWanted = {}
                local iHighestPriorityEngi = iCurPriority
                local oHighestPriorityEngi
                for iEngi, oEngi in toAssignedEngisOfTechLevel do
                    if not(oEngi[refbPrimaryBuilder]) and not(oEngi[refiAssignedAction] == iActionToAssign) and oEngi[refiAssignedActionPriority] > iHighestPriorityEngi and not(oEngi:IsUnitState('Reclaiming')) and not(oEngi:IsUnitState('Attached')) and not(oEngi:IsUnitState('Capturing')) then
                        --Exception for engineers assisting a shield
                        if not(oEngi[refiAssignedAction] == refActionAssistShield) or not(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) then
                            iHighestPriorityEngi = oEngi[refiAssignedActionPriority]
                            oHighestPriorityEngi = oEngi
                        end
                    elseif bConsiderRetreatingEngineers and not(oHighestPriorityEngi) and oEngi[refiAssignedActionPriority] < iHighestPriorityEngi and oEngi[refiAssignedAction] == refActionRunToLandZone and not(oEngi:IsUnitState('Reclaiming')) and not(oEngi:IsUnitState('Attached')) and not(oEngi:IsUnitState('Capturing')) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will make use of engi running away to build emergency PD') end
                        oHighestPriorityEngi = oEngi
                    end
                end
                if oHighestPriorityEngi then
                    table.insert(tEngineersOfTechWanted, oHighestPriorityEngi)
                    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; iMinTechWanted='..iMinTechWanted..'; oHighestPriorityEngi='..oHighestPriorityEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oHighestPriorityEngi)..'; oHighestPriorityEngi action='..(oHighestPriorityEngi[refiAssignedAction] or 'nil')..' with a priority '..(oHighestPriorityEngi[refiAssignedActionPriority] or 'nil')..'; Is primary='..tostring(oHighestPriorityEngi[refbPrimaryBuilder] or false)..'; table size='..table.getn(tEngineersOfTechWanted)) end
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Is tEngineersOfTechWanted empty='..tostring(M28Utilities.IsTableEmpty(tEngineersOfTechWanted))) end
        if M28Utilities.IsTableEmpty(tEngineersOfTechWanted) == false and iTotalBuildPowerWanted > 0 then

            local sOrderRef = 'A'..iActionToAssign..'Pr'..iCurPriority --For debugging - if show unit names then will include this
            local iMaxSearchRange = 180 --Must be bigger than the largest land zone or else units wont be able to build, so can lead to engineers entering a land zone to build and then moving away to a different land zone
            local iEngiCount = table.getn(tEngineersOfTechWanted)
            local iCurEngiTechLevel
            local iCurEngiBuildPower
            local aiBrain = tEngineersOfTechWanted[1]:GetAIBrain()
            local iMinCategoryTechLevel = iMinTechWanted
            --Override tech level if we lack the relevant factory HQ
            if iActionToAssign == refActionBuildLandFactory or iActionToAssign == refActionBuildSecondLandFactory then
                iMinCategoryTechLevel = math.max(1, math.min(iMinTechWanted, (aiBrain[M28Economy.refiOurHighestLandFactoryTech] or 1)))
            elseif iActionToAssign == refActionBuildAirFactory or iActionToAssign == refActionBuildSecondAirFactory then
                iMinCategoryTechLevel = math.max(1, math.min(iMinTechWanted, (aiBrain[M28Economy.refiOurHighestAirFactoryTech] or 1)))
            elseif iActionToAssign == refActionBuildNavalFactory then
                iMinCategoryTechLevel = math.max(1, math.min(iMinTechWanted, (aiBrain[M28Economy.refiOurHighestNavalFactoryTech] or 1)))
            end
            --Check faction available
            local tbEngineersOfFaction
            if tbActionsWithFactionSpecificLogic[iActionToAssign] and not(bAlreadyHaveTechLevelWanted) then
                tbEngineersOfFaction = {}
                for iUnit, oUnit in tEngineersOfTechWanted do
                    tbEngineersOfFaction[M28UnitInfo.GetUnitFaction(oUnit)] = true
                end
            end

            local iCategoryWanted, iOptionalFactionRequired = GetCategoryToBuildOrAssistFromAction(iActionToAssign, iMinCategoryTechLevel, aiBrain, tbEngineersOfFaction, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iLandOrWaterZone)
            --Land and air facs - optional variable can be used to specify max tech level to use
            if vOptionalVariable and (iActionToAssign == refActionBuildAirFactory or iActionToAssign == refActionBuildLandFactory or iActionToAssign == refActionBuildSecondLandFactory or iActionToAssign == refActionBuildSecondLandFactory) and vOptionalVariable >= iMinCategoryTechLevel and (vOptionalVariable == 1 or vOptionalVariable == 2) then
                iCategoryWanted = iCategoryWanted * M28UnitInfo.ConvertTechLevelToCategory(vOptionalVariable)
            end
            if iSpecificFactionRequiredOverride and not(iOptionalFactionRequired) then iOptionalFactionRequired = iSpecificFactionRequiredOverride end

            function UpdateBPTracking()
                iCurEngiTechLevel = M28UnitInfo.GetUnitTechLevel(tEngineersOfTechWanted[iEngiCount])
                iCurEngiBuildPower = tEngineersOfTechWanted[iEngiCount]:GetBlueprint().Economy.BuildRate
                iTotalBuildPowerWanted = iTotalBuildPowerWanted - iCurEngiBuildPower
                if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[iCurEngiTechLevel]) == false then --If we are reassigning an engineer this wont have a value
                    for iEngi, oEngi in toAvailableEngineersByTech[iCurEngiTechLevel] do
                        if oEngi == tEngineersOfTechWanted[iEngiCount] then
                            table.insert(toAssignedEngineers, tEngineersOfTechWanted[iEngiCount])
                            table.remove(toAvailableEngineersByTech[iCurEngiTechLevel], iEngi)
                            break
                        end
                    end
                end

                tEngineersOfTechWanted[iEngiCount] = nil
                iEngiCount = iEngiCount - 1
            end

            if bDebugMessages == true then LOG(sFunctionRef..': iActionToAssign='..iActionToAssign..'; iEngiCount='..iEngiCount..'; Is category watned nil='..tostring(iCategoryWanted == nil)..'; iMinCategoryTechLevel='..(iMinCategoryTechLevel or 'nil')) end


            if iCategoryWanted then
                --Do we have a part complete unit of this category already under construction in this land zone?
                --Building a factory - change whether to search for assistance based on mass stored %; for mass storage instead base the check on how many locations we have as we may be trying to build a second storage
                local iConstructionCountToIgnore = (tiIgnoreUnderConstructionThreshold[iActionToAssign] or 0)
                --local bShouldIgnoreUnderConstruction = tbIgnoreUnderConstructionActions[iActionToAssign]
                if iActionToAssign == refActionBuildLandFactory or iActionToAssign == refActionBuildAirFactory then
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 15 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then iConstructionCountToIgnore = 1 end
                elseif iActionToAssign == refActionBuildMassStorage and table.getn(tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable]) >= 5 then iConstructionCountToIgnore = 1
                elseif iConstructionCountToIgnore > 0 and iActionToAssign == refActionBuildSecondExperimental then
                    if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti + M28UnitInfo.refCategoryParagon + M28UnitInfo.refCategorySML * categories.EXPERIMENTAL, iCategoryWanted) then
                        iConstructionCountToIgnore = 0
                    end
                end

                local oBuildingToAssist
                if iConstructionCountToIgnore < 100 then
                    --We adjust power to only consider the min tech levle not higher ones (presumably so we can build t1/t2 power when we have access to t3, if we need more power to build t3); therefore need to take this into account here
                    local iUnderConstructionCategory
                    if iActionToAssign == refActionBuildPower then
                        iUnderConstructionCategory = M28UnitInfo.refCategoryPower - M28UnitInfo.refCategoryHydro
                    else iUnderConstructionCategory = iCategoryWanted
                    end
                    oBuildingToAssist = GetPartCompleteBuildingInZone(iTeam, iPlateauOrPond, iLandOrWaterZone, iUnderConstructionCategory, bIsWaterZone, iConstructionCountToIgnore)
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking to see if we have a unit of the desired category. oBuildingToAssist='..(oBuildingToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBuildingToAssist) or 'nil')..'; bIsWaterZone='..tostring(bIsWaterZone)) end
                end

                if oBuildingToAssist then
                    --Assist the building under construction that has the category we want
                    while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                        if bDebugMessages == true then LOG(sFunctionRef..': Assigning engineer for repair action '..iActionToAssign..'; iEngiCount='..iEngiCount..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted) end
                        M28Orders.IssueTrackedRepair(tEngineersOfTechWanted[iEngiCount], oBuildingToAssist, false, sOrderRef)
                        TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, not(bAlreadyHaveTechLevelWanted), iCurPriority, nil, nil, bMarkAsSpare)
                        UpdateBPTracking()
                    end
                else
                    --Dont have any buildings of the type wanted under construction; do we have an engineer already assigned to the same action? If so then assist it
                    local oEngineerToAssist
                    if not(tbIgnoreEngineerAssistance[iActionToAssign]) and M28Utilities.IsTableEmpty(toAssignedEngineers) == false then

                        for iEngi, oEngi in toAssignedEngineers do
                            if oEngi[refiAssignedAction] == iActionToAssign then
                                --Only assist if engi last order was to build
                                if bDebugMessages == true then
                                    if oEngi[M28Orders.reftiLastOrders] then
                                        LOG(sFunctionRef..': Considering if oEngi '..oEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngi)..' can be assisted to build this; tablegetn of last orders='..oEngi[M28Orders.refiOrderCount]..'; reprs of last orders='..reprs(oEngi[M28Orders.reftiLastOrders])..'; refiOrderCount='..oEngi[M28Orders.refiOrderCount]..'; Is the last order to build something='..tostring(oEngi[M28Orders.reftiLastOrders][oEngi[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild))
                                    else
                                        LOG(sFunctionRef..': Considering if oEngi '..oEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngi)..' can be assisted to build this; Engi last orders is nil, reprs='..reprs(oEngi[M28Orders.reftiLastOrders]))
                                    end
                                end
                                if oEngi[M28Orders.reftiLastOrders] and oEngi[M28Orders.reftiLastOrders][oEngi[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild then
                                    if bDebugMessages == true then LOG(sFunctionRef..': We can assist the engineer') end
                                    oEngineerToAssist = oEngi
                                    break
                                end
                            end
                        end
                    end
                    if not(oEngineerToAssist) then
                        --Has a building been queued for this land zone even if we havent found an engineer to assist? (e.g. rare cases where engineer queues order then briefly drops out of the land zone list of engineers)
                        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefQueuedBuildings]) == false and iConstructionCountToIgnore == 0 and not(tbIgnoreEngineerAssistance[iActionToAssign]) then
                            for iEntry, tQueuedDetails in tLZOrWZTeamData[M28Map.subrefQueuedBuildings] do
                                if EntityCategoryContains(iCategoryWanted, tQueuedDetails[M28Map.subrefBuildingID]) and M28UnitInfo.IsUnitValid(tQueuedDetails[M28Map.subrefPrimaryBuilder]) and not(tQueuedDetails[M28Map.subrefPrimaryBuilder]:GetFocusUnit()[refbDontIncludeAsPartCompleteBuildingForConstruction]) and not(tQueuedDetails[M28Map.subrefPrimaryBuilder][refiAssignedAction] == refActionSpecialShieldDefence) then
                                    oEngineerToAssist = tQueuedDetails[M28Map.subrefPrimaryBuilder]
                                    break
                                end
                            end
                        end
                    end
                    if oEngineerToAssist then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will assign engineers to build, iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                        local tLastOrder = oEngineerToAssist[M28Orders.reftiLastOrders][oEngineerToAssist[M28Orders.refiOrderCount]]
                        local sBlueprintToBuild = tLastOrder[M28Orders.subrefsOrderBlueprint]
                        local tOrderPosition = tLastOrder[M28Orders.subreftOrderPosition]
                        if sBlueprintToBuild and tOrderPosition and EntityCategoryContains(iCategoryWanted, sBlueprintToBuild) then
                            while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                if tEngineersOfTechWanted[iEngiCount]:CanBuild(sBlueprintToBuild) then
                                    --Can build
                                    M28Orders.IssueTrackedBuild(tEngineersOfTechWanted[iEngiCount], tOrderPosition, sBlueprintToBuild, false, sOrderRef..'B')
                                else
                                    --Assist the engineer for lower tech enginers
                                    M28Orders.IssueTrackedGuard(tEngineersOfTechWanted[iEngiCount], oEngineerToAssist, false, sOrderRef..'A')
                                end
                                TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, nil, nil, bMarkAsSpare)
                                UpdateBPTracking()
                            end

                        else
                            --Assist the engineer for all engineers
                            while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                if bDebugMessages == true then LOG(sFunctionRef..': Assigning engineer for assist engineer action '..iActionToAssign..'; iEngiCount='..iEngiCount..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted) end
                                M28Orders.IssueTrackedGuard(tEngineersOfTechWanted[iEngiCount], oEngineerToAssist, false, sOrderRef..'A')
                                TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, nil, nil, bMarkAsSpare)
                                UpdateBPTracking()
                            end
                        end
                    else

                        if tiActionOrder[iActionToAssign] == M28Orders.refiOrderIssueGuard then
                            --Want to assist something, and are just looking for a single predefined category (so dont need the  later on custom logic)
                            local oUnitToAssist
                            if vOptionalVariable and M28UnitInfo.IsUnitValid(vOptionalVariable) then oUnitToAssist = vOptionalVariable
                            else
                                local oBackupUnit
                                local sAlliedUnitRef
                                if bIsWaterZone then sAlliedUnitRef = M28Map.subreftoLZOrWZAlliedUnits
                                else sAlliedUnitRef = M28Map.subreftoLZOrWZAlliedUnits
                                end
                                local tUnitsOfCategoryInLZ = EntityCategoryFilterDown(tiActionCategory[iActionToAssign], tLZOrWZTeamData[sAlliedUnitRef])
                                if M28Utilities.IsTableEmpty(tUnitsOfCategoryInLZ) == false then
                                    --Shield assistance - special logic
                                    if iActionToAssign == refActionAssistShield then
                                        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftPriorityShieldsToAssist]) then --redundancy
                                            M28Utilities.ErrorHandler('Dont have a priority shield to assist somehow')
                                        else
                                            --Get the shield with the least assistance
                                            local iLowestBPAssisting = 100000
                                            local iCurBPAssisting
                                            for iShield, oShield in tLZOrWZTeamData[M28Map.reftPriorityShieldsToAssist] do
                                                iCurBPAssisting = 0
                                                if M28Utilities.IsTableEmpty(oShield[M28UnitInfo.reftoUnitsAssistingThis]) == false then
                                                    for iAssisting, oAssisting in oShield[M28UnitInfo.reftoUnitsAssistingThis] do
                                                        iCurBPAssisting = iCurBPAssisting + (oAssisting:GetBlueprint().Economy.BuildRate or 0)
                                                    end
                                                end
                                                if iCurBPAssisting < iLowestBPAssisting then
                                                    iLowestBPAssisting = iCurBPAssisting
                                                    oUnitToAssist = oShield
                                                    if iLowestBPAssisting == 0 then break end
                                                end
                                            end
                                        end
                                    else
                                        for iUnit, oUnit in tUnitsOfCategoryInLZ do
                                            if oUnit:GetWorkProgress() > 0 then
                                                oUnitToAssist = oUnit
                                            else
                                                oBackupUnit = oUnitToAssist
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to assist unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with work progress '..oUnit:GetWorkProgress()) end
                                        end
                                        if not(oUnitToAssist) then oUnitToAssist = oBackupUnit end
                                    end
                                end
                            end
                            if M28UnitInfo.IsUnitValid(oUnitToAssist) then
                                while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                    if bDebugMessages == true then LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to assist unit '..oUnitToAssist.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToAssist)) end
                                    M28Orders.IssueTrackedGuard(tEngineersOfTechWanted[iEngiCount], oUnitToAssist, false, sOrderRef)
                                    TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, nil, nil, bMarkAsSpare)
                                    UpdateBPTracking()
                                end
                            else
                                --Dont have anything to assist
                                if bDebugMessages == true then LOG(sFunctionRef..': Cant assist the desired category so will stop trying to assist it and reduce build power required') end
                                iTotalBuildPowerWanted = 0
                            end

                        else
                            --No building under construciton, and no existing engineer to assist - assign engineers to build instead

                            --Do we need a specific faction? If so then filter available engineers to just these
                            if iOptionalFactionRequired then tEngineersOfTechWanted, iEngiCount = FilterEngineersOfTechAndEngiCountForFaction(iOptionalFactionRequired, tEngineersOfTechWanted) end

                            if iEngiCount > 0 then
                                --Building power - if we get to T3, have at least 750 gross energy per tick, and have an action to build second power, then change building power normally so it builds separately to building second power
                                if iActionToAssign == refActionBuildThirdPower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 1000 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                                    tiIgnoreUnderConstructionThreshold[refActionBuildPower] = 1
                                end
                                local oFirstEngineer = tEngineersOfTechWanted[iEngiCount]
                                local sBlueprint, tBuildLocation
                                local iAdjacencyCategory

                                --Early game - build cheapest option of a unit (e.g. useful for mods that might add expensive hydros or experimental units)
                                local bGetCheapest = false
                                if GetGameTimeSeconds() <= 900 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 10 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 300 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 6 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 15 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and not(iActionToAssign == refActionBuildLandFactory) and not(iActionToAssign == refActionBuildAirFactory) and not(iActionToAssign == refActionBuildExperimental) and not(M28Team.tTeamData[aiBrain.M28Team][M28Team.refiTimeLastNearUnitCap]) then bGetCheapest = true
                                end


                                if bDebugMessages == true then LOG(sFunctionRef..': About to get the blueprint and build location, oFirstEngineer='..oFirstEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFirstEngineer)) end
                                if iActionToAssign == refActionBuildShield or iActionToAssign == refActionBuildSecondShield then
                                    GetMaxShieldSearchRangeForEngineer(oFirstEngineer, iCategoryWanted)
                                    --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerAction, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy,                         tAlternativePositionToLookFrom, bNotYetUsedLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData, bCalledFromGetBestLocation, sBlueprintOverride)
                                    sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted, iMaxSearchRange, tiActionAdjacentCategory[iActionToAssign], vOptionalVariable:GetPosition(), false,                              nil,                nil,                                false,                  tLZOrWZData, tLZOrWZTeamData)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished getting blueprint and build location for shield, sBlueprint='..(sBlueprint or 'nil')..'; tBuildLocation='..repru(tBuildLocation)..'; vOptionalVariable='..(vOptionalVariable.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(vOptionalVariable) or 'nil')..'; iMaxSearchRange='..iMaxSearchRange..'; vOptionalVariable position='..repru(vOptionalVariable:GetPosition())) end
                                    if M28Utilities.IsTableEmpty(tBuildLocation) and vOptionalVariable.UnitId then
                                        vOptionalVariable[refiFailedShieldConstructionCount] = (vOptionalVariable[refiFailedShieldConstructionCount] or 0) + 1
                                        if vOptionalVariable[refiFailedShieldConstructionCount] >= 5 then
                                            --Lower value by 1 in 3 minutes
                                            M28Utilities.DelayChangeVariable(vOptionalVariable, refiFailedShieldConstructionCount, -1, 180, nil, nil, nil, nil, true)
                                        end
                                    end
                                elseif vOptionalVariable and (iActionToAssign == refActionBuildEmergencyPD or iActionToAssign == refActionBuildEmergencyArti) then
                                    --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerAction, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy,                tAlternativePositionToLookFrom, bNotYetUsedLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData, bCalledFromGetBestLocation, sBlueprintOverride)
                                    sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted, iMaxSearchRange, tiActionAdjacentCategory[iActionToAssign], vOptionalVariable,       false,                              nil,             nil,                                   bGetCheapest,                   tLZOrWZData, tLZOrWZTeamData)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have just tried to get location for PD, vOptionalVariable='..repru(vOptionalVariable)..'; sBlueprint='..(sBlueprint or 'nil')..'; tBuildLocation='..repru(tBuildLocation))
                                        M28Utilities.DrawLocation(tBuildLocation)
                                    end
                                elseif vOptionalVariable and iActionToAssign == refActionBuildTMD then
                                    --Build near the unit we want to protect (get blueprint will also factor in maxsearchrange based on the TMD range)
                                    if vOptionalVariable.UnitId then
                                        --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerAction, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy,                tAlternativePositionToLookFrom, bNotYetUsedLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData, bCalledFromGetBestLocation, sBlueprintOverride)
                                        sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted, iMaxSearchRange, tiActionAdjacentCategory[iActionToAssign], vOptionalVariable:GetPosition(), false,                      nil,                nil,                                bGetCheapest, tLZOrWZData, tLZOrWZTeamData)
                                    elseif M28Utilities.IsTableEmpty(vOptionalVariable) == false then
                                        sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted, iMaxSearchRange, tiActionAdjacentCategory[iActionToAssign], vOptionalVariable,               false,                      nil,                nil,                                bGetCheapest, tLZOrWZData, tLZOrWZTeamData)
                                    else
                                        M28Utilities.ErrorHandler('Trying to build TMD without a unit or location')
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Building TMD, sBlueprint='..sBlueprint..'; tBuildLocation='..repru(tBuildLocation)) end
                                elseif iActionToAssign == refActionBuildAirStaging and (bGetCheapest or not(M28Team.tTeamData[aiBrain.M28Team][M28Team.refiTimeLastNearUnitCap])) then
                                    --Mod support for mods that introduce t3 air staging which is very expensive - want to avoid unless close to unit cap
                                    --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerAction, iCategoryToBuild,                                         iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bNotYetUsedLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData, bCalledFromGetBestLocation, sBlueprintOverride)
                                    sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted - categories.TECH3 - categories.EXPERIMENTAL, iMaxSearchRange, iAdjacencyCategory, nil,                           false,                          nil,                nil,                                bGetCheapest,           tLZOrWZData,  tLZOrWZTeamData)
                                else
                                    iAdjacencyCategory = tiActionAdjacentCategory[iActionToAssign]
                                    if not(iAdjacencyCategory) and (iActionToAssign == refActionBuildExperimental or iActionToAssign == refActionBuildSecondExperimental) then
                                        if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti * categories.STRUCTURE + M28UnitInfo.refCategorySML, iCategoryWanted) then
                                            iAdjacencyCategory = M28UnitInfo.refCategoryT3Power
                                        end
                                    end
                                    --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerAction, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bNotYetUsedLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData, bCalledFromGetBestLocation, sBlueprintOverride)
                                    sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted, iMaxSearchRange, iAdjacencyCategory, nil,                                false,                          nil,                nil,                                bGetCheapest, tLZOrWZData, tLZOrWZTeamData)
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Just got blueprint and location to build for oFirstEngineer='..oFirstEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFirstEngineer)..'; iActionTOAssign='..iActionToAssign..'; sBlueprint='..(sBlueprint or 'nil')..'; tBuildLocation='..repru(tBuildLocation)..'; Is tiActionAdjacentCategory[iActionToAssign] nil='..tostring(tiActionAdjacentCategory[iActionToAssign] == nil)) end
                                if M28Utilities.IsTableEmpty(tBuildLocation) then
                                    if not(iActionToAssign == refActionBuildShield or iActionToAssign == refActionBuildSecondShield) then
                                        if sBlueprint and (GetGameTimeSeconds() <= 300 or GetGameTimeSeconds() - (tLZOrWZTeamData[M28Map.refiTimeLastShowedBuildLocationFailure] or -300) >= 300) then
                                            --Couldnt find a build locaiton, but might be valid particularly later in the game or on small island maps, so only show as a warning message every 5m
                                            local Game = import("/lua/game.lua")
                                            if not(Game.IsRestricted(sBlueprint, M28Team.GetFirstActiveM28Brain(iTeam))) then
                                                local bShowError = true
                                                if M28Map.bIsCampaignMap and EntityCategoryContains(M28UnitInfo.refCategoryMex, sBlueprint) then
                                                    --Is the first unbuilt mex location outside the playable area?
                                                    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations][1]) == false and not(M28Conditions.IsLocationInPlayableArea(tLZOrWZData[M28Map.subrefMexUnbuiltLocations][1])) then
                                                        --Mex is outside playable area so dont show error, and dont flag location as needing engis for mexes
                                                        tLZOrWZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] = false
                                                        bShowError = false
                                                    end
                                                end
                                                if bShowError then
                                                    M28Utilities.ErrorHandler('Unable to find build location, iActionToAssign='..(iActionToAssign or 'nil')..'; P'..(iPlateauOrPond or 'nil')..'Z'..(iLandOrWaterZone or 'nil')..'; sBlueprint='..(sBlueprint or 'nil'), true)
                                                    --Note - campaign maps where building mex - reason may be that all the mex locations remaining are outside of the playable area
                                                    tLZOrWZTeamData[M28Map.refiTimeLastShowedBuildLocationFailure] = GetGameTimeSeconds()
                                                end
                                            end
                                        end
                                    end
                                elseif sBlueprint then
                                    local tMoveLocation
                                    while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Assigning engineer for building action '..iActionToAssign..'; iEngiCount='..iEngiCount..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; tiActionOrder[iActionToAssign]='..(tiActionOrder[iActionToAssign] or 'nil')..'; sBlueprint='..sBlueprint..'; tBuildLocation='..repru(tBuildLocation)..'; Eng cur state='..M28UnitInfo.GetUnitState(tEngineersOfTechWanted[iEngiCount])) end
                                        --Is our order to build or assist?
                                        if tiActionOrder[iActionToAssign] then
                                            if tiActionOrder[iActionToAssign] == M28Orders.refiOrderIssueBuild then
                                                tMoveLocation = GetLocationToMoveForConstruction(tEngineersOfTechWanted[iEngiCount], tBuildLocation, sBlueprint, 0, false)
                                                if tMoveLocation then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Telling engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to move to '..repru(tMoveLocation)..' and then build '..sBlueprint..' at location '..repru(tBuildLocation)) end
                                                    M28Orders.IssueTrackedMoveAndBuild(tEngineersOfTechWanted[iEngiCount], tBuildLocation, sBlueprint, tMoveLocation, 1, false, sOrderRef)
                                                else
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Telling engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to build '..sBlueprint..' at build location '..repru(tBuildLocation)) end
                                                    M28Orders.IssueTrackedBuild(tEngineersOfTechWanted[iEngiCount], tBuildLocation, sBlueprint, false, sOrderRef)
                                                end
                                                TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, true, iCurPriority, nil, nil, bMarkAsSpare)
                                                UpdateBPTracking()
                                                --Mex specific - build a separate unit
                                                if iActionToAssign == refActionBuildMex and iTotalBuildPowerWanted > 0 and iEngiCount > 0 then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Were building a mex at tBuildLocation='..repru(tBuildLocation)..'; however have already assigned an engineer and have more to assign, so will build at a different mex now') end
                                                    --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerAction, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bNotYetUsedLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData, bCalledFromGetBestLocation, sBlueprintOverride)
                                                    sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted, iMaxSearchRange, iAdjacencyCategory, nil,                                false,                          nil,             nil,                                   false,                  tLZOrWZData,    tLZOrWZTeamData)
                                                    if M28Utilities.IsTableEmpty(tBuildLocation) then break end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': New mex build location='..repru(tBuildLocation)) end
                                                end
                                            else
                                                M28Utilities.ErrorHandler('Need to add code for actions that dont involve building, ActionToAssign='..iActionToAssign..'; order ref='..(tiActionOrder[iActionToAssign] or 'nil'))
                                            end
                                        else
                                            M28Utilities.ErrorHandler('Missing action order type for iActionToAssign '..iActionToAssign)
                                        end
                                    end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': Cant build the desired category so will stop trying to build it and reduce build power required') end
                                    iTotalBuildPowerWanted = 0
                                end
                            else
                                iTotalBuildPowerWanted = 0
                                if iOptionalFactionRequired then
                                    if not(tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted]) then tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted] = {} end
                                    tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted][iOptionalFactionRequired] = true
                                end
                            end
                        end
                    end
                end
            else --Dont have a category to search for
                --Order specific logic
                if iActionToAssign == refActionMoveToLandZone then
                    local iTargetLZ
                    local iPlateauToMoveTo
                    if bIsWaterZone then
                        iTargetLZ = vOptionalVariable[2]
                        iPlateauToMoveTo = vOptionalVariable[1]
                    else
                        iTargetLZ = vOptionalVariable
                        iPlateauToMoveTo = iPlateauOrPond
                    end
                    local tTargetLZ = M28Map.tAllPlateaus[iPlateauToMoveTo][M28Map.subrefPlateauLandZones][iTargetLZ]


                    sOrderRef = sOrderRef..'TLZ='..iTargetLZ
                    if M28Utilities.IsTableEmpty(tTargetLZ) then
                        M28Utilities.ErrorHandler('Invalid LZ  for moving to, iPlateauOrPOND='..iPlateauOrPond..'; iPlateauToMoveTo='..(iPlateauToMoveTo or 'nil')..'; will do reprs of iTargetLZ in log')
                        LOG(sFunctionRef..': Invalid LZ for moving to, iPlateauOrPond='..(iPlateauOrPond or 'nil')..'; iTargetLZ='..reprs(iTargetLZ)..'; vOptionalVariable='..reprs(vOptionalVariable))
                    else
                        local tMoveLocation = tTargetLZ[M28Map.subrefMidpoint]
                        while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to move to iPlateauOrPond '..iPlateauOrPond..'; iTargetLZ='..iTargetLZ)
                            end
                            M28Orders.IssueTrackedMove(tEngineersOfTechWanted[iEngiCount], tMoveLocation, 5, false, sOrderRef)
                            TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, {iPlateauToMoveTo, iTargetLZ}, nil, bMarkAsSpare)
                            UpdateBPTracking()
                        end
                    end
                elseif iActionToAssign == refActionMoveToWaterZone then
                    local iTargetWZ = vOptionalVariable
                    local iPond = M28Map.tiPondByWaterZone[iTargetWZ]
                    local tTargetWZ = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iTargetWZ]
                    sOrderRef = sOrderRef..'TWZ='..iTargetWZ
                    if M28Utilities.IsTableEmpty(tTargetWZ) then
                        M28Utilities.ErrorHandler('Invalid WZ  for moving to, iPlateauOrPond='..iPlateauOrPond..'; will do reprs of iTargetWZ in log')
                        LOG(sFunctionRef..': iTargetWZ='..reprs(iTargetWZ))
                    else
                        local tMoveLocation = tTargetWZ[M28Map.subrefMidpoint]
                        while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to move to iPlateauOrPond '..iPlateauOrPond..'; iTargetWZ='..iTargetWZ..'; iPond='..iPond)
                            end
                            M28Orders.IssueTrackedMove(tEngineersOfTechWanted[iEngiCount], tMoveLocation, 5, false, sOrderRef)
                            TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, nil, iTargetWZ, bMarkAsSpare)
                            UpdateBPTracking()
                        end
                    end
                elseif iActionToAssign == refActionAssistUpgrade then
                    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefActiveUpgrades]) then
                        M28Utilities.ErrorHandler('Trying to assist upgrade but there are none for this LZ')
                    else
                        local oBestProgress
                        if vOptionalVariable and M28UnitInfo.IsUnitValid(vOptionalVariable) then
                            oBestProgress = vOptionalVariable
                        else
                            local iBestProgress = 0
                            local iCurProgress
                            for iUnit, oUnit in tLZOrWZTeamData[M28Map.subrefActiveUpgrades] do
                                if M28UnitInfo.IsUnitValid(oUnit) and oUnit.GetWorkProgress then
                                    iCurProgress = (oUnit:GetWorkProgress() or 0)
                                    if iCurProgress > iBestProgress then
                                        iBestProgress = iCurProgress
                                        oBestProgress = oUnit
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iBestProgress='..iBestProgress..'; Is oBestProgress valid='..tostring(M28UnitInfo.IsUnitValid(oBestProgress))..'; Best progress ID='..(oBestProgress.UnitId or 'nil')..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                        if oBestProgress then
                            while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                if bDebugMessages == true then LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to assist unit '..oBestProgress.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestProgress)) end
                                M28Orders.IssueTrackedGuard(tEngineersOfTechWanted[iEngiCount], oBestProgress, false, sOrderRef)
                                TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, nil, nil, bMarkAsSpare)
                                UpdateBPTracking()
                            end
                        end
                    end
                elseif iActionToAssign == refActionReclaimArea then
                    local bWantEnergyNotMass = vOptionalVariable
                    while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                        if bDebugMessages == true then LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to reclaim nearby, iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                        --GetEngineerToReclaimNearbyArea(oEngineer,                       iPriorityOverride,   tLZOrWZTeamData, iPlateauOrPondOrPond, iLandOrWaterZone, bWantEnergyNotMass, bOnlyConsiderReclaimInRangeOfEngineer, iMinIndividualValueOverride, bIsWaterZone)
                        GetEngineerToReclaimNearbyArea(tEngineersOfTechWanted[iEngiCount], iCurPriority, tLZOrWZTeamData, iPlateauOrPond,           iLandOrWaterZone,      bWantEnergyNotMass, false, nil, bIsWaterZone)
                        UpdateBPTracking()
                    end
                elseif iActionToAssign == refActionReclaimFriendlyUnit or iActionToAssign == refActionReclaimEnemyUnit then
                    --Search for nearest unit in LZ units to be reclaimed
                    local iNearestUnitDist = 10000
                    local oNearestUnit
                    local iCurDist

                    local tUnitsToReclaim
                    if vOptionalVariable then
                        if M28Utilities.IsTableEmpty(tUnitsToReclaim, true) then
                            tUnitsToReclaim = {vOptionalVariable}
                        else
                            tUnitsToReclaim = vOptionalVariable
                        end
                    else
                        tUnitsToReclaim = tLZOrWZTeamData[M28Map.subreftoUnitsToReclaim]
                    end

                    if M28Utilities.IsTableEmpty(tUnitsToReclaim) then
                        M28Utilities.ErrorHandler('Want to reclaim a unit but no units in LZ to reclaim')
                    else
                        while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                            if bDebugMessages == true then LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to move to iPlateauOrPond '..iPlateauOrPond) end


                            local bAreDeadUnits = false
                            for iUnit, oUnit in tUnitsToReclaim do
                                if M28UnitInfo.IsUnitValid(oUnit) then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tEngineersOfTechWanted[iEngiCount]:GetPosition(), oUnit:GetPosition())
                                    if iCurDist < iNearestUnitDist then
                                        iNearestUnitDist = iCurDist
                                        oNearestUnit = oUnit
                                    end
                                else
                                    --Have dead units in the list of units to reclaim, so need to update the table
                                    if not(bAreDeadUnits) then
                                        bAreDeadUnits = true
                                        ForkThread(M28Economy.RefreshUnitsToReclaim, iTeam, iPlateauOrPond, iLandOrWaterZone)
                                    end
                                end
                            end

                            if oNearestUnit then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to reclaim oNearestUnit='..oNearestUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestUnit)) end
                                M28Orders.IssueTrackedReclaim(tEngineersOfTechWanted[iEngiCount], oNearestUnit, false, 'RecObs')
                                TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, nil, nil, bMarkAsSpare)
                                UpdateBPTracking()
                            else
                                break
                            end
                        end
                    end
                elseif iActionToAssign == refActionLoadOntoTransport then
                    if iTotalBuildPowerWanted > 0 and iEngiCount > 0 then
                        --Load onto first transport in LZ needing engis (max 1 engi per transport)]
                        for iTransport, oTransport in tLZOrWZTeamData[M28Map.reftoTransportsWaitingForEngineers] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Trying to load engi into transport, iEngiCount='..iEngiCount..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; oTransport='..oTransport.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTransport)..'; Engineer='..(tEngineersOfTechWanted[iEngiCount].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount]) or 'nil')..'; Transport engis wanted='..oTransport[M28Air.refiEngisWanted]..'; Transport cargo capacity='..M28Air.GetTransportEngiCargoAndRemainingCapacity(oTransport, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech])) end
                            M28Orders.IssueTrackedTransportLoad(tEngineersOfTechWanted[iEngiCount], oTransport, false, sOrderRef, false)
                            TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority) --(not using bmarkasspare as dont want to change orders for an engiener loading into transport)
                            UpdateBPTracking()
                            if bDebugMessages == true then LOG(sFunctionRef..': Post sending order to load onto transport, iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                            if iEngiCount <= 0 or iTotalBuildPowerWanted <= 0 then
                                break
                            end
                        end
                    end
                elseif iActionToAssign == refActionCaptureUnit then
                    local oUnitToCapture = vOptionalVariable
                    if bDebugMessages == true then LOG(sFunctionRef..': oUnitToCapture='..oUnitToCapture.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToCapture)..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                    while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                        if bDebugMessages == true then LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to capture unit '..oUnitToCapture.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToCapture)..'; iEngiCount='..iEngiCount..' unless it is already capturing') end
                        if not(tEngineersOfTechWanted[iEngiCount]:IsUnitState('Capturing')) then
                            M28Orders.IssueTrackedCapture(tEngineersOfTechWanted[iEngiCount], oUnitToCapture, false, 'Cap', false)
                        end
                        TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority) --(not using bmarkasspare since are capturing and dont want to abort part way through)
                        UpdateBPTracking()
                    end
                elseif iActionToAssign == refActionRepairUnit then
                    local oUnitToRepair = vOptionalVariable
                    while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                        if bDebugMessages == true then LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to repair nearby unit '..oUnitToRepair.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToRepair)..', iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                        M28Orders.IssueTrackedRepair(tEngineersOfTechWanted[iEngiCount], oUnitToRepair, false, 'Rep', false)
                        TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, nil, nil, bMarkAsSpare)
                        UpdateBPTracking()
                    end
                elseif iActionToAssign == refActionSpecialShieldDefence then
                    --Get list of units in zone that want defence and get the best faction they think is available
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of units for special shield protection empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]))) end
                    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) then
                        M28Utilities.ErrorHandler('Are trying to do special shield protection but have no units wanting it')
                    else
                        for iUnit, oUnit in tLZOrWZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
                            if oUnit[M28Building.refoNearbyFactoryOfFaction] then
                                iOptionalFactionRequired = M28UnitInfo.GetUnitFaction(oUnit)
                                break
                            end
                        end
                        if iOptionalFactionRequired then tEngineersOfTechWanted, iEngiCount = FilterEngineersOfTechAndEngiCountForFaction(iOptionalFactionRequired, tEngineersOfTechWanted) end
                        if iEngiCount > 0 then
                            while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                AssignEngineerToShieldDefenceDuty(tEngineersOfTechWanted[iEngiCount], tLZOrWZTeamData)
                                if bDebugMessages == true then LOG(sFunctionRef..': Have just assigned engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to do special shield protection logic, will now update tracking of that engineer') end
                                --TRACKING NOTE - this will get cleared so the ActiveShieldMonitor will then impute backup values - i.e. changes made to below are unlikely to have an effect
                                TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, nil, nil, bMarkAsSpare)
                                UpdateBPTracking()
                            end
                        else
                            iTotalBuildPowerWanted = 0
                            if iOptionalFactionRequired then
                                --Flag that we need engineers of the desired faction
                                if not(tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted]) then tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted] = {} end
                                tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted][iOptionalFactionRequired] = true
                            end
                        end
                    end

                else
                    if not(aiBrain[M28Overseer.refbCloseToUnitCap]) then
                        M28Utilities.ErrorHandler('Unrecognised order, need to add logic, iActionToAssign='..(iActionToAssign or 'nil'))
                    end
                    iTotalBuildPowerWanted = 0
                end
            end
        end

        --If we still have build power we want to assign, record in the land zone
        if bDebugMessages == true then LOG(sFunctionRef..': About to update BP wanted for iPlateauOrPond'..iPlateauOrPond..'; iLandOrWaterZone='..iLandOrWaterZone..'; iTeam='..iTeam..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; tLZBuildPowerByTechWanted before update='..repru(tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted])) end
        if iTotalBuildPowerWanted > 0 and not(bDontIncreaseLZBPWanted) then
            local iAdditionalBuildPowerWanted
            if not(tLZOrWZTeamData[M28Map.subreftiBPWantedByAction][iActionToAssign]) then
                iAdditionalBuildPowerWanted = iTotalBuildPowerWanted
            else
                if bBPIsInAdditionToExisting then
                    iAdditionalBuildPowerWanted = iTotalBuildPowerWanted
                    iTotalBuildPowerWanted = tLZOrWZTeamData[M28Map.subreftiBPWantedByAction][iActionToAssign] + iTotalBuildPowerWanted
                else
                    iAdditionalBuildPowerWanted = math.max(0, iTotalBuildPowerWanted - tLZOrWZTeamData[M28Map.subreftiBPWantedByAction][iActionToAssign])
                end
            end
            if iAdditionalBuildPowerWanted > 0 then
                tLZOrWZTeamData[M28Map.subreftiBPWantedByAction][iActionToAssign] = iTotalBuildPowerWanted
                tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iMinTechWanted] = (tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iMinTechWanted] or 0) + iTotalBuildPowerWanted
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    for iTech = 3, 1, -1 do
        if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[iTech]) == false then
            return iTech
        end
    end
    return 0
end

function UpdateSpareEngineerNumber(tLZOrWZTeamData, toAvailableEngineersByTech)
    --Intended to be called after running all engineer builder logic for the LZ
    tLZOrWZTeamData[M28Map.subrefSpareBPByTech] = {[1]=0, [2]=0,[3]=0}
    local iTotalBP
    for iTech = 1, 3, 1 do
        if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[iTech]) == false then
            iTotalBP = 0
            for iUnit, oUnit in toAvailableEngineersByTech[iTech] do
                iTotalBP = iTotalBP + oUnit:GetBlueprint().Economy.BuildRate
                if M28Config.M28ShowUnitNames then M28Orders.UpdateUnitNameForOrder(oUnit, 'Idle') end
            end
            tLZOrWZTeamData[M28Map.subrefSpareBPByTech][iTech] = iTotalBP
        end
    end
end

function GetBPToAssignToSMD(iPlateau, iLandZone, iTeam, tLZTeamData, bCoreZone, bHaveLowMass, bWantMorePower)
    --Returns BP to assign, and whether it should be assigned to assist the SMD (returns true) rather than building a new SMD
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPToAssignToSMD'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iBPWanted = 0
    local bAssistSMD = false
    --Does this LZ have enough value?
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want SMD for iPlateau '..iPlateau..'; iLandZone '..iLandZone..'; LZ building vlaue='..(tLZTeamData[M28Map.subrefLZSValue] or 'nil')) end
    if tLZTeamData[M28Map.subrefLZSValue] >= 11000 or tLZTeamData[M28Map.reftObjectiveSMDLocation] then
        local tSMD = EntityCategoryFilterDown(M28UnitInfo.refCategorySMD, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local iSMDsWeHave = 0
        local iSMDsWithNoMissiles = 0
        local iUnderConstructionSMD = 0
        if M28Utilities.IsTableEmpty(tSMD) == false then
            for iSMDNumber, oSMD in tSMD do
                --Check we've completed construction
                if M28UnitInfo.IsUnitValid(oSMD) then
                    if bDebugMessages == true then LOG(sFunctionRef .. ': Have an SMD '..oSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSMD)..', will check if its completed construction; fraction complete='..oSMD:GetFractionComplete()..'; Ammo count='..oSMD:GetTacticalSiloAmmoCount()..'; oSMD[M28Building.refbMissileRecentlyBuilt]='..tostring(oSMD[M28Building.refbMissileRecentlyBuilt] or false)) end
                    if oSMD:GetFractionComplete() == 1 then
                        iSMDsWeHave = iSMDsWeHave + 1
                        if oSMD.GetTacticalSiloAmmoCount and oSMD:GetTacticalSiloAmmoCount() < 1 and not (oSMD[M28Building.refbMissileRecentlyBuilt]) then
                            iSMDsWithNoMissiles = iSMDsWithNoMissiles + 1
                            if bDebugMessages == true then LOG(sFunctionRef..': SMD has no missile, iSMDsWithNoMissiles='..iSMDsWithNoMissiles) end
                        end
                    else
                        iUnderConstructionSMD = iUnderConstructionSMD + 1
                    end
                end
            end
        end
        local iEnemyNukes = 0 --Cant use table.getn
        local iEnemyBattleshipNukes = 0
        local iEnemyNormalNukes = 0
        local bEnemyNukeNotConstructed = true
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false then
            for iNuke, oNuke in M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers] do
                if EntityCategoryContains(categories.BATTLESHIP, oNuke.UnitId) then
                    iEnemyBattleshipNukes = iEnemyBattleshipNukes + 1
                elseif EntityCategoryContains(categories.EXPERIMENTAL, oNuke.UnitId) then
                    iEnemyNormalNukes = iEnemyNormalNukes + 8
                else
                    iEnemyNormalNukes = iEnemyNormalNukes + 1
                end
                if oNuke:GetFractionComplete() >= 0.95 then
                    bEnemyNukeNotConstructed = false
                end
            end
        elseif bDebugMessages == true then
            LOG(sFunctionRef .. ': No SML detected but will build SMD anyway as a precaution as we have a good economy')
        end
        if iEnemyBattleshipNukes > 0 and iEnemyNormalNukes == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 500 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 300 or M28Map.bIsCampaignmap) then
            iEnemyNukes = 0
        else
            iEnemyNukes = math.max(iEnemyNormalNukes, iEnemyBattleshipNukes * 0.2, 1) --Redundancy - if table isnt empty enemy must have at least one, and will assume they have 1 if we are building as a precaution
        end
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': iSMDsWeHave=' .. iSMDsWeHave .. '; iEnemyNukes=' .. iEnemyNukes..'; iEnemyNormalNukes='..iEnemyNormalNukes..'; iEnemyBattleshipNukes='..iEnemyBattleshipNukes..'; bEnemyNukeNotConstructed='..tostring(bEnemyNukeNotConstructed))
            if iEnemyNukes > 1 then
                LOG(sFunctionRef .. ': Will now list out each nuke unit ID')
                for iNuke, oNuke in M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers] do
                    LOG(sFunctionRef .. ': iNuke=' .. iNuke .. '; oNuke=' .. oNuke.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oNuke))
                end
            end
        end
        local iSMDWanted = math.min(iEnemyNukes, math.max(1, math.floor((M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) / 5)))
        if bHaveLowMass then
            iSMDWanted = math.min( iEnemyNukes * 2 / 3, iSMDWanted)
            if iEnemyNukes <= 5 then iSMDWanted = math.min(iSMDWanted, 3) end
        end
        --Cap amount of SMD, in turn depending on enemy nuke size
        if iEnemyNukes >= 5 and tLZTeamData[M28Map.subrefLZSValue] >= 12000 * iEnemyNukes then iSMDWanted = math.min(8, iSMDWanted)
        else iSMDWanted = math.min(4, iSMDWanted)
        end

        if iSMDWanted <= 0 and tLZTeamData[M28Map.reftObjectiveSMDLocation] then iSMDWanted = 1 end
        if bDebugMessages == true then LOG(sFunctionRef..': iSMDsWeHave='..iSMDsWeHave..'; iSMDWanted='..iSMDWanted..'; iSMDsWithNoMissiles='..iSMDsWithNoMissiles) end
        if iSMDsWeHave < iSMDWanted or iSMDsWithNoMissiles > 0 then
            if bHaveLowMass or iSMDsWeHave > 0 then iBPWanted = 150
            elseif bWantMorePower then iBPWanted = 225
            else iBPWanted = 300 end
            if not(bCoreZone) then iBPWanted = iBPWanted * 0.5 end
        end
        if iSMDsWithNoMissiles > 0 and (iSMDsWeHave >= iSMDWanted or iSMDsWeHave == iSMDsWithNoMissiles) and iUnderConstructionSMD ==0 then
            --If have under construction SMD then finish it off
            bAssistSMD = true
            iBPWanted = math.max(150, iBPWanted * 3)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iBPWanted='..(iBPWanted or 'nil')..'; bAssistSMD='..tostring(bAssistSMD)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBPWanted, bAssistSMD
end

function GetBPToAssignToMassStorage(iPlateauOrZero, iLandOrWaterZone, iTeam, tLZOrWZData, tLZOrWZTeamData, bCoreZone, bHaveLowMass, bWantMorePower)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPToAssignToMassStorage'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iBPWanted = 0
    --Are all mexes in the LZ at T2+ or do we have any T3 mexes in the LZ?
    if bDebugMessages == true then LOG(sFunctionRef..': iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; T2+T3 mex count='..tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3]..'; T1 mex count='..tLZOrWZTeamData[M28Map.subrefMexCountByTech][1]..'; Is table of mass storage locations to build empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable]))..'; Size of mex table='..table.getn(tLZOrWZData[M28Map.subrefLZMexLocations])) end
    if tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] > 0 and (tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] == 0 or tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] >= 4) then
        --Do we have empty locations for mass storage?
        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable]) == false then
            --Do we have really low power?
            if not(bWantMorePower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] < 0.5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < 0) then

                iBPWanted = 10
                if not (bHaveLowMass) or tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] > 0 then
                    iBPWanted = iBPWanted + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
                    if not (bWantMorePower) then
                        iBPWanted = iBPWanted + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2
                    end
                else
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 50 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0 then
                        iBPWanted = iBPWanted + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 0.5
                    end
                end
            elseif tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 50 then
                iBPWanted = 5
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iBPWanted='..iBPWanted) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBPWanted
end

function GetBPToAssignToAssistUpgrade(tLZTeamData, iTeam, bCoreZone, bHaveLowMass, bHaveLowPower, bWantMorePower)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPToAssignToAssistUpgrade'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iBPWanted = 0

    if bDebugMessages == true then LOG(sFunctionRef..': Considering if any active upgrades we want to assist; Is table of upgrades empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]))..'; ='..tostring(bWantMorePower)..'; Have low power='..tostring(M28Conditions.HaveLowPower(iTeam))..'; bHaveLowMass='..tostring(bHaveLowMass)..'; bHaveLowPower='..tostring(bHaveLowPower)) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false and (not(bHaveLowPower) or (not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] >= 0.9 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 7))) then
        if not(bWantMorePower) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] > 0.8 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > 2) then
            if bCoreZone then iBPWanted = 5 end
            if not(bHaveLowPower) then
                if not (bHaveLowMass) then
                    iBPWanted = iBPWanted + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2
                    if not (bWantMorePower) then
                        iBPWanted = iBPWanted + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2
                    end
                else
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 50 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0 then
                        iBPWanted = iBPWanted + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
                    end
                end
            end
            if not(bCoreZone) and iBPWanted > 5 then iBPWanted = math.min(25, iBPWanted * 0.5) end
        end
        --Increase assistance if we have lots of upgrades
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] >= 0.95 and not(bHaveLowPower) then
            if table.getn(tLZTeamData[M28Map.subrefActiveUpgrades]) >= 3 then iBPWanted = iBPWanted * 2
            elseif table.getn(tLZTeamData[M28Map.subrefActiveUpgrades]) == 2 then iBPWanted = iBPWanted * 1.25
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef .. ': iBPWanted=' .. iBPWanted) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBPWanted
end

function GetBPForShieldAssistance(tLZTeamData, iTeam)
    --Assist shields to defend against arti
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPForShieldAssistance'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iBPWanted = 0
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for game time='..GetGameTimeSeconds()..'; Are we defending against arti='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti])) end
    if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] then
        M28Building.RecordPriorityShields(iTeam, tLZTeamData)
        if bDebugMessages == true then LOG(sFunctionRef..': Is the table of priority shields empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]))) end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]) == false then
            local iEnemyT3ArtiValue = 0
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure]) == false then
                for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure] do
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        if EntityCategoryContains(M28UnitInfo.refCategoryNovaxCentre, oUnit.UnitId) then
                            if oUnit:GetFractionComplete() >= 0.5 then
                                iEnemyT3ArtiValue = iEnemyT3ArtiValue + 0.5
                            else
                                iEnemyT3ArtiValue = iEnemyT3ArtiValue + 0.25
                            end

                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, oUnit.UnitId) then
                            if oUnit:GetFractionComplete() >= 0.5 then
                                iEnemyT3ArtiValue = iEnemyT3ArtiValue + 1
                            else
                                if oUnit:GetFractionComplete() >= 0.25 then
                                    iEnemyT3ArtiValue = iEnemyT3ArtiValue + 0.5
                                else
                                    iEnemyT3ArtiValue = iEnemyT3ArtiValue + 0.25
                                end
                            end
                        end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyMobileSatellites]) == false then
                local iNovaxCount = 0
                for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyMobileSatellites] do
                    iNovaxCount = iNovaxCount + 1
                end
                iEnemyT3ArtiValue = math.max(iEnemyT3ArtiValue, iNovaxCount * 0.5)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is the table of enemy arti empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure]))..'; iEnemyT3ArtiValue='..iEnemyT3ArtiValue..'; number of priority shields for thie LZ='..table.getn(tLZTeamData[M28Map.reftPriorityShieldsToAssist])) end
            local iShieldsWantingAssistance = 0
            local iShieldsRecentlyDamaged = 0
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.5 then
                iShieldsWantingAssistance = table.getn(tLZTeamData[M28Map.reftPriorityShieldsToAssist])
            else
                local iCurShield, iMaxShield
                local bHaveRecentlyDamagedShields = false

                for iShield, oShield in tLZTeamData[M28Map.reftPriorityShieldsToAssist] do
                    if M28UnitInfo.IsUnitValid(oShield) then
                        iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                        if iCurShield > 0 then
                            if iCurShield < iMaxShield then
                                iShieldsRecentlyDamaged = iShieldsRecentlyDamaged + 1
                            else
                                --How long since shield took damage?
                                if oShield[M28UnitInfo.refiTimeLastDamaged] and GetGameTimeSeconds() - (oShield[M28UnitInfo.refiTimeLastDamaged] or -100) <= 40 then
                                    iShieldsRecentlyDamaged = iShieldsRecentlyDamaged + 1
                                end
                            end
                        end
                    end
                end
                if iShieldsRecentlyDamaged > 0 then
                    local iTotalShields = table.getn(tLZTeamData[M28Map.reftPriorityShieldsToAssist])
                    if iTotalShields < iShieldsRecentlyDamaged then
                        iShieldsWantingAssistance = iShieldsRecentlyDamaged + (iTotalShields - iShieldsRecentlyDamaged) * 0.5
                    else
                        iShieldsWantingAssistance = iShieldsRecentlyDamaged
                    end
                end
                if tLZTeamData[M28Map.subrefLZbCoreBase] then iShieldsWantingAssistance = math.max(iShieldsWantingAssistance, 0.6) end

            end
            --Reduce BP for shield assistance if we have lots of mass - i.e. in late game scenario better to spend mass than to assist a full health shield
            iBPWanted = iShieldsWantingAssistance * math.max(120, math.min(780, (360 * iEnemyT3ArtiValue)))

        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iBPWanted='..iBPWanted) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBPWanted
end

function GetBPMinTechAndUnitForFixedShields(tLZTeamData, iTeam, bCoreZone, bHaveLowMass, bWantMorePower, bConsideringSecondShield, iLandZoneRef, iPlateau)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPMinTechAndUnitForFixedShields'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iBPWanted = 0
    local iTechLevelWanted = 2
    local oUnitToShield
    local iHighestMassValue = 0
    local iHighMassThreshold = 15000
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; Is table of units wanting fixed shields empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitWantingFixedShield]))..'; bConsideringSecondShield='..tostring(bConsideringSecondShield or false)) end
    if M28Conditions.IsTableOfUnitsStillValid(tLZTeamData[M28Map.reftoLZUnitWantingFixedShield]) then
        --Early in a campaign (less than 20m in) - dont get shield if dont have good mass, unless on Aeon mission 5 where need to build shields to defend civilians
        local bGetShield = true
        if M28Map.bIsCampaignMap then
            if bHaveLowMass and GetGameTimeSeconds() <= 1200 and not(ScenarioInfo.Ariel and ScenarioInfo.UEF and ScenarioInfo.Colonies) then --First 20m
                --Does enemy have a >=60% complete arti, and game is at least 10m old?
                if GetGameTimeSeconds() >= 600 then
                    if M28Conditions.GetT3ArtiEquivalent(iTeam, 1, 0, false, 0.6) > 0 then
                        bGetShield = true
                    else
                        bGetShield = false
                    end
                else
                    bGetShield = false
                end
            end
        else
            --Not a campaign map - dont get a shield if we have a low lifetime experimental count on our team and low mass
            if not(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) and (bHaveLowMass or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 25 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                if (bHaveLowMass and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 20) then
                    bGetShield = false
                elseif M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryExperimentalLevel) < (1 + 0.5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                    bGetShield = false
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bGetShield='..tostring(bGetShield)) end
        if bGetShield then

            --Shield the highest value unit in this LZ that wants a shield, factoring in failed shield attempts
            if bConsideringSecondShield then iHighestMassValue = iHighMassThreshold end --will only try shielding if we have very high value target (e.g. t3 arti or experimental) that is unshielded
            local iCurMass
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            local iLowestShieldAttempt = 10 --dont want to keep trying to shield if have failed lots of times (the count gets reset over time)
            for iUnit, oUnit in tLZTeamData[M28Map.reftoLZUnitWantingFixedShield] do
                --Increase likelihood the build location we want is available
                SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateau, iLandZoneRef, 10)
                if (oUnit[refiFailedShieldConstructionCount] or 0) <= iLowestShieldAttempt then
                    iCurMass = oUnit:GetBlueprint().Economy.BuildCostMass
                    if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; iCurMass='..reprs(iCurMass)..'; iHighestMassValue='..reprs(iHighestMassValue)..'; (oUnit[refiFailedShieldConstructionCount]='..reprs(oUnit[refiFailedShieldConstructionCount])..'; iLowestShieldAttempt='..reprs(iLowestShieldAttempt)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Build cost mass via blueprint='..(__blueprints[oUnit.UnitId].Economy.BuildCostMass or 'nil')) end
                    if iCurMass and (iCurMass > iHighestMassValue or (oUnit[refiFailedShieldConstructionCount] or 0) < iLowestShieldAttempt) then
                        --Check we are likely to be able ot build a shield nearby
                        if (oUnit[refiFailedShieldBuildDistance] or 0) <= 17 then --Cybran ED4 has a readius of 17
                            iHighestMassValue = iCurMass
                            oUnitToShield = oUnit
                            iLowestShieldAttempt = (oUnit[refiFailedShieldConstructionCount] or 0)
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurMass='..(iCurMass or 'nil')..'; iHighestMassValue='..(iHighestMassValue or 'nil')..'; Failed shield build distance='..(oUnit[refiFailedShieldBuildDistance] or 0)) end
            end
            if oUnitToShield then
                if iHighestMassValue >= iHighMassThreshold or M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 12000 then
                    iTechLevelWanted = 3
                    --Think have logic elsewhere which will make a T3 shield be built if nowhere for T2 shield that will cover it

                end
                iBPWanted = 210
                if bCoreZone or iHighestMassValue >= 25000 then iBPWanted = iBPWanted + 60 end
                if bWantMorePower then iBPWanted = iBPWanted * 0.75 end
                if bHaveLowMass then iBPWanted = iBPWanted * 0.75 end
                if bDebugMessages == true then LOG(sFunctionRef..': Have a unit to shield, bCoreZone='..tostring(bCoreZone or false)..'; M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or false)..'; bWantMorePower='..tostring(bWantMorePower)..'; bHaveLowMass='..tostring(bHaveLowMass)..'; iBPWanted='..iBPWanted) end
            end
        end
    end
    if oUnitToShield and (oUnitToShield[refiFailedShieldBuildDistance] or 0) > 0 then iTechLevelWanted = 3 end
    if bDebugMessages == true then LOG(sFunctionRef..': oUnitToShield='..(oUnitToShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitToShield) or 'nil')..'; iBPWanted='..iBPWanted..'; iTechLevelWanted='..iTechLevelWanted..'; iHighestMassValue='..iHighestMassValue) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBPWanted, iTechLevelWanted, oUnitToShield
end

function GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateau, iLandZone, bOptionalReturnMassToCompleteOtherZoneUnderConstruction, iOptionalSearchRange, iOptionalCategoryFilter)
    --returns two variables, the first is true/false if iLandZone has a queued experimental to build; the second is the number of other land zones for iTeam that have queued experimentals to build
    --Optional variables are all for if bOptionalReturnMassToCompleteOtherZoneUnderConstruction is true, except for iOptionalCategoryFilter
    --bOptionalReturnMassToCompleteOtherZoneUnderConstruction will return the amount of mass needed to complete all under construction experimentals in other zones
    --iOptionalSearchRange Will only include those within iOptionalSearchRange
    --iOptionalCategoryFilter - if specified, then will only count engineers who are building or are queued to build a unit meeting this category (will include everything if nil)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetExperimentalsBeingBuiltInThisAndOtherLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bHaveExperimentalForThisLandZone = false
    local iOtherLandZonesWithExperimental = 0
    local iMassToComplete
    if bOptionalReturnMassToCompleteOtherZoneUnderConstruction then iMassToComplete = 0 end

    if bDebugMessages == true then LOG(sFunctionRef..': Is table of engis building exp empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]))..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; Time='..GetGameTimeSeconds()) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]) == false then
        local tiPlateauAndLZBuildingExperimental = {}
        local toUnderConstructionExperimentalsInOtherZonesByUnitRef = {}
        local iCurPlateau, iCurLZ
        local bIncludeCurEntry
        local sCurBPBeingBuilt
        for iEngi, oEngi in M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals] do
            if M28UnitInfo.IsUnitValid(oEngi) and oEngi[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam] then
                iCurPlateau = oEngi[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1]
                iCurLZ = oEngi[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]
                bIncludeCurEntry = nil
                if bDebugMessages == true then LOG(sFunctionRef..': Considering engineer '..oEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngi)..'; iCurPlateau='..(iCurPlateau or 'nil')..'; iCurLZ='..(iCurLZ or 'nil')..'; Engi last order blueprint='..(oEngi[M28Orders.reftiLastOrders][(oEngi[M28Orders.refiOrderCount] or 1)][M28Orders.subrefsOrderBlueprint] or 'nil')..'; Engi last order reprs='..reprs(oEngi[M28Orders.reftiLastOrders])..'; is primary engineer='..tostring(oEngi[refbPrimaryBuilder] or false))
                    local oEngiOrderTarget = oEngi[M28Orders.reftiLastOrders][(oEngi[M28Orders.refiOrderCount] or 1)][M28Orders.subrefoOrderUnitTarget]
                    if M28UnitInfo.IsUnitValid(oEngiOrderTarget) then
                        LOG(sFunctionRef..': oEngiOrderTarget='..oEngiOrderTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngiOrderTarget)..'; Fraction complete='..oEngiOrderTarget:GetFractionComplete())
                        local oOrderTargetFocus = oEngiOrderTarget:GetFocusUnit()
                        if M28UnitInfo.IsUnitValid(oOrderTargetFocus) then
                            LOG(sFunctionRef..': oOrderTargetFocus='..oOrderTargetFocus.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOrderTargetFocus)..'; fraction complete='..oOrderTargetFocus:GetFractionComplete())
                        end
                    end
                end
                if bOptionalReturnMassToCompleteOtherZoneUnderConstruction then --Check if want to include this
                    if not(iCurLZ == iLandZone and iPlateau == iCurPlateau) then
                        bIncludeCurEntry = false
                        local oCurExperimental = oEngi:GetFocusUnit()
                        if oCurExperimental and oCurExperimental:GetFractionComplete() < 1 then
                            if not(iOptionalCategoryFilter) or EntityCategoryContains(iOptionalCategoryFilter, oCurExperimental.UnitId) then
                                if not(toUnderConstructionExperimentalsInOtherZonesByUnitRef[oCurExperimental.EntityId]) then
                                    bIncludeCurEntry = true
                                    toUnderConstructionExperimentalsInOtherZonesByUnitRef[oCurExperimental.EntityId] = oCurExperimental
                                end
                            end
                        end
                    end
                end
                if not(iOptionalCategoryFilter) then
                    bIncludeCurEntry = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have an optional category filter o will include this zone as building an experimental') end
                elseif bIncludeCurEntry == nil then
                    sCurBPBeingBuilt = oEngi[M28Orders.reftiLastOrders][(oEngi[M28Orders.refiOrderCount] or 1)][M28Orders.subrefsOrderBlueprint]
                    if bDebugMessages == true then LOG(sFunctionRef..': sCurBPBeingBuilt='..(sCurBPBeingBuilt or 'nil')) end
                    if sCurBPBeingBuilt and EntityCategoryContains(iOptionalCategoryFilter, sCurBPBeingBuilt) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Are queued up to be building a unit of the specified category so will include this zone as building an experimental') end
                        bIncludeCurEntry = true
                    else
                        local oCurExperimental = oEngi:GetFocusUnit()
                        if oCurExperimental and oCurExperimental:GetFractionComplete() < 1 and EntityCategoryContains(iOptionalCategoryFilter, oCurExperimental.UnitId) then
                            bIncludeCurEntry = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Engi is actively building the experimental' ..oCurExperimental.UnitId..M28UnitInfo.GetUnitLifetimeCount(oCurExperimental)) end
                        end
                    end
                end
                if bIncludeCurEntry then
                    if not(tiPlateauAndLZBuildingExperimental[iCurPlateau]) then tiPlateauAndLZBuildingExperimental[iCurPlateau] = {} end
                    tiPlateauAndLZBuildingExperimental[iCurPlateau][iCurLZ] = (tiPlateauAndLZBuildingExperimental[iCurPlateau][iCurLZ] or 0) + 1
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is tiPlateauAndLZBuildingExperimental empty='..tostring(M28Utilities.IsTableEmpty(tiPlateauAndLZBuildingExperimental))..'; reprs='..reprs(tiPlateauAndLZBuildingExperimental)) end
        if M28Utilities.IsTableEmpty(tiPlateauAndLZBuildingExperimental) == false then
            for iAssignedPlateau, tEngineersByLZ in tiPlateauAndLZBuildingExperimental do
                for iAssignedLZ, iEngineersAssigned in tEngineersByLZ do
                    if iPlateau == iAssignedPlateau and iLandZone == iAssignedLZ then
                        bHaveExperimentalForThisLandZone = true
                    else
                        iOtherLandZonesWithExperimental = iOtherLandZonesWithExperimental + 1
                    end
                end
            end
        end
        if bOptionalReturnMassToCompleteOtherZoneUnderConstruction and M28Utilities.IsTableEmpty(toUnderConstructionExperimentalsInOtherZonesByUnitRef) == false then
            local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
            for iUnit, oUnit in toUnderConstructionExperimentalsInOtherZonesByUnitRef do
                if not(iOptionalSearchRange) or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= iOptionalSearchRange then
                    iMassToComplete = iMassToComplete + (oUnit:GetBlueprint().Economy.BuildCostMass or 0) * (1 - oUnit:GetFractionComplete())
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iOtherLandZonesWithExperimental='..iOtherLandZonesWithExperimental..'; iMassToComplete='..(iMassToComplete or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bHaveExperimentalForThisLandZone, iOtherLandZonesWithExperimental, iMassToComplete
end

function GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, iAdjLZ, iPathingRef, iHighestTechEngiAvailable, bNearbyZone, bIslandPathing, bRequireUnbuiltMexes)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPByTechWantedForAlternativeLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tiBPWantedByTech
    local tAltLZ = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
    if not(M28Map.bIsCampaignMap) or M28Conditions.IsLocationInPlayableArea(tAltLZ[M28Map.subrefMidpoint]) or M28Team.tTeamData[iTeam][M28Team.rebTeamOnlyHasCampaignAI] then
        local tAltLZTeamData = tAltLZ[M28Map.subrefLZTeamData][iTeam]
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Does iAdjLZ '..iAdjLZ..' for plateau '..iPlateau..' want BP='..tostring(tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP])..'; bIslandPathing='..tostring(bIslandPathing or false)..'; base tLZData[M28Map.subrefLZIslandRef]='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..'; iAdjLZ tAltLZ[M28Map.subrefLZIslandRef]='..(tAltLZ[M28Map.subrefLZIslandRef] or 'nil')..'; Is table of unbuilt mexes empty='..tostring(M28Utilities.IsTableEmpty(tAltLZ[M28Map.subrefMexUnbuiltLocations]))..'; bRequireUnbuiltMexes='..tostring(bRequireUnbuiltMexes or false)) end
        if not(bRequireUnbuiltMexes) or (M28Utilities.IsTableEmpty(tAltLZ[M28Map.subrefMexUnbuiltLocations]) == false and (not(tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase]) or M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryEngineer, tAltLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))) then
            local iTotalBPWanted = 0
            --Do we need unbuilt mexes?


            --Does the LZ want BP?
            if tAltLZTeamData[M28Map.subrefTbWantBP] or bIslandPathing then
                --Do we have engis of the right tech level to give to the LZ? (ignore this check if we are trying to move engineers to an island for which the closest LZ doesnt want engineers
                local bHaveSufficientTech = false
                if tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP] then
                    for iTech = 1, iHighestTechEngiAvailable, 1 do
                        if (tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][iTech] or 0) > 0 then
                            bHaveSufficientTech = true
                            break
                        end
                    end
                end

                if bHaveSufficientTech or (bIslandPathing and not(tLZData[M28Map.subrefLZIslandRef] == tAltLZ[M28Map.subrefLZIslandRef])) then
                    --Would we path through any dangerous LZs?
                    if M28Land.IsLandZonePathSafe(iPlateau, tLZData, iTeam, iPathingRef, bIslandPathing) then
                        tiBPWantedByTech = {[1]=0,[2]=0,[3]=0}
                        if not(bIslandPathing) or bHaveSufficientTech then
                            for iTech = 1, iHighestTechEngiAvailable, 1 do
                                if (tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][iTech] or 0) > 0 then
                                    tiBPWantedByTech[iTech] = tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][iTech]
                                    iTotalBPWanted = iTotalBPWanted + tiBPWantedByTech[iTech]
                                end
                            end
                        else
                            for iEntry, iIslandLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][tAltLZ[M28Map.subrefLZIslandRef]] do
                                local tAltLZ = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iIslandLZ]
                                if tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP] and M28Utilities.IsTableEmpty(tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEngineersTravelingHere]) then
                                    for iTech = 1, iHighestTechEngiAvailable, 1 do
                                        if (tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][iTech] or 0) > 0 then
                                            tiBPWantedByTech[iTech] = tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][iTech]
                                            iTotalBPWanted = iTotalBPWanted + tiBPWantedByTech[iTech]
                                            if iTotalBPWanted >= math.min(25, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tAltLZ[M28Map.subrefLZIslandRef]] * 5) then
                                                break
                                            end
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if iIslandLZ '..iIslandLZ..' wants BP='..tostring(tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP])..'; Island mex count='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tAltLZ[M28Map.subrefLZIslandRef]]..'; LZ mex count='..tAltLZ[M28Map.subrefLZMexCount]..'; iTotalBPWanted after considering this islandLZ='..iTotalBPWanted) end
                            end
                        end
                    end
                end
            end



            --Override - for core land zones dont want any BP from a non-adjacent zone in certain cases
            if bIslandPathing or (not(bNearbyZone) and tiBPWantedByTech and tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase]) then

                local iBPToAssign

                if bIslandPathing then
                    iBPToAssign = math.min(iTotalBPWanted, 25, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tAltLZ[M28Map.subrefLZIslandRef]] * 5)
                else
                    if M28Utilities.IsTableEmpty(tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEngineersTravelingHere]) then
                        iBPToAssign = math.max(5, iTotalBPWanted - 3 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]])
                    else
                        iBPToAssign = math.max(0, iTotalBPWanted - 3 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]])
                    end
                end
                if iBPToAssign < iTotalBPWanted then
                    local iBPToIgnore = iTotalBPWanted - iBPToAssign
                    local iCurBPToIgnore
                    local iRevisedBPWanted = 0
                    for iTech, iBuildPowerWanted in tiBPWantedByTech do
                        iCurBPToIgnore = math.min(iBuildPowerWanted, iBPToIgnore)
                        tiBPWantedByTech[iTech] = tiBPWantedByTech[iTech] - iCurBPToIgnore
                        iBPToIgnore = iBPToIgnore - iCurBPToIgnore
                        iRevisedBPWanted = iRevisedBPWanted + tiBPWantedByTech[iTech]
                    end
                    if iRevisedBPWanted == 0 then
                        tiBPWantedByTech = nil
                        if bDebugMessages == true then LOG(sFunctionRef..': Have reduced BP wanted by tech for iAdjZone='..iAdjLZ..'; iTotalBPWanted='..iTotalBPWanted..'; iRevisedBPWanted='..iRevisedBPWanted) end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iAdjLZ='..iAdjLZ..'; tiBPWantedByTech='..repru(tiBPWantedByTech)) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tiBPWantedByTech
end

function GetEngisWantedForTransports(tLZTeamData)
    local iTransports = table.getn(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers])
    local iEngisWanted = 0
    for iEntry = iTransports, 1, -1 do
        if not(M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers][iEntry])) or (tLZTeamData[M28Map.reftoTransportsWaitingForEngineers][iEntry][M28Air.refiEngisWanted] or 0) <= 0 then
            table.remove(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers], iEntry)
        else
            iEngisWanted = iEngisWanted + tLZTeamData[M28Map.reftoTransportsWaitingForEngineers][iEntry][M28Air.refiEngisWanted]
        end
    end
    return iEngisWanted
end

function GetZoneAndFactionForPriorityEngineerTravel(tBaseLZTeamData, iTeam, iBaseLandZone, iBasePlateau)
    local iZoneWantingEngineer, iFactionWanted
    for iFactory, oFactory in tBaseLZTeamData[M28Map.reftFactoriesWantedForEngineers] do
        if M28Utilities.IsTableEmpty(oFactory[M28Building.reftoUnitsWantingFactoryEngineers]) == false then
            --Do we already have at least 3 engineers of this factory's faction in the zone that the gameender is in?
            local iFactionRef = M28UnitInfo.GetUnitFaction(oFactory)
            for iUnit, oUnit in oFactory[M28Building.reftoUnitsWantingFactoryEngineers] do
                if M28UnitInfo.IsUnitValid(oUnit) then
                    local iGameEnderPlateau, iGameEnderZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                    local tLZTeamData = M28Map.tAllPlateaus[iGameEnderPlateau][M28Map.subrefPlateauLandZones][iGameEnderZone][M28Map.subrefLZTeamData][iTeam]
                    if tLZTeamData[M28Map.subreftbBPByFactionWanted][iFactionRef] then
                        if  iBasePlateau == iGameEnderPlateau and not(iGameEnderZone == iBaseLandZone) then
                            --How many T3 engineers of this faction do we have traveling to this zone already?
                            local iEngiCatWanted = M28UnitInfo.refCategoryEngineer * categories.TECH3
                            if iFactionRef == M28UnitInfo.refFactionUEF then iEngiCatWanted = iEngiCatWanted * categories.UEF
                            elseif iFactionRef == M28UnitInfo.refFactionAeon then iEngiCatWanted = iEngiCatWanted * categories.AEON
                            elseif iFactionRef == M28UnitInfo.refFactionCybran then iEngiCatWanted = iEngiCatWanted * categories.CYBRAN
                            elseif iFactionRef == M28UnitInfo.refFactionSeraphim then iEngiCatWanted = iEngiCatWanted * categories.SERAPHIM
                            end
                            local iEngisAlreadyTraveling = 0
                            --Want at least 3 enginers traveling of the desired tech level
                            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
                                for iEngi, oEngi in  tLZTeamData[M28Map.subrefTEngineersTravelingHere] do
                                    if M28UnitInfo.IsUnitValid(oEngi) and EntityCategoryContains(iEngiCatWanted, oEngi.UnitId) then
                                        iEngisAlreadyTraveling = iEngisAlreadyTraveling + 1
                                    end
                                end
                            end
                            if iEngisAlreadyTraveling < 3 then
                                iZoneWantingEngineer = iGameEnderZone
                                iFactionWanted = iFactionRef
                                break
                            end
                        end
                    end
                end
            end
        end
        if iZoneWantingEngineer then break end
    end
    return iZoneWantingEngineer, iFactionWanted
end

function GetPDThreatAboveRangeThresholdAlongPath(iPlateau, iLandZone, tLZData, tLZTeamData, iTeam, iRangeThreshold, tTarget)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPDThreatAboveRangeThresholdAlongPath'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; iRangeThreshold='..iRangeThreshold..'; tTarget='..repru(tTarget)..'; Dist from target to LZ mid='..M28Utilities.GetDistanceBetweenPositions(tTarget, tLZData[M28Map.subrefMidpoint])) end
    local iCurPDThreat = 0
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
            if iRange >= iRangeThreshold then
                iCurPDThreat = iCurPDThreat + iThreat
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPDThreat for just this zone='..iCurPDThreat) end
    local iTargetPlateauOrZero, iTargetLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tTarget)
    if bDebugMessages == true then LOG(sFunctionRef..': iTargetLandZone='..(iTargetLandZone or 'nil')..'; iTargetPlateauOrZero='..(iTargetPlateauOrZero or 'nil')) end
    if iTargetLandZone > 0 and iTargetPlateauOrZero == iPlateau and not(iTargetLandZone == iLandZone) then
        --ACU is in a different land zone
        if bDebugMessages == true then LOG(sFunctionRef..': Table of land zone path from start to target='..repru(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath])) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath]) == false then
            for iEntry, iAdjLZ in  tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath] do
                if not(iAdjLZ == iLandZone) then
                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
                        for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                            if iRange >= iRangeThreshold then
                                iCurPDThreat = iCurPDThreat + iThreat
                            end
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPDThreat after factoring in adjacent zones='..iCurPDThreat) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iCurPDThreat
end

function GetClosestMobileTMLIfWantMoreTMD(iTeam, tLZTeamData)
    --Assumes we have already confirmed there are enemy mobile tml on the enemy team
    --Dont bother trying to get TMD if enemy has units in this zone
    --NOTE: After drafting this decided to use a different approach to tracking mobile TML
    M28Utilities.ErrorHandler('Obsolete never tested code')
    local oMobileTMLToDefendAgainst
    if (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) == 0 and (tLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) == 0 then

        local iZoneTMDCount = 0
        local tZoneTMD = EntityCategoryFilterDown(M28UnitInfo.refCategoryTMD, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tZoneTMD) == false then
            for iUnit, oUnit in tZoneTMD do
                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then iZoneTMDCount = iZoneTMDCount + 1 end
            end
        end
        if iZoneTMDCount < 4 or (iZoneTMDCount < 16 and tLZTeamData[M28Map.subrefLZSValue] > iZoneTMDCount * 800) then
            --Get the closest enemy TML to midpoint
            local iCurDist
            local iClosestDist = 100000
            local oClosestUnit
            local tMidpoint = tLZTeamData[M28Map.subrefMidpoint]
            for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyMobileTML] do
                iCurDist = M28Utilities.GetDistanceBetweenPositions(tMidpoint, oUnit:GetPosition()) - math.max((oUnit[M28UnitInfo.refiManualRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0))
                if iCurDist < iClosestDist then
                    iClosestDist = iCurDist
                    oClosestUnit = oUnit
                end
            end
            if iClosestDist <= 50 then
                oMobileTMLToDefendAgainst = oClosestUnit
            end

        end
    end
    return oMobileTMLToDefendAgainst
end

function GetCaptureBPWanted(oUnitToCapture, bHaveLowPower, iTeam, bIsCoreBase)
    local iTargetBuildTime = (oUnitToCapture:GetBlueprint().Economy.BuildTime or 1)
    local iBPWanted = math.min(5 + 20 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iTargetBuildTime * 0.25)

    local iTimeToCapture = iTargetBuildTime / iBPWanted
    if iTimeToCapture >= 10 and not(bHaveLowPower) then
        iBPWanted = math.min(40 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iTargetBuildTime / 10)
    end
    iBPWanted = math.max(5, iBPWanted)
    return iBPWanted
end

function ConsiderCoreBaseLandZoneEngineerAssignment(tLZTeamData, iTeam, iPlateau, iLandZone, tEngineers)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderCoreBaseLandZoneEngineerAssignment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --For land zones in the core base
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local toAvailableEngineersByTech, toAssignedEngineers = FilterToAvailableEngineersByTech(tEngineers, true, tLZData, tLZTeamData, iTeam, iPlateau, iLandZone)
    local bDontCheckPlayableArea = false
    if M28Map.bIsCampaignMap then
        bDontCheckPlayableArea = true
        if M28Team.tTeamData[iTeam][M28Team.rebTeamOnlyHasCampaignAI] then bDontCheckPlayableArea = false end
    end

    tLZTeamData[M28Map.subrefTBuildPowerByTechWanted] = {[1]=0,[2]=0,[3]=0}
    if bDebugMessages == true then LOG(sFunctionRef..': Have just reset BPByTech to 0 for Plateau'..iPlateau..'; LZ='..iLandZone..'; repru='..repru(tLZTeamData[M28Map.subrefTBuildPowerByTechWanted])) end
    --local iCurCondition = 0
    local iCurPriority = 0
    local iHighestTechEngiAvailable
    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
    local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)
    local bWantMorePower = M28Conditions.WantMorePower(iTeam)
    local bWantMoreFactories = M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone)
    local iBPWanted
    local iActiveMexUpgrades = M28Conditions.GetActiveMexUpgrades(tLZTeamData)
    local iNearbyEnemyAirToGroundThreat = tLZTeamData[M28Map.refiEnemyAirToGroundThreat]
    local iHighestTechInZone = M28Conditions.GetHighestTechInZone(iTeam, tLZTeamData) --Highest completed factory HQ or engineer in the zone (or 1 if none)
    local iFactoriesInLZ = 0
    local tFactoriesInLZ

    --For now only do land zone not water zone given water zone includes torp bombers
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
            iNearbyEnemyAirToGroundThreat = iNearbyEnemyAirToGroundThreat + tLZTeamData[M28Map.refiEnemyAirToGroundThreat]
        end
    end

    function HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
        --Done as subfunction for convenience so can just note the key values for the action in question and add on the others that wont change
        --vOptionalVariable can be used for action specific information to save having to recalculate the same thing - could be a table, nil, or a value
        ConsiderActionToAssign(iActionToAssign, math.max(1, iMinTechLevelWanted), iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iCurPriority, tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, toAvailableEngineersByTech, toAssignedEngineers, false, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
    end

    if bDebugMessages == true then
        LOG(sFunctionRef..': About to consider what actions we want to give engineers for iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iTeam='..(iTeam or 'nil')..'; bHaveLowMass='..tostring(bHaveLowMass or false)..'; Team gross mass='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] or 'nil')..'; Lowest mass % stored='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] or 'nil')..'; Team mass stored='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] or 'nil')..'; Team net mass='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] or 'nil')..'; Team gross mass='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] or 'nil'))
        LOG(sFunctionRef..': Repeat of log but without the nil backups to help identify errors, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Team gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Lowest mass % stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; Team mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Team net mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]..'; Team gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass])
    end
    local iMinTechLevelForPower = 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 then
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 22 then iMinTechLevelForPower = 1
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 110 then iMinTechLevelForPower = 2
        else
            if bHaveLowPower and not(bHaveLowMass) then
                iMinTechLevelForPower = iHighestTechInZone
            else
                iMinTechLevelForPower = M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': iMinTechLevelForPower='..iMinTechLevelForPower..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end

    --Higher priority than low power - if we need to rush T3 AA due to enemy having T3 air and us not having good enoguh AA force
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] <= 3000 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 then
        --Get AirAA threat for the likely subteam in here
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            local aiBrain
            for iUnit, oUnit in tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do
                if oUnit:GetAIBrain().M28AI then
                    aiBrain = oUnit:GetAIBrain()
                    break
                end
            end
            if M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiOurAirAAThreat] <= 1200 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirAA * categories.TECH3) == 0 then
                --Do we have any T3 AA here already?
                local tExistingAirAA = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructureAA * categories.TECH3, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                local bAlreadyHaveT3AA = false
                if M28Utilities.IsTableEmpty(tExistingAirAA) == false then
                    for iUnit, oUnit in tExistingAirAA do
                        if oUnit:GetFractionComplete() >= 1 then
                            bAlreadyHaveT3AA = true
                            break
                        end
                    end
                end
                if not(bAlreadyHaveT3AA) then
                    iBPWanted = 30
                    if not(bHaveLowPower) then iBPWanted = 90 end
                    HaveActionToAssign(refActionBuildAA, 3, iBPWanted)
                    if bDebugMessages == true then LOG(sFunctionRef..': T3 AA builder - iBPWanted='..iBPWanted) end
                end
            end
        end
    end

    --First T2 PD emergency builder if we have no T2 PD and nearby enemy threat
    --Approaching enemy guncom - prioritise upgrades if dont have T2, if do have T2 then get T2 PD; also get T2 PD if enemies are in this LZ and we have T2 tech
    iCurPriority = iCurPriority + 1
    local oNearestEnemy
    local iApproachingACUThreat, tNearestEnemyACU = M28Conditions.GetThreatOfApproachingEnemyACUsAndNearestACU(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if emergency PD is needed, iApproachingACUThreat='..iApproachingACUThreat) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 25 and (((iApproachingACUThreat > 0 or (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2)) and M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU]) or (tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false)) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 and (not(M28Overseer.bNoRushActive) or M28Overseer.iNoRushTimer - GetGameTimeSeconds() <= 120 or (not(bHaveLowMass) and not(bHaveLowPower) and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 0)) then
        --We have T2 (or only need T1 due to enemy not having gun), so want to build PD
        local iRangeThreshold = 35 --Range of Aeon guncom
        local iCurPDThreat = 0
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                if iRange >= iRangeThreshold then
                    iCurPDThreat = iCurPDThreat + iThreat
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': We have T2 or better, iCurPDThreat='..iCurPDThreat..'; iAppraochingACUThreat='..iApproachingACUThreat..'; iRangeThreshold='..iRangeThreshold..'; tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]='..repru(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange])..'; iLandZone='..iLandZone) end
        if iCurPDThreat <= 470 then
            iBPWanted = 40
            if not(bHaveLowMass) and not(bHaveLowPower) then iBPWanted = 80 end
            local tTargetBuildLocation
            if tNearestEnemyACU then
                tTargetBuildLocation = GetStartSearchPositionForEmergencyPD(tNearestEnemyACU, tLZData[M28Map.subrefMidpoint], iPlateau, iLandZone)
            else
                local tEnemiesToConsider = {}
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                    for iUnit, oUnit in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            table.insert(tEnemiesToConsider, oUnit)
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tEnemiesToConsider) == false then
                    if not(oNearestEnemy) then oNearestEnemy = M28Utilities.GetNearestUnit(tLZTeamData[M28Map.reftoNearestDFEnemies], tLZData[M28Map.subrefMidpoint], true, M28Map.refPathingTypeLand) end
                    if oNearestEnemy then --factors in if can path to enemy by land
                        if bDebugMessages == true then LOG(sFunctionRef..': oNearestEnemy='..(oNearestEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemy) or 'nil')..'; tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint])) end
                        tTargetBuildLocation = GetStartSearchPositionForEmergencyPD(oNearestEnemy:GetPosition(), tLZData[M28Map.subrefMidpoint], iPlateau, iLandZone)
                    end
                end
                if not(oNearestEnemy) then iBPWanted = 0 end
            end
            if iBPWanted > 0 and tTargetBuildLocation then

                HaveActionToAssign(refActionBuildEmergencyPD, 2, iBPWanted, tTargetBuildLocation)
                if bDebugMessages == true then LOG(sFunctionRef..': Will build emergency T2 PD') end
            end
        end
    end

    --Start of game or low power - build hydro if one nearby, otherwise build pgen
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Low power at start of game builder, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Is table of hydro locations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroLocations]))..'; Is table of unbuilt locations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations]))..'; bHaveLowPower='..tostring(bHaveLowPower)..'; bHaveLowMass='..tostring(bHaveLowMass)) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 200 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 10 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultipler] then
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroLocations]) == false then
            --Norush check
            if bDebugMessages == true then LOG(sFunctionRef..': CHecking if hydro prevented by norush, M28Overseer.bNoRushActive='..tostring(M28Overseer.bNoRushActive or false)..'; M28Conditions.NoRushPreventingHydro(tLZTeamData)='..tostring(M28Conditions.NoRushPreventingHydro(tLZTeamData) or false)) end
            if M28Overseer.bNoRushActive and M28Conditions.NoRushPreventingHydro(tLZTeamData) then
                if bDebugMessages == true then LOG(sFunctionRef..': Norush is preventing b uilding a hydro at core zone so will just build a pgen, iLandZone='..iLandZone) end
                HaveActionToAssign(refActionBuildPower, iMinTechLevelForPower, 10)
            else

                if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..':  Will try and build a hydro, unless we have no unbuilt locations and have no part complete hydro in which case will build power') end
                local bCanBuildOrAssistHydro = false
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefHydroUnbuiltLocations]) == false then
                    bCanBuildOrAssistHydro = true
                else
                    local tHydroInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryHydro, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tHydroInZone) == false then
                        for iUnit, oUnit in tHydroInZone do
                            if oUnit:GetFractionComplete() < 1 then bCanBuildOrAssistHydro = true break end
                        end
                    end
                end
                --Issue on some maps if lots of hydro locations spread out
                if bDebugMessages == true then LOG(sFunctionRef..': bCanBuildOrAssistHydro='..tostring(bCanBuildOrAssistHydro)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; bHaveLowMass='..tostring(bHaveLowMass)..'; bHaveLowPower='..tostring(bHaveLowPower)..'; Hydros in zone='..table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroLocations])..'; Higheest friendly factory tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; Get power instead of hydro='..tostring(M28Conditions.GetPowerInsteadOfHydroEvenIfHydroAvailable(iTeam, tLZData, tLZTeamData, iPlateau, iLandZone, bHaveLowMass, bHaveLowPower))) end
                if bCanBuildOrAssistHydro and not(M28Conditions.GetPowerInsteadOfHydroEvenIfHydroAvailable(iTeam, tLZData, tLZTeamData, iPlateau, iLandZone, bHaveLowMass, bHaveLowPower)) then
                    HaveActionToAssign(refActionBuildHydro, 1, 10)
                else
                    HaveActionToAssign(refActionBuildPower, iMinTechLevelForPower, 5)
                end
            end
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..': Will try and build PGens') end
            HaveActionToAssign(refActionBuildPower, iMinTechLevelForPower, 5)
        end
    else
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations]) == false and (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 20 >=  M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] or (bHaveLowPower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 0.5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) then
            if bDebugMessages == true then LOG(sFunctionRef..': Have at least 10 energy income on the team, cHecking if hydro prevented by norush, M28Overseer.bNoRushActive='..tostring(M28Overseer.bNoRushActive or false)..'; M28Conditions.NoRushPreventingHydro(tLZTeamData)='..tostring(M28Conditions.NoRushPreventingHydro(tLZTeamData) or false)..'; Want power instad of hydro='..tostring(M28Conditions.GetPowerInsteadOfHydroEvenIfHydroAvailable(iTeam, tLZData, tLZTeamData, iPlateau, iLandZone, bHaveLowMass, bHaveLowPower))) end
            if (M28Overseer.bNoRushActive and M28Conditions.NoRushPreventingHydro(tLZTeamData)) or M28Conditions.GetPowerInsteadOfHydroEvenIfHydroAvailable(iTeam, tLZData, tLZTeamData, iPlateau, iLandZone, bHaveLowMass, bHaveLowPower) then
                if bDebugMessages == true then LOG(sFunctionRef..': Norush is preventing b uilding a hydro so will just build a pgen, iLandZone='..iLandZone) end

                HaveActionToAssign(refActionBuildPower, iMinTechLevelForPower, 10)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': WIll try to build hydro') end
                HaveActionToAssign(refActionBuildHydro, 1, 10)
            end
            --Make sure we have 1 power of the cur tech level provided dont have low mass
        elseif (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 0.5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and (bHaveLowPower and ((not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 30 or GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or -100) <= 10)) or (not(bHaveLowMass) and bWantMorePower and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < (30 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] + 160 * math.max(0, (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] - 2))) * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultipler]) then
            --Exception if recently built power and have nearby enemies (so can e.g. do things like PD)
            if iNearbyEnemyAirToGroundThreat == 0 and (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) == 0 and not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.35 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 3 then
                iBPWanted = 4 * tiBPByTech[iMinTechLevelForPower]
                if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                    iBPWanted = 3 * tiBPByTech[iMinTechLevelForPower]
                else
                    iBPWanted = 4 * tiBPByTech[iMinTechLevelForPower]
                end
            else
                if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.03 then
                    iBPWanted = tiBPByTech[iMinTechLevelForPower]
                else
                    iBPWanted = 2 * tiBPByTech[iMinTechLevelForPower]
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Start of game Want more power, iBPWanted='..iBPWanted) end
            HaveActionToAssign(refActionBuildPower, iMinTechLevelForPower, iBPWanted)

        end
    end

    --Being bombed or have large air force in our core base - need AA if dont have any fixed AA (see a bit later on for high priority AA builder when under air attack if already have 1 fixed AA)
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 or iNearbyEnemyAirToGroundThreat >= 500 or tLZTeamData[M28Map.refiEnemyAirAAThreat] >= 500 then
        --Do we already have fixed AA in this LZ?
        local iAACategory = M28UnitInfo.refCategoryStructureAA
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then iAACategory = iAACategory * categories.TECH3 end
        local tExistingFixedAA = EntityCategoryFilterDown(iAACategory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local bHaveFixedAA = false
        if M28Utilities.IsTableEmpty(tExistingFixedAA) == false then
            for iUnit, oUnit in tExistingFixedAA do
                if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have fixed AA, considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                if oUnit:GetFractionComplete() then bHaveFixedAA = true break end
            end
        end
        if not(bHaveFixedAA) then
            iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
            if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 or iNearbyEnemyAirToGroundThreat >= 500 then iBPWanted = iBPWanted * 2 end
            if not(bHaveLowPower) then
                if not(bHaveLowMass) then iBPWanted = iBPWanted * 4
                else iBPWanted = iBPWanted * 2
                end
            end
            HaveActionToAssign(refActionBuildAA, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted)
            if bDebugMessages == true then LOG(sFunctionRef..': AA builder if no fixed AA: iBPWanted='..iBPWanted..'; iNearbyEnemyAirToGroundThreat='..iNearbyEnemyAirToGroundThreat..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; subrefiAlliedGroundAAThreat='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]) end
        end
    end

    --Protect game-ender or similar high avlue target (very high priority on assumption if we have built such a unit we shouldnt have to worry about lack of resources for this
    iCurPriority = iCurPriority + 1

    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Want to assign units to active shield protection, will list out each unit for this zone that wants active protection')
            for iUnit, oUnit in tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
                LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Mass cost='..oUnit:GetBlueprint().Economy.BuildCostMass)
            end
        end
        if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] then
            iBPWanted = 500
        else
            iBPWanted = 100
        end


        if bDebugMessages == true then LOG(sFunctionRef..': Special shield defence action iBPWanted='..iBPWanted) end

        --Only use T3 engineers (even if we already have t3 engineers assigned) as want to make sure we can quickly get good concentrated build power
        --function HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist)
        HaveActionToAssign(refActionSpecialShieldDefence, 3, iBPWanted,         nil,                nil,                    nil,                        nil,                            true)
    end




    --Unclaimed mex in the zone
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then
        LOG(sFunctionRef..': Considering if unbuilt or part build mexes in t his LZ, is subrefMexUnbuiltLocations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]))..'; Is subreftoPartBuiltMexes empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]))..'; Mex by tech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; subrefLZMexCount='..tLZData[M28Map.subrefLZMexCount])
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) == false then
            LOG(sFunctionRef..': Size of unbuilt locations table='..table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]))

        end
    end
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) == false then
        iBPWanted = math.max(5, table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) * 2.5)
        if bHaveLowPower and not(bHaveLowMass) and iBPWanted > 10 then
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= 0.25 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 then
                iBPWanted = 10
            elseif iBPWanted > 20 and iBPWanted >= tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2 then
                iBPWanted = 20
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': High priority mex builder, Have a total of '..table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations])..' unbuilt mex locations in this zone, iBPWanted='..iBPWanted..'; Highest friendly tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end
        HaveActionToAssign(refActionBuildMex, 1, iBPWanted)
        if (tLZTeamData[M28Map.subreftiBPWantedByAction][refActionBuildMex] or 0) > 0 then tLZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] = true end
    elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
        --Do we have no engineers assigned to building a mex?
        local bHaveEngisBuilding = false
        if bDebugMessages == true then LOG(sFunctionRef..': Have part built mexes, is toAssignedEngineers empty='..tostring(M28Utilities.IsTableEmpty(toAssignedEngineers))) end
        if M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
            for iEngi, oEngi in toAssignedEngineers do
                if oEngi[refiAssignedAction] == refActionBuildMex then
                    bHaveEngisBuilding = true
                    break
                end
            end
        end
        if not(bHaveEngisBuilding) then
            --Refresh list of mexes
            RefreshPartBuiltMexList(tLZTeamData)
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to assign 5 BP to complete a part built mex') end
                HaveActionToAssign(refActionCompletePartBuiltMex, 1, 5)
            end
        end
    end


    --Early game transport wanting engineer (takes priority over factory if we have at least 2 in this zone)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; Is table of transports waiting for engineers empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers]) == false then
        --Check the table is still valid
        local iEngisWantedForTransports = GetEngisWantedForTransports(tLZTeamData)
        if bDebugMessages == true then LOG(sFunctionRef..': iEngisWantedForTransports after refresh='..iEngisWantedForTransports) end
        if iEngisWantedForTransports > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': want engineers to load onto transport if early game, will first check if we have at least 2 factories in this zone and if the transport has a lifetime count of 1 and we only have 1 transport, size of transport table='..table.getn(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers])..'; Time='..GetGameTimeSeconds()) end
            if table.getn(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers]) == 1 and GetGameTimeSeconds() <= 900 then
                local bFirstTransport = true
                if (M28UnitInfo.GetUnitLifetimeCount(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers][1] or 1)) > 1 then bFirstTransport = false end
                if bDebugMessages == true then LOG(sFunctionRef..': bFirstTransport='..tostring(bFirstTransport)) end
                if bFirstTransport then
                    if not(tFactoriesInLZ) or iFactoriesInLZ == 0 then
                        iFactoriesInLZ = 0
                        tFactoriesInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    end
                    if M28Utilities.IsTableEmpty(tFactoriesInLZ) == false then
                        for iFactory, oFactory in tFactoriesInLZ do
                            if oFactory:GetFractionComplete() == 1 then
                                iFactoriesInLZ = iFactoriesInLZ + 1
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iFactoriesInLZ='..iFactoriesInLZ) end
                    if iFactoriesInLZ >= 2 then
                        --iActionToAssign,      iMinTechLevelWanted, i  BuildPowerWanted,                                                                       vOptionalVariable,  bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting
                        --BP wanted - engineers already attached shouldn't be treated as available, however want BP wanted to be total not additional to avoid multiple unattached engineers being given the same order
                        if bDebugMessages == true then LOG(sFunctionRef..': Will seek engineers for transport') end
                        HaveActionToAssign(refActionLoadOntoTransport, 1, iEngisWantedForTransports * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]], nil, false,false) --Max 5 BP to make sure we only try loading 1 engi at a time
                    end
                end
            end
        end
    end

    --Adjacent zones wanting mexes that dont already have 1 engineer traveling for every 2 unbuilt mexes
    iCurPriority = iCurPriority + 1
    --(ANY CHANGES TO BELOW - CONSIDER REPLICATING FOR BOTH CORE AND NONCORE BUILDERS) Adjacent LZ that wants engineers (only chekc if we have available engineers)
    --(as of v24 decided to go with differences for the minior LZ (which uses a simplified appraoch) vs core base highest priority for adj LZs
    local tiAdjacentLandZonesWantingEngineersThatAlreadyHaveSome = {}
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have available engineers to send to another LZ. GetHighestTechEngiAvailable='..GetHighestTechEngiAvailable(toAvailableEngineersByTech)) end
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    local iNearbyZonesWantingEngineers = 0
    local iPrevEngisAvailable
    local tLZWantingBPConsidered = {}
    local iAdjLZ
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
        local iEngineersTravelingHere
        local iEngineersPresentHere
        local iMaxEngineersWanted
        for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
            if tPathingDetails[M28Map.subrefLZTravelDist] <= tLZData[M28Map.subrefLZFurthestAdjacentLandZoneTravelDist] then
                iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                if tAdjLZTeamData[M28Map.subrefTbWantBP] and not(tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] or (tAdjLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) > 0) then
                    iEngineersTravelingHere = 0
                    iEngineersPresentHere = 0
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
                        iEngineersTravelingHere = table.getn(tAdjLZTeamData[M28Map.subrefTEngineersTravelingHere])
                    end
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                        local tEngineersInAdjZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                        if M28Utilities.IsTableEmpty(tEngineersInAdjZone) == false then
                            iEngineersPresentHere = table.getn(tEngineersInAdjZone)
                        end
                    end
                    iMaxEngineersWanted = 1
                    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then iMaxEngineersWanted = 2 end
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefMexUnbuiltLocations]) == false then
                        iMaxEngineersWanted = math.max(iMaxEngineersWanted, math.ceil(table.gent(tAdjLZTeamData[M28Map.subrefMexUnbuiltLocations]) * 0.5))
                    end
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefHydroUnbuiltLocations]) == false then
                        iMaxEngineersWanted = iMaxEngineersWanted + 1
                    end
                    if iEngineersTravelingHere + iEngineersPresentHere >= iMaxEngineersWanted then
                        tiAdjacentLandZonesWantingEngineersThatAlreadyHaveSome[iPathingRef] = iAdjLZ
                    else
                        tLZWantingBPConsidered[iAdjLZ] = true
                        local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, iAdjLZ, iPathingRef, iHighestTechEngiAvailable, true, false, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                        if tiBPByTechWanted then
                            for iTech = 1, iHighestTechEngiAvailable, 1 do
                                if tiBPByTechWanted[iTech] > 0 then
                                    iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                    iBPWanted = iNearbyZonesWantingEngineers * 5 + tiBPByTechWanted[iTech]
                                    HaveActionToAssign(refActionMoveToLandZone, iTech, iBPWanted, iAdjLZ, true)
                                    if (tLZTeamData[M28Map.subreftiBPWantedByAction][refActionMoveToLandZone] or 0) > 0 then tLZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] = true end
                                    if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                        iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                    end

                                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want iBPWanted='..iBPWanted..' to go to iAdjLZ='..iAdjLZ..'; iNearbyZonesWantingEngineers='..iNearbyZonesWantingEngineers..'; iHighestTechEngiAvailable='..iHighestTechEngiAvailable) end
                                    if iHighestTechEngiAvailable == 0 then break end
                                end
                            end
                        end
                        if iHighestTechEngiAvailable == 0 then break end
                    end
                end
            else
                break --Table shoudl be sorted closest first so if we are too far away now the later entries should be ignored
            end
        end
    end

    iCurPriority = iCurPriority + 1
    local iCoreWZWantingSupportAsLowerPriority
    --If have adjacent waterzone that has unbuilt mexes and has no engineers (incl traveling engineers) then also send engineer here
    if bDebugMessages == true then LOG(sFunctionRef..': High priority Considering if we have adjacent WZ that wants engineer for unbuilt mexes or core WZ, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
        local iCurWZ, iCurPond
        local iBPAlreadyAssigned = 0
        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
            iCurWZ = tSubtable[M28Map.subrefAWZRef]
            iCurPond = M28Map.tiPondByWaterZone[iCurWZ]
            local tWZData = M28Map.tPondDetails[iCurPond][M28Map.subrefPondWaterZones][iCurWZ]
            if bDebugMessages == true then LOG(sFunctionRef..': iCurWZ='..iCurWZ..'; Is table of unbuilt mexes empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]))) end
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]) == false then
                local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]

                local iEngineersTravelingHere
                local iEngineersPresentHere
                local iMaxEngineersWanted
                if bDebugMessages == true then LOG(sFunctionRef..': does zone want bp='..tostring(tWZTeamData[M28Map.subrefTbWantBP])..'; subrefbEnemiesInThisOrAdjacentWZ='..tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])..'; enemy air to ground='..(tWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0)) end
                if tWZTeamData[M28Map.subrefTbWantBP] and not(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] or (tWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) > 0) then
                    iEngineersTravelingHere = 0
                    iEngineersPresentHere = 0
                    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
                        iEngineersTravelingHere = table.getn(tWZTeamData[M28Map.subrefTEngineersTravelingHere])
                    end
                    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                        local tEngineersInAdjZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                        if M28Utilities.IsTableEmpty(tEngineersInAdjZone) == false then
                            iEngineersPresentHere = table.getn(tEngineersInAdjZone)
                        end
                    end
                    iMaxEngineersWanted = 1
                    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefMexUnbuiltLocations]) == false then
                        iMaxEngineersWanted = math.max(iMaxEngineersWanted, math.ceil(table.gent(tWZTeamData[M28Map.subrefMexUnbuiltLocations]) * 0.5))
                    end
                    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefHydroUnbuiltLocations]) == false then
                        iMaxEngineersWanted = iMaxEngineersWanted + 1
                    end
                    iBPWanted = iMaxEngineersWanted * 5
                    HaveActionToAssign(refActionMoveToWaterZone, 1, iBPWanted + iBPAlreadyAssigned, iCurWZ, true)
                    iBPAlreadyAssigned = iBPAlreadyAssigned + iBPWanted
                    if (tLZTeamData[M28Map.subreftiBPWantedByAction][refActionMoveToWaterZone] or 0) > 0 then tLZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] = true end
                    if bDebugMessages == true then LOG(sFunctionRef..': Tried to send engineers to iCurWZ '..iCurWZ..'; iBPWanted='..iBPWanted..'; iBPAlreadyAssigned='..iBPAlreadyAssigned) end
                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                    if iHighestTechEngiAvailable == 0 or iBPAlreadyAssigned >= iBPWanted * 3 then break end
                end
            end
        end
    end

    --Very High priority factory if we have fewer than 4 (or if lwoer thre number of mexes in the LZ or small map and signif mass stored) and is a smaller map - takes priority over mex expansion; also build more than 4 if dont have low mass and outtech enemy
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want v.high priority factory builder, mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; bWantMoreFactories='..tostring(bWantMoreFactories)..'; Team gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; GameTime='..GetGameTimeSeconds()) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 11 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 100 and bWantMoreFactories and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1 and (GetGameTimeSeconds() >= 200 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1.5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or M28Map.iMapSize <= 256) then

        if iFactoriesInLZ == 0 or not(tFactoriesInLZ) then
            tFactoriesInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tFactoriesInLZ) == false then iFactoriesInLZ = table.getn(tFactoriesInLZ) end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iFactoriesInLZ='..iFactoriesInLZ..'; LZ mex count='..tLZData[M28Map.subrefLZMexCount]..'; M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]='..M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) end
        local iFactoryAdjust = 0
        if M28Map.iMapSize <= 256 then
            iFactoryAdjust = math.min(3,M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] / 100)
        end
        if not(bHaveLowMass) and not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] <= 2 and M28Map.iMapSize <= 1024 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] > math.max(M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech], M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech], M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech]) then
            --We outtech enemy and have decent mass and power, so want more factories to make use of our advantage, if enemy base is relatively near
            if M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 550 and NavUtils.GetTerrainLabel(tLZTeamData[M28Map.reftClosestEnemyBase]) == NavUtils.GetTerrainLabel(tLZTeamData[M28Map.reftClosestFriendlyBase]) then
                iFactoryAdjust = iFactoryAdjust + 2
            end
        end

        if iFactoriesInLZ < iFactoryAdjust + math.max(2 , math.min(4, tLZData[M28Map.subrefLZMexCount] + 1, 10 * M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) then
            iBPWanted = 5
            if not(bHaveLowMass) then iBPWanted = iBPWanted * 2.5 end
            if not(bHaveLowPower) then iBPWanted = iBPWanted * 2.5 end
            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 and GetGameTimeSeconds() <= 400 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] < 4 then
                iBPWanted = math.min(15, iBPWanted)
                if bHaveLowMass or bHaveLowPower or GetGameTimeSeconds() <= 300 then iBPWanted = math.min(10, iBPWanted) end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build factory, iBPWanted='..iBPWanted) end
            local bWantAirNotLand
            if iFactoriesInLZ == 0 then bWantAirNotLand = false
            else bWantAirNotLand = M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)
            end
            local iFactoryAction
            if bWantAirNotLand then iFactoryAction = refActionBuildAirFactory
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Want to build land factory not air factory1') end
                iFactoryAction = refActionBuildLandFactory
            end
            if bHaveLowPower and bWantAirNotLand then iBPWanted = iBPWanted * 0.5 end

            --Change factory action if we already have a particular type under construction
            local tFactoriesInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryAirFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tFactoriesInZone) == false then
                for iUnit, oUnit in tFactoriesInZone do
                    if oUnit:GetFractionComplete() < 1 then
                        if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oUnit.UnitId) then iFactoryAction = refActionBuildAirFactory
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) then iFactoryAction = refActionBuildLandFactory
                        end
                    end
                end
            end

            HaveActionToAssign(iFactoryAction, 1, iBPWanted)
        end
    end

    --Need SMD as enemy has nuke launcher
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; About to consider if want SMD, is table of enemy nukes empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false then
        local bAssistSMD = false
        iBPWanted, bAssistSMD = GetBPToAssignToSMD(iPlateau, iLandZone, iTeam, tLZTeamData, true, bHaveLowMass, bWantMorePower)
        if bDebugMessages == true then LOG(sFunctionRef..': iBPWanted for SMD='..(iBPWanted or 'nil')..'; bAssistSMD='..tostring(bAssistSMD or false)) end
        if iBPWanted > 0 then
            if bAssistSMD then
                if bDebugMessages == true then LOG(sFunctionRef..': Will assist existing SMD') end
                HaveActionToAssign(refActionAssistSMD, 1, iBPWanted)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Want to build SMD, iCurPrioriyt='..iCurPriority) end
                HaveActionToAssign(refActionBuildSMD, 3, iBPWanted)
            end
        end
    end

    --Transports waiting for engineers
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; Is table of transports waiting for engineers empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers]) == false then
        --Check the table is still valid
        local iEngisWantedForTransports = GetEngisWantedForTransports(tLZTeamData)
        if bDebugMessages == true then LOG(sFunctionRef..': iEngisWantedForTransports after refresh='..iEngisWantedForTransports) end
        if iEngisWantedForTransports > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': want engineers to load onto transport') end
            --iActionToAssign,      iMinTechLevelWanted, i  BuildPowerWanted,                                                                       vOptionalVariable,  bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting
            --BP wanted - engineers already attached shouldn't be treated as available, however want BP wanted to be total not additional to avoid multiple unattached engineers being given the same order
            HaveActionToAssign(refActionLoadOntoTransport, 1, iEngisWantedForTransports * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]], nil, false,false) --Max 5 BP to make sure we only try loading 1 engi at a time
        end
    end

    --Zones wanting specific faction engineers (e.g. for shielding game ender)
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftFactoriesWantedForEngineers]) == false then
        local iZoneWantingEngineersOfFaction, iFactionWanted = GetZoneAndFactionForPriorityEngineerTravel(tLZTeamData, iTeam, iLandZone, iPlateau)
        if iZoneWantingEngineersOfFaction and iFactionWanted then
            HaveActionToAssign(refActionMoveToLandZone, 3, 90, iZoneWantingEngineersOfFaction, true, false, iFactionWanted)
        end
    end

    --Energy storage if we have none and at least 1 T2+ mex
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; Considering building energy storage, Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; Have low power='..tostring(bHaveLowPower)..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount]='..M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount]..'; Enemy unit with highest health='..M28Team.tTeamData[iTeam][M28Team.refiEnemyHighestMobileLandHealth]) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] <= 0 and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 1 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 75) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 35 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2.5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
        --Is the number of storage in this LZ <= lowest storage count?
        local toStorageInThisLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryEnergyStorage, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local iStorageInThisLZ = 0
        if M28Utilities.IsTableEmpty(toStorageInThisLZ) == false then
            for iUnit, oUnit in toStorageInThisLZ do
                if oUnit:GetFractionComplete() == 1 then iStorageInThisLZ = iStorageInThisLZ + 1 end
            end
        else
            iStorageInThisLZ = 0
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iStorageInThisLZ='..iStorageInThisLZ) end
        if iStorageInThisLZ <= M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then --are ok with gifting storage to a teammate
            if bDebugMessages == true then LOG(sFunctionRef..': Want to get storage, Is tEngineers[1] valid='..tostring(M28UnitInfo.IsUnitValid(tEngineers[1]))) end
            iBPWanted = 5
            if not(bHaveLowMass) and not(bHaveLowPower) then iBPWanted = 20 end
            HaveActionToAssign(refActionBuildEnergyStorage, 1, iBPWanted)
        end
    end

    --Units needing air staging
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': About to check if we need air staging for core zone, Time='..GetGameTimeSeconds()..'; Time of last shortage='..(M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastAirStagingShortage] or 'nil')) end
    if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastAirStagingShortage] or 0) <= 1.1 then
        --Limit of 3 air staging in a LZ
        local tExistingAirStaging = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirStaging, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local iExistingAirStaging = 0
        local oExistingM28Brain
        local iAirStagingInThisZoneUnderConstruction = 0
        if M28Utilities.IsTableEmpty(tExistingAirStaging) == false then
            for iStaging, oStaging in tExistingAirStaging do
                if oStaging:GetAIBrain().M28AI then
                    if oStaging:GetFractionComplete() == 1 then
                        oExistingM28Brain = oStaging:GetAIBrain()
                        iExistingAirStaging = iExistingAirStaging + 1
                    else
                        iAirStagingInThisZoneUnderConstruction = iAirStagingInThisZoneUnderConstruction + 1
                    end
                end
            end
        end
        local iUnderConstructionInOtherZonesWithLowResources = 0
        if bDebugMessages == true then LOG(sFunctionRef..': iAirStagingInThisZoneUnderConstruction='..iAirStagingInThisZoneUnderConstruction..'; Active brain count='.. M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]..'; bHaveLowMass='..tostring(bHaveLowMass)..'; bHaveLowPower='..tostring(bHaveLowPower)..'; Highest air fac tech='.. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]) end
        if iAirStagingInThisZoneUnderConstruction == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 and (bHaveLowMass or bHaveLowPower or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] < 3) then
            --How many under construction air staging do we have
            iUnderConstructionInOtherZonesWithLowResources = M28Conditions.GetNumberOfUnderConstructionUnitsOfCategoryInOtherZones(tLZTeamData, iTeam, M28UnitInfo.refCategoryAirStaging)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iExistingAirStaging='..iExistingAirStaging..'; bHaveLowMass='..tostring(bHaveLowMass)..'; iAirStagingInThisZoneUnderConstruction='..iAirStagingInThisZoneUnderConstruction..'; iUnderConstructionInOtherZonesWithLowResources='..iUnderConstructionInOtherZonesWithLowResources) end
        if iUnderConstructionInOtherZonesWithLowResources == 0 and (iExistingAirStaging <= 1 or (iExistingAirStaging < 3 and not(bHaveLowMass)) or (iExistingAirStaging < 8 and oExistingM28Brain and oExistingM28Brain:GetCurrentUnits(M28UnitInfo.refCategoryAllNonExpAir) >= 50 * iExistingAirStaging)) then

            iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
            if not(bHaveLowMass) then iBPWanted = iBPWanted * 2 end
            HaveActionToAssign(refActionBuildAirStaging, 1, iBPWanted, nil, false)
            if bDebugMessages == true then LOG(sFunctionRef..': Have flagged we want air staging with iBPWanted='..iBPWanted) end
        end
    end


    --1st experimental - Enemy has land experimental and we dont have one of our own yet (and havent completed one before), unless enemy has a fatboy (in which case we want to focus more on getting t2 arti)
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] <= 18000 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.ALLUNITS - M28UnitInfo.refCategoryFatboy, M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals])) == false then
        local iEnemyHighestPercentComplete = 0
        local iClosestExperimental = 100000
        for iExperimental, oExperimental in M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
            if M28UnitInfo.IsUnitValid(oExperimental) then
                iEnemyHighestPercentComplete = math.max(iEnemyHighestPercentComplete, oExperimental:GetFractionComplete())
                iClosestExperimental = math.min(iClosestExperimental, M28Utilities.GetDistanceBetweenPositions(oExperimental:GetPosition(), tLZData[M28Map.subrefMidpoint]))
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iEnemyHighestPercentComplete='..iEnemyHighestPercentComplete..'; iClosestExperimental='..iClosestExperimental) end
        if iEnemyHighestPercentComplete > 0 and iClosestExperimental <= 700 then
            local iAliveExperimentals = 0
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                local tFriendlyExperimentals = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandExperimental, false, false)
                if M28Utilities.IsTableEmpty(tFriendlyExperimentals) == false then
                    for iExperimental, oExperimental in tFriendlyExperimentals do
                        if oExperimental:GetFractionComplete() >= 0.95 then
                            iAliveExperimentals = iAliveExperimentals + 1
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iAliveExperimentals='..iAliveExperimentals) end
            if iAliveExperimentals == 0 then

                local iHighestCompleteExperimentalInZone = 0
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                    local tExperimentalsUnderConstruction = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tExperimentalsUnderConstruction) == false then
                        for iUnit, oUnit in tExperimentalsUnderConstruction do
                            if M28UnitInfo.IsUnitValid(oUnit) then
                                iHighestCompleteExperimentalInZone = math.max(iHighestCompleteExperimentalInZone, oUnit:GetFractionComplete())
                            end
                        end
                    end

                end
                if bDebugMessages == true then LOG(sFunctionRef..': iHighestCompleteExperimentalInZone='..iHighestCompleteExperimentalInZone) end
                if iHighestCompleteExperimentalInZone > 0 and iHighestCompleteExperimentalInZone + 0.2 >= iEnemyHighestPercentComplete then
                    --Assist the experimental
                    HaveActionToAssign(refActionBuildExperimental, 1, 240)
                else
                    --Assist air factory
                    iBPWanted = 240
                    if bHaveLowPower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= 0.6 then iBPWanted = 120 end
                    local tAirFacsToAssist = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory * M28UnitInfo.ConvertTechLevelToCategory(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]), tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    local oAirFactoryToAssist
                    if M28Utilities.IsTableEmpty(   tAirFacsToAssist) then
                        tAirFacsToAssist = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of air facs to assist empty='..tostring(M28Utilities.IsTableEmpty(tAirFacsToAssist))..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone) end
                    if M28Utilities.IsTableEmpty(tAirFacsToAssist) == false then

                        local iHighestAirFac = 0
                        local iCurTechLevel
                        for iFactory, oFactory in tAirFacsToAssist do
                            iCurTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
                            if iCurTechLevel > iHighestAirFac then
                                iHighestAirFac = iCurTechLevel
                                oAirFactoryToAssist = oFactory
                            end
                        end
                        if oAirFactoryToAssist then
                            HaveActionToAssign(refActionAssistAirFactory, 1, iBPWanted, oAirFactoryToAssist)
                        end

                        HaveActionToAssign(refActionAssistAirFactory, 1, iBPWanted, oAirFactoryToAssist)
                    end
                end
            end
        end
    end



    --Shielding in a high mass scenario
    iCurPriority = iCurPriority + 1
    if (M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or (not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 25 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 250 + 250 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
        local iBPWanted, iTechLevelWanted, oUnitToShield = GetBPMinTechAndUnitForFixedShields(tLZTeamData, iTeam, true, bHaveLowMass, bWantMorePower, false, iLandZone, iPlateau)
        if iBPWanted > 0 then
            iBPWanted = math.min(iBPWanted, 40)

            HaveActionToAssign(refActionBuildShield, iTechLevelWanted, iBPWanted, oUnitToShield)
            if bDebugMessages == true then LOG(sFunctionRef..': High priority shield builder, iBPWanted='..iBPWanted) end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Dont want to assign any BP to high priority shield builder') end
        end
    end


    --Start of game - if low power and dont ahve 12 gross energy yet, then ahve 1 engi on tree reclaim duty
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Early game tree reclaim: bHaveLowPower='..tostring(bHaveLowPower)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Want to relcaim energy nt mass='..tostring(M28Conditions.WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone))) end
    if bHaveLowPower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 12 and M28Conditions.WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone) then
        HaveActionToAssign(refActionReclaimArea, 1, 5, true)
    end

    --Send engineers to adjacent zones wnating engineers hwich already have some engineers in them
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tiAdjacentLandZonesWantingEngineersThatAlreadyHaveSome) == false and iHighestTechEngiAvailable > 0 then
        for iPathingRef, iAdjLZ in tiAdjacentLandZonesWantingEngineersThatAlreadyHaveSome do
            tLZWantingBPConsidered[iAdjLZ] = true
            local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, iAdjLZ, iPathingRef, iHighestTechEngiAvailable, true, false, true)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering for adjacent zone of lower priority iAdjLZ='..iAdjLZ..'; tiBPByTechWanted='..repru(tiBPByTechWanted)) end
            if tiBPByTechWanted then
                for iTech = 1, iHighestTechEngiAvailable, 1 do
                    if tiBPByTechWanted[iTech] > 0 then
                        iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                        iBPWanted = iNearbyZonesWantingEngineers * 5 + tiBPByTechWanted[iTech]
                        HaveActionToAssign(refActionMoveToLandZone, iTech, iBPWanted, iAdjLZ, true)
                        if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                            iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                        end

                        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                        if bDebugMessages == true then LOG(sFunctionRef..': Want iBPWanted='..iBPWanted..' to go to lower priority adjacent iAdjLZ='..iAdjLZ..'; iNearbyZonesWantingEngineers='..iNearbyZonesWantingEngineers..'; iHighestTechEngiAvailable='..iHighestTechEngiAvailable) end
                        if iHighestTechEngiAvailable == 0 then break end
                    end
                end
            end
            if iHighestTechEngiAvailable == 0 then break end
        end
    end


    iCurPriority = iCurPriority + 1
    local iCoreWZWantingSupportAsLowerPriority
    --If have adjacent waterzone that has unbuilt mexes or is a core WZ, wants engineers and has no combat threat then assign engi
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have adjacent WZ that wants engineer for unbuilt mexes or core WZ, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
    if iHighestTechEngiAvailable > 0 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
        local iCurWZ, iCurPond
        local iBPAlreadyAssigned = 0
        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
            iCurWZ = tSubtable[M28Map.subrefAWZRef]
            iCurPond = M28Map.tiPondByWaterZone[iCurWZ]
            local tWZData = M28Map.tPondDetails[iCurPond][M28Map.subrefPondWaterZones][iCurWZ]
            local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
            --Use similar logic to minor land zone to avoid unintended consequences
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iCurWZ='..iCurWZ..'; Core base='..tostring(tWZTeamData[M28Map.subrefWZbCoreBase] or false)..'; tWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation]='..tostring(tWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation])..'; Does it have an empty table of unbuilt mex locations='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]))) end
            local bConsiderWaterZone = false
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]) == false then
                bConsiderWaterZone = true
            elseif tWZTeamData[M28Map.subrefWZbCoreBase] and tWZTeamData[M28Map.subrefTbWantBP] then
                --Do we already have a completed naval factory here and at least 1 engineer? if so not as high priority
                bConsiderWaterZone = true
                if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                    local tFactoriesAndEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tFactoriesAndEngineers) == false then
                        local iEngiCount = 0
                        local iCompletedFactoryCount = 0
                        for iUnit, oUnit in tFactoriesAndEngineers do
                            if oUnit:GetFractionComplete() == 1 then
                                if EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oUnit.UnitId) then
                                    iCompletedFactoryCount = iCompletedFactoryCount + 1
                                else
                                    iEngiCount = iEngiCount + 1
                                end
                            end
                        end
                        if iCompletedFactoryCount > 0 and iCompletedFactoryCount + iEngiCount >= 3 then
                            bConsiderWaterZone = false
                        end
                    end
                end
                if not(bConsiderWaterZone) then iCoreWZWantingSupportAsLowerPriority = iCurWZ end
            end
            if bConsiderWaterZone then

                if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to send engineers to an adjaent water zone, iCurWZ='..iCurWZ..'; tWZTeamData[M28Map.subrefTbWantBP]='..tostring(tWZTeamData[M28Map.subrefTbWantBP] or false)) end
                if tWZTeamData[M28Map.subrefTbWantBP] and tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 10 then
                    iBPWanted = 5
                    if tWZTeamData[M28Map.subrefTbWantBP] then
                        iBPWanted = math.min(40, math.max(tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]], tWZTeamData[M28Map.subrefTBuildPowerByTechWanted][1]))
                    end

                    HaveActionToAssign(refActionMoveToWaterZone, 1, iBPWanted + iBPAlreadyAssigned, iCurWZ, true)
                    iBPAlreadyAssigned = iBPAlreadyAssigned + iBPWanted
                    if bDebugMessages == true then LOG(sFunctionRef..': Tried to send engineers to iCurWZ '..iCurWZ..'; iBPWanted='..iBPWanted..'; iBPAlreadyAssigned='..iBPAlreadyAssigned) end
                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                    if iHighestTechEngiAvailable == 0 or iBPAlreadyAssigned >= tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 3 then break end
                end
            end

        end
    end

    --High priority reclaim if are low on mass or energy
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we will want to reclaim mass in LZ, bHaveLowMass='..tostring(bHaveLowMass)..'; tLZData[M28Map.subrefTotalMassReclaim]='..tLZData[M28Map.subrefTotalMassReclaim]) end
    if bHaveLowMass and tLZData[M28Map.subrefTotalMassReclaim] >= 50 and tLZData[M28Map.subrefTotalSignificantMassReclaim] > 0 then
        if bDebugMessages == true then LOG(sFunctionRef..': High priority reclaim, Total mass in Plateau '..iPlateau..' LZ '..iLandZone..'='..tLZData[M28Map.subrefTotalMassReclaim]) end
        HaveActionToAssign(refActionReclaimArea, 1, math.min(40, math.max(5, tLZData[M28Map.subrefTotalMassReclaim] / 50)), false)
    elseif M28Conditions.WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone) then
        HaveActionToAssign(refActionReclaimArea, 1, 5, true)
    end

    --TMD (including vs mobile ACUs with TML upgrade)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Considering if we want to get TMD; is table of units wanting TMD empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]) == false then
        local oUnitWantingTMD = M28Building.GetUnitWantingTMD(tLZData, tLZTeamData, iTeam)
        if bDebugMessages == true then LOG(sFunctionRef..': Is oUnitWantingTMD valid unit='..tostring(M28UnitInfo.IsUnitValid(oUnitWantingTMD))) end
        if oUnitWantingTMD then
            iBPWanted = 40
            if not(bHaveLowMass) and not(bHaveLowPower) then iBPWanted = 70 end
            if bDebugMessages == true then LOG(sFunctionRef..': Want to build TMD, iBPWanted='..iBPWanted..'; Unit wanting TMD='..oUnitWantingTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitWantingTMD)) end
            HaveActionToAssign(refActionBuildTMD, 2, iBPWanted, oUnitWantingTMD)
        end
    end

    --Approaching enemy guncom - prioritise upgrades if dont have T2, if do have T2 then get T2 PD
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if emergency PD is needed, iApproachingACUThreat='..iApproachingACUThreat) end
    if iApproachingACUThreat > 0 and (not(M28Overseer.bNoRushActive) or M28Overseer.iNoRushTimer - GetGameTimeSeconds() <= 120 or (not(bHaveLowMass) and not(bHaveLowPower) and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 0)) then
        --Do we have T2 (or a teammate has t3)?
        local bHaveSufficientTech = false
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then bHaveSufficientTech = true
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 then
            local tT2PlusFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory - categories.TECH1, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tT2PlusFactories) == false then
                for iUnit, oUnit in tT2PlusFactories do
                    if oUnit:GetFractionComplete() >= 1 and oUnit:GetAIBrain().M28AI then
                        bHaveSufficientTech = true
                        break
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveSufficientTech='..tostring(bHaveSufficientTech)) end
        if not(bHaveSufficientTech) and (M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 4) then
            --Do we have an active factory upgrade?
            local bHaveActiveHQUpgrade = false
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then
                for iUpgrade, oUpgrade in tLZTeamData[M28Map.subrefActiveUpgrades] do
                    if EntityCategoryContains(M28UnitInfo.refCategoryFactory, oUpgrade.UnitId) then
                        bHaveActiveHQUpgrade = true
                        break
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bHaveActiveHQUpgrade='..tostring(bHaveActiveHQUpgrade)) end
            if bHaveActiveHQUpgrade then
                iBPWanted = 20
                if not(bHaveLowPower) and not(bHaveLowMass) then iBPWanted = 40 end
                HaveActionToAssign(refActionAssistUpgrade, 1, iBPWanted)
                if bDebugMessages == true then LOG(sFunctionRef..': We have an active HQ upgrade so will assist this') end
            else
                --We need a priority upgrade
                local tExistingT1LandFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory * categories.TECH1, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if M28Utilities.IsTableEmpty(tExistingT1LandFactories) == false then
                    --Get factory with lowest fraction complete
                    local oFactoryToUpgrade
                    local iLowestWorkProgress = 1
                    for iFactory, oFactory in tExistingT1LandFactories do
                        if M28UnitInfo.IsUnitValid(oFactory) and oFactory:GetFractionComplete() then
                            if (oFactory:GetWorkProgress() or 0) < iLowestWorkProgress then
                                oFactoryToUpgrade = oFactory
                                iLowestWorkProgress = (oFactory:GetWorkProgress() or 0)
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Have searched for t1 land factories to upgrade, is oFactoryToUpgrade valid='..tostring(M28UnitInfo.IsUnitValid(oFactoryToUpgrade))) end
                    if oFactoryToUpgrade then
                        if bDebugMessages == true then LOG(sFunctionRef..': Doign priority upgrade for oFactoryToUpgrade='..oFactoryToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactoryToUpgrade)..' due to appraoching enemy ACU') end
                        M28Economy.UpgradeUnit(oFactoryToUpgrade, true)
                    end
                end
            end
        else
            --We have T2 tech (or only need T1 due to enemy not having gun), so want to build PD
            local iRangeThreshold = 30 --typical guncom range
            if not(bHaveSufficientTech) then iRangeThreshold = 1 end
            --Increase PD threat if enemy is in another zone that has PD in it
            local iCurPDThreat = GetPDThreatAboveRangeThresholdAlongPath(iPlateau, iLandZone, tLZData, tLZTeamData, iTeam, iRangeThreshold, tNearestEnemyACU)
            local iACUPlateauOrZero, iACULandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tNearestEnemyACU)
            if iACULandZone > 0 and iACUPlateauOrZero == iPlateau and not(iACULandZone == iLandZone) then
                --ACU is in a different land zone
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iACULandZone]][M28Map.subrefLZPath]) == false then
                    for iEntry, iAdjLZ in  tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iACULandZone]][M28Map.subrefLZPath] do
                        if not(iAdjLZ == iLandZone) then
                            local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                            if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
                                for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                                    if iRange >= iRangeThreshold then
                                        iCurPDThreat = iCurPDThreat + iThreat
                                    end
                                end
                            end
                        end
                    end
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': We have T2 or better or want T1 PD for nongun ACU, iCurPDThreat='..iCurPDThreat..'; iAppraochingACUThreat='..iApproachingACUThreat..'; bHaveSufficientTech='..tostring(bHaveSufficientTech)) end
            if (bHaveSufficientTech or iCurPDThreat == 0) and (iCurPDThreat <= math.max(1200, iApproachingACUThreat * 1.5) or (iCurPDThreat <= 2400 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 200 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0) and (iApproachingACUThreat >= 1400 or (M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU] and iApproachingACUThreat >= 1000)))) then
                --Do we have friendly mobile units iwth decent range in this zone or an adjacent zone? if so then reduce the threat needed
                local iNearbyMobileThreat = 0
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
                    for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                        if iRange >= iRangeThreshold then
                            iNearbyMobileThreat = iNearbyMobileThreat + iThreat
                        end
                    end
                end

                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                        if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
                            for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                                if iRange >= iRangeThreshold then
                                    iNearbyMobileThreat = iNearbyMobileThreat + iThreat * 0.5
                                end
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iNearbyMobileThreat='..iNearbyMobileThreat..'; iCurPDThreat='..iCurPDThreat..'; iApproachingACUThreat='..iApproachingACUThreat..'; Dist between ACU and this LZ midpoint='..M28Utilities.GetDistanceBetweenPositions(tNearestEnemyACU, tLZData[M28Map.subrefMidpoint])) end
                if iNearbyMobileThreat < 200 or iCurPDThreat < iApproachingACUThreat or iCurPDThreat + iNearbyMobileThreat < iApproachingACUThreat * 1.75 then
                    local iACUThreatFactorWanted = 1.75
                    --below check - ACU doesnt have gun yet and presumably not much veterancy, and we have near-full health T1 and T2 PD
                    if iApproachingACUThreat <= 1150 and iCurPDThreat >= 900 then
                        if (bHaveLowMass or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.3) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 6 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                            iACUThreatFactorWanted = 0.85 --i.e. if we have some nearby mobile threat (even if not much) will be enough
                        else
                            iACUThreatFactorWanted = 1.2
                        end
                    elseif iCurPDThreat >= 2400 and M28Utilities.GetDistanceBetweenPositions(tNearestEnemyACU, tLZData[M28Map.subrefMidpoint]) >= 80 then
                        iACUThreatFactorWanted = 1.4
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iACUThreatFactorWanted='..iACUThreatFactorWanted..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Lowest mass percent='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) end
                    if iCurPDThreat + iNearbyMobileThreat < iApproachingACUThreat * iACUThreatFactorWanted then
                        iBPWanted = 40
                        if not(bHaveLowMass) and not(bHaveLowPower) then iBPWanted = 80 end
                        local tTargetBuildLocation
                        if tNearestEnemyACU then
                            tTargetBuildLocation = GetStartSearchPositionForEmergencyPD(tNearestEnemyACU, tLZData[M28Map.subrefMidpoint], iPlateau, iLandZone)
                        end
                        local iPDTechLevelWanted = 2
                        if not(bHaveSufficientTech) then iPDTechLevelWanted = 1 end
                        HaveActionToAssign(refActionBuildEmergencyPD, iPDTechLevelWanted, iBPWanted, tTargetBuildLocation)
                        if bDebugMessages == true then LOG(sFunctionRef..': Will build emergency PD, iPDTechLevelWanted='..iPDTechLevelWanted) end
                    end
                end
            end
        end
    end

    --Nearby enemy ground threat and we dont already have at least 2 T2 PD
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if want emergency PD for normal ground threat, tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Is table of nearest DF enemies empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]))..'; iCurPriority='..iCurPriority..'; Norush active='..tostring(M28Overseer.bNoRushActive)..'; Time until norush nolonger active='..(GetGameTimeSeconds() - (M28Overseer.iNoRushTimer or 0))..'; Have low mass='..tostring(bHaveLowMass)..'; Have low power='..tostring(bHaveLowPower)..'; Mex count by tech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
    if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false and (not(M28Overseer.bNoRushActive) or M28Overseer.iNoRushTimer - GetGameTimeSeconds() <= 120 or (not(bHaveLowMass) and not(bHaveLowPower) and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 0)) then
        --Get existing T2 PD threat
        local iCurPDThreat = 0
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                iCurPDThreat = iCurPDThreat + iThreat
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iCurPDThreat='..iCurPDThreat..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end
        if (iCurPDThreat <= 1700 or (iCurPDThreat <= 2800 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 6 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) and (iCurPDThreat == 0 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] > 1) then
            --Get nearby enemy threat, but only for adjacent LZs
            local iEnemyThreat = tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]

            if bDebugMessages == true then LOG(sFunctionRef..': enemy combat threat in this zone='..iEnemyThreat..'; Is table of adjacent zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]))) end
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; Enemy threat in AdjLZ='..(tAltLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)..'; Mobile DF='..(tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)..'; Mobile indirect='..(tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)) end
                    --onlu use df+IF i best enemy structure range is > 0 and < 35
                    if (tAltLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) > 0 then
                        if (tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 50) < 35 then
                            iEnemyThreat = iEnemyThreat + (tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) + (tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)
                        else
                            iEnemyThreat = iEnemyThreat + math.max(math.min(500, (tAltLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)), (tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) + (tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0))
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iEnemyThreat='..iEnemyThreat) end
            if iCurPDThreat < iEnemyThreat * 3 then
                --Are the enemies in an adjacent zone with none in this zone? if so factor in PD in that zone as well
                local iClosestDist = 100000
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) then
                    local iCurDist
                    local oClosestUnit
                    for iUnit, oUnit in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oClosestUnit = oUnit
                            end
                        end
                    end
                    if oClosestUnit and iClosestDist >= 50 then
                        iCurPDThreat = GetPDThreatAboveRangeThresholdAlongPath(iPlateau, iLandZone, tLZData, tLZTeamData, iTeam, 1, oClosestUnit:GetPosition())
                    end
                end
                if iCurPDThreat < iEnemyThreat * 3 then
                    --Is this early-game, with a relatively low enemy threat, and do we have nearby combat units that can deal with the enemy?
                    local bWantToGetPD = true

                    if iEnemyThreat <= 600 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] <= 2 and GetGameTimeSeconds() <= 720 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 6 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                        local iNearbyFriendlyMobileThreat = tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                iNearbyFriendlyMobileThreat = iNearbyFriendlyMobileThreat + (tAltLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0)
                            end
                        end
                        if iNearbyFriendlyMobileThreat > iEnemyThreat * 1.2 or (bHaveLowMass and iCurPDThreat + iNearbyFriendlyMobileThreat > iEnemyThreat * 2.5) then
                            bWantToGetPD = false
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iNearbyFriendlyMobileThreat='..iNearbyFriendlyMobileThreat) end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': bWantToGetPD='..tostring(bWantToGetPD)..'; iEnemyThreat='..iEnemyThreat..'; Highest tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end
                    if bWantToGetPD then
                        iBPWanted = 40
                        if not(bHaveLowMass) and not(bHaveLowPower) then iBPWanted = 80 end
                        local tEnemiesToConsider = {}
                        local oNearestEnemy
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                            for iUnit, oUnit in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                                if M28UnitInfo.IsUnitValid(oUnit) then
                                    table.insert(tEnemiesToConsider, oUnit)
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(tEnemiesToConsider) == false then
                            if not(oNearestEnemy) then oNearestEnemy = M28Utilities.GetNearestUnit(tLZTeamData[M28Map.reftoNearestDFEnemies], tLZData[M28Map.subrefMidpoint], true, M28Map.refPathingTypeLand) end
                            if oNearestEnemy then
                                local tTargetBuildLocation = GetStartSearchPositionForEmergencyPD(oNearestEnemy:GetPosition(), tLZData[M28Map.subrefMidpoint], iPlateau, iLandZone)
                                local iMinTechWanted = 1
                                if iCurPDThreat > 0 then iMinTechWanted = 2 end
                                HaveActionToAssign(refActionBuildEmergencyPD, iMinTechWanted, iBPWanted, tTargetBuildLocation)
                                if bDebugMessages == true then LOG(sFunctionRef..': Will build emergency PD to stop enemy ground threat, iMinTechWanted='..iMinTechWanted) end
                            end
                        end
                    end
                end
            end
        end
    end

    --High priority T1 radar if we have T2 arti but poor radar coverage
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; Radar coverage='..tLZTeamData[M28Map.refiRadarCoverage]..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]) end
    if (not(bHaveLowPower) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 100) and (tLZTeamData[M28Map.refiRadarCoverage] <= 100 or (M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.refoBestRadar]) and tLZTeamData[M28Map.refoBestRadar]:GetFractionComplete() < 1)) then
        --Do we have T2 arti in this zone, or T2 PD with poor radar, or lots of mexes
        if bDebugMessages == true then LOG(sFunctionRef..': T3 mex count='..tLZTeamData[M28Map.subrefMexCountByTech][3]..'; Is table of T2 arti empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))) end
        if tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false or (tLZTeamData[M28Map.refiRadarCoverage] <= 50 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryT2PlusPD, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false) then
            local bWantT1DueToRadarUnderConstruction = false
            if M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.refoBestRadar]) and tLZTeamData[M28Map.refoBestRadar]:GetFractionComplete() < 1 then
                local tRadarInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryRadar, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                bWantT1DueToRadarUnderConstruction = true
                if M28Utilities.IsTableEmpty(tRadarInZone) == false then
                    for iUnit, oUnit in tRadarInZone do
                        if M28UnitInfo.IsUnitValid(oUnit) and (oUnit:GetFractionComplete() == 1 or EntityCategoryContains(categories.TECH1, oUnit.UnitId)) then
                            bWantT1DueToRadarUnderConstruction = false
                            break
                        end
                    end
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) end
            --T1 radar
            local bWantT1RadarFirst = false
            if (bWantT1DueToRadarUnderConstruction or tLZTeamData[M28Map.refiRadarCoverage] <= 50) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 25 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2.5 then
                --Check we dont already have t1 radar in the land zone
                if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryT1Radar, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) then
                    iBPWanted = 5
                    if not(bHaveLowMass) then iBPWanted = 15 end
                    bWantT1RadarFirst = true
                    HaveActionToAssign(refActionBuildT1Radar, 1, iBPWanted)
                    if bDebugMessages == true then LOG(sFunctionRef..': High priority T1 radar builder, iBPWanted='..iBPWanted) end
                end
            end

            --T2 radar
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if want T2 radar, tLZTeamData[M28Map.refiRadarCoverage]='..tLZTeamData[M28Map.refiRadarCoverage]..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; bWantT1RadarFirst='..tostring(bWantT1RadarFirst)) end
            if not(bWantT1RadarFirst) and tLZTeamData[M28Map.refiRadarCoverage] <= 130 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 100 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 5 then
                --Check we dont already have t2 radar in the land zone
                if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryT2Radar, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) then
                    iBPWanted = 20
                    if not(bHaveLowMass) then iBPWanted = 60 end
                    if bDebugMessages == true then LOG(sFunctionRef..': High priority t2 radar builder') end
                    HaveActionToAssign(refActionBuildT2Radar, 2, iBPWanted)
                end
            end
        end
    end

    --T2 arti if enemy has sniper bots or fatboy, or a firebase that threatens this zone
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want emergency T2 arti, iCurPriority='..iCurPriority..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]..'; Friendly tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Is table of pathing to other zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]))..'; Is tLZTeamData[M28Map.subreftEnemyFirebasesInRange] empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]))) end
    if (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 5) and (not(M28Overseer.bNoRushActive) or M28Overseer.iNoRushTimer - GetGameTimeSeconds() <= 180 or (not(bHaveLowMass) and not(bHaveLowPower) and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 0)) then
        local iRangeThreshold = 65
        local iEnemyLongRangeThreat = 0
        local iSearchRange = 300
        local iBestEnemyRange = 0
        local iCurDFThreat, iCurIFThreat
        local iHighestIndividiualLongRangeThreat = (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0)

        if tLZTeamData[M28Map.refbBaseInSafePosition] then
            iSearchRange = 200
            iHighestIndividiualLongRangeThreat = iHighestIndividiualLongRangeThreat * 0.5
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of firebases in range empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]))) end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
            for iFirebase, tPlateauAndZone in tLZTeamData[M28Map.subreftEnemyFirebasesInRange] do
                iEnemyLongRangeThreat = iEnemyLongRangeThreat + math.max(1500, (M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefThreatEnemyStructureTotalMass] or 0))
                if bDebugMessages == true then LOG(sFunctionRef..': iEnemyLongRangeThreat after increasing for firebase in tPlateauAndZone '..repru(tPlateauAndZone)..'='..iEnemyLongRangeThreat) end
            end
        end
        --Only consider enemy long range threat in adjacent zones - if already in this zone then presumably too close for arti to help that much
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
            for iEntry, tSubtable in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                if tSubtable[M28Map.subrefLZTravelDist] > iSearchRange then break
                else
                    local iAltLZ = tSubtable[M28Map.subrefLZNumber]
                    local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAltLZ][M28Map.subrefLZTeamData][iTeam]
                    iCurDFThreat = 0
                    iCurIFThreat = 0
                    if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) == false then
                        for iRange, iThreat in tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] do
                            if iRange >= iRangeThreshold then
                                iCurDFThreat = iCurDFThreat + iThreat
                                iBestEnemyRange = math.max(iBestEnemyRange, iRange)
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange]) == false then
                        for iRange, iThreat in tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] do
                            if iRange >= iRangeThreshold then
                                iCurIFThreat = iCurIFThreat + iThreat
                                iBestEnemyRange = math.max(iBestEnemyRange, iRange)
                            end
                        end
                    end
                    iEnemyLongRangeThreat = iEnemyLongRangeThreat + math.max(iCurIFThreat, iCurDFThreat)
                    if not(tLZTeamData[M28Map.refbBaseInSafePosition]) then iHighestIndividiualLongRangeThreat = math.max(iHighestIndividiualLongRangeThreat, (tAltLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0)) end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering iAltLZ='..iAltLZ..'; iCurIFThreat='..iCurIFThreat..'; iCurDFThreat='..iCurDFThreat..'; iEnemyLongRnageThreat='..iEnemyLongRangeThreat..'; tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]='..repru(tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange])..'; tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange]='..repru(tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange])) end
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': iEnemyLongRangeThreat after checking all zones within dist threshold='..iEnemyLongRangeThreat..'; iHighestIndividiualLongRangeThreat='..iHighestIndividiualLongRangeThreat) end
        if iEnemyLongRangeThreat >= 750 or iHighestIndividiualLongRangeThreat > 0 or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then

                --Increase long range threat based on enemy T2 arti within 175 of our midpoint
                for iT2Arti, oT2Arti in tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits] do
                    if M28UnitInfo.IsUnitValid(oT2Arti) then
                        if M28Utilities.GetDistanceBetweenPositions(oT2Arti:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= (oT2Arti[M28UnitInfo.refiIndirectRange] or 'nil') + 50 then
                            iBestEnemyRange = math.max(iBestEnemyRange, (oT2Arti[M28UnitInfo.refiIndirectRange] or 'nil'))
                            iEnemyLongRangeThreat = iEnemyLongRangeThreat + oT2Arti:GetBlueprint().Economy.BuildCostMass
                        end
                    end
                end
            elseif iHighestIndividiualLongRangeThreat then iBestEnemyRange = math.max(iBestEnemyRange, 80) end



            --What is our long range threat that equals their range?
            iCurDFThreat = 0
            iCurIFThreat = 0
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
                for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                    if iRange >= iBestEnemyRange then iCurDFThreat = iCurDFThreat + iThreat end
                end
            end
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange]) == false then
                for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] do
                    if iRange >= iBestEnemyRange then iCurIFThreat = iCurIFThreat + iThreat end
                end
            end
            local iThreatWanted = math.max(iEnemyLongRangeThreat * 1.5, iHighestIndividiualLongRangeThreat * 0.75) - iCurDFThreat - iCurIFThreat
            if iEnemyLongRangeThreat >= 1600 then iThreatWanted = math.max(iThreatWanted, 500) end --Want 1 T2 arti if enemy has significant long rnage threat, even if we have friendly units
            if bDebugMessages == true then LOG(sFunctionRef..': iCurDFThreat='..iCurDFThreat..'; iCurIFThreat='..iCurIFThreat..'; iThreatWanted='..iThreatWanted) end
            if iThreatWanted >= 500 or (iThreatWanted > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 18 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                --Get friendly T2 arti threat
                local iT2ArtiThreat = 0
                local iT2ArtiCount = 0
                local tT2Arti
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                    tT2Arti = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tT2Arti) == false then
                        iT2ArtiThreat = M28UnitInfo.GetCombatThreatRating(tT2Arti, false, true) --Will be 60% of mass cost per getcombatthreatrating
                        for iArti, oArti in tT2Arti do
                            if oArti:GetFractionComplete() == 1 then iT2ArtiCount = iT2ArtiCount + 1 end
                        end
                    end
                end
                if iT2ArtiThreat >= 10000 then iThreatWanted = iThreatWanted * 0.75 end
                if tLZTeamData[M28Map.refbBaseInSafePosition] then iThreatWanted = iThreatWanted * 0.75 end
                iThreatWanted = iThreatWanted - iT2ArtiThreat
                if bDebugMessages == true then LOG(sFunctionRef..': iT2ArtiThreat='..iT2ArtiThreat..'; iThreatWanted='..iThreatWanted) end
                if iThreatWanted >= 500 or (iThreatWanted > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 18 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                    if iThreatWanted <= 4000 and iT2ArtiThreat >= 1000 then
                        iBPWanted = math.min(120, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 10 / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])
                        if bHaveLowMass or bHaveLowPower then iBPWanted = iBPWanted * 0.5 end
                    else
                        --Presumably up against a fatboy or are outranged and have no T2 arti so need T2 arti asap
                        iBPWanted = math.min(240, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 10)
                        if bHaveLowMass or bHaveLowPower then iBPWanted = iBPWanted * 0.75 end
                    end

                    --Build shield instead of T2 art ifi we ahve 2+ T2 arti and want shielding for them
                    local bGetShieldingInstead = false
                    if iT2ArtiCount >= 2 and tT2Arti and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitWantingFixedShield]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, tLZTeamData[M28Map.reftoLZUnitWantingFixedShield])) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want shielding for land zone for T2 arti unless we already have several fixed shields') end
                        local tExistingFixedShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                        local iExistingShields = 0
                        if M28Utilities.IsTableEmpty(tExistingFixedShields) == false then
                            for iShield, oShield in tExistingFixedShields do
                                if oShield:GetFractionComplete() == 1 then
                                    iExistingShields = iExistingShields + 1
                                end
                            end
                        end
                        if iExistingShields < 2 and (iExistingShields == 9 or iT2ArtiCount >= 3) then bGetShieldingInstead = true end
                    end
                    local oArtiToShield
                    if bGetShieldingInstead then
                        for iArti, oArti in tT2Arti do
                            if M28Utilities.IsTableEmpty(oArti[M28Building.reftoShieldsProvidingCoverage]) then
                                oArtiToShield = oArti
                                break
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': oArtiToShield='..(oArtiToShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oArtiToShield) or 'nil')) end
                    end

                    if bGetShieldingInstead and M28UnitInfo.IsUnitValid(oArtiToShield) then
                        iBPWanted = iBPWanted * 0.75
                        HaveActionToAssign(refActionBuildShield, 2, iBPWanted, oArtiToShield)
                        if bDebugMessages == true then LOG(sFunctionRef..': Will build shield to cover arti isntead of more arti; however will still try more arti as slightly lower priority') end
                        iCurPriority = iCurPriority + 1
                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 10 then iBPWanted = iBPWanted * 0.5 end
                    end
                    --adjust location to build if we already have 3 t2 arti so we build towards enemy
                    local tLocationToBuild
                    if iT2ArtiCount >= 3 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) then
                        tLocationToBuild = M28Utilities.MoveInDirection(tLZData[M28Map.subrefMidpoint], M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase]), 20, true, false)
                        if not(NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, tLocationToBuild) == iPlateau) then
                            tLocationToBuild = {tLZData[M28Map.subrefMidpoint][1]. tLZData[M28Map.subrefMidpoint][2]. tLZData[M28Map.subrefMidpoint][3]}
                        end
                    else
                        tLocationToBuild = {tLZData[M28Map.subrefMidpoint][1], tLZData[M28Map.subrefMidpoint][2], tLZData[M28Map.subrefMidpoint][3]}
                    end

                    HaveActionToAssign(refActionBuildEmergencyArti, 2, iBPWanted, tLocationToBuild)
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to build emergency arti, iBPWanted='..iBPWanted) end

                end
            end

        end
    end

    --Extra (second) shielding in a high mass scenario - will only try to shield t3 arti/game ender
    iCurPriority = iCurPriority + 1
    if (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 500 then

        local iBPWanted, iTechLevelWanted, oUnitToShield = GetBPMinTechAndUnitForFixedShields(tLZTeamData, iTeam, true, bHaveLowMass, bWantMorePower, true, iLandZone, iPlateau)
        if iBPWanted > 0 then
            iBPWanted = math.min(iBPWanted, 40)

            HaveActionToAssign(refActionBuildSecondShield, iTechLevelWanted, iBPWanted, oUnitToShield)
            if bDebugMessages == true then LOG(sFunctionRef..': Second shield builder, iBPWanted='..iBPWanted..'; iLandZone='..iLandZone) end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Dont want to assign any BP to second shield builder, LZ='..iLandZone) end
        end
    end


    --Preemptive fixed AA if we have T2+ air fac and no fixed T2+ ground AA and dont have much MAA threat here either
    --Also includes T3 SAM preemptive builder in greater numbers if we lack air control and have at least 10 mass per tick and not low mass
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want fixed AA due to haveing T2+ air, iCurPriority='..iCurPriority..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]..'; tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 2 and tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < 800 * (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] - 1) then
        --Do we already have fixed AA in this LZ?
        local iAACategory = M28UnitInfo.refCategoryStructureAA - categories.TECH1
        if M28Team.subrefiHighestFriendlyFactoryTech >= 3 then iAACategory = iAACategory * categories.TECH3 end
        local tExistingFixedAA = EntityCategoryFilterDown(iAACategory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local bHaveFixedAA = false
        if M28Utilities.IsTableEmpty(tExistingFixedAA) == false then
            for iUnit, oUnit in tExistingFixedAA do
                if oUnit:GetFractionComplete() then bHaveFixedAA = true break end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveFixedAA='..tostring(bHaveFixedAA)) end
        if not(bHaveFixedAA) then
            iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
            if iNearbyEnemyAirToGroundThreat > 0 then iBPWanted = iBPWanted * 2 end
            if not(bHaveLowPower) then
                if not(bHaveLowMass) then iBPWanted = iBPWanted * 3
                else iBPWanted = iBPWanted * 1.5
                end
            end
            HaveActionToAssign(refActionBuildAA, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted)
            if bDebugMessages == true then LOG(sFunctionRef..': T2 plus preemptive AA builder, iBPWanted='..iBPWanted) end
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 and not(bHaveLowMass) and not(M28Team.tTeamData[iTeam][M28Team.refbHaveAirControl]) and table.getn(tExistingFixedAA) < 4 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 then
            if bDebugMessages == true then LOG(sFunctionRef..': Want to get T3 AA preemptively') end
            HaveActionToAssign(refActionBuildAA, 3, 30)
        end
    end

    --Second power builder to help scale power late game if high on mass
    iCurPriority = iCurPriority + 1
    if bWantMorePower and not(bHaveLowMass) and ((M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 0) >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 * (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 1)) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 120 * (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 1) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0) * 1.25 then
        iBPWanted = tiBPByTech[(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 1)] * 10
        --reduce BP wanted if dont have massive amount of mass
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] <= 5000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 25 then iBPWanted = iBPWanted * 0.6 end
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 500 then
            iBPWanted = iBPWanted * 0.5 --i.e. want to have construction started so primary power builder can build sooner but not as worried about building this really fast
        end
        HaveActionToAssign(refActionBuildSecondPower, (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 1), iBPWanted)
        if bDebugMessages == true then LOG(sFunctionRef..': Want to build second power due to lots of mass and having recently needed more energy for air production') end
    end

    --Similar to above but for third power with slightly greater mass threshold, and only for very high mass and energy incomes, and only if have stalled for power in last 60s
    iCurPriority = iCurPriority + 1
    if bWantMorePower and not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 8000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 60 and (GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or 0) <= 60 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0) * 1.1) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 0) >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 1500 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0) * 1.25 then
        iBPWanted = 325 --10 T3 engis
        --reduce BP wanted if dont have massive amount of mass
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] <= 15000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 80 then iBPWanted = 150 end
        HaveActionToAssign(refActionBuildThirdPower, 3, iBPWanted)
        if bDebugMessages == true then LOG(sFunctionRef..': Want to build second power due to lots of mass and having recently needed more energy for air production') end
    end

    --Assist air fac if at T2+ and want more factories
    iCurPriority = iCurPriority + 1
    if not(bWantMorePower) and (not(bHaveLowMass) or bWantMoreFactories) then
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 2 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 or M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryAllAir - categories.TECH1) <= 5) then
            --Check we have more power than when we last were unable to build air units
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] > (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0) * 1.25 then
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                    local tT2PlusAirFacsInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory * M28UnitInfo.ConvertTechLevelToCategory(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]), tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(   tT2PlusAirFacsInLZ) == false and (not(bHaveLowMass) or tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                        if bHaveLowMass then iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 1.5
                        else
                            iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 4
                            if not(bWantMorePower) then iBPWanted = iBPWanted * 2 end
                        end
                        local oAirFactoryToAssist
                        local iHighestAirFac = 0
                        local iCurTechLevel
                        for iFactory, oFactory in tT2PlusAirFacsInLZ do
                            iCurTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
                            if iCurTechLevel > iHighestAirFac then
                                iHighestAirFac = iCurTechLevel
                                oAirFactoryToAssist = oFactory
                            end
                        end
                        if oAirFactoryToAssist then
                            HaveActionToAssign(refActionAssistAirFactory, 1, iBPWanted, oAirFactoryToAssist)
                        end
                    end
                end
            end
        end
    end

    --High priority factories
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to build a factory, bWantMoreFactories='..tostring(bWantMoreFactories)..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Mass % stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; Highest tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end
    if bWantMoreFactories and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 11 and (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 and GetGameTimeSeconds() <= 600 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.05) or (M28Map.iMapSize <= 256 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 150 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0)))) then
        if (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 0) > 0 then
            if bHaveLowMass then iBPWanted =  tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2
            else iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 4
            end
        else
            iBPWanted = 5
        end

        local bWantAirNotLand = M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)
        local iFactoryAction
        if bWantAirNotLand then iFactoryAction = refActionBuildAirFactory
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Want to build land factory not air factory2') end
            iFactoryAction = refActionBuildLandFactory
        end

        local tFactoriesInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryAirFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tFactoriesInZone) == false then
            for iUnit, oUnit in tFactoriesInZone do
                if oUnit:GetFractionComplete() < 1 and not(oUnit:IsUnitState('Upgrading')) and not(oUnit:IsUnitState('BeingUpgraded')) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a factory under construction in this zone already, unit state='..M28UnitInfo.GetUnitState(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                    if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oUnit.UnitId) then iFactoryAction = refActionBuildAirFactory
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) then iFactoryAction = refActionBuildLandFactory
                    end
                end
            end
        end

        if bHaveLowPower and bWantAirNotLand then iBPWanted = iBPWanted * 0.5 end
        if bDebugMessages == true then LOG(sFunctionRef..': Wnat to build a factory, iBPWanted='..iBPWanted..'; iFactoryAction='..iFactoryAction..'; bWantAirNotLand='..tostring(bWantAirNotLand)) end
        HaveActionToAssign(iFactoryAction, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted, nil)
    end


    --High priority islands (early-game expansion)
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS)
    iCurPriority = iCurPriority + 1
    local iBPAlreadyTraveling = 0
    GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if bDebugMessages == true then LOG(sFunctionRef..': Core LZ considering engis for islands, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Time='..GetGameTimeSeconds()) end
    if iHighestTechEngiAvailable > 0 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of pathing to other islands empty='..tostring(tLZData[M28Map.subrefLZPathingToOtherIslands])) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
            local iDistanceThreshold = math.max(125, M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) * 0.502)
            if bDebugMessages == true then LOG(sFunctionRef..': iDistanceThreshold='..iDistanceThreshold) end

            for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..'; Travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; tPathingData[M28Map.subrefIslandClosestLZRef]='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; Are there enemies in this or adjacnet LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                if tPathingData[M28Map.subrefIslandTravelDist] > iDistanceThreshold then break
                else
                    --Are there enemies in the target LZ?
                    local tIslandLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]]
                    if tPathingData[M28Map.subrefIslandClosestLZRef] and M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefMexUnbuiltLocations]) == false and (tIslandLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] or 0) == 0 then
                        local iEnemyThreatNearby = 0
                        if tIslandLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                            if M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                    iEnemyThreatNearby = iEnemyThreatNearby + (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..'; iEnemyThreatNearby='..iEnemyThreatNearby) end
                        if iEnemyThreatNearby <= 10 then
                            local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, tPathingData[M28Map.subrefIslandClosestLZRef], iEntry, iHighestTechEngiAvailable, false, true)
                            if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                            if tiBPByTechWanted then
                                --Is it either a minor zone, or a core zone that either wants lots of BP or doesnt have any engineers traveling to it?
                                for iTech = 1, iHighestTechEngiAvailable, 1 do
                                    if tiBPByTechWanted[iTech] > 0 then
                                        iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                        iBPWanted = iBPAlreadyTraveling + 5
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and assign an engineer to go to tPathingData[M28Map.subrefIslandClosestLZRef]='..tPathingData[M28Map.subrefIslandClosestLZRef]..'; BP wanted='..iBPWanted..'; iTech='..iTech..'; iPrevEngisAvailable='..iPrevEngisAvailable) end
                                        HaveActionToAssign(refActionMoveToLandZone, iTech, iBPWanted, tPathingData[M28Map.subrefIslandClosestLZRef], true)
                                        if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                            iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                            iBPAlreadyTraveling = iBPAlreadyTraveling + tiBPByTech[iTech]
                                        end

                                        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                        if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable after this='..iHighestTechEngiAvailable) end
                                        if iHighestTechEngiAvailable == 0 then break end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    --TML if enemy has vulnerable units
    iCurPriority = iCurPriority + 1
    if iHighestTechEngiAvailable >= 2 and not(bHaveLowPower) then
        iBPWanted = GetBPToAssignToBuildingTML(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam, bHaveLowMass)
        if iBPWanted > 0 then
            HaveActionToAssign(refActionBuildTML, 2, iBPWanted)
        end
    end



    --Energy storage once have eco to support it
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; Considering building energy storage, Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; Have low power='..tostring(bHaveLowPower)..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount]='..M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount]..'; Enemy unit with highest health='..M28Team.tTeamData[iTeam][M28Team.refiEnemyHighestMobileLandHealth]) end
    if not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] <= 7 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 1 + M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] * 5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 30 + M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] * 20 and (((M28Map.bIsCampaignMap or (GetGameTimeSeconds() >= 600 and M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] == 0)) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1 + 0.25 * M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount]) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2.5 + 0.25 * M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount])) then
        --Do we have enough storage to 1-shot any enemy unit?
        if M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] < math.max(1, math.ceil((M28Team.tTeamData[iTeam][M28Team.refiEnemyHighestMobileLandHealth] / 0.9 - 1000) / (0.25 * M28Building.iEnergyStorageExpectedCapacity))) then
            --Is the number of storage in this LZ <= lowest storage count?
            local toStorageInThisLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryEnergyStorage, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            local iStorageInThisLZ
            if M28Utilities.IsTableEmpty(toStorageInThisLZ) == false then
                iStorageInThisLZ = table.getn(toStorageInThisLZ)
            else
                iStorageInThisLZ = 0
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iStorageInThisLZ='..iStorageInThisLZ) end
            if iStorageInThisLZ <= M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to get storage, Is tEngineers[1] valid='..tostring(M28UnitInfo.IsUnitValid(tEngineers[1]))) end
                iBPWanted = 5
                if not(bHaveLowMass) then iBPWanted = 20 end
                HaveActionToAssign(refActionBuildEnergyStorage, 1, iBPWanted)
            end
        end
    end

    --1 T3 mass fab if not defending against T3 arti and have lots of t3 mexes
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and tLZTeamData[M28Map.subrefMexCountByTech][3] >= tLZData[M28Map.subrefLZMexCount] and not(bHaveLowPower) and not(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) then
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 250 + 500 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or (M28Map.bIsLowMexMap and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 260 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
            local iExistingT3MassFabs = 0
            local iUnderConstructionT3MassFabs = 0
            local tExistingMassFabs = EntityCategoryFilterDown(M28UnitInfo.refCategoryMassFab * categories.TECH3, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty( tExistingMassFabs) == false then
                for iUnit, oUnit in tExistingMassFabs do
                    if oUnit:GetFractionComplete() < 1 then iUnderConstructionT3MassFabs = iUnderConstructionT3MassFabs + 1
                    else iExistingT3MassFabs = iExistingT3MassFabs + 1
                    end
                end
            end
            if iExistingT3MassFabs == 0 or iUnderConstructionT3MassFabs > 0 or (iExistingT3MassFabs <= 4 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 8 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or M28Map.bIsLowMexMap)) then
                iBPWanted = 90
                if bWantMorePower then iBPWanted = 45 end
                HaveActionToAssign(refActionBuildT3MassFab, 3, iBPWanted)
            elseif M28Map.bIsLowMexMap then
                local tQuantumGateways = EntityCategoryFilterDown(M28UnitInfo.refCategoryQuantumGateway, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                local iExistingGateways = 0
                if M28Utilities.IsTableEmpty( tQuantumGateways) == false then
                    for iUnit, oUnit in tQuantumGateways do
                        if oUnit:GetFractionComplete() == 1 then
                            iExistingGateways = iExistingT3MassFabs + 1
                        end
                    end
                end
                if iExistingGateways == 0 then
                    iBPWanted = 70
                    if bWantMorePower then iBPWanted = 35 end
                    HaveActionToAssign(refActionBuildQuantumGateway, 3, iBPWanted)
                end

            end
        end
    end

    --Shielding
    iCurPriority = iCurPriority + 1
    local iTechLevelWanted, oUnitToShield
    iBPWanted, iTechLevelWanted, oUnitToShield = GetBPMinTechAndUnitForFixedShields(tLZTeamData, iTeam, true, bHaveLowMass, bWantMorePower, false, iLandZone, iPlateau)
    if iBPWanted > 0 then
        if bDebugMessages == true then LOG(sFunctionRef..': Want to build a shield, iBPWanted='..iBPWanted..'; bHaveLowMass='..tostring(bHaveLowMass)..'; bWantMorePower='..tostring(bWantMorePower)..'; oUnitToShield='..oUnitToShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToShield)..'; iTechLevelWanted='..iTechLevelWanted) end
        HaveActionToAssign(refActionBuildShield, iTechLevelWanted, iBPWanted, oUnitToShield)
    end

    --AA including SAMs
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Do we want more airaa? iNearbyEnemyAirToGroundThreat='..iNearbyEnemyAirToGroundThreat..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]) end
    if iNearbyEnemyAirToGroundThreat > 0 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= math.max(tLZTeamData[M28Map.subrefLZThreatAllyGroundAA], 800) then
        local iGroundAAThreatWanted
        if M28Team.tTeamData[iTeam][M28Team.refbHaveAirControl] then
            iGroundAAThreatWanted = M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.4 + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.15
        elseif M28Team.tTeamData[iTeam][M28Team.refbFarBehindOnAir] then
            iGroundAAThreatWanted = M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.8 + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.3
            if M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] >= 2000 then iGroundAAThreatWanted = iGroundAAThreatWanted + math.min(M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.15, M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat]) end
        else
            iGroundAAThreatWanted = M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.6 + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.225
            if M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] >= 2000 then iGroundAAThreatWanted = iGroundAAThreatWanted + math.min(M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.1, M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat]) end
        end
        iGroundAAThreatWanted = math.max(iNearbyEnemyAirToGroundThreat * 2, iNearbyEnemyAirToGroundThreat + iGroundAAThreatWanted)
        --Cap Ground AA at equiv of 3 T2 flak if no enemy air to ground threat in this zone, and we arent at T3
        if iGroundAAThreatWanted >= 2400 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) then
            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 then
                iGroundAAThreatWanted = 2400
            else
                --At T3 - reduce the amount of fixed AA wanted slightly for very high threat values (i.e. >= 10 SAM equivalent)
                if iGroundAAThreatWanted >= 16000 then
                    if iGroundAAThreatWanted >= 30000 then
                        iGroundAAThreatWanted = 16000 + 14000 * 0.75 + (iGroundAAThreatWanted - 30000) * 0.5
                    else
                        iGroundAAThreatWanted = 16000 + (iGroundAAThreatWanted - 16000) * 0.75
                    end
                end

                --Campaign maps - further reduce amount earlier into the game
                if M28Map.bIsCampaignMap and iGroundAAThreatWanted >= 8000 and (bHaveLowMass or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.4) and (tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] >= math.max(20000, 1000 * M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) or GetGameTimeSeconds() <= 15 * 60) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= math.max(20, tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] / 1000)) then
                    iGroundAAThreatWanted = math.min((iGroundAAThreatWanted - 8000) * 0.25 + 8000, 12000)
                end
            end
        end
        --= M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]
        if tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < iGroundAAThreatWanted or (tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] <= 1600 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 or (tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < 1200 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2) or tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < 120)) then
            --Do we already have fixed AA in this LZ?
            local iAACategory = M28UnitInfo.refCategoryStructureAA
            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then iAACategory = iAACategory * categories.TECH3 end
            local tExistingFixedAA = EntityCategoryFilterDown(iAACategory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of fixed AA empty='..tostring(M28Utilities.IsTableEmpty(tExistingFixedAA))..'; Ally groundAA threat='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]..'; Highest enemy air tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech]..'; Enemy air to ground threat='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Enemy AirAA threat='..tLZTeamData[M28Map.refiEnemyAirAAThreat]..'; iGroundAAThreatWanted='..iGroundAAThreatWanted..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end
            if M28Utilities.IsTableEmpty(tExistingFixedAA) or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < math.max(1500 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech], tLZTeamData[M28Map.refiEnemyAirToGroundThreat] * 3 + tLZTeamData[M28Map.refiEnemyAirAAThreat], iGroundAAThreatWanted)) or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 and tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < math.max(425 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech], tLZTeamData[M28Map.refiEnemyAirToGroundThreat] * 3 + tLZTeamData[M28Map.refiEnemyAirAAThreat] * 0.5, iGroundAAThreatWanted)) then
                --Cap amount of SAMs if we dont have all T3 mexes in the zone and have low mass
                if bDebugMessages == true then LOG(sFunctionRef..': bHaveLowMass='..tostring(bHaveLowMass)..'; Is table of enemy air units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]))..'; Ally groundAA threat='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]..'; Mex count by tech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; Team gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Active brain count='..M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) end
                if not(bHaveLowMass and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) and tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] >= 6000 and (tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][1]) > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] > 15 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                    iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
                    if iNearbyEnemyAirToGroundThreat > 0 then iBPWanted = iBPWanted * 2 end
                    if not(bHaveLowPower) then
                        if not(bHaveLowMass) then iBPWanted = iBPWanted * 4
                        else iBPWanted = iBPWanted * 2
                        end
                    end
                    HaveActionToAssign(refActionBuildAA, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted)
                    if bDebugMessages == true then LOG(sFunctionRef..': WIll build more AA, iBPWanted='..iBPWanted) end
                end
            end
        end
    end

    --Reclaim specific units
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if have units to reclaim, is table empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoUnitsToReclaim]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoUnitsToReclaim]) == false then
        local bObjectiveToReclaim = false
        if M28Map.bIsCampaignMap then
            for iUnit, oUnit in tLZTeamData[M28Map.subreftoUnitsToReclaim] do
                if oUnit[M28UnitInfo.refbIsReclaimTarget] then bObjectiveToReclaim = true break end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Want to try and reclaim, bObjectiveToReclaim='..tostring(bObjectiveToReclaim)) end
        HaveActionToAssign(refActionReclaimFriendlyUnit, 1, math.min(2 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]], math.max(10, 10 * table.getn(tLZTeamData[M28Map.subreftoUnitsToReclaim]))), nil, not(bObjectiveToReclaim))
    end




    --More power
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': More power builder, bHaveLowMass='..tostring(bHaveLowMass)..'; bWantMorePower='..tostring(bWantMorePower)..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Highest friendly factory tech='..(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 'nil')) end
    if not(bHaveLowMass) and bWantMorePower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 11 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 0) > 0 then
        iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 5
        if bDebugMessages == true then LOG(sFunctionRef..': Want more power, iCurPriority='..iCurPriority..'; iBPWanted='..iBPWanted) end
        HaveActionToAssign(refActionBuildPower, iMinTechLevelForPower, iBPWanted)
    end

    --Assist ACU going for teleporter
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of upgrading ACUs on team empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingACUs]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingACUs]) == false then
        local oACUUpgradingForTeleportInThisZone
        local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua') --done here incase having it above causes issues (havent actually tested, but m28acu refers to parts of m28engineer)
        if M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingACUs], false) then
            for iACU, oACU in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingACUs] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering upgrading ACU oACU='..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' owned by brain '..oACU:GetAIBrain().Nickname..'; Unit state='..M28UnitInfo.GetUnitState(oACU)..'; Planning to get teleport='..tostring(oACU[M28ACU.refbPlanningToGetTeleport])) end
                if oACU[M28ACU.refbPlanningToGetTeleport] and oACU:IsUnitState('Upgrading') then
                    --Is ACU in this zone or nearby?

                    local iACUPlateauOrZero, iACULandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oACU:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': Have ACU wanting to get teleport whose unit state is upgrading, ACU brain='..oACU:GetAIBrain().Nickname..'; iACUPlateauOrZero='..(iACUPlateauOrZero or 'nil')..'; iACULandOrWaterZone='..(iACULandOrWaterZone or 'nil')..'; This plateau='..iPlateau..'; This LZ='..iLandZone..'; Dist from ACU to this zone midpoint='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oACU:GetPosition())) end
                    if iACUPlateauOrZero == iPlateau and iACULandOrWaterZone == iLandZone then --or M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oACU:GetPosition()) <= 100) then
                        oACUUpgradingForTeleportInThisZone = oACU
                        break
                    end
                end
            end
        end

        if oACUUpgradingForTeleportInThisZone then
            if bHaveLowPower then iBPWanted = 25
            else
                iBPWanted = 60
            end
            if not(bWantMorePower) then iBPWanted = 100 end
            if bDebugMessages == true then LOG(sFunctionRef..': Have ACU trying to get teleporter upgrade, iBPWanted='..iBPWanted) end
            HaveActionToAssign(refActionAssistUpgrade, 1, iBPWanted, oACUUpgradingForTeleportInThisZone)
        end
    end

    --Shield assistance
    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPForShieldAssistance(tLZTeamData, iTeam)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionAssistShield, 1, iBPWanted)
    end

    --Higher priority mass storage if we have T3 in the LZ and available storage locations
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 11 and (tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][2] >= 4) and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 then
        iBPWanted = GetBPToAssignToMassStorage(iPlateau, iLandZone, iTeam, tLZData, tLZTeamData, true, bHaveLowMass, bWantMorePower)
        if iBPWanted > 0 then
            HaveActionToAssign(refActionBuildMassStorage, 1, iBPWanted)
        end
    end

    --Factory builder ahead of assisting upgrades for if we have low mass stored but lots of mexes upgrading in this LZ, and are at T3
    iCurPriority = iCurPriority + 1
    if iActiveMexUpgrades >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.01 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0 and table.getn(tLZTeamData[M28Map.subrefActiveUpgrades]) >= 3 then
        if bHaveLowPower then iBPWanted = tiBPByTech[3] * 3
        else iBPWanted = tiBPByTech[3] * 5
        end
        local bWantAirNotLand = M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)
        local iFactoryAction
        if bWantAirNotLand then iFactoryAction = refActionBuildAirFactory
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Want to build land factory not air factory3') end
            iFactoryAction = refActionBuildLandFactory
        end
        if bHaveLowPower and bWantAirNotLand then iBPWanted = iBPWanted * 0.5 end

        HaveActionToAssign(iFactoryAction, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted, nil)
    end

    --Preemptive SMD
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; About to consider if want SMD, is table of enemy nukes empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]))..'; tLZTeamData[M28Map.subrefLZSValue]='..tLZTeamData[M28Map.subrefLZSValue]..'; Lifetime T3 nonstructure count='..M28Conditions.GetTeamLifetimeBuildCount(iTeam, categories.TECH3 - categories.STRUCTURE)..'; Team mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; T3 mex count='..tLZTeamData[M28Map.subrefMexCountByTech][3]) end
    if tLZTeamData[M28Map.subrefLZSValue] >= 20000 and not(bHaveLowPower) and (tLZTeamData[M28Map.subrefLZSValue] >= 30000 or not(bHaveLowMass)) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then
        --Only build SMD if we have built a lot of T3 units or have built experimentals or have very high eco
        if tLZTeamData[M28Map.subrefLZSValue] >= 45000 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 30 or M28Conditions.GetTeamLifetimeBuildCount(iTeam, categories.TECH3 - categories.STRUCTURE) >= 20 then
            --Also require several T3 mexes unless we have very high mass
            if (tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and (not(bHaveLowMass) or tLZTeamData[M28Map.subrefMexCountByTech][3] > 0) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 26 + 18 * (1-M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) or (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and (tLZTeamData[M28Map.subrefMexCountByTech][2] == 0 or tLZTeamData[M28Map.subrefMexCountByTech][3] >= 5)) or (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1 and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 24) then
                local iExperimentalLifetimeCount = M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryExperimentalLevel)
                if iExperimentalLifetimeCount > 1 + math.min(3, M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 30 or (not(bHaveLowMass) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 30)) or M28Map.bIsCampaignMap then
                    local iSMDUnderConstructionInThisZone = M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategorySMD, true)
                    local bStillGetSMD = true
                    if iSMDUnderConstructionInThisZone == 0 then
                        local iSMDUnderConstructionInOtherZones = M28Conditions.GetNumberOfUnderConstructionUnitsOfCategoryInOtherZones(tLZTeamData, iTeam, M28UnitInfo.refCategorySMD)
                        if iSMDUnderConstructionInOtherZones > 0 then bStillGetSMD = false end
                    end
                    if bStillGetSMD then
                        local bAssistSMD = false
                        iBPWanted, bAssistSMD = GetBPToAssignToSMD(iPlateau, iLandZone, iTeam, tLZTeamData, false, bHaveLowMass, bWantMorePower)
                        if iBPWanted > 0 and not(bAssistSMD) then --Since htis is precautionary not worried about rushing the SMD
                            if bDebugMessages == true then LOG(sFunctionRef..': Will assign BP to build an SMD preemptively, iBPWanted='..iBPWanted) end
                            HaveActionToAssign(refActionBuildSMD, 3, iBPWanted)
                        end
                    end
                end
            end
        end
    end

    --Build multiple land factories if have lots of mass stored (higher priority)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want high priority second factory builder, bHaveLowMass='..tostring(bHaveLowMass)..'; bHaveLowPower='..tostring(bHaveLowPower)..'; bWantMoreFactories='..tostring(bWantMoreFactories)..'; iActiveMexUpgrades='..iActiveMexUpgrades..'; Mass % stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; Friendly highest land fac tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]..'; Team net mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) end
    if not(bHaveLowMass) and not(bHaveLowPower) and bWantMoreFactories and iFactoriesInLZ >= 4 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 11 and (iActiveMexUpgrades >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.25) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3 or iActiveMexUpgrades >= 4) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 1 or iActiveMexUpgrades >= 4) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.45 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= math.min(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 0.25, 8)) then

        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.55 then iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]] * 4
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0 then iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]] * 2
        else iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]]
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Have lots of mass so want to build more than one factory at once as high priority, iBPWanted='..iBPWanted) end
        if not(M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)) then
            HaveActionToAssign(refActionBuildSecondLandFactory, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech], iBPWanted)
        end
    end

    --Second mass storage if we have T3 mex in this LZ and 5+ mass storage locations
    iCurPriority = iCurPriority + 1
    if (tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][2] >= 4) and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 then
        iBPWanted = GetBPToAssignToMassStorage(iPlateau, iLandZone, iTeam, tLZData, tLZTeamData, true, bHaveLowMass, bWantMorePower)
        if iBPWanted > 0 then
            if table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZOrWZMassStorageLocationsAvailable]) >= 5 then
                HaveActionToAssign(refActionBuildSecondMassStorage, 1, iBPWanted)
            end
        end
    end

    --Lower priority core WZ wanting engineers:
    iCurPriority = iCurPriority + 1

    if iCoreWZWantingSupportAsLowerPriority then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if iHighestTechEngiAvailable > 0 then

            HaveActionToAssign(refActionMoveToWaterZone, 1, tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]], iCoreWZWantingSupportAsLowerPriority, true)
        end
    end

    --Assist upgrades:
    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPToAssignToAssistUpgrade(tLZTeamData, iTeam, true, bHaveLowMass, bHaveLowPower, bWantMorePower)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionAssistUpgrade, 1, iBPWanted)
    end

    --Build mass storage if we have T2+ mexes
    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPToAssignToMassStorage(iPlateau, iLandZone, iTeam, tLZData, tLZTeamData, true, bHaveLowMass, bWantMorePower)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionBuildMassStorage, 1, iBPWanted)
    end


    --Lower priority mass reclaim
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.35 and tLZData[M28Map.subrefTotalMassReclaim] >= 5 then
        if bDebugMessages == true then LOG(sFunctionRef..': Lower priority reclaim, Total mass in Plateau '..iPlateau..' LZ '..iLandZone..'='..tLZData[M28Map.subrefTotalMassReclaim]) end
        HaveActionToAssign(refActionReclaimArea, 1, math.min(100, math.max(5, tLZData[M28Map.subrefTotalMassReclaim] / 50)), false)
    end

    --Radar (not high priority)
    iCurPriority = iCurPriority + 1
    if not(bHaveLowPower) and not (M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmni]) then
        --T1 radar
        if tLZTeamData[M28Map.refiRadarCoverage] <= 50 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 25 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2.5 then
            --Check we dont already have t1 radar in the land zone
            if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryT1Radar, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) then
                iBPWanted = 5
                if not(bHaveLowMass) then iBPWanted = 15 end
                HaveActionToAssign(refActionBuildT1Radar, 1, iBPWanted)
            end
        end

        --T2 radar
        iCurPriority = iCurPriority + 1
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if want T2 radar, tLZTeamData[M28Map.refiRadarCoverage]='..tLZTeamData[M28Map.refiRadarCoverage]..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]) end
        if tLZTeamData[M28Map.refiRadarCoverage] <= 130 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 100 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 5 then
            --Check we dont already have t2 radar in the land zone
            if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryT2Radar, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) then
                iBPWanted = 20
                if not(bHaveLowMass) then iBPWanted = 60 end
                HaveActionToAssign(refActionBuildT2Radar, 2, iBPWanted)
            end
        end

        --T3 radar
        iCurPriority = iCurPriority + 1
        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to build T3 radar, tLZTeamData[M28Map.refiRadarCoverage]='..tLZTeamData[M28Map.refiRadarCoverage]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Closest enemy base dist to midpoint='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase])..'; tLZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
        if tLZTeamData[M28Map.refiRadarCoverage] <= 300 and ((M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 500 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 200) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 350 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 100 and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryMobileLand * categories.TECH3 - M28UnitInfo.refCategoryEngineer) >= 40) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 and (M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase]) > tLZTeamData[M28Map.refiRadarCoverage] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20) then
            --Require T3 mexes before building T3 radar
            if tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 or (tLZTeamData[M28Map.subrefMexCountByTech][3] == 1 and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][1] == 0) then
                iBPWanted = 30
                if not(bHaveLowMass) then iBPWanted = 100 end
                if bDebugMessages == true then LOG(sFunctionRef..': Will build T3 radar, iBPWanted='..iBPWanted..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]) end
                HaveActionToAssign(refActionBuildT3Radar, 3, iBPWanted)
            end
        end
    end

    --Air fac and second air fac ahead of land experimental if enemy has significant air to ground threat, for larger maps
    iCurPriority = iCurPriority + 1
    if M28Map.iMapSize > 512 and (M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeAir] or 0) < 8 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 + (M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeAir] or 0) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 and M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone) then
        if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) then
            iBPWanted = 40
            if not(bHaveLowMass) then iBPWanted = 80 end
            HaveActionToAssign(refActionBuildAirFactory, 3, iBPWanted)
            if not(bHaveLowMass) and not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 10000 and not(M28Conditions.TeamHasAirControl(iTeam)) then
                HaveActionToAssign(refActionBuildSecondAirFactory, 3, iBPWanted)
            end
        end
    end

    --Land experimental if lots of mass or have built lots of T3 units, or enemy has experimental and we dont
    iCurPriority = iCurPriority + 1
    local bExperimentalsBuiltInThisLZ, iExperimentalsBuiltInOtherLZ = GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateau, iLandZone)
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; iCurPriority='..iCurPriority..'; bExperimentalsBuiltInThisLZ='..tostring(bExperimentalsBuiltInThisLZ)..'; iExperimentalsBuiltInOtherLZ='..iExperimentalsBuiltInOtherLZ..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; M28Team.tTeamData[iTeam][M28Team.refbBuiltLotsOfT3Combat]='..tostring(M28Team.tTeamData[iTeam][M28Team.refbBuiltLotsOfT3Combat] or false)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and (
            (bExperimentalsBuiltInThisLZ or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] > 7) and
                    --Are we already building an experimental here (in which case finish), or ave we built lots of T3 units, or does enemy have a land experimental and we arent building one anywhere?
                    ((bExperimentalsBuiltInThisLZ or (iExperimentalsBuiltInOtherLZ == 0 and (M28Team.tTeamData[iTeam][M28Team.refbBuiltLotsOfT3Combat] or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false)))
                            --Alternatively do we have lots of mass stored?
                            or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 8000 + 8000 * iExperimentalsBuiltInOtherLZ or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] > 16 + iExperimentalsBuiltInOtherLZ * 30)
                            --Alternatively have we not built an experimental before but our team has high mass income and at least 1 T3 mex in this zone?
                            or (iExperimentalsBuiltInOtherLZ == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 400 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 14 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1)
                    )
                    or GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] or -1000) <= 60
                    or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 400) then
        iBPWanted = 100 --No point trying to build an experimental with less build power
        if not(bHaveLowPower) then
            iBPWanted = iBPWanted * 1.5
            --BP wanted: e.g. monkeylord will cost 0.07 mass per tick for 1 BP; so if want to spend approx 50% of mass on the experimental, then for every 1 mass per tick generated, would want roughly 7 build power
            if not(bHaveLowMass) then iBPWanted = math.max(iBPWanted * 1.5, (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] - iExperimentalsBuiltInOtherLZ * 25 - 10) * 5) end
            if bDebugMessages == true then LOG(sFunctionRef..': iExperimentalsBuiltInOtherLZ='..iExperimentalsBuiltInOtherLZ..'; Is table of enemy land exp empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]))..'; Lifetime exp level build count='..M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryExperimentalLevel)) end
            if iExperimentalsBuiltInOtherLZ == 0 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryExperimentalLevel) < math.max(2, M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] * 0.75) then
                local iCapOnIncrease = 500
                if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] then iCapOnIncrease = 250 end
                iBPWanted = math.max(iBPWanted, math.min(iCapOnIncrease, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 6))
                if bDebugMessages == true then LOG(sFunctionRef..': IBPWanted after increasing if first experimental being built and enemy team has one='..iBPWanted) end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Will get experimental if have enough T3 mexes in this zone, tLZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
        if tLZTeamData[M28Map.subrefMexCountByTech][1] + tLZTeamData[M28Map.subrefMexCountByTech][2] == 0 or tLZTeamData[M28Map.subrefMexCountByTech][3] >= 4 or (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 and tLZTeamData[M28Map.subrefMexCountByTech][2] < 2) or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
            --Want to only build experimental if have mostly T3 mexes in this zone

            HaveActionToAssign(refActionBuildExperimental, 3, iBPWanted)

            --Also want more BP than what we have regardless if have lots of mass stored and experimental is being built
            if bDebugMessages == true then LOG(sFunctionRef..': Have just had action to build experimental with iBPWanted='..iBPWanted..'; If lots of mass stored will increase BP assigned to experimental, bExperimentalsBuiltInThisLZ='..tostring(bExperimentalsBuiltInThisLZ)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; bHaveLowPower='..tostring(bHaveLowPower)) end
            if bExperimentalsBuiltInThisLZ and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.6 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 20000) and not(bHaveLowPower) then
                --Want 60 extra BP vs what we have already assigned
                iBPWanted = 60
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.8 or not(bWantMorePower) then iBPWanted = 120 end
                HaveActionToAssign(refActionBuildExperimental, 3, iBPWanted, nil, false, true)
            end
        end

    end

    --Build multiple land factories if have lots of mass stored (lower priority)
    iCurPriority = iCurPriority + 1
    if not(bHaveLowMass) and not(bHaveLowPower) and bWantMoreFactories and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 then
        if bDebugMessages == true then LOG(sFunctionRef..': Have lots of mass so want to build more than one factory at once (lower priority)') end

        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.7 then iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 7
        else iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 5
        end
        if not(M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)) then --factors in things like if we are on the same plateau
            HaveActionToAssign(refActionBuildSecondLandFactory, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech], tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 5)
        end
    end



    --Lower priority land zones wanting engineers:
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS) Other non adjacent LZ on this plateau that wants engineers (low priority) - prioritise those nearest this zone
    iCurPriority = iCurPriority + 1
    iBPAlreadyTraveling = 0
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then
        if M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
            for iEngi, oEngi in toAssignedEngineers do
                if oEngi[refiAssignedAction] == refActionMoveToLandZone then
                    iBPAlreadyTraveling = iBPAlreadyTraveling + oEngi:GetBlueprint().Economy.BuildRate
                end
            end
        end

        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
            for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                if iBPAlreadyTraveling > 0 or not(tLZWantingBPConsidered[iAdjLZ]) then
                    tLZWantingBPConsidered[iAdjLZ] = true
                    local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, iAdjLZ, iPathingRef, iHighestTechEngiAvailable, false)
                    if tiBPByTechWanted then
                        --Is it either a minor zone, or a core zone that either wants lots of BP or doesnt have any engineers traveling to it?
                        for iTech = 1, iHighestTechEngiAvailable, 1 do
                            if tiBPByTechWanted[iTech] > 0 then
                                iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                iBPWanted = iBPAlreadyTraveling + 5
                                if bDebugMessages == true then LOG(sFunctionRef..': Will try and assign an engineer to go to iAdjLZ='..iAdjLZ..'; BP wanted='..iBPWanted..'; iTech='..iTech..'; iPrevEngisAvailable='..iPrevEngisAvailable) end
                                HaveActionToAssign(refActionMoveToLandZone, iTech, iBPWanted, iAdjLZ, true)
                                if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                    iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                    iBPAlreadyTraveling = iBPAlreadyTraveling + tiBPByTech[iTech]
                                end

                                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable after this='..iHighestTechEngiAvailable) end
                                if iHighestTechEngiAvailable == 0 then break end
                            end
                        end
                    end
                end
                if iHighestTechEngiAvailable == 0 then break end
            end
        end
    end

    --Islands wanting engineers (provided there are no enemy naval units in an adjacent naval zone)
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Core LZ considering engis for islands, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Time='..GetGameTimeSeconds()) end
    if iHighestTechEngiAvailable > 0 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of pathing to other islands empty='..tostring(tLZData[M28Map.subrefLZPathingToOtherIslands])) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
            local iDistanceThreshold = math.max(125, M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) * 0.6)
            if bDebugMessages == true then LOG(sFunctionRef..': iDistanceThreshold='..iDistanceThreshold) end

            for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..'; Travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; tPathingData[M28Map.subrefIslandClosestLZRef]='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; Are there enemies in this or adjacnet LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                if tPathingData[M28Map.subrefIslandTravelDist] > iDistanceThreshold then break
                else
                    --Are there enemies in the target LZ?
                    if tPathingData[M28Map.subrefIslandClosestLZRef] then
                        local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]]
                        if bDebugMessages == true then LOG(sFunctionRef..': Are there enemies in the land zone or adjacent='..tostring(tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Is the midpoint in the playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]))) end
                        if not(tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                            --Can we reach the island?
                            if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]) then

                                local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, tPathingData[M28Map.subrefIslandClosestLZRef], iEntry, iHighestTechEngiAvailable, false, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                                if tiBPByTechWanted then
                                    --Is it either a minor zone, or a core zone that either wants lots of BP or doesnt have any engineers traveling to it?
                                    for iTech = 1, iHighestTechEngiAvailable, 1 do
                                        if tiBPByTechWanted[iTech] > 0 then
                                            iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                            iBPWanted = iBPAlreadyTraveling + 5
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will try and assign an engineer to go to tPathingData[M28Map.subrefIslandClosestLZRef]='..tPathingData[M28Map.subrefIslandClosestLZRef]..'; BP wanted='..iBPWanted..'; iTech='..iTech..'; iPrevEngisAvailable='..iPrevEngisAvailable) end
                                            HaveActionToAssign(refActionMoveToLandZone, iTech, iBPWanted, tPathingData[M28Map.subrefIslandClosestLZRef], true)
                                            if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                                iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                                iBPAlreadyTraveling = iBPAlreadyTraveling + tiBPByTech[iTech]
                                            end

                                            iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                            if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable after this='..iHighestTechEngiAvailable) end
                                            if iHighestTechEngiAvailable == 0 then break end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    --Quantum gateway for high AiX modifier and campaign, once we are at T3 mexes for the LZ
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to build quantum gateway, MexCountByTech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; bHaveLowPower='..tostring(bHaveLowPower)..'; mass storage locations empty?='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZOrWZMassStorageLocationsAvailable]))..'; mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]) end
    if not(bHaveLowPower) and (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 or (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 11) or (M28Map.bIsCampaignMap and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 13))
            and (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 6 or (tLZTeamData[M28Map.subrefMexCountByTech][2] == 0 and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0))
            and (M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZOrWZMassStorageLocationsAvailable]) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 or (M28Map.bIsCampaignMap and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 14))
            and (M28Map.bIsCampaignMap or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 0 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 30) then
        --Are we in campaign (where ecoing more important) or AiX 1.2+?
        local iHighestCheatModifier = 1
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                if oBrain.CheatEnabled then
                    iHighestCheatModifier = tonumber(ScenarioInfo.Options.CheatMult or 1.5)
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bIsCampaignMap='..tostring(M28Map.bIsCampaignMap)..'; iHighestCheatModifier='..iHighestCheatModifier) end
        if M28Map.bIsCampaignMap or iHighestCheatModifier >= 1.2 or (M28Map.iMapSize >= 1024 and not(bHaveLowMass) and tLZTeamData[M28Map.subrefMexCountByTech][3] >= tLZData[M28Map.subrefLZMexCount]) then
            iBPWanted = 20
            if not(bHaveLowMass) then iBPWanted = 80 end
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build a quantum gateway') end
            --Do we already have a quantum gateway in this land zone?
            local iCurQuantumGateways = 0
            local tQuantumGateways = EntityCategoryFilterDown(M28UnitInfo.refCategoryQuantumGateway, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty( tQuantumGateways) == false then
                for iUnit, oUnit in tQuantumGateways do
                    if oUnit:GetFractionComplete() >= 1 then
                        iCurQuantumGateways = iCurQuantumGateways + 1
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iCurQuantumGateways='..iCurQuantumGateways) end
            --Get 1 quantumn gateway (or 2+ if we have 1.5+ AiX modifier)
            if iCurQuantumGateways == 0 or (iCurQuantumGateways < 3 and M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultipler] >= 1.4 and iCurQuantumGateways < 0.4 + M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultipler]) then
                HaveActionToAssign(refActionBuildQuantumGateway, 3, iBPWanted)
                if bDebugMessages == true then LOG(sFunctionRef..': Will try and assign '..iBPWanted..' to building a quantum gateway') end
            end
        end
    end

    --Low mass - mass fabs (number depends on AiX modifier)


    --Second experimental builder (for very high mass scenarios) assuming we have lots of T3 mexes
    iCurPriority = iCurPriority + 1
    if not(bHaveLowMass) and not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 8 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 5000 then
        if tLZTeamData[M28Map.subrefMexCountByTech][1] + tLZTeamData[M28Map.subrefMexCountByTech][2] == 0 or tLZTeamData[M28Map.subrefMexCountByTech][3] >= 4 or (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 and tLZTeamData[M28Map.subrefMexCountByTech][2] < 2) or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
            --Want 30 extra BP vs what we have already assigned to both normal and second experimental builders
            iBPWanted = 30
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.8 or not(bWantMorePower) then iBPWanted = iBPWanted * 2 end
            --HaveActionToAssign(iActionToAssign,           iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting)
            HaveActionToAssign(refActionBuildExperimental,   3,                       iBPWanted,      nil,                false, true)
            if bDebugMessages == true then LOG(sFunctionRef..': Will flag that we want a second experimental to be built, additional iBPWanted='..iBPWanted) end
            HaveActionToAssign(refActionBuildSecondExperimental, 3,                     iBPWanted,      nil,                false,                      true)
        end
    end

    --Assist upgrade even if resources aren't great
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] >= 0.95 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 20 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > 0 then
        HaveActionToAssign(refActionAssistUpgrade, 1, 10, false, false)
    end


    --Units to capture
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]) == false then
        --Refresh the list
        local iCaptureCount = table.getn(tLZData[M28Map.subreftoUnitsToCapture])
        for iCurCount = iCaptureCount, 1, -1 do
            if not(M28UnitInfo.IsUnitValid(tLZData[M28Map.subreftoUnitsToCapture][iCurCount])) then
                table.remove(tLZData[M28Map.subreftoUnitsToCapture], iCurCount)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Have units to capture for zone '..iLandZone..'; after freshing them is table empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]))) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]) == false then
            local oUnitToCapture
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 75 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                local tPotentialCapture = EntityCategoryFilterDown(categories.ALLUNITS - M28UnitInfo.refCategoryT3Power, tLZData[M28Map.subreftoUnitsToCapture])
                if M28Utilities.IsTableEmpty(tPotentialCapture) == false then
                    oUnitToCapture = M28Utilities.GetNearestUnit(tPotentialCapture, tLZData[M28Map.subrefMidpoint])
                end
            else
                oUnitToCapture = M28Utilities.GetNearestUnit(tLZData[M28Map.subreftoUnitsToCapture], tLZData[M28Map.subrefMidpoint])
            end
            if oUnitToCapture then
                if bDebugMessages == true then LOG(sFunctionRef..': Unit to cpature='..oUnitToCapture.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToCapture)) end
                iBPWanted = GetCaptureBPWanted(oUnitToCapture, bHaveLowPower, iTeam, tLZTeamData[M28Map.subrefLZbCoreBase])
                HaveActionToAssign(refActionCaptureUnit, 1, iBPWanted, oUnitToCapture)
            end
        end
    end

    --Units to repair
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToRepair]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Have units to repair for zone '..iLandZone..' is table empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToRepair]))) end

        if M28Conditions.IsTableOfUnitsStillValid(tLZData[M28Map.subreftoUnitsToRepair], true) then
            local oUnitToTarget = M28Utilities.GetNearestUnit(tLZData[M28Map.subreftoUnitsToRepair], tLZData[M28Map.subrefMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': Unit to repair='..oUnitToTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToTarget)) end
            HaveActionToAssign(refActionRepairUnit, 1, 5, oUnitToTarget)
        end

    end

    --Game ender builder (in addition to normal experimental builders) - intended for extreme scenarios where overflowing lots of mass, or where are in campaign, at unit cap and have decent eco
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to build gameender, bHaveLowPower='..tostring(bHaveLowPower)..'; M28Team.tTeamData[iTeam][M28Team.refiLowestUnitCapAdjustmentLevel]='..(M28Team.tTeamData[iTeam][M28Team.refiLowestUnitCapAdjustmentLevel] or 'nil')..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Gameender count='..M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount]) end
    if not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= 3 and (
            (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 95 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.55 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 20 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 10000)
                    or (M28Map.bIsCampaignMap and ((M28Team.tTeamData[iTeam][M28Team.refiLowestUnitCapAdjustmentLevel] or 100) <= 2 or (not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 60 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 30 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) then
        local bAlreadyHaveGameEnderUnderConstruction = false
        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        if bDebugMessages == true then LOG(sFunctionRef..': About to check for nearby gameenders for team '..(iTeam or 'nil')..'; First active M28brain aibrain='..(aiBrain.Nickanme or 'nil')..'; LZ midpoint='..repru(tLZData[M28Map.subrefMidpoint])) end
        local tNearbyGameEnders = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryGameEnder, tLZData[M28Map.subrefMidpoint], 1000, 'Ally')
        local iCompletedGameEnders = 0
        if M28Utilities.IsTableEmpty(tNearbyGameEnders) == false then
            for iExperimental, oExperimental in tNearbyGameEnders do
                if oExperimental:GetFractionComplete() < 1 then
                    --Is this gameender in a different zone?
                    local iGameEnderPlateau, iGameEnderZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oExperimental:GetPosition())
                    if not(iGameEnderZone == iLandZone and iGameEnderPlateau == iPlateau) then
                        bAlreadyHaveGameEnderUnderConstruction = true
                    end
                else
                    iCompletedGameEnders = iCompletedGameEnders + 1
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bAlreadyHaveGameEnderUnderConstruction='..tostring(bAlreadyHaveGameEnderUnderConstruction or false)) end
        if not(bAlreadyHaveGameEnderUnderConstruction) then
            iBPWanted = 45
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 125 then iBPWanted = 90 end
            if iCompletedGameEnders < 1 then
                HaveActionToAssign(refActionBuildGameEnder, 3,                     iBPWanted,      nil,                false,                      true)
                if bDebugMessages == true then LOG(sFunctionRef..': iBPWanted for gameender='..iBPWanted) end
            else
                --Consider getting land experimental instead unless we have large number already
                local iCompletedLandExperimentals = 0
                local tNearbyLandExperimentals = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandExperimental, tLZData[M28Map.subrefMidpoint], 1000, 'Ally')
                if M28Utilities.IsTableEmpty(tNearbyLandExperimentals) == false then
                    for iUnit, oUnit in tNearbyLandExperimentals do
                        if oUnit:GetFractionComplete() >= 1 then
                            iCompletedLandExperimentals = iCompletedLandExperimentals + 1
                        end
                    end
                end
                local iLandExpeimentalsWantedPerGameEnder = 1
                if NavUtils.GetLabel(M28Map.refPathingTypeHover, tLZTeamData[M28Map.reftClosestEnemyBase]) == NavUtils.GetLabel(M28Map.refPathingTypeHover, tLZData[M28Map.subrefMidpoint]) then iLandExpeimentalsWantedPerGameEnder = 5 end
                if bDebugMessages == true then LOG(sFunctionRef..': Deciding if want gameender or land experimental, iCompletedLandExperimentals='..iCompletedLandExperimentals..'; iCompletedGameEnders='..iCompletedGameEnders..'; iLandExpeimentalsWantedPerGameEnder='..iLandExpeimentalsWantedPerGameEnder) end
                if iCompletedLandExperimentals < iCompletedGameEnders * iLandExpeimentalsWantedPerGameEnder then
                    HaveActionToAssign(refActionBuildLandExperimental, 3,                     iBPWanted,      nil,                false,                      true)
                else
                    HaveActionToAssign(refActionBuildGameEnder, 3,                     iBPWanted,      nil,                false,                      true)
                end
            end
        end
    end

    --Low priority island support - will consider further away distances tahn before, up to a distance of 400, and only if the island wants T1 engineer BP

    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Low priority core zone island engi support logic, iHighestTechEngiAvailable='..iHighestTechEngiAvailable) end
    if iHighestTechEngiAvailable > 0 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if iHighestTechEngiAvailable > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': is pathing to other islands empty='..tostring( M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]))) end
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; tLZTeamData[M28Map.reftClosestEnemyBase]='..repru(tLZTeamData[M28Map.reftClosestEnemyBase])..'; tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint])) end

                for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering island '..tPathingData[M28Map.subrefIslandNumber]..' for lower priority travel; travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; Closest LZ ref='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; are enemies in this or adjacent LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                    if tPathingData[M28Map.subrefIslandTravelDist] > 400 then break
                    else
                        --Are there enemies in the target LZ?

                        if tPathingData[M28Map.subrefIslandClosestLZRef] then
                            local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]]
                            if not(tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbDangerousEnemiesInThisLZ]) then
                                --Can we reach the island?
                                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]) then
                                    --Are there enemies in an adjacent LZ
                                    local iAdjacentEnemyThreat = 0
                                    if tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                                        if M28Utilities.IsTableEmpty(tAdjLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                            for _, iAdjToAdjLZ in tAdjLZData[M28Map.subrefLZAdjacentLandZones] do
                                                local tAdjToAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjToAdjLZ]
                                                iAdjacentEnemyThreat = iAdjacentEnemyThreat + tAdjToAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal]
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': iAdjacentEnemyThreat='..iAdjacentEnemyThreat) end
                                    if iAdjacentEnemyThreat < 10 then

                                        local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, tPathingData[M28Map.subrefIslandClosestLZRef], iEntry, iHighestTechEngiAvailable, false, true)
                                        if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                                        if (tiBPByTechWanted[1] or 0) > 0 then
                                            HaveActionToAssign(refActionMoveToLandZone, 1, 5, tPathingData[M28Map.subrefIslandClosestLZRef], true)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Finished trying to give order for engi to move to the island LZ '..tPathingData[M28Map.subrefIslandClosestLZRef]) end
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    --Build more air factories if close to overflowing mass and dont have low power (e.g. to help in campaign and unit restriction scenarios where land factories arent an option)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether want a low priority air factory if overflowing mass, bHaveLowMass='..tostring(bHaveLowMass)..'; bHaveLowPower='..tostring(bHaveLowPower)..'; Lowest mass% stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; Land facotyr lifetime count='..M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandFactory)..'; Want more factories='..tostring(M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone))..'; want air instead of land fac='..tostring(M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData))) end
    if not(bHaveLowMass) and not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.6 and M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone) then
        if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) or ((M28Map.bIsCampaignMap or M28Overseer.bUnitRestrictionsArePresent) and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandFactory) <= 1) then
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build another air factory as low priority action due to mass overflow') end
            iBPWanted = 3 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
            HaveActionToAssign(refActionBuildAirFactory, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted, nil)
        end
    end

    --Build second air factories if really close to overflowing mass and dont have low power (e.g. to help in campaign and unit restriction scenarios where land factories arent an option)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether want a low priority air factory if overflowing mass, bHaveLowMass='..tostring(bHaveLowMass)..'; bHaveLowPower='..tostring(bHaveLowPower)..'; Lowest mass% stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; Land facotyr lifetime count='..M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandFactory)..'; Want more factories='..tostring(M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone))..'; want air instead of land fac='..tostring(M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData))) end
    if not(bHaveLowMass) and not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.8 and M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 1 then
        if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) or ((M28Map.bIsCampaignMap or M28Overseer.bUnitRestrictionsArePresent) and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandFactory) <= 1) then
            iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]]
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build another air factory as low priority action due to mass overflow, iBPWanted='..iBPWanted..'; Highest air fac tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]) end
            HaveActionToAssign(refActionBuildSecondAirFactory, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted, nil)
        end
    end

    --Check for any part constructed buildings in this zone if we have available engineers
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then
        local tBuildings = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tBuildings) == false then
            for iUnit, oUnit in tBuildings do
                --Dont assist a part built shield being built for special shielding logic
                if oUnit:GetFractionComplete() < 1 and not(oUnit[refbDontIncludeAsPartCompleteBuildingForConstruction]) then
                    HaveActionToAssign(refActionRepairUnit, 1, 5, oUnit)
                    break
                end
            end
        end
    end


    --SPARE ENGINEER ACTIONS----->
    UpdateSpareEngineerNumber(tLZTeamData, toAvailableEngineersByTech)


    --All spare engi actions
    if iHighestTechEngiAvailable > 0 then

        --Spare engi - assist any upgrading unit
        iCurPriority = iCurPriority + 1
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then
            HaveActionToAssign(refActionAssistUpgrade, 1, 1000, nil, true, nil, nil, nil, true)
            iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        end

        --Spare engi - reclaim area
        iCurPriority = iCurPriority + 1 --do this after each action
        if iHighestTechEngiAvailable > 0 then
            if tLZData[M28Map.subrefTotalMassReclaim] >= 20 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.6 then
                local bWantEnergy = false
                HaveActionToAssign(refActionReclaimArea, 1, 500, bWantEnergy, true, nil, nil, nil, true)
                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
            end
        end

        --Spare engi - assist under construction building if we dont have low mass or energy
        iCurPriority = iCurPriority + 1
        if bDebugMessages == true then LOG(sFunctionRef..': Spare engineer action, iHighestTechEngiAvaialble='..iHighestTechEngiAvailable..'; Have low mass='..tostring(bHaveLowMass)..'; Mass stored on team='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Have low power='..tostring(bHaveLowPower)) end
        if iHighestTechEngiAvailable > 0 and (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 5000) and not(bHaveLowPower) then
            --Dont assist part complete shields due to risk we are using for active shielding
            local oBuildingToAssist = GetPartCompleteBuildingInZone(iTeam, iPlateau, iLandZone, M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryExperimentalLevel - M28UnitInfo.refCategoryFixedShield, false)
            if bDebugMessages == true then LOG(sFunctionRef..': oBuildingToAssist='..(oBuildingToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBuildingToAssist) or 'nil')) end
            if oBuildingToAssist then
                if bDebugMessages == true then LOG(sFunctionRef..': Will assign all remaining engineers to repair building') end
                --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
                HaveActionToAssign(refActionRepairUnit, 1,                  300,                oBuildingToAssist, true,                    true, nil, nil, true) --max 300 BP to allow for a very slight spreading of engineers where have lots
                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
            end
        end

        --Spare engi action - go to any nearby land or water zone that wants BP
        iCurPriority = iCurPriority + 1

        if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; If have available engis then will look for other zones wanting them, time='..GetGameTimeSeconds()..'; Is table of other land and water zones by distance empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]))) end
        if iHighestTechEngiAvailable > 0 then
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through all other land and water zones, reprs='..reprs(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance])) end
                for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to travel to zone '..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..'; Distance='..tSubtable[M28Map.subrefiDistance]) end
                    if tSubtable[M28Map.subrefiDistance] <= 500 then
                        local tAdjLZOrWZData, tAdjLZOrWZTeamData
                        if tSubtable[M28Map.subrefbIsWaterZone] then
                            tAdjLZOrWZData =M28Map.tPondDetails[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                            tAdjLZOrWZTeamData = tAdjLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                        else
                            tAdjLZOrWZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                            tAdjLZOrWZTeamData = tAdjLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering zone '..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..'; Wnats BP='..tostring(tAdjLZOrWZTeamData[M28Map.subrefTbWantBP])..'; In playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAdjLZOrWZData[M28Map.subrefMidpoint]))..'; Zone plateau='..(NavUtils.GetLabel(M28Map.refPathingTypeHover, tAdjLZOrWZData[M28Map.subrefMidpoint]) or 'nil')..'; iPlateau='..iPlateau) end
                        if tAdjLZOrWZTeamData[M28Map.subrefTbWantBP] and NavUtils.GetLabel(M28Map.refPathingTypeHover, tAdjLZOrWZData[M28Map.subrefMidpoint]) == iPlateau and (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZOrWZData[M28Map.subrefMidpoint])) then
                            local iCurBPWanted = 0
                            local iMinTechWanted = 3
                            for iTech, iBP in tAdjLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted] do
                                iMinTechWanted = math.min(iMinTechWanted, iTech)
                                iCurBPWanted = iCurBPWanted + iBP
                            end
                            if iCurBPWanted > 0 and iMinTechWanted <= iHighestTechEngiAvailable then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have BP wanted, iCurBPWanted='..iCurBPWanted..'; PlateauorPond='..(tSubtable[M28Map.subrefiPlateauOrPond] or 'nil')..'; Land or water zone ref='..(tSubtable[M28Map.subrefiLandOrWaterZoneRef] or 'nil')..'; Is water zone='..tostring(tSubtable[M28Map.subrefbIsWaterZone] or false)) end
                                if tSubtable[M28Map.subrefbIsWaterZone] then
                                    --HaveActionToAssign(iActionToAssign,   iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable,                      bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
                                    HaveActionToAssign(refActionMoveToWaterZone, iMinTechWanted, iCurBPWanted,      tSubtable[M28Map.subrefiLandOrWaterZoneRef],true, true,nil,nil, false) --Dont treat it as spare action, or else it gets orders overwritten and can end up in a loop where it moves to another zone and that zone sends it back home
                                else
                                    HaveActionToAssign(refActionMoveToLandZone, iMinTechWanted, iCurBPWanted, tSubtable[M28Map.subrefiLandOrWaterZoneRef], true, true,nil,nil,false) --Dont treat it as spare action, or else it gets orders overwritten and can end up in a loop where it moves to another zone and that zone sends it back home
                                end
                                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                if iHighestTechEngiAvailable == 0 then break end
                            end
                        end
                    end
                end
            else
                M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint])
            end
        end

        iCurPriority = iCurPriority + 1
        --Spare engi action - assist air factory if it isnt idle and we dont have low mass
        if iHighestTechEngiAvailable > 0 and not(bHaveLowPower) and not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] > 0 and GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeAirFacHadNothingToBuild] or -100) <= 5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.35 then
            local tAirFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tAirFactories) == false then
                --Get the factory  closest to the midpoint
                local iClosestDistOfHighestTech = 100000
                local iHighestTech = 0
                local oClosestFactory
                local iCurDist, iCurTech
                for iUnit, oUnit in tAirFactories do
                    iCurTech = M28UnitInfo.GetUnitTechLevel(oUnit)
                    if iCurTech >= iHighestTech then
                        if iCurTech > iHighestTech then
                            iHighestTech = iCurTech
                            iClosestDistOfHighestTech = 100000
                        end
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                        if iCurDist < iClosestDistOfHighestTech then
                            iClosestDistOfHighestTech = iCurDist
                            oClosestFactory = oUnit
                        end
                    end
                end
                if oClosestFactory then
                    --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
                    HaveActionToAssign(refActionAssistAirFactory, 1,                  10000,                oClosestFactory, true,                    true,                       nil,                         nil,                                true)
                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                end
            end
        end
    end


    --Localised mex upgrade logic (this is in addition to centralised logic) - intended for games on larger maps - but only if no enemies in adjacent zone
    if bDebugMessages == true then LOG(sFunctionRef..': Considering engineer based mex upgrade logic for zone '..iLandZone..', bHaveLowPower='..tostring(bHaveLowPower)..'; mex count by tech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; Map size='..M28Map.iMapSize..'; Enemies in adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Is Active upgrades in this LZ table empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]))..'; Team gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Is table of mexes on team empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]))..'; Team factory tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end
    if (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 100 or not(bHaveLowPower)) and iActiveMexUpgrades == 0 and (tLZTeamData[M28Map.subrefMexCountByTech][1] + tLZTeamData[M28Map.subrefMexCountByTech][2] > 0) and M28Map.iMapSize >= 256 and (not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) or (not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 5) and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 8) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 or not(bHaveLowMass) or tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][1] > 0)) then
        --Do we have T3 factory (or T2 if we have t1 mexes) and either we aren't mass stalling, or we have no mex upgrades at a team level?
        if bDebugMessages == true then LOG(sFunctionRef..': Passed initial checks, checking further') end
        if (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 or (tLZTeamData[M28Map.subrefMexCountByTech][1] > 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2)) and (not(bHaveLowMass) or not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) or tLZTeamData[M28Map.subrefMexCountByTech][1] > 0 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20) then
            --Find a mex to upgrade - first try T1 mexes
            local tPotentialMexes
            if tLZTeamData[M28Map.subrefMexCountByTech][1] then
                tPotentialMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryT1Mex, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            else
                tPotentialMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryT2Mex + M28UnitInfo.refCategoryT1Mex, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of potential mexes empty='..tostring(M28Utilities.IsTableEmpty(tPotentialMexes))) end
            if M28Utilities.IsTableEmpty(tPotentialMexes) == false then
                for iMex, oMex in tPotentialMexes do
                    if oMex:GetFractionComplete() >= 1 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will upgrade mex '..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)) end
                        M28Economy.UpgradeUnit(oMex, true)
                        break
                    end
                end
            end

        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tLZTeamData[M28Map.subrefTBuildPowerByTechWanted] before general adjustments='..repru(tLZTeamData[M28Map.subrefTBuildPowerByTechWanted])..'; tLZTeamData[M28Map.subrefSpareBPByTech]='..repru(tLZTeamData[M28Map.subrefSpareBPByTech])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end
function ConsiderMinorLandZoneEngineerAssignment(tLZTeamData, iTeam, iPlateau, iLandZone, tEngineers)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderMinorLandZoneEngineerAssignment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bDontCheckPlayableArea = false
    if M28Map.bIsCampaignMap then
        bDontCheckPlayableArea = true
        if M28Team.tTeamData[iTeam][M28Team.rebTeamOnlyHasCampaignAI] then bDontCheckPlayableArea = false end
    end

    --if bDebugMessages == true then M28Map.DrawSpecificLandZone(iPlateau, iLandZone, 1) end
    local iBPWanted
    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
    local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)
    local bWantMorePower = M28Conditions.WantMorePower(iTeam)
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local bAdjacentToCoreZone

    local iNearbyEnemyAirToGroundThreat = tLZTeamData[M28Map.refiEnemyAirToGroundThreat]
    --For now only do land zone not water zone given water zone includes torp bombers
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
            iNearbyEnemyAirToGroundThreat = iNearbyEnemyAirToGroundThreat + tLZTeamData[M28Map.refiEnemyAirToGroundThreat]
            if tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] then bAdjacentToCoreZone = true end
        end
    end


    local toAvailableEngineersByTech, toAssignedEngineers = FilterToAvailableEngineersByTech(tEngineers, false, tLZData, tLZTeamData, iTeam, iPlateau, iLandZone)
    tLZTeamData[M28Map.subrefTBuildPowerByTechWanted] = {[1]=0,[2]=0,[3]=0}
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Non core LZ - Have just reset BPByTech to 0 for Plateau'..iPlateau..'; LZ='..iLandZone..'; repru='..repru(tLZTeamData[M28Map.subrefTBuildPowerByTechWanted])..'; subrefLZCoreExpansion='..tostring(tLZTeamData[M28Map.subrefLZCoreExpansion] or false)..'; subrefbCoreBaseOverride='..tostring(tLZTeamData[M28Map.subrefbCoreBaseOverride] or false)) end
    --local iCurCondition = 0
    local iCurPriority = 0

    function HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
        --Done as subfunction for convenience so can just note the key values for the action in question and add on the others that wont change
        ConsiderActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iCurPriority, tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, toAvailableEngineersByTech, toAssignedEngineers, false, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
    end


    --Land fac if this is an island with no core LZs - also set this as the primary if no such LZ
    iCurPriority = iCurPriority + 1
    local iHighestTechEngiAvailable
    local bExpansionOnSameIslandAsBase = false

    if bDebugMessages == true then LOG(sFunctionRef..': do we want this zone as an expansion point? iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Time='..GetGameTimeSeconds()..'; tLZTeamData[M28Map.subrefLZCoreExpansion]='..tostring(tLZTeamData[M28Map.subrefLZCoreExpansion] or false)..'; tLZTeamData[M28Map.subrefLZCoreExpansion] is nil='..tostring(tLZTeamData[M28Map.subrefLZCoreExpansion] == nil)..'; tLZTeamData[M28Map.subrefLZExpansionOverride]='..tostring(tLZTeamData[M28Map.subrefLZExpansionOverride] or false)..'; tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][1]='..(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][1] or 'nil')) end
    if tLZTeamData[M28Map.subrefLZCoreExpansion] == nil or (tLZTeamData[M28Map.subrefLZExpansionOverride] and not(tLZTeamData[M28Map.subrefLZCoreExpansion])) then
        if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then
            local iEnemyBaseStraightLineDist = 200
            local iTravelLimit = 600 --If takes more than this to travel to the nearest friendly base, and we are more than iEnemyBaseStraightLineDist from the nearest enemy base on a straight line basis, then will consider a land expansion point

            bExpansionOnSameIslandAsBase = false
            if tLZData[M28Map.subrefLZIslandRef] == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestFriendlyBase]) then
                bExpansionOnSameIslandAsBase = true
                if not(bDontCheckPlayableArea) then
                    bExpansionOnSameIslandAsBase = false
                    --Check we can actually travel here by land
                    local iNearestBasePlateau, iNearestBaseLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tLZTeamData[M28Map.reftClosestFriendlyBase])
                    if (iNearestBaseLandZone or 0) > 0 then
                        local iEntryNumber = tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iNearestBaseLandZone]
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': iEntryNumber='..(iEntryNumber or 'nil')..'; iNearestBasePlateau='..(iNearestBasePlateau or 'nil')..'; LZ Ref based on this entry number='..(tLZData[M28Map.subrefLZPathingToOtherLandZones][iEntryNumber][M28Map.subrefLZNumber] or 'nil')..'; iNearestBaseLandZone='..iNearestBaseLandZone)
                            if not(iEntryNumber) then LOG(sFunctionRef..': Dont have a ref for iNearestBaseLandZone='..iNearestBaseLandZone..'; All refs='..repru(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef])) end
                        end
                        if iEntryNumber then
                            local tTravelPath = tLZData[M28Map.subrefLZPathingToOtherLandZones][iEntryNumber][M28Map.subrefLZPath]
                            if bDebugMessages == true then LOG(sFunctionRef..': tTravelPath='..repru(tTravelPath)) end
                            if M28Utilities.IsTableEmpty(tTravelPath) == false then
                                bExpansionOnSameIslandAsBase = true
                                for iPath, iPathLZ in tTravelPath do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iPathLZ='..iPathLZ..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefMidpoint]))) end
                                    if not(M28Conditions.IsLocationInPlayableArea(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefMidpoint])) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': iPathLZ is not in the playable area so dont want to make this an expansion') end
                                        bExpansionOnSameIslandAsBase = false
                                        break
                                    end
                                end
                                if bExpansionOnSameIslandAsBase then
                                    --Still consider as expansion point if far away
                                    if bDebugMessages == true then LOG(sFunctionRef..': Expansion is on same island as base, checking if it is still really far away such that we want to considera n expansion point, travel dist='..tLZData[M28Map.subrefLZPathingToOtherLandZones][iEntryNumber][M28Map.subrefLZTravelDist]..'; Dist to enemy base (straight line)='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase])) end
                                    if tLZData[M28Map.subrefLZPathingToOtherLandZones][iEntryNumber][M28Map.subrefLZTravelDist] >= iTravelLimit and M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase]) >= iEnemyBaseStraightLineDist then
                                        bExpansionOnSameIslandAsBase = false
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': tLZData[M28Map.subrefLZMexCount]='..(tLZData[M28Map.subrefLZMexCount] or 'nil')..'; Island mex count='..(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tLZData[M28Map.subrefLZIslandRef]] or 'nil')..'; bExpansionOnSameIslandAsBase='..tostring(bExpansionOnSameIslandAsBase or false)..'; tLZData[M28Map.subrefLZIslandRef]='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..'; Closest firendly base island ref='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestFriendlyBase]) or 'nil')) end
            if (tLZData[M28Map.subrefLZMexCount] > 0 or (M28Map.bIsCampaignMap and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tLZData[M28Map.subrefLZIslandRef]] >= 4)) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tLZData[M28Map.subrefLZIslandRef]] >= 3 and not(bExpansionOnSameIslandAsBase) then
                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable='..iHighestTechEngiAvailable) end
                if iHighestTechEngiAvailable > 0 then
                    local bHaveCoreLZ = false
                    for iEntry, iIslandLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][tLZData[M28Map.subrefLZIslandRef]] do
                        if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iIslandLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] or M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iIslandLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZCoreExpansion] then
                            if bDebugMessages == true then LOG(sFunctionRef..': iIslandlZ'..iIslandLZ..' in the island '..tLZData[M28Map.subrefLZIslandRef]..' is either a core base or expansion, Is core base='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iIslandLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] or false)..'; Is core expansion='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iIslandLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZCoreExpansion] or false)..'; bDontCheckPlayableArea='..tostring(bDontCheckPlayableArea)) end
                            if bDontCheckPlayableArea then
                                bHaveCoreLZ = true
                                break
                            else
                                --Check we can actually travel here by land and it isn't too far away
                                local iEntryNumber = tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iIslandLZ]
                                if bDebugMessages == true then LOG(sFunctionRef..': iEntryNumber='..(iEntryNumber or 'nil')..'; LZ Ref based on this entry number='..(tLZData[M28Map.subrefLZPathingToOtherLandZones][iEntryNumber][M28Map.subrefLZNumber] or 'nil')..'; iIslandLZ='..iIslandLZ) end
                                if iEntryNumber then
                                    local tTravelPath = tLZData[M28Map.subrefLZPathingToOtherLandZones][iEntryNumber][M28Map.subrefLZPath]
                                    if bDebugMessages == true then LOG(sFunctionRef..': tTravelPath='..repru(tTravelPath)) end
                                    if M28Utilities.IsTableEmpty(tTravelPath) == false then
                                        bHaveCoreLZ = true
                                        for iPath, iPathLZ in tTravelPath do
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iPathLZ='..iPathLZ..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefMidpoint]))) end
                                            if not(M28Conditions.IsLocationInPlayableArea(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefMidpoint])) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': iPathLZ is not in the playable area so dont think we have a core LZ after all') end
                                                bHaveCoreLZ = false
                                                break
                                            end
                                        end
                                        if bHaveCoreLZ then
                                            --Ignore if this location is far away
                                            if tLZData[M28Map.subrefLZPathingToOtherLandZones][iEntryNumber][M28Map.subrefLZTravelDist] >= iTravelLimit then
                                                bHaveCoreLZ = false
                                            end
                                            if bHaveCoreLZ then
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Updating core expansion flag, bHaveCoreLZ='..tostring(bHaveCoreLZ)..'; Have override='..tostring(tLZTeamData[M28Map.subrefLZExpansionOverride] or false)) end
                    if not(bHaveCoreLZ) or tLZTeamData[M28Map.subrefLZExpansionOverride] then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will set this location as the core expansion location') end
                        --Build a land factory
                        tLZTeamData[M28Map.subrefLZCoreExpansion] = true
                    else
                        tLZTeamData[M28Map.subrefLZCoreExpansion] = false
                    end
                end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Will update core expansion flag, tLZTeamData[M28Map.subrefLZExpansionOverride]='..tostring(tLZTeamData[M28Map.subrefLZExpansionOverride] or false)) end
                if tLZTeamData[M28Map.subrefLZExpansionOverride] then
                    tLZTeamData[M28Map.subrefLZCoreExpansion] = true
                else
                    tLZTeamData[M28Map.subrefLZCoreExpansion] = false
                end
            end
        end
    elseif tLZTeamData[M28Map.subrefLZCoreExpansion] and not(bExpansionOnSameIslandAsBase) then
        --Need to calculate if are on same island
        local iBaseIslandRef = NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestFriendlyBase])
        if iBaseIslandRef == tLZData[M28Map.subrefLZIslandRef] then
            bExpansionOnSameIslandAsBase = true
        end
    end
    local iFactoriesWanted = 0
    local iExistingFactory = 0
    local bExistingFactoryIsComplete = false
    if tLZTeamData[M28Map.subrefLZCoreExpansion] or (bAdjacentToCoreZone and not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 750) then
        local tExistingFactory = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tExistingFactory) == false then
            for iUnit, oUnit in tExistingFactory do
                if oUnit:GetFractionComplete() == 1 then
                    bExistingFactoryIsComplete = true
                    iExistingFactory = iExistingFactory + 1
                    if M28UnitInfo.GetUnitTechLevel(oUnit) >= 2 then
                        iExistingFactory = iExistingFactory + 1
                    end
                end
            end
        end
        iFactoriesWanted = math.min(4, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tLZData[M28Map.subrefLZIslandRef]] - 2)
        local iIslandZoneCount = table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][tLZData[M28Map.subrefLZIslandRef]])
        if bExpansionOnSameIslandAsBase then iFactoriesWanted = math.max(1, math.min(4, iFactoriesWanted, tLZData[M28Map.subrefLZMexCount] - 2))
        else
            if iIslandZoneCount < 4 then iFactoriesWanted = math.max(1, math.min(iFactoriesWanted, iIslandZoneCount * 0.5)) end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iIslandZoneCount='..iIslandZoneCount..'; iFactoriesWanted pre adj='..iFactoriesWanted) end
        if (iIslandZoneCount > 2 or tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and not(bWantMorePower) and not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 then

            if not(bExpansionOnSameIslandAsBase) or M28Map.iMapSize >= 750 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.6 then iFactoriesWanted = iFactoriesWanted + 1 end
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.8 then
                if not(bExpansionOnSameIslandAsBase) or M28Map.iMapSize >= 750 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.9 then iFactoriesWanted = iFactoriesWanted + math.max(1, iFactoriesWanted / 3) end
            end
        end
        if iFactoriesWanted >= 1 and M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] and not(M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone)) then iFactoriesWanted = 1 end
        if bDebugMessages == true then LOG(sFunctionRef..': iFactoriesWanted='..iFactoriesWanted..'; bWantMorePower='..tostring(bWantMorePower)..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Mass% stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; Map size='..M28Map.iMapSize..'; bExpansionOnSameIslandAsBase='..tostring(bExpansionOnSameIslandAsBase)..'; Island mex count='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tLZData[M28Map.subrefLZIslandRef]]..'; LZ mex count='..tLZData[M28Map.subrefLZMexCount]) end
        if iFactoriesWanted > 2 then
            --Does enemy have any units/threats on this island within a certain range?
            local bEnemyHasDangerousUnitsOnIsland = tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]
            if not(bEnemyHasDangerousUnitsOnIsland) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                local iAdjLZ
                for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                    iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; Travel dist='..tPathingDetails[M28Map.subrefLZTravelDist]..'; Does it want DF support='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport])) end
                    if tPathingDetails[M28Map.subrefLZTravelDist] < 275 then
                        local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]='..tostring(tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])) end
                        if tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] then
                            bEnemyHasDangerousUnitsOnIsland = true
                            break
                        end
                    end
                end
            end
            if not(bEnemyHasDangerousUnitsOnIsland) then
                if iFactoriesWanted > 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.8 then
                    iFactoriesWanted = 3
                else
                    iFactoriesWanted = 2 --only here if we have >=2 factories wanted
                end
            end
        end
        if bHaveLowMass then iFactoriesWanted = math.max(1, math.floor(iFactoriesWanted * 0.5)) end
        if bDebugMessages == true then LOG(sFunctionRef..': iFactoriesWanted after adjusting for enemy units='..iFactoriesWanted..'; iExistingFactory='..iExistingFactory) end
    end

    --Do we want emergency PD?
    if bDebugMessages == true then LOG(sFunctionRef..': Considering emergency PD for zone '..iLandZone..', iExistingFactory='..iExistingFactory..'; Mex count by tech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; Enemies in this or adj LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Air to ground threat='..(tLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0)..'; Ally AA threat='..(tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0)) end
    if (tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and (iExistingFactory >= 1 or (tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] * 2 + tLZTeamData[M28Map.subrefMexCountByTech][1] * 0.35) >= 2) and (tLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) <= math.min(350, 0.5*(tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0))) and (not(M28Overseer.bNoRushActive) or M28Overseer.iNoRushTimer - GetGameTimeSeconds() <= 120 or (not(bHaveLowMass) and not(bHaveLowPower) and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 0)) then
        --Does enemy have any units that can outrange a PD? If so then dont bother building
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) then
            local iHighestNearbyEnemyRange = math.max((tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0), tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0)
            local bConsiderT2PD = false
            if bDebugMessages == true then LOG(sFunctionRef..': iHighestNearbyEnemyRange='..iHighestNearbyEnemyRange..'; Highest friendly land fac tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Active brain count='..M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]..'; Mex count by tehc='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; LZ s value='..tLZTeamData[M28Map.subrefLZSValue]..'; Mex count='..tLZData[M28Map.subrefLZMexCount]) end
            if iHighestNearbyEnemyRange < 50 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 6 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and (tLZTeamData[M28Map.subrefMexCountByTech][3] + tLZTeamData[M28Map.subrefMexCountByTech][2] >= 1 or (tLZData[M28Map.subrefLZMexCount] >= 4 and tLZTeamData[M28Map.subrefLZSValue] >= 500)) and (tLZData[M28Map.subrefLZMexCount] >= 3 or tLZTeamData[M28Map.subrefMexCountByTech][2] >= 2 or tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1) then bConsiderT2PD = true end
            if iHighestNearbyEnemyRange <= 25 or bConsiderT2PD then
                local iEnemyCombatThreat = (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                        iHighestNearbyEnemyRange = math.max(iHighestNearbyEnemyRange, (tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0), tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0)
                        iEnemyCombatThreat = iEnemyCombatThreat + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)
                    end
                end
                if bConsiderT2PD then
                    if iHighestNearbyEnemyRange >= 50 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 2 then bConsiderT2PD = false
                    elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 2 then
                        --Do we have T2 factories or engineers of any kind in this zone?
                        local tT2Units = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryFactory - categories.TECH1, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                        local bHaveT2FactoriesOrEngineers = false
                        if M28Utilities.IsTableEmpty(tT2Units) == false then
                            for iUnit, oUnit in tT2Units do
                                if oUnit:GetFractionComplete() == 1 then
                                    bHaveT2FactoriesOrEngineers = true
                                    break
                                end
                            end
                        end
                        if not(bHaveT2FactoriesOrEngineers) then bConsiderT2PD = false end
                    end

                end
                if iHighestNearbyEnemyRange <= 25 or bConsiderT2PD then
                    local iExistingStructureThreat = 0
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
                        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                            iExistingStructureThreat = iExistingStructureThreat + iThreat
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iExistingStructureThreat of existing PD='..iExistingStructureThreat..'; will get emergency PD if below threshold, iEnemyCombatThreat='..iEnemyCombatThreat..'; bConsiderT2PD='..tostring(bConsiderT2PD or false)) end
                    if iExistingStructureThreat < 400 or (bConsiderT2PD and iExistingStructureThreat < math.max(800, math.max(iEnemyCombatThreat, math.min(iEnemyCombatThreat * 2, 2880)))) or (not(bConsiderT2PD) and iExistingStructureThreat < math.min(800, iEnemyCombatThreat * 3)) then
                        local iMinTechLevelWanted = 1
                        iBPWanted = 40
                        if bConsiderT2PD and iExistingStructureThreat >= 400 then
                            iMinTechLevelWanted = 2
                            iBPWanted = 60
                        end
                        local tPDStartPoint
                        if iExistingStructureThreat <= 800 then tPDStartPoint = {tLZData[M28Map.subrefMidpoint][1], tLZData[M28Map.subrefMidpoint][2], tLZData[M28Map.subrefMidpoint][3]}
                        else
                            tPDStartPoint = M28Utilities.MoveInDirection(tLZData[M28Map.subrefMidpoint], M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase]), 25, true, false, M28Map.bIsCampaignMap)
                            if not(tPDStartPoint) or not(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tPDStartPoint) == tLZData[M28Map.subrefLZIslandRef]) then  tPDStartPoint = {tLZData[M28Map.subrefMidpoint][1], tLZData[M28Map.subrefMidpoint][2], tLZData[M28Map.subrefMidpoint][3]} end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to build emergency PD, iMinTechLevelWanted='..iMinTechLevelWanted) end
                        HaveActionToAssign(refActionBuildEmergencyPD, iMinTechLevelWanted, 40, tPDStartPoint)
                    end
                end
            end
        end
    end


    iCurPriority = iCurPriority + 1
    if iExistingFactory < iFactoriesWanted then
        --Dont want to build air factories at a core expansion point, instead only want land
        --[[local bWantAirNotLand = M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)
    local iFactoryAction
    if bWantAirNotLand then iFactoryAction = refActionBuildAirFactory
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Want to build land factory not air factory4') end
        iFactoryAction = refActionBuildLandFactory
    end--]]
        iBPWanted = 10
        if bExistingFactoryIsComplete then iBPWanted = 5 end
        local iMaxTechLevelIfAny
        if iExistingFactory == 0 then iMaxTechLevelIfAny = 1 end
        if bDebugMessages == true then LOG(sFunctionRef..': Want a land facotry, iExistingFactory='..iExistingFactory..'; iFactoriesWanted='..iFactoriesWanted) end
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 750 and M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) then
            HaveActionToAssign(refActionBuildAirFactory, 1, iBPWanted, iMaxTechLevelIfAny)
        else
            HaveActionToAssign(refActionBuildLandFactory, 1, iBPWanted, iMaxTechLevelIfAny)
        end
    end

    --High reclaim zone when ahve low mass - want to be reclaiming ahead of building mexes
    iCurPriority = iCurPriority + 1
    if bHaveLowMass and tLZData[M28Map.subrefTotalSignificantMassReclaim] >= 250 then
        if bDebugMessages == true then LOG(sFunctionRef..': High priority reclaim, Total mass in Plateau '..iPlateau..' LZ '..iLandZone..'='..tLZData[M28Map.subrefTotalMassReclaim]) end
        HaveActionToAssign(refActionReclaimArea, 1, 5, false)
    end

    if bDebugMessages == true then LOG(sFunctionRef..': About to consider what actions we want to give engineers for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; Is table of unbuilt mex locations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]))..'; Is table of part complete mexes empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]))) end
    iCurPriority = iCurPriority + 1
    --Unclaimed mex high priority
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': We have unbuilt mex locations for this land zone, locations='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations])) end
        HaveActionToAssign(refActionBuildMex, 1, 5)
        if (tLZTeamData[M28Map.subreftiBPWantedByAction][refActionBuildMex] or 0) > 0 then tLZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] = true end
    end

    --Reclaim enemy building if have available engineers, and enemy has buildings but no combat threat
    iCurPriority = iCurPriority + 1
    if not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if iHighestTechEngiAvailable > 0 then
            local oNearestEnemyUnitToMidpoint = M28Utilities.GetNearestUnit(tLZTeamData[M28Map.subrefTEnemyUnits], tLZData[M28Map.subrefMidpoint])
            if M28UnitInfo.IsUnitValid(oNearestEnemyUnitToMidpoint) then
                HaveActionToAssign(refActionReclaimEnemyUnit, 1, 5, oNearestEnemyUnitToMidpoint)

            end
        end
    end



    --AA if enemy has air to ground threat
    if bDebugMessages == true then LOG(sFunctionRef..': High priority AA builder: iNearbyEnemyAirToGroundThreat='..iNearbyEnemyAirToGroundThreat..'; enemy air to ground threat='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Enemy AirAA threat='..tLZTeamData[M28Map.refiEnemyAirAAThreat]) end
    iCurPriority = iCurPriority + 1
    if iNearbyEnemyAirToGroundThreat > 0 or tLZTeamData[M28Map.refiEnemyAirAAThreat] >= 500 then
        --Do we already have fixed AA in this LZ?
        local iAACategory = M28UnitInfo.refCategoryStructureAA
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then iAACategory = iAACategory * categories.TECH3 end
        local tExistingFixedAA = EntityCategoryFilterDown(iAACategory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local bHaveFixedAA = false
        if M28Utilities.IsTableEmpty(tExistingFixedAA) == false then
            for iUnit, oUnit in tExistingFixedAA do
                if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have fixed AA, considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                if oUnit:GetFractionComplete() then bHaveFixedAA = true break end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveFixedAA='..tostring(bHaveFixedAA)..'; Enemy air to ground threat='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Ally groundAA threat='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]) end
        if not(bHaveFixedAA) or iNearbyEnemyAirToGroundThreat > tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] then
            iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
            if iNearbyEnemyAirToGroundThreat > 0 then iBPWanted = iBPWanted * 2 end
            if not(bHaveLowPower) then
                if not(bHaveLowMass) then iBPWanted = iBPWanted * 4
                else iBPWanted = iBPWanted * 2
                end
            end
            local bIncreaseBPWanted = false
            local iT2PlusMex = 0
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefMexCountByTech]) == false then
                for iTech, iCount in tLZTeamData[M28Map.subrefMexCountByTech] do
                    if iTech > 1 then iT2PlusMex = iT2PlusMex + iCount end
                end
            end
            if iT2PlusMex > 0 then  bIncreaseBPWanted = true end
            --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted,                                          iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting)
            HaveActionToAssign(refActionBuildAA, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted     , nil,              true)
            if bDebugMessages == true then LOG(sFunctionRef..': Minor Zone AA builder if no fixed AA: iBPWanted='..iBPWanted..'; iNearbyEnemyAirToGroundThreat='..iNearbyEnemyAirToGroundThreat..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; subrefiAlliedGroundAAThreat='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]..'; iT2PlusMex='..iT2PlusMex..'; bIncreaseBPWanted='..tostring(bIncreaseBPWanted)) end
        end
    end

    --Protect game-ender or similar high avlue target (very high priority on assumption if we have built such a unit we shouldnt have to worry about lack of resources for this
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Want to assign units to active shield protection, will list out each unit for this zone that wants active protection')
            for iUnit, oUnit in tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
                LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Mass cost='..oUnit:GetBlueprint().Economy.BuildCostMass)
            end
        end
        if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] then
            iBPWanted = 500
        else
            iBPWanted = 100
        end


        if bDebugMessages == true then LOG(sFunctionRef..': Special shield defence action iBPWanted='..iBPWanted) end

        --Only use T3 engineers (even if we already have t3 engineers assigned) as want to make sure we can quickly get good concentrated build power
        --function HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist)
        HaveActionToAssign(refActionSpecialShieldDefence, 3, iBPWanted,         nil,                nil,                    nil,                        nil,                            true)
    end

    --Fortify zone (if flagged to fortify)
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefLZFortify] and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 2 then
        local bHaveSufficientTech = false
        local tT2PlusFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory - categories.TECH1, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tT2PlusFactories) == false then
            for iUnit, oUnit in tT2PlusFactories do
                if oUnit:GetFractionComplete() >= 1 and oUnit:GetAIBrain().M28AI then
                    bHaveSufficientTech = true
                    break
                end
            end
        end
        if bHaveSufficientTech then
            --If have capture targets then try and protect these, otherwise base destination on midpoint of the zone
            local tPointForPDConstruction
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoUnitsToCapture]) == false then
                for iUnit, oUnit in tLZTeamData[M28Map.subreftoUnitsToCapture] do
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        tPointForPDConstruction = oUnit:GetPosition()
                        break
                    end
                end
            end
            if not(tPointForPDConstruction) then
                tPointForPDConstruction = M28Utilities.MoveInDirection(tLZData[M28Map.subrefMidpoint], M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase]), 40, true, false, M28Map.bIsCampaignMap)
            end
            local iCurPDThreat = GetPDThreatAboveRangeThresholdAlongPath(iPlateau, iLandZone, tLZData, tLZTeamData, iTeam, 40, tPointForPDConstruction)

            if bDebugMessages == true then LOG(sFunctionRef..': Want PD for a zone that we want to fortify, iCurPDThreat='..(iCurPDThreat or 'nil')..'; Have sufficient tech='..tostring(bHaveSufficientTech)..'; tPointForPDConstruction='..repru(tPointForPDConstruction)..'; Midpoint of zone='..repru(tLZData[M28Map.subrefMidpoint])) end
            if iCurPDThreat <= 2100 then
                iBPWanted = 40
                if not(bHaveLowMass) and not(M28Conditions.HaveLowPower(iTeam)) then iBPWanted = 80 end
                local iPDTechLevelWanted = 2
                HaveActionToAssign(refActionBuildEmergencyPD, iPDTechLevelWanted, iBPWanted, tPointForPDConstruction)
                if bDebugMessages == true then LOG(sFunctionRef..': Will build PD to fortify zone, iPDTechLevelWanted='..iPDTechLevelWanted..'; iBPWanted='..iBPWanted) end
            end
        end
    end

    --Assign more BP to factories
    iCurPriority = iCurPriority + 1
    if iExistingFactory < iFactoriesWanted then
        --Dont want to build air factories at a core expansion point, instead only want land
        iBPWanted = 10
        if not(bHaveLowMass) then iBPWanted = math.min(30, 3 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]) end
        --[[local bWantAirNotLand = M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)
    local iFactoryAction
    if bWantAirNotLand then iFactoryAction = refActionBuildAirFactory
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Want to build land factory not air factory5') end
        iFactoryAction = refActionBuildLandFactory
    end--]]
        if bDebugMessages == true then LOG(sFunctionRef..': Want more BP for land factories, iBPWanted='..iBPWanted..' iExistingFactory='..iExistingFactory..'; iFactoriesWanted='..iFactoriesWanted) end
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 750 and M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) then
            HaveActionToAssign(refActionBuildAirFactory, 1, iBPWanted, nil)
        else
            HaveActionToAssign(refActionBuildLandFactory, 1, iBPWanted, nil)
        end
    end

    --Unclaimed mex in the zone
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) == false then
        iBPWanted = math.max(5, table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) * 2.5)
        if bDebugMessages == true then LOG(sFunctionRef..': We have unbuilt mex locations for this land zone, iBPWanted='..iBPWanted..', locations='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations])) end
        HaveActionToAssign(refActionBuildMex, 1, iBPWanted)
        if (tLZTeamData[M28Map.subreftiBPWantedByAction][refActionBuildMex] or 0) > 0 then tLZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] = true end
    elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
        --Do we have no engineers assigned to building a mex?
        local bHaveEngisBuilding = false
        if M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
            for iEngi, oEngi in toAssignedEngineers do
                if oEngi[refiAssignedAction] == refActionBuildMex then
                    bHaveEngisBuilding = true
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of assigned engineers empty='..tostring(M28Utilities.IsTableEmpty(toAssignedEngineers))..'; bHaveEngisBuilding='..tostring(bHaveEngisBuilding)) end
        if not(bHaveEngisBuilding) then
            --Refresh list of mexes
            RefreshPartBuiltMexList(tLZTeamData)
            if bDebugMessages == true then LOG(sFunctionRef..': Refreshed part built mex list, is table of part built mexes empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]))) end
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
                HaveActionToAssign(refActionCompletePartBuiltMex, 1, 5)
                if bDebugMessages == true then LOG(sFunctionRef..': Will get engi to complete part built mex') end
            end
        end
    end

    --Zones wanting specific faction engineers (e.g. for shielding game ender)
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftFactoriesWantedForEngineers]) == false then
        local iZoneWantingEngineersOfFaction, iFactionWanted = GetZoneAndFactionForPriorityEngineerTravel(tLZTeamData, iTeam, iLandZone, iPlateau)
        if iZoneWantingEngineersOfFaction and iFactionWanted then
            HaveActionToAssign(refActionMoveToLandZone, 3, 90, iZoneWantingEngineersOfFaction, true, false, iFactionWanted)
        end
    end

    --nearby zones with unclaimed mexes and no engineers traveling there
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have available engineers to send to another LZ. GetHighestTechEngiAvailable='..GetHighestTechEngiAvailable(toAvailableEngineersByTech)) end
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    local iNearbyZonesWantingEngineers = 0
    local iPrevEngisAvailable
    local tLZWantingBPConsidered = {}
    local iAdjLZ
    if iHighestTechEngiAvailable > 0 then
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
            for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                if tPathingDetails[M28Map.subrefLZTravelDist] <= tLZData[M28Map.subrefLZFurthestAdjacentLandZoneTravelDist] then
                    iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                    local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                    if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]) then
                        local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                        if tAdjLZTeamData[M28Map.subrefTbWantBP] and tAdjLZTeamData[M28Map.subrefTBuildPowerByTechWanted][1] > 0 and M28Utilities.IsTableEmpty(tAdjLZData[M28Map.subrefMexUnbuiltLocations]) == false and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEngineersTravelingHere]) and not(tAdjLZTeamData[M28Map.subrefLZCoreExpansion]) and not(tAdjLZTeamData[M28Map.subrefLZbCoreBase]) and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) then
                            HaveActionToAssign(refActionMoveToLandZone, 1, iNearbyZonesWantingEngineers * 5 + 5, iAdjLZ, true)
                            iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                            iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                            if (tLZTeamData[M28Map.subreftiBPWantedByAction][refActionMoveToLandZone] or 0) > 0 then tLZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] = true end
                            if iHighestTechEngiAvailable == 0 then break end
                        end
                    end
                else
                    break --Table shoudl be sorted closest first so if we are too far away now the later entries should be ignored
                end
            end
        end
    end

    --High priority reclaim if are low on mass or energy
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then
        LOG(sFunctionRef..': Considering if we want high priority reclaim, bHaveLowMass='..tostring(bHaveLowMass)..'; tLZData[M28Map.subrefTotalMassReclaim]='..(tLZData[M28Map.subrefTotalMassReclaim] or 'nil')..'; Significant mass reclaim='..tLZData[M28Map.subrefTotalSignificantMassReclaim])
        M28Land.DrawReclaimSegmentsInLandZone(iPlateau, iLandZone, true)
    end
    if bHaveLowMass and tLZData[M28Map.subrefTotalSignificantMassReclaim] >= 25 then
        local iReclaimFactor = 60
        if GetGameTimeSeconds() <= 540 then iReclaimFactor = 90 end
        iBPWanted = math.min(40, math.max(5, tLZData[M28Map.subrefTotalMassReclaim] / iReclaimFactor))
        if iBPWanted > 15 and GetGameTimeSeconds() <= 540 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 then
            iBPWanted = math.min(iBPWanted, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * 15)
        end
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then iBPWanted = math.max(5, iBPWanted * 0.6) end
        if bDebugMessages == true then LOG(sFunctionRef..': Higher priority reclaim, Total mass in Plateau '..iPlateau..' LZ '..iLandZone..'='..tLZData[M28Map.subrefTotalMassReclaim]) end
        HaveActionToAssign(refActionReclaimArea, 1, iBPWanted, false)
        if bDebugMessages == true then LOG(sFunctionRef..': Have just tried assigning action to reclaim area') end
    elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= 0.7 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 80 and tLZData[M28Map.subrefLZTotalEnergyReclaim] >= 100 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < 2 then
        HaveActionToAssign(refActionReclaimArea, 1, 5, true)
    end


    --TMD - TML (including mobile ACUs with TML upgrade)
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]) == false then
        iBPWanted = 30
        if not(bHaveLowMass) then iBPWanted = 50 end
        if bDebugMessages == true then LOG(sFunctionRef..': We have untis wanting TMD in LZ '..iLandZone..'; will list out each unit')
            for iUnit, oUnit in tLZTeamData[M28Map.reftUnitsWantingTMD] do
                LOG(sFunctionRef..': Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Unit position='..repru(oUnit:GetPosition()))
            end
        end
        --Get the unit closest to the nearest enemy base to protect first
        local oUnitWantingTMD = M28Building.GetUnitWantingTMD(tLZData, tLZTeamData, iTeam, iLandZone)
        if bDebugMessages == true then LOG(sFunctionRef..': Is oUnitWantingTMD valid='..tostring(M28UnitInfo.IsUnitValid(oUnitWantingTMD))..'; iBPWanted='..iBPWanted) end
        if oUnitWantingTMD then
            HaveActionToAssign(refActionBuildTMD, 2, iBPWanted,  oUnitWantingTMD)
        end
    end

    --Reclaim specific units
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if have units to reclaim, is table empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoUnitsToReclaim]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoUnitsToReclaim]) == false then
        local bObjectiveToReclaim = false
        if M28Map.bIsCampaignMap then
            for iUnit, oUnit in tLZTeamData[M28Map.subreftoUnitsToReclaim] do
                if oUnit[M28UnitInfo.refbIsReclaimTarget] then bObjectiveToReclaim = true break end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Want to reclaim friendly unit, bObjectiveToReclaim='..tostring(bObjectiveToReclaim)) end
        if bObjectiveToReclaim or (bHaveLowMass and not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])) then
            HaveActionToAssign(refActionReclaimFriendlyUnit, 1, math.min(1.5 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]], math.max(5, 5 * table.getn(tLZTeamData[M28Map.subreftoUnitsToReclaim]))), nil, false)
        else
            --if have engi in the zone then reclaim it, but dont request an engi
            HaveActionToAssign(refActionReclaimFriendlyUnit, 1, 5, nil, true)
        end
    end

    --Unclaimed hydro in the zone (and we have less than 4k power in our team)
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 400 and M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': We have unbuilt hydro locations for this land zone, locations='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations])) end

        HaveActionToAssign(refActionBuildHydro, 1, 10)
    end

    --SMD if very high value and enemy has nukes
    if tLZTeamData[M28Map.subrefLZSValue] >= 60000 or (tLZTeamData[M28Map.subrefLZSValue] >= 20000 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false) or tLZTeamData[M28Map.reftObjectiveSMDLocation] then
        --Make sure we have at least 2 T3 mex in this zone (or no T2 and T1 mexes)
        if (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 or (tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10)) or (tLZTeamData[M28Map.reftObjectiveSMDLocation] and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])) then

            local bAssistSMD = false
            iBPWanted, bAssistSMD = GetBPToAssignToSMD(iPlateau, iLandZone, iTeam, tLZTeamData, false, bHaveLowMass, bWantMorePower)
            if iBPWanted > 0 then
                if bAssistSMD then
                    HaveActionToAssign(refActionAssistSMD, 1, iBPWanted)
                else
                    HaveActionToAssign(refActionBuildSMD, 3, iBPWanted)
                end
            end
        end
    end

    --TML (will only trigger atm for core expansions)
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefLZCoreExpansion] then --Redundancy - getbptoassign function also includes this condition; however might be faster by having ith ere as an excluding factor?
        iBPWanted = GetBPToAssignToBuildingTML(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam, bHaveLowMass)
        if iBPWanted > 0 then
            HaveActionToAssign(refActionBuildTML, 2, iBPWanted)
        end
    end

    --Shielding
    iCurPriority = iCurPriority + 1
    local iTechLevelWanted, oUnitToShield
    iBPWanted, iTechLevelWanted, oUnitToShield = GetBPMinTechAndUnitForFixedShields(tLZTeamData, iTeam, false, bHaveLowMass, bWantMorePower, false, iLandZone, iPlateau)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionBuildShield, iTechLevelWanted, iBPWanted, oUnitToShield)
        if bDebugMessages == true then LOG(sFunctionRef..': Have just tried to assign an action to shield unit '..oUnitToShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToShield)) end
    end

    --Units to capture
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of units to capture empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]))) end
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]) == false then
        --Refresh the list
        local iCaptureCount = table.getn(tLZData[M28Map.subreftoUnitsToCapture])
        for iCurCount = iCaptureCount, 1, -1 do
            if not(M28UnitInfo.IsUnitValid(tLZData[M28Map.subreftoUnitsToCapture][iCurCount])) then
                table.remove(tLZData[M28Map.subreftoUnitsToCapture], iCurCount)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Have units to capture for zone '..iLandZone..', after freshing them is table empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]))) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]) == false then
            local oUnitToCapture
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 75 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                local tPotentialCapture = EntityCategoryFilterDown(categories.ALLUNITS - M28UnitInfo.refCategoryT3Power, tLZData[M28Map.subreftoUnitsToCapture])
                if M28Utilities.IsTableEmpty(tPotentialCapture) == false then
                    oUnitToCapture = M28Utilities.GetNearestUnit(tPotentialCapture, tLZData[M28Map.subrefMidpoint])
                end
            else
                oUnitToCapture = M28Utilities.GetNearestUnit(tLZData[M28Map.subreftoUnitsToCapture], tLZData[M28Map.subrefMidpoint])
            end
            if oUnitToCapture then
                if bDebugMessages == true then LOG(sFunctionRef..': Unit to cpature='..oUnitToCapture.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToCapture)) end
                iBPWanted = GetCaptureBPWanted(oUnitToCapture, bHaveLowPower, iTeam, tLZTeamData[M28Map.subrefLZbCoreBase])
                HaveActionToAssign(refActionCaptureUnit, 1, iBPWanted, oUnitToCapture)
            end

        end
    end

    --Units to repair
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of units to repair empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToRepair]))..'; iTeam='..iTeam) end
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToRepair]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Have units to repair for zone '..iLandZone..' is table empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToRepair]))) end
        if M28Conditions.IsTableOfUnitsStillValid(tLZData[M28Map.subreftoUnitsToRepair], true) then
            local oUnitToTarget = M28Utilities.GetNearestUnit(tLZData[M28Map.subreftoUnitsToRepair], tLZData[M28Map.subrefMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': Unit to repair='..oUnitToTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToTarget)..'; will flag we want some BP for this') end
            HaveActionToAssign(refActionRepairUnit, 1, 5, oUnitToTarget)
        end
    end

    --late game power (in case running out of space in core zone)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if we want power in minor zone, bHaveLowPower='..tostring(bHaveLowPower)..'; tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Mass % stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; bHaveLowMass='..tostring(bHaveLowMass)..'; MexT3 count='..tLZTeamData[M28Map.subrefMexCountByTech][3]..'; tLZTeamData[M28Map.subrefLZSValue]='..tLZTeamData[M28Map.subrefLZSValue]..'; iExistingFactory='..iExistingFactory) end
    if (bHaveLowPower or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.8 and M28Conditions.WantMorePower(iTeam))) and not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and not(bHaveLowMass) and (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 3 or tLZTeamData[M28Map.subrefLZSValue] >= 10000 or (bAdjacentToCoreZone and tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1)) then
        --Either adjacent to core zone, or have a land fac in this zone, or relatively close to our base
        if bDebugMessages == true then LOG(sFunctionRef..': tLZTeamData[M28Map.refiModDistancePercent]='..tLZTeamData[M28Map.refiModDistancePercent]..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]) end
        if bAdjacentToCoreZone or iExistingFactory > 0 or tLZTeamData[M28Map.refiModDistancePercent] <= 0.15 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.95 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 3000) then
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 350 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.35 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.7 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 30 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 80 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 900 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) then
                iBPWanted = 90
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.85 then iBPWanted = 180 end
                HaveActionToAssign(refActionBuildPower, 3, iBPWanted)
            end
        end
    end

    --Shield assistance
    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPForShieldAssistance(tLZTeamData, iTeam)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionAssistShield, 1, iBPWanted)
    end

    iCurPriority = iCurPriority + 1
    --(ANY CHANGES TO BELOW - CONSIDER REPLICATING FOR BOTH CORE AND NONCORE BUILDERS) Adjacent LZ that wants engineers and has unbuilt mexes (only chekc if we have available engineers)
    --(as of v24 decided to go with differences for the minior LZ (which uses a simplified appraoch) vs core base highest priority for adj LZs
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have available engineers to send to another LZ. GetHighestTechEngiAvailable='..GetHighestTechEngiAvailable(toAvailableEngineersByTech)) end
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
            for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                if tPathingDetails[M28Map.subrefLZTravelDist] <= tLZData[M28Map.subrefLZFurthestAdjacentLandZoneTravelDist] then
                    iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]

                    --tLZWantingBPConsidered[iAdjLZ] = true --Are now adding in the condition that the zone has unbuilt mexes
                    --Require unbuilt mexes:
                    local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, iAdjLZ, iPathingRef, iHighestTechEngiAvailable, true, false, true)
                    if tiBPByTechWanted then
                        for iTech = 1, iHighestTechEngiAvailable, 1 do
                            if tiBPByTechWanted[iTech] > 0 then
                                iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                HaveActionToAssign(refActionMoveToLandZone, iTech, iNearbyZonesWantingEngineers * 5 + tiBPByTechWanted[iTech], iAdjLZ, true)
                                if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                    iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                end

                                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                if iHighestTechEngiAvailable == 0 then break end
                            end
                        end
                    end
                    if iHighestTechEngiAvailable == 0 then break end
                else
                    break --Table shoudl be sorted closest first so if we are too far away now the later entries should be ignored
                end
            end
        end
    end

    iCurPriority = iCurPriority + 1
    --If have adjacent waterzone that has unbuilt mexes, wants engineers and has no combat threat then assign engi unelss it already has engis and we dont have many in this zone
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; Checking if adjacent water zones that want engis to build mexes, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
    local iCoreWZWantingSupportAsLowerPriority
    if iHighestTechEngiAvailable > 0 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
        local iCurWZ, iCurPond
        local iBPAlreadyAssigned = 0
        local bConsiderWaterZone
        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
            --Use similar logic to core land zone to avoid unintended consequences
            iCurWZ = tSubtable[M28Map.subrefAWZRef]
            iCurPond = M28Map.tiPondByWaterZone[iCurWZ]
            local tWZData = M28Map.tPondDetails[iCurPond][M28Map.subrefPondWaterZones][iCurWZ]
            if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent water zone iCurWZ='..iCurWZ..'; iCurPond='..iCurPond..'; Is table of unbuilt mex locations empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]))) end
            local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
            bConsiderWaterZone = false
            if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tWZData[M28Map.subrefMidpoint]) then
                if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]) == false then
                    bConsiderWaterZone = true
                elseif tWZTeamData[M28Map.subrefWZbCoreBase] and tWZTeamData[M28Map.subrefTbWantBP] then
                    --Do we already have a completed naval factory here and at least 1 engineer? if so not as high priority
                    bConsiderWaterZone = true
                    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                        local tFactoriesAndEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                        if M28Utilities.IsTableEmpty(tFactoriesAndEngineers) == false then
                            local iEngiCount = 0
                            local iCompletedFactoryCount = 0
                            for iUnit, oUnit in tFactoriesAndEngineers do
                                if oUnit:GetFractionComplete() == 1 then
                                    if EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oUnit.UnitId) then
                                        iCompletedFactoryCount = iCompletedFactoryCount + 1
                                    else
                                        iEngiCount = iEngiCount + 1
                                    end
                                end
                            end
                            if iCompletedFactoryCount > 0 and iCompletedFactoryCount + iEngiCount >= 3 then
                                bConsiderWaterZone = false
                            end
                        end
                    end
                    if not(bConsiderWaterZone)  and tWZTeamData[M28Map.subrefTbWantBP] then iCoreWZWantingSupportAsLowerPriority = iCurWZ end
                end
            end
            if bConsiderWaterZone then

                --or (tWZTeamData[M28Map.subrefWZbCoreBase] and (M28Utilities.IsTableEmpty(tWZTeamData[M28Map. then

                if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to send engineers to an adjaent water zone, iCurWZ='..iCurWZ..'; tWZTeamData[M28Map.subrefTbWantBP]='..tostring(tWZTeamData[M28Map.subrefTbWantBP] or false)) end
                if tWZTeamData[M28Map.subrefTbWantBP] and tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 10 then
                    iBPWanted = 5
                    if tWZTeamData[M28Map.subrefTbWantBP] then
                        iBPWanted = math.min(50, math.max(tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]], tWZTeamData[M28Map.subrefTBuildPowerByTechWanted][1]))
                    end
                    HaveActionToAssign(refActionMoveToWaterZone, 1, iBPWanted + iBPAlreadyAssigned, iCurWZ, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': BP wanted+BP assigned='..iBPWanted + iBPAlreadyAssigned) end
                    iBPAlreadyAssigned = iBPAlreadyAssigned + iBPWanted
                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                    if iHighestTechEngiAvailable == 0 or iBPAlreadyAssigned >= tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 3 then break end
                end
            end
        end
    end

    --High priority islands (early-game expansion)
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS)
    iCurPriority = iCurPriority + 1
    local iBPAlreadyTraveling = 0
    GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if bDebugMessages == true then LOG(sFunctionRef..': Core LZ considering engis for islands, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Time='..GetGameTimeSeconds()) end
    if iHighestTechEngiAvailable > 0 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of pathing to other islands empty='..tostring(tLZData[M28Map.subrefLZPathingToOtherIslands])) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
            local iDistanceThreshold = math.max(125, M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) * 0.502)
            if bDebugMessages == true then LOG(sFunctionRef..': iDistanceThreshold='..iDistanceThreshold) end

            for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..'; Travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; tPathingData[M28Map.subrefIslandClosestLZRef]='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; Are there enemies in this or adjacnet LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                if tPathingData[M28Map.subrefIslandTravelDist] > iDistanceThreshold then break
                else
                    --Are there enemies in the target LZ?
                    local tIslandLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]]
                    if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tIslandLZData[M28Map.subrefMidpoint]) then
                        if tPathingData[M28Map.subrefIslandClosestLZRef] and M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefMexUnbuiltLocations]) == false and not(tIslandLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                            local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, tPathingData[M28Map.subrefIslandClosestLZRef], iEntry, iHighestTechEngiAvailable, false, true)
                            if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                            if tiBPByTechWanted then
                                --Is it either a minor zone, or a core zone that either wants lots of BP or doesnt have any engineers traveling to it?
                                for iTech = 1, iHighestTechEngiAvailable, 1 do
                                    if tiBPByTechWanted[iTech] > 0 then
                                        iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                        iBPWanted = iBPAlreadyTraveling + 5
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and assign an engineer to go to tPathingData[M28Map.subrefIslandClosestLZRef]='..tPathingData[M28Map.subrefIslandClosestLZRef]..'; BP wanted='..iBPWanted..'; iTech='..iTech..'; iPrevEngisAvailable='..iPrevEngisAvailable) end
                                        HaveActionToAssign(refActionMoveToLandZone, iTech, iBPWanted, tPathingData[M28Map.subrefIslandClosestLZRef], true)
                                        if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                            iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                            iBPAlreadyTraveling = iBPAlreadyTraveling + tiBPByTech[iTech]
                                        end

                                        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                        if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable after this='..iHighestTechEngiAvailable) end
                                        if iHighestTechEngiAvailable == 0 then break end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end


    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPToAssignToAssistUpgrade(tLZTeamData, iTeam, false, bHaveLowMass, bHaveLowPower, bWantMorePower)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionAssistUpgrade, 1, iBPWanted)
    end

    --Build mass storage if we have T2+ mexes
    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPToAssignToMassStorage(iPlateau, iLandZone, iTeam, tLZData, tLZTeamData, true, bHaveLowMass, bWantMorePower)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionBuildMassStorage, 1, iBPWanted)
    end

    --Lower priority mass reclaim
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Lower priority reclaim if want mass, Total mass reclaim in zone='..(tLZData[M28Map.subrefTotalMassReclaim] or 'nil')..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Lowest mass % stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]) end
    if (bHaveLowMass or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.35) and tLZData[M28Map.subrefTotalMassReclaim] >= 5 then
        local iReclaimFactor = 75
        if GetGameTimeSeconds() <= 540 then iReclaimFactor = 125 end
        iBPWanted = math.min(40, math.max(5, tLZData[M28Map.subrefTotalMassReclaim] / iReclaimFactor))
        if iBPWanted > 15 and GetGameTimeSeconds() <= 540 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 then
            iBPWanted = math.min(iBPWanted, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * 10)
        end
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then iBPWanted = math.max(5, iBPWanted * 0.6) end

        if bDebugMessages == true then LOG(sFunctionRef..': Lower priority reclaim, Total mass in Plateau '..iPlateau..' LZ '..iLandZone..'='..tLZData[M28Map.subrefTotalMassReclaim]) end
        HaveActionToAssign(refActionReclaimArea, 1, math.min(100, math.max(5, iBPWanted)), false)
    end

    --SAMs for minor zones
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefLZSValue] >= 1500 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and (tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] > 0 or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 1000 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3) then
        local iGroundAAWanted = math.max(1600, M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.2)
        if (not(M28Team.tTeamData[iTeam][M28Team.refbHaveAirControl] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 8) or (not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20 and M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] >= 2000)) and tLZTeamData[M28Map.subrefLZSValue] >= 1500 then
            iGroundAAWanted = math.max(3200, M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.25 + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.05)
        end
        if iGroundAAWanted > math.max(7000, tLZTeamData[M28Map.subrefLZSValue] * 0.5) then
            iGroundAAWanted = math.max(7000, math.min(iGroundAAWanted, tLZTeamData[M28Map.subrefLZSValue] * 0.5, 4000 * tLZTeamData[M28Map.subrefMexCountByTech][3]  + 1000 * tLZTeamData[M28Map.subrefMexCountByTech][2]))
        end

        if tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < iGroundAAWanted then
            --Do we already have fixed AA in this LZ?
            local iAACategory = M28UnitInfo.refCategoryStructureAA
            if M28Team.subrefiHighestFriendlyFactoryTech >= 3 then iAACategory = iAACategory * categories.TECH3 end
            local tExistingFixedAA = EntityCategoryFilterDown(iAACategory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            --Max of 1 sam per 1 T3 mex (approx), more if we have large gunship threat and lack air control
            if M28Utilities.IsTableEmpty(tExistingFixedAA) or tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < math.max(iNearbyEnemyAirToGroundThreat * 2, iGroundAAWanted) then
                --Further cap on number of SAMs
                if not(bHaveLowMass and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) and tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] >= 6000 and (tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][1]) > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] > 15 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                    iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
                    if iNearbyEnemyAirToGroundThreat > 0 then iBPWanted = iBPWanted * 2 end
                    if not(bHaveLowPower) then
                        if not(bHaveLowMass) then iBPWanted = iBPWanted * 4
                        else iBPWanted = iBPWanted * 2
                        end
                    end
                    HaveActionToAssign(refActionBuildAA, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted)
                    if bDebugMessages == true then LOG(sFunctionRef..': Wnat more AA for minor zone, iBPWanted='..iBPWanted) end
                end
            end
        end
    end

    --Higher priority T2 radar creep where we have large mass income or lots of experimentals
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': T2 radar creep - bHaveLowMass='..tostring(bHaveLowMass)..'; bWantMorePower='..tostring(bWantMorePower)..'; Radar coverage='..tLZTeamData[M28Map.refiRadarCoverage]..'; Map size='..M28Map.iMapSize..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; tLZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
    if not(bHaveLowPower) and tLZTeamData[M28Map.subrefLZSValue] >= 3000 and tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1 and tLZTeamData[M28Map.refiRadarCoverage] < 250 and tLZTeamData[M28Map.refiRadarCoverage] < 170 and (tLZTeamData[M28Map.refiRadarCoverage] < 130 or not(bHaveLowMass)) and M28Map.iMapSize > 600 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 60 and (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 150) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL) >= 4 then
        --Check we dont have any radar here already (redundancy for radar coverage)
        local tExistingRadar = EntityCategoryFilterDown(M28UnitInfo.refCategoryRadar, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local bHaveRadar = false
        if M28Utilities.IsTableEmpty(tExistingRadar) == false then
            for iUnit, oUnit in tExistingRadar do
                if oUnit:GetFractionComplete() >= 1 then
                    bHaveRadar = true
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveRadar='..tostring(bHaveRadar)) end
        if not(bHaveRadar) then
            --Are we able to build radar? assume we can if we have access to T3 factories for simplicity
            if not(M28Map.bIsCampaignMap) or not(M28Overseer.bUnitRestrictionsArePresent) or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then
                HaveActionToAssign(refActionBuildT2Radar, 2, 10)
            end
        end
    end

    --Lower priority LZs wanting engineers:
    iCurPriority = iCurPriority + 1
    if iCoreWZWantingSupportAsLowerPriority and iHighestTechEngiAvailable > 0 then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if iHighestTechEngiAvailable > 0 then
            HaveActionToAssign(refActionMoveToWaterZone, 1, tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]], iCoreWZWantingSupportAsLowerPriority, true)
        end
    end
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS) Other non adjacent LZ on this plateau that wants engineers (low priority) - prioritise those nearest this zone
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if bDebugMessages == true then LOG(sFunctionRef..': About to check for further away zones wanting BP, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; iCurPriority='..iCurPriority) end
    if iHighestTechEngiAvailable > 0 then
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
            for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                if bDebugMessages == true then LOG(sFunctionRef..': Lower priority logic to send engineers to another LZ, iAdjLZ='..iAdjLZ..'; Have we alreayd considered='..tostring(tLZWantingBPConsidered[iAdjLZ] or false)) end
                if not(tLZWantingBPConsidered[iAdjLZ]) then
                    tLZWantingBPConsidered[iAdjLZ] = true
                    local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, iAdjLZ, iPathingRef, iHighestTechEngiAvailable, false)
                    if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                    if tiBPByTechWanted then
                        for iTech = 1, iHighestTechEngiAvailable, 1 do
                            if tiBPByTechWanted[iTech] > 0 then
                                iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                HaveActionToAssign(refActionMoveToLandZone, iTech, (iNearbyZonesWantingEngineers + 1) * 5, iAdjLZ, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': Sending engineers to nearby zone, BPWanted='..(iNearbyZonesWantingEngineers + 1) * 5) end
                                if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                    iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                end

                                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                if iHighestTechEngiAvailable == 0 then break end
                            end
                        end
                    end
                end
                if iHighestTechEngiAvailable == 0 then break end
            end
        end
    end

    --Islands wanting engineers (provided we dont have adjacent naval threats)
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': About to check if minor LZ wants to send engis to an island, iHighestTechEngiAvailable='..iHighestTechEngiAvailable) end
    local iIslandDistanceThreshold
    if iHighestTechEngiAvailable > 0 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
        if bDebugMessages == true then LOG(sFunctionRef..': is pathing to other islands empty='..tostring( M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]))) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; tLZTeamData[M28Map.reftClosestEnemyBase]='..repru(tLZTeamData[M28Map.reftClosestEnemyBase])..'; tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint])) end
            iIslandDistanceThreshold = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) * 0.6
            if M28Map.bIsCampaignMap then iIslandDistanceThreshold = iIslandDistanceThreshold * 1.5 end
            if bDebugMessages == true then LOG(sFunctionRef..': Will search for islands, iIslandDistanceThreshold='..iIslandDistanceThreshold) end

            for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering island '..tPathingData[M28Map.subrefIslandNumber]..'; travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; Closest LZ ref='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; are enemies in this or adjacent LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                if tPathingData[M28Map.subrefIslandTravelDist] > iIslandDistanceThreshold then break
                else
                    --Are there enemies in the target LZ?
                    if tPathingData[M28Map.subrefIslandClosestLZRef] and not(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                        local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, tPathingData[M28Map.subrefIslandClosestLZRef], iEntry, iHighestTechEngiAvailable, false, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                        if tiBPByTechWanted then
                            --Is it either a minor zone, or a core zone that either wants lots of BP or doesnt have any engineers traveling to it?
                            for iTech = 1, iHighestTechEngiAvailable, 1 do
                                if tiBPByTechWanted[iTech] > 0 then
                                    iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                    HaveActionToAssign(refActionMoveToLandZone, iTech, math.max((iNearbyZonesWantingEngineers + 1) * 5, tiBPByTechWanted[iTech]), tPathingData[M28Map.subrefIslandClosestLZRef], true)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished trying to give order for engi to move to the island LZ, table.getn(toAvailableEngineersByTech[iTech])='..table.getn(toAvailableEngineersByTech[iTech])..'; iPrevEngisAvailable='..iPrevEngisAvailable) end
                                    if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                        iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                    end

                                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                    if iHighestTechEngiAvailable == 0 then break end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    --If have are overflowing mass and have high income, energy, and are at T3, and this zone has mexes and no enemy units then get land factories if <=2, or an experimental otherwise
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3 and not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 750 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 30 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1000 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.6) then
        --We need at least 1 T3 mex in the zone and no enemy units
        if tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) then
            local iExistingFactories = 0
            local tExistingLandFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tExistingLandFactories) == false then
                iExistingFactories = table.getn(tExistingLandFactories)
            end
            if iExistingFactories < 2 and M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone) then
                --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting)
                if bDebugMessages == true then LOG(sFunctionRef..': Want to build land factory as only have 1 factory') end
                HaveActionToAssign(refActionBuildLandFactory, 1, 40)
            else
                --Build land experimental if enemy base is pathable by land from here and we have high gross mass
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 60 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 6 then
                    if (NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) or 0) == (NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint]) or -1) then
                        HaveActionToAssign(refActionBuildLandExperimental, 3, 60, nil, false, true)
                    else
                        HaveActionToAssign(refActionBuildExperimental, 3, 60, nil, false, true)
                    end
                end
            end
        end
    end

    --If still have an engineer available and have an adjacent LZ that wants BP and doesnt have any enemies in that LZ specifically (even if there might be in an adjacent one) then send engineer
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then

        if bDebugMessages == true then LOG(sFunctionRef..': Table of adjacnet LZs='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones])) end
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
            local iBPAlreadyTraveling = 0
            if M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
                for iEngi, oEngi in toAssignedEngineers do
                    if oEngi[refiAssignedAction] == refActionMoveToLandZone then
                        iBPAlreadyTraveling = iBPAlreadyTraveling + oEngi:GetBlueprint().Economy.BuildRate
                    end
                end
            end

            for _, iAdjLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; Does it want BP='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP])..'; Combat threat='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal]) end
                if not(tLZWantingBPConsidered[iAdjLZ]) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP] and (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][1] or 0) > 0 and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] == 0 then
                    HaveActionToAssign(refActionMoveToLandZone, 1, iBPAlreadyTraveling + 5, iAdjLZ, true)
                    iBPAlreadyTraveling = iBPAlreadyTraveling + 5
                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                    if iHighestTechEngiAvailable == 0 then break end
                end
            end
        end
    end


    --Adjacent water zones that want an engineer
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have adjacent WZ that wants engineer, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
    if iHighestTechEngiAvailable > 0 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
        local iCurWZ
        local iCurPond
        local bWantBPOfOurTech
        local iMinTechWanted = 1
        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
            iCurWZ = tSubtable[M28Map.subrefAWZRef]
            iCurPond = M28Map.tiPondByWaterZone[iCurWZ]
            local tWZData = M28Map.tPondDetails[iCurPond][M28Map.subrefPondWaterZones][iCurWZ]
            if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tWZData[M28Map.subrefMidpoint]) then
                local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to send engineers to an adjaent water zone, iCurWZ='..iCurWZ..'; tWZTeamData[M28Map.subrefTbWantBP]='..tostring(tWZTeamData[M28Map.subrefTbWantBP] or false)) end
                if tWZTeamData[M28Map.subrefTbWantBP] then
                    bWantBPOfOurTech = false
                    for iTech = iHighestTechEngiAvailable, 1, -1 do
                        if tWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                            bWantBPOfOurTech = true
                            iMinTechWanted = iTech
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': bWantBPOfOurTech='..tostring(bWantBPOfOurTech)) end
                    if bWantBPOfOurTech then
                        HaveActionToAssign(refActionMoveToWaterZone, iMinTechWanted, math.min(tiBPByTech[iMinTechWanted] * 2, 50), iCurWZ, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': have tried to send BP of '..(tiBPByTech[iMinTechWanted] * 2)..' to iCurWZ '..iCurWZ) end
                        break
                    end
                end
                if bWantBPOfOurTech then break end
            end
        end
    end

    --Extra (second) shielding in a high mass scenario - will only try to shield t3 arti/game ender
    iCurPriority = iCurPriority + 1
    if (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 500 then
        local iBPWanted, iTechLevelWanted, oUnitToShield = GetBPMinTechAndUnitForFixedShields(tLZTeamData, iTeam, true, bHaveLowMass, bWantMorePower, true, iLandZone, iPlateau)
        if iBPWanted > 0 then
            iBPWanted = math.min(iBPWanted, 40)

            HaveActionToAssign(refActionBuildSecondShield, iTechLevelWanted, iBPWanted, oUnitToShield)
            if bDebugMessages == true then LOG(sFunctionRef..': High priority shield builder, iBPWanted='..iBPWanted) end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Dont want to assign any BP to high priority shield builder') end
        end
    end

    --Dont have low mass and have a navla fac in a WZ that wants more BP and is near enough for engineers to be sent to assist, then send BP here


    --Low priority power builder if we have lots of mass and dont have much power
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 75 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < math.max(250, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.5) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 20) then
        local iMinTechLevelForPower = 1
        --[[if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 then
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 22 then iMinTechLevelForPower = 1
    elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 110 then iMinTechLevelForPower = 2
    end
end--]]
        HaveActionToAssign(refActionBuildPower, iMinTechLevelForPower, tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 6)
    end

    --Low priority air staging, if we have T3 mex, decent intel coverage, no nearby enemies, and need air staging
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': About to check if we need air staging for core zone, Time='..GetGameTimeSeconds()..'; Time of last shortage='..(M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastAirStagingShortage] or 'nil')) end
    if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastAirStagingShortage] or 0) <= 1.1 and not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and (tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][2] >= 3) and tLZTeamData[M28Map.refiRadarCoverage] >= 100 then
        local tExistingAirStaging = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirStaging, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local iExistingAirStaging = 0
        if M28Utilities.IsTableEmpty(tExistingAirStaging) == false then
            for iStaging, oStaging in tExistingAirStaging do
                if oStaging:GetFractionComplete() == 1 and oStaging:GetAIBrain().M28AI then
                    iExistingAirStaging = iExistingAirStaging + 1
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iExistingAirStaging='..iExistingAirStaging..'; bHaveLowMass='..tostring(bHaveLowMass)) end
        if iExistingAirStaging < 1 then
            iBPWanted = 5
            if not(bHaveLowMass) then iBPWanted = iBPWanted * 2 end
            HaveActionToAssign(refActionBuildAirStaging, 1, iBPWanted, nil, false)
            if bDebugMessages == true then LOG(sFunctionRef..': Have flagged we want air staging for minor zone with iBPWanted='..iBPWanted) end
        end
    end

    --Low priority T2 radar creep
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': T2 radar creep - bHaveLowMass='..tostring(bHaveLowMass)..'; bWantMorePower='..tostring(bWantMorePower)..'; Radar coverage='..tLZTeamData[M28Map.refiRadarCoverage]..'; Map size='..M28Map.iMapSize..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; tLZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
    if not(bHaveLowMass) and not(bWantMorePower) and tLZTeamData[M28Map.refiRadarCoverage] < 100 and M28Map.iMapSize > 512 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 18 or M28Map.bIsCampaignMap) and (tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][2] >= 2 or tLZTeamData[M28Map.subrefLZSValue] >= 1750) then
        --Check we dont have any radar here already (redundancy for radar coverage)
        local tExistingRadar = EntityCategoryFilterDown(M28UnitInfo.refCategoryRadar, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local bHaveRadar = false
        if M28Utilities.IsTableEmpty(tExistingRadar) == false then
            for iUnit, oUnit in tExistingRadar do
                if oUnit:GetFractionComplete() >= 1 then
                    bHaveRadar = true
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveRadar='..tostring(bHaveRadar)) end
        if not(bHaveRadar) then
            --Are we able to build radar? assume we can if we have access to T3 factories for simplicity
            if not(M28Map.bIsCampaignMap) or not(M28Overseer.bUnitRestrictionsArePresent) or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then
                HaveActionToAssign(refActionBuildT2Radar, 2, 10)
            end
        end
    end

    --Low priority air staging builder (max of 1) for expansion bases
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefLZCoreExpansion] and not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastAirStagingShortage] or -100) <= 2 and tLZTeamData[M28Map.subrefLZSValue] >= 400 and not(bHaveLowMass) and not(bHaveLowPower) then
        local bHaveAirStaging = false
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            local tAirStaging = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirStaging, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tAirStaging) == false then
                for iUnit, oUnit in tAirStaging do
                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then bHaveAirStaging = true break end
                end
            end
        end
        if not(bHaveAirStaging) then
            HaveActionToAssign(refActionBuildAirStaging, 1, 10)
            if bDebugMessages == true then LOG(sFunctionRef..': Low priority air staging builder') end
        end
    end


    --If still have an engineer available and there is reclaim in the LZ of any kind, and we arent overflowing, then reclaim
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.8 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] > 0.95 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] < 0.9) then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if bDebugMessages == true then LOG(sFunctionRef..': Very low priority reclaimer if have available engineers; iHighestTechEngiAvailable='..iHighestTechEngiAvailable) end
        if iHighestTechEngiAvailable > 0 then
            if tLZData[M28Map.subrefTotalMassReclaim] >= 5 then
                if bDebugMessages == true then LOG(sFunctionRef..': Lower priority reclaim, Total mass in Plateau '..iPlateau..' LZ '..iLandZone..'='..tLZData[M28Map.subrefTotalMassReclaim]..'; will request at least 100 BP, but wont request more than we already have') end
                HaveActionToAssign(refActionReclaimArea, 1, 100, false, true)
            end
        end
    end

    --Check for any part constructed buildings in this zone if we either have available engineers, or no engineers at all
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if M28Utilities.IsTableEmpty(tEngineers) or iHighestTechEngiAvailable > 0 then
        local tBuildings = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tBuildings) == false then
            for iUnit, oUnit in tBuildings do
                --Dont assist part complete shields as may be for special shielding logic
                if oUnit:GetFractionComplete() < 1 and not(oUnit[refbDontIncludeAsPartCompleteBuildingForConstruction]) then
                    HaveActionToAssign(refActionRepairUnit, 1, 5, oUnit)
                    break
                end
            end
        end
    end

    UpdateSpareEngineerNumber(tLZTeamData, toAvailableEngineersByTech)

    --Spare engi - assist any upgrading unit
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then
        if not(bHaveLowPower) then
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of active upgrades empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]))..'; have spare engis so will send any spare to assist any active upgrades') end
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then
                HaveActionToAssign(refActionAssistUpgrade, 1, 1000, false, true, nil, nil, nil, true)
                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
            end
        end

        --Spare engi - assist part complete buildings
        iCurPriority = iCurPriority + 1
        if iHighestTechEngiAvailable > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': Have a spare engi, will look to see to see if htere are any part complete buildings in the area') end
            local tFriendlyBuildings = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tFriendlyBuildings) == false then
                local oUnitToAssist
                local iClosestToCompletion = 0
                for iUnit, oUnit in tFriendlyBuildings do
                    if oUnit:GetFractionComplete() < 1 and oUnit:GetFractionComplete() > iClosestToCompletion then
                        iClosestToCompletion = oUnit:GetFractionComplete()
                        oUnitToAssist = oUnit
                    end
                end
                if oUnitToAssist then
                    HaveActionToAssign(refActionRepairUnit, 1, 1000, oUnitToAssist, true, nil, nil, nil, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Will try assisting unit '..oUnitToAssist.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToAssist)) end
                end
            end


            --Low priority island support (for any spare engineers) - will consider further away distances tahn before, up to a distance of 400, and only if the island wants T1 engineer BP
            if iHighestTechEngiAvailable > 0 and (iIslandDistanceThreshold or 0) > 0 and iIslandDistanceThreshold <= 400 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                if iHighestTechEngiAvailable > 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': is pathing to other islands empty='..tostring( M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]))) end
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; tLZTeamData[M28Map.reftClosestEnemyBase]='..repru(tLZTeamData[M28Map.reftClosestEnemyBase])..'; tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint])) end

                        if bDebugMessages == true then LOG(sFunctionRef..': Will search for islands, iIslandDistanceThreshold='..iIslandDistanceThreshold) end

                        for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering island '..tPathingData[M28Map.subrefIslandNumber]..' for lower priority travel; travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; Closest LZ ref='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; are enemies in this or adjacent LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                            if tPathingData[M28Map.subrefIslandTravelDist] > iIslandDistanceThreshold then --Have already considered islands with a shorter travel distance above
                                if tPathingData[M28Map.subrefIslandTravelDist] > 400 then break --Too far to try and travel by engineer
                                else
                                    --Are there enemies in the target LZ?
                                    if tPathingData[M28Map.subrefIslandClosestLZRef] and not(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                                        local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, tPathingData[M28Map.subrefIslandClosestLZRef], iEntry, iHighestTechEngiAvailable, false, true)
                                        if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                                        if (tiBPByTechWanted[1] or 0) > 0 then
                                            HaveActionToAssign(refActionMoveToLandZone, 1, 5, tPathingData[M28Map.subrefIslandClosestLZRef], true) --wont flag as 'spare' since only assigning a small amount of BP
                                            if bDebugMessages == true then LOG(sFunctionRef..': Finished trying to give order for engi to move to the island LZ '..tPathingData[M28Map.subrefIslandClosestLZRef]) end
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end

            --Spare engi action - go to any nearby land or water zone that wants BP
            iCurPriority = iCurPriority + 1

            if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; If have available engis then will look for other zones wanting them, time='..GetGameTimeSeconds()..'; Is table of other land and water zones by distance empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]))) end
            if iHighestTechEngiAvailable > 0 then
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through all other land and water zones, reprs='..reprs(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance])) end
                    for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to travel to zone '..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..'; Distance='..tSubtable[M28Map.subrefiDistance]) end
                        if tSubtable[M28Map.subrefiDistance] <= 500 then
                            local tAdjLZOrWZData, tAdjLZOrWZTeamData
                            if tSubtable[M28Map.subrefbIsWaterZone] then
                                tAdjLZOrWZData =M28Map.tPondDetails[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                tAdjLZOrWZTeamData = tAdjLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                            else
                                tAdjLZOrWZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                tAdjLZOrWZTeamData = tAdjLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering zone '..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..'; Wnats BP='..tostring(tAdjLZOrWZTeamData[M28Map.subrefTbWantBP])..'; In playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAdjLZOrWZData[M28Map.subrefMidpoint]))) end
                            if tAdjLZOrWZTeamData[M28Map.subrefTbWantBP] and NavUtils.GetLabel(M28Map.refPathingTypeHover, tAdjLZOrWZData[M28Map.subrefMidpoint]) == iPlateau and (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZOrWZData[M28Map.subrefMidpoint])) then
                                local iCurBPWanted = 0
                                local iMinTechWanted = 3
                                for iTech, iBP in tAdjLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted] do
                                    iMinTechWanted = math.min(iMinTechWanted, iTech)
                                    iCurBPWanted = iCurBPWanted + iBP
                                end
                                if iCurBPWanted > 0 and iHighestTechEngiAvailable >= iMinTechWanted then
                                    if tSubtable[M28Map.subrefbIsWaterZone] then
                                        --HaveActionToAssign(iActionToAssign,   iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable,                      bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
                                        HaveActionToAssign(refActionMoveToWaterZone, iMinTechWanted, iCurBPWanted,      tSubtable[M28Map.subrefiLandOrWaterZoneRef],true, true,nil,nil, false) --Dont treat it as spare action, or else it gets orders overwritten and can end up in a loop where it moves to another zone and that zone sends it back home
                                    else
                                        HaveActionToAssign(refActionMoveToLandZone, iMinTechWanted, iCurBPWanted, tSubtable[M28Map.subrefiLandOrWaterZoneRef], true, true,                    nil,                            nil,            false) --Dont treat it as spare action, or else it gets orders overwritten and can end up in a loop where it moves to another zone and that zone sends it back home
                                    end
                                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                    if iHighestTechEngiAvailable == 0 then break end
                                end
                            end
                        end
                    end
                else
                    M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint])
                end

                --Adjacent core zones if we have spare engis in this zone

                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                if iHighestTechEngiAvailable > 0 then
                    local iTotalAvailableEngineerBP = 0
                    for iTech, tEngineers in toAvailableEngineersByTech do
                        if M28Utilities.IsTableEmpty(tEngineers) == false then
                            iTotalAvailableEngineerBP = iTotalAvailableEngineerBP + tiBPByTech[iTech] * table.getn(tEngineers)
                        end
                    end
                    if iTotalAvailableEngineerBP >= 80 then
                        local iBPToSend = iTotalAvailableEngineerBP - 80
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]) then
                                    local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                                    if tAdjLZTeamData[M28Map.subrefLZbCoreBase] or tAdjLZTeamData[M28Map.subrefTbWantBP] then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Minor zone spare engi overflow - will send to adjacent zone '..iAdjLZ..'; iPlateau='..iPlateau..'; iBPToSend='..iBPToSend) end
                                        HaveActionToAssign(refActionMoveToLandZone, 1, iBPToSend, iAdjLZ, true, nil, nil, nil, true)
                                        break
                                    end
                                end
                            end
                        end
                    end
                end

            end
        end
    end


    --Do we have stuff to reclaim in this LZ and arent about to overflow mass? Decided to leave this out as looks like it can do more harm than good
    --[[iCurPriority = iCurPriority + 1
iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
if iHighestTechEngiAvailable > 0 and tLZData[M28Map.subrefTotalMassReclaim] >= 5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.6 then
HaveActionToAssign(refActionReclaimArea, 1, math.min(100, math.max(10, tLZData[M28Map.subrefTotalMassReclaim] / 10)), false, true)
end--]]




    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function ConsiderWaterZoneEngineerAssignment(tWZTeamData, iTeam, iPond, iWaterZone, tEngineers)
    --Called from ConsiderLandOrWaterZoneEngineerAssignment
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderWaterZoneEngineerAssignment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iBPWanted
    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
    local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)
    local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
    local iHighestTechEngiAvailable
    local iExistingWaterFactory = 0
    local bDontCheckPlayableArea = false
    if M28Map.bIsCampaignMap then
        bDontCheckPlayableArea = true
        if M28Team.tTeamData[iTeam][M28Team.rebTeamOnlyHasCampaignAI] then bDontCheckPlayableArea = false end
    end
    if tWZTeamData[M28Map.subrefWZbCoreBase] then
        local tExistingWaterFactory = EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tExistingWaterFactory) == false then
            for iFactory, oFactory in tExistingWaterFactory do
                if oFactory:GetFractionComplete() == 1 then iExistingWaterFactory = iExistingWaterFactory + 1 end
            end
        end
    end


    local toAvailableEngineersByTech, toAssignedEngineers = FilterToAvailableEngineersByTech(tEngineers, false, tWZData, tWZTeamData, iTeam, iPond, iWaterZone, true)
    tWZTeamData[M28Map.subrefTBuildPowerByTechWanted] = { [1] = 0, [2] = 0, [3] = 0 }
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Time=' .. GetGameTimeSeconds() .. '; iPond=' .. iPond .. '; iWaterZone=' .. iWaterZone .. '; tWZTeamData[M28Map.subrefWZbCoreBase]=' .. tostring(tWZTeamData[M28Map.subrefWZbCoreBase] or false) .. '; iExistingWaterFactory=' .. (iExistingWaterFactory or 'nil') .. '; Have just reset BPByTech to 0 for Pond' .. iPond .. '; WZ=' .. iWaterZone .. '; repru=' .. repru(tWZTeamData[M28Map.subrefTBuildPowerByTechWanted]) .. '; bHaveLowMass=' .. tostring(bHaveLowMass or false) .. '; bHaveLowPower=' .. tostring(bHaveLowPower or false))
    end
    --local iCurCondition = 0
    local iCurPriority = 0

    function HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
        --Done as subfunction for convenience so can just note the key values for the action in question and add on the others that wont change
        ConsiderActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iCurPriority, tWZData, tWZTeamData, iTeam, iPond, iWaterZone, toAvailableEngineersByTech, toAssignedEngineers, true, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
    end

    --High priority hydro if we have low energy and water zone start
    iCurPriority = iCurPriority + 1
    if tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] and M28Utilities.IsTableEmpty(tWZData[M28Map.subrefHydroUnbuiltLocations]) == false then
        iBPWanted = 5
        if bHaveLowPower or not (bHaveLowMass) then
            iBPWanted = 10
            if table.getn(tWZData[M28Map.subrefHydroUnbuiltLocations]) >= 2 then
                iBPWanted = 15
            end
        end
        HaveActionToAssign(refActionBuildHydro, 1, iBPWanted)
    end

    --High priority AA if we have a naval factory
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': High priority AA builder, iExistingWaterFactory='..iExistingWaterFactory..'; Enemy air to ground threat='..(tWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0)) end
    if iExistingWaterFactory > 0 and (tWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) > (tWZTeamData[M28Map.subrefWZThreatAlliedAA] or 0) * 0.4 then
        iBPWanted = 25
        if not (bHaveLowMass) and not (bHaveLowPower) then
            iBPWanted = 50
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Will try and build AA for water zone') end
        HaveActionToAssign(refActionBuildAA, math.max(1, (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] or 1)), iBPWanted)
    end

    --Higih priority mex if we have water zone start
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]) == false and tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': We want to build a mex asap as we have unbuilt locations and have started in water')
        end
        HaveActionToAssign(refActionBuildMex, 1, math.max(5, table.getn(tWZData[M28Map.subrefMexUnbuiltLocations]) * 2.5))
    end


    --Naval fac if this is a core WZ and we dont have any, with eco condition
    iCurPriority = iCurPriority + 1
    --Commented out as need logic for identifying build locations first
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': About to see if we want to build a naval factory, is this a core WZ base=' .. tostring(tWZTeamData[M28Map.subrefWZbCoreBase]) .. '; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; First M28 lifetime factory highest build count='..M28Team.GetFirstActiveM28Brain(iTeam)[M28Factory.refiHighestFactoryBuildCount])
    end
    if (tWZTeamData[M28Map.subrefWZbCoreBase] and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 4 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or M28Map.bIsCampaignMap and ((not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2.5) or M28Team.GetFirstActiveM28Brain(iTeam)[M28Factory.refiHighestFactoryBuildCount] >= 30))) or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
        --Is this a priority pond for our team to expand to?
        if bDebugMessages == true then LOG(sFunctionRef..': M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]]='..(M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]] or 'nil')) end
        if (M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]] or 0) > 0 or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
            local iFactoriesWanted = 1
            --if bHaveLowMass then iFactoriesWanted = math.max(1, iFactoriesWanted * 0.5) end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': iFactoriesWanted=' .. iFactoriesWanted .. '; iExistingWaterFactory=' .. iExistingWaterFactory)
            end
            if iExistingWaterFactory < iFactoriesWanted then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': We want to build a naval factory')
                end
                HaveActionToAssign(refActionBuildNavalFactory, 1, 30, nil)
            end
        end
    end

    if bDebugMessages == true then
        LOG(sFunctionRef .. ': About to consider what actions we want to give engineers for iPond=' .. iPond .. '; iWaterZone=' .. iWaterZone .. '; iTeam=' .. iTeam .. '; Is table of unbuilt mex locations empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations])) .. '; Is table of part complete mexes empty=' .. tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoPartBuiltMexes])))
    end

    --Emergency AA (slightly lower priority than above)
    iCurPriority = iCurPriority + 1
    if (tWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) > (tWZTeamData[M28Map.subrefWZThreatAlliedAA] or 0) * 0.25 and (tWZTeamData[M28Map.subrefWZbCoreBase] or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) then
        iBPWanted = 25
        if not (bHaveLowMass) and not (bHaveLowPower) then
            iBPWanted = 50
        end
        HaveActionToAssign(refActionBuildAA, math.max(1, (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] or 1)), iBPWanted)
    end

    --Unclaimed mex in the zone
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering if unbuilt or part build mexes in t his WZ ' .. iWaterZone .. ', is subrefMexUnbuiltLocations empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations])) .. '; Is subreftoPartBuiltMexes empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subreftoPartBuiltMexes])) .. '; Is table of mex locations empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZMexLocations])) .. '; Enemy combat threat=' .. tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal])
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]) == false then
            LOG(sFunctionRef .. ': Size of unbuilt locations table=' .. table.getn(tWZData[M28Map.subrefMexUnbuiltLocations]))
        end
    end
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]) == false then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': We want to build a mex as we have unbuilt locations')
        end
        HaveActionToAssign(refActionBuildMex, 1, math.max(5, table.getn(tWZData[M28Map.subrefMexUnbuiltLocations]) * 2.5))
    elseif M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
        --Do we have no engineers assigned to building a mex?
        local bHaveEngisBuilding = false
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Have part built mexes, is toAssignedEngineers empty=' .. tostring(M28Utilities.IsTableEmpty(toAssignedEngineers)))
        end
        if M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
            for iEngi, oEngi in toAssignedEngineers do
                if oEngi[refiAssignedAction] == refActionBuildMex then
                    bHaveEngisBuilding = true
                    break
                end
            end
        end
        if not (bHaveEngisBuilding) then
            --Refresh list of mexes
            RefreshPartBuiltMexList(tWZTeamData)
            if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
                HaveActionToAssign(refActionCompletePartBuiltMex, 1, 5)
            end
        end
    elseif M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZMexLocations]) == false then
        --Does the enemy have mexes in this WZ but doesnt have combat threat? If so then try and reclaim
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Checking if enemy has any mexes in this WZ, Is table of enemey units empty=' .. tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits])) .. '; Enemy combat threat=' .. tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal])
        end
        if tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 15 and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
            local tEnemyMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tWZTeamData[M28Map.subrefTEnemyUnits])
            if bDebugMessages == true then
                LOG(sFunctionRef .. 'Is table of enemy mexes empty=' .. tostring(M28Utilities.IsTableEmpty(tEnemyMexes)))
            end
            if M28Utilities.IsTableEmpty(tEnemyMexes) == false then
                HaveActionToAssign(refActionReclaimEnemyUnit, 1, 5, tEnemyMexes)
            end
        end
    end


    --Lower priority mass reclaim where will request engineers to reclaim
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.35 and tWZData[M28Map.subrefTotalMassReclaim] >= 5 then
        local iReclaimFactor = 75
        if GetGameTimeSeconds() <= 540 then
            iReclaimFactor = 125
        end
        iBPWanted = math.min(40, math.max(5, tWZData[M28Map.subrefTotalMassReclaim] / iReclaimFactor))
        if iBPWanted > 15 and GetGameTimeSeconds() <= 540 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 then
            iBPWanted = math.min(iBPWanted, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * 10)
        end
        if tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then
            iBPWanted = math.max(5, iBPWanted * 0.6)
        end

        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Lower priority reclaim, Total mass in Pond ' .. iPond .. ' WZ ' .. iWaterZone .. '=' .. tWZData[M28Map.subrefTotalMassReclaim])
        end
        HaveActionToAssign(refActionReclaimArea, 1, math.min(100, math.max(5, iBPWanted)), false, false)
    end

    --Unclaimed hydro
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefHydroUnbuiltLocations]) == false then
        iBPWanted = 10
        if table.getn(tWZData[M28Map.subrefHydroUnbuiltLocations]) >= 2 then
            iBPWanted = 20
        end
        HaveActionToAssign(refActionBuildHydro, 1, iBPWanted)
    end

    --Extra naval facs if need build power and dont have low mass and have positive net energy income
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': About to see if we want to build a naval factory, is this a core WZ base=' .. tostring(tWZTeamData[M28Map.subrefWZbCoreBase]) .. '; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] .. '; bHaveLowMass=' .. tostring(bHaveLowMass) .. '; bWantBP=' .. tostring(tWZTeamData[M28Map.subrefTbWantBP]))
    end
    if (not (bHaveLowMass) or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) and (not (bHaveLowPower) or (tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > 1 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or -100) >= 10)) and ((tWZTeamData[M28Map.subrefWZbCoreBase] and (tWZTeamData[M28Map.subrefTbWantBP] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 10000 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.8) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 6 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) or (tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 4 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and (tWZTeamData[M28Map.subrefTbWantBP] or not (bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 12 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]))) then
        if (M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]] or 0) > 0 or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
            local iMaxFactories = 2
            if tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
                iMaxFactories = math.min(8, math.max(2, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / 2))
            end
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 100 then
                iMaxFactories = 3
            end

            --if bHaveLowMass then iFactoriesWanted = math.max(1, iFactoriesWanted * 0.5) end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': iMaxFactories=' .. iMaxFactories .. '; iExistingWaterFactory=' .. iExistingWaterFactory)
            end
            if iExistingWaterFactory < iMaxFactories then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Lower priority builder - We want to build a naval factory')
                end
                HaveActionToAssign(refActionBuildNavalFactory, 1, 30, nil)
            end
        end
    end

    --Build sonar if no nearby enemies and lack decent coverage and have decent eco
    iCurPriority = iCurPriority + 1
    --Coverage set at 100, as can have large water zones, with sonar built on edge, meaning T2 sonar doesnt even give 100 coverage of its own midpoint
    if tWZTeamData[M28Map.refiSonarCoverage] <= 100 and not (bHaveLowMass) and not (bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 and tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] == 0 and not (M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmni]) then
        local iGrossMassWanted = 6
        local iGrossEnergyWanted = 125
        iBPWanted = 15
        if not (tWZTeamData[M28Map.subrefWZbCoreBase]) then
            iGrossMassWanted = iGrossMassWanted * 2
            iGrossEnergyWanted = iGrossEnergyWanted * 2
        else
            iBPWanted = 40
        end
        if tWZTeamData[M28Map.refiSonarCoverage] == 0 then
            iGrossMassWanted = iGrossMassWanted * 0.8
            iGrossEnergyWanted = iGrossEnergyWanted * 0.8
            if M28Map.bIsCampaignMap and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 then
                iGrossMassWanted = iGrossMassWanted * 0.7
                iGrossEnergyWanted = iGrossEnergyWanted * 0.7
            end
        end
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= iGrossMassWanted and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= iGrossEnergyWanted then
            --Check we dont have any T2+ sonar in this WZ as sometimes water zones are so big that they dont get great coverage from sonar
            local tFriendlySonar
            if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                tFriendlySonar = EntityCategoryFilterDown(M28UnitInfo.refCategorySonar, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            end
            if M28Utilities.IsTableEmpty(tFriendlySonar) then
                --Build t1 sonar if enemy has enemies in adjacent WZ or we have reached 400 gross mass income, T2 if no enemies in this or adjacent
                if not (tWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 40 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 750) then
                    HaveActionToAssign(refActionBuildT2Sonar, 2, iBPWanted, false, false)
                elseif tWZTeamData[M28Map.refiSonarCoverage] <= 10 then
                    HaveActionToAssign(refActionBuildT1Sonar, 1, 5, false, false)
                end
            end
        end
    end

    --Build mass storage if we have T2+ mexes
    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPToAssignToMassStorage(0, iWaterZone, iTeam, tWZData, tWZTeamData, false, bHaveLowMass, bHaveLowPower)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionBuildMassStorage, 1, iBPWanted)
    end

    --Experimental naval unit for very high mass levels (higher priority than naval fac assist so engis stop assisting naval fac and start building this)

    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Experimental navy builder - core base=' .. tostring(tWZTeamData[M28Map.subrefWZbCoreBase]) .. '; bHaveLowMass=' .. tostring(bHaveLowMass) .. '; Low power=' .. tostring(bHaveLowPower) .. '; Mass%=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] .. '; Gross mass=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] .. '; Net mass=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] .. '; Naval tehc=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] .. '; Enemies in adjacent QZ=' .. tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) .. '; Ally combat total=' .. tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal])
    end
    if tWZTeamData[M28Map.subrefWZbCoreBase] and not (bHaveLowMass) and not (bHaveLowPower) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1000 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 35 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 5 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > -1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 80)) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] >= 3 and (not (tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) or (tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= 8000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.7)))) then
        --Likely have the eco to get an experimental naval unit, check if we have a lifetime build count of at least 2 T3 naval units
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Think we have enough eco for experimental navy builder, lifetime battleship count=' .. M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryBattleship))
        end
        if M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryBattleship) >= 2 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1000 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.8 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 100) then
            --Cap experimentals to 2 if there are no enemy naval targets (increase cap if about to overflow mass)
            local iCurNavalExperimentals = 0
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    iCurNavalExperimentals = iCurNavalExperimentals + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryAllNavy * categories.EXPERIMENTAL)
                end
            end
            local iExperimentalsWanted = 4
            if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastNoSurfaceCombatTargetByPond][iPond] or -100) <= 30 then
                iExperimentalsWanted = 2
            end
            if iCurNavalExperimentals >= iExperimentalsWanted then
                local iCurLandExperimentals = 0
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        iCurLandExperimentals = iCurLandExperimentals + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandExperimental)
                    end
                end
                iExperimentalsWanted = math.max(iExperimentalsWanted, iCurLandExperimentals)
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': iCurLandExperimentals=' .. iCurLandExperimentals)
                end
            end
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.9 then
                iExperimentalsWanted = iExperimentalsWanted * 1.5
            end
            if iCurNavalExperimentals < iExperimentalsWanted then
                iBPWanted = 45
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1000 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.6 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 10) then
                    iBPWanted = 90
                end
                HaveActionToAssign(refActionBuildExperimentalNavy, 3, iBPWanted, false, false, true)
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Want experimental naval unit, iBPWanted=' .. iBPWanted)
                end
            elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1000 then
                HaveActionToAssign(refActionBuildLandExperimental, 3, 90)
            end
        end
    end

    --Send engineer to a land zone adjacent to this that wants support and lacks factories
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    local iLZSentTo = 0
    if bDebugMessages == true then LOG(sFunctionRef .. ': About to see if have adjacent land zones wanting engineers, iHighestTechEngiAvailable=' .. iHighestTechEngiAvailable..'; Is table of adjacent LZs empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]))) end
    if iHighestTechEngiAvailable > 0 then
        --Do we haev adjacent land zone wanting engineer?
        local iMinTechWanted        = 1
        local bWantBPOfOurTech
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
            for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                local iPlateau = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                local iLandZone = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]) then
                    local tLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent LZ '..(iLandZone or 'nil')..' on plateau '..(iPlateau or 'nil')..'; Does this LZ want BP='..tostring(tLZTeamData[M28Map.subrefTbWantBP])..'; Dangerous enemies in this LZ='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])..'; Allied untis in this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
                    if tLZTeamData[M28Map.subrefTbWantBP] and not (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) then
                        bWantBPOfOurTech = false
                        for iTech = iHighestTechEngiAvailable, 1, -1 do
                            if tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                bWantBPOfOurTech = true
                                iMinTechWanted = iTech
                            end
                        end
                        if bWantBPOfOurTech then
                            --For now to keep things simple will ignore minimum engineer tech requirements
                            iLZSentTo = iLZSentTo + 1
                            if bDebugMessages == true then LOG(sFunctionRef..': About to try and send engineers to iLandZOne '..(iLandZone or 'nil')..'; iPlateau='..(iPlateau or 'nil')) end
                            --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted,            vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted)
                            HaveActionToAssign(refActionMoveToLandZone, iMinTechWanted, 10 * 2 * iLZSentTo, {iPlateau, iLandZone}, true)
                            if bDebugMessages == true then LOG(sFunctionRef..': Have flagged we want to send BP of '..10 * 2 * iLZSentTo..' to land zone '..iLandZone) end
                        end
                    end
                end
            end
        end
    end


    --Send engineer to a water zone near this that wants support, or alternatively a land zone adjacent to that water zone that wants support
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': About to check if have adjacent water zones wanting engineers, iHighestTechEngiAvailable=' .. iHighestTechEngiAvailable)
    end
    if iHighestTechEngiAvailable > 0 then
        local bWantBPOfOurTech
        local iMinTechWanted       = 1
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
            for iEntry, tSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                local iAdjWZ = tSubtable[M28Map.subrefWZAWZRef]
                local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAltWZData[M28Map.subrefMidpoint]) then
                    local tAltWZTeamData = tAltWZData[M28Map.subrefWZTeamData][iTeam]
                    local bWZOrAdjacentLZWantsEngineers
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Considering iAdjWZ=' .. iAdjWZ .. '; tAltWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]=' .. tostring(tAltWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] or false) .. '; tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]=' .. (tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0) .. '; tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. (tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) .. '; tAltWZTeamData[M28Map.subrefTbWantBP]=' .. tostring(tAltWZTeamData[M28Map.subrefTbWantBP]) .. '; WZ table of unclaimed mexes is empty=' .. tostring(M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefMexUnbuiltLocations])) .. '; WZ table of unbuilt hydro is empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefHydroUnbuiltLocations]))..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subrefTEnemyUnits])))
                    end
                    if (not (tAltWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) or (tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= math.min(6000, math.max(100, tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 0.75)) or (tAltWZTeamData[M28Map.subrefWZbCoreBase] and M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subrefTEnemyUnits]) and M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.reftLZEnemyAirUnits]) and (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20)))) then
                        --WZ is safe to go to, does the WZ want engineers and/or does it have an adjacent LZ that wants engineers?
                        bWZOrAdjacentLZWantsEngineers = tAltWZTeamData[M28Map.subrefTbWantBP]
                        bWantBPOfOurTech = false
                        if bWZOrAdjacentLZWantsEngineers then
                            for iTech = iHighestTechEngiAvailable, 1, -1 do
                                if tAltWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                    bWantBPOfOurTech = true
                                    iMinTechWanted = iTech
                                end
                            end
                        end

                        if not (bWantBPOfOurTech) and M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefAdjacentLandZones]) == false then

                            for iEntry, tSubtable in tAltWZData[M28Map.subrefAdjacentLandZones] do
                                local iPlateau = tSubtable[1]
                                local iLandZone = tSubtable[2]
                                local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                                if tLZTeamData[M28Map.subrefTbWantBP] and not (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) then
                                    bWantBPOfOurTech = false
                                    for iTech = iHighestTechEngiAvailable, 1, -1 do
                                        if tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                            bWantBPOfOurTech = true
                                            iMinTechWanted = iTech
                                        end
                                    end
                                    if bWantBPOfOurTech then
                                        bWZOrAdjacentLZWantsEngineers = true
                                        break
                                    end
                                end
                            end
                        end
                        if bWZOrAdjacentLZWantsEngineers then
                            iLZSentTo = iLZSentTo + 1
                            HaveActionToAssign(refActionMoveToWaterZone, iMinTechWanted, 10 * 2 * iLZSentTo, iAdjWZ, true)
                            if iLZSentTo >= 4 then break end
                        end
                    end
                end
            end
        end
    end

    --Naval fac if this is a core WZ and we dont have any, but have engineers available, or we have lots of mass stored
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then
        if tWZTeamData[M28Map.subrefWZbCoreBase] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 4 then
            if (M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]] or 0) > 0 or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
                local iFactoriesWanted = 1
                if not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 then
                    iFactoriesWanted = 2
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.7 then iFactoriesWanted = 3 end
                end
                --if bHaveLowMass then iFactoriesWanted = math.max(1, iFactoriesWanted * 0.5) end
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': iFactoriesWanted=' .. iFactoriesWanted .. '; iExistingWaterFactory=' .. iExistingWaterFactory)
                end
                if iExistingWaterFactory < iFactoriesWanted then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Later naval fac builder We want to build a naval factory')
                    end
                    HaveActionToAssign(refActionBuildNavalFactory, 1, 30, nil)
                end
            end
        end
    end

    --Assist naval factory based on average mass income of team
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to assist naval fac, core base='..tostring(tWZTeamData[M28Map.subrefWZbCoreBase])..'; iExistingWaterFactory='..iExistingWaterFactory..'; Is table of naval factories empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))) end
    if tWZTeamData[M28Map.subrefWZbCoreBase] and iExistingWaterFactory > 0 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false then
        --e.g. 1 BP building a frigate uses 0.2 mass per second, or 0.02 mass per tick; if want 40% of team mass income spent on navy, then want to assign 20 BP per 1 mass per tick (i.e. 20 BP per 10 mass per sec)
        iBPWanted = math.min(1000, (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) * 20)
        if not (bHaveLowMass) and not (bHaveLowPower) then
            iBPWanted = iBPWanted * 1.5
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 then iBPWanted = iBPWanted * 1.5 end
        elseif bHaveLowMass and M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] then
            iBPWanted = iBPWanted * 0.7
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Want to assist naval fac, iBPWanted='..iBPWanted) end
        HaveActionToAssign(refActionAssistNavalFactory, 1, iBPWanted, false, false)
    end

    --If already have 1 naval fac build another if high mass
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': More naval fac if already have some and have lots of mass stored, iCurPrioriyt='..iCurPriority..'; iExistingWaterFactory='..iExistingWaterFactory..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; Time since last had nothing to build='..GetGameTimeSeconds() - (tWZTeamData[M28Map.subrefiTimeNavalFacHadNothingToBuild] or -100)..'; Have low power='..tostring(bHaveLowPower)) end
    if iExistingWaterFactory > 0 and iExistingWaterFactory < 4 and  M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 and not(bHaveLowPower) and GetGameTimeSeconds() - (tWZTeamData[M28Map.subrefiTimeNavalFacHadNothingToBuild] or -100) >= 30 then
        iBPWanted = 15 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech]
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.8 then iBPWanted = iBPWanted * 1.5 end
        if bDebugMessages == true then LOG(sFunctionRef..': Want to assign BP to build a naval fac, iBPWanted='..iBPWanted) end
        HaveActionToAssign(refActionBuildNavalFactory, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech], iBPWanted, nil)
    end

    --Preemptive AA builder if we are at T3 and have decent mass income, and have friendly units in the WZ or intel coverage, and no enemy units
    iCurPriority = iCurPriority + 1
    if not (bHaveLowMass) and not (bHaveLowPower) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] or 1) >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 then
        --Build AA if we have <1.5k AA threat
        local iAAThreatWanted = 1500
        if tWZTeamData[M28Map.subrefWZbCoreBase] or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
            iAAThreatWanted = 3000
        end
        if tWZTeamData[M28Map.subrefWZThreatAlliedAA] < iAAThreatWanted then
            if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) and ((tWZTeamData[M28Map.refiSonarCoverage] or 0) > 20 or M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false) then
                iBPWanted = 50
                if tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then
                    iBPWanted = 25
                end
                HaveActionToAssign(refActionBuildAA, 3, iBPWanted)
            end
        end
    end

    --Build land experimentals in water if v.high mass
    iCurPriority = iCurPriority + 1
    if not (bHaveLowMass) and not (bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.8 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] or 1) >= 3 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 40 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.9 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20)) then
        local iT3AndExperimentalNavy = 0
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                iT3AndExperimentalNavy = iT3AndExperimentalNavy + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryAllNavy * categories.EXPERIMENTAL + M28UnitInfo.refCategoryAllNavy * categories.TECH3)
            end
        end
        if iT3AndExperimentalNavy >= 4 then
            iBPWanted = 45
            HaveActionToAssign(refActionBuildLandExperimental, 3, iBPWanted, false, false, true)
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Want experimental naval unit, iBPWanted=' .. iBPWanted)
            end
        end
    end

    --Units to capture
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subreftoUnitsToCapture]) == false then
        --Refresh the list
        local iCaptureCount = table.getn(tWZData[M28Map.subreftoUnitsToCapture])
        for iCurCount = iCaptureCount, 1, -1 do
            if not (M28UnitInfo.IsUnitValid(tWZData[M28Map.subreftoUnitsToCapture][iCurCount])) then
                table.remove(tWZData[M28Map.subreftoUnitsToCapture], iCurCount)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finishedupdating if have units to capture for zone, after freshing them is table empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subreftoUnitsToCapture]))) end
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subreftoUnitsToCapture]) == false then
            local oUnitToCapture
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 75 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                local tPotentialCapture = EntityCategoryFilterDown(categories.ALLUNITS - M28UnitInfo.refCategoryT3Power, tWZData[M28Map.subreftoUnitsToCapture])
                if M28Utilities.IsTableEmpty(tPotentialCapture) == false then
                    oUnitToCapture = M28Utilities.GetNearestUnit(tPotentialCapture, tWZData[M28Map.subrefMidpoint])
                end
            else
                oUnitToCapture = M28Utilities.GetNearestUnit(tWZData[M28Map.subreftoUnitsToCapture], tWZData[M28Map.subrefMidpoint])
            end
            if oUnitToCapture then
                if bDebugMessages == true then LOG(sFunctionRef..': Unit to cpature='..oUnitToCapture.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToCapture)) end
                iBPWanted = GetCaptureBPWanted(oUnitToCapture, bHaveLowPower, iTeam, tWZTeamData[M28Map.subrefLZbCoreBase])
                HaveActionToAssign(refActionCaptureUnit, 1, iBPWanted, oUnitToCapture)
            end
        end
    end

    --Units to repair
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subreftoUnitsToRepair]) == false then
        --Refresh the list
        local iUnitCount = table.getn(tWZData[M28Map.subreftoUnitsToRepair])
        for iCurCount = iUnitCount, 1, -1 do
            if not(M28UnitInfo.IsUnitValid(tWZData[M28Map.subreftoUnitsToRepair][iCurCount])) then
                table.remove(tWZData[M28Map.subreftoUnitsToRepair], iCurCount)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Have units to repair for water zone '..iWaterZone..' after freshing them is table empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subreftoUnitsToRepair]))) end
        if M28Conditions.IsTableOfUnitsStillValid(tLZData[M28Map.subreftoUnitsToRepair], true) then
            local oUnitToTarget = M28Utilities.GetNearestUnit(tWZData[M28Map.subreftoUnitsToRepair], tWZData[M28Map.subrefMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': Unit to repair='..oUnitToTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToTarget)) end
            HaveActionToAssign(refActionRepairUnit, 1, 5, oUnitToTarget)
        end
    end

    --Under construction unit
    iCurPriority = iCurPriority + 1
    if iHighestTechEngiAvailable > 0 then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if iHighestTechEngiAvailable > 0 then
            local tBuildingsInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tBuildingsInZone) == false then
                for iUnit, oUnit in tBuildingsInZone do
                    if oUnit:GetFractionComplete() < 1 then
                        HaveActionToAssign(refActionRepairUnit, 1, 5, oUnit)
                        break
                    end
                end
            end
        end
    end

    --Lower priority sending engineeres to other land and water zones
    --Send engineer to a land zone adjacent to this that wants support and lacks factories
    iCurPriority = iCurPriority + 1
    if iHighestTechEngiAvailable > 0 then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if bDebugMessages == true then LOG(sFunctionRef .. ': Lower priority About to see if have adjacent land zones wanting engineers, iHighestTechEngiAvailable=' .. iHighestTechEngiAvailable..'; Is table of adjacent LZs empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]))) end
        if iHighestTechEngiAvailable > 0 then
            --Do we haev adjacent land zone wanting engineer?
            local bWantBPOfOurTech
            local iMinTechWanted = 1

            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
                for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                    local iPlateau = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                    local iLandZone = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                    if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then
                        local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent LZ '..(iLandZone or 'nil')..' on plateau '..(iPlateau or 'nil')..'; Does this LZ want BP='..tostring(tLZTeamData[M28Map.subrefTbWantBP])..'; Dangerous enemies in this LZ='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])..'; Allied untis in this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
                        if tLZTeamData[M28Map.subrefTbWantBP] and not (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) then
                            bWantBPOfOurTech = false
                            for iTech = iHighestTechEngiAvailable, 1, -1 do
                                if tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                    bWantBPOfOurTech = true
                                    iMinTechWanted = iTech
                                end
                            end
                            if bWantBPOfOurTech then
                                --For now to keep things simple will ignore minimum engineer tech requirements
                                iLZSentTo = iLZSentTo + 1
                                if bDebugMessages == true then LOG(sFunctionRef..': About to try and send engineers to iLandZOne '..(iLandZone or 'nil')..'; iPlateau='..(iPlateau or 'nil')) end
                                --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted,            vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted)
                                HaveActionToAssign(refActionMoveToLandZone, iMinTechWanted, 10 * 2 * iLZSentTo, {iPlateau, iLandZone}, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': Have flagged we want to send BP of '..10 * 2 * iLZSentTo..' to land zone '..iLandZone) end
                            end
                        end
                    end
                end
            end
        end
    end


    --Send engineer to a water zone near this that wants support, or alternatively a land zone adjacent to that water zone that wants support
    iCurPriority = iCurPriority + 1
    if iHighestTechEngiAvailable > 0 then

        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Lower priority About to check if have adjacent water zones wanting engineers, iHighestTechEngiAvailable=' .. iHighestTechEngiAvailable)
        end
        if iHighestTechEngiAvailable > 0 then
            local bWantBPOfOurTech
            local iMinTechWanted = 1
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                for iEntry, tSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                    local iAdjWZ = tSubtable[M28Map.subrefWZAWZRef]
                    local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
                    if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAltWZData[M28Map.subrefMidpoint]) then
                        local tAltWZTeamData = tAltWZData[M28Map.subrefWZTeamData][iTeam]
                        local bWZOrAdjacentLZWantsEngineers
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Considering iAdjWZ=' .. iAdjWZ .. '; tAltWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]=' .. tostring(tAltWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] or false) .. '; tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]=' .. (tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0) .. '; tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. (tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) .. '; tAltWZTeamData[M28Map.subrefTbWantBP]=' .. tostring(tAltWZTeamData[M28Map.subrefTbWantBP]) .. '; WZ table of unclaimed mexes is empty=' .. tostring(M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefMexUnbuiltLocations])) .. '; WZ table of unbuilt hydro is empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefHydroUnbuiltLocations]))..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subrefTEnemyUnits])))
                        end
                        if (not (tAltWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) or (tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= math.min(6000, math.max(100, tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 0.75)) or (tAltWZTeamData[M28Map.subrefWZbCoreBase] and M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subrefTEnemyUnits]) and M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.reftLZEnemyAirUnits]) and (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20)))) then
                            --WZ is safe to go to, does the WZ want engineers and/or does it have an adjacent LZ that wants engineers?
                            bWZOrAdjacentLZWantsEngineers = tAltWZTeamData[M28Map.subrefTbWantBP]
                            bWantBPOfOurTech = false
                            if bWZOrAdjacentLZWantsEngineers then

                                for iTech = iHighestTechEngiAvailable, 1, -1 do
                                    if tAltWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                        bWantBPOfOurTech = true
                                        iMinTechWanted = iTech
                                    end
                                end
                            end
                            if not (bWantBPOfOurTech) and M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefAdjacentLandZones]) == false then

                                for iEntry, tSubtable in tAltWZData[M28Map.subrefAdjacentLandZones] do
                                    local iPlateau = tSubtable[1]
                                    local iLandZone = tSubtable[2]
                                    local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                                    if tLZTeamData[M28Map.subrefTbWantBP] and not (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) then
                                        bWantBPOfOurTech = false
                                        for iTech = iHighestTechEngiAvailable, 1, -1 do
                                            if tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                                bWantBPOfOurTech = true
                                                iMinTechWanted = iTech
                                            end
                                        end
                                        if bWantBPOfOurTech then
                                            bWZOrAdjacentLZWantsEngineers = true
                                            break
                                        end
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of adj land zones empty='..tostring(M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefAdjacentLandZones]))..'; bWantBPOfOurTech='..tostring(bWantBPOfOurTech)..'; bWZOrAdjacentLZWantsEngineers='..tostring(bWZOrAdjacentLZWantsEngineers)) end
                            if bWZOrAdjacentLZWantsEngineers and bWantBPOfOurTech then
                                iLZSentTo = iLZSentTo + 1
                                HaveActionToAssign(refActionMoveToWaterZone, iMinTechWanted, 10 * 2 * iLZSentTo, iAdjWZ, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': Assigned engineers to move to water zone, Total of iLZSentTo='..iLZSentTo..'; iAdjWZ='..iAdjLZ) end
                                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                if iLZSentTo >= 4 or iHighestTechEngiAvailable == 0 then break end
                            end
                        end
                    end
                end
            end
        end
    end


    UpdateSpareEngineerNumber(tWZTeamData, toAvailableEngineersByTech)

    --spare engis - If still have an engineer available and there is reclaim in the WZ of any kind, and we arent overflowing, then reclaim (but dont request engineers for this)
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then
        iCurPriority = iCurPriority + 1
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.8 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] < 0.9 then
            iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': iCurPriority=' .. iCurPriority .. '; considering if want to reclaim in the WZ, iHighestTechEngiAvailable=' .. iHighestTechEngiAvailable .. '; tWZData[M28Map.subrefTotalMassReclaim]=' .. (tWZData[M28Map.subrefTotalMassReclaim] or 0))
            end
            if iHighestTechEngiAvailable > 0 then
                if tWZData[M28Map.subrefTotalMassReclaim] >= 5 then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Will tell engineer to get lower priority reclaim, Total mass in pond ' .. iPond .. ' WZ ' .. iWaterZone .. '=' .. tWZData[M28Map.subrefTotalMassReclaim])
                    end
                    HaveActionToAssign(refActionReclaimArea, 1, 100, false, true, nil, nil, nil, true)
                end
            end
        end
        --Spare engis - if have adjacent land zone wanting engineers, then send them here
        iCurPriority = iCurPriority + 1
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
            for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                local iBPWanted = 0
                local iMinTechWanted = 3
                local iPlateau = tSubtable[1]
                local iLandZone = tSubtable[2]
                local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then
                    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                    if tLZTeamData[M28Map.subrefTbWantBP] then
                        for iTech, iZoneBPWanted in tAltWZTeamData[M28Map.subrefTBuildPowerByTechWanted] do
                            iBPWanted = iBPWanted + iZoneBPWanted
                            iMinTechWanted = math.min(iZoneBPWanted, iTech)
                        end
                    end
                    if iBPWanted > 0 then
                        --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
                        HaveActionToAssign(refActionMoveToLandZone, iMinTechWanted, iBPWanted,      {iPlateau, iLandZone}, true,                    true,                       nil,                            nil,                                false) --Dont treat it as spare action, or else it gets orders overwritten and can end up in a loop where it moves to another zone and that zone sends it back home
                        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                        if iHighestTechEngiAvailable == 0 then break end
                    end
                end
            end
        end

        --Spare engis - if still have engi available, then send engineer to the closest land or water zone wanting more BP
        iCurPriority = iCurPriority + 1
        if iHighestTechEngiAvailable > 0 and M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
            for iEntry, tSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                local iAdjWZ = tSubtable[M28Map.subrefWZAWZRef]
                local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAltWZData[M28Map.subrefMidpoint]) then
                    local tAltWZTeamData = tAltWZData[M28Map.subrefWZTeamData][iTeam]
                    local iBPWanted = 0
                    local iMinTechWanted = 3
                    if tAltWZTeamData[M28Map.subrefTbWantBP] then
                        for iTech, iZoneBPWanted in tAltWZTeamData[M28Map.subrefTBuildPowerByTechWanted] do
                            iBPWanted = iBPWanted + iZoneBPWanted
                            iMinTechWanted = math.min(iZoneBPWanted, iTech)
                        end
                        if iBPWanted > 0 then
                            --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
                            HaveActionToAssign(refActionMoveToWaterZone, iMinTechWanted, iBPWanted,             iAdjWZ,         true,                   true,                       nil,                            nil,                                false) --Dont treat it as spare action, or else it gets orders overwritten and can end up in a loop where it moves to another zone and that zone sends it back home
                            iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                            if iHighestTechEngiAvailable == 0 then break end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefAdjacentLandZones]) == false then
                        for iEntry, tSubtable in tAltWZData[M28Map.subrefAdjacentLandZones] do
                            local iPlateau = tSubtable[1]
                            local iLandZone = tSubtable[2]
                            local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                            if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then
                                local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                                if tLZTeamData[M28Map.subrefTbWantBP] then
                                    for iTech, iZoneBPWanted in tAltWZTeamData[M28Map.subrefTBuildPowerByTechWanted] do
                                        iBPWanted = iBPWanted + iZoneBPWanted
                                        iMinTechWanted = math.min(iZoneBPWanted, iTech)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        --Spare engis - assist naval factory if dont ahve low mass
        iCurPriority = iCurPriority + 1
        if not (bHaveLowMass) and iExistingWaterFactory > 0 then
            --+5 BP a time assigned to naval factory
            HaveActionToAssign(refActionAssistNavalFactory, 1, 5, false, true, true, nil, nil, true)
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function ConsiderLandOrWaterZoneEngineerAssignment(tLZOrWZTeamData, iTeam, iPlateauOrPond, iLandOrWaterZone, tEngineers, bIsWaterZone)
    --tEngineers might be empty if e.g. we just want to record how much build power the land zone wants
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderLandOrWaterZoneEngineerAssignment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Start of code, iTeam=' .. iTeam .. '; iPlateauOrPond=' .. iPlateauOrPond .. '; iLandOrWaterZone=' .. iLandOrWaterZone .. '; is tEngineers empty=' .. tostring(M28Utilities.IsTableEmpty(tEngineers)) .. '; Is this a core base LZ=' .. tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or false) .. '; bIsWaterZone=' .. tostring(bIsWaterZone or false)..'; tLZOrWZTeamData[M28Map.subrefTbWantBP] before reset='..tostring(tLZOrWZTeamData[M28Map.subrefTbWantBP] or false)..'; iTeam='..iTeam)
    end

    --First clear any faction requests (will set to true again if we want to build something and dont have an engineer of the right faction for it)
    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted]) == false then
        for iFaction, bWantEngineers in tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted] do
            tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted][iFaction] = false
        end
    end
    --Clear tracking of engineers wanted by action
    tLZOrWZTeamData[M28Map.subreftiBPWantedByAction] = {}
    tLZOrWZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] = false

    if bIsWaterZone then
        ConsiderWaterZoneEngineerAssignment(tLZOrWZTeamData, iTeam, iPlateauOrPond, iLandOrWaterZone, tEngineers, bIsWaterZone)
    elseif tLZOrWZTeamData[M28Map.subrefLZbCoreBase] then
        ConsiderCoreBaseLandZoneEngineerAssignment(tLZOrWZTeamData, iTeam, iPlateauOrPond, iLandOrWaterZone, tEngineers)
    else
        --Not dealing with a core base
        ConsiderMinorLandZoneEngineerAssignment(tLZOrWZTeamData, iTeam, iPlateauOrPond, iLandOrWaterZone, tEngineers)
    end

    tLZOrWZTeamData[M28Map.subrefTbWantBP] = false --set to true later if any BP wanted
    --Reduce BP wanted by any engineers assigned to this LZ from another LZ
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Checking if engineers already assigned here, Is table of traveling engis empty=' .. tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere])) .. '; BP wanted pre update for traveling engis=' .. repru(tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted]))
    end
    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
        --Make sure the list of units traveling here is still accurate
        function KeepCurEntry(tArray, iEntry)
            if M28UnitInfo.IsUnitValid(tArray[iEntry]) then
                if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, tArray[iEntry].UnitId) then
                    if (tArray[iEntry][refiAssignedAction] == refActionRunToLandZone or tArray[iEntry][refiAssignedAction] == refActionMoveToLandZone) and tArray[iEntry][M28Land.reftiPlateauAndLZToMoveTo][2] == iLandOrWaterZone then
                        return true
                    elseif (tArray[iEntry][refiAssignedAction] == refActionMoveToWaterZone or tArray[iEntry][refiAssignedAction] == refActionRunToWaterZone) and tArray[iEntry][M28Navy.refiWZToMoveTo] == iLandOrWaterZone then
                        return true
                    else
                        return false

                    end
                else
                    --Not an engineer so dont remove from the table of traveling units as only concerned with removing engineers no longer assigned to do this
                    return true
                end
            else
                return false
            end
        end

        M28Utilities.RemoveEntriesFromArrayBasedOnCondition(tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere], KeepCurEntry)
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
            local tTravelingEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere])
            local iCurEngiTechLevel
            if M28Utilities.IsTableEmpty(tTravelingEngineers) == false then
                for iUnit, oUnit in tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere] do
                    --Refresh list of traveling engineers in case it is invalid

                    if M28UnitInfo.IsUnitValid(oUnit) then
                        --Is the engi still actually travelling here?
                        iCurEngiTechLevel = M28UnitInfo.GetUnitTechLevel(oUnit)
                        for iTech = iCurEngiTechLevel, 1, -1 do
                            if tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                --Dont ignore traveling engineers for fortify zone (so UEF M2 we still try doing a drop)
                                if iTech > 1 or not(M28Map.bIsCampaignMap) or not(tLZOrWZTeamData[M28Map.subrefLZFortify]) then
                                    tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] = tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] - oUnit:GetBlueprint().Economy.BuildRate
                                    break
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': BP wanted after updating for traveling engineers=' .. repru(tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted]))
            end
        end
    end

    --Cap BP wanted for non-core LZs and all WZs if enemies in the zone or adjacent
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering capping engis wnated for noncore zones; tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil') .. '; tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]=' .. tostring(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or false))
    end
    if not (tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and not (tLZOrWZTeamData[M28Map.subrefWZbCoreBase]) then
        local iBPCap
        if (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) > 10 or (bIsWaterZone and tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 10) then
            iBPCap = 0
            --Exception - cap of 5 for campaign with objective to repair (i.e. M2 UEF)
            if M28Map.bIsCampaignMap and tLZOrWZTeamData[M28Map.subrefLZFortify] and (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) < 1000 and M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subreftoUnitsToRepair][1] and M28UnitInfo.GetUnitHealthPercent(M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subreftoUnitsToRepair][1]) < 0.15 then
                iBPCap = 5
            end
            --Clear any engineers already traveling here
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Setting BP cap to 0 (or 5 if unit to repair) and clearing engineers traveling here, iBPCap='..iBPCap..'; M28Map.bIsCampaignMap='..tostring(M28Map.bIsCampaignMap)..'; Fortify='..tostring(tLZOrWZTeamData[M28Map.subrefLZFortify] or false)..'; Fortify based on plateau and zone='..tostring(M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZFortify] or false)..'; Enemy combat='..(tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)..';1st unit to repair if there is one='..(M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subreftoUnitsToRepair][1].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subreftoUnitsToRepair][1]) or 'nil')..'; flag for iTeam '..iTeam)
            end
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
                local tTravelingEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere])
                if M28Utilities.IsTableEmpty(tTravelingEngineers) == false then
                    for iEngi, oEngi in tTravelingEngineers do
                        if iBPCap > 0 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will hold off clearing engineer '..oEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngi)..' and will set BP cap to 0') end
                            iBPCap = 0
                        else
                            M28Orders.IssueTrackedClearCommands(oEngi)
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iBPCap after clearing traveling engineers='..iBPCap) end
        elseif tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] then
            iBPCap = 5
        end
        if iBPCap then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': have iBPCap of ' .. iBPCap .. '; so will limit BP wanted for this LZ')
            end
            for iTech = 1, 3 do
                if tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > iBPCap then
                    tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] = iBPCap
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if zone wants BP for any tech level 1-3, tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted]='..repru(tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted])) end
    for iTech = 1, 3 do
        if tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': Zone wants BP so setting flag to true') end
            tLZOrWZTeamData[M28Map.subrefTbWantBP] = true
            break
        end
    end
    --Clear the BP wanted flag if this is a pacifist zone
    if M28Overseer.bPacifistModeActive and tLZOrWZTeamData[M28Map.subrefTbWantBP] then
        local tLZOrWZData
        if bIsWaterZone then
            tLZOrWZData = M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        else
            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        end
        if tLZOrWZData[M28Map.subrefbPacifistArea] then
            tLZOrWZTeamData[M28Map.subrefTbWantBP] = false
            for iTech = 1, 3 do
                tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] = 0
            end
        end
    end

    --Clear any BP wanted if norush active and dealing with a non-core LZ outside any M28 norush raidius
    if M28Overseer.bNoRushActive and M28Overseer.iNoRushTimer - GetGameTimeSeconds() > 30 and tLZOrWZTeamData[M28Map.subrefTbWantBP] and not (tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and not (tLZOrWZTeamData[M28Map.subrefWZbCoreBase]) then
        local tLZOrWZData
        if bIsWaterZone then
            tLZOrWZData = M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        else
            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        end
        if M28Utilities.GetDistanceBetweenPositions(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], tLZOrWZData[M28Map.subrefMidpoint]) > M28Overseer.iNoRushRange then
            for iTech = 1, 3 do
                tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] = 0
            end
            tLZOrWZTeamData[M28Map.subrefTbWantBP] = false
            if bDebugMessages == true then LOG(sFunctionRef..': No rush override - clearing any BP wanted') end
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Finished updating the BP wanted for this land or water zone '..iLandOrWaterZone..'; iPlateauOrPond='..iPlateauOrPond..'; tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted]=' .. repru(tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted]) .. '; tLZOrWZTeamData[M28Map.subrefTbWantBP]=' .. tostring(tLZOrWZTeamData[M28Map.subrefTbWantBP]))
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckDestroyedBuildingLocations()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckDestroyedBuildingLocations'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iLastEntryToRemove
    local aiBrain
    for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
        aiBrain = oBrain
        if not(oBrain.M28IsDefeated) then
            break
        end
    end

    for iEntry, tSubtable in tRecentlyDestroyedBuildings do
        --As a rough test, in sandbox it looked like an Aeon T2 shield took about 3.5s to complete, so will go with 3.9s to be safe
        if GetGameTimeSeconds() - tSubtable[subrefDestroyedBuildingTime] >= 3.9 then
            iLastEntryToRemove = iEntry
            local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tSubtable[subrefDestroyedBuildingLocation])
            local tLZOrWZData
            local tZoneBySegmentRef
            local tBlueprintSizeTableRef
            if iPlateauOrZero > 0 then
                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                tZoneBySegmentRef = M28Map.tLandZoneBySegment
                tBlueprintSizeTableRef = tsBlueprintsBySize
            elseif iPlateauOrZero == 0 then
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                tZoneBySegmentRef = M28Map.tWaterZoneBySegment
                tBlueprintSizeTableRef = tsWZBlueprintsBySize
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iENtry='..iEntry..'; repru='..repru(tSubtable)) end
            if iLandOrWaterZone > 0 then
                local iBuildingSize = M28UnitInfo.GetBuildingSize(tSubtable[subrefDestroyedBuildingBlueprint])
                local iBaseSegmentX, iBaseSegmentZ = M28Map.GetPathingSegmentFromPosition(tSubtable[subrefDestroyedBuildingLocation])
                --local iAffectedDistanceRadius = math.min(math.max(iBuildingSize, 8), iBuildingSize * 0.5 + iMaxBuildingSize * 0.5)

                if aiBrain then
                    SearchForBuildableLocationsNearTarget(aiBrain, tLZOrWZData, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, iBaseSegmentX, iBaseSegmentZ, iBuildingSize * 0.5)

                    --Record any mass storage locations
                    if iPlateauOrZero > 0 then
                        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZMexLocations]) == false then
                            local bHaveNearbyMex = false
                            local iPotentialStorageDistance = iBuildingSize * 0.5 + 3
                            for iMex, tMex in tLZOrWZData[M28Map.subrefLZMexLocations] do
                                if M28Utilities.GetRoughDistanceBetweenPositions(tMex, tSubtable[subrefDestroyedBuildingLocation]) <= iPotentialStorageDistance then
                                    bHaveNearbyMex = true
                                    break
                                end
                            end
                            if bHaveNearbyMex then
                                M28Map.RecordAvailableMassStorageLocationsForLandZone(iPlateauOrZero, iLandOrWaterZone)
                            end
                        end
                    end
                else
                    M28Utilities.ErrorHandler('No longer have M28 brain')
                end
            end
        else
            iLastEntryToRemove = iEntry - 1
            break
        end
    end
    if iLastEntryToRemove > 0 then
        for iEntry = iLastEntryToRemove, 1, -1 do
            table.remove(tRecentlyDestroyedBuildings, iEntry)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DestroyedBuildingLocationMonitor()
    if not(bActiveDestroyedBuildingLoop) then
        while M28Utilities.bM28AIInGame do
            WaitTicks(1)
            if M28Utilities.IsTableEmpty(tRecentlyDestroyedBuildings) == false then
                ForkThread(CheckDestroyedBuildingLocations)
            end
        end
    end
end

function EngineerInitialisation(aiBrain)
    --Variable declaration
    aiBrain[refiEngineerCurUniqueReference] = 0
    aiBrain[M28Factory.refiHighestFactoryBuildCount] = 0

    if not (bBuildLocationLoopActive) then
        ForkThread(SlowlyRefreshBuildableLandZoneLocations, aiBrain)
        ForkThread(DestroyedBuildingLocationMonitor)
    end
    if not (bWZBuildLocationLoopActive) then
        ForkThread(RecordBuildableCoreWaterZoneLocationsNearStartOfGame)
    end
end

function GetBPToAssignToBuildingTML(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam, bHaveLowMass)
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPToAssignToBuildingTML'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iBPWanted = 0
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': TIme=' .. GetGameTimeSeconds() .. ' iPlateau=' .. iPlateau .. '; bHaveLowMass=' .. tostring(bHaveLowMass) .. '; Is core base=' .. tostring(tLZTeamData[M28Map.subrefLZbCoreBase]) .. '; is core expansion=' .. tostring(tLZTeamData[M28Map.subrefLZCoreExpansion]) .. '; iLandZone=' .. iLandZone)
    end
    if tLZTeamData[M28Map.subrefLZbCoreBase] or (tLZTeamData[M28Map.subrefLZCoreExpansion] and not (bHaveLowMass)) then
        --Make sure we have recorded pathing in a straight line for this zone (will only run if table is empty)
        M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint])

        if bDebugMessages == true then
            LOG(sFunctionRef .. ': M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] .. '; Is table of pathing to other LZ and WZ empty=' .. tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance])))
        end
        --Decided to remove the check about max enemy tech, as they may have T2 mexes but T1 units, and performance isn't as big a concern early-game anyway
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
            --Do we have any TML in this LZ already?
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Do we already have TML in this LZ? Is table of TML empty=' .. tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryTML, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))))
            end
            if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryTML, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': About to cycle through every land zone and consider targets')
                end
                for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Zone ' .. tSubtable[M28Map.subrefiLandOrWaterZoneRef] .. ' is distance ' .. tSubtable[M28Map.subrefiDistance] .. ' away')
                    end
                    if tSubtable[M28Map.subrefiDistance] <= M28Building.iTMLMissileRange then
                        if not (tSubtable[M28Map.subrefbIsWaterZone]) then
                            local tAltLZTeamData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]][M28Map.subrefLZTeamData][iTeam]
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Considering enemy zone ' .. tSubtable[M28Map.subrefiLandOrWaterZoneRef] .. '; Is table of enemy TMD empty=' .. tostring(M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoEnemyTMD])) .. '; is talbe of enemy potential targets empty=' .. tostring(M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoEnemyTMD])))
                            end
                            if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoEnemyTMD]) == false then
                                --Refresh the table
                                local iLastEntry = table.getn(tAltLZTeamData[M28Map.subreftoEnemyTMD])
                                for iCurEntry = iLastEntry, 1, -1 do
                                    if not (M28UnitInfo.IsUnitValid(tAltLZTeamData[M28Map.subreftoEnemyTMD][iCurEntry])) then
                                        table.remove(tAltLZTeamData[M28Map.subreftoEnemyTMD], iCurEntry)
                                    end
                                end
                                if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoEnemyTMD]) == false then
                                    break
                                end
                            end
                            if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets]) == false then
                                --Refresh the list of potential targets
                                local iLastEntry = table.getn(tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets])
                                for iCurEntry = iLastEntry, 1, -1 do
                                    if not (M28UnitInfo.IsUnitValid(tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets][iCurEntry])) then
                                        table.remove(tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets], iCurEntry)
                                    end
                                end
                                if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets]) == false then
                                    --Do we have >=50% complete T2+ mex, or 100% of a high value alt unit?
                                    local iDecentTargetCount = 0
                                    local bDontDoDistanceCheck = false
                                    if table.getn(tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets]) >= 5 then bDontDoDistanceCheck = true end
                                    for iUnit, oUnit in tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets] do
                                        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Distance to midpoint='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])) end
                                        if oUnit:GetFractionComplete() >= 0.75 then
                                            if bDontDoDistanceCheck or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= M28Building.iTMLMissileRange - 10 then
                                                if EntityCategoryContains(M28UnitInfo.refCategoryMex - categories.TECH1, oUnit.UnitId) then
                                                    iDecentTargetCount = iDecentTargetCount + 1
                                                else iDecentTargetCount = iDecentTargetCount + oUnit:GetFractionComplete() *  (oUnit:GetBlueprint().BuildCostMass or 0) / 1200
                                                end
                                                if iDecentTargetCount >= 1 then break end
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': iDecentTargetCount='..iDecentTargetCount) end
                                    if iDecentTargetCount >= 1 then
                                        iBPWanted = 40
                                        if not (bHaveLowMass) then
                                            iBPWanted = 80
                                        end
                                        break
                                    end
                                end
                            end
                        end
                    else
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Remaining zones out of range so will abort')
                        end
                        break
                    end
                end
            end
        else
            M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint])
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBPWanted
end

function GetStartSearchPositionForEmergencyPD(tTargetBuildLocation, tLZMidpoint, iPlateau, iLandZone)
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetStartSearchPositionForEmergencyPD'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iAngleFromTargetToMidpoint = M28Utilities.GetAngleFromAToB(tTargetBuildLocation, tLZMidpoint)
    local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(tTargetBuildLocation, tLZMidpoint)
    local iDistToMove = math.max(25, iDistToTarget * 0.6)
    if iDistToTarget - iDistToMove >= 60 then
        iDistToMove = iDistToTarget - 60
    end
    local tTargetLocation = M28Utilities.MoveInDirection(tTargetBuildLocation, iAngleFromTargetToMidpoint, iDistToMove, true, false, true)
    --Adjust if we end up out of the zone
    local iTargetPlateau, iTargetLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Time ' .. GetGameTimeSeconds() .. '; First position with iDistToMove=' .. iDistToMove .. '=' .. repru(tTargetLocation) .. '; tLZMidpoint=' .. repru(tLZMidpoint) .. '; tTargetBuildLocation=' .. repru(tTargetBuildLocation) .. '; Dist to midpoint=' .. M28Utilities.GetDistanceBetweenPositions(tTargetBuildLocation, tLZMidpoint) .. '; Dist to original target=' .. M28Utilities.GetDistanceBetweenPositions(tTargetBuildLocation, tTargetLocation) .. '; iTargetPlateau=' .. (iTargetPlateau or 'nil') .. '; iTargetLandZone=' .. (iTargetLandZone or 'nil'))
    end
    while not (iLandZone == iTargetLandZone) do
        iDistToMove = iDistToMove + 5
        if iDistToMove > iDistToTarget then
            tTargetLocation = tLZMidpoint
            break
        end
        tTargetLocation = M28Utilities.MoveInDirection(tTargetBuildLocation, iAngleFromTargetToMidpoint, iDistToMove, true, false, true)
        iTargetPlateau, iTargetLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
    end

    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Time=' .. GetGameTimeSeconds() .. '; tTargetBuildLocation=' .. repru(tTargetBuildLocation) .. '; tLZMidpoint=' .. repru(tLZMidpoint) .. '; iAngleFromTargetToMidpoint=' .. iAngleFromTargetToMidpoint .. '; iDistToTarget=' .. iDistToTarget .. '; iDistToMove=' .. iDistToMove .. '; tTargetLocation=' .. repru(tTargetLocation))
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tTargetLocation
end

function GetMaxShieldSearchRangeForEngineer(oFirstEngineer, iCategoryWanted)
    --Sets max search range to ensure we dont go outside the max shield radius available to oFirstEngineer
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetMaxShieldSearchRangeForEngineer'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                                            --GetBlueprintThatCanBuildOfCategory(aiBrain,               iCategoryCondition, oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
    local tsAvailableBlueprints = M28Factory.GetBlueprintThatCanBuildOfCategory(oFirstEngineer:GetAIBrain(), iCategoryWanted, oFirstEngineer)
    local iMaxSearchRange = 10 --Default in case something goes wrong
    if M28Utilities.IsTableEmpty(tsAvailableBlueprints) == false then
        for iShield, sShield in tsAvailableBlueprints do
            iMaxSearchRange = math.max(iMaxSearchRange, (__blueprints[sShield].ShieldSize or 0) * 0.5)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iMaxSearchRange
end

function ClearEngineersBuildingUnit(oEngineer, oJustBuilt, bClearEngineersBuildingAtSameLocation)
    --Note - oJustBuilt can also be a unit under construction (e.g. if we want to cancel construction and reclaim it)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ClearEngineersBuildingUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iAction = oEngineer[refiAssignedAction]

    function ClearEngineerIfActionObseleteNow(oCurEngineer, bCalledViaRepairTracking)
        local bClearEngineer = false
        if M28UnitInfo.IsUnitValid(oCurEngineer) and not (oCurEngineer:IsUnitState('Reclaiming')) then
            --Does it have the same action, or alternatitvely is it trying to build something at this location that will now be blocked?
            local tLastOrder = oCurEngineer[M28Orders.reftiLastOrders][oCurEngineer[M28Orders.refiOrderCount]]
            local iOrderDistToJustBuilt
            --Ignore if last order was to load onto transport
            if not(tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderLoadOntoTransport) and not(oEngineer[refiAssignedAction] == refActionLoadOntoTransport) then --redundancy
                if M28Utilities.IsTableEmpty(tLastOrder[M28Orders.subreftOrderPosition]) == false then iOrderDistToJustBuilt = M28Utilities.GetDistanceBetweenPositions(tLastOrder[M28Orders.subreftOrderPosition], oJustBuilt:GetPosition()) end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if should clear engineer, oJustBuilt='..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; oCurEngineer='..oCurEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oCurEngineer)..'; iOrderDistToJustBuilt='..iOrderDistToJustBuilt..'; tLastOrder[M28Orders.subrefoOrderUnitTarget]='..(tLastOrder[M28Orders.subrefoOrderUnitTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tLastOrder[M28Orders.subrefoOrderUnitTarget]) or 'nil')..'; iAction='..(iAction or 'nil')..'; Cur engineer action='..(oCurEngineer[refiAssignedAction] or 'nil')) end
                if iOrderDistToJustBuilt <= 1 or tLastOrder[M28Orders.subrefoOrderUnitTarget] == oJustBuilt then
                    bClearEngineer = true
                elseif bCalledViaRepairTracking and oCurEngineer:GetFocusUnit() == oJustBuilt then
                    bClearEngineer = true
                    --Are we building something near here that is now blocked?
                elseif iOrderDistToJustBuilt and iOrderDistToJustBuilt <= 10 and tLastOrder[M28Orders.subrefsOrderBlueprint] then
                    local oBlueprint = __blueprints[tLastOrder[M28Orders.subrefsOrderBlueprint]]
                    local iBuildingRadius = math.min(oBlueprint.Physics.SkirtSizeX, oBlueprint.Physics.SkirtSizeZ) * 0.5
                    if iOrderDistToJustBuilt < iBuildingRadius * 1.45 then --1.4142 should be enough, 1.45 used for prudence
                        --do more precise check
                        if math.abs(tLastOrder[M28Orders.subreftOrderPosition][1] - oJustBuilt:GetPosition()[1]) < iBuildingRadius and math.abs(tLastOrder[M28Orders.subreftOrderPosition][3] - oJustBuilt:GetPosition()[3]) < iBuildingRadius then
                            bClearEngineer = true
                        end
                    end

                end
            end
            if bClearEngineer then
                if bDebugMessages == true then LOG(sFunctionRef..': Will clear engineer') end
                M28Orders.IssueTrackedClearCommands(oCurEngineer)
            end
        end
    end

    if (tiActionOrder[iAction] == M28Orders.refiOrderIssueBuild and not (tbIgnoreEngineerAssistance[iAction])) or (oJustBuilt:GetFractionComplete() == 1 and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oJustBuilt.UnitId)) then
        --FIrst clear any engineers tracked as repariing this building
        if M28Utilities.IsTableEmpty(oJustBuilt[M28Orders.toUnitsOrderedToRepairThis]) == false then
            for iCurEngineer = table.getn(oJustBuilt[M28Orders.toUnitsOrderedToRepairThis]), 1, -1 do
                ClearEngineerIfActionObseleteNow(oJustBuilt[M28Orders.toUnitsOrderedToRepairThis][iCurEngineer], true)
            end
        end
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oEngineer:GetPosition())
        if (iLandOrWaterZone or 0) > 0 then
            local tLZOrWZTeamData
            local aiBrain = oEngineer:GetAIBrain()
            local iTeam = aiBrain.M28Team
            if iPlateauOrZero == 0 then
                tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
            else
                tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
            end
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                local tAllEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if M28Utilities.IsTableEmpty(tAllEngineers) == false then
                    for iUnit, oUnit in tAllEngineers do
                        ClearEngineerIfActionObseleteNow(oUnit, false)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ClearEngineersWhoseTargetIsNowBlockedByUnitConstructionStarted(oEngineer, oConstruction)
    --Idea is to prevent scenarios where two units get queued orders for the same location - once construction is started for one, it wont be possible for the other
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ClearEngineersWhoseTargetIsNowBlockedByUnitConstructionStarted'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iAction = oEngineer[refiAssignedAction]
    if tiActionOrder[iAction] == M28Orders.refiOrderIssueBuild then
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oConstruction:GetPosition())
        if (iLandOrWaterZone or 0) > 0 then
            local tLZOrWZTeamData
            local aiBrain = oEngineer:GetAIBrain()
            local iTeam = aiBrain.M28Team
            if iPlateauOrZero == 0 then
                tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
            else
                tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
            end
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                local tAllEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if M28Utilities.IsTableEmpty(tAllEngineers) == false then
                    local iBuildingSizeRadius = M28UnitInfo.GetBuildingSize(oConstruction.UnitId) * 0.5
                    local iQueuedBuildingSizeRadius
                    for iUnit, oUnit in tAllEngineers do
                        if M28UnitInfo.IsUnitValid(oUnit) and oUnit[refiAssignedAction] and not (oUnit[refiAssignedAction] == iAction) and not (oUnit:IsUnitState('Reclaiming')) and tiActionOrder[oUnit[refiAssignedAction]] == M28Orders.refiOrderIssueBuild then
                            local tLastOrder = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]]
                            if tLastOrder[M28Orders.subrefsOrderBlueprint] then
                                if M28Utilities.IsTableEmpty(tLastOrder[M28Orders.subreftOrderPosition]) == false then
                                    iQueuedBuildingSizeRadius = M28UnitInfo.GetBuildingSize(tLastOrder[M28Orders.subrefsOrderBlueprint]) * 0.5
                                    if M28Utilities.GetRoughDistanceBetweenPositions(tLastOrder[M28Orders.subreftOrderPosition], oConstruction:GetPosition()) < iBuildingSizeRadius + iQueuedBuildingSizeRadius then
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Clearing engineer ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. ' as it has a queued order ' .. reprs(tLastOrder) .. ' that is blocked by oConstruction=' .. oConstruction.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oConstruction.UnitId))
                                        end
                                        M28Orders.IssueTrackedClearCommands(oUnit)
                                    end
                                end
                            end
                        end
                    end
                end
            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function ConsiderDestroyingLowTechEngineers(oJustBuilt)
    --Intended late game where lots of low tech engis in a core base
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderDestroyingLowTechEngineers'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain = oJustBuilt:GetAIBrain()
    local iCurEngineers = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer)
    if iCurEngineers >= 100 then
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oJustBuilt:GetPosition())
        if (iLandOrWaterZone or 0) > 0 then
            local tLZOrWZTeamData
            local iTeam = aiBrain.M28Team
            if iPlateauOrZero == 0 then
                tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
            else
                tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
            end
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                local tT1AndT2EngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer * categories.TECH1 + M28UnitInfo.refCategoryEngineer * categories.TECH2, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if M28Utilities.IsTableEmpty(tT1AndT2EngineersInZone) == false then
                    local iT1AndT2EngineersInZone = table.getn(tT1AndT2EngineersInZone)
                    if iT1AndT2EngineersInZone >= 10 or (iCurEngineers >= 150 and iT1AndT2EngineersInZone >= 4) then
                        local tT3EngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer * categories.TECH3, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])

                        if M28Utilities.IsTableEmpty(tT3EngineersInZone) == false then
                            local iT3EngineersInZone = table.getn(tT3EngineersInZone)
                            if iT3EngineersInZone >= 40 then
                                --Ctrl-K up to 3 engineers
                                local iEngineersKilled = 0
                                local tT1Engineers = EntityCategoryFilterDown(categories.TECH1, tT1AndT2EngineersInZone)
                                local iT1Count = 0
                                function KillEngineerIfSufficientlyIdle(oEngi)
                                    if not (oEngi[refbPrimaryBuilder]) and not (oEngi:IsUnitState('Building')) and not (oEngi:IsUnitState('Reclaiming')) and not (oEngi:IsUnitState('Capturing')) and not (oEngi:IsUnitState('Repairing')) then
                                        if bDebugMessages == true then LOG(sFunctionRef .. ': Just given order to kill unit ' .. oEngi.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oEngi) .. ' as have oto many engis in this zone') end
                                        M28Orders.IssueTrackedKillUnit(oEngi)
                                        iEngineersKilled = iEngineersKilled + 1
                                    end
                                end
                                if M28Utilities.IsTableEmpty(tT1Engineers) == false then
                                    for iUnit, oUnit in tT1Engineers do
                                        KillEngineerIfSufficientlyIdle(oUnit)
                                        if iEngineersKilled >= 3 then
                                            break
                                        end
                                    end
                                end
                                if iEngineersKilled < 3 then
                                    local tT2Engineers = EntityCategoryFilterDown(categories.TECH2, tT1AndT2EngineersInZone)
                                    if M28Utilities.IsTableEmpty(tT2Engineers) == false then
                                        for iUnit, oUnit in tT2Engineers do
                                            KillEngineerIfSufficientlyIdle(oUnit)
                                            if iEngineersKilled >= 3 then
                                                break
                                            end
                                        end
                                    end
                                end

                            end
                        end
                    end
                end
            end
        end
    end
end

function RecordUnitAsCaptureTarget(oUnit, bOptionalOnlyRecordIfSameUnitIdInCaptureList)
    --bOptionalOnlyRecordIfSameUnitIdInCaptureList - true if we only want to record oUnit if a unit with the same .UnitId is in the zone as a capture target - i.e. intended where a unit is captured that can be captured back
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordUnitAsCaptureTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28Map.bIsCampaignMap and not(EntityCategoryContains(categories.MOBILE, oUnit.UnitId)) then
        while not(M28Map.bWaterZoneInitialCreation) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if GetGameTimeSeconds() >= 10 then break end
        end

        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
        local tLZOrWZData
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..';  oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; Unit position='..repru(oUnit:GetPosition())..'; Unit owner='..oUnit:GetAIBrain().Nickname) end
        if iLandOrWaterZone > 0 then
            if iPlateauOrZero == 0 then
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
            else
                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
            end
            --If this was called via onunitcaptured then want to check if the same unitid was recorded in a table of capture targets:
            local bWantToCaptureUnit = not(bOptionalOnlyRecordIfSameUnitIdInCaptureList)
            if bOptionalOnlyRecordIfSameUnitIdInCaptureList then
                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subreftoUnitsToCapture]) == false then
                    for iCaptureTarget, oCaptureTarget in tLZOrWZData[M28Map.subreftoUnitsToCapture] do
                        if oCaptureTarget.UnitId == oUnit.UnitId then
                            bWantToCaptureUnit = true
                            break
                        end
                    end
                end
            end

            --Check we havent already recorded this unit
            if bWantToCaptureUnit and oUnit[M28UnitInfo.refbIsCaptureTarget] and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subreftoUnitsToCapture]) == false then
                for iRecordedUnit, oRecordedUnit in tLZOrWZData[M28Map.subreftoUnitsToCapture] do
                    if oRecordedUnit == oUnit then
                        bWantToCaptureUnit = false
                        break
                    end
                end
            end

            --Record unit against zone as a capture target and flag so we dont try and reclaim it
            if bDebugMessages == true then LOG(sFunctionRef..': bWantToCaptureUnit='..tostring(bWantToCaptureUnit)..'; oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')) end
            if bWantToCaptureUnit then
                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subreftoUnitsToCapture]) then tLZOrWZData[M28Map.subreftoUnitsToCapture] = {} end
                table.insert(tLZOrWZData[M28Map.subreftoUnitsToCapture], oUnit)
                oUnit[M28UnitInfo.refbIsCaptureTarget] = true
                if bDebugMessages == true then LOG(sFunctionRef..': Added unit to table of units to capture') end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckForSpecialCampaignCaptureTargets()
    --Called whenever we get a new objective or the map size changes, as a basic way of checking for extra objectives that dont use the normal objective function
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckForSpecialCampaignCaptureTargets'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --FA M6 - check for control centre building
    if bDebugMessages == true then LOG(sFunctionRef..': is ControlCentreBldg nil='..tostring(ScenarioInfo.ControlCenterBldg == nil)) end
    if ScenarioInfo.ControlCenterBldg then
        local oControlCentre = ScenarioInfo.ControlCenterBldg
        if bDebugMessages == true then LOG(sFunctionRef..': oControlCentre='..(oControlCentre.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oControlCentre) or 'nil')..'; Is capturable='..tostring(oControlCentre:IsCapturable())..'; refbIsCaptureTarget='..tostring(oControlCentre[M28UnitInfo.refbIsCaptureTarget] or false)) end
        if M28UnitInfo.IsUnitValid(oControlCentre) and oControlCentre:IsCapturable() then
            --Have we already recorded as a capturable target?
            if not(oControlCentre[M28UnitInfo.refbIsCaptureTarget]) then
                --Get first M28 brain in game
                local oFirstM28Brain
                if M28Utilities.IsTableEmpty(M28Overseer.tAllActiveM28Brains) == false then
                    for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                        if oBrain.M28AI then
                            oFirstM28Brain = oBrain
                            if not(oBrain.CampaignAI) then
                                break
                            end
                        end
                    end
                end
                if oFirstM28Brain and not(IsAlly(oFirstM28Brain:GetArmyIndex(), oControlCentre:GetAIBrain():GetArmyIndex())) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will call logic to record control centre as a capture target') end
                    RecordUnitAsCaptureTarget(oControlCentre)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function GetLocationToBuildWall(oEngineer, oJustBuilt, sWallBP)
    --Builds wall around nearby T1 PD (if there is any), subject to blacklist
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetLocationToBuildWall'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local oPDToSurround
    if EntityCategoryContains(M28UnitInfo.refCategoryPD * categories.TECH1, oJustBuilt.UnitId) then
        if oJustBuilt:GetBlueprint().Physics.SkirtSizeX <= 1 then
            oPDToSurround = oJustBuilt
        end
    else
        --Search nearby for T1 PD
        local tNearbyUnits = GetUnitsInRect(M28Utilities.GetRectAroundLocation(oJustBuilt:GetPosition(), 1.9))
        if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
            local tNearbyPD = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD * categories.TECH1, tNearbyUnits)
            if M28Utilities.IsTableEmpty(tNearbyPD) == false then
                local tSuitablePDSize = {}
                for iUnit, oUnit in tNearbyPD do
                    if oUnit:GetBlueprint().Physics.SkirtSizeX <= 1 then
                        table.insert(tSuitablePDSize, oUnit)
                    end
                end
                if M28Utilities.IsTableEmpty(tSuitablePDSize) == false then
                    local iCurDist
                    local iClosestDist = 10000
                    if table.getn(tSuitablePDSize) > 1 then
                        for iPD, oPD in tSuitablePDSize do
                            iCurDist = M28Utilities.GetRoughDistanceBetweenPositions(oPD:GetPosition(), oJustBuilt:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oPDToSurround = oPD
                            end
                        end
                    else
                        oPDToSurround = tSuitablePDSize[1]
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Near start, oPDToSurround='..(oPDToSurround.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oPDToSurround) or 'nil')..'; Gametime='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)) end
    if oPDToSurround then
        local tPDToSurround = oPDToSurround:GetPosition()
        --Get first location around the PD that is available for building, if any
        local aiBrain = oEngineer:GetAIBrain()
        for iXAdjust = -1, 1, 1 do
            for iZAdjust = -1, 1, 1 do
                if not(iXAdjust == 0 and iZAdjust == 0) then
                    local tTargetLocation = {tPDToSurround[1] + iXAdjust, tPDToSurround[2], tPDToSurround[3] + iZAdjust}
                    tTargetLocation[2] = GetSurfaceHeight(tTargetLocation[1], tTargetLocation[3])
                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                    if bDebugMessages == true then LOG(sFunctionRef..': Can engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' that has just built unit '..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..' at position '..repru(oJustBuilt:GetPosition())..' build at tTargetLocation '..repru(tTargetLocation)..'='..tostring(CanBuildAtLocation(aiBrain, sWallBP, tTargetLocation, nil, nil, nil, false, true, false, true))..'; Simple can build check='..tostring(aiBrain:CanBuildStructureAt(sWallBP, tTargetLocation))..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
                    if (iPlateau or 0) > 0 and (iLandZone or 0) > 0 then
                        --CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, iOptionalPlateauGroupOrZero, iOptionalLandOrWaterZone, iEngiActionToIgnore, bClearActionsIfNotStartedBuilding, bCheckForQueuedBuildings, bCheckForOverlappingBuildings, bCheckBlacklistIfNoGameEnder)
                        if CanBuildAtLocation(aiBrain, sWallBP,         tTargetLocation,     iPlateau,                  iLandZone, nil, false, true, false, true) then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return tTargetLocation
                        end
                    --sometimes an area might appear to be on a cliff but could still fit a wall piece
                    elseif aiBrain:CanBuildStructureAt(sWallBP, tTargetLocation) then
                        return tTargetLocation
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end