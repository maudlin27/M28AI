---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 29/01/2023 18:46
---

local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28Chat = import('/mods/M28AI/lua/AI/M28Chat.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')


--Global variables
iTMLMissileRange = 256 --e.g. use if dont have access to a unit blueprint
iEnergyStorageExpectedCapacity = 5000 --i.e. how much energy does an energy storage hold - for a long time for FAF was 5k, but beta balance changes (expected July 2023) are meant to be changing this
iTimeForSMDToBeConstructed = 45 --i.e. number of seconds we assume an SMD will be constructed in; even if it is built faster, it will be treated as having been built this many seconds ago so are being consistent with logic
bShieldsCanDischarge = true
bNovaxInGame = false
iLowestAirStagingTechAvailable = 3

--Variables against a unit:
    --TML and TMD
reftTMLInRangeOfThisUnit = 'M28BuildTMLInRange' --Records table of TML in range of this unit
reftUnitsInRangeOfThisTML = 'M28BuildUnitsInRangeOfTML' --Records units threatened by this TML, from the perspective of the threatened unit's team
reftUnprotectedUnitTargetsForThisTML = 'M28BuildTargetsInRangeOfTML' --records units that TML should be able to hit, from the perspective of the TML owner's team
reftUnitsCoveredByThisTMD = 'M28BuildUnitsCoveredByTMD' --Against TMD, table of units that it provides TML coverage to
reftTMDCoveringThisUnit = 'M28BuildTMDCoveringUnit' --against unit, table of TMD providing TML coverage to it
refbUnitWantsMoreTMD = 'M28BuildUnitWantsTMD' --true if a unit wants more TMD
refbNoNearbyTMDBuildLocations = 'M28BuiltUnitHasNoNearbyTMDBuildLocations' --true if we buitl a TMD to cover this unit and the TMD ended up too far away
refbMissileRecentlyBuilt = 'M28BuildMissileBuiltRecently' --true if unit has recently built a missile
refbMissileChecker = 'M28BuildMissileChecker' --true if active missile builder checker for the unit
reftActiveNukeTarget = 'M28BuildLastTargetLaucnh' --Against oLauncher, returns location of the target we last launched a TML/Nuke at while the missile is still alive, set to nil once the missile dies
reftMobileTMLLastLocationChecked = 'M28BuildLastTMLLoc' --against mobile missile TMLs like ACU/SACU, to determine if shoudl rerun logic for identifying targets
refiTimeMobileTMLLastChecked = 'M28BuildLastTMLChk' --Gametimeseconds that we last refreshed a mobile TML's potential targets
refbTMDBuiltSinceLastChecked = 'M28BuildTMDMobChk' --true if we have built a TMD since the last time we checked mobile TML
refbActiveMissileChecker = 'M28BuildMissileTargetChecker' --true if active missile target checker for the unit
--iTMLHighPriorityCategories = M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryT3Mex * categories.CYBRAN + M28UnitInfo.refCategoryT2Mex + M28UnitInfo.refCategoryTML + M28UnitInfo.refCategorySML + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategoryT2Power + M28UnitInfo.refCategoryT3Radar
tbExpectMissileBlockedByCliff = 'M28BuildMisBlck' --true if missile firing at this has hit a cliff
refiTMLShotsFired = 'M28BuildTMLShtFird'
refoLastTMLTarget = 'M28BuildTMLLstTrg'
refoLastTMLLauncher = 'M28BuildTMLLastLnch' --When a TML targets a unit, this is recorded against that unit, so if we have 2 TML they shouldn't target the same unit at the same time
refiTimeOfLastLaunch = 'M28BuildTMLTimLstLnch' --Gametimeseconds that we last fired a missile at the unit, i.e. this is against the target, not the launcher
refiTimeLastFiredMissile = 'M28BuildTMLTmLstFir' --Gametimeseconds that the nuke last was given an order to fire a missile at something
refiTimeLastGotBestArtiTarget = 'M28BuildArtTgCh' --Gametimeseconds that the arti unit last was given an order to attack a unit/location
refiLastTMLMassKills = 'M28BuildTMLMssKil'
refbPausedAsNoTargets = 'M28BuildPausNoT' --e.g. for SML use this to flag if we have paused it due to lack of targets
reftTerrainBlockedTargets = 'M28BuildTerrainBLock' --If a TML missile impacts terrain then record the original target
refbProtectedByTerrain = 'M28BuildUnitBlockByTer' --true if a target of a TML was protected by terrain
refbSalvoDelayActive = 'M28BuildSalvoDelayActive' --true if want to hold off on targets due to salvo

    --Shield related
reftoShieldsProvidingCoverage = 'M28BuildShieldsCoveringUnit' --Against unit being shielded, records the fixed shields that are covering it
reftoUnitsCoveredByShield = 'M28BuildUnitsCoveredByShield' --Against shield, returns table of units covered by shield
--refiShieldsWanted = 'M28BuildShieldsWanted' --number of fixed shield coverage wanted for the unit
refbUnitWantsShielding = 'M28BuildUnitWantsFixedShield' --true if unit wants a fixed shield
refbPriorityShield = 'M28BuildPriorityShield' --True if shield is a priority shield for assistance
refbRemoveShieldFromPriorityTableWhenFullHealth = 'M28BuildRemPrSh' --true if the shield should be removed from the table of shields wanting priority shielding when full health
refoPriorityShieldProvidingCoverage = 'M28BuildPriorityShieldCoveringUnit' --Against unit being shielded; If a shield marked as a priority shield is covering the unit, then this should return that shield
refoNearbyFactoryOfFaction = 'M28BuildNrFactionFac' --assigned against a gameender, to record that it can obtain engineers of a particular faction (for shielding purposes)
reftoUnitsWantingFactoryEngineers = 'M28BuildEngFac' --table of any units that have htis factory as their 'nearest' factory - intended for gamenders so can track which game enders assume this factory can provide engineers
reftLocationsForPriorityShield = 'M28BuildShdLoc' --against a unit (such as a game ender), [x] = 1,2,3...; returns the predetermined reserved location to build a shield in order to cover the game ender
reftoSpecialAssignedShields = 'M28BuildSpecAssShield' --against a unit (such as a game ender), [x] = 3 or 2 or 1 based on the reftLocationsForPriorityShield index; for special shielding gameender logic
refoGameEnderBeingShielded = 'M28BuildSpecShdlTarg' --against a shield, records the unit it has been assigned to (i.e. the corresponding variable for reftoSpecialAssignedShields)
reftArtiTemplateRefs = 'M28ArtiTemplateRef' --returns {iPlateau, iLandZone, iTemplateRef}, with tempalteref being the index for tLZTeamData[reftActiveGameEnderTemplates], assigned to any units that form part of it
refiTimeOfLastDischarge = 'M28ShLastDisc' --gametime that we gave a discharge order, so can check for redundancies

--T3 arti specific
reftiPlateauAndZonesInRange = 'M28BuildArtiPlatAndZInRange' --entries in order of distance, 1,2,3 etc, returns {iPlateauOrZero, iLandOrWaterZoneRef}
refbProtectingAllArtiLocations = 'M28BuildShdProtAllArti' --true if a shield is covering the midpoint of all arti locations (or arti units) - used os we avoid including in shield cycling shields like aeon shields that are too far away
refiLastTargetValue = 'M28ArtiTgVal' --value of the last target the arti targeted

--Special buildings
refbActiveOpticsManager = 'M28BuildActOptMan' --true if have active quantum optics manager
reftScathisBuiltLocation = 'M28ScaBultLoc' --location that scathis construction was started

function CheckIfUnitWantsFixedShield(oUnit, bCheckForNearbyShields, iOptionalShieldsWantedOverride)
    --Intended to be called whenever something happens that means oUnit may want to change whehter it is recorded as wanting a shield, except for death which is handled elsewhere now
    --oUnit construction is started (done via OnConstructionStarted)
    --A shield covering oUnit dies (done via UpdateShieldCoverageOfUnits)
    --A shield covering oUnit has construction started (done via UpdateShieldCoverageOfUnits)
    --bCheckForNearbyShields - if true, then will check for any already constructed shields; i.e. this should be true if this function is called from oUnit's construction being started

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckIfUnitWantsFixedShield'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at game time '..GetGameTimeSeconds()..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bCheckForNearbyShields='..tostring(bCheckForNearbyShields or false)..'; oUnit[refbUnitWantsShielding] before update='..tostring(oUnit[refbUnitWantsShielding] or false)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; iOptionalShieldsWantedOverride='..(iOptionalShieldsWantedOverride or 'nil')..'; owner='..oUnit:GetAIBrain().Nickname..'; Enemy novax count='..M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiEnemyNovaxCount]..'; Enemy arti count='..M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiEnemyT3ArtiCount]) end

    local iShieldsWanted = 0
    local iShieldCoverage = 0

    if oUnit[reftoShieldsProvidingCoverage] and M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]) == false then
        iShieldCoverage = table.getn(oUnit[reftoShieldsProvidingCoverage])
    end

    --Determine shields wanted
    if M28UnitInfo.IsUnitValid(oUnit) then
        if iOptionalShieldsWantedOverride then iShieldsWanted = iOptionalShieldsWantedOverride
        elseif oUnit[reftArtiTemplateRefs] then
            iShieldsWanted = 0 --we will be relying on template instead
        else
            local oBP = oUnit:GetBlueprint()
            --Dont get shields for other shields (to avoid infinite shields)
            if bDebugMessages == true then LOG(sFunctionRef..': Unit mass cost='..oUnit[M28UnitInfo.refiUnitMassCost]..'; Shieldm ax health='..(oBP.Defense.Shield.ShieldMaxHealth or 0)) end
            local bT2ArtiAgainstEnemyT2ArtiOrFatboy
            if EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) then
                local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, oUnit:GetAIBrain().M28Team)
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then bT2ArtiAgainstEnemyT2ArtiOrFatboy = true
                elseif tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] >= 1500 then
                    bT2ArtiAgainstEnemyT2ArtiOrFatboy = true
                end
            end
            if (bT2ArtiAgainstEnemyT2ArtiOrFatboy or (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) >= 2000 or (EntityCategoryContains(M28UnitInfo.refCategoryT2Mex, oUnit.UnitId) and M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiEnemyNovaxCount] > 0)) and (oBP.Defense.Shield.ShieldMaxHealth or 0) == 0 then
                local iTeam = oUnit:GetAIBrain().M28Team
                if bDebugMessages == true then LOG(sFunctionRef..': Unit health='..oBP.Defense.Health..'; Defending against t3 arti for iTeam'..oUnit:GetAIBrain().M28Team..'='..tostring(M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refbDefendAgainstArti] or false)) end
                if oBP.Defense.Health / (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) < 1
                        or EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId)
                        or ((M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refbDefendAgainstArti] or M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiEnemyAirToGroundThreat] >= 12000) and (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) >= 3000 and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId))
                        or (EntityCategoryContains(M28UnitInfo.refCategoryMex - categories.TECH1, oUnit.UnitId) and M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiEnemyNovaxCount] > 0) then

                    if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] and (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) >= 12000 and (M28Team.tTeamData[iTeam][M28Team.refiEnemyT3ArtiCount] >= 1 or M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] >= 2) and M28Utilities.IsTableEmpty(oUnit[reftoSpecialAssignedShields]) then iShieldsWanted = 2
                    else iShieldsWanted = 1
                    end
                end
            end
        end
    end

    --If have just started construction of oUnit then check if there are any existing shields that can help it
    if bCheckForNearbyShields and iShieldsWanted > 0 then
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
        if iPlateau > 0 and iLandZone > 0 then
            local tNearbyShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tNearbyShields) == false then
                if not(oUnit[reftoShieldsProvidingCoverage]) then oUnit[reftoShieldsProvidingCoverage] = {} end

                for iLZShield, oLZShield in tNearbyShields do
                    local iShieldRadius = oLZShield:GetBlueprint().Defense.Shield.ShieldSize * 0.5 - 0.1 -- - 1
                    RecordIfShieldIsProtectingUnit(oLZShield, oUnit, iShieldRadius, true)
                end

                if oUnit[reftoShieldsProvidingCoverage] and M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]) == false then
                    iShieldCoverage = table.getn(oUnit[reftoShieldsProvidingCoverage])
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': iShieldsWanted='..iShieldsWanted..'; iSHieldCoverage='..iShieldCoverage) end
    if iShieldsWanted > iShieldCoverage then
        --Want more shielding
        if not(oUnit[refbUnitWantsShielding]) then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
            if iPlateau > 0 and iLandZone > 0 then
                oUnit[refbUnitWantsShielding] = true
                local tUnitLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
                if not(tUnitLZTeamData[M28Map.reftoLZUnitWantingFixedShield]) then tUnitLZTeamData[M28Map.reftoLZUnitWantingFixedShield] = {} end
                table.insert(tUnitLZTeamData[M28Map.reftoLZUnitWantingFixedShield], oUnit)
                if bDebugMessages == true then LOG(sFunctionRef..': Have added unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of units wanting shielding to iPlateau='..iPlateau..'; iLandZOne='..iLandZone) end
            end
        end
    elseif M28UnitInfo.IsUnitValid(oUnit) then
        --Dont want more shielding
        if oUnit[refbUnitWantsShielding] then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
            if iPlateau > 0 and iLandZone > 0 then
                oUnit[refbUnitWantsShielding] = false
                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield]) == false then
                    for iRecordedUnit, oRecordedUnit in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield] do
                        if oRecordedUnit == oUnit then
                            table.remove(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield], iRecordedUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Removed unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from the table of units wanting fixed shielding') end
                            break
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
        LOG(sFunctionRef..': Is table of units wanting fixed shield empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield])))
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield]) == false then
            for iUnit, oUnit in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield] do
                LOG(sFunctionRef..': Listing out each unit wanting shielding for iLandZOne '..iLandZone..'; iUnit '..iUnit..' is oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordIfShieldIsProtectingUnit(oShield, oUnit, iShieldRadius, bDontCheckIfWantsFixedShield)
    --bDontCheckIfWantsFixedShield - true if calling from the 'CheckIfUnitWantsFixedShield' function to avoid infinite loop
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordIfShieldIsProtectingUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Checking if unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; is covered by oShield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; iShieldRadius='..iShieldRadius..'; Distance='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oShield:GetPosition())) end
    if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oShield:GetPosition()) <= iShieldRadius then
        local bAddToUnit = true
        --Record against unit
        if oUnit[reftoShieldsProvidingCoverage] and M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]) == false then
            --Redundancy in case something goes wrong with tracking:
            for iRecordedShield, oRecordedShield in oUnit[reftoShieldsProvidingCoverage] do
                if oRecordedShield == oShield then
                    bAddToUnit = false
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if already recorded this shield, bAddToUnit='..tostring(bAddToUnit)) end
        if bAddToUnit then
            if not(oUnit[reftoShieldsProvidingCoverage]) then oUnit[reftoShieldsProvidingCoverage] = {} end
            table.insert(oUnit[reftoShieldsProvidingCoverage], oShield)
            if bDebugMessages == true then LOG(sFunctionRef..': Recording shield as covering the unit; bDontCheckIfWantsFixedShield='..tostring(bDontCheckIfWantsFixedShield or false)) end
            if not(bDontCheckIfWantsFixedShield) then CheckIfUnitWantsFixedShield(oUnit) end
        end
        --Record against shield
        local bAddToShield = true
        if not(oShield[reftoUnitsCoveredByShield]) then oShield[reftoUnitsCoveredByShield] = {}
        else
            for iRecorded, oRecorded in oShield[reftoUnitsCoveredByShield] do
                if oRecorded == oUnit then bAddToShield = false break end
            end
        end
        if bAddToShield then
            table.insert(oShield[reftoUnitsCoveredByShield], oUnit)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateShieldCoverageOfUnits(oShield, bTreatAsDead)
    --If shield has died, then remove any units it was protecting; if shield has just started construction then instead record any units it can provide coverage to
    --Either way, clear any existing units from the shield (as redundancy - in theory should only be needed if shield is dead

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateShieldCoverageOfUnits'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through every unit that the shield is providing coverage to, and will update to remove this unit from that table, oShield='..(oShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oShield) or 'nil')..'; Is table of units empty='..tostring(M28Utilities.IsTableEmpty(oShield[reftoUnitsCoveredByShield])))
        if M28Utilities.IsTableEmpty(oShield[reftoUnitsCoveredByShield]) == false then LOG(sFunctionRef..': Number of units covered='..table.getn(oShield[reftoUnitsCoveredByShield])) end
    end
    if M28Conditions.IsTableOfUnitsStillValid(oShield[reftoUnitsCoveredByShield]) then
        for iUnit, oUnit in oShield[reftoUnitsCoveredByShield] do
            if M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Will update unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to no longer have the shield recorded as providing coverage to it') end
                for iRecordedShield, oRecordedShield in oUnit[reftoShieldsProvidingCoverage] do
                    if oRecordedShield == oShield then
                        if bDebugMessages == true then LOG(sFunctionRef..': We had recorded shield '..oRecordedShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRecordedShield)..' as covering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so will now remove it') end
                        table.remove(oUnit[reftoShieldsProvidingCoverage], iRecordedShield)
                        break
                    end
                end
                if M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]) then oUnit[reftoShieldsProvidingCoverage] = nil end
            end
            if oUnit:GetAIBrain().M28AI then
                CheckIfUnitWantsFixedShield(oUnit)
            end
        end
        oShield[reftoUnitsCoveredByShield] = nil
    end

    if not(bTreatAsDead) then
        --Record what units this shield can protect in t he LZ it is in
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oShield:GetPosition())
        if iPlateau > 0 and iLandZone > 0 then
            local tUnitsWantingShielding = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oShield:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield]
            if M28Utilities.IsTableEmpty(tUnitsWantingShielding) == false then
                local iShieldRadius = oShield:GetBlueprint().Defense.Shield.ShieldSize * 0.5 - 0.1 -- - 1
                oShield[reftoUnitsCoveredByShield] = {}
                local bAddToUnit = false
                local tUnitsToConsider = {}
                --Copy table so we dont have to fork thread to update each unit
                for iUnit, oUnit in tUnitsWantingShielding do
                    if M28UnitInfo.IsUnitValid(oUnit) then table.insert(tUnitsToConsider, oUnit) end
                end
                for iUnit, oUnit in tUnitsToConsider do
                    RecordIfShieldIsProtectingUnit(oShield, oUnit, iShieldRadius)
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code for oShield='..(oShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oShield) or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordUnitShieldCoverage(oUnit)
    --For all units, not just M28 specific, so e.g. a TML will recognise when it's firing at a shielded target
    --Intended to be called when a unit is created
    if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) then
        local aiBrain = oUnit:GetAIBrain()
        --Is this a shield? if so then update all units around it
        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oUnit.UnitId) then
            local iShieldRadius = oUnit:GetBlueprint().Defense.Shield.ShieldSize * 0.5 - 0.1 -- - 1 --removed the -1 as of v50 since now that are using this to track enemies it can lead to false results
            local tNearbyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure, oUnit:GetPosition(), iShieldRadius, 'Ally')
            if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                for iNearbyUnit, oNearbyUnit in tNearbyUnits do
                    RecordIfShieldIsProtectingUnit(oUnit, oNearbyUnit, iShieldRadius, true)
                end
            end
        else
            local iPotentialShieldRadius = 22 --seraphim is 23 radius
            local tNearbyShields = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedShield, oUnit:GetPosition(), iPotentialShieldRadius, 'Ally')
            if M28Utilities.IsTableEmpty(tNearbyShields) == false then
                local iShieldRadius
                for iShield, oShield in tNearbyShields do
                    if oShield:GetFractionComplete() == 1 then
                        iShieldRadius = oShield:GetBlueprint().Defense.Shield.ShieldSize * 0.5 -0.1 -- - 1
                        RecordIfShieldIsProtectingUnit(oShield, oUnit, iShieldRadius, true)
                    end
                end
            end
        end
    end
end

function ForkedCheckForAnotherMissile(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ForkedCheckForAnotherMissile'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if not(oUnit[refbMissileChecker]) then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1) --make sure we have an accurate number for missiles
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        local iMissiles = 0
        if oUnit.GetTacticalSiloAmmoCount then iMissiles = iMissiles + oUnit:GetTacticalSiloAmmoCount() end
        if oUnit.GetNukeSiloAmmoCount then iMissiles = iMissiles + oUnit:GetNukeSiloAmmoCount() end
        if iMissiles >= 2 then
            oUnit[refbMissileChecker] = true
            while M28UnitInfo.IsUnitValid(oUnit) do
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitSeconds(10)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if M28UnitInfo.IsUnitValid(oUnit) then
                    local iTeam = oUnit:GetAIBrain().M28Team
                    iMissiles = 0
                    if oUnit.GetTacticalSiloAmmoCount then iMissiles = iMissiles + oUnit:GetTacticalSiloAmmoCount() end
                    if oUnit.GetNukeSiloAmmoCount then iMissiles = iMissiles + oUnit:GetNukeSiloAmmoCount() end
                    if bDebugMessages == true then LOG(sFunctionRef..': iMissiles='..iMissiles) end
                    if iMissiles < 2 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.8 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 400) then
                        oUnit:SetPaused(false)
                        oUnit:SetAutoMode(true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Will change unit state so it isnt paused') end
                        break
                    end
                else
                    break
                end

            end
        else
            if M28UnitInfo.IsUnitValid(oUnit) then oUnit:SetPaused(false) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckIfWantToBuildAnotherMissile(oUnit)
    ForkThread(ForkedCheckForAnotherMissile, oUnit)
end

function RecordUnitsInRangeOfTMLAndAnyTMDProtection(oTML, tOptionalUnitsToConsider)
    --tOptionalUnitsToConsider - if nil then will get all nearby units on an opposing team to oTML
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordUnitsInRangeOfTMLAndAnyTMDProtection'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if M28UnitInfo.IsUnitValid(oTML) then
        --If this is a mobile TML then want to update any units not in range of it now that were recorded as being in range previously
        --[[local toMobilePrevRecordedUnitsToUpdate
        if EntityCategoryContains(categories.MOBILE, oTML.UnitId) and oTML[refbTMDBuiltSinceLastChecked] and M28Conditions.IsTableOfUnitsStillValid(oTML[reftUnitsInRangeOfThisTML]) then
            toMobilePrevRecordedUnitsToUpdate = {}
            for iRecorded, oRecorded in oTML[reftUnitsInRangeOfThisTML] do
                toMobilePrevRecordedUnitsToUpdate[GetUnitRef(oRecorded)] = oRecorded
            end
        end--]]

        local iTMLRange = math.max((oTML[M28UnitInfo.refiManualRange] or 0), (oTML[M28UnitInfo.refiIndirectRange] or 0))
        if iTMLRange == 0 then iTMLRange = iTMLMissileRange end
        --Increase range if mobile
        if EntityCategoryContains(categories.MOBILE, oTML.UnitId) then
            iTMLRange = iTMLRange + 10
        end
        --Increase range for aoe
        iTMLRange = iTMLRange + (oTML[M28UnitInfo.refiIndirectAOE] or 2)
        if bDebugMessages == true then LOG(sFunctionRef..': TMl range: Manual range='..(oTML[M28UnitInfo.refiManualRange] or 0)..'; IF range='..(oTML[M28UnitInfo.refiIndirectRange] or 0)..'; AOE='..(oTML[M28UnitInfo.refiIndirectAOE] or 2)..'; Is TML mobile='..tostring(EntityCategoryContains(categories.MOBILE, oTML.UnitId))..'; TML='..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)) end


        local iTMLTeam = oTML:GetAIBrain().M28Team
        local tNearbyTMD = {}
        local tUnitsToProtect = {}
        local tiTeamsWithUnitsThatMightWantTMD = {}
        if tOptionalUnitsToConsider then
            for iUnit, oUnit in tOptionalUnitsToConsider do
                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTML:GetPosition()) <= iTMLRange then
                    table.insert(tUnitsToProtect, oUnit)
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Near start of code for oTML='..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)..' at time of '..GetGameTimeSeconds()..'; Is tOptionalUnitsToConsider nil='..tostring(tOptionalUnitsToConsider == nil)) end
        for iTMDTeam = 1, M28Team.iTotalTeamCount do
            --Get all TMD that could stop this TML, and all units it could threaten
            if not(iTMDTeam == iTMLTeam) then
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTMDTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
                    local oTMDBrain
                    for iBrain, oBrain in M28Team.tTeamData[iTMDTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                        oTMDBrain = oBrain
                        break
                    end

                    local tTeamNearbyTMD = oTMDBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD, oTML:GetPosition(), iTMLRange + 13, 'Ally')
                    if M28Utilities.IsTableEmpty(tTeamNearbyTMD) == false then
                        for iUnit, oUnit in tTeamNearbyTMD do
                            table.insert(tNearbyTMD, oUnit)
                        end
                    end
                    if not(tOptionalUnitsToConsider) then
                        --i.e. this is the first time we are considering the TML; double-check we havent already recorded the TML
                        local bNotAlreadyRecordedInTeamData = EntityCategoryContains(M28UnitInfo.refCategoryTML, oTML.UnitId)
                        if bNotAlreadyRecordedInTeamData and M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTMDTeam][M28Team.reftEnemyTML]) then
                            for iUnit, oUnit in M28Team.tTeamData[iTMDTeam][M28Team.reftEnemyTML] do
                                if oUnit == oTML then
                                    bNotAlreadyRecordedInTeamData = false
                                    break
                                end
                            end
                        end
                        if bNotAlreadyRecordedInTeamData then
                            if bDebugMessages == true then LOG(sFunctionRef..': TML not already recorded in team data so will add for team '..iTMDTeam..', oTML='..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)) end
                            table.insert(M28Team.tTeamData[iTMDTeam][M28Team.reftEnemyTML], oTML)
                        end
                        local tTeamUnitsToProtect = oTMDBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryProtectFromTML, oTML:GetPosition(), iTMLRange, 'Ally')
                        if bDebugMessages == true then LOG(sFunctionRef..': Is tTeamUnitsToProtect empty='..tostring(M28Utilities.IsTableEmpty(tTeamUnitsToProtect))..'; iTMLRange='..iTMLRange..'; TML position='..repru(oTML:GetPosition())) end
                        if M28Utilities.IsTableEmpty(tTeamUnitsToProtect) == false then
                            for iUnit, oUnit in tTeamUnitsToProtect do
                                table.insert(tUnitsToProtect, oUnit)
                            end
                        end
                    end
                end
            end
        end
        --Below not needed - had put it in when thought was reason TML wasnt firing but the civilians in campaign were already assigned teams as had updated the iscivilian flag for campaign
        --[[if not(tOptionalUnitsToConsider) and M28Map.bIsCampaignMap then
            local iTMLIndex = oTML:GetAIBrain():GetArmyIndex()
            for iBrain, oBrain in ArmyBrains do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering oBrain='..oBrain.Nickname..'; M28Team='..(oBrain.M28Team or 'nil')..'; IsEnemy='..tostring(IsEnemy(iTMLIndex, oBrain:GetArmyIndex()))) end
                if not(oBrain.M28Team) and IsEnemy(iTMLIndex, oBrain:GetArmyIndex()) then
                    local tTeamUnitsToProtect = oBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryProtectFromTML, oTML:GetPosition(), iTMLRange, 'Ally')
                    if M28Utilities.IsTableEmpty(tTeamUnitsToProtect) == false then
                        for iUnit, oUnit in tTeamUnitsToProtect do
                            local bAlreadyIncluded = false
                            if M28Utilities.IsTableEmpty(tUnitsToProtect) == false then
                                for iRecorded, oRecorded in tUnitsToProtect do
                                    if oRecorded == oUnit then bAlreadyIncluded = true break end
                                end
                            end
                            if not(bAlreadyIncluded) then
                                table.insert(tUnitsToProtect, oUnit)
                            end
                        end
                    end
                end
            end
        end--]]

        if bDebugMessages == true then LOG(sFunctionRef..': Is table of units to protect empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToProtect))..'; Is table of TMD empty='..tostring(M28Utilities.IsTableEmpty(tNearbyTMD))) end
        if M28Utilities.IsTableEmpty(tUnitsToProtect) == false then
            local iCurTeam
            for iUnit, oUnit in tUnitsToProtect do
                --if toMobilePrevRecordedUnitsToUpdate then toMobilePrevRecordedUnitsToUpdate[GetUnitRef(oUnit)] = nil end
                if not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                    --Update various tracking variables based on whether TMD are protecting this unit or not (i.e. updates TML for potential targets, TMD for units theyre covering, and units for TML that have hte unit in their range)
                    RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oTML, tNearbyTMD)
                    iCurTeam = oUnit:GetAIBrain().M28Team
                    if iCurTeam then
                        if not(tiTeamsWithUnitsThatMightWantTMD[iCurTeam]) then tiTeamsWithUnitsThatMightWantTMD[iCurTeam] = {} end
                        table.insert(tiTeamsWithUnitsThatMightWantTMD[iCurTeam], oUnit)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering if unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is protected from the TML by TMD') end
                end
            end
            if M28Utilities.IsTableEmpty(tiTeamsWithUnitsThatMightWantTMD) == false then
                for iTeam, tUnits in tiTeamsWithUnitsThatMightWantTMD do
                    RecordIfUnitsWantTMDCoverageAgainstLandZone(iTeam, tUnits)
                end
            end
        end
        --[[if M28Utilities.IsTableEmpty(toMobilePrevRecordedUnitsToUpdate) == false then
            --Dealing with a mobile TML so check for units that we havent updated per the above since they may now have TMD to cover them
            for iRecorded, oRecorded in toMobilePrevRecordedUnitsToUpdate do
                local tNearbyTMD = oRecorded:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD, oRecorded:GetPosition(), iTMLRange + 30, 'Ally')
                if M28Utilities.IsTableEmpty(tNearbyTMD) == false then
                    RecordIfUnitIsProtectedFromTMLByTMD(oRecorded, oTML, tNearbyTMD)
                end
            end
        end--]]
    end
end

function GetUnitRef(oUnit)
    return oUnit.UnitId..'L'..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'B'..oUnit:GetAIBrain():GetArmyIndex()
end

function TMDJustBuilt(oTMD)
    --Searches for any enemy TML in range of the TMD, and any friendly units in range of the TMD
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TMDJustBuilt'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local oTMDBrain = oTMD:GetAIBrain()
    local iTMDTeam = oTMDBrain.M28Team
    if not(oTMD[M28UnitInfo.refiMissileDefenceRange]) then M28UnitInfo.RecordUnitRange(oTMD) end
    local iTMDRange = (oTMD[M28UnitInfo.refiMissileDefenceRange] or 12.5)
    local tNearbyTML = {}
    local iTMDPlateauOrZero, iTMDZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oTMD:GetPosition())
    local tTMDZoneData, tTMDZoneTeamData
    if (iTMDZone or 0) > 0 then
        if iTMDPlateauOrZero == 0 then
            tTMDZoneData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iTMDZone]][M28Map.subrefPondWaterZones][iTMDZone]
            tTMDZoneTeamData = tTMDZoneData[M28Map.subrefWZTeamData][iTMDTeam]
        else
            tTMDZoneData = M28Map.tAllPlateaus[iTMDPlateauOrZero][M28Map.subrefPlateauLandZones][iTMDZone]
            tTMDZoneTeamData = tTMDZoneData[M28Map.subrefLZTeamData][iTMDTeam]
        end
    end
    local bCheckForUnitsInZone = M28Utilities.IsTableEmpty(tTMDZoneTeamData[M28Map.reftUnitsWantingTMD]) == false
    local tbUnitRefsConsideredByTML
    local tbUnitRefsConsideredAllTML = {}
    local sCurUnitRef

    for iTMLTeam = 1, M28Team.iTotalTeamCount do
        --Get all TML in range of this TMD
        if not(iTMDTeam == iTMLTeam) then
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
                local oTMLBrain
                for iBrain, oBrain in M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                    oTMLBrain = oBrain
                    break
                end
                local tTeamNearbyTML = oTMLBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTML, oTMD:GetPosition(), iTMLMissileRange + iTMDRange - 3, 'Ally')
                if bDebugMessages == true then LOG(sFunctionRef..': Dealing with oTMD='..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..'; is table of nearby TML empty='..tostring(M28Utilities.IsTableEmpty(tTeamNearbyTML))..'; iTMLTeam='..iTMLTeam) end
                if M28Utilities.IsTableEmpty(tTeamNearbyTML) == false then
                    for iTML, oTML in tTeamNearbyTML do
                        tbUnitRefsConsideredByTML = {}
                        local tFriendlyUnitsInRangeOfTML = oTMDBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryProtectFromTML, oTML:GetPosition(), iTMLMissileRange + 2, 'Ally')
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of TMD friendly units in range of TML empty='..tostring(M28Utilities.IsTableEmpty(tFriendlyUnitsInRangeOfTML))) end
                        if M28Utilities.IsTableEmpty(tFriendlyUnitsInRangeOfTML) == false then
                            for iUnit, oUnit in tFriendlyUnitsInRangeOfTML do
                                sCurUnitRef = GetUnitRef(oUnit)

                                tbUnitRefsConsideredByTML[sCurUnitRef] = true
                                tbUnitRefsConsideredAllTML[sCurUnitRef] = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Will check if unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is in range of TML '..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)) end
                                RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oTML, { oTMD }) --This will do a distance check from the unit to the TMD
                            end
                        end
                        --Also check for any units wanting TMD coverage in the TMD zone (redundancy in case there are issues with getunitsaroundpoint not picking up upgrading units)
                        if bCheckForUnitsInZone and M28Utilities.IsTableEmpty(tTMDZoneTeamData[M28Map.reftUnitsWantingTMD]) == false then
                            for iUnit, oUnit in tTMDZoneTeamData[M28Map.reftUnitsWantingTMD] do
                                if M28UnitInfo.IsUnitValid(oUnit) then
                                    sCurUnitRef = GetUnitRef(oUnit)
                                    if not(tbUnitRefsConsideredByTML[sCurUnitRef]) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have unit in zone wanting TMD coverage that we havent considered with getunitsaroundpoint, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Unit fraction complete='..oUnit:GetFractionComplete()) end
                                        RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oTML, { oTMD })
                                        tbUnitRefsConsideredAllTML[sCurUnitRef] = true
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of mobile TML empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTMDTeam][M28Team.reftEnemyMobileTML]))) end
    if M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTMDTeam][M28Team.reftEnemyMobileTML]) then
        for iMobileTML, oMobileTML in M28Team.tTeamData[iTMDTeam][M28Team.reftEnemyMobileTML] do
            if M28Conditions.IsTableOfUnitsStillValid(oMobileTML[reftUnitsInRangeOfThisTML]) then
                for iRecorded, oRecorded in oMobileTML[reftUnitsInRangeOfThisTML] do
                    sCurUnitRef = GetUnitRef(oRecorded)
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oMobileTML '..oMobileTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMobileTML)..'; oRecorded='..oRecorded.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRecorded)..'; is tbUnitRefsConsideredAllTML nil for this unit='..tostring(tbUnitRefsConsideredAllTML[sCurUnitRef] == nil)) end
                    if not(tbUnitRefsConsideredAllTML[sCurUnitRef]) then
                        RecordIfUnitIsProtectedFromTMLByTMD(oRecorded, oMobileTML, { oTMD })
                        tbUnitRefsConsideredAllTML[sCurUnitRef] = true
                    end
                end
            end
            oMobileTML[refbTMDBuiltSinceLastChecked] = true
        end
    end

    --Reevaluate all units in the zone flagged as wanting TMD, due to issue where in some cases the unit would be recorded against the LZ despite loads of TMD covering it
    if M28Utilities.IsTableEmpty(tTMDZoneTeamData[M28Map.reftUnitsWantingTMD]) == false then
        RecordIfUnitsWantTMDCoverageAgainstLandZone(iTMDTeam, tTMDZoneTeamData[M28Map.reftUnitsWantingTMD])
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordTMLAndTMDForUnitJustBuilt(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordTMLAndTMDForUnitJustBuilt'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local oTMDBrain = oUnit:GetAIBrain()
    local iTMDTeam = oTMDBrain.M28Team
    local tNearbyTMD = oTMDBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD, oUnit:GetPosition(), iTMLMissileRange + 2, 'Ally')

    for iTMLTeam = 1, M28Team.iTotalTeamCount do
        --Get all TML in range of this TMD
        if not(iTMDTeam == iTMLTeam) then
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
                local oTMLBrain
                for iBrain, oBrain in M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                    oTMLBrain = oBrain
                    break
                end
                local tTeamNearbyTML = oTMLBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTML, oUnit:GetPosition(), iTMLMissileRange + 2, 'Ally')
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of TML in TML missile range of this unit empty='..tostring(M28Utilities.IsTableEmpty(tTeamNearbyTML))..'; iTMLMissileRange='..iTMLMissileRange..'; Unit position='..repru(oUnit:GetPosition())..'; oTMLBrain='..oTMLBrain.Nickname) end
                if M28Utilities.IsTableEmpty(tTeamNearbyTML) == false then
                    for iTML, oTML in tTeamNearbyTML do
                        RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oTML, tNearbyTMD) --This will do a distance check from the unit to the TMD
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordTMLAndTMDForEnemyUnitTargetJustDetected(oUnit, iTMLTeam)
    --Intended if an M28 TML owner detects an enemy target
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordTMLAndTMDForEnemyUnitTargetJustDetected'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local oTMDBrain = oUnit:GetAIBrain()
    local iTMDTeam = oTMDBrain.M28Team
    local tNearbyTMD = oTMDBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD, oUnit:GetPosition(), iTMLMissileRange + 2, 'Ally')



    if bDebugMessages == true then LOG(sFunctionRef..': Detected unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTMLTeam='..iTMLTeam..'; Is table of active brains empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains]))..'; TimeOfGame='..GetGameTimeSeconds()) end

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
        local oTMLBrain
        for iBrain, oBrain in M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
            oTMLBrain = oBrain
            break
        end
        local tTeamNearbyTML = oTMLBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTML, oUnit:GetPosition(), iTMLMissileRange + 2, 'Ally')
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of TML in missile range of this unit empty='..tostring(M28Utilities.IsTableEmpty(tTeamNearbyTML))..'; iTMLMissileRange='..iTMLMissileRange..'; Unit position='..repru(oUnit:GetPosition())..'; oTMLBrain.Nickname='..oTMLBrain.Nickname) end
        if M28Utilities.IsTableEmpty(tTeamNearbyTML) == false then --NOTE: If TML is firing from a cliff (big height dif) then it might not detect a unit that appears within its range, assuming due to targeting of units not being straightline ignoring height, but also factoring in height difs, with getunitsaroundpoint appearing to factor this in as well
            for iTML, oTML in tTeamNearbyTML do
                if bDebugMessages == true then LOG(sFunctionRef..': Are in range of oTML='..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)..'; will record if is protected by TMD') end
                RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oTML, tNearbyTMD) --This will do a distance check from the unit to the TMD
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function IsTMDProtectingUnitFromTML(oTMD, oUnit, oTML, iOptionalBuildingSize)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsTMDProtectingUnitFromTML'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iBuildingSize = iOptionalBuildingSize
    if not(iBuildingSize) then iBuildingSize = M28UnitInfo.GetBuildingSize(oUnit.UnitId) end
    local iUnitToTMD = M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), oUnit:GetPosition())
    if not(oTMD[M28UnitInfo.refiMissileDefenceRange]) then M28UnitInfo.RecordUnitRange(oTMD) end
    local iTMDRange = (oTMD[M28UnitInfo.refiMissileDefenceRange] or 12.5)

    --Reduce TMDRange to the effective range
    iTMDRange = iTMDRange - iBuildingSize


    local iUnitToTML = M28Utilities.GetDistanceBetweenPositions(oTML:GetPosition(), oUnit:GetPosition())
    local iTMDToTML = M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), oTML:GetPosition())

    local iAngleTMLToUnit = M28Utilities.GetAngleFromAToB(oTML:GetPosition(), oUnit:GetPosition())
    local iAngleTMLToTMD = M28Utilities.GetAngleFromAToB(oTML:GetPosition(), oTMD:GetPosition())
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if TMD '..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' is able to block the TML '..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)..' for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iUnitToTMD='..iUnitToTMD..'; iTMDRange reduced by building size='..iTMDRange..'; TMD recorded range='..(oUnit[M28UnitInfo.refiMissileDefenceRange] or 'nil')..'; iUnitToTML='..iUnitToTML..'; iTMDToTML='..iTMDToTML..'; iAngleTMLToUnit='..iAngleTMLToUnit..'; iAngleTMLToTMD='..iAngleTMLToTMD..'; Is line result='..tostring(M28Utilities.IsLineFromAToBInRangeOfCircleAtC(iUnitToTML, iTMDToTML, iUnitToTMD, iAngleTMLToUnit, iAngleTMLToTMD, iTMDRange))) end
    if M28Utilities.IsLineFromAToBInRangeOfCircleAtC(iUnitToTML, iTMDToTML, iUnitToTMD, iAngleTMLToUnit, iAngleTMLToTMD, iTMDRange) then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false

end

function RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oTML, tTMDInRange)
    --Updates the following variables: For TMD: reftUnitsCoveredByThisTMD; for TML: reftUnprotectedUnitTargetsForThisTML and reftUnitsInRangeOfThisTML; for units in range of TML: reftTMDCoveringThisUnit and reftTMLInRangeOfThisUnit
    --Assumes that oTML is in range of oUnit

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordIfUnitIsProtectedFromTMLByTMD'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bTMLAlreadyRecordedAgainstUnit = false
    local bUpdateZoneForUnitsWantingTMD = false
    if M28Utilities.IsTableEmpty(oUnit[reftTMLInRangeOfThisUnit]) == false then
        for iExistingTML, oExistingTML in oUnit[reftTMLInRangeOfThisUnit] do
            if oExistingTML == oTML then
                bTMLAlreadyRecordedAgainstUnit = true
                break
            end
        end
    end
    if not(bTMLAlreadyRecordedAgainstUnit) then
        if not(oUnit[reftTMLInRangeOfThisUnit]) then oUnit[reftTMLInRangeOfThisUnit] = {} end
        table.insert(oUnit[reftTMLInRangeOfThisUnit], oTML)
    end
    local bIsBlockedByTMD
    if bDebugMessages == true then LOG(sFunctionRef..': Near start at time '..GetGameTimeSeconds()..'; Considering if oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; is proitected from oTML '..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)..' by any of the TMD noted, is table of TMD empty='..tostring(M28Utilities.IsTableEmpty(tTMDInRange))) end
    local iBuildingSize = M28UnitInfo.GetBuildingSize(oUnit.UnitId)
    if M28Utilities.IsTableEmpty(tTMDInRange) == false then
        --[[local iUnitToTMD
        local iTMDRange
        local iUnitToTML, iTMDToTML, iAngleTMLToUnit, iAngleTMLToTMD--]]
        local bAlreadyRecordedTMD



        for iTMD, oTMD in tTMDInRange do
            if IsTMDProtectingUnitFromTML(oTMD, oUnit, oTML, iBuildingSize) then

                --TMD can block the TML
                bAlreadyRecordedTMD = false
                bIsBlockedByTMD = true
                if bDebugMessages == true then LOG(sFunctionRef..': oTMD='..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' can block the TML so will record it') end
                if not(oUnit[reftTMDCoveringThisUnit]) then oUnit[reftTMDCoveringThisUnit] = {}
                else
                    for iRecordedTMD, oRecordedTMD in oUnit[reftTMDCoveringThisUnit] do
                        if oRecordedTMD == oTMD then bAlreadyRecordedTMD = true  break end
                    end
                end
                if not(bAlreadyRecordedTMD) then
                    table.insert(oUnit[reftTMDCoveringThisUnit], oTMD)
                    if not(oTMD[reftUnitsCoveredByThisTMD]) then oTMD[reftUnitsCoveredByThisTMD] = {} end
                    table.insert(oTMD[reftUnitsCoveredByThisTMD], oUnit)
                    if bDebugMessages == true then LOG(sFunctionRef..': TMD '..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' recorded against oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' as covering it from TML') end
                end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': TMD '..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' doesnt block the TML') end
            end
        end
    end
    if not(bIsBlockedByTMD) then
        --None of the TMD are blocking the TML from hitting this unit; check if there are any other valid TMD that are covering this unit
        if M28Utilities.IsTableEmpty(oUnit[reftTMDCoveringThisUnit]) == false then
            for iTMD, oTMD in oUnit[reftTMDCoveringThisUnit] do
                if M28UnitInfo.IsUnitValid(oTMD) then
                    --Have we considered this TMD alreayd?
                    local bConsideredAbove = false
                    for iExistingTMD, oExistingTMD in tTMDInRange do
                        if oExistingTMD == oTMD then
                            bConsideredAbove = true
                            break
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': This unit has TMD recorded as covering it, oTMD='..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..'; bConsideredAbove='..tostring(bConsideredAbove)..'; Does the TMD cover the unit from this TML='..tostring(IsTMDProtectingUnitFromTML(oTMD, oUnit, oTML, iBuildingSize))) end
                    if not(bConsideredAbove) then
                        if IsTMDProtectingUnitFromTML(oTMD, oUnit, oTML, iBuildingSize) then
                            bIsBlockedByTMD = true
                            break
                        end
                    end
                end
            end
        end
    end
    if not(bIsBlockedByTMD) then
        local bAlreadyIncluded = false
        if not(oTML[reftUnprotectedUnitTargetsForThisTML]) or M28Utilities.IsTableEmpty(oTML[reftUnprotectedUnitTargetsForThisTML]) then
            oTML[reftUnprotectedUnitTargetsForThisTML] = {}

        else
            for iRecordedUnit, oRecordedUnit in oTML[reftUnprotectedUnitTargetsForThisTML] do
                if oRecordedUnit == oUnit then
                    bAlreadyIncluded = true
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Will record this unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' against table of unprotected units for TML as it isnt blocked by any of the TMD, bAlreadyIncluded='..tostring(bAlreadyIncluded or false)) end
        if not(bAlreadyIncluded) then
            table.insert(oTML[reftUnprotectedUnitTargetsForThisTML], oUnit)
            if oUnit:GetAIBrain().M28AI then
                RecordIfUnitsWantTMDCoverageAgainstLandZone(oUnit:GetAIBrain().M28Team, { oUnit })
            end
        end
    else
        --is covered by TMD, make sure not listed in reftUnprotectedUnitTargetsForThisTML, and reassess if we want the unit flagged as wanting TMD
        if bDebugMessages == true then LOG(sFunctionRef..': Unit is covered by TMD so will make sure not listed as an unprotected target against the TML, is table of unrptoected targets empty='..tostring(M28Utilities.IsTableEmpty(oTML[reftUnprotectedUnitTargetsForThisTML]))) end
        bUpdateZoneForUnitsWantingTMD = true
        if M28Utilities.IsTableEmpty(oTML[reftUnprotectedUnitTargetsForThisTML]) == false then
            for iExistingUnit, oExistingUnit in oTML[reftUnprotectedUnitTargetsForThisTML] do
                if oExistingUnit == oUnit then
                    if bDebugMessages == true then LOG(sFunctionRef..': This unit was previously recorded as an unprotected target, will remove') end
                    table.remove(oTML[reftUnprotectedUnitTargetsForThisTML], iExistingUnit)
                    break
                end
            end
        end
    end
    --Either way record unit as being in range of TML
    local bAlreadyIncluded = false
    if not(oTML[reftUnitsInRangeOfThisTML]) or M28Utilities.IsTableEmpty(oTML[reftUnitsInRangeOfThisTML]) then
        oTML[reftUnitsInRangeOfThisTML] = {}

    else
        for iRecordedUnit, oRecordedUnit in oTML[reftUnitsInRangeOfThisTML] do
            if oRecordedUnit == oUnit then
                bAlreadyIncluded = true
                break
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Will record this unit against the TML as being in range, unless already included, bAlreadyIncluded='..tostring(bAlreadyIncluded)) end
    if not(bAlreadyIncluded) then
        table.insert(oTML[reftUnitsInRangeOfThisTML], oUnit)
    end
    if bUpdateZoneForUnitsWantingTMD and oUnit:GetAIBrain().M28AI then
        RecordIfUnitsWantTMDCoverageAgainstLandZone(oUnit:GetAIBrain().M28Team, { oUnit })
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AlliedTMDFirstRecorded(iTeam, oTMD)
    --Have just recorded an allied TMD for a land zone - want to record all units within a long range that want protecting from TML if this provides protection from an enemy TML
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AlliedTMDFirstRecorded'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': oTMD '..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' has been identified, will reecord if are any enemy TML, is table of enemy TML empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyTML]))) end

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyTML]) == false then
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            if aiBrain then
                local tUnitsToProtect = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryProtectFromTML, oTMD:GetPosition(), iTMLMissileRange + 20, 'Ally')
                if M28Utilities.IsTableEmpty(tUnitsToProtect) == false then
                    local tOnLandUnits = {}
                    for iUnit, oUnit in tUnitsToProtect do
                        if not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                            table.insert(tOnLandUnits, oUnit)
                        end
                    end
                    if M28Utilities.IsTableEmpty(tOnLandUnits) == false then
                        UpdateTMDCoverageOfUnits(iTeam,{ oTMD }, tOnLandUnits)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TMLDied(oTML)
    --Updates tracking of the TML including for any units that had it recorded as being in range of them, and then checks if those units want TMD coverage (as there may no longer be any TML to protect from)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TMLDied'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': TML has just died, is the table of units in range of it empty='..tostring(M28Utilities.IsTableEmpty(oTML[reftUnitsInRangeOfThisTML]))) end
    local iTMLTeam = oTML:GetAIBrain().M28Team
    --Update each team that was tracking this
    for iTeam = 1, M28Team.iTotalTeamCount do
        if not(iTMLTeam == iTeam) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyTML]) == false then
            for iRecordedTML, oRecordedTML in M28Team.tTeamData[iTeam][M28Team.reftEnemyTML] do
                if oRecordedTML == oTML then
                    table.remove(M28Team.tTeamData[iTeam][M28Team.reftEnemyTML], iRecordedTML)
                end
            end
        end
    end
    --Update each unit that was tracking this:
    if M28Utilities.IsTableEmpty(oTML[reftUnitsInRangeOfThisTML]) == false then
        local tUnitsToUpdateByTeam = {}
        local iCurTeam
        for iUnit, oUnit in oTML[reftUnitsInRangeOfThisTML] do
            if M28UnitInfo.IsUnitValid(oUnit) then
                for iExistingTML, oExistingTML in oUnit[reftTMLInRangeOfThisUnit] do
                    if oExistingTML == oTML then
                        iCurTeam = oUnit:GetAIBrain().M28Team
                        if not(tUnitsToUpdateByTeam[iCurTeam]) then tUnitsToUpdateByTeam[iCurTeam] = {} end
                        table.insert(tUnitsToUpdateByTeam[iCurTeam], oUnit)
                        table.remove(oUnit[reftTMLInRangeOfThisUnit], iExistingTML)
                        break
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tUnitsToUpdateByTeam) == false then
            for iTeam, tUnitList in tUnitsToUpdateByTeam do
                RecordIfUnitsWantTMDCoverageAgainstLandZone(iTeam, tUnitList)
            end
        end
    end
end
function TMDDied(oTMD)
    --Updates any units that were relying on oTMD for protection from TML, and reassesses if those units want more TMD now
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TMDDied'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': TMD has just died, is the table of units covered by this TMD empty='..tostring(M28Utilities.IsTableEmpty(oTMD[reftUnitsCoveredByThisTMD]))) end
    if M28Utilities.IsTableEmpty(oTMD[reftUnitsCoveredByThisTMD]) == false then
        local tUnitsToCheckIfWantTMDCoverageByTeam = {}
        local iCurTeam
        for iUnit, oUnit in oTMD[reftUnitsCoveredByThisTMD] do
            if M28UnitInfo.IsUnitValid(oUnit) then
                for iRecordedTMD, oRecordedTMD in oUnit[reftTMDCoveringThisUnit] do
                    if oRecordedTMD == oTMD then
                        iCurTeam = oUnit:GetAIBrain().M28Team
                        if not(tUnitsToCheckIfWantTMDCoverageByTeam[iCurTeam]) then tUnitsToCheckIfWantTMDCoverageByTeam[iCurTeam] = {} end
                        table.insert(tUnitsToCheckIfWantTMDCoverageByTeam[iCurTeam], oUnit)
                        table.remove(oUnit[reftTMDCoveringThisUnit], iRecordedTMD)
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tUnitsToCheckIfWantTMDCoverageByTeam) == false then
            for iTeam, tUnitList in tUnitsToCheckIfWantTMDCoverageByTeam do
                RecordIfUnitsWantTMDCoverageAgainstLandZone(iTeam, tUnitList)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateTMDCoverageOfUnits(iTeam, tTMD, tUnitsToUpdate)
    --Goes through each unit in tUnitsToUpdate, and records any TMD in tTMD that can protect it from all TML in range of the unit
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateTMDCoverageOfUnits'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tAllEnemyTML = M28Team.tTeamData[iTeam][M28Team.reftEnemyTML]
    if M28Utilities.IsTableEmpty(tAllEnemyTML) == false then --redundancy
        local bTMDCoversFromAllTML
        local bCanBlockCurTML
        local bAlreadyRecordedTMD = false
        local bAlreadyRecordedAsWantingTMD
        local iUnitToTMD, iUnitToTML, iTMDToTML, iTMDRange, iBuildingSize, iAngleTMLToTMD, iAngleTMLToUnit
        local iUnitPlateau, iUnitLandZone
        for iUnit, oUnit in tUnitsToUpdate do
            if M28Utilities.IsTableEmpty(oUnit[reftTMLInRangeOfThisUnit]) == false then
                iBuildingSize = M28UnitInfo.GetBuildingSize(oUnit.UnitId)
                for iTMD, oTMD in tTMD do
                    bTMDCoversFromAllTML = true
                    iUnitToTMD = M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), oUnit:GetPosition())
                    if not(oTMD[M28UnitInfo.refiMissileDefenceRange]) then M28UnitInfo.RecordUnitRange(oTMD) end
                    iTMDRange = (oTMD[M28UnitInfo.refiMissileDefenceRange] or 12.5)

                    --Reduce TMDRange to the effective range
                    iTMDRange = iTMDRange - iBuildingSize

                    for iTML, oTML in oUnit[reftTMLInRangeOfThisUnit] do
                        bCanBlockCurTML = false
                        iUnitToTML = M28Utilities.GetDistanceBetweenPositions(oTML:GetPosition(), oUnit:GetPosition())
                        iTMDToTML = M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), oTML:GetPosition())

                        iAngleTMLToUnit = M28Utilities.GetAngleFromAToB(oTML:GetPosition(), oUnit:GetPosition())
                        iAngleTMLToTMD = M28Utilities.GetAngleFromAToB(oTML:GetPosition(), oTMD:GetPosition())
                        if M28Utilities.IsLineFromAToBInRangeOfCircleAtC(iUnitToTML, iTMDToTML, iUnitToTMD, iAngleTMLToUnit, iAngleTMLToTMD, iTMDRange) then
                            --TMD can block the TML
                            if bDebugMessages == true then LOG(sFunctionRef..': oTMD='..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' can block the TML so will record it') end
                            bCanBlockCurTML = true
                        end
                        if not(bCanBlockCurTML) then
                            bTMDCoversFromAllTML = false
                            break
                        end
                    end
                    if bTMDCoversFromAllTML then
                        if not(oUnit[reftTMDCoveringThisUnit]) then oUnit[reftTMDCoveringThisUnit] = {}
                        else
                            for iRecordedTMD, oRecordedTMD in oUnit[reftTMDCoveringThisUnit] do
                                if oRecordedTMD == oTMD then bAlreadyRecordedTMD = true  break end
                            end
                        end
                        if not(bAlreadyRecordedTMD) then
                            table.insert(oUnit[reftTMDCoveringThisUnit], oTMD)
                        end
                    end
                end
            end
        end
        RecordIfUnitsWantTMDCoverageAgainstLandZone(iTeam, tUnitsToUpdate)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordIfUnitsWantTMDCoverageAgainstLandZone(iTeam, tUnits)
    --Cycles through each unit in tUnits and if it has less TMD covering it than TML in range, makes sure it is reecorded in its land zone as one of the units wanting TMD
    --If it has sufficient TMD coverage, then instead makes sure it isnt recorded in its land zone as one of the units wanting TMD
    --Relies on otherfunctions for accurately recording TML in range of it and TMD giving coverage

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordIfUnitsWantTMDCoverageAgainstLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTMDInRange, iUnitPlateau, iUnitLandZone
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; size of tUnits='..table.getn(tUnits)..'; iTeam='..iTeam) end
    for iUnit, oUnit in tUnits do
        --Does the unit need TMD coverage?
        iTMDInRange = 0
        if M28Utilities.IsTableEmpty(oUnit[reftTMDCoveringThisUnit]) == false then
            --Treat Aeon as having twice the TMD power as other factions
            for iRecordedTMD, oRecordedTMD in oUnit[reftTMDCoveringThisUnit] do
                if M28UnitInfo.IsUnitValid(oRecordedTMD) then
                    if EntityCategoryContains(categories.AEON, oRecordedTMD.UnitId) then
                        iTMDInRange = iTMDInRange + 2
                    else
                        iTMDInRange = iTMDInRange + 1
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Considierng unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTMDInRange='..iTMDInRange..'; TML in range='..table.getn((oUnit[reftTMLInRangeOfThisUnit] or {}))..'; oUnit[refbUnitWantsMoreTMD]='..tostring(oUnit[refbUnitWantsMoreTMD] or false)) end
        local iTMLValueInRangeOfUnit = 0
        if M28Utilities.IsTableEmpty(oUnit[reftTMLInRangeOfThisUnit]) == false then
            for iRecordedTML, oRecordedTML in oUnit[reftTMLInRangeOfThisUnit] do
                if M28UnitInfo.IsUnitValid(oRecordedTML) then
                    --UEF ACU with billy nuke upgrade - increase value
                    if EntityCategoryContains(categories.COMMAND * categories.UEF, oRecordedTML.UnitId) and oRecordedTML.HasEnhancement and oRecordedTML:HasEnhancement('TacticalNukeMissile') then
                        if bDebugMessages == true then LOG(sFunctionRef..': ENemy unit owned by brain '..oRecordedTML:GetAIBrain().Nickname..' has a billy nuke') end
                        iTMLValueInRangeOfUnit = iTMLValueInRangeOfUnit + 4
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMissileShip * categories.AEON, oRecordedTML.UnitId) then
                        --Aeon missile ship
                        iTMLValueInRangeOfUnit = iTMLValueInRangeOfUnit + 3
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMML * categories.TECH2, oRecordedTML.UnitId) then
                        iTMLValueInRangeOfUnit = iTMLValueInRangeOfUnit + 0.75
                    else
                        iTMLValueInRangeOfUnit = iTMLValueInRangeOfUnit + 1
                    end
                end
            end
        end

        if iTMDInRange < iTMLValueInRangeOfUnit and not(oUnit[refbNoNearbyTMDBuildLocations]) then
            if not(oUnit[refbUnitWantsMoreTMD]) then --redundancy (i.e. will ahve already called below if unit is already flagged as wanting more TMD)
                iUnitPlateau, iUnitLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                if bDebugMessages == true then LOG(sFunctionRef..': Want TMD for this unit, iUnitPlateau='..(iUnitPlateau or 'nil')..'; iUnitLandZone='..(iUnitLandZone or 'nil')) end
                if iUnitLandZone > 0 then
                    local tLZTeamData = M28Map.tAllPlateaus[iUnitPlateau][M28Map.subrefPlateauLandZones][iUnitLandZone][M28Map.subrefLZTeamData][iTeam]
                    table.insert(tLZTeamData[M28Map.reftUnitsWantingTMD], oUnit)
                end
                oUnit[refbUnitWantsMoreTMD] = true
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Have enough TMD covering this unit, unit wants more TMD flag='..tostring(oUnit[refbUnitWantsMoreTMD] or false)) end
            if oUnit[refbUnitWantsMoreTMD] then --i.e. unit previously was flagged as needing more TMD (but now it doesnt)
                --Remove this unit from the land zone list of units wanting TMD
                iUnitPlateau, iUnitLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                if iUnitLandZone > 0 then
                    local tLZTeamData = M28Map.tAllPlateaus[iUnitPlateau][M28Map.subrefPlateauLandZones][iUnitLandZone][M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont want TMD for this unit, iUnitPlateau='..(iUnitPlateau or 'nil')..'; iUnitLandZone='..(iUnitLandZone or 'nil')..'; is table of LZ units wanting TMD empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]))) end
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]) == false then
                        --Remove htis unit from the list of units wanting TMD
                        for iRecordedUnit, oRecordedUnit in tLZTeamData[M28Map.reftUnitsWantingTMD] do
                            if bDebugMessages == true then LOG(sFunctionRef..': oRecordedUnit='..oRecordedUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRecordedUnit)) end
                            if oRecordedUnit == oUnit then
                                table.remove(tLZTeamData[M28Map.reftUnitsWantingTMD], iRecordedUnit)
                                if bDebugMessages == true then LOG(sFunctionRef..': Have removed from units wanting TMD in zone, is table of units wanting TMD empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]))) end
                                break
                            end
                        end
                    end
                end
                oUnit[refbUnitWantsMoreTMD] = false
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateLZUnitsWantingTMDForUnitDeath(oUnit)
    --Updates any units currently recorded as wanting TMD to see if htey still want TMD based on TMD coverage
    local iUnitPlateau, iUnitLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
    if iUnitLandZone > 0 then
        local iTeam = oUnit:GetAIBrain().M28AITeam
        local tLZTeamData = M28Map.tAllPlateaus[iUnitPlateau][M28Map.subrefPlateauLandZones][iUnitLandZone][M28Map.subrefLZTeamData][iTeam]
        --Remove all dead units from the table (not just this one) as extra redundancy
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]) == false then
            local iRevisedIndex = 1
            local iTableSize = table.getn(tLZTeamData[M28Map.reftUnitsWantingTMD])

            for iOrigIndex=1, iTableSize do
                if tLZTeamData[M28Map.reftUnitsWantingTMD][iOrigIndex] then
                    if M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.reftUnitsWantingTMD][iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                        --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                        if (iOrigIndex ~= iRevisedIndex) then
                            tLZTeamData[M28Map.reftUnitsWantingTMD][iRevisedIndex] = tLZTeamData[M28Map.reftUnitsWantingTMD][iOrigIndex]
                            tLZTeamData[M28Map.reftUnitsWantingTMD][iOrigIndex] = nil
                        end
                        iRevisedIndex = iRevisedIndex + 1 --i.e. this will be the position of where the next value that we keep will be located
                    else
                        tLZTeamData[M28Map.reftUnitsWantingTMD][iOrigIndex] = nil
                    end
                end
            end
            if iRevisedIndex < iTableSize then
                --table.setn(tLZTeamData[M28Map.reftUnitsWantingTMD], iRevisedIndex - 1)
                for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
                    table.remove(tLZTeamData[M28Map.reftUnitsWantingTMD], iRemovalEntry)
                end
            end
        end
    end
    oUnit[refbUnitWantsMoreTMD] = false --redundancy
end

function GetUnitWantingTMD(tLZData, tLZTeamData, iTeam, iOptionalLandZone)
    --Gets the unit closest to the nearest enemy base that wants TMD; also refreshes the table for any dead units
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnitWantingTMD'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Cap on number of TMD to prvent massiveo verbuilding - dont have more than 10 in a LZ
    local tExistingTMD = EntityCategoryFilterDown(M28UnitInfo.refCategoryTMD, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of existing TMD empty='..tostring(M28Utilities.IsTableEmpty(tExistingTMD))..'; iOptionalLandZone='..(iOptionalLandZone or 'nil')..'; Time='..GetGameTimeSeconds()) end
    if M28Utilities.IsTableEmpty(tExistingTMD) == false then
        local iExistingValidTMD = table.getn(tExistingTMD)

        --Max TMD limit - no. of mexes in the zone * 0.5 if lower; also higher TMD if we have Aeon TMD
        local iTMDLimit = math.min(30, math.max(10, (tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3]) * 0.5, tLZTeamData[M28Map.subrefLZSValue] / 5000))
        if not(tLZTeamData[M28Map.subrefLZbCoreBase]) then iTMDLimit = math.min(iTMDLimit, math.max(4, tLZTeamData[M28Map.subrefMexCountByTech][3] * 2 + tLZTeamData[M28Map.subrefMexCountByTech][2], tLZTeamData[M28Map.subrefLZSValue] / 5000)) end
        if bDebugMessages == true then LOG(sFunctionRef..': iExistingValidTMD='..iExistingValidTMD..'; iTMDLimit='..iTMDLimit) end
        if iExistingValidTMD >= iTMDLimit then
            local iEnemyTotalTMLCount = 0
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyTML]) == false then
                iEnemyTotalTMLCount = table.getn(M28Team.tTeamData[iTeam][M28Team.reftEnemyTML])
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iEnemyTotalTMLCount='..iEnemyTotalTMLCount) end
            if iExistingValidTMD > math.min(31, iTMDLimit + (iEnemyTotalTMLCount - 1) * 2) then
                --Too much TMD already, clear any units wanting TMD; send error message if we have loads of TMD
                if iExistingValidTMD >= 10 then
                    M28Utilities.ErrorHandler('Have at least TMD in land zone so wont build any more TMD, risk we may be overbuilding TMD, will clear entries', true)
                end
                tLZTeamData[M28Map.reftUnitsWantingTMD] = {}
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return nil
            end
        end
    end

    local iUnitsWantingTMD = table.getn(tLZTeamData[M28Map.reftUnitsWantingTMD])
    local iClosestDist = 10000
    local iCurDist
    local oClosestUnit
    local tEnemyBase = tLZTeamData[M28Map.reftClosestEnemyBase]
    for iEntry = iUnitsWantingTMD, 1, -1 do
        if not(M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry])) then
            table.remove(tLZTeamData[M28Map.reftUnitsWantingTMD], iEntry)
        else
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tEnemyBase, tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry]:GetPosition())
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if unit '..tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry].UnitId..M28UnitInfo.GetUnitLifetimeCount(tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry])..' is the closest, iCurDist='..iCurDist..'; iCLosestDist='..iClosestDist..'; refbUnitWantsMoreTMD='..tostring(tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry][refbUnitWantsMoreTMD])) end
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestUnit = tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry]
            end
        end
    end

    if bDebugMessages == true then
        LOG(sFunctionRef..': End of code, oClosestUnit='..(oClosestUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestUnit) or 'nil')..'; Is table of TML in range of this unit empty='..tostring(M28Utilities.IsTableEmpty(oClosestUnit[reftTMLInRangeOfThisUnit]))..'; Is reftTMDCoveringThisUnit empty='..tostring(M28Utilities.IsTableEmpty(oClosestUnit[reftTMDCoveringThisUnit])))
        if oClosestUnit then
            for iTML, oTML in oClosestUnit[reftTMLInRangeOfThisUnit] do
                LOG(sFunctionRef..': oTML in range='..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)..'; Dist='..M28Utilities.GetDistanceBetweenPositions(oTML:GetPosition(), oClosestUnit:GetPosition())..'; TML range='..(oTML[M28UnitInfo.refiIndirectRange] or oTML[M28UnitInfo.refiManualRange] or 'nil'))
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oClosestUnit
end


function RecordPriorityShields(iTeam, tLZTeamData)
    --Records shields that want to ahve engineers assisting
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordPriorityShields'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if GetGameTimeSeconds() - (tLZTeamData[M28Map.refiTimeOfLastShieldPriorityRefresh] or -100) >= 10 then
        tLZTeamData[M28Map.refiTimeOfLastShieldPriorityRefresh] = GetGameTimeSeconds()
        local tShieldsToAssist = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        --First clear any engineers assigned to shields that arent listed as a priority shield from the last update
        if bDebugMessages == true then LOG(sFunctionRef..': WIll refresh list of shields. Is table empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssist))..'; do we already have any priority shields when when last ran this? is table empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]))) end
        if M28Utilities.IsTableEmpty(tShieldsToAssist) == false then
            local tTemporaryPriorityShields = {}
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]) == false then
                for iShield, oShield in tShieldsToAssist do
                    if M28Utilities.IsTableEmpty(oShield[M28UnitInfo.reftoUnitsAssistingThis]) == false and not(oShield[refbPriorityShield]) then
                        local bClearShield = true
                        if oShield[refbRemoveShieldFromPriorityTableWhenFullHealth] then
                            bClearShield = false
                            local iCurShieldHealth, iCurShieldMaxHealth = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                            if iCurShieldHealth / iCurShieldMaxHealth >= 0.99 then
                                bClearShield = true
                            end
                            if not(bClearShield) then
                                table.insert(tTemporaryPriorityShields, oShield)
                            else
                                oShield[refbRemoveShieldFromPriorityTableWhenFullHealth] = nil
                            end
                        end
                        if bClearShield then
                            --Shield wasnt a priority shield in the last cycle but has engineers assigned to assist it - will clear these engineers
                            local tEngineersToClear = {}
                            for iEngi, oEngi in oShield[M28UnitInfo.reftoUnitsAssistingThis] do
                                table.insert(tEngineersToClear, oEngi)
                            end
                            for iAssistingEngineer, oAssistingEngineer in tEngineersToClear do
                                if M28UnitInfo.IsUnitValid(oAssistingEngineer) then M28Orders.IssueTrackedClearCommands(oAssistingEngineer) end
                            end
                            oShield[M28UnitInfo.reftoUnitsAssistingThis] = nil
                        end
                    end
                end
            end

            tLZTeamData[M28Map.reftPriorityShieldsToAssist] = {}
            if M28Utilities.IsTableEmpty(tTemporaryPriorityShields) == false then
                for iShield, oShield in tTemporaryPriorityShields do
                    table.insert(tLZTeamData[M28Map.reftPriorityShieldsToAssist], oShield)
                end
            end
            local iTotalUnitMassCoverage
            local iCurMassValue
            local bConsiderRecentlyDamagedShields = false
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates]) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 300 then bConsiderRecentlyDamagedShields = true end
            for iShield, oShield in tShieldsToAssist do
                iTotalUnitMassCoverage = 0
                if bDebugMessages == true then LOG(sFunctionRef..': Considering shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; size of table of units nearby='..table.getn(oShield[reftoUnitsCoveredByShield])) end
                if M28Utilities.IsTableEmpty(oShield[reftoUnitsCoveredByShield]) == false and not(oShield[reftArtiTemplateRefs]) and not(oShield[refbRemoveShieldFromPriorityTableWhenFullHealth]) then
                    --Only flag a shield for assistance if its health is <80%
                    local iCurShieldHealth, iMaxShieldHealth = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Shield health='..iCurShieldHealth..'; Max health='..iMaxShieldHealth) end
                    if iCurShieldHealth > 0 and (iCurShieldHealth / iMaxShieldHealth <= 0.8 or (bConsiderRecentlyDamagedShields and oShield[M28UnitInfo.refiTimeLastDamaged] and GetGameTimeSeconds() - (oShield[M28UnitInfo.refiTimeLastDamaged] or -100) <= 30)) then

                        for iUnit, oUnit in oShield[reftoUnitsCoveredByShield] do
                            if not(oUnit == oShield) then
                                if EntityCategoryContains(M28UnitInfo.refCategorySMD, oUnit.UnitId) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false then
                                    iCurMassValue = 30000
                                elseif EntityCategoryContains(M28UnitInfo.refCategorySML, oUnit.UnitId) then
                                    iCurMassValue = 27500
                                else
                                    iCurMassValue = (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
                                end
                                if not(oUnit[refoPriorityShieldProvidingCoverage] == oShield) and M28UnitInfo.IsUnitValid(oUnit[refoPriorityShieldProvidingCoverage]) then
                                    iCurMassValue = iCurMassValue * 0.1
                                    if bDebugMessages == true then LOG(sFunctionRef..': Already have a priority shield providing coverage='..oUnit[refoPriorityShieldProvidingCoverage].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[refoPriorityShieldProvidingCoverage])..' so will reduce mass value') end
                                end
                                iTotalUnitMassCoverage = iTotalUnitMassCoverage + iCurMassValue
                                if bDebugMessages == true then LOG(sFunctionRef..': Getting shield protection mass value of oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' for oShield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; iCurMassValue='..iCurMassValue..'; iTotalUnitMassCoverage='..iTotalUnitMassCoverage..'; Is there already a valid shield protecting it='..tostring(M28UnitInfo.IsUnitValid(oUnit[refoPriorityShieldProvidingCoverage]))) end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iTotalUnitMassCoverage='..iTotalUnitMassCoverage..'; refiAssignedFirebase='..(oShield[refiAssignedFirebase] or 'nil')) end
                        if iTotalUnitMassCoverage >= 25000 then
                            --Add as a priority shield
                            table.insert(tLZTeamData[M28Map.reftPriorityShieldsToAssist], oShield)
                            oShield[refbPriorityShield] = true
                            for iUnit, oUnit in oShield[reftoUnitsCoveredByShield] do
                                oUnit[refoPriorityShieldProvidingCoverage] = oShield --Deliberately overwrites existing value, means if 2 shields cover same area, and one can justify it even with the ot her, but the other cant, then we wont protect the other
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding the shield as a priority shield') end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function OnMexDeath(tUnitPosition, sUnitRef, sLifetimeCount, iOwnerArmyIndex)
    --Call via fork thread due to the WaitSeconds() in it; however note that as this is forked, the unit (mex) may not exist anymore, so tUnitPosition needs to be a copy of the position table, and dont want to pass the unit object
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OnMexDeath'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; tUnitPosition='..repru(tUnitPosition)) end



    --local tUnitPosition = {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]}
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tUnitPosition)
    local tMexLocations
    local tLZOrWZData
    local iWaterZone, iPond



    if iPlateau and not(iLandZone) then
        iWaterZone = M28Map.GetWaterZoneFromPosition(tUnitPosition)
        if iWaterZone then
            iPond = M28Map.tiPondByWaterZone[iWaterZone]
            tLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
            tMexLocations = tLZOrWZData[M28Map.subrefWZMexLocations]
        end
    else
        tLZOrWZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
        tMexLocations = tLZOrWZData[M28Map.subrefLZMexLocations]
    end



    if bDebugMessages == true then LOG(sFunctionRef..': is table of mex locations empty='..tostring( M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]))..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; tUnitPosition='..repru(tUnitPosition)..'; is tMexLocations empty='..tostring(M28Utilities.IsTableEmpty(tMexLocations))..'; iWaterZone='..(iWaterZone or 'nil')) end
    if M28Utilities.IsTableEmpty(tMexLocations) == false then
        --Record time of last mex death against LZ data to help with error messages
        tLZOrWZData[M28Map.refiTimeOfLastMexDeath] = GetGameTimeSeconds()

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1) --dont treat mex as available for a second (this is to help cover scenarios where if a mex has 'died' due to being upgraded, the new building will be here) - was a 2s delay, are trying 1s delay now to see if causes an issue
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        local tClosestMexLocation
        local iClosestMexLocation = 2.1 --no point considering mexes further away
        local iCurAbsDif
        for iEntry, tMex in tLZOrWZData[M28Map.subrefLZMexLocations] do --(WZ uses same ref ID definition)
            iCurAbsDif = math.abs(tMex[1] - tUnitPosition[1]) + math.abs(tMex[3] - tUnitPosition[3])
            if iCurAbsDif < iClosestMexLocation then
                iClosestMexLocation = iCurAbsDif
                tClosestMexLocation = {tMex[1], tMex[2], tMex[3]}
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting a period of time and then searching for closest mex location, tClosestMexLocation='..repru(tClosestMexLocation)..'; Time='..GetGameTimeSeconds()..'; iPlateau='..iPlateau..'; iLandZone='..(iLandZone or 'nil')) end
        if not(tClosestMexLocation) then M28Utilities.ErrorHandler('Couldnt find a mex in this zone close enough to the unit position on death')
        else
            --for iMexLocation, tMexLocation in tMexLocations do
            --Prev line - redid at same time as changing approach for removing an unbuilt location to try and be more accurate
            --if M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition()) <= 0.9 then
            --Revised line:
            --if tMexLocation[1] == tClosestMexLocation[1] and tMexLocation[3] == tClosestMexLocation[3] then
            --Do we have any mexes in this location?
            local rRect = M28Utilities.GetRectAroundLocation(tClosestMexLocation, 0.9)
            local tUnitsInRect = GetUnitsInRect(rRect)
            if bDebugMessages == true then
                LOG(sFunctionRef..': Is tUnitsInRect empty='..tostring(M28Utilities.IsTableEmpty(tUnitsInRect)))
                if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                    LOG(sFunctionRef..': If filter to just mexes is the table empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tUnitsInRect))))
                end
            end
            local bNoMex = true
            if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                local tMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tUnitsInRect)
                if M28Utilities.IsTableEmpty(tMexes) == false then
                    for iMex, oMex in tMexes do
                        if M28UnitInfo.IsUnitValid(oMex) and not(oMex.UnitId == sUnitRef and M28UnitInfo.GetUnitLifetimeCount(oMex) == sLifetimeCount and oMex:GetAIBrain():GetArmyIndex() == iOwnerArmyIndex) then
                            local tMexPosition = oMex:GetPosition()
                            --Get closest mex to this, in case there's another mex that's closer
                            local iCurMexClosestLocation = 2.1
                            local tCurMexClosestLocation
                            for iEntry, tMex in tLZOrWZData[M28Map.subrefLZMexLocations] do --(WZ uses same ref ID definition)
                                iCurAbsDif = math.abs(tMex[1] - tMexPosition[1]) + math.abs(tMex[3] - tMexPosition[3])
                                if iCurAbsDif < iCurMexClosestLocation then
                                    iCurMexClosestLocation = iCurAbsDif
                                    tCurMexClosestLocation = {tMex[1], tMex[2], tMex[3]}
                                end
                            end
                            if tCurMexClosestLocation[1] == tClosestMexLocation[1] and tCurMexClosestLocation[3] == tClosestMexLocation[3] then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have a valid mex in this location, oMex='..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)..'; Army Index='..oMex:GetAIBrain():GetArmyIndex()..'; sUnitRef='..sUnitRef..'; sLifetimeCount='..sLifetimeCount..'; iOwnerArmyIndex='..(iOwnerArmyIndex or 'nil')..'; tCurMexClosestLocation='..repru(tCurMexClosestLocation)..'; Mex position='..repru(oMex:GetPosition())..'; tUnitPosition='..repru(tUnitPosition)..'; tClosestMexLocation='..repru(tClosestMexLocation)) end
                                bNoMex = false
                                break
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if we have a mex at this location anymore, bNoMex='..tostring(bNoMex)) end
            if bNoMex then
                local bAlreadyRecorded = false
                if not(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) then
                    tLZOrWZData[M28Map.subrefMexUnbuiltLocations] = {}
                else
                    for iEntry, tUnbuiltLocation in tLZOrWZData[M28Map.subrefMexUnbuiltLocations] do --redundancy in case this code triggers more than once, as were comign across unbuilt locations with the same entry listed more than once (although it wasnt showing up with a reprs/repru)
                        if tUnbuiltLocation[1] == tClosestMexLocation[1] and tUnbuiltLocation[3] == tClosestMexLocation[3] then
                            bAlreadyRecorded = true
                            break
                        end
                    end
                end
                if not(bAlreadyRecorded) then
                    table.insert(tLZOrWZData[M28Map.subrefMexUnbuiltLocations], tClosestMexLocation)
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Recording location as being unbuilt as mex is dead and no mexes visible there now, tClosestMexLocation='..repru(tClosestMexLocation))
                        M28Utilities.DrawLocation(tClosestMexLocation)
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Already recorded this location as unbuilt') end
                end
                --break
            end
            --end
            --end
        end
        if bDebugMessages == true then
            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) then LOG(sFunctionRef..': tLZOrWZData[M28Map.subrefMexUnbuiltLocations] after update is empty')
            else LOG(sFunctionRef..': tLZOrWZData[M28Map.subrefMexUnbuiltLocations] after update has a size '..table.getn(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])..', table='..repru(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]))
            end
        end
    else
        M28Utilities.ErrorHandler('Mex has died but not in a recognised land or water zone that has mexes')
    end

    --Track mexes by team

    local iTeam
    local oOwnerBrain
    for iBrain, oBrain in ArmyBrains do
        if iBrain == iOwnerArmyIndex then
            oOwnerBrain = oBrain
            iTeam = oBrain.M28Team
            break
        end
    end
    if iTeam then
        local iMexTech = M28UnitInfo.GetBlueprintTechLevel(sUnitRef)
        M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][iMexTech] = (M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][iMexTech] or 0) - 1
    else
        if not(oOwnerBrain) or not(M28Conditions.IsCivilianBrain(oOwnerBrain)) then
            M28Utilities.ErrorHandler('Mex death for a brain that doesnt have a team, oOwnerBrain='..(oOwnerBrain.Nickname or 'nil'))
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function OnMexConstructionStarted(oUnit)
    --Run for all brains

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OnMexConstructionStarted'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --If 100% complete mex and fullshare is enabled then wait 2 ticks before running logic due to issue where the new unit cna be created before the logic re the old one dying triggers
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..'; Is game in full share='..tostring(ScenarioInfo.Options.Share == 'FullShare')..'; Time since last teammate death='..(GetGameTimeSeconds() - (M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiTimeOfLastTeammateDeath] or 0))..'; Fraction complete='..oUnit:GetFractionComplete()) end
    if oUnit:GetFractionComplete() == 1 and ScenarioInfo.Options.Share == 'FullShare' and GetGameTimeSeconds() - (M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiTimeOfLastTeammateDeath] or 0) <= 20 then
        if bDebugMessages == true then LOG(sFunctionRef..': A player has recently died so delaying logic for mex that is fully complete') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(3)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    if not(M28Map.bMapLandSetupComplete) or GetGameTimeSeconds() <= 4 or not(M28Map.bWaterZoneInitialCreation) then
        while (not(M28Map.bMapLandSetupComplete) or GetGameTimeSeconds() <= 4 or not(M28Map.bWaterZoneInitialCreation)) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if GetGameTimeSeconds() >= 6 then break end
        end
    end

    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
    local tMexLocations
    local tLZOrWZData
    local iWaterZone, iPond



    if iPlateau and not(iLandZone) then
        iWaterZone = M28Map.GetWaterZoneFromPosition(oUnit:GetPosition())
        if iWaterZone then
            iPond = M28Map.tiPondByWaterZone[iWaterZone]
            tLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
            tMexLocations = tLZOrWZData[M28Map.subrefWZMexLocations]
        end
    else
        tLZOrWZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
        tMexLocations = tLZOrWZData[M28Map.subrefLZMexLocations]
    end

    if bDebugMessages == true then LOG(sFunctionRef..': The time is '..GetGameTimeSeconds()..'; Have just started construction for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'; Is M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]))..'; Unit position='..repru(oUnit:GetPosition())..'; Unit brain='..oUnit:GetAIBrain().Nickname..'; on team '..(oUnit:GetAIBrain().M28Team or 'nil')) end
    local bFoundMexLocation = false
    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false then
        --Find the closest mex location in the zone
        local tClosestMexLocation
        local iClosestMexLocation = 2.1 --no point considering mexes further away
        local iCurAbsDif
        local tUnitPosition = oUnit:GetPosition()
        for iEntry, tMex in tLZOrWZData[M28Map.subrefLZMexLocations] do --(WZ uses same ref ID definition)
            iCurAbsDif = math.abs(tMex[1] - tUnitPosition[1]) + math.abs(tMex[3] - tUnitPosition[3])
            if iCurAbsDif < iClosestMexLocation then
                iClosestMexLocation = iCurAbsDif
                tClosestMexLocation = {tMex[1], tMex[2], tMex[3]}
            end
        end


        local iSizeBefore = table.getn(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])
        if bDebugMessages == true then LOG('About to loop through Mex locations; iPlateau='..iPlateau..'; iLandZone='..(iLandZone or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'; reprs='..reprs(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])..'; iSizeBefore='..iSizeBefore..'; tClosestMexLocation='..repru(tClosestMexLocation)) end
        --local iSizeAfter
        --local iLocationToRemove
        if bDebugMessages == true then
            for iMexLocation, tMexLocation in tLZOrWZData[M28Map.subrefMexUnbuiltLocations] do
                LOG(sFunctionRef..': iMexLocation='..iMexLocation..'; tMexLocation='..repru(tMexLocation))
            end
        end
        if tClosestMexLocation then
            for iEntry = iSizeBefore, 1, -1 do
                local tMexLocation = tLZOrWZData[M28Map.subrefMexUnbuiltLocations][iEntry]
                if bDebugMessages == true then LOG(sFunctionRef..': Comparing dist for iEntry '..iEntry..'; tMexLocation='..repru(tMexLocation)..'; tClosestMexLocation='..repru(tClosestMexLocation)) end
                if tMexLocation[1] == tClosestMexLocation[1] and tMexLocation[3] == tClosestMexLocation[3] then
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Have built a mex within 1 of a mex location so will treat this mex location as no longer available. iEntry='..iEntry)
                        M28Utilities.DrawLocation(tMexLocation, 2)
                    end
                    bFoundMexLocation = true
                    local vRemoved = table.remove(tLZOrWZData[M28Map.subrefMexUnbuiltLocations], iEntry)
                    if bDebugMessages == true then LOG(sFunctionRef..': tLZOrWZData[M28Map.subrefMexUnbuiltLocations] after removal='..repru(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])..'; vRemoved='..reprs(vRemoved)..'; iSizeBefore='..iSizeBefore) end
                    break
                end
            end
        else
            M28Utilities.ErrorHandler('Couldnt find a mex location close enough')
        end
        --Old code - had issues with this sometimes where e.g. would have a table that with reprs showed as only having 1 entry, but it actually had 2 and were identical
        --[[for iMexLocation, tMexLocation in tLZOrWZData[M28Map.subrefMexUnbuiltLocations] do
            --Old code commented out below caused issues on maps like sludge:
            --if M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition()) <= 2 then
            --Replaced with the following:
            if bDebugMessages == true then LOG(sFunctionRef..': Considering tMexLocation='..repru(tMexLocation)..'; compared with Unit position '..repru(oUnit:GetPosition())) end
            if math.abs(tMexLocation[1] - oUnit:GetPosition()[1]) < 1 and math.abs(tMexLocation[3] - oUnit:GetPosition()[3]) < 1 then
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Have built a mex within 1 of a mex location so will treat this mex location as no longer available. iMexLocation='..iMexLocation)
                    M28Utilities.DrawLocation(tMexLocation, 2)
                end
                bFoundMexLocation = true
                iLocationToRemove = iMexLocation
                break
            end
        end
        if iLocationToRemove then
            local vRemoved = table.remove(tLZOrWZData[M28Map.subrefMexUnbuiltLocations], iLocationToRemove)
            local iSizeAfter
            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) then iSizeAfter = 0
            else iSizeAfter = table.getn(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])
            end
            if bDebugMessages == true then LOG(sFunctionRef..': tLZOrWZData[M28Map.subrefMexUnbuiltLocations] after removal='..repru(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])..'; vRemoved='..reprs(vRemoved)..'; iSizeBefore='..iSizeBefore..'; iSizeAfter='..iSizeAfter) end
        end
        if iSizeAfter >= iSizeBefore then
            --Backup for strange case where table.remove would remove a table but the table would still remain

        end--]]
    end
    if not(bFoundMexLocation) then
        --Is the reason we cant find any unbuilt locations because a mex is being upgraded? Doing a reprs of a mex being upgraded, CanTakeDamage was false and IsUpgrade was true, so use these to check
        if oUnit.CanTakeDamage and not(oUnit.IsUpgrade) and (GetGameTimeSeconds() - (tLZOrWZData[M28Map.refiTimeOfLastMexDeath] or 0)) > 2.1 then
            --Ignore if early game and is owned by non-human brain, or campaign and owned by non-M28AI non-human brain
            if oUnit:GetAIBrain().BrainType == 'Human' or oUnit:GetAIBrain().M28AI or (GetGameTimeSeconds() >= 10 and not(M28Map.bIsCampaignMap)) then
                local tNearbyRect = M28Utilities.GetRectAroundLocation(oUnit:GetPosition(), 0.49)
                local tUnitsWhereDied = GetUnitsInRect(tNearbyRect)
                local bHaveMexHere = false
                if M28Utilities.IsTableEmpty(tNearbyRect) == false then
                    for iBuilding, oBuilding in tNearbyRect do
                        if not(oBuilding == oUnit) and EntityCategoryContains(M28UnitInfo.refCategoryMex, oBuilding.UnitId) and M28UnitInfo.IsUnitValid(oBuilding) then
                            bHaveMexHere = true
                            break
                        end
                    end
                end
                if not(bHaveMexHere) then
                    --we have a 1s delay on a mex dying before checking for available locations, so this could explain this
                    if tLZOrWZData[M28Map.refiTimeOfLastMexDeath] and GetGameTimeSeconds() - tLZOrWZData[M28Map.refiTimeOfLastMexDeath] > 1.01 then
                        M28Utilities.ErrorHandler('OnCreate triggered for a mex but no unbuilt locations near it, iPlateau='..iPlateau..'; iLandZone='..(iLandZone or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'; Map setup complete='..tostring(M28Map.bMapLandSetupComplete)..'; bWaterZoneInitialCreation='..tostring(M28Map.bWaterZoneInitialCreation or false), true)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': tLZOrWZData[M28Map.subrefMexUnbuiltLocations]='..repru(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit position='..repru(oUnit:GetPosition())) end
                end
            end
        end
    end

    --Add mex to enemy unit table if underwater, due to flaw with current approach - i.e. to reduce overhead all AI regardless of team use the same table for if a mex has been built; engineers are meant to either build on unbuilt mexes, or try and reclaim if the enemy is there; however without this step they effectively end up thinking a teammate has the mex so they never tyr sending an engineer to build or capture.  For land it's not an issue as would expect land scouts or other land units to reveal the mexes anyway
    if iWaterZone > 0 then
        local tTeamsUpdated = {}
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.subreftoEnemyBrains]) == false then
            for iBrain, oBrain in M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.subreftoEnemyBrains] do
                if oBrain.M28AI and not(tTeamsUpdated[oBrain.M28Team]) then
                    tTeamsUpdated[oBrain.M28Team] = true
                    --(aiBrain, oUnit, bAlreadyUpdatedPosition, bAlreadyTriedReassignment, bIgnoreIfAssignedAlready)
                    M28Team.AssignUnitToLandZoneOrPond(oBrain, oUnit, false,                    false,                      true)
                end
            end
        else
            --E.g. civilians that own mexes
            local iMexBrainIndex = oUnit:GetAIBrain():GetArmyIndex()
            for iBrain, oBrain in ArmyBrains do
                if not(IsAlly(oBrain:GetArmyIndex(), iMexBrainIndex)) then
                    if oBrain.M28AI and not(tTeamsUpdated[oBrain.M28Team]) then
                        tTeamsUpdated[oBrain.M28Team] = true
                        --(aiBrain, oUnit, bAlreadyUpdatedPosition, bAlreadyTriedReassignment, bIgnoreIfAssignedAlready)
                        M28Team.AssignUnitToLandZoneOrPond(oBrain, oUnit, false,                    false,                      true)
                    end
                end
            end
        end
    end

    --Track mexes by team
    local iTeam = oUnit:GetAIBrain().M28Team
    if iTeam then
        local iMexTech = M28UnitInfo.GetUnitTechLevel(oUnit)
        if not(M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech]) then
            M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech] = {}
        end
        M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][iMexTech] = (M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][iMexTech] or 0) + 1
    elseif not(M28Conditions.IsCivilianBrain(oUnit:GetAIBrain())) then
        M28Utilities.ErrorHandler('No brain for mex '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' owned by brain '..(oUnit:GetAIBrain().Nickname or 'nil')..' so wont record for that brain team')
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tLZOrWZData[M28Map.subrefMexUnbuiltLocations]='..repru(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DecideToLaunchNukeSMLOrTMLMissile()  end --Done only to make it easier to find considerlaunchingmissile
function ConsiderLaunchingMissile(oLauncher, oOptionalWeapon)
    --Should be called via forkthread when missile created due to creating a loop
    --oOptioanlWeapon - if specified then can get the missile speed
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderLaunchingMissile'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28UnitInfo.IsUnitValid(oLauncher) and not(oLauncher[refbActiveMissileChecker]) then
        local aiBrain = oLauncher:GetAIBrain()
        if bDebugMessages == true then LOG(sFunctionRef..': aiBrain.HostileCampaignAI='..tostring(aiBrain.HostileCampaignAI or false)..'; ScenarioInfo.Options.CmpAIDelay='..tonumber(ScenarioInfo.Options.CmpAIDelay)..'; ScenarioInfo.OpEnded='..tostring(ScenarioInfo.OpEnded or false)..'; Time='..GetGameTimeSeconds()) end
        if not(aiBrain.HostileCampaignAI) or tonumber(ScenarioInfo.Options.CmpAIDelay) <= GetGameTimeSeconds() then
            --Aeon SML - one case having 11s threshold was fine, another when it was 12.1s since it fired a nuke it ended up clearing the old order
            local iTimeToWaitBetweenLaunches = 6 --i.e. TML
            if EntityCategoryContains(M28UnitInfo.refCategorySML, oLauncher.UnitId) then
                if EntityCategoryContains(categories.AEON, oLauncher.UnitId) then
                    iTimeToWaitBetweenLaunches = 13
                else
                    iTimeToWaitBetweenLaunches = 8
                end
            end

            if bDebugMessages == true then
                LOG(sFunctionRef..': Start of code for oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..' owned by brain '..oLauncher:GetAIBrain().Nickname..' at time='..GetGameTimeSeconds()..'; launcher position='..repru(oLauncher:GetPosition())..'Unit missile count='..M28UnitInfo.GetMissileCount(oLauncher)..'; Time since last issued a nuke launch order='..GetGameTimeSeconds() - (oLauncher[refiTimeLastFiredMissile] or -1000)..'; iTimeToWaitBetweenLaunches='..iTimeToWaitBetweenLaunches)
            end

            --If we have just tried giving an order to fire then wait longer
            if oLauncher[refiTimeLastFiredMissile] and GetGameTimeSeconds() - oLauncher[refiTimeLastFiredMissile] <= iTimeToWaitBetweenLaunches then
                if bDebugMessages == true then LOG(sFunctionRef..': we tried firing recently so will do a delayed launch instead') end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                --LOG('Forked consideration of launching missile Delay3')
                DelayedConsiderLaunchingMissile(oLauncher, iTimeToWaitBetweenLaunches - (GetGameTimeSeconds() - oLauncher[refiTimeLastFiredMissile]), true, true)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Beginning main launcher logic, setting active missile checker to true') end
                oLauncher[refbActiveMissileChecker] = true
                local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)

                local tTarget
                local iBestTargetValue
                local iCurTargetValue
                local tEnemyCategoriesOfInterest
                local aiBrain = oLauncher:GetAIBrain()
                local iMaxRange = 250 --basic default, should get overwritten
                local iMinRange = 0
                local iAOE, iDamage

                local bTML = false
                local bSML = false
                local bCheckForSMD = false
                local iMinDelayBetweenNukes = 55 --Aeon nuke takes 60s to get to corner of setons, think it takes 5s longer to fire, so will go with 55 for non-aeon
                local iTeam = aiBrain.M28Team
                local iTotalWaitCount = 0 --Nukes will spread calculations over a number of ticks, this tracks the ticks waited
                if EntityCategoryContains(M28UnitInfo.refCategoryTML, oLauncher.UnitId) then
                    bTML = true
                elseif EntityCategoryContains(M28UnitInfo.refCategorySML, oLauncher.UnitId) then
                    bSML = true
                    if not(EntityCategoryContains(categories.EXPERIMENTAL, oLauncher.UnitId)) then
                        bCheckForSMD = true --default
                        --If we have lots more nukes than enemy has SMD then consider overwhelming the SMD with nukes
                        local iNukeCount = 0
                        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                            iNukeCount = oBrain:GetCurrentUnits(M28UnitInfo.refCategorySML - categories.EXPERIMENTAL - M28UnitInfo.refCategoryBattleship) + oBrain:GetCurrentUnits(M28UnitInfo.refCategorySML * categories.EXPERIMENTAL) * 6
                        end
                        --Only consider overwhelming if we have 6 nukes
                        local iEnemySMD = 0
                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to check for SMD when deciding on targets for a non experimental nuke launcher, iNukeCount='..iNukeCount) end
                        if iNukeCount >= 4 then
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) == false then
                                for iSMD, oSMD in M28Team.tTeamData[iTeam][M28Team.reftEnemySMD] do
                                    if oSMD:GetFractionComplete() == 1 then
                                        iEnemySMD = iEnemySMD + 1
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iEnemySMD='..iEnemySMD) end
                            if iNukeCount >= iEnemySMD * 1.5 then
                                --Have enough nukes to overwhelm enemy
                                bCheckForSMD = false
                                if bDebugMessages == true then LOG(sFunctionRef..': Have more than 50% of enemy SMD in nuke launchers so will nuke regardless of SMD, iNukeCount='..iNukeCount..'; iEnemySMD='..iEnemySMD) end
                            else
                                --How many SMD does enemy have in one zone?
                                local tiSMDByPlateauAndZone = {}
                                local iCurSMDPlateauOrZero, iCurSMDZone
                                local iHighestSMDPerZone = 0
                                for iSMD, oSMD in M28Team.tTeamData[iTeam][M28Team.reftEnemySMD] do
                                    if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(oSMD:GetPosition()) then
                                        iCurSMDPlateauOrZero, iCurSMDZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oSMD:GetPosition())
                                        if not(tiSMDByPlateauAndZone[iCurSMDPlateauOrZero]) then tiSMDByPlateauAndZone[iCurSMDPlateauOrZero] = {} end
                                        tiSMDByPlateauAndZone[iCurSMDPlateauOrZero][iCurSMDZone] = (tiSMDByPlateauAndZone[iCurSMDPlateauOrZero][iCurSMDZone] or 0) + 1
                                        iHighestSMDPerZone = math.max(iHighestSMDPerZone, tiSMDByPlateauAndZone[iCurSMDPlateauOrZero][iCurSMDZone])
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': iNukeCount='..iNukeCount..'; iEnemySMD='..iEnemySMD..'; iHighestSMDPerZone='..iHighestSMDPerZone) end
                                if iNukeCount >= iHighestSMDPerZone * 1.5 then
                                    bCheckForSMD = false
                                end
                            end

                            if not(bCheckForSMD) then
                                iMinDelayBetweenNukes = math.min(10, math.max(5, 15 - iNukeCount/2))
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to ignore SMD, oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..'; iNukeCount='..iNukeCount..'; iEnemySMD (if we have lots of nukes)='..iEnemySMD..'; bCheckForSMD='..tostring(bCheckForSMD)..'; Time='..GetGameTimeSeconds()..'; iMinDelayBetweenNukes='..iMinDelayBetweenNukes) end
                        end

                        if EntityCategoryContains(categories.AEON, oLauncher.UnitId) then iMinDelayBetweenNukes = iMinDelayBetweenNukes + 5 end
                    else
                        --yolona - refuce min delay if enemy has lots of SMD as may be trying to overwhelm
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) == false and table.getn(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) >= 3 then
                            iMinDelayBetweenNukes = 9
                        end
                    end


                elseif EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oLauncher.UnitId) then
                    M28Utilities.ErrorHandler('Are running TML logic on an ACU or SACU, but code not setup to work for this yet')
                else M28Utilities.ErrorHandler('Unknown type of launcher, code to fire a missile wont work; oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher))
                end

                if bTML or bSML then
                    iAOE, iDamage, iMinRange, iMaxRange = M28UnitInfo.GetLauncherAOEStrikeDamageMinAndMaxRange(oLauncher)

                    if bTML then
                        --tEnemyCategoriesOfInterest = iTMLHighPriorityCategories
                    else --SML
                        if oLauncher[M28UnitInfo.refbEasyBrain] then
                            tEnemyCategoriesOfInterest = {M28UnitInfo.refCategoryExperimentalStructure, M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategorySML + categories.COMMAND, M28UnitInfo.refCategoryT3Mex + M28UnitInfo.refCategoryT3Power}
                        else
                            tEnemyCategoriesOfInterest = {M28UnitInfo.refCategoryExperimentalStructure, M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategorySML + categories.COMMAND, M28UnitInfo.refCategoryT3Mex + M28UnitInfo.refCategoryT3Power, M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryStructure * categories.TECH3 + M28UnitInfo.refCategoryFixedT2Arti - M28UnitInfo.refCategoryExperimentalStructure - M28UnitInfo.refCategoryFixedT3Arti - M28UnitInfo.refCategorySML - M28UnitInfo.refCategoryT3Mex - M28UnitInfo.refCategorySMD - M28UnitInfo.refCategoryT3Power, M28UnitInfo.refCategoryNavalSurface * categories.TECH3 + M28UnitInfo.refCategoryNavalSurface * categories.EXPERIMENTAL}
                        end
                    end

                    if bDebugMessages == true then LOG(sFunctionRef..': Will consider missile target. iMinRange='..(iMinRange or 'nil')..'; iAOE='..(iAOE or 'nil')..'; iDamage='..(iDamage or 'nil')..'; bSML='..tostring((bSML or false))) end
                    if M28UnitInfo.IsUnitValid(oLauncher) then
                        if bTML then
                            --local tHighHealthTargets = {}
                            local tStartPos = oLauncher:GetPosition()
                            local tPotentialTargets = oLauncher[reftUnprotectedUnitTargetsForThisTML]
                            local iValidTargets = 0
                            local tValidTargets = {}
                            local iTMLRange = (oLauncher[M28UnitInfo.refiManualRange] or iTMLMissileRange)
                            local iTMLAOE = math.max(oLauncher[M28UnitInfo.refiIndirectAOE] or 0, 2)
                            local iPotentialInRangeDistance = iTMLRange + iTMLAOE + 4 --unlikely to have larger buildings than this
                            --First refresh list of untis in range for any that are dead
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of potential targets empty='..tostring(M28Utilities.IsTableEmpty(tPotentialTargets))) end
                            if M28Utilities.IsTableEmpty(tPotentialTargets) == false then
                                local iPotentialTargets = table.getn(tPotentialTargets)
                                local iCurDist
                                for iCurEntry = iPotentialTargets, 1, -1 do
                                    if not(M28UnitInfo.IsUnitValid(tPotentialTargets[iCurEntry])) then
                                        table.remove(oLauncher[reftUnprotectedUnitTargetsForThisTML], iCurEntry)
                                    else
                                        if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tPotentialTargets[iCurEntry]:GetPosition()) then
                                            --Can we hit this unit factoring in AOE?
                                            iCurDist = M28Utilities.GetDistanceBetweenPositions(tPotentialTargets[iCurEntry]:GetPosition(), tStartPos)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry '..iCurEntry..'; Unit='..tPotentialTargets[iCurEntry].UnitId..M28UnitInfo.GetUnitLifetimeCount(tPotentialTargets[iCurEntry])..'; iCurDist='..iCurDist..'; iPotentialInRangeDistance='..iPotentialInRangeDistance..'; iTMLRange='..iTMLRange..'; iTMLAOE='..iTMLAOE) end
                                            if iCurDist <= iPotentialInRangeDistance then
                                                if iCurDist <= iTMLRange or iCurDist <= iTMLRange + math.max(iTMLAOE, 0.5 * math.min(tPotentialTargets[iCurEntry]:GetBlueprint().Physics.SkirtSizeX, tPotentialTargets[iCurEntry]:GetBlueprint().Physics.SkirtSizeZ)) then
                                                    table.insert(tValidTargets, tPotentialTargets[iCurEntry])
                                                    iValidTargets = iValidTargets + 1
                                                end
                                            end
                                        end
                                    end
                                end
                            end

                            local oBestTarget
                            if iValidTargets == 0 then
                                --Disable autobuild and pause the TML since we have no targets - handled below to cover cases where for whatever reason we fail to find a valid target
                            else
                                --Have at least 1 valid target, so want to pick the best one

                                iBestTargetValue = 120 --wont consider targets worth less than this
                                local sLauncherLocationRef = M28Utilities.ConvertLocationToReference(oLauncher:GetPosition())
                                for iUnit, oUnit in tValidTargets do
                                    if M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]) == false then
                                        iCurTargetValue = 0
                                        if bDebugMessages == true then LOG(sFunctionRef..': Shields are covering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                    else
                                        --GetDamageFromBomb(aiBrain, tBaseLocation,         iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory, iOptionalReclaimFactor)
                                        iCurTargetValue = M28Logic.GetDamageFromBomb(aiBrain, oUnit:GetPosition(), iAOE, iDamage,       nil,                                nil,                true,                           nil,                nil,                            nil,                                        false,              nil,                            true,                               nil,                                nil,                    nil)
                                        if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then iCurTargetValue = iCurTargetValue * 1.5 end
                                        --Adjust value if we think the missile will hit a cliff
                                        if oUnit[tbExpectMissileBlockedByCliff][sLauncherLocationRef] == nil then
                                            if not(oUnit[tbExpectMissileBlockedByCliff]) then oUnit[tbExpectMissileBlockedByCliff] = {} end
                                            local tExpectedMissileVertical = M28Utilities.MoveInDirection(oLauncher:GetPosition(), M28Utilities.GetAngleFromAToB(oLauncher:GetPosition(), oUnit:GetPosition()), 31, true)
                                            tExpectedMissileVertical[2] = tExpectedMissileVertical[2] + 60 --Doing testing, it actually only goes up by 50, but I think it travels in an arc from here to the target, as in a test scenario doing at less than +60 meant it thought it would hit a cliff when it didnt
                                            -- {oLauncher:GetPosition()[1], oLauncher:GetPosition()[2] + 65, oLauncher:GetPosition()[3]}
                                            oUnit[tbExpectMissileBlockedByCliff][sLauncherLocationRef] = M28Logic.IsLineBlocked(aiBrain, tExpectedMissileVertical, oUnit:GetPosition(), iAOE, false)
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Potential TML target '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurTargetValue before adj for blocked='..iCurTargetValue..'; oUnit[tbExpectMissileBlockedByCliff][sLauncherLocationRef]='..tostring(oUnit[tbExpectMissileBlockedByCliff][sLauncherLocationRef])..'; oUnit[refiTMLShotsFired]='..(oUnit[refiTMLShotsFired] or 0)..'; refiTimeOfLastLaunch='..(oUnit[refiTimeOfLastLaunch] or 'nil')..'; oUnit[refbProtectedByTerrain]='..tostring(oUnit[refbProtectedByTerrain] or false)..'; oLauncher[reftTerrainBlockedTargets]='..repru(oLauncher[reftTerrainBlockedTargets] or {'nil'})..'; iDamage='..iDamage..'; iAOE='..iAOE..'; Unit health='..oUnit:GetHealth()..'; Unit position='..repru(oUnit:GetPosition())..'; Is reftoShieldsProvidingCoverage empty='..tostring(M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]))) end
                                        if oUnit[tbExpectMissileBlockedByCliff][sLauncherLocationRef] then iCurTargetValue = iCurTargetValue * 0.2 end
                                        --Check against actual terrain blocked blacklist
                                        if oUnit[refbProtectedByTerrain] then
                                            iCurTargetValue = 0
                                        elseif M28Utilities.IsTableEmpty(oLauncher[reftTerrainBlockedTargets]) == false then
                                            for iEntry, tLocation in oLauncher[reftTerrainBlockedTargets] do
                                                if M28Utilities.GetDistanceBetweenPositions(tLocation, oUnit:GetPosition()) <= 1.5 then
                                                    oUnit[refbProtectedByTerrain] = true
                                                    iCurTargetValue = 0
                                                    break
                                                end
                                            end
                                        end
                                        if iCurTargetValue > 0 and (oUnit[refiTMLShotsFired] or 0) > 0 then
                                            --Reduce shots fired if we dealt damage with our last missile (as may have e.g. hit mass storage blocking us from reaching the target mex)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Last TML target='..(oLauncher[refoLastTMLTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oLauncher[refoLastTMLTarget]) or 'nil')..'; Launcher mass killed='..(oLauncher.VetExperience or oLauncher.Sync.totalMassKilled or 0)..'; TML mass kills='..(oLauncher[refiLastTMLMassKills] or 0)) end
                                            if oLauncher[refoLastTMLTarget] == oUnit and (oLauncher.VetExperience or oLauncher.Sync.totalMassKilled or 0) > (oLauncher[refiLastTMLMassKills] or 0) then
                                                oLauncher[refiLastTMLMassKills] = (oLauncher.VetExperience or oLauncher.Sync.totalMassKilled or 0)
                                                oUnit[refiTMLShotsFired] = oUnit[refiTMLShotsFired] - 1
                                            end
                                            if oUnit[refiTMLShotsFired] > 0 or oUnit[refiTimeOfLastLaunch] then
                                                local iUnitMaxHealth = oUnit:GetMaxHealth()
                                                local iUnitCurShield, iUnitMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit)
                                                if (iUnitMaxHealth + iUnitMaxShield <= iDamage and M28UnitInfo.IsUnitValid(oUnit[refoLastTMLLauncher])) and (not(oUnit[refoLastTMLLauncher] == oLauncher) or GetGameTimeSeconds() - (oUnit[refiTimeOfLastLaunch] or -100) <= 35) then
                                                    iCurTargetValue = 0
                                                else

                                                    local iExpectedShots = math.ceil((iUnitMaxHealth + iUnitMaxShield) / iDamage)
                                                    if oUnit[refiTMLShotsFired] > iExpectedShots then
                                                        --Reduce by 50% for each time are over
                                                        iCurTargetValue = iCurTargetValue * 0.5^(oUnit[refiTMLShotsFired] - iExpectedShots)
                                                        if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) and oUnit[refiTMLShotsFired] - iExpectedShots >= 3 then
                                                            iCurTargetValue = 0
                                                        end
                                                    end
                                                end

                                                if bDebugMessages == true then LOG(sFunctionRef..': iUnitMaxHealth='..iUnitMaxHealth..'; iUnitMaxShield='..iUnitMaxShield..'; oUnit[refiTMLShotsFired]='..oUnit[refiTMLShotsFired]..'; oUnit[refiTimeOfLastLaunch]='..(oUnit[refiTimeOfLastLaunch] or 'nil')..'; iCurTargetValue after adjusting for excess='..iCurTargetValue) end
                                            end
                                        end
                                    end
                                    if iBestTargetValue < iCurTargetValue then
                                        iBestTargetValue = iCurTargetValue
                                        oBestTarget = oUnit
                                    end
                                end
                                if oBestTarget then
                                    tTarget = oBestTarget:GetPosition()
                                    --Target ground following FAF changes to TMLs
                                    tTarget[2] = GetSurfaceHeight(tTarget[1], tTarget[3])
                                    if oLauncher:IsUnitState('Busy') and (GetGameTimeSeconds() - (oLauncher[refiTimeOfLastLaunch] or -100)) < 5 and M28UnitInfo.IsUnitValid(oLauncher[refoLastTMLTarget]) then
                                        oLauncher[refoLastTMLTarget][refiTMLShotsFired] = (oLauncher[refoLastTMLTarget][refiTMLShotsFired] or 0) - 1
                                    end
                                    oBestTarget[refiTMLShotsFired] = (oBestTarget[refiTMLShotsFired] or 0) + 1
                                    oLauncher[refoLastTMLTarget] = oBestTarget
                                    oLauncher[refiLastTMLMassKills] = (oLauncher.VetExperience or oLauncher.Sync.totalMassKilled or 0)
                                    oBestTarget[refoLastTMLLauncher] = oLauncher
                                    oBestTarget[refiTimeOfLastLaunch] = GetGameTimeSeconds()
                                    if bDebugMessages == true then LOG(sFunctionRef..': oBestTarget='..oBestTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestTarget)..'; iBestTargetValue='..iBestTargetValue..'; SHots fired afteri ncluding this one='..oBestTarget[refiTMLShotsFired]..'; Mass killed prior to missile impacting='..oLauncher[refiLastTMLMassKills]) end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iValidTargets='..iValidTargets..'; tTarget='..repru((tTarget or {'nil'}))..'; Is oBestTarget valid='..tostring(M28UnitInfo.IsUnitValid(oBestTarget))) end

                        else --SML - work out which location would deal the most damage - consider all high value structures and the enemy start position
                            --Reduce AOE by 0.5 if >10 to be more reliable (since height differences mean we might incorrectly think we will hit a high value target?)
                            if iAOE > 10 then iAOE = math.max(10, iAOE - 0.5) end
                            iBestTargetValue = 0
                            --Shortlist of locations we have recently nuked
                            local tRecentlyNuked = {}
                            local iTimeSMDNeedsToHaveBeenBuiltFor = 200 + iTimeForSMDToBeConstructed --default, will adjust
                            local iMissileSpeed
                            if oOptionalWeapon then iMissileSpeed = (__blueprints[oOptionalWeapon.Blueprint.ProjectileId].Physics.MaxSpeed or 40)
                            else iMissileSpeed = 40
                            end
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..'; Breakdown of the weapon table='..reprs(oOptionalWeapon)..'; iMissileSpeed='..iMissileSpeed..'; missile speed per BP='..(__blueprints[oOptionalWeapon.Blueprint.ProjectileId].Physics.MaxSpeed or 'nil'))
                            end

                            local iNukeSegmentSize = 15
                            local tiNukeSegmentsConsidered = {}
                            local iCurNukeSegmentX, iCurNukeSegmentZ
                            local bAlreadyConsideredBestAOETarget = true

                            local iPositionsConsideredThisTick = 0
                            local iAbortThreshold = 60000

                            function GetNukeSegmentsFromPosition(tPosition)
                                return math.ceil(tPosition[1] / iNukeSegmentSize), math.ceil(tPosition[3] / iNukeSegmentSize)
                            end
                            function RecordHaveConsideredNukeLocation(tPosition, bConsideredBestAOETarget)
                                iCurNukeSegmentX, iCurNukeSegmentZ = GetNukeSegmentsFromPosition(tPosition)
                                if not(tiNukeSegmentsConsidered[iCurNukeSegmentX]) then tiNukeSegmentsConsidered[iCurNukeSegmentX] = {} end
                                tiNukeSegmentsConsidered[iCurNukeSegmentX][iCurNukeSegmentZ] = true
                                if bConsideredBestAOETarget then
                                    iPositionsConsideredThisTick = iPositionsConsideredThisTick + 5 --approximation - will likely be more than this
                                else
                                    iPositionsConsideredThisTick = iPositionsConsideredThisTick + 1
                                end

                            end

                            if bDebugMessages == true then LOG(sFunctionRef..': Checking nuke launch locations, is table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]))..'; Time of check='..GetGameTimeSeconds()) end
                            function RefreshRecentlyNukedLocations()
                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]) == false then
                                    local iTimeSinceFired
                                    local iLoopCheck
                                    for iTime, tLocation in M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations] do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iTime='..iTime..'; tLocation='..repru(tLocation)..'; GameTime='..GetGameTimeSeconds()) end
                                        iTimeSinceFired = GetGameTimeSeconds() - iTime

                                        if iTimeSinceFired < iMinDelayBetweenNukes then --Testing with Aeon SML on setons it takes 60s to go from one corner to another roughly
                                            iLoopCheck = 0
                                            while tRecentlyNuked[iTimeSinceFired] do
                                                iTimeSinceFired = iTimeSinceFired - 0.0001
                                                iLoopCheck = iLoopCheck + 1
                                                if iLoopCheck >= 20 then M28Utilities.ErrorHandler('Potential infinite loop with nuke location recording, will stop attempting to record extra recently nuked locations') break end
                                            end
                                            tRecentlyNuked[iTimeSinceFired] = {tLocation[1], tLocation[2], tLocation[3]}
                                        end
                                    end
                                end
                            end

                            RefreshRecentlyNukedLocations()

                            if bDebugMessages == true then LOG(sFunctionRef..': tRecentlyNuked='..repru((tRecentlyNuked or {'nil'}))) end

                            function HaventRecentlyNukedLocation(tLocation )--, bIgnoreIfCoveredBySMD) --bIgnoreIfCoveredBySMD - removed from v46 (previously would set to true if want to ignore the fact that we have recenlty nuked the target if it is covered by SMD (i.e. if there is SMD then we likely want to overwhelm the target hence want to fire multiple nukes at the same location)

                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of recently nuked locations empty='..tostring(M28Utilities.IsTableEmpty(tRecentlyNuked))..'; tLocation='..repru(tLocation)) end
                                if M28Utilities.IsTableEmpty(tRecentlyNuked) then return true
                                else
                                    for iTimeSinceFired, tRecentLocation in tRecentlyNuked do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering tLocation='..repru(tLocation)..'; Distance to tRecentLocation='..M28Utilities.GetDistanceBetweenPositions(tLocation, tRecentLocation)..'; is smd blocking targeet='..tostring(IsSMDBlockingTarget(aiBrain, tLocation, oLauncher:GetPosition(), 180, 0))..'; iTimeSinceFired='..iTimeSinceFired) end
                                        --if iTimeSinceFired <= iMinDelayBetweenNukes then --(incorporated into refreshrecentlynukedlocations)
                                        if M28Utilities.GetDistanceBetweenPositions(tLocation, tRecentLocation) <= 50 then
                                            return false
                                            --[[ Old logic (removed v46 and replaced with iMinDelayBetweenNukes)
                                            if bIgnoreIfCoveredBySMD then
                                                if IsSMDBlockingTarget(aiBrain, tLocation, oLauncher:GetPosition(), 60, 0) then
                                                    return true --we have fired here recently but we want to fire multiple nukes to overwhelm smd
                                                else
                                                    return false --we have fired here recently and there's no smd to overwhelm
                                                end
                                            else
                                                return false --we have fired here recently and dont care about overwhelming smd
                                            end--]]
                                        end
                                        --end
                                    end
                                end
                                return true --we havent fired here recently
                            end

                            --Decide whether to value destroying reclaim
                            local iReclaimFactor
                            if M28Utilities.IsTableEmpty(M28Map.tiVeryHighValueReclaimSegments) == false and not(M28Map.bIsCampaignMap) then
                                iReclaimFactor = 0.4
                            end

                            --First get the best location if just target the start position or locations near here
                            if HaventRecentlyNukedLocation(M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) then--, not(bCheckForSMD)) then
                                iTimeSMDNeedsToHaveBeenBuiltFor = iTimeForSMDToBeConstructed + 190 - (M28Utilities.GetDistanceBetweenPositions( M28Map.GetPrimaryEnemyBaseLocation(aiBrain), oLauncher:GetPosition()) / iMissileSpeed + 10)
                                --GetBestAOETarget(aiBrain, tBaseLocation,                              iAOE, iDamage, bOptionalCheckForSMD, tSMLLocationForSMDCheck, iOptionalTimeSMDNeedsToHaveBeenBuiltFor, iSMDRangeAdjust, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, iOptionalMaxDistanceCheckOptions, iMobileValueOverrideFactorWithin75Percent, iOptionalShieldReductionFactor, iOptionalReclaimFactor)
                                tTarget, iBestTargetValue = M28Logic.GetBestAOETarget(aiBrain, M28Map.GetPrimaryEnemyBaseLocation(aiBrain), iAOE, iDamage, bCheckForSMD,        oLauncher:GetPosition(),    nil,                                    nil,                2,                                  2.5,                    nil,                            nil,                                        nil,                            iReclaimFactor)
                                RecordHaveConsideredNukeLocation(M28Map.GetPrimaryEnemyBaseLocation(aiBrain), true)
                            end

                            --Cycle through other start positions to see if can get a better target, but reduce value of target if we havent scouted it in the last 5 minutes
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering best target for nuke.  If target enemy base then iBestTargetValue='..iBestTargetValue) end
                            local iPlateauOrZero, iLandOrWaterZone
                            local bAbortLoop = false
                            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
                                local tEnemyStartPosition =  M28Map.PlayerStartPoints[oBrain:GetArmyIndex()]
                                if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tEnemyStartPosition)) and M28Utilities.GetDistanceBetweenPositions(tEnemyStartPosition, M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) >= 30 then
                                    --Have we scouted this location recently or do we have radar coverage
                                    local tLZOrWZTeamData
                                    iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tEnemyStartPosition)
                                    if iPlateauOrZero > 0 then
                                        tLZOrWZTeamData  = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
                                    else
                                        --Water zone
                                        tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
                                    end


                                    if bDebugMessages == true then LOG(sFunctionRef..': Cycling through start points, considering brain '..(oBrain.Nickname or 'nil')..' with start point '..repru(tEnemyStartPosition)) end
                                    if GetGameTimeSeconds() - (tLZOrWZTeamData[M28Map.refiTimeLastHadVisual] or -1000) <= 300 or tLZOrWZTeamData[M28Map.refiRadarCoverage] >= 20 then
                                        iCurNukeSegmentX, iCurNukeSegmentZ = GetNukeSegmentsFromPosition(tEnemyStartPosition)
                                        if not(tiNukeSegmentsConsidered[iCurNukeSegmentX][iCurNukeSegmentZ]) then
                                            if HaventRecentlyNukedLocation(tEnemyStartPosition) then --, not(bCheckForSMD)) then
                                                RecordHaveConsideredNukeLocation(tEnemyStartPosition, false)
                                                --GetDamageFromBomb(aiBrain, tBaseLocation,         iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory, iOptionalReclaimFactor)
                                                iCurTargetValue = M28Logic.GetDamageFromBomb(aiBrain, tEnemyStartPosition, iAOE, iDamage,   2,                                  2.5                     , nil,                          nil,                nil,                            nil,                                        false,                  nil,                            true,                       nil,                                    nil,                    iReclaimFactor)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering the start position '..repru( tEnemyStartPosition)..'; value ignroign SMD='..iCurTargetValue) end
                                                if iCurTargetValue > iBestTargetValue then
                                                    iTimeSMDNeedsToHaveBeenBuiltFor = iTimeForSMDToBeConstructed + 190 - (M28Utilities.GetDistanceBetweenPositions( tEnemyStartPosition, oLauncher:GetPosition()) / iMissileSpeed + 10)
                                                    if IsSMDBlockingTarget(aiBrain,  tEnemyStartPosition, oLauncher:GetPosition(), iTimeSMDNeedsToHaveBeenBuiltFor) then
                                                        iCurTargetValue = 4000
                                                        if bDebugMessages == true then LOG(sFunctionRef..': SMD is blocking target so reducing value to 4k. iTimeSMDNeedsToHaveBeenBuiltFor='..iTimeSMDNeedsToHaveBeenBuiltFor) end
                                                    end
                                                    if iCurTargetValue > iBestTargetValue then
                                                        bAlreadyConsideredBestAOETarget = false
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Have a better start position target, dealing damage of '..iCurTargetValue..' vs prev best value of '..iBestTargetValue..'; iTimeSMDNeedsToHaveBeenBuiltFor='..iTimeSMDNeedsToHaveBeenBuiltFor) end
                                                        iBestTargetValue = iCurTargetValue
                                                        tTarget = {tEnemyStartPosition[1], tEnemyStartPosition[2], tEnemyStartPosition[3]}
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            function ConsiderPotentialNukeLocation(tLocationToConsiderNuke, bOverrideCheckForSMD, iOptionalMobileOverrideFactor)
                                iCurNukeSegmentX, iCurNukeSegmentZ = GetNukeSegmentsFromPosition(tLocationToConsiderNuke)
                                if not(tiNukeSegmentsConsidered[iCurNukeSegmentX][iCurNukeSegmentZ]) then
                                    if HaventRecentlyNukedLocation(tLocationToConsiderNuke) then --, not(bOverrideCheckForSMD)) then
                                        RecordHaveConsideredNukeLocation(tLocationToConsiderNuke, false)
                                        if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLocationToConsiderNuke)) then
                                            --GetDamageFromBomb(aiBrain, tBaseLocation,         iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory, iOptionalReclaimFactor)
                                            iCurTargetValue = M28Logic.GetDamageFromBomb(aiBrain, tLocationToConsiderNuke, iAOE, iDamage,   2,                                  2.5,                    nil,                            nil,                nil,                            iOptionalMobileOverrideFactor,                  false,              nil,                            true,                       nil,                                    nil,                    iReclaimFactor)
                                            if bDebugMessages == true then LOG(sFunctionRef..': tLocationToConsiderNuke='..repru(tLocationToConsiderNuke)..'; iCurTargetValue='..iCurTargetValue..'; iPositionsConsideredThisTick='..iPositionsConsideredThisTick) end
                                            --Stop looking if tried >=10 targets and have one that is at least 20k of value
                                            if iCurTargetValue > iBestTargetValue then
                                                iTimeSMDNeedsToHaveBeenBuiltFor = iTimeForSMDToBeConstructed + 190 - (M28Utilities.GetDistanceBetweenPositions( tLocationToConsiderNuke, oLauncher:GetPosition()) / iMissileSpeed + 10)
                                                if bOverrideCheckForSMD and IsSMDBlockingTarget(aiBrain, tLocationToConsiderNuke, oLauncher:GetPosition(), iTimeSMDNeedsToHaveBeenBuiltFor) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': SMD is blocking the unit target '..repru(tLocationToConsiderNuke)..'; will limit damage to 4k; iTimeSMDNeedsToHaveBeenBuiltFor='..iTimeSMDNeedsToHaveBeenBuiltFor) end
                                                    iCurTargetValue = 4000 end
                                                if iCurTargetValue > iBestTargetValue then
                                                    bAlreadyConsideredBestAOETarget = false
                                                    iBestTargetValue = iCurTargetValue
                                                    tTarget = tLocationToConsiderNuke
                                                    if bDebugMessages == true then LOG(sFunctionRef..': New best target with value='..iBestTargetValue..'; iTimeSMDNeedsToHaveBeenBuiltFor='..iTimeSMDNeedsToHaveBeenBuiltFor) end
                                                end
                                            end
                                            --Note: Mass value of mexes is doubled, so 3 T3 mexes would give a value of 27600
                                            if iPositionsConsideredThisTick >= 8 and iBestTargetValue >= iAbortThreshold then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have a target with a decent amount of value and have already tried quite a few units.  iBestTargetValue='..iBestTargetValue..'; iPositionsConsideredThisTick='..iPositionsConsideredThisTick) end
                                                bAbortLoop = true
                                            end
                                        end
                                    end
                                end
                                --Spread out calculations over a number of ticks due to their intesnity
                                if iPositionsConsideredThisTick >= 10 and not(bAbortLoop) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considered '..iPositionsConsideredThisTick..' targets, will wait 1 tick before considering more for performance reasons. iBestTargetValue='..iBestTargetValue) end
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                    WaitTicks(1)
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                                    RefreshRecentlyNukedLocations()
                                    iPositionsConsideredThisTick = 0
                                    iTotalWaitCount = iTotalWaitCount + 1
                                    if not(M28UnitInfo.IsUnitValid(oLauncher)) then
                                        tTarget = nil
                                        bAbortLoop = true
                                    end
                                    --Lower requirements to stop searching over time
                                    if iTotalWaitCount >= 20 then
                                        iAbortThreshold = iAbortThreshold * 0.95
                                        if iTotalWaitCount >= 100 then
                                            iAbortThreshold = math.min(iAbortThreshold * 0.95, 1000)
                                            if iTotalWaitCount >= 150 then bAbortLoop = true end
                                        end
                                        if iBestTargetValue >= iAbortThreshold then bAbortLoop = true end
                                    end
                                end
                            end

                            function ConsiderTableOfPotentialTargets(tEnemyUnitsOfInterest, bOverrideCheckForSMD, iOptionalMobileOverrideFactor)
                                if M28Utilities.IsTableEmpty(tEnemyUnitsOfInterest) == false then
                                    for iUnit, oUnit in tEnemyUnitsOfInterest do
                                        if M28UnitInfo.IsUnitValid(oUnit) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iPositionsConsideredThisTick='..iPositionsConsideredThisTick..'; Have we recently nuked this location='..tostring((HaventRecentlyNukedLocation(oUnit:GetPosition())))) end
                                            ConsiderPotentialNukeLocation(oUnit:GetPosition(), bOverrideCheckForSMD, iOptionalMobileOverrideFactor)
                                            if bAbortLoop then break end
                                        end
                                    end
                                end
                            end

                            --Consider a defensive nuke as well if enemy has land experimentals or battleships that are relatively near a friendly base - treat as higher value than normal where not covered by SMD (e.g. if have yolona then only want defensive nukes if expect the nuke to land)
                            local tEnemyClosestLandAndNavalThreats = {}
                            local iDefensiveThreshold = 350
                            local iBestValueOfDefensiveNuke = 0
                            local iDefensiveNukePlateauAndZone = {}
                            if M28Map.iMapSize <= 512 then iDefensiveThreshold = 260 end
                            local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oLauncher:GetPosition(), true, iTeam)
                            if tLZTeamData then
                                iDefensiveThreshold = math.max(125, math.min(iDefensiveThreshold, M28Utilities.GetDistanceBetweenPositions(oLauncher:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase])) * 0.475)
                            end
                            local iCurUnitPlateauOrZero, iCurUnitZone
                            local toClosestEnemyUntisByPlateauAndZone = {}

                            if bDebugMessages == true then LOG(sFunctionRef..': Considering priority enemy land threats near our base, is table of enemy land experimenatls empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]))) end
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
                                for iUnit, oUnit in  M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
                                    if M28UnitInfo.IsUnitValid(oUnit) then
                                        iCurUnitPlateauOrZero, iCurUnitZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                                        if (iCurUnitZone or 0) > 0 and (iCurUnitPlateauOrZero or -1) >= 0 then
                                            local tUnitLZOrWZData, tUnitLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that is '..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tUnitLZOrWZTeamData[M28Map.reftClosestFriendlyBase])..' dist to the closest friendly base; iDefensiveThreshold='..iDefensiveThreshold) end
                                            if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tUnitLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) <= iDefensiveThreshold then
                                                table.insert(tEnemyClosestLandAndNavalThreats, oUnit)
                                                if not(toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero]) then toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero] = {} end
                                                if not(toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero][iCurUnitZone]) then toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero][iCurUnitZone] = {} end
                                                table.insert(toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero][iCurUnitZone], oUnit)
                                            end
                                        end
                                    end
                                end
                            end
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyBattleships]) == false then
                                for iUnit, oUnit in  M28Team.tTeamData[iTeam][M28Team.reftEnemyBattleships] do
                                    if M28UnitInfo.IsUnitValid(oUnit) then
                                        iCurUnitPlateauOrZero, iCurUnitZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                                        if (iCurUnitZone or 0) > 0 and (iCurUnitPlateauOrZero or -1) >= 0 then
                                            local tUnitLZOrWZData, tUnitLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                            if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tUnitLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) <= iDefensiveThreshold then
                                                table.insert(tEnemyClosestLandAndNavalThreats, oUnit)
                                                if not(toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero]) then toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero] = {} end
                                                if not(toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero][iCurUnitZone]) then toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero][iCurUnitZone] = {} end
                                                table.insert(toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero][iCurUnitZone], oUnit)
                                            end
                                        end
                                    end
                                end
                            end
                            if M28Utilities.IsTableEmpty(tEnemyClosestLandAndNavalThreats) == false then
                                local iMassValueOfThreats = M28UnitInfo.GetMassCostOfUnits(tEnemyClosestLandAndNavalThreats)
                                if bDebugMessages == true then LOG(sFunctionRef..': Mass value of nearby threats='..iMassValueOfThreats) end
                                if iMassValueOfThreats * 2 > iBestTargetValue and iMassValueOfThreats > 24000 then
                                    --Go through the actual zones and consider targeting units in here, but always checking for SMD even with yolona
                                    for iPlateauOrZero, tSubtable in toClosestEnemyUntisByPlateauAndZone do
                                        for iZone, tUnits in tSubtable do
                                            if M28UnitInfo.GetMassCostOfUnits(tUnits) >= 24000 then
                                                local iBestValuePreCheck = iBestTargetValue
                                                if bDebugMessages == true then LOG(sFunctionRef..': Best target value pre check for experimental land untis in P'..iPlateauOrZero..'Z'..iZone..'='..iBestTargetValue) end
                                                ConsiderTableOfPotentialTargets(tUnits, true, 0.8)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Best target value post check for experimental land untis in P'..iPlateauOrZero..'Z'..iZone..'='..iBestTargetValue) end
                                                if iBestTargetValue > iBestValuePreCheck then
                                                    iBestValueOfDefensiveNuke = iBestTargetValue
                                                    iDefensiveNukePlateauAndZone = {iPlateauOrZero, iZone}
                                                end
                                            end
                                        end
                                    end
                                end
                            end



                            if bDebugMessages == true then LOG(sFunctionRef..': iBestTargetValue for enemy base='..iBestTargetValue..'; if <80k then will consider other targets. tTarget='..repru(tTarget)..'; iBestValueOfDefensiveNuke='..iBestValueOfDefensiveNuke) end
                            if iBestTargetValue < 80000 and (not(oLauncher[M28UnitInfo.refbEasyBrain]) or iBestTargetValue < 30000) then --If have high value location for nearest enemy start then just go with this
                                --Consider high reclaim segments
                                if M28Utilities.IsTableEmpty(M28Map.tiVeryHighValueReclaimSegments) == false then
                                    for iEntry, tSegmentXZ in M28Map.tiVeryHighValueReclaimSegments do
                                        local tSegmentMidpoint = M28Map.GetReclaimLocationFromSegment(tSegmentXZ[1], tSegmentXZ[2])
                                        local tReclaimLZData, tReclaimLZTeamData = M28Map.GetLandOrWaterZoneData(tSegmentMidpoint, true, iTeam)
                                        if tReclaimLZTeamData[M28Map.refiModDistancePercent] > 0.6 then --If changing 0.6 threshold also update getdamagefrombomb
                                            ConsiderPotentialNukeLocation(tSegmentMidpoint, bCheckForSMD)
                                            if bAbortLoop then break end
                                        end
                                    end
                                end



                                for iRef, iCategory in tEnemyCategoriesOfInterest do
                                    ConsiderTableOfPotentialTargets(aiBrain:GetUnitsAroundPoint(iCategory, oLauncher:GetPosition(), iMaxRange, 'Enemy'), bCheckForSMD)

                                end
                                if iBestTargetValue > iBestValueOfDefensiveNuke then
                                    --GetBestAOETarget(aiBrain, tBaseLocation, iAOE, iDamage, bOptionalCheckForSMD, tSMLLocationForSMDCheck, iOptionalTimeSMDNeedsToHaveBeenBuiltFor, iSMDRangeAdjust, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, iOptionalMaxDistanceCheckOptions, iMobileValueOverrideFactorWithin75Percent, iOptionalShieldReductionFactor, iOptionalReclaimFactor)
                                    if tTarget then tTarget, iBestTargetValue = M28Logic.GetBestAOETarget(aiBrain, tTarget,         iAOE, iDamage, bCheckForSMD,        oLauncher:GetPosition(), nil,                                       nil,                2,                                      2.5,                    nil,                            nil,                                        nil,                            iReclaimFactor) end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': iBestTargetValue after getting best location='..iBestTargetValue..'; Best location for this target='..repru(tTarget)) end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': If value is <14k then will clear target unless have yolona; iBestTargetValue='..iBestTargetValue..'; tTarget='..repru(tTarget or {'nil'})) end
                            if iBestTargetValue < 20000 then --Mex is 4.6k base, with a 1.75 factor is 8050; with mass storage would be 9450; therefore if want to hit 3+ mex equivalents with a nuke, min value should be at least 19k (just over 2 capped T3 mexes)
                                if iBestTargetValue < 4000 or not(EntityCategoryContains(categories.EXPERIMENTAL, oLauncher.UnitId)) then
                                    tTarget = nil
                                end
                            end --Increased vs M27 as will only apuse if no target


                            function ChangeTargetToClosestUnitToLauncher(tUnitsToConsider, iOptionalLeadingDistanceBaseAdjust)
                                local iClosestEnemyDist = 100000
                                local oClosestEnemyUnit
                                local iCurEnemyDist
                                local iBaseLeadingDistance = iOptionalLeadingDistanceBaseAdjust or iAOE * 0.7
                                for iUnit, oUnit in tUnitsToConsider do
                                    iCurEnemyDist = M28Utilities.GetDistanceBetweenPositions(oLauncher:GetPosition(), oUnit:GetPosition())
                                    if iCurEnemyDist < iClosestEnemyDist then
                                        iClosestEnemyDist = iCurEnemyDist
                                        oClosestEnemyUnit = oUnit
                                    end
                                end
                                if oClosestEnemyUnit then
                                    --Base target is this unit
                                    local tPotentialAltTarget = oClosestEnemyUnit:GetPosition()
                                    --Ajdust for unit facing direction if it is moving
                                    local iUnitFacingAngle = M28UnitInfo.GetUnitFacingAngle(oClosestEnemyUnit)
                                    if oClosestEnemyUnit:IsUnitState('Moving') then
                                        tPotentialAltTarget = M28Utilities.MoveInDirection(oClosestEnemyUnit:GetPosition(), M28UnitInfo.GetUnitFacingAngle(oClosestEnemyUnit), iBaseLeadingDistance, true, false, true)
                                    end
                                    --Check the value of this isn't negative (due to friendly fire)
                                    --GetDamageFromBomb(aiBrain, tBaseLocation,     iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory, iOptionalReclaimFactor)
                                    if M28Logic.GetDamageFromBomb(aiBrain, tPotentialAltTarget, iAOE, iDamage,   2,                                  2.5,                    nil,                            nil,                nil,                            0.6,                                       nil,                    nil,                            true,                           nil,                                nil,                    iReclaimFactor) > 0 then
                                        tTarget = tPotentialAltTarget
                                        --Adjust the target further if it is far away
                                        local iCurDist = M28Utilities.GetDistanceBetweenPositions(tTarget, oLauncher:GetPosition())
                                        if iCurDist >= 300 then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Target is far away so will adjust further, tTarget pre adjust='..repru(tTarget)) end
                                            tTarget = M28Utilities.MoveInDirection(tTarget, iUnitFacingAngle, math.min(iBaseLeadingDistance, (iCurDist - 300) / 30), true, false, true)
                                            if bDebugMessages == true then LOG(sFunctionRef..': tTarget post adjust='..repru(tTarget)) end
                                        end
                                    end

                                    if bDebugMessages == true then LOG(sFunctionRef..': tPotentialAltTarget='..repru(tPotentialAltTarget)..'; tTarget after update='..repru(tTarget)..' based on oClosestEnemyUnit='..oClosestEnemyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyUnit)..' at position '..repru(oClosestEnemyUnit:GetPosition())..' with unit state='..M28UnitInfo.GetUnitState(oClosestEnemyUnit)..' and facing angle='..M28UnitInfo.GetUnitFacingAngle(oClosestEnemyUnit)..'; iAOE='..iAOE..'; Damage of bomb at potential target='..M28Logic.GetDamageFromBomb(aiBrain, tPotentialAltTarget, iAOE, iDamage,   2,                                  2.5,                    nil,                            nil,                nil,                            0.6)) end
                                end
                            end

                            if tTarget and iBestTargetValue <= iBestValueOfDefensiveNuke and M28Utilities.IsTableEmpty(toClosestEnemyUntisByPlateauAndZone) == false and M28Utilities.IsTableEmpty(toClosestEnemyUntisByPlateauAndZone[toClosestEnemyUntisByPlateauAndZone[1]][toClosestEnemyUntisByPlateauAndZone[2]]) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will launch a defensive nuke, positio before adjust='..repru(tTarget)) end
                                --Doing a defensive nuke so target the enemy unit nearest us, and adjust slightly for its facing direction
                                ChangeTargetToClosestUnitToLauncher(toClosestEnemyUntisByPlateauAndZone[toClosestEnemyUntisByPlateauAndZone[1]][toClosestEnemyUntisByPlateauAndZone[2]])
                            elseif M28Utilities.IsTableEmpty(tTarget) == false then
                                --Still check if significant threat is made of mobile units

                                local tTargetZoneData, tTargetZoneTeamData = M28Map.GetLandOrWaterZoneData(tTarget, true, iTeam)
                                if bDebugMessages == true then LOG(sFunctionRef..': Arent firing as a defensvie unit, checking structure value in zone, tTargetZoneTeamData[M28Map.subrefThreatEnemyStructureTotalMass]='..(tTargetZoneTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 'nil')) end
                                if (tTargetZoneTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) <  iBestTargetValue * 0.5 then
                                    --Are there enemy experimentals or battleships in this zone?
                                    local tEnemyExperimentalsAndBattleships = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryNavalSurface * categories.BATTLESHIP,tTargetZoneTeamData[M28Map.subrefTEnemyUnits])
                                    M28Conditions.IsTableOfUnitsStillValid(tEnemyExperimentalsAndBattleships)
                                    if M28Utilities.IsTableEmpty(tEnemyExperimentalsAndBattleships) then
                                        tEnemyExperimentalsAndBattleships = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryNavalSurface * categories.BATTLESHIP, tTarget, iAOE, 'Enemy')
                                        if bDebugMessages == true then LOG(sFunctionRef..': No enemy experimentals in the zone being targeting, is units around point empty='..tostring(M28Utilities.IsTableEmpty(tEnemyExperimentalsAndBattleships))) end
                                    end
                                    if M28Utilities.IsTableEmpty( tEnemyExperimentalsAndBattleships) == false then
                                        local bHaveMobileUnitsAndNoUnderConstruction = false
                                        local bHaveAttackingOrPatrollingUnits = false

                                        for iUnit, oUnit in tEnemyExperimentalsAndBattleships do
                                            if bDebugMessages == true then LOG(sFunctionRef..': Checking enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; Dead='..tostring(oUnit.Dead or false)) end
                                            if oUnit:GetFractionComplete() < 1 and oUnit:GetFractionComplete() >= 0.05 then
                                                bHaveMobileUnitsAndNoUnderConstruction = false
                                                break
                                            else
                                                if oUnit:IsUnitState('Moving') then
                                                    bHaveMobileUnitsAndNoUnderConstruction = true
                                                elseif oUnit:IsUnitState('Attacking') or oUnit:IsUnitState('Patrolling') then
                                                    bHaveAttackingOrPatrollingUnits = true
                                                end
                                            end
                                        end
                                        local iDistanceAdjust
                                        if bHaveMobileUnitsAndNoUnderConstruction then iDistanceAdjust = iAOE * 0.75
                                        elseif bHaveAttackingOrPatrollingUnits then iDistanceAdjust = iAOE * 0.45
                                        end
                                        if iDistanceAdjust then
                                            if bDebugMessages == true then LOG(sFunctionRef..': tTarget before updating to nearest experimental or battleship='..repru(tTarget)) end
                                            ChangeTargetToClosestUnitToLauncher(tEnemyExperimentalsAndBattleships)
                                            if bDebugMessages == true then LOG(sFunctionRef..': tTarget after updating to nearest experimental or battleship='..repru(tTarget)) end
                                        end
                                    end
                                end
                            end
                            --Yolona target SMD that will stop us, if there are any, instead of our actual target, so we dont risk trying to take on loads of SMD in one go
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Checking if we are a yolona in which case we want to target any blocking SMD first, tTarget='..repru(tTarget)..'; bCheckForSMD='..tostring(bCheckForSMD)..'; Yolona='..tostring(EntityCategoryContains(categories.EXPERIMENTAL, oLauncher.UnitId))..'; Is table of enemy SMD empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]))..'; If enemy has more than 1 SMD will consider targeting SMD instead of the best target for the missile')
                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) == false then LOG(sFunctionRef..': Number of enemy SMD='..table.getn(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD])) end
                            end
                            if tTarget and not(bCheckForSMD) and EntityCategoryContains(categories.EXPERIMENTAL, oLauncher.UnitId) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) == false and table.getn(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) > 1 and not(oLauncher[M28UnitInfo.refbEasyBrain]) then
                                --WOrk out which SMD are intercepting our missile
                                local tSMDBlockingTarget = IsSMDBlockingTarget(aiBrain, tTarget, oLauncher:GetPosition(), 60, 0, true)
                                if bDebugMessages == true then
                                    LOG(sFunctionRef..': Is table of enemy SMD blocking target empty='..tostring(M28Utilities.IsTableEmpty(tSMDBlockingTarget)))
                                    if M28Utilities.IsTableEmpty(tSMDBlockingTarget) == false then LOG(sFunctionRef..': Number of SMD blocking target='..table.getn(tSMDBlockingTarget)) end
                                end
                                --Only target down SMD if we have 2+ SMD blocking our desired target (otherwise it may be better to just ignore)
                                if M28Utilities.IsTableEmpty(tSMDBlockingTarget) == false and table.getn(tSMDBlockingTarget) > 1 then
                                    local tAltTarget = GetBestAOETargetForSpecifiedBuildings(aiBrain, iTeam, oLauncher:GetPosition(), tSMDBlockingTarget, iAOE, iDamage)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Yolona target will be intercepted by SMD, want to take out the nearest blocking SMD first, tTarget='..repru(tTarget)..'; tAltTarget after facotirng in blockgin SMD='..repru(tAltTarget)) end
                                    if tAltTarget and (table.getn(tSMDBlockingTarget) >= 3 or HaventRecentlyNukedLocation(tAltTarget)) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will now draw ttarget and talttarget, tTarget will be in blue, tAltTarget will be in gold')
                                            M28Utilities.DrawLocation(tTarget)
                                            M28Utilities.DrawLocation(tAltTarget, 4)
                                        end

                                        tTarget = tAltTarget
                                    end
                                end
                            end
                        end

                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to launch at time '..GetGameTimeSeconds()..', tTarget='..repru(tTarget)) end
                        if tTarget then
                            --Launch missile
                            if bDebugMessages == true then LOG(sFunctionRef..': Will launch missile at tTarget='..repru(tTarget)..'; Cur time='..GetGameTimeSeconds()) end
                            if bTML then
                                --Adjust target it outside our range but inside our AOE
                                if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oLauncher.UnitId) then --redundancy to make sure not dealing with mobile unit
                                    local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(tTarget, oLauncher:GetPosition())
                                    if iDistToTarget > oLauncher[M28UnitInfo.refiManualRange] then
                                        if iDistToTarget - oLauncher[M28UnitInfo.refiManualRange] > oLauncher[M28UnitInfo.refiIndirectAOE] then
                                            M28Utilities.ErrorHandler('Have a TML launcher with a target outside its range+manual range')
                                        else
                                            tTarget = M28Utilities.MoveInDirection(oLauncher:GetPosition(), M28Utilities.GetAngleFromAToB(oLauncher:GetPosition(), tTarget), oLauncher[M28UnitInfo.refiManualRange] - 0.01)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Updating target so we can hit the actual target with our aoe, tTarget='..repru(tTarget)..'; iDistToTarget pre this adjust='..iDistToTarget) end
                                        end
                                    end
                                end
                                M28Orders.IssueTrackedTMLMissileLaunch(oLauncher, tTarget, 0.25, false, 'TMLFire', true)
                                if M28UnitInfo.GetMissileCount(oLauncher) <= 1 then
                                    oLauncher:SetAutoMode(true)
                                end
                                oLauncher:SetPaused(false)
                                if bDebugMessages == true then
                                    local tExpectedMissileVertical = M28Utilities.MoveInDirection(oLauncher:GetPosition(), M28Utilities.GetAngleFromAToB(oLauncher:GetPosition(), tTarget), 31, true)
                                    tExpectedMissileVertical[2] = tExpectedMissileVertical[2] + 60 --Doing testing, it actually only goes up by 50, but I think it travels in an arc from here to the target, as in a test scenario doing at less than +60 meant it thought it would hit a cliff when it didnt
                                    local bShotBlocked = M28Logic.IsLineBlocked(aiBrain, tExpectedMissileVertical, tTarget, iAOE, false)
                                    LOG(sFunctionRef..': Just launched tactical missile at tTarget='..repru(tTarget)..'; oLauncher position='..repru(oLauncher:GetPosition())..'; will draw in blue if think shot will hit, red if think shot blocked. dist to target='..M28Utilities.GetDistanceBetweenPositions(oLauncher:GetPosition(), tTarget)..'; launcher range='..oLauncher[M28UnitInfo.refiManualRange]..'; bShotBlocked='..tostring(bShotBlocked))
                                    local iColour = 1
                                    if bShotBlocked then iColour = 2 end
                                    M28Utilities.DrawLocation(tTarget, nil, iColour)
                                end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Have a nuke target, tTarget='..repru(tTarget)..'; have we not recently nuked this location='..tostring(HaventRecentlyNukedLocation(tTarget))..'; iTotalWaitCount='..iTotalWaitCount) end
                                if iTotalWaitCount >= 1 then
                                    if not(HaventRecentlyNukedLocation(tTarget)) then --, true, iTotalWaitCount * 0.1 + 2)) then
                                        --Presumably the target we chose as the best target is no longer appropriate because another nuke has just nuked it
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will wait 1 second then try getting a target again since we are about to nuke a location that we just nuked') end
                                        oLauncher[refbActiveMissileChecker] = false
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        WaitSeconds(1)
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                                        tTarget = nil
                                        --LOG('Forked consideration of launching missile 1')
                                        ForkThread(ConsiderLaunchingMissile, oLauncher, oOptionalWeapon)
                                    end
                                end
                                if tTarget then
                                    if bDebugMessages == true then
                                        M28Utilities.DrawCircleAtTarget({ tTarget[1], tTarget[2], tTarget[3] }, 2, 200, iAOE)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Giving order to fire nuke at tTarget='..repru(tTarget)..'; Launcher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..' owend by brain '..oLauncher:GetAIBrain().Nickname..'; iBestTargetValue='..(iBestTargetValue or 'nil')..'; Is SMD blocking target='..tostring(IsSMDBlockingTarget(aiBrain, tTarget, oLauncher:GetPosition(), 60, 0))..'; Time='..GetGameTimeSeconds()) end
                                    end
                                    M28Orders.IssueTrackedNukeMissileLaunch(oLauncher, tTarget, 2, false, 'Nuke', false)
                                    --[[M28Orders.IssueTrackedClearCommands(oLauncher)
                                    IssueNuke({oLauncher}, tTarget)
                                    oLauncher[reftActiveNukeTarget] = {tTarget[1], tTarget[2], tTarget[3]}
                                    --Unpause incase we paused previously
                                    if oLauncher[refbPausedAsNoTargets] then
                                        oLauncher[refbPausedAsNoTargets] = false
                                        if M28UnitInfo.GetMissileCount(oLauncher) <= 1 then
                                            oLauncher:SetAutoMode(true)
                                        end
                                        oLauncher:SetPaused(false)
                                    end
                                    if not(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]) then M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations] = {} end

                                    M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations][math.floor(GetGameTimeSeconds())] = tTarget--]]
                                    if bDebugMessages == true then LOG(sFunctionRef..': Launching nuke at tTarget='..repru(tTarget)..'; M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]='..repru(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations])..'; Time of game='..GetGameTimeSeconds()) end
                                    --Send a voice taunt if havent in last 10m and we expect to do significant damage
                                    if iBestTargetValue >= (25000 + 5000 * M28Chat.iNukeGloatingMessagesSent) then
                                        if bCheckForSMD or not(IsSMDBlockingTarget(aiBrain, tTarget, oLauncher:GetPosition(), 60, 0)) then
                                            M28Chat.iNukeGloatingMessagesSent = M28Chat.iNukeGloatingMessagesSent + 1
                                            ForkThread(M28Chat.SendGloatingMessage, aiBrain, 20, 600)
                                        end
                                    end
                                end
                            end
                        else
                            --Disable autobuild and pause
                            if not(oLauncher[refbPausedAsNoTargets]) and not(EntityCategoryContains(categories.EXPERIMENTAL, oLauncher.UnitId)) then
                                --Dont pause if we have loads of resources
                                if M28Conditions.HaveLowPower(iTeam) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 400 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.8 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 30 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 25 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.99))) then
                                    oLauncher[refbPausedAsNoTargets] = true
                                    oLauncher:SetAutoMode(false)
                                    oLauncher:SetPaused(true)
                                    if oLauncher.UnitId == 'xsb2401' then M28Utilities.ErrorHandler('Pausing Yolona') end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Pausing unit '..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..' as have no targets') end
                                end
                            end
                            oLauncher[refbActiveMissileChecker] = false
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitSeconds(10)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                            if bDebugMessages == true then LOG(sFunctionRef..': Have waited 10s, will now reconsider launching the missile, time='..GetGameTimeSeconds()) end
                            --LOG('Forked consideration of launching missile 2')
                            ForkThread(ConsiderLaunchingMissile, oLauncher, oOptionalWeapon)
                        end
                    end
                    --Already have an else error handler above so dont need below
                    --else M28Utilities.ErrorHandler('Unrecognised launcher type, UnitID='..(oLauncher.UnitId or 'nil')..'; wont consider launching a missile')
                end
                oLauncher[refbActiveMissileChecker] = false
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function IsSMDBlockingTarget(aiBrain, tTarget, tSMLPosition, iIgnoreSMDCreatedThisManySecondsAgo, iSMDRangeAdjust, bOptionalReturnTableOfBlockingSMD)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsSMDBlockingTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bEnemySMDInRange = false
    local iSMLToTarget = M28Utilities.GetDistanceBetweenPositions(tTarget, tSMLPosition)
    local iAngleSMLToTarget = M28Utilities.GetAngleFromAToB(tSMLPosition, tTarget)
    local iTargetToSMD

    local iSMLToSMD
    local iSMDRange
    local iAngleToSMD
    local bSMDInRangeOfMissile

    if bDebugMessages == true then LOG(sFunctionRef..': Considering tTarget='..repru(tTarget)..'; iIgnoreSMDCreatedThisManySecondsAgo='..(iIgnoreSMDCreatedThisManySecondsAgo or 1)..'; Current game time='..GetGameTimeSeconds()) end
    local iTeam = aiBrain.M28Team
    local tBlockingSMD

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) == false then
        local iBuildRateMod = 1
        for iSMD, oSMD in M28Team.tTeamData[iTeam][M28Team.reftEnemySMD] do
            if M28UnitInfo.IsUnitValid(oSMD) then
                --Update SMD time to complete tracker
                if oSMD:GetFractionComplete() < 1 then
                    oSMD[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds() - iTimeForSMDToBeConstructed * oSMD:GetFractionComplete()
                    if bDebugMessages == true then LOG(sFunctionRef..': Just updated oSMD as it is constructed now,  oSMD='..oSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSMD)..'; Owner='..oSMD:GetAIBrain().Nickname..'; Time='..GetGameTimeSeconds()) end
                end
                if iIgnoreSMDCreatedThisManySecondsAgo then iBuildRateMod = (oSMD:GetAIBrain()[M28Economy.refiBrainBuildRateMultiplier] or 1) end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering oSMD='..oSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSMD)..'; Cur time less time of last check or -10='..GetGameTimeSeconds() - (oSMD[M28UnitInfo.refiTimeOfLastCheck] or (GetGameTimeSeconds() - 10))..'; iIgnoreSMDCreatedThisManySecondsAgo='..(iIgnoreSMDCreatedThisManySecondsAgo or 'nil')..'; iBuildRateMod='..iBuildRateMod..'; oSMD[M28UnitInfo.refiTimeOfLastCheck]='..(oSMD[M28UnitInfo.refiTimeOfLastCheck] or 'nil')) end
                if GetGameTimeSeconds() - (oSMD[M28UnitInfo.refiTimeOfLastCheck] or (GetGameTimeSeconds() - 10)) > (iIgnoreSMDCreatedThisManySecondsAgo or 0) / iBuildRateMod then

                    bSMDInRangeOfMissile = false
                    iSMDRange = (oSMD:GetBlueprint().Weapon[1].MaxRadius or 90) + 1 + (iSMDRangeAdjust or 0)
                    iTargetToSMD = M28Utilities.GetDistanceBetweenPositions(tTarget, oSMD:GetPosition())

                    iSMLToSMD = M28Utilities.GetDistanceBetweenPositions(oSMD:GetPosition(), tSMLPosition)
                    iAngleToSMD = M28Utilities.GetAngleFromAToB(tSMLPosition, oSMD:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': oSMD='..oSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSMD)..'; iTargetToSMD='..iTargetToSMD..'; iSMLToSMD='..iSMLToSMD..'; iSMLToTarget='..iSMLToTarget..'; iSMDRange='..iSMDRange..'; oSMD[M27UnitInfo.refiTimeOfLastCheck]='..(oSMD[M28UnitInfo.refiTimeOfLastCheck] or 'nil')..'; Distance from target to oSMD='..M28Utilities.GetDistanceBetweenPositions(tTarget, oSMD:GetPosition())..'; iSMDRange='..iSMDRange..'; iAngleToSMD='..iAngleToSMD..'; iAngleSMLToTarget='..iAngleSMLToTarget..'; SMD position='..repru(oSMD:GetPosition())..'; tSMLPosition='..repru(tSMLPosition)..'; TargetPos='..repru(tTarget)..'; iAngleFromAToB - iAngleFromAToC='..(iAngleSMLToTarget - iAngleToSMD)..'; ConvertAngleToRadians(iAngleFromAToB - iAngleFromAToC)='..M28Utilities.ConvertAngleToRadians(iAngleSMLToTarget - iAngleToSMD)..'; math.tan(math.abs(ConvertAngleToRadians(iAngleFromAToB - iAngleFromAToC)))='..math.tan(math.abs(M28Utilities.ConvertAngleToRadians(iAngleSMLToTarget - iAngleToSMD)))..'; iDistFromAToC='..iSMLToSMD..'; Tan result times this distance='..iSMLToSMD*math.tan(math.abs(M28Utilities.ConvertAngleToRadians(iAngleSMLToTarget - iAngleToSMD)))) end

                    bSMDInRangeOfMissile = M28Utilities.IsLineFromAToBInRangeOfCircleAtC(iSMLToTarget, iSMLToSMD, iTargetToSMD, iAngleSMLToTarget, iAngleToSMD, iSMDRange)

                    if bSMDInRangeOfMissile then
                        if bDebugMessages == true then LOG(sFunctionRef..': SMD is in range and was built a while ago') end
                        bEnemySMDInRange = true
                        if not(bOptionalReturnTableOfBlockingSMD) then
                            break
                        else
                            if not(tBlockingSMD) then tBlockingSMD = {} end
                            table.insert(tBlockingSMD, oSMD)
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding SMD to table of blocking SMD') end
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': SMD is not blocking the target')
                    end

                elseif bDebugMessages == true then LOG(sFunctionRef..': SMD was only recently built, time we think the SMD was active='..GetGameTimeSeconds() - (oSMD[M28UnitInfo.refiTimeOfLastCheck] or (GetGameTimeSeconds() - 10)))
                end
            end
        end
    elseif bDebugMessages == true then LOG(sFunctionRef..': No enemy SMD detected')
    end
    if bDebugMessages == true then LOG(sFunctionRef..': bEnemySMDInRange='..tostring(bEnemySMDInRange)..'; Is table of blocking SMD empty='..tostring(M28Utilities.IsTableEmpty(tBlockingSMD))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bOptionalReturnTableOfBlockingSMD then
        return tBlockingSMD
    else
        return bEnemySMDInRange
    end
end

function GetHighestNukeTargetValue(tLZOrWZData, tLZOrWZTeamData, iTeam)
    --Refresh list if havent calcualted before or SMD has been refreshed; returns highest value target
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        if aiBrain then
            local iBestValue = 0
            local iCurValue

            function GetZoneValue(iEnemyStructureMass, iEnemyCombatThreat)
                return iEnemyStructureMass + iEnemyCombatThreat * 0.25
            end
            local tSMLPosition = tLZOrWZData[M28Map.subrefMidpoint]
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones]) or M28Team.tTeamData[iTeam][M28Team.refbEnemySMDDiedSinceLastNukeCheck] then
                --Do full calculation
                tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones] = {}
                --Make sure we have recorded pathing in a straight line for this zone (will only run if table is empty)
                M28Air.RecordOtherLandAndWaterZonesByDistance(tLZOrWZData, tLZOrWZData[M28Map.subrefMidpoint])
                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) then
                    M28Utilities.ErrorHandler('No other zones found')
                else
                    for iEntry, tSubtable in tLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                        local tAltLZOrWZData
                        local tAltLZOrWZTeamData
                        local sMidpointRef
                        local sCombatThreatRef
                        local iCurPlateauOrPond
                        local iCurLZOrWZRef = tSubtable[M28Map.subrefiLandOrWaterZoneRef]
                        if tSubtable[M28Map.subrefbIsWaterZone] then
                            sMidpointRef = M28Map.subrefMidpoint
                            sCombatThreatRef = M28Map.subrefTThreatEnemyCombatTotal
                            tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurLZOrWZRef]][M28Map.subrefPondWaterZones][iCurLZOrWZRef]
                            iCurPlateauOrPond = 0
                            tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                        else
                            sMidpointRef = M28Map.subrefMidpoint
                            sCombatThreatRef = M28Map.subrefTThreatEnemyCombatTotal
                            iCurPlateauOrPond = tSubtable[M28Map.subrefiPlateauOrPond]
                            tAltLZOrWZData = M28Map.tAllPlateaus[iCurPlateauOrPond][M28Map.subrefPlateauLandZones][iCurLZOrWZRef]
                            tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                        end
                        if not(IsSMDBlockingTarget(aiBrain, tAltLZOrWZData[sMidpointRef], tSMLPosition, 0, 0)) then
                            --Have a valid target
                            table.insert(tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones], {iCurPlateauOrPond, iCurLZOrWZRef })
                            iCurValue = GetZoneValue(tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass], tAltLZOrWZTeamData[sCombatThreatRef])
                            if iCurValue > iBestValue then
                                iBestValue = iCurValue
                            end
                        end
                    end
                end
            elseif M28Team.tTeamData[iTeam][M28Team.refbEnemySMDBuiltSinceLastNukeCheck] then
                --Check existing values for if still valid
                local iExistingEntries = table.getn(tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones])
                for iEntry = iExistingEntries, 1, -1 do
                    local tAltLZOrWZData
                    local tAltLZOrWZTeamData
                    local sMidpointRef
                    local sCombatThreatRef
                    local iCurPlateauOrPond = tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones][iEntry][1]
                    local iCurLZOrWZRef = tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones][iEntry][2]

                    if iCurPlateauOrPond == 0 then
                        sMidpointRef = M28Map.subrefMidpoint
                        sCombatThreatRef = M28Map.subrefTThreatEnemyCombatTotal
                        tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurLZOrWZRef]][M28Map.subrefPondWaterZones][iCurLZOrWZRef]
                        tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                    else
                        sMidpointRef = M28Map.subrefMidpoint
                        sCombatThreatRef = M28Map.subrefTThreatEnemyCombatTotal
                        tAltLZOrWZData = M28Map.tAllPlateaus[iCurPlateauOrPond][M28Map.subrefPlateauLandZones][iCurLZOrWZRef]
                        tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                    end
                    if IsSMDBlockingTarget(aiBrain, tAltLZOrWZData[sMidpointRef], tSMLPosition, 0, 0) then
                        --No longer have a valid target
                        table.remove(tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones], iEntry)
                    else
                        iCurValue = GetZoneValue(tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass], tAltLZOrWZTeamData[sCombatThreatRef])
                        if iCurValue > iBestValue then
                            iBestValue = iCurValue
                        end
                    end
                end
            end
            return iBestValue
        else
            M28Utilities.ErrorHandler('No alive M28 brain')
            return 0
        end
    else
        M28Utilities.ErrorHandler('No active M28 brains')
        return 0
    end
end

function RecheckForArtiTargetSoon(oArti)
    WaitSeconds(10)
    if M28UnitInfo.IsUnitValid(oArti) then
        M28UnitInfo.EnableUnitWeapon(oArti)
        GetT3ArtiTarget(oArti, false)
    end
end

function DontChangeCurrentScathisTarget(oArti)
    --returns true if we want to retain the current scathis target
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DontChangeCurrentScathisTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tLastOrder = oArti[M28Orders.reftiLastOrders][oArti[M28Orders.refiOrderCount]]
    local oCurTarget = tLastOrder[M28Orders.subrefoOrderUnitTarget]
    if M28UnitInfo.IsUnitValid(oCurTarget) then
        local iLowerTimeThreshold = 120
        local iUpperTimeThreshold = 300
        local iTimeSinceLastTargetAssessment = GetGameTimeSeconds() - (oArti[refiTimeLastGotBestArtiTarget] or -iUpperTimeThreshold)
        if bDebugMessages == true then LOG(sFunctionRef..': iTimeSinceLastTargetAssessment='..iTimeSinceLastTargetAssessment..'; oArti[refiLastTargetValue]='..(oArti[refiLastTargetValue] or 'nil')..'; tLastOrder[M28Orders.subreftOrderPosition]='..repru(tLastOrder[M28Orders.subreftOrderPosition])..'; oCurTarget='..(oCurTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oCurTarget) or 'nil')) end
        if iTimeSinceLastTargetAssessment < iUpperTimeThreshold and (iTimeSinceLastTargetAssessment < iLowerTimeThreshold or (oArti[refiLastTargetValue] or 0) >= 10000 + 30000 * (iUpperTimeThreshold - iTimeSinceLastTargetAssessment) / (iUpperTimeThreshold - iLowerTimeThreshold)) and (not(EntityCategoryContains(categories.MOBILE, tLastOrder[M28Orders.subrefoOrderUnitTarget].UnitId)) or M28Utilities.GetDistanceBetweenPositions(tLastOrder[M28Orders.subrefoOrderUnitTarget]:GetPosition(), tLastOrder[M28Orders.subreftOrderPosition]) <= 25) then
            IncreaseArtiShotCount(tLastOrder[M28Orders.subreftOrderPosition] or oCurTarget:GetPosition(), oArti:GetAIBrain().M28Team)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function IncreaseArtiShotCount(tActualTarget, iTeam, iOptionalShotCountOverride)
    --Increase shot count
    local iAltPlateauOrZero, iAltLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tActualTarget)
    local tAltLZOrWZTeamData
    if iAltPlateauOrZero == 0 then
        tAltLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAltLZOrWZ]][M28Map.subrefPondWaterZones][iAltLZOrWZ][M28Map.subrefWZTeamData][iTeam]
    else
        tAltLZOrWZTeamData = M28Map.tAllPlateaus[iAltPlateauOrZero][M28Map.subrefPlateauLandZones][iAltLZOrWZ][M28Map.subrefLZTeamData][iTeam]
    end

    tAltLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] = (tAltLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 0) + (iOptionalShotCountOverride or 1)
end

function DelayedScathisOrderChange(bAttackUnitNotGround, oArti, oBestTarget, tActualTarget)
    --E.g. for cases like LOUD where need to clear scathis orders when changing target to stop it moving around
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DelayedScathisOrderChange'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bWillIssueNewOrder = false

    local tLastOrder = oArti[M28Orders.reftiLastOrders][oArti[M28Orders.refiOrderCount]]
    if bAttackUnitNotGround then
        bWillIssueNewOrder = true
        if tLastOrder[M28Orders.subrefoOrderUnitTarget] == oBestTarget and tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAttack then bWillIssueNewOrder = false end
    else
        if tLastOrder[M28Orders.subreftOrderPosition] and M28Utilities.GetRoughDistanceBetweenPositions(tLastOrder, tActualTarget) > 1 then bWillIssueNewOrder = true end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Scathis oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)..'; bWillIssueNewOrder='..tostring(bWillIssueNewOrder or false)..'; oBestTarget='..(oBestTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBestTarget) or 'nil')..'; Time='..GetGameTimeSeconds()) end
    if bWillIssueNewOrder then
        local tAllWeapons = oArti:GetBlueprint().Weapon
        local iUnpackTime = 0
        if tAllWeapons then
            for iWeapon, tWeapon in tAllWeapons do
                iUnpackTime = math.max(iUnpackTime, (tWeapon.WeaponUnpackTimeout or 0))
            end
        end
        local bTrackForMovement = false
        if bDebugMessages == true then LOG(sFunctionRef..': iUnpackTime='..iUnpackTime) end
        if iUnpackTime > 0 then
            bTrackForMovement = true
            M28Orders.IssueTrackedClearCommands(oArti)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(iUnpackTime) --strangly when testing, if wait for unpack time + 1 tick, it causes scathis to move
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end

        function AttackOrigTarget(bQueuedOrder)
            if bDebugMessages == true then LOG(sFunctionRef..': About to issue attack order if target is still valid, is oBestTarget valid='..tostring(M28UnitInfo.IsUnitValid(oBestTarget))..'; Time='..GetGameTimeSeconds()) end
            if bAttackUnitNotGround then
                if M28UnitInfo.IsUnitValid(oBestTarget) then
                    M28Orders.IssueTrackedAttack(oArti, oBestTarget, bQueuedOrder, 'ScaAtU'..oBestTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestTarget), false)
                else
                    bTrackForMovement = false
                end
            else
                M28Orders.IssueTrackedGroundAttack(oArti, tActualTarget, 1, bQueuedOrder, 'ArtiSGF'..oBestTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestTarget), false, oBestTarget)
                --IncreaseArtiShotCount(tActualTarget, iTeam) --Dont call this here as woudlve already been called when doing the delayed order change
            end
        end
        AttackOrigTarget(false)

        if bTrackForMovement then
            --Redundancy - havent actually tested if it works as intended
            local iTimeToTrack = 5
            local iStartTime = GetGameTimeSeconds()
            while GetGameTimeSeconds() <= iStartTime + iTimeToTrack do
                WaitSeconds(1)
                if M28UnitInfo.IsUnitValid(oArti) and (not(bAttackUnitNotGround) or M28UnitInfo.IsUnitValid(oBestTarget)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Monitoring arti, Unit state='..M28UnitInfo.GetUnitState(oArti)..'; Time='..GetGameTimeSeconds()) end
                    if oArti:IsUnitState('Moving') then
                        M28Orders.IssueTrackedClearCommands(oArti)
                        if oArti[reftScathisBuiltLocation] and M28Utilities.GetDistanceBetweenPositions(oArti:GetPosition(), oArti[reftScathisBuiltLocation]) >= 15 then
                            M28Orders.IssueTrackedMove(oArti, oArti[reftScathisBuiltLocation], 1, false, 'ScathMvBk', false)
                        end
                        AttackOrigTarget(true)
                    end
                else
                    break
                end

            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetT3ArtiTarget(oArti, bCalledFromSalvoSize)
    --Gets oArti to fire an attack on the ground for where it thinks it will deal the most damage, works for t3 and experimental arti
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetT3ArtiTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bCalledFromSalvoSize then oArti[refbSalvoDelayActive] = false end
    if not(oArti[refbSalvoDelayActive]) then
        local iPlateau, iLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oArti:GetPosition())
        local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
        local aiBrain = oArti:GetAIBrain()
        local iTeam = aiBrain.M28Team
        local iArtiFacingAngle = M28UnitInfo.GetUnitFacingAngle(oArti)
        local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
        local iShotCount = 1
        if oArti.UnitId == 'url0401' then iShotCount = 0.1 end

        local iAOE, iDamage, iMinRange, iMaxRange, iSalvoSize, iSalvoIndividualDelay = M28UnitInfo.GetLauncherAOEStrikeDamageMinAndMaxRange(oArti)
        --Wait if salvo size >1
        local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
        if iSalvoSize > 1 and not(bCalledFromSalvoSize) and oArti[M28UnitInfo.refiLastWeaponEvent] then
            --E.g. scathis - dont want to change targets after firing a single shot - we have fired the scathis before, and this has presumably been called from the onweaponevent trigger

            local iTimeToWait = 4
            if (iSalvoIndividualDelay or 0) > 0 then iTimeToWait = iSalvoSize * iSalvoIndividualDelay + 0.1 end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(iTimeToWait)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if M28UnitInfo.IsUnitValid(oArti) then
                oArti[refbSalvoDelayActive] = true
                ForkThread(GetT3ArtiTarget, oArti, true)
            end
            --Scathis outside of FAF - it doesnt have a salvo, but does have wierd behaviour where changing targets causes it to move towards the target
        elseif not(M28Utilities.bFAFActive) and oArti.UnitId == 'url0401' and DontChangeCurrentScathisTarget(oArti) then
            if bDebugMessages == true then LOG(sFunctionRef..': Dont want to change t3 arti target yet as think we have a scathis') end
        else
            if (iMaxRange or 0) == 0 or (iAOE or 0) == 0 then M28Utilities.ErrorHandler('Arti '..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)..' has no range or no aoe')
            end

            --First make sure pathing is setup
            if M28Utilities.IsTableEmpty(oArti[reftiPlateauAndZonesInRange]) then
                oArti[reftiPlateauAndZonesInRange] = {}
                M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint])
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) then
                    M28Utilities.ErrorHandler('No other zones located for oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti))
                else
                    local iPlateauOrZero
                    if bDebugMessages == true then LOG(sFunctionRef..': About to search through all zones for targets for oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)..'; iMinRange='..(iMinRange or 'nil')..'; iMaxRange='..(iMaxRange or 'nil')) end
                    for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                        --Stop searching once got past arti max range
                        if tSubtable[M28Map.subrefiDistance] > iMaxRange then
                            if bDebugMessages == true then LOG(sFunctionRef..': Are outside the max range so wil stop searching') end
                            break
                        end
                        --If outside min range then include
                        if tSubtable[M28Map.subrefiDistance] > iMinRange then
                            --Add to potential zone table
                            local tAltLZOrWZData
                            local tAltLZOrWZTeamData
                            if tSubtable[M28Map.subrefbIsWaterZone] then
                                iPlateauOrZero = 0

                                tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[tSubtable[M28Map.subrefiLandOrWaterZoneRef]]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                            else
                                iPlateauOrZero = tSubtable[M28Map.subrefiPlateauOrPond]
                                tAltLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Recording plateau '..iPlateauOrZero..' zone '..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..' as being within max range') end
                            table.insert(oArti[reftiPlateauAndZonesInRange], {iPlateauOrZero, tSubtable[M28Map.subrefiLandOrWaterZoneRef], M28Utilities.GetDistanceBetweenPositions(tAltLZOrWZData[M28Map.subrefMidpoint], tAltLZOrWZTeamData[M28Map.reftClosestFriendlyBase]), M28Utilities.GetAngleFromAToB(oArti:GetPosition(), tAltLZOrWZData[M28Map.subrefMidpoint])})
                        end
                    end
                end
            end

            --Cycle through each zone that may be in range and pick the best one
            local iCurValue
            local iBestValue = 0
            local iSecondBestValue = 0
            local iBestPlateauOrZero, iBestLZOrWZ, iSecondBestPlateauOrZero, iSecondBestLZOrWZ, iBestAngleFactor, iSecondBestAngleFactor
            local iCurMobileThreat
            local iCurAAThreat
            local iShotMissFactor
            local iArtiAngleFactor

            for iEntry, tPlateauZoneAndDist in oArti[reftiPlateauAndZonesInRange] do
                local tAltLZOrWZData
                local tAltLZOrWZTeamData
                if tPlateauZoneAndDist[1] == 0 then
                    tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[tPlateauZoneAndDist[2]]][M28Map.subrefPondWaterZones][tPlateauZoneAndDist[2]]
                    tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                else
                    tAltLZOrWZData = M28Map.tAllPlateaus[tPlateauZoneAndDist[1]][M28Map.subrefPlateauLandZones][tPlateauZoneAndDist[2]]
                    tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                end
                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAltLZOrWZData[M28Map.subrefMidpoint]) then
                    iCurMobileThreat = ((tAltLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) + (tAltLZOrWZTeamData[M28Map.subrefWZThreatEnemySurface] or 0))
                    --Get more precise calculation - i.e. the threat calculation above reduces threat for health, meaning if we attack say a fatboy, its threat decreases as its shield decreases, making it likely we switch targets when its shield is about to be destroyed; however dont bother with low threat values
                    if iCurMobileThreat >= 1000 then
                        if tPlateauZoneAndDist[1] == 0 then
                            iCurMobileThreat = M28UnitInfo.GetMassCostOfUnits(EntityCategoryFilterDown(categories.MOBILE - M28UnitInfo.refCategoryAmphibious - categories.SUBMERSIBLE, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits]))
                        else
                            iCurMobileThreat = M28UnitInfo.GetMassCostOfUnits(EntityCategoryFilterDown(categories.MOBILE, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits]))
                        end
                    end
                    if tPlateauZoneAndDist[1] == 0 and tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] > 0 then
                        iCurValue = M28UnitInfo.GetMassCostOfUnits(EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits])) + iCurMobileThreat * 0.2
                    else
                        iCurValue = tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] + iCurMobileThreat * 0.2
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering plateau and zone '..tPlateauZoneAndDist[1]..'Z'..tPlateauZoneAndDist[2]..'; tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]='..(tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 'nil')..'; iCurMobileThreat='..iCurMobileThreat) end
                    --Add extra mobile threat if enemy has long ranged units and is close to our nearest base
                    if iCurMobileThreat >= 4000 and tPlateauZoneAndDist[3] <= 300 and M28Utilities.IsTableEmpty(tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) == false then
                        local iLongRangeThreat = 0
                        for iRange, iThreat in tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] do
                            if iRange >= 65 then --i.e. just above a megaliths range
                                iLongRangeThreat = iLongRangeThreat + iThreat
                            end
                        end
                        if iLongRangeThreat >= 1500 then
                            iCurValue = iCurValue + iCurMobileThreat * 0.8 --want based on mobile threat so less likely to run into issue for units like fatboy where threat decreases as shield decreases
                        end
                    end
                    --Add extra mobile threat if enemy has large mobile MAA
                    iCurAAThreat = (tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) + (tAltLZOrWZTeamData[M28Map.subrefWZThreatEnemyAA] or 0)
                    if iCurAAThreat >= 3000 then
                        local tEnemyMobileAA = EntityCategoryFilterDown(categories.MOBILE, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits])
                        if M28Utilities.IsTableEmpty( tEnemyMobileAA) == false then
                            iCurValue = iCurValue + iCurAAThreat * 0.2 + M28UnitInfo.GetMassCostOfUnits(tEnemyMobileAA) * 0.8
                        else
                            iCurValue = iCurValue + iCurAAThreat * 0.2
                        end
                    else
                        iCurValue = iCurValue + iCurAAThreat * 0.2
                    end

                    --Add extra threat if enemy has t2 arti near the nearest friendly base (relevant for team games, since 1v1 this hsould be inside the minimum rnage)
                    if tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] >= 4000 and tPlateauZoneAndDist[3] <= 200 and not(tPlateauZoneAndDist[1] == 0) then
                        local tEnemyT2ArtiAndMissileShips = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryTML + M28UnitInfo.refCategoryMissileShip, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits])
                        if M28Utilities.IsTableEmpty(tEnemyT2ArtiAndMissileShips) == false then
                            iCurValue = iCurValue + tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]
                        end
                    end

                    if bDebugMessages == true then LOG(sFunctionRef..': Considering plateau '..tPlateauZoneAndDist[1]..' and zone '..tPlateauZoneAndDist[2]..'; Dist='..tPlateauZoneAndDist[3]..'; iCurValue before factoring in ineffective shot count='..iCurValue..'; tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount]='..(tAltLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 'nil')..'; iCurAAThreat='..iCurAAThreat..'; iCurMobileThreat='..iCurMobileThreat..'; tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]='..tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]..'; iSecondBestValue='..iSecondBestValue) end

                    --Adjust value for number of times shots have hit
                    if iCurValue > iSecondBestValue then
                        --Adjust cur value for shot missed percentage
                        iShotMissFactor = GetArtiValueFactorForShotFailures((tAltLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 0))
                        --Adjust cur value for angle to target
                        iArtiAngleFactor = GetArtiValueFactorForFacingDifference(iArtiFacingAngle, tPlateauZoneAndDist[4])

                        iCurValue = iCurValue * iShotMissFactor * iArtiAngleFactor

                        --Record as best/second best
                        if iCurValue > iBestValue then
                            iSecondBestValue = iBestValue
                            iSecondBestPlateauOrZero = iBestPlateauOrZero
                            iSecondBestLZOrWZ = iBestLZOrWZ
                            iSecondBestAngleFactor = iBestAngleFactor
                            iBestValue = iCurValue
                            iBestPlateauOrZero = tPlateauZoneAndDist[1]
                            iBestLZOrWZ = tPlateauZoneAndDist[2]
                            iBestAngleFactor = iArtiAngleFactor
                        elseif iCurValue > iSecondBestValue then
                            iSecondBestValue = iCurValue
                            iSecondBestPlateauOrZero = tPlateauZoneAndDist[1]
                            iSecondBestLZOrWZ = tPlateauZoneAndDist[2]
                            iSecondBestAngleFactor = iArtiAngleFactor
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iCurValue after adj='..iCurValue..'; iShotMissFactor='..iShotMissFactor..'; iArtiAngleFactor='..iArtiAngleFactor) end
                    end
                end
            end

            --Now have the best 2 zones on an aggregate basis, get the best location for the arti target within these zones
            local iFriendlyUnitReductionFactor = 2
            local iFriendlyUnitAOEFactor = 2
            local iSizeAdjust = 0.25
            local iMultipleShotMod = 1
            local iMobileValueFactorInner = 0.4
            local iShieldReductionFactor = 0.25 --i.e. amount by which value of target will be reduced if it is under shielding
            --Reduce value of shields against high damage and aoe targets
            if iDamage >= 7500 and iAOE >= 6 then iShieldReductionFactor = math.min(math.max(iShieldReductionFactor, 0.8), iShieldReductionFactor * 1.5) end

            function GetBestUnitTargetAndValueInZone(iPlateauOrZero, iLZOrWZ, iAngleFactor)
                local tAltLZOrWZData
                local tAltLZOrWZTeamData
                local iCurValue
                local iBestValue = 0
                local oBestUnitTarget
                if iPlateauOrZero == 0 then
                    tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLZOrWZ]][M28Map.subrefPondWaterZones][iLZOrWZ]
                    tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                else
                    tAltLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLZOrWZ]
                    tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering best target in plateau '..iPlateauOrZero..'; Zone '..iLZOrWZ..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits]))) end
                if M28Utilities.IsTableEmpty(tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    local tPriorityUnits
                    local iMaxTargetsPerZone = 25
                    local bDontConsiderIfUnderwater = true
                    if iPlateauOrZero == 0 then bDontConsiderIfUnderwater = true end
                    if oArti[M28UnitInfo.refbEasyBrain] then
                        tPriorityUnits = EntityCategoryFilterDown(categories.EXPERIMENTAL + M28UnitInfo.refCategoryStructure * categories.TECH3 + M28UnitInfo.refCategoryStructure * categories.TECH2, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits])
                        iMaxTargetsPerZone = 10
                    else
                        tPriorityUnits = EntityCategoryFilterDown(categories.EXPERIMENTAL + categories.TECH3 + M28UnitInfo.refCategoryStructure * categories.TECH2 + M28UnitInfo.refCategoryCruiser * categories.TECH2, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits])
                    end

                    local iCurDist
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of priority units empty='..tostring(M28Utilities.IsTableEmpty(tPriorityUnits))) end
                    if M28Utilities.IsTableEmpty(tPriorityUnits) then tPriorityUnits = tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits] end
                    --Filter to the top 25 units in the zone by mass cost for performance reasons
                    local tiBaseValueOfPriorityUnits = {}
                    local iBaseValue

                    for iUnit, oUnit in tPriorityUnits do
                        --Double check are in range
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oArti:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering targeting oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..iCurDist..'; iMaxRange='..iMaxRange..'; iMinRange='..iMinRange..'; iAOE='..(iAOE or 'nil')..'; iDamage='..(iDamage or 'nil')..'; iFriendlyUnitReductionFactor='..(iFriendlyUnitReductionFactor or 'nil')..'; iFriendlyUnitAOEFactor='..(iFriendlyUnitAOEFactor or 'nil')..'; iSizeAdjust='..(iSizeAdjust or 'nil')..'; iMultipleShotMod='..(iMultipleShotMod or 'nil')..'; iMobileValueFactorInner='..(iMobileValueFactorInner or 'nil')..'; iShieldReductionFactor='..(iShieldReductionFactor or 'nil')) end
                            if iCurDist <= iMaxRange and iCurDist >= iMinRange and (bDontConsiderIfUnderwater or not(M28UnitInfo.IsUnitUnderwater(oUnit))) then
                                iBaseValue = (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * oUnit:GetFractionComplete()
                                if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) and oUnit:GetFractionComplete() >= 0.98 then iBaseValue = iBaseValue * iMobileValueFactorInner end
                                tiBaseValueOfPriorityUnits[iUnit] = iBaseValue
                            end
                        end
                    end
                    local iCurCount = 0
                    if M28Utilities.IsTableEmpty(tiBaseValueOfPriorityUnits) == false then
                        for iEntry, iValue in M28Utilities.SortTableByValue(tiBaseValueOfPriorityUnits, true) do
                            iCurCount = iCurCount + 1
                            if iCurCount > iMaxTargetsPerZone then break end
                            local oUnit = tPriorityUnits[iEntry]
                            --GetDamageFromBomb(aiBrain, tBaseLocation,     iAOE,   iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory, iOptionalReclaimFactor, bCheckIfUnderwater)
                            iCurValue = M28Logic.GetDamageFromBomb(aiBrain, oUnit:GetPosition(), iAOE, iDamage, iFriendlyUnitReductionFactor,       iFriendlyUnitAOEFactor,     false,                      iSizeAdjust,        iMultipleShotMod,                   iMobileValueFactorInner,                true,                   iShieldReductionFactor,         true,                           nil,                                    nil,                    nil,                    not(bDontConsiderIfUnderwater))
                            if bDebugMessages == true then LOG(sFunctionRef..': Damage from bomb if we target it at unit='..iCurValue..'; iBestValue='..(iBestValue or 'nil')) end
                            local iMinValue = 0
                            --Only set the min value if we dont have a negative value from the target (e.g. happens if targeting our own base or capture target)
                            if (iCurValue or 0) >= 0 and M28UnitInfo.IsUnitValid(oUnit) and oUnit.GetFractionComplete and (oUnit:GetFractionComplete() < 1 or EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId)) then
                                --redundancy for buildings and under construction units
                                iMinValue = (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * oUnit:GetFractionComplete()
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering increasing cur value to min basic value based on the unit target, iCurValue='..(iCurValue or 'nil')..'; iBestValue='..(iBestValue or 'nil')..'; iMinValue='..(iMinValue or 'nil')) end
                                iCurValue = math.max((iCurValue or 0), iMinValue)
                            end
                            if iCurValue > iBestValue then
                                iBestValue = iCurValue
                                oBestUnitTarget = oUnit
                                if bDebugMessages == true then LOG(sFunctionRef..': Setting the best unit target to '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iBestValue='..iBestValue) end
                            end
                        end
                    end
                end
                return oBestUnitTarget, iBestValue
            end

            local oBestTarget, iBestTargetValue = GetBestUnitTargetAndValueInZone(iBestPlateauOrZero, iBestLZOrWZ)
            if not(iBestAngleFactor) then iBestAngleFactor = GetArtiValueFactorForFacingDifference(0,180) end
            if not(iBestTargetValue) then iBestTargetValue = 0 end
            iBestTargetValue = iBestAngleFactor * iBestTargetValue
            if bDebugMessages == true then LOG(sFunctionRef..': iBestPlateauOrZero='..(iBestPlateauOrZero or 'nil')..'; iBestLZOrWZ='..(iBestLZOrWZ or 'nil')..'; iBestTargetValue='..(iBestTargetValue or 'nil')..'; oBestTarget='..(oBestTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBestTarget) or 'nil')..'; iBestAngleFactor='..(iBestAngleFactor or 'nil')) end
            if iSecondBestLZOrWZ then
                local oAltTarget, iAltTargetValue = GetBestUnitTargetAndValueInZone(iSecondBestPlateauOrZero, iSecondBestLZOrWZ)
                if bDebugMessages == true then LOG(sFunctionRef..': iSecondBestPlateauOrZero='..(iSecondBestPlateauOrZero or 'nil')..'; iSecondBestLZOrWZ='..(iSecondBestLZOrWZ or 'nil')..'; iAltTargetValue='..(iAltTargetValue or 'nil')..'; oAltTarget='..(oAltTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oAltTarget) or 'nil')..'; iBestTargetValue before considering this='..(iBestTargetValue or 'nil')..'; iSecondBestAngleFactor='..(iSecondBestAngleFactor or 'nil')) end
                if not(iSecondBestAngleFactor) then iSecondBestAngleFactor = GetArtiValueFactorForFacingDifference(0,180) end
                if not(iAltTargetValue) then iAltTargetValue = 0
                elseif oAltTarget.GetPosition then
                    --Get value from targeting the best target in this alt zone
                    --GetDamageFromBomb(aiBrain, tBaseLocation,             iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory, bCheckIfUnderwater)
                    iAltTargetValue  = M28Logic.GetDamageFromBomb(aiBrain, oAltTarget:GetPosition(), iAOE, iDamage, iFriendlyUnitReductionFactor,       iFriendlyUnitAOEFactor,     false,                      iSizeAdjust,        iMultipleShotMod,                   iMobileValueFactorInner,                true,                   iShieldReductionFactor,         true)
                end
                iAltTargetValue = iAltTargetValue * iSecondBestAngleFactor
                if bDebugMessages == true then LOG(sFunctionRef..': iAltTargetValue='..iAltTargetValue..'; iBestTargetValue before reflecting this='..iBestTargetValue) end
                if iAltTargetValue > iBestTargetValue then
                    oBestTarget = oAltTarget
                    iBestTargetValue = iAltTargetValue
                end
            end
            if not(oBestTarget) then
                M28Utilities.ErrorHandler('No target found for T3 arti, will fire at closest enemy base instead if we can hit it', true)
                local bGivenAltTarget = false
                local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                local iDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], oArti:GetPosition())
                if iDistToEnemyBase <= iMaxRange and iDistToEnemyBase >= iMinRange and ( bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZTeamData[M28Map.reftClosestEnemyBase])) then
                    --GetDamageFromBomb(aiBrain, tBaseLocation,                             iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory)
                    local iDamage = M28Logic.GetDamageFromBomb(aiBrain, tLZTeamData[M28Map.reftClosestEnemyBase], iAOE, iDamage, iFriendlyUnitReductionFactor, iFriendlyUnitAOEFactor,          false,                          iSizeAdjust,        iMultipleShotMod,               iMobileValueFactorInner,                    true,               iShieldReductionFactor,         true)
                    if iDamage >= 0 then --should mean dont have much in way of friendly forces there
                        --Check there are enemy units nearby
                        local bNearbyEnemyUnits = false
                        local tNearbyUnits = GetUnitsInRect(M28Utilities.GetRectAroundLocation(tLZTeamData[M28Map.reftClosestEnemyBase], iAOE * 1.3))
                        if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                            for iUnit, oUnit in tNearbyUnits do
                                if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategoryStructure - categories.TECH1 * categories.MOBILE, oUnit.UnitId) then
                                    if IsEnemy(oUnit:GetAIBrain():GetArmyIndex(), aiBrain:GetArmyIndex()) then
                                        bNearbyEnemyUnits = true
                                        break
                                    end
                                end
                            end
                        end
                        if bNearbyEnemyUnits then
                            iBestTargetValue = iDamage
                            --Is this the same as the last target?
                            oArti[refiLastTargetValue] = iBestTargetValue
                            local tLastOrder = oArti[M28Orders.reftiLastOrders][oArti[M28Orders.refiOrderCount]]
                            if tLastOrder[M28Orders.subreftOrderPosition] and M28Utilities.GetRoughDistanceBetweenPositions(tLastOrder, tLZTeamData[M28Map.reftClosestEnemyBase]) > 1 then
                                oArti[refiTimeLastGotBestArtiTarget] = GetGameTimeSeconds()
                                M28Orders.IssueTrackedGroundAttack(oArti, tLZTeamData[M28Map.reftClosestEnemyBase], 1, false, 'ArtiEB'..'ALZ'..iLandZone, false)
                                IncreaseArtiShotCount(tLZTeamData[M28Map.reftClosestEnemyBase], iTeam, iShotCount)
                            end
                            bGivenAltTarget = true
                        end
                    end
                end
                if not(bGivenAltTarget) then M28Orders.IssueTrackedClearCommands(oArti) end
            else
                local tActualTarget
                local tLeadingTarget
                local bAttackUnitNotGround = false
                if bDebugMessages == true then LOG(sFunctionRef..': Considering oBestTarget='..oBestTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestTarget)..'; Does this contain mobile='..tostring(EntityCategoryContains(categories.MOBILE, oBestTarget.UnitId))..'; Fraction complete='..oBestTarget:GetFractionComplete()..'; Is moving unit state='..tostring(oBestTarget:IsUnitState('Moving'))..'; Unit state='..M28UnitInfo.GetUnitState(oBestTarget)) end
                if EntityCategoryContains(categories.MOBILE, oBestTarget.UnitId) and oBestTarget:GetFractionComplete() == 1 and oBestTarget:IsUnitState('Moving') and not(oArti[M28UnitInfo.refbEasyBrain]) and (M28Utilities.bFAFActive or not(oArti.UnitId == 'url0401')) then
                    --If best target is mobile and moving, then consider a leading shot instead
                    local oBP = oArti:GetBlueprint()
                    local iWeaponVelocity
                    if oBP.Weapon then
                        for iCurWeapon, oCurWeapon in oBP.Weapon do
                            if (oCurWeapon.DamageRadius or 0) > 0 and (oCurWeapon.MaxRadius or 0) >= iMaxRange then
                                iWeaponVelocity = oCurWeapon.MuzzleVelocity
                                break
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iWeaponVelocity='..(iWeaponVelocity or 'nil')) end
                    if (iWeaponVelocity or 0) > 0 then
                        local iDistToEnemy = M28Utilities.GetDistanceBetweenPositions(oBestTarget:GetPosition(), oArti:GetPosition())
                        local iTimeToImpact = 0.5 + iDistToEnemy * 1.75 / iWeaponVelocity
                        local iCurFacingDirection = M28UnitInfo.GetUnitFacingAngle(oBestTarget)
                        local iDistToLead = iTimeToImpact * (oBestTarget:GetBlueprint().Physics.MaxSpeed or 0)
                        tLeadingTarget = M28Utilities.MoveInDirection(oBestTarget:GetPosition(), iCurFacingDirection, iDistToLead, true, false, M28Map.bIsCampaignMap)
                        if bDebugMessages == true then LOG(sFunctionRef..': tLeadingTarget='..repru(tLeadingTarget)..'; Dist to best arti='..M28Utilities.GetDistanceBetweenPositions(tLeadingTarget, oArti:GetPosition())..'; Min range='..iMinRange) end
                        if not(tLeadingTarget and M28Utilities.GetDistanceBetweenPositions(tLeadingTarget, oArti:GetPosition()) >= iMinRange) then
                            tLeadingTarget = nil
                        end
                    end
                end
                if tLeadingTarget then
                    if bDebugMessages == true then LOG(sFunctionRef..': Changing Arti target for oBestTarget='..oBestTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestTarget)..' to try and lead target, oBestTarget position='..repru(oBestTarget:GetPosition())..'; tLeadingTarget='..repru(tLeadingTarget)..'; Time='..GetGameTimeSeconds()) end
                    tActualTarget = tLeadingTarget
                elseif M28Utilities.bFAFActive or not(oArti.UnitId == 'url0401') then
                    --GetBestAOETarget(aiBrain, tBaseLocation,            iAOE, iDamage, bOptionalCheckForSMD, tSMLLocationForSMDCheck, iOptionalTimeSMDNeedsToHaveBeenBuiltFor, iSMDRangeAdjust, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, iOptionalMaxDistanceCheckOptions, iMobileValueOverrideFactorWithin75Percent, iOptionalShieldReductionFactor, iOptionalReclaimFactor)
                    tActualTarget = M28Logic.GetBestAOETarget(aiBrain, oBestTarget:GetPosition(), iAOE, iDamage, false,                 nil,                    nil,                                    nil,            iFriendlyUnitReductionFactor,       iFriendlyUnitAOEFactor,     nil,                            iMobileValueFactorInner,                    iShieldReductionFactor,         nil)
                else
                    if M28UnitInfo.CanSeeUnit(aiBrain, oBestTarget, false) then
                        bAttackUnitNotGround = true
                    end
                    tActualTarget = oBestTarget:GetPosition()
                end



                --Double check are still in range
                local iTargetDist = M28Utilities.GetDistanceBetweenPositions(tActualTarget, oArti:GetPosition())
                if bDebugMessages == true then LOG(sFunctionRef..': tActualTarget='..repru(tActualTarget)..'; iTargetDist='..iTargetDist..'; iBestTargetValue='..(iBestTargetValue or 'nil')) end
                if iTargetDist > iMaxRange or iTargetDist < iMinRange then
                    bAttackUnitNotGround = false --redundancy
                    tActualTarget = oBestTarget:GetPosition()
                end

                if M28Map.bIsCampaignMap and (iBestTargetValue or 0) < 0 then
                    --Disable weapon
                    M28UnitInfo.DisableUnitWeapon(oArti)
                    if bDebugMessages == true then LOG(sFunctionRef..': Disabling Arti weapon, oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)) end
                    ForkThread(RecheckForArtiTargetSoon, oArti)
                else

                    --Issue attack order
                    oArti[refiLastTargetValue] = iBestTargetValue
                    oArti[refiTimeLastGotBestArtiTarget] = GetGameTimeSeconds()
                    local tLastOrder = oArti[M28Orders.reftiLastOrders][oArti[M28Orders.refiOrderCount]]
                    if not(M28Utilities.bFAFActive) and oArti.UnitId == 'url0401' then
                        ForkThread(DelayedScathisOrderChange, bAttackUnitNotGround, oArti, oBestTarget, tActualTarget)
                    elseif bAttackUnitNotGround then
                        M28Orders.IssueTrackedAttack(oArti, oBestTarget, false, 'ScaAtU', false)
                    else
                        if tLastOrder[M28Orders.subreftOrderPosition] and M28Utilities.GetRoughDistanceBetweenPositions(tLastOrder, tActualTarget) > 1 then
                            M28Orders.IssueTrackedGroundAttack(oArti, tActualTarget, 1, false, 'ArtiGF'..'ALZ'..iLandZone, false, oBestTarget)
                        end
                    end
                    IncreaseArtiShotCount(tActualTarget, iTeam, iShotCount)
                end
            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetArtiValueFactorForShotFailures(iShotFailedCount)
    --iShotFailedCount: Should be (tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 0)
    local iFactor
    local iInterval = 13
    if iShotFailedCount >= iInterval then
        iFactor = math.max(0.03, 1 - math.floor(iShotFailedCount / iInterval) * iInterval * 0.03)
    else
        --Have failed fewer than 15 shots
        iFactor = 1
    end
    return iFactor
end
function GetArtiValueFactorForFacingDifference(iArtiFacingAngle, iAngleToTarget)
    local iAngleDif = M28Utilities.GetAngleDifference(iArtiFacingAngle, iAngleToTarget)
    if iAngleDif <= 10 then
        return 1
    else
        return 1 - 0.4 * iAngleDif / 180
    end
end

function JustFiredMissile(oLauncher)
    --Wait 1 tick then check if sitll have missile loaded and if so then consider firing another missile
    if EntityCategoryContains(M28UnitInfo.refCategoryTML + M28UnitInfo.refCategorySML, oLauncher.UnitId) then
        WaitTicks(1)
        if M28UnitInfo.IsUnitValid(oLauncher) then
            local iMissiles = 0 --For some reason the count is off by 1, presumably a slight delay between the event being called and the below ammo counts working
            if oLauncher.GetTacticalSiloAmmoCount then iMissiles = iMissiles + oLauncher:GetTacticalSiloAmmoCount() end
            if oLauncher.GetNukeSiloAmmoCount then iMissiles = iMissiles + oLauncher:GetNukeSiloAmmoCount() end
            if iMissiles > 0 then
                --LOG('consideration of launching missile 3')
                ConsiderLaunchingMissile(oLauncher)
            end
            --Track SML launchers who have recently fired
            if M28UnitInfo.IsUnitValid(oLauncher) and oLauncher:GetAIBrain().M28AI then
                if EntityCategoryContains(M28UnitInfo.refCategorySML, oLauncher.UnitId) then
                    local iTeam = oLauncher:GetAIBrain().M28Team
                    local bAddToTable = true
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers]) then M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers] = {}
                    else
                        for iRecordedLauncher, oRecordedLauncher in M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers] do
                            if oRecordedLauncher == oLauncher then
                                bAddToTable = false
                                break
                            end
                        end
                    end
                    if bAddToTable then
                        table.insert(M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers], oLauncher)
                    end
                end
            end

        end
    end
end

function ReserveLocationsForGameEnder(oUnit)
    --Reserve locations to provide shield coverage for oUnit
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReserveLocationsForGameEnder'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(oUnit[reftArtiTemplateRefs]) then --redundancy as shouldve already checked before getting here

        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, gametimeseconds is '..GetGameTimeSeconds()..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; owned by '..oUnit:GetAIBrain().Nickname..' on team '..oUnit:GetAIBrain().M28Team) end

        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
        if iLandZone > 0 then
            local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
            local tiShieldBuildLocationOptions = {}
            local tiShieldLocationCountByOption = {}
            local sBlueprintToBuild = 'xsb4202'
            local iNewBuildingDiameter = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
            local iNewBuildingRadius = iNewBuildingDiameter * 0.5
            local iAdjacencyBuildingRadius = M28UnitInfo.GetBuildingSize(oUnit.UnitId) * 0.5
            local tAdjacencyBuildingPosition = oUnit:GetPosition()

            local iCurZ, iCurX
            local iCornerAdjust = math.min(iNewBuildingDiameter, iAdjacencyBuildingRadius * 2)

            local iCurOptionCount = 0

            if bDebugMessages == true then LOG(sFunctionRef..': tAdjacencyBuildingPosition='..repru(tAdjacencyBuildingPosition)..'; iAdjacencyBuildingRadius='..iAdjacencyBuildingRadius..'; iNewBuildingRadius='..iNewBuildingRadius..'; iCornerAdjust='..iCornerAdjust) end
            local aiBrain = oUnit:GetAIBrain()

            --First go along top and bottom:
            local iCurMod = 0
            local iMostBuildLocations = 0
            local iBestOptionCountRef
            for iZFactor = -1, 1, 2 do
                iCurOptionCount = iCurOptionCount + 1
                tiShieldBuildLocationOptions[iCurOptionCount] = {}
                iCurZ = tAdjacencyBuildingPosition[3] + (iAdjacencyBuildingRadius + iNewBuildingRadius) * iZFactor
                --Include corner positions even though not adjacent
                for iCurX = tAdjacencyBuildingPosition[1] - iCornerAdjust, tAdjacencyBuildingPosition[1] + iCornerAdjust, 1 do
                    if iCurMod > 0 then
                        iCurMod = iCurMod - 1
                    elseif M28Engineer.CanBuildAtLocation(aiBrain, sBlueprintToBuild, { iCurX, 0, iCurZ}, iPlateau, iLandZone, nil, false, true, false, true) then
                        tiShieldLocationCountByOption[iCurOptionCount] = (tiShieldLocationCountByOption[iCurOptionCount] or 0) + 1
                        tiShieldBuildLocationOptions[iCurOptionCount][tiShieldLocationCountByOption[iCurOptionCount]] = {iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ}
                        iCurMod = iCurMod + iNewBuildingDiameter - 1
                        if tiShieldLocationCountByOption[iCurOptionCount] > iMostBuildLocations then
                            iMostBuildLocations = tiShieldLocationCountByOption[iCurOptionCount]
                            iBestOptionCountRef = iCurOptionCount
                            if iMostBuildLocations >= 3 then break end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished considering top or bottom, iZFactor='..(iZFactor or 'nil')..'; iCurOptionCount='..(iCurOptionCount or 'nil')..'; tiShieldBuildLocationOptions[iCurOptionCount]='..repru(tiShieldBuildLocationOptions[iCurOptionCount])..'; tiShieldLocationCountByOption[iCurOptionCount]='..(tiShieldLocationCountByOption[iCurOptionCount] or 'nil')..'; iMostBuildLocations='..iMostBuildLocations) end
                if iMostBuildLocations >= 3 then break end
                iCurMod = 0
            end
            if iMostBuildLocations < 3 then
                --Next go along the sides:
                for iXFactor = -1, 1, 2 do
                    iCurMod = 0
                    iCurOptionCount = iCurOptionCount + 1
                    tiShieldBuildLocationOptions[iCurOptionCount] = {}

                    iCurX = tAdjacencyBuildingPosition[1] + (iAdjacencyBuildingRadius + iNewBuildingRadius) * iXFactor
                    for iCurZ = tAdjacencyBuildingPosition[3] - iCornerAdjust, tAdjacencyBuildingPosition[3] + iCornerAdjust, 1 do
                        if iCurMod > 0 then
                            iCurMod = iCurMod - 1
                        elseif M28Engineer.CanBuildAtLocation(aiBrain, sBlueprintToBuild, { iCurX, 0, iCurZ}, iPlateau, iLandZone, nil, false, true, false, true) then
                            tiShieldLocationCountByOption[iCurOptionCount] = (tiShieldLocationCountByOption[iCurOptionCount] or 0) + 1
                            tiShieldBuildLocationOptions[iCurOptionCount][tiShieldLocationCountByOption[iCurOptionCount]] = {iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ}
                            iCurMod = iCurMod + iNewBuildingDiameter - 1
                            if tiShieldLocationCountByOption[iCurOptionCount] > iMostBuildLocations then
                                iMostBuildLocations = tiShieldLocationCountByOption[iCurOptionCount]
                                iBestOptionCountRef = iCurOptionCount
                                if iMostBuildLocations >= 3 then break end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering left or right side, iXFactor='..(iXFactor or 'nil')..'; iCurOptionCount='..(iCurOptionCount or 'nil')..'; tiShieldBuildLocationOptions[iCurOptionCount]='..repru(tiShieldBuildLocationOptions[iCurOptionCount])..'; tiShieldLocationCountByOption[iCurOptionCount]='..(tiShieldLocationCountByOption[iCurOptionCount] or 'nil')..'; iMostBuildLocations='..iMostBuildLocations) end
                    if iMostBuildLocations >= 3 then break end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iMostBuildLocations='..iMostBuildLocations) end

            if iMostBuildLocations >= 1 then
                --Figure out the best faction engineer that could realistically build the shield by locating the closest factory of each faction type
                local tLZTeamData = tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
                local iRecordedCount = 0
                if not(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) then tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] = {} end
                table.insert(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection], oUnit)
                RecordNearbyFactoryForShieldEngineers(oUnit)

                if bDebugMessages == true then LOG(sFunctionRef..': Can build at least 2 shields close to each other and the gameender, will now pick the best set of shield options, unit position='..repru(oUnit:GetPosition())..'; iBestOptionCountRef='..(iBestOptionCountRef or 'nil')..'; tiShieldBuildLocationOptions for this='..repru(tiShieldBuildLocationOptions[iBestOptionCountRef])) end
                if iBestOptionCountRef then
                    oUnit[reftLocationsForPriorityShield] = {}
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording priority shield locations, tLocations='..repru(tiShieldBuildLocationOptions[iBestOptionCountRef])) end
                    for iLocation, tLocation in tiShieldBuildLocationOptions[iBestOptionCountRef] do
                        iRecordedCount = iRecordedCount + 1
                        table.insert(oUnit[reftLocationsForPriorityShield], {tLocation[1], tLocation[2], tLocation[3]})
                        --Blacklist the location
                        M28Engineer.RecordBlacklistLocation(tLocation, iNewBuildingRadius, 600, oUnit)
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Added shild build location '..repru(tLocation)..' against the game ender and will record blacklist, Will draw shield locations in black')
                            M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tLocation, iNewBuildingRadius), 3, 100)
                        end
                    end
                    --Add other shield locations if there are any and we want more to get to 3
                    if iRecordedCount < 3 then
                        for iShieldOption, tShieldLocations in tiShieldBuildLocationOptions do
                            if not(iShieldOption == iBestOptionCountRef) then
                                for iLocation, tLocation in tShieldLocations do
                                    if M28Engineer.CanBuildAtLocation(aiBrain, sBlueprintToBuild, tLocation, iPlateau, iLandZone, nil, false, true, true, true) then
                                        iRecordedCount = iRecordedCount + 1
                                        table.insert(oUnit[reftLocationsForPriorityShield], {tLocation[1], tLocation[2], tLocation[3]})
                                        --Blacklist the location
                                        M28Engineer.RecordBlacklistLocation(tLocation, iNewBuildingRadius, 600, oUnit)
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef..': Added further shild build location '..repru(tLocation)..' against the game ender and will record blacklist, Will draw shield location')
                                            M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tLocation, iNewBuildingRadius), 4, 100)
                                        end
                                    end
                                end
                            end
                        end
                    end

                    --Update any buildable locaitons around here
                    if iRecordedCount > 0 then
                        for iLocation, tLocation in oUnit[reftLocationsForPriorityShield] do
                            M28Engineer.CheckIfBuildableLocationsNearPositionStillValid(aiBrain, tLocation, true, 5)
                        end
                    end


                    --CLear any engineers with queued orders that will conflict with a shield location
                    local tEngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tEngineersInZone) == false then
                        local bClearEngineer
                        local tEngineersToClear = {}
                        for iEngineer, oEngineer in tEngineersInZone do
                            bClearEngineer = false
                            if M28Utilities.IsTableEmpty(oEngineer[M28Engineer.reftQueuedBuildings]) == false then
                                for iQueueRef, tQueueDetails in oEngineer[M28Engineer.reftQueuedBuildings] do
                                    if tQueueDetails[M28Engineer.subrefBuildingLocation] then
                                        for iReservedLocation, tReservedLocation in oUnit[reftLocationsForPriorityShield] do
                                            if M28Utilities.GetDistanceBetweenPositions(tReservedLocation, tQueueDetails[M28Engineer.subrefBuildingLocation]) - tQueueDetails[M28Engineer.subrefBuildingRadius] < 0 then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have queued building '..tQueueDetails[M28Engineer.subrefBuildingID]..' at location that is within '..M28Utilities.GetDistanceBetweenPositions(tReservedLocation, tQueueDetails[M28Engineer.subrefBuildingLocation])..' of a shield reserved location, with building radius of '..tQueueDetails[M28Engineer.subrefBuildingRadius]..' so will clear the engineer') end
                                                bClearEngineer = true
                                                table.insert(tEngineersToClear, oEngineer)
                                                break
                                            end
                                        end
                                        if bClearEngineer then break end
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of engineers to clear empty='..tostring(M28Utilities.IsTableEmpty(tEngineersToClear))) end
                        if M28Utilities.IsTableEmpty(tEngineersToClear) == false then
                            for iEngineer, oEngineer in tEngineersToClear do
                                M28Orders.IssueTrackedClearCommands(oEngineer)
                            end
                        end
                    end


                end
                --[[for iOption, tLocations in tiShieldBuildLocationOptions do
                    if (tiShieldBuildLocationOptions[iOption] or 0) >= iMostBuildLocations then
                        oUnit[reftLocationsForPriorityShield] = {}
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording priority shield locations, tLocations='..repru(tLocations)..'; tiShieldBuildLocationOptions[iOption]='..repru(tiShieldBuildLocationOptions[iOption])..'; iOption='..(iOption or 'nil')) end
                        for iLocation, tLocation in tLocations do
                            table.insert(oUnit[reftLocationsForPriorityShield], {tLocation[1], tLocation[2], tLocation[3]})
                            --Blacklist the location
                            M28Engineer.RecordBlacklistLocation(tLocation, iNewBuildingRadius, 600, oUnit)
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Will draw shield locations in black')
                                M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tLocation, iNewBuildingRadius), 3, 100)
                            end
                        end
                        break
                    end
                end--]]
                M28Team.tTeamData[aiBrain.M28Team][M28Team.refbStartedOnUnitWantingSpecialShielding] = true
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetBestFactionFactoryOfCategory(oUnitToGetTo, iCategory, iDistanceCap, iLandSubteam, iUnitPlateau, tLZData)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBestFactionFactoryOfCategory'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iClosestFactory = iDistanceCap
    local iCurDist, iCurPlateau, iCurLandZone, iCurZoneDist
    local iClosestZoneDist = iDistanceCap + 60
    local oBestFactory
    for iBrain, oBrain in M28Team.tLandSubteamData[iLandSubteam][M28Team.subreftoFriendlyM28Brains] do
        local tFactoriesOfCategory = oBrain:GetListOfUnits(iCategory, false, true)
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of factories of catory empty for brain '..oBrain.Nickname..'='..tostring(M28Utilities.IsTableEmpty(tFactoriesOfCategory))) end
        if M28Utilities.IsTableEmpty(tFactoriesOfCategory) == false then
            for iFactory, oFactory in tFactoriesOfCategory do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; Fraction complete='..oFactory:GetFractionComplete()..'; Is factory valid='..tostring(M28UnitInfo.IsUnitValid(oFactory))) end
                if oFactory:GetFractionComplete() == 1 and M28UnitInfo.IsUnitValid(oFactory) then
                    --Is this in the same plateau?
                    iCurPlateau, iCurLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oFactory:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': iCurPlateau='..(iCurPlateau or 'nil')..'; iUnitPlateau='..(iUnitPlateau or 'nil')) end
                    if iCurPlateau == iUnitPlateau then
                        --Get the travel distance
                        iCurZoneDist = tLZData[M28Map.subrefLZTravelDistToOtherLandZones][iCurPlateau][iCurLandZone]
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering factory with iCurZoneDist='..(iCurZoneDist or 'nil')..'; iClosestZoneDist='..iClosestZoneDist..'; Dist between factory and unit to cover='..M28Utilities.GetDistanceBetweenPositions(oUnitToGetTo:GetPosition(), oFactory:GetPosition())) end
                        if iCurZoneDist then
                            if iCurZoneDist <= iClosestZoneDist then
                                if iCurZoneDist < iClosestZoneDist then
                                    iClosestZoneDist = iCurZoneDist
                                    iClosestFactory = iDistanceCap + 100 --reset the distance so any factory in a closer zone will be preferred, even if the factory itself might be further away
                                end
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnitToGetTo:GetPosition(), oFactory:GetPosition())
                                if iCurDist < iClosestFactory then
                                    iClosestFactory = iCurDist
                                    oBestFactory = oFactory
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oBestFactory
end

function UnitNoLongerRequiresFactoryFactionShieldEngineers(oUnit)
    local oFactory = oUnit[refoNearbyFactoryOfFaction]
    if M28UnitInfo.IsUnitValid(oFactory) and M28Utilities.IsTableEmpty(oFactory[reftoUnitsWantingFactoryEngineers]) == false then
        for iEntry, oEntry in oFactory[reftoUnitsWantingFactoryEngineers] do
            if oEntry == oUnit then
                table.remove(oFactory[reftoUnitsWantingFactoryEngineers], iEntry)
                break
            end
        end
        oUnit[refoNearbyFactoryOfFaction] = nil
    end
end

function RecordNearbyFactoryForShieldEngineers(oUnit, tbOptionalFactionsWanted)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordNearbyFactoryForShieldEngineers'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iDistanceCap = 350 --Wont try and get engineers from factories further away than this.
    local aiBrain = oUnit:GetAIBrain()
    local iLandSubteam = aiBrain.M28LandSubteam
    local oBestFactory

    local iUnitPlateau, iUnitLandZone
    if oUnit[reftArtiTemplateRefs] then iUnitPlateau = oUnit[reftArtiTemplateRefs][1] iUnitLandZone = oUnit[reftArtiTemplateRefs][2]
    else
        iUnitPlateau, iUnitLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want a special factory for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; tbOptionalFactionsWanted='..repru(tbOptionalFactionsWanted)..'; iUnitPlateau='..(iUnitPlateau or 'nil')..'; iUnitLandZone='..(iUnitLandZone or 'nil')..'; Time='..GetGameTimeSeconds()) end
    if (iUnitLandZone or 0) > 0 then
        local tLZData = M28Map.tAllPlateaus[iUnitPlateau][M28Map.subrefPlateauLandZones][iUnitLandZone]
        --Seraphim factories
        if not(tbOptionalFactionsWanted) or tbOptionalFactionsWanted[M28UnitInfo.refFactionSeraphim] then
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have Seraphim T3 land on our land subteam, iLandSubteam='..iLandSubteam..'; M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionSeraphim]='..repru(M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionSeraphim])) end
            if (M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionSeraphim][3] or 0) > 0 then
                oBestFactory = GetBestFactionFactoryOfCategory(oUnit, M28UnitInfo.refCategoryLandFactory * categories.TECH3 * categories.SERAPHIM, iDistanceCap, iLandSubteam, iUnitPlateau, tLZData)
                if bDebugMessages == true then LOG(sFunctionRef..': oBestFactory after checking for seraphim='..(oBestFactory.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBestFactory) or 'nil')) end
            end
        end
        if not(oBestFactory) then
            --Aeon
            if not(tbOptionalFactionsWanted) or tbOptionalFactionsWanted[M28UnitInfo.refFactionAeon] then
                if (M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionAeon][3] or 0) > 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to try and get the best factory at time '..GetGameTimeSeconds()..'; iDistanceCap='..(iDistanceCap or 'nil')..'; iLandSubteam='..(iLandSubteam or 'nil')..'; iUnitPlateau='..(iUnitPlateau or 'nil')..'; is tLZData empty='..tostring(M28Utilities.IsTableEmpty(tLZData))) end
                    oBestFactory = GetBestFactionFactoryOfCategory(oUnit, M28UnitInfo.refCategoryLandFactory * categories.TECH3 * categories.AEON, iDistanceCap, iLandSubteam, iUnitPlateau, tLZData)
                end
            end
            if not(oBestFactory) then
                --UEF
                if not(tbOptionalFactionsWanted) or tbOptionalFactionsWanted[M28UnitInfo.refFactionUEF] then
                    if (M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionUEF][3] or 0) > 0 then
                        oBestFactory = GetBestFactionFactoryOfCategory(oUnit, M28UnitInfo.refCategoryLandFactory * categories.TECH3 * categories.UEF, iDistanceCap, iLandSubteam, iUnitPlateau, tLZData)
                    end
                end
                --If dont have any of these factions then dont worry about getting a faction specific shield
            end
        end
        --If have a best factory then record against the game ender
        oUnit[refoNearbyFactoryOfFaction] = oBestFactory
        if bDebugMessages == true then LOG(sFunctionRef..': Finished looking for nearby factories, oBestFactory='..(oBestFactory.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBestFactory) or 'nil')) end
        if oBestFactory then
            if not(oBestFactory[reftoUnitsWantingFactoryEngineers]) then
                oBestFactory[reftoUnitsWantingFactoryEngineers] = {}
            end

            table.insert(oBestFactory[reftoUnitsWantingFactoryEngineers], oUnit)
            local iFactoryPlateau, iFactoryLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oBestFactory:GetPosition())
            local tFactoryLZTeamData = M28Map.tAllPlateaus[iFactoryPlateau][M28Map.subrefPlateauLandZones][iFactoryLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
            local bRecordedInZoneAlready = false
            if not(tFactoryLZTeamData[M28Map.reftFactoriesWantedForEngineers]) then tFactoryLZTeamData[M28Map.reftFactoriesWantedForEngineers] = {}
            else
                for iExistingFactory, oExistingFactory in tFactoryLZTeamData[M28Map.reftFactoriesWantedForEngineers] do
                    if oExistingFactory == oBestFactory then
                        bRecordedInZoneAlready = true
                    end
                end
            end
            if not(bRecordedInZoneAlready) then
                table.insert(tFactoryLZTeamData[M28Map.reftFactoriesWantedForEngineers], oBestFactory)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RemoveFactoryFromZoneList(oFactory)
    --If a factory was assigned as providing engineers to a unit such as a gameender for shielding, it'd be recorded in the zone it was in - this removes it (e.g. intended where the factory ahs no units to assist, or the factory is dead)
    local iFactoryPlateau, iFactoryLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oFactory:GetPosition())
    if iFactoryLandZone > 0 then
        local tLZTeamData = M28Map.tAllPlateaus[iFactoryPlateau][M28Map.subrefPlateauLandZones][iFactoryLandZone][M28Map.subrefLZTeamData][oFactory:GetAIBrain().M28Team]
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftFactoriesWantedForEngineers]) == false then
            local iExistingEntries = table.getn(tLZTeamData[M28Map.reftFactoriesWantedForEngineers])
            for iCurEntry = iExistingEntries, 1, -1 do
                if tLZTeamData[M28Map.reftFactoriesWantedForEngineers][iCurEntry] == oFactory or not(M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.reftFactoriesWantedForEngineers][iCurEntry])) then
                    table.remove(tLZTeamData[M28Map.reftFactoriesWantedForEngineers], iCurEntry)
                end
            end
        end
    end
end

function ClearTrackingOfDeadUnitWantingFactoryEngineers(oUnit)
    --If a gameender had a factory assigned as providing engineers e.g. for shielding, and the gameender is dead, then this clears related tracking
    if M28Utilities.IsTableEmpty(oUnit[refoNearbyFactoryOfFaction][reftoUnitsWantingFactoryEngineers]) == false then
        local oFactory = oUnit[refoNearbyFactoryOfFaction]
        local iExistingEntries = table.getn(oFactory[reftoUnitsWantingFactoryEngineers])
        for iCurEntry = iExistingEntries, 1, -1 do
            if oFactory[reftoUnitsWantingFactoryEngineers][iCurEntry] == oUnit or not(M28UnitInfo.IsUnitValid(oFactory[reftoUnitsWantingFactoryEngineers][iCurEntry])) then
                table.remove(oFactory[reftoUnitsWantingFactoryEngineers], iCurEntry)
            end
        end
        if M28Utilities.IsTableEmpty(  oFactory[reftoUnitsWantingFactoryEngineers]) then
            RemoveFactoryFromZoneList(oFactory)
        end
    end
    --Remove this unit from the zone
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
    local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) == false then
        local iTotalEntries = table.getn(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection])
        for iCurEntry = iTotalEntries, 1, -1 do
            if tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection][iCurEntry] == oUnit or not(M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection][iCurEntry])) then
                table.remove(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection], iCurEntry)
            end
        end
    end
end

function UpdateTrackingOfDeadFactoryProvidingEngineers(oUnit)
    --If a factory that was providing engineers e.g. to a gameender for shielding dies, this updates the tracking variables and looks for a new factory to provide engineers
    local iExistingEntries = table.getn(oUnit[reftoUnitsWantingFactoryEngineers])
    for iCurEntry = iExistingEntries, 1, -1 do
        if oUnit[reftoUnitsWantingFactoryEngineers][iCurEntry][refoNearbyFactoryOfFaction] == oUnit then
            oUnit[reftoUnitsWantingFactoryEngineers][iCurEntry][refoNearbyFactoryOfFaction] = nil
            if M28UnitInfo.IsUnitValid(oUnit[reftoUnitsWantingFactoryEngineers][iCurEntry]) then
                --Get a new 'best factory to provide engineers' for the game ender
                RecordNearbyFactoryForShieldEngineers(oUnit[reftoUnitsWantingFactoryEngineers][iCurEntry])
            end
        end
    end
    --Remove this factory from the list of factories in the zone
    oUnit[reftoUnitsWantingFactoryEngineers] = nil
    RemoveFactoryFromZoneList(oUnit)
end

function AssignShieldToGameEnder(oConstruction, oEngineer, oOptionalBackupGameEnderToAssignTo)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignShieldToGameEnder'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oConstruction:GetPosition())

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at game time '..GetGameTimeSeconds()..'; oConstruction='..(oConstruction.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oConstruction) or 'nil')..'; oEngineer='..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil')..'; oConstruction iPlateau='..(iPlateau or 'nil')..'; Zone='..(iLandZone or 'nil')..'; oConstruction position='..repru(oConstruction:GetPosition())) end
    if (iLandZone or 0) > 0 then
        local oGameEnder
        local aiBrain = oEngineer:GetAIBrain()
        local iTeam = aiBrain.M28Team
        local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
        if not(oEngineer[M28Engineer.refoUnitActivelyShielding]) then
            oGameEnder = oOptionalBackupGameEnderToAssignTo
            if not(oGameEnder) then
                M28Utilities.ErrorHandler('Dont have a unit recorded that the engineer is actively shielding, will just get the first gameender in the zone')
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) == false then
                    for iUnit, oUnit in tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
                        oGameEnder = oUnit
                        break
                    end
                end
            end
        else
            oGameEnder = oEngineer[M28Engineer.refoUnitActivelyShielding]
            if bDebugMessages == true then LOG(sFunctionRef..': Engineer is actively shielding oGameEnder='..(oGameEnder.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oGameEnder) or 'nil')) end
        end
        if M28UnitInfo.IsUnitValid(oGameEnder) then
            if not(oGameEnder[reftoSpecialAssignedShields]) then
                oGameEnder[reftoSpecialAssignedShields] = {}
            end
            table.insert(oGameEnder[reftoSpecialAssignedShields], oConstruction)
            oConstruction[refoGameEnderBeingShielded] = oGameEnder
            if bDebugMessages == true then LOG(sFunctionRef..': Added oConstruction to the table of assigned shields for gameender') end
        else
            if oGameEnder then
                M28Utilities.ErrorHandler('Dont have a valid unit')
            end
        end
    else
        M28Utilities.ErrorHandler('Dont have valid land zone for construction')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateForNukeMissileDeath(oLauncher, tOptionalLikelyTarget)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateForNukeMissileDeath'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start at time ='..GetGameTimeSeconds()..'; oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..'; oLauncher[reftActiveNukeTarget] before reset='..repru(oLauncher[reftActiveNukeTarget])) end
    oLauncher[reftActiveNukeTarget] = nil

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function DetermineBuildingExpectedValues()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DetermineBuildingExpectedValues'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local tsT1EnergyStorageBlueprints = EntityCategoryGetUnitList(M28UnitInfo.refCategoryEnergyStorage)
    local iLowestTechTier = 5
    local iHighestEnergyStored = 0
    local iCurTechLevel
    if M28Utilities.IsTableEmpty(tsT1EnergyStorageBlueprints) == false then
        for _, sBlueprint in tsT1EnergyStorageBlueprints do
            local oBP = __blueprints[sBlueprint]
            if (oBP.Economy.StorageEnergy or 0) > 0 then
                iCurTechLevel = M28UnitInfo.GetBlueprintTechLevel(sBlueprint)
                if iCurTechLevel < iLowestTechTier then
                    iLowestTechTier = iCurTechLevel
                    iHighestEnergyStored = oBP.Economy.StorageEnergy
                elseif iCurTechLevel == iLowestTechTier and iHighestEnergyStored < oBP.Economy.StorageEnergy then
                    iHighestEnergyStored = oBP.Economy.StorageEnergy
                end
            end
        end
    end
    iEnergyStorageExpectedCapacity = (iHighestEnergyStored or 5000)
    if bDebugMessages == true then LOG(sFunctionRef..': end of code, iHighestEnergyStored='..iHighestEnergyStored..'; iLowestTechTier='..iLowestTechTier) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedConsiderLaunchingMissile(oLauncher, iSecondsToWait, bCheckIfStillLoaded, bOnlyConsiderIfNotFiredRecently)
    --Call via forkthread
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DelayedConsiderLaunchingMissile'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitSeconds(iSecondsToWait)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28UnitInfo.IsUnitValid(oLauncher) then
        local bProceed = true
        if bCheckIfStillLoaded then
            bProceed = false
            local iMissiles = 0
            if oLauncher.GetTacticalSiloAmmoCount then iMissiles = iMissiles + oLauncher:GetTacticalSiloAmmoCount() end
            if oLauncher.GetNukeSiloAmmoCount then iMissiles = iMissiles + oLauncher:GetNukeSiloAmmoCount() end
            if iMissiles > 0 then bProceed = true end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Dealing with oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..'; bProceed='..tostring(bProceed)..'; Time='..GetGameTimeSeconds()) end
        if bProceed then
            if bDebugMessages == true then LOG(sFunctionRef..': Time since last weapon event='..(GetGameTimeSeconds() - oLauncher[M28UnitInfo.refiLastWeaponEvent] or -100)..'; iSecondsToWait='..iSecondsToWait..'; bOnlyConsiderIfNotFiredRecently='..tostring(bOnlyConsiderIfNotFiredRecently or false)) end
            if not(bOnlyConsiderIfNotFiredRecently) or GetGameTimeSeconds() - (oLauncher[M28UnitInfo.refiLastWeaponEvent] or -100) > iSecondsToWait then
                if bDebugMessages == true then LOG(sFunctionRef..': Will consider launching a missile') end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                --LOG('consideration of launching missile 4')
                ConsiderLaunchingMissile(oLauncher)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AreUnitsAdjacent(oFirstUnit, oSecondUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AreUnitsAdjacent'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iFirstUnitSize = M28UnitInfo.GetBuildingSize(oFirstUnit.UnitId) * 0.5
    local iSecondUnitSize = M28UnitInfo.GetBuildingSize(oSecondUnit.UnitId) * 0.5
    local iMaxDif = iFirstUnitSize + iSecondUnitSize + 0.749 --assumed margin of error after where got to with mexes (where would go with 2.749 distance)
    local iMinDif = iFirstUnitSize + iSecondUnitSize - 0.749

    local iXDif = math.abs(oFirstUnit:GetPosition()[1] - oSecondUnit:GetPosition()[1])
    local iZDif = math.abs(oFirstUnit:GetPosition()[3] - oSecondUnit:GetPosition()[3])
    if bDebugMessages == true then LOG(sFunctionRef..': Considering oFirstUnit='..oFirstUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFirstUnit)..'; Position='..repru(oFirstUnit:GetPosition())..'; Size='..iFirstUnitSize..'; Second unit='..oSecondUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSecondUnit)..'; oSecondUnit position='..repru(oSecondUnit:GetPosition())..'; iSecondUnitSize='..iSecondUnitSize..'; iXDif='..iXDif..'; iZDif='..iZDif) end
    if (iXDif <= iMaxDif and iXDif >= iMinDif) or (iZDif <= iMaxDif and iZDif >= iMinDif) then
        --Are we in a corner position?
        --[[local iCornerDif = iFirstUnitSize + iSecondUnitSize - 0.1
        if bDebugMessages == true then LOG(sFunctionRef..': Units are close to each other, iXDif='..iXDif..'; iZDif='..iZDif..'; iCornerDif='..iCornerDif) end
        if iXDif < iCornerDif or iZDif < iCornerDif then--]]
        --Max smallest dif due to size dif
        local iMaxSmallestDif = math.abs(iFirstUnitSize - iSecondUnitSize) + 0.749
        if iXDif < iMaxSmallestDif or iZDif < iMaxSmallestDif then


            if bDebugMessages == true then LOG(sFunctionRef..': Units are adjacent') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end
        --end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Units are adjacent') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function ConsiderGiftingPowerToTeammateForAdjacency(oUnit)
    --Call when a t3 power has been constructed by an M28 brain
    --WARNING: Not tested fully, so only gives a rough approximation.  do further testing if more accuracy needed

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderGiftingPowerToTeammateForAdjacency'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain = oUnit:GetAIBrain()
    local iTeam = aiBrain.M28Team
    if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 then
        local iPotentialAdjacencyCategories = M28UnitInfo.refCategoryExperimentalLevel + M28UnitInfo.refCategoryAirFactory + M28UnitInfo.refCategoryStructure * categories.TECH3

        if EntityCategoryContains(M28UnitInfo.refCategoryT3Power, oUnit.UnitId) then
            --Are we adjacent to any air factories, omni, nuke launchers, t3 arti, owned by another teammate, and have no adjacency of such units on our own?

            if bDebugMessages == true then LOG(sFunctionRef..': is table of adjacent units empty='..tostring(M28Utilities.IsTableEmpty(oUnit.AdjacentUnits))) end
            if M28Utilities.IsTableEmpty(oUnit.AdjacentUnits) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(iPotentialAdjacencyCategories, oUnit.AdjacentUnits)) then
                --We have no existing adjacency
                local tNearbyUnitsOfInterest = aiBrain:GetUnitsAroundPoint(iPotentialAdjacencyCategories, oUnit:GetPosition(), M28UnitInfo.GetBuildingSize(oUnit.UnitId) + 1, 'Ally')
                if M28Utilities.IsTableEmpty(tNearbyUnitsOfInterest) == false then
                    for iNearbyUnit, oNearbyUnit in tNearbyUnitsOfInterest do
                        if not(oNearbyUnit:GetAIBrain() == aiBrain) and oNearbyUnit:GetAIBrain().M28Team == iTeam then
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oNearbyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearbyUnit)..'; Position='..repru(oNearbyUnit:GetPosition())..'; oUnit position='..repru(oUnit:GetPosition())) end
                            if AreUnitsAdjacent(oUnit, oNearbyUnit) then
                                --Gift to other brain
                                M28Team.TransferUnitsToPlayer({oUnit}, oNearbyUnit:GetAIBrain():GetArmyIndex(), false)
                                break
                            end
                        end
                    end
                end
            end
        else
            local iSpecificAdjacencyCategories = M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti - categories.MOBILE + M28UnitInfo.refCategorySML * categories.TECH3 + M28UnitInfo.refCategoryAirFactory * categories.TECH3 + M28UnitInfo.refCategoryMassFab * categories.TECH3 + M28UnitInfo.refCategoryT3Radar
            if EntityCategoryContains(iSpecificAdjacencyCategories, oUnit.UnitId) then
                if bDebugMessages == true then LOG(sFunctionRef..': is table of adjacent units empty='..tostring(M28Utilities.IsTableEmpty(oUnit.AdjacentUnits))) end
                if M28Utilities.IsTableEmpty(oUnit.AdjacentUnits) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryT3Power, oUnit.AdjacentUnits)) then
                    --We have no existing adjacency
                    local tNearbyUnitsOfInterest = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryT3Power, oUnit:GetPosition(), M28UnitInfo.GetBuildingSize(oUnit.UnitId) + 1, 'Ally')
                    if M28Utilities.IsTableEmpty(tNearbyUnitsOfInterest) == false then
                        for iNearbyUnit, oNearbyUnit in tNearbyUnitsOfInterest do
                            if not(oNearbyUnit:GetAIBrain() == aiBrain) and oNearbyUnit:GetAIBrain().M28Team == iTeam then
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oNearbyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearbyUnit)..'; Position='..repru(oNearbyUnit:GetPosition())..'; oUnit position='..repru(oUnit:GetPosition())) end
                                if AreUnitsAdjacent(oUnit, oNearbyUnit) then
                                    --Gift nearby t3 power to this unit's brain owner
                                    M28Team.TransferUnitsToPlayer({oNearbyUnit}, oUnit:GetAIBrain():GetArmyIndex(), false)
                                    break
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function JustBuiltParagon(oParagon)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'JustBuiltParagon'

    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28UnitInfo.IsUnitValid(oParagon) then
        if bDebugMessages == true then LOG(sFunctionRef..': oParagon owner='..oParagon:GetAIBrain().Nickname..'; Unit='..oParagon.UnitId..M28UnitInfo.GetUnitLifetimeCount(oParagon)..'; GameTime='..GetGameTimeSeconds()..'; Fraction complete='..oParagon:GetFractionComplete()..'; oParagon(M28BuiltParagon)='..tostring(oParagon['M28BuiltParagon'] or false)) end
        if not(oParagon['M28BuiltParagon']) then
            oParagon['M28BuiltParagon'] = true
            local aiBrain = oParagon:GetAIBrain()
            local iTeam = aiBrain.M28Team
            local oOtherBrain
            local bGiftedParagonToOtherBrain = false
            if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 then
                --If we now own 2+ paragons, then gift this to a teammate
                if bDebugMessages == true then LOG(sFunctionRef..': Cur paragon units owned by brain='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryParagon)) end
                if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryParagon) >= 2 then
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        if not(oBrain == aiBrain) and not(oBrain.M28IsDefeated) and not(oBrain[M28Economy.refbBuiltParagon]) then
                            if oBrain[M28Economy.refiGrossMassBaseIncome] <= 500 and oBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryEngineer) >= 2 then
                                oOtherBrain = oBrain
                                break
                            end
                        end
                    end
                    if not(oOtherBrain) then
                        for iBrain, oBrain in ArmyBrains do
                            if oBrain.M28Team == iTeam and not(oBrain.M28AI) and not(oBrain[M28Economy.refbBuiltParagon]) and not(oBrain.CampaignAI) and oBrain[M28Economy.refiGrossMassBaseIncome] <= 500 and not(oBrain.M28IsDefeated) and oBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryEngineer) >= 3 and oBrain:GetCurrentUnits(M28UnitInfo.refCategoryParagon) == 0 then
                                oOtherBrain = oBrain
                                break
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is oOtherBrain nil='..tostring(oOtherBrain == nil)) end
                    if oOtherBrain then
                        bGiftedParagonToOtherBrain = true
                        local tUnitsToGift = {oParagon}
                        M28Team.TransferUnitsToPlayer(tUnitsToGift, oOtherBrain:GetArmyIndex(), false)
                        if not(oOtherBrain.M28AI) then
                            M28Chat.SendMessage(aiBrain, 'ParagGift'..aiBrain:GetArmyIndex(), 'You look like you could use this resource generator more than me', 0, 300, true, true, nil, nil)
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Have gifted paragon to teammate') end
                    end
                end
                if not(bGiftedParagonToOtherBrain) then


                    --Gift mexes, mass storage, RAS SACUs, and half of our pgens to another teammate
                    local iMaxEngineersToGift = math.min(aiBrain[M28Overseer.refiExpectedRemainingCap] * 0.5, 30)
                    local iEngineersGifted = 0
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        if not(oBrain == aiBrain) and not(oBrain.M28IsDefeated) then
                            if oBrain[M28Economy.refiGrossMassBaseIncome] <= 500 then
                                oOtherBrain = oBrain
                                --Gift all non-land factories (retain land so we still build some units), fatboys, nukes, SMD, aircraft carriers
                                local tFactoriesToGift = oBrain:GetListOfUnits(M28UnitInfo.refCategoryNavalFactory + M28UnitInfo.refCategoryAirFactory + M28UnitInfo.refCategoryQuantumGateway + M28UnitInfo.refCategorySML + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryCarrier + M28UnitInfo.refCategoryHive, false, true)
                                if M28Utilities.IsTableEmpty(tFactoriesToGift) == false then
                                    local tUnitsToGift = {}
                                    for iUnit, oUnit in tFactoriesToGift do
                                        if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then
                                            table.insert(tUnitsToGift, oUnit)
                                        end
                                    end
                                    if M28Utilities.IsTableEmpty(tUnitsToGift) == false then
                                        M28Team.TransferUnitsToPlayer(tUnitsToGift, aiBrain:GetArmyIndex(), false)
                                    end
                                end
                                if iEngineersGifted < iMaxEngineersToGift then
                                    local tEngineersAvailable = oBrain:GetListOfUnits(M28UnitInfo.refCategoryEngineer, false, true)
                                    if M28Utilities.IsTableEmpty(tEngineersAvailable) == false then
                                        local tEngineersToGift = {}
                                        local iCurCount = 0


                                        for iUnit, oUnit in tEngineersAvailable do
                                            iCurCount = iCurCount + 1
                                            if iCurCount >= 2 then
                                                if not(oUnit:IsUnitState('Attached')) and not(oUnit[M28Engineer.refbPrimaryBuilder]) then
                                                    table.insert(tEngineersToGift, oUnit)
                                                    iEngineersGifted = iEngineersGifted + 1
                                                    if iEngineersGifted >= iMaxEngineersToGift then break end
                                                end
                                                iCurCount = 0
                                            end

                                        end
                                        if M28Utilities.IsTableEmpty(tEngineersToGift) == false then
                                            M28Team.TransferUnitsToPlayer(tEngineersToGift, aiBrain:GetArmyIndex(), false)
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if not(oOtherBrain) then
                --Do we have other (non-M28) teammates we can gift to, that aren't campaign AI?
                local oFirstTeammateBrain
                local oFirstHumanBrain
                for iBrain, oBrain in ArmyBrains do
                    if not(oBrain.M28IsDefeated) and not(oBrain:IsDefeated()) and oBrain.M28Team == aiBrain.M28Team and not(oBrain == aiBrain) and not(oBrain.CampaignAI) then
                        if not(oFirstTeammateBrain) then oFirstTeammateBrain = oBrain end
                        if not(oBrain.BrainType == 'AI') and not(oFirstHumanBrain) then
                            oFirstHumanBrain = oBrain
                            break
                        end
                    end
                end
                if oFirstHumanBrain then oOtherBrain = oFirstHumanBrain else oOtherBrain = oFirstTeammateBrain end
            end
            if oOtherBrain and not(bGiftedParagonToOtherBrain) then
                local tUnitsToGift = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryT1Power + M28UnitInfo.refCategoryT2Power + M28UnitInfo.refCategoryMassStorage + M28UnitInfo.refCategoryRASSACU, false, true)
                if M28Utilities.IsTableEmpty(tUnitsToGift) then
                    tUnitsToGift = {}
                end
                local tT3Power = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryT3Power, false, true)
                if M28Utilities.IsTableEmpty(tT3Power) == false then
                    local iCurCount = -1
                    local iGiftThreshold = 1
                    for iUnit, oUnit in tT3Power do
                        iCurCount = iCurCount + 1
                        if iCurCount >= iGiftThreshold then
                            iCurCount = 0
                            table.insert(tUnitsToGift, oUnit)
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tUnitsToGift) == false then
                    M28Team.TransferUnitsToPlayer(tUnitsToGift, oOtherBrain:GetArmyIndex(), false)
                    if not(oOtherBrain.M28AI) then
                        M28Chat.SendMessage(aiBrain, 'ParagGift'..aiBrain:GetArmyIndex(), 'You look like you could use these resource buildings more than me', 0, 300, true, true, nil, nil)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function ConsiderManualT2ArtiTarget(oArti, oOptionalWeapon, iOptionalDelaySecondsAndWeaponFireCheck)
    --Considers giving manual orders to the T2 arti, so e.g. can use aoe and shot firing randomness to damage enemy shields just outside of our range

    --oOptionalWeapon - if called from the weapon fire event then this means we can check our last target
    --iOptionalDelaySecondsAndWeaponFireCheck - if specified, then will wait this many seconds then check if we have fired since the code started, and if not then proceed (used so if we are targeting a mobile unit and it goes out of our range we arent stuck with an invalid fire order)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderManualT2ArtiTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if not(oArti[M28UnitInfo.refbEasyBrain]) then
        local bProceedWithLogic = true
        if iOptionalDelaySecondsAndWeaponFireCheck then
            --e.g. we have targeted a mobile unit, so only check again if we have failed to fire recently
            bProceedWithLogic = false
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(iOptionalDelaySecondsAndWeaponFireCheck)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if not(oArti[M28UnitInfo.refiLastWeaponEvent]) or GetGameTimeSeconds() - oArti[M28UnitInfo.refiLastWeaponEvent] >= iOptionalDelaySecondsAndWeaponFireCheck - 0.01 then
                bProceedWithLogic = true
            end
        elseif oArti[M28UnitInfo.refiTimeBetweenIFShots] and GetGameTimeSeconds() - (oArti[M28UnitInfo.refiLastWeaponEvent] or -100) < oArti[M28UnitInfo.refiTimeBetweenIFShots] - 2 then
            if bDebugMessages == true then LOG(sFunctionRef..': Want to wait until Arti almost ready to fire before choosing the next target, oArti[M28UnitInfo.refiTimeBetweenIFShots]='..(oArti[M28UnitInfo.refiTimeBetweenIFShots] or 'nil')..'; Time since last weapn event='..(GetGameTimeSeconds() - (oArti[M28UnitInfo.refiLastWeaponEvent] or -100))) end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(math.min(oArti[M28UnitInfo.refiTimeBetweenIFShots] - 2, oArti[M28UnitInfo.refiTimeBetweenIFShots] -2 - (GetGameTimeSeconds() - (oArti[M28UnitInfo.refiLastWeaponEvent] or -100))))
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to proceed for oArti='..(oArti.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oArti) or 'nil')..'; Is oArti valid='..tostring(M28UnitInfo.IsUnitValid(oArti))..'; bProceedWithLogic='..tostring(bProceedWithLogic)..'; iOptionalDelaySecondsAndWeaponFireCheck='..(iOptionalDelaySecondsAndWeaponFireCheck or 'nil')..'; Is oOptionalWeapon nil='..tostring(oOptionalWeapon == nil)..'; Time='..GetGameTimeSeconds()) end
        if bProceedWithLogic and M28UnitInfo.IsUnitValid(oArti) then


            local bGivenOrder = false
            local tLastTarget
            if oOptionalWeapon.GetCurrentTarget then
                local vLastTarget = oOptionalWeapon:GetCurrentTarget()
                if vLastTarget.GetPosition then
                    tLastTarget = vLastTarget:GetPosition()
                elseif vLastTarget[1] and vLastTarget[3] and not(vLastTarget[4]) then
                    tLastTarget = {vLastTarget[1], vLastTarget[2], vLastTarget[3]}
                end
            end

            --Are there T2 arti nearby? if so then want to target the closest t2 arti or shield covering the t2 arti
            local aiBrain = oArti:GetAIBrain()
            local iTeam = aiBrain.M28Team
            local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oArti:GetPosition(), true, iTeam)
            local oClosestTargetOfInterest
            local iClosestTargetOfInterest
            if not(oArti[M28UnitInfo.refiIndirectRange]) then
                M28Utilities.ErrorHandler('Dont have indirect fire range for T2 Arti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti))
                iClosestTargetOfInterest = 115 + 30
            else
                iClosestTargetOfInterest = oArti[M28UnitInfo.refiIndirectRange] + 30 --wont bother trying to fire at something further away than this (and in some cases will need to be closer - ie.. depends on shielding situation)
            end
            local iCurDist
            local tArtiPosition = oArti:GetPosition()
            --Set the min range so we avoid targets inside this
            local iMinRange = oArti[M28UnitInfo.refiArtiMinRange]
            if not(iMinRange) then
                if oOptionalWeapon then
                    oArti[M28UnitInfo.refiArtiMinRange] = (oOptionalWeapon.MinRadius or 1)
                else
                    for iWeapon, tWeapon in oArti:GetBlueprint().Weapon do
                        if tWeapon.MinRadius then
                            oArti[M28UnitInfo.refiArtiMinRange] = tWeapon.MinRadius
                            break
                        end
                    end
                    iMinRange = oArti[M28UnitInfo.refiArtiMinRange]
                    if not(iMinRange) then
                        iMinRange = math.min(oArti[M28UnitInfo.refiIndirectRange] * 0.7, 50)
                    end
                end
            end

            function UpdateClosestUnit(tUnits)
                for iUnit, oUnit in tUnits do
                    if not(oUnit.Dead) then
                        --Check unit is on land and not attached
                        if not(oUnit:IsUnitState('Attached')) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tArtiPosition)
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurDist='..repru(iCurDist)..'; iClosestTargetOfInterest='..repru(iClosestTargetOfInterest)..'; iMinRange='..repru(iMinRange)) end
                            if iCurDist < iClosestTargetOfInterest and iCurDist >= iMinRange then
                                iClosestTargetOfInterest = iCurDist
                                oClosestTargetOfInterest = oUnit
                            end
                        end
                    end
                end
            end

            --First consider enemy fatboys
            if (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) > 0 then
                UpdateClosestUnit(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats])
            end

            if not(oClosestTargetOfInterest) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
                --Enemy has t2 arti nearby so consider groundfiring units unless they have a fatboy nearby
                UpdateClosestUnit(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits])
            end

            if not(oClosestTargetOfInterest) and tLastTarget then
                --No T2 arti but we were firing at something before, so check if any enemy shields or T2 arti or ravagers around the arti and (if so) if we want to ground fire them
                local tNearbyUnitsOfInterest = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryMissileShip + M28UnitInfo.refCategoryPD * categories.TECH3, tArtiPosition, iClosestTargetOfInterest - 1, 'Enemy')
                if M28Utilities.IsTableEmpty(tNearbyUnitsOfInterest) == false then
                    UpdateClosestUnit(tNearbyUnitsOfInterest)
                end
                if not(oClosestTargetOfInterest) then
                    tNearbyUnitsOfInterest = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryIndirectT2Plus + M28UnitInfo.refCategoryT2PlusPD + M28UnitInfo.refCategoryTMD + M28UnitInfo.refCategoryTML, oArti:GetPosition(), iClosestTargetOfInterest - 1, 'Enemy')
                    if M28Utilities.IsTableEmpty(tNearbyUnitsOfInterest) == false then
                        UpdateClosestUnit(tNearbyUnitsOfInterest)
                    end
                end
            end

            --If we have a unit consider attacking it, or groundfiring if it is out of our range
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for main target, oClosestTargetOfInterest='..(oClosestTargetOfInterest.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestTargetOfInterest) or 'nil')..'; iClosestTargetOfInterest='..iClosestTargetOfInterest) end
            if oClosestTargetOfInterest then
                --Is it covered by a fixed shield? if so then switch target to the closest shield that is covering it
                if M28Utilities.IsTableEmpty(oClosestTargetOfInterest[reftoShieldsProvidingCoverage]) == false then
                    local iOrigUnitDist = iClosestTargetOfInterest
                    local oOrigUnitTarget = oClosestTargetOfInterest
                    iClosestTargetOfInterest = 100000
                    UpdateClosestUnit(oClosestTargetOfInterest[reftoShieldsProvidingCoverage])
                    if iClosestTargetOfInterest >= 100000 then --Redundancy
                        iClosestTargetOfInterest = iOrigUnitDist
                        oClosestTargetOfInterest = oOrigUnitTarget
                    elseif bDebugMessages == true then LOG(sFunctionRef..': Original target was covered by a fixed shield so will target the shield instead, revised target='..oOrigUnitTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOrigUnitTarget)..'; iOrigUnitDist='..iOrigUnitDist)
                    end
                end

                --Now have selcted the unit we want to target - if its in our range then issue an attack order, otherwise issue a ground fire order
                local bTargetingMobileUnit = EntityCategoryContains(categories.MOBILE, oClosestTargetOfInterest.UnitId)
                bGivenOrder = true
                --Consider whether to ground fire
                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to do ground fire attack; iClosestTargetOfInterest='..iClosestTargetOfInterest..'; oArti[M28UnitInfo.refiIndirectRange]='..(oArti[M28UnitInfo.refiIndirectRange] or 'nil')) end
                if iClosestTargetOfInterest <= oArti[M28UnitInfo.refiIndirectRange] then
                    if bDebugMessages == true then LOG(sFunctionRef..': Can we see the oClosestTargetOfInterest='..tostring(M28UnitInfo.CanSeeUnit(aiBrain, oClosestTargetOfInterest, false))..'; oClosestTargetOfInterest='..(oClosestTargetOfInterest.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestTargetOfInterest) or 'nil')) end
                    if M28UnitInfo.CanSeeUnit(aiBrain, oClosestTargetOfInterest, false) then
                        M28Orders.IssueTrackedAttack(oArti, oClosestTargetOfInterest, false, 'ArtAt', false)
                    else
                        M28Orders.IssueTrackedGroundAttack(oArti, oClosestTargetOfInterest:GetPosition(), 0.1, false, 'ArtXG', false, oClosestTargetOfInterest)
                        if bDebugMessages == true then LOG(sFunctionRef..': Will do ground attack as cant see the unit') end
                    end
                else
                    --Ground fire as target is out of our range; dont even try ground firing if its not a shield and is well outside our range
                    if oClosestTargetOfInterest.MyShield or iClosestTargetOfInterest <= oArti[M28UnitInfo.refiIndirectRange] + 20 then

                        local iDistShortfall = 1
                        local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
                        if GetGameTimeSeconds() - (oArti[M28Events.refiLastWeaponEvent] or -100) >= 25 then iDistShortfall = 3 end --greater dist threshold in case are trying to fire at elevated position
                        local tGroundFireTarget = M28Utilities.MoveInDirection(tArtiPosition, M28Utilities.GetAngleFromAToB(tArtiPosition, oClosestTargetOfInterest:GetPosition()), (oArti[M28UnitInfo.refiIndirectRange] or 115) - iDistShortfall, true, false, M28Map.bIsCampaignMap)
                        if bDebugMessages == true then LOG(sFunctionRef..': Will gorund fire as target unit is outside our range, tGroundFireTarget='..repru(tGroundFireTarget)) end
                        if tGroundFireTarget then
                            M28Orders.IssueTrackedGroundAttack(oArti, tGroundFireTarget, 0.1, false, 'ArtGF', false, oClosestTargetOfInterest)
                        else
                            M28Utilities.ErrorHandler('Failed to calculate valid ground fire target for arti '..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti))
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Not targeting a shield and it is too far outside our range so will abort') end
                        bGivenOrder = false
                    end
                end

                --If we were targeting a mobile unit then reconsider targets 5s later if we have failed to fire a shot in the meantime
                if bTargetingMobileUnit then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to start a forked thread to re-consider t2 arti target as we are targeting a mobile unit') end
                    ForkThread(ConsiderManualT2ArtiTarget, oArti, oOptionalWeapon, 5)
                end
            end

            --Clear orders if last order was attack ground and we havent given any new order (so will revert to default weapon targeting)
            if not(bGivenOrder) then
                M28Orders.UpdateRecordedOrders(oArti)
                local iLastOrderType = oArti[M28Orders.reftiLastOrders][1][M28Orders.subrefiOrderType]
                if iLastOrderType == M28Orders.refiOrderIssueGroundAttack or iLastOrderType == M28Orders.refiOrderIssueAttack then
                    if bDebugMessages == true then LOG(sFunctionRef..': Couldnt find any targets and arti was given an attack or ground fire order so will clear the order') end
                    M28Orders.IssueTrackedClearCommands(oArti)
                else
                    --Give an attack ground order if we haven't fired a shot at all this game, so we are likely to be facing the right direction
                    local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
                    if bDebugMessages == true then LOG(sFunctionRef..': Last weapon event='..(oArti[M28Events.refiLastWeaponEvent] or 'nil')) end
                    if not(oArti[M28Events.refiLastWeaponEvent]) then
                        local tDirectionTowardsEnemy = M28Utilities.MoveInDirection(oArti:GetPosition(), M28Utilities.GetAngleFromAToB(oArti:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase]), (oArti[M28UnitInfo.refiIndirectRange] or 110) - 5, true, false, M28Map.bIsCampaignMap)
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and fire at tDirectionTowardsEnemy='..repru(tDirectionTowardsEnemy)..', Dist to arti='..M28Utilities.GetDistanceBetweenPositions(oArti:GetPosition(), tDirectionTowardsEnemy)) end
                        M28Orders.IssueTrackedGroundAttack(oArti, tDirectionTowardsEnemy, 0.1, false, 'ArtGF', false, oClosestTargetOfInterest)
                        --Clear this order in 5s if still not got a target
                        ForkThread(ConsiderManualT2ArtiTarget, oArti, oOptionalWeapon, 5)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetBestAOETargetForSpecifiedBuildings(aiBrain, iTeam, tLauncherPosition, tSMDBlockingTarget, iAOE, iDamage)
    --intended for yolona targeting blocking smds; start by getting the closest enemy SMD, returns revised target

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBestAOETargetForSpecifiedBuildings'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iClosestDist = 100000
    local oClosestSMD
    local iCurDist
    local tTarget
    local iClosestAltSMDToSMD = 100000
    local tNearbyAltSMD = {}

    if table.getn(tSMDBlockingTarget) == 1 then
        oClosestSMD = tSMDBlockingTarget[1]
    else
        for iSMD, oSMD in tSMDBlockingTarget do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tLauncherPosition, oSMD:GetPosition())
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestSMD = oSMD
            end
        end
    end

    --Competing concerns - if try to edge nuke SMD then might deal minimal damage to wider base once we break through; if instead target for max damage we might cause other SMD not previously in range to become in range
    --will therefore only consider best damage if there is only 1 SMD nearby

    local iNearbyThreshold = iAOE * 2
    local tiDistToClosestSMD = {}
    for iSMD, oSMD in M28Team.tTeamData[iTeam][M28Team.reftEnemySMD] do
        if not(oSMD == oClosestSMD) and M28UnitInfo.IsUnitValid(oSMD) then
            iCurDist = M28Utilities.GetDistanceBetweenPositions(oClosestSMD:GetPosition(), oSMD:GetPosition())
            if iCurDist < iNearbyThreshold then
                table.insert(tNearbyAltSMD, oSMD)
                table.insert(tiDistToClosestSMD, iCurDist)
            end
        end
    end
    if M28Utilities.IsTableEmpty(tNearbyAltSMD) == false then
        --work out the position that hits the max no. of units - approximate by taking the best midpoint between smd pairs that include the first
        local bCheckPlayableArea = M28Map.bIsCampaignMap
        local iBestSMDInRange = 0
        local tBestTarget
        for iSMD, oSMD in tNearbyAltSMD do
            local tCurMidpoint = M28Utilities.MoveInDirection(oClosestSMD:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestSMD:GetPosition(), oSMD:GetPosition()), tiDistToClosestSMD[iSMD] * 0.5, false, bCheckPlayableArea)
            local iSMDInRange = 2
            for iAltSMD, oAltSMD in tNearbyAltSMD do
                if not(oAltSMD == oSMD) then
                    if M28Utilities.GetDistanceBetweenPositions(tCurMidpoint, oAltSMD:GetPosition()) < iAOE then
                        if bDebugMessages == true then LOG(sFunctionRef..': IF target the midpoint between smd '..oSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSMD)..' and the closest SMD '..oClosestSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestSMD)..' then another SMD, oAltSMD='..oAltSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oAltSMD)..' is also in range. is alt smd valid='..tostring(M28UnitInfo.IsUnitValid(oAltSMD))) end
                        iSMDInRange = iSMDInRange + 1
                    end
                end
            end
            if iSMDInRange > iBestSMDInRange then
                tBestTarget = {tCurMidpoint[1], tCurMidpoint[2], tCurMidpoint[3]}
                iBestSMDInRange = iSMDInRange
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iBestSMDInRange='..iBestSMDInRange..'; oClosestSMD='..oClosestSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestSMD)) end
        if iBestSMDInRange >= 2 then
            tTarget = tBestTarget
        else
            tTarget = M28Logic.GetBestAOETarget(aiBrain, oClosestSMD:GetPosition(), iAOE, iDamage, false)
        end

    else
        tTarget = M28Logic.GetBestAOETarget(aiBrain, oClosestSMD:GetPosition(), iAOE, iDamage, false)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tTarget='..repru(tTarget)..'; Time='..GetGameTimeSeconds()) end
    return tTarget
end

function MonitorShieldsForCycling(tTableRef, iTeam, iLandZone, iTemplateRef)
    --Called from the gameender template logic
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MonitorShieldsForCycling'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(tTableRef[M28Map.subrefGEbActiveShieldMonitor]) and bShieldsCanDischarge then
        tTableRef[M28Map.subrefGEbActiveShieldMonitor] = true
        local oLowestHealthActiveShield, oHighestHealthActiveShield, iCompletedShieldCount, iCurHealth, iMaxHealth, iLowestHealth, iHighestHealth, iLongestRechargeTime
        local iSecondsBetweenShieldCycles = 1 --will change
        local M28Config = import('/mods/M28AI/lua/M28Config.lua')
        local bUpdateName = M28Config.M28ShowUnitNames
        local iCurShieldRadius, iShieldWithHealth

        while M28Conditions.IsTableOfUnitsStillValid(tTableRef[M28Map.subrefGEShieldUnits]) do
            --Get the highest and lowest health active shields
            iLowestHealth = 1000000
            iHighestHealth = 0
            oLowestHealthActiveShield = nil
            oHighestHealthActiveShield = nil
            iCompletedShieldCount = 0
            iLongestRechargeTime = 10
            iShieldWithHealth = 0
            for iShield, oShield in tTableRef[M28Map.subrefGEShieldUnits] do

                if oShield:GetFractionComplete() == 1 then
                    --Check we should include the shield (i.e. that it is covering the arti locations); assume UEF and seraphim T3+ are
                    if oShield[refbProtectingAllArtiLocations] == nil then
                        oShield[refbProtectingAllArtiLocations] = true --default
                        if not(EntityCategoryContains(categories.SERAPHIM + categories.UEF - categories.TECH2, oShield.UnitId)) then

                            iCurShieldRadius = (oShield:GetBlueprint().Defense.Shield.ShieldSize or 0) * 0.5
                            if iCurShieldRadius < 10 then
                                oShield[refbProtectingAllArtiLocations] = false
                            else
                                if M28Conditions.IsTableOfUnitsStillValid(tTableRef[M28Map.subrefGEArtiUnits]) then
                                    for iArti, oArti in tTableRef[M28Map.subrefGEArtiUnits] do
                                        if M28Utilities.GetDistanceBetweenPositions(oArti:GetPosition(), oShield:GetPosition()) > iCurShieldRadius then
                                            oShield[refbProtectingAllArtiLocations] = false
                                            break
                                        end
                                    end
                                else
                                    --Use expected arti locations
                                    for iArti, tArti in tTableRef[M28Map.subrefGEArtiLocations] do
                                        if M28Utilities.GetDistanceBetweenPositions(tArti, oShield:GetPosition()) > iCurShieldRadius then
                                            oShield[refbProtectingAllArtiLocations] = false
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; oShield[refbProtectingAllArtiLocations]='..tostring(oShield[refbProtectingAllArtiLocations] or false)) end
                    if oShield[refbProtectingAllArtiLocations] then
                        iCompletedShieldCount = iCompletedShieldCount + 1
                        iCurHealth, iMaxHealth = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' at time='..GetGameTimeSeconds()..'; iCurHealth='..iCurHealth..'; iMaxHealth='..iMaxHealth..'; Is shield enabled='..tostring(M28UnitInfo.IsUnitShieldEnabled(oShield))..'; Time since last discharge='..GetGameTimeSeconds() - (oShield[refiTimeOfLastDischarge] or -100)..'; Is shield paused='..tostring(oShield[M28UnitInfo.refbPaused] or false)) end
                        if iCurHealth > 0 then
                            iShieldWithHealth = iShieldWithHealth + 1
                            if iCurHealth < iLowestHealth then
                                iLowestHealth = iCurHealth
                                oLowestHealthActiveShield = oShield
                            end
                            if iCurHealth >= iHighestHealth then --want this to be >= and above to be < so that if we have 2 of the same shields at 100% health, we will have different shields recorded for lowest and highest health
                                iHighestHealth = iCurHealth
                                oHighestHealthActiveShield = oShield
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Time since last recharge='..GetGameTimeSeconds() - (oShield[refiTimeOfLastDischarge] or -100)..'; Is shield a transferred unit='..tostring(oShield[M28UnitInfo.refbTransferredUnit])..'; oUnit[refbShieldIsDisabled]='..repru(oShield[M28UnitInfo.refbShieldIsDisabled])) end

                            if oShield[refiTimeOfLastDischarge] and GetGameTimeSeconds() - oShield[refiTimeOfLastDischarge] >= math.max(iLongestRechargeTime + 10, 40) and GetGameTimeSeconds() - (oShield[M28UnitInfo.refiTimeCreated] or 0) >= 5 then
                                --Enable the shield incase it was somehow paused following the transfer
                                if bDebugMessages == true then LOG(sFunctionRef..': Enabling shield as it has been a long time since it was discharged, shield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; Time='..GetGameTimeSeconds()) end
                                M28UnitInfo.EnableUnitShield(oShield)
                            elseif not(oShield[refiTimeOfLastDischarge]) and oShield[M28UnitInfo.refbTransferredUnit] and oShield[M28UnitInfo.refbShieldIsDisabled] == nil and iCurHealth == 0 and oShield:GetAIBrain():GetEconomyStoredRatio('ENERGY') >= 0.1 and not(oShield[M28UnitInfo.refbPaused]) and GetGameTimeSeconds() - (oShield[M28UnitInfo.refiTimeCreated] or 0) >= 5 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have 0 health shield that was transferred so will try enabling shield, shield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; Time='..GetGameTimeSeconds()) end
                                M28UnitInfo.EnableUnitShield(oShield)
                            end
                        end

                        iLongestRechargeTime = math.max(iLongestRechargeTime, (oShield:GetBlueprint().Defense.Shield.ShieldRechargeTime or 0))
                    end
                end
            end
            if iCompletedShieldCount == 0 then break end
            if bDebugMessages == true then LOG(sFunctionRef..': Deciding how long to wait and whether to discharge a shield, iShieldWithHealth='..iShieldWithHealth..'; iCompletedShieldCount='..iCompletedShieldCount) end
            if not(oLowestHealthActiveShield) or oLowestHealthActiveShield == oHighestHealthActiveShield or iShieldWithHealth <= 1 then
                --We only have 1 shield active, so dont want to reset it
                iSecondsBetweenShieldCycles = 0.1 --review position next tick
                if bDebugMessages == true then LOG(sFunctionRef..': we either have no or 1 active shield so wont discharge but will check again in 1 tick') end
            else
                --We will presumably have waited the appropriate time before getting here, so can disable the lowest health shield; work out how long we want to wait for the next shield
                if iCompletedShieldCount > 1 then
                    iSecondsBetweenShieldCycles = iLongestRechargeTime / (iCompletedShieldCount - 1)
                else
                    --Redundancy - should be impossible to get here
                    iSecondsBetweenShieldCycles = 10
                end
                M28UnitInfo.DischargeShield(oLowestHealthActiveShield)
                if bDebugMessages == true then LOG(sFunctionRef..': have just discharged shield '..oLowestHealthActiveShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLowestHealthActiveShield)..' at time='..GetGameTimeSeconds()) end
                oLowestHealthActiveShield[refiTimeOfLastDischarge] = GetGameTimeSeconds()
                if bUpdateName then
                    M28Orders.UpdateUnitNameForOrder(oLowestHealthActiveShield, 'DischZ'..(oLowestHealthActiveShield[reftArtiTemplateRefs][2] or 'nil')..'T'..(oLowestHealthActiveShield[reftArtiTemplateRefs][3] or 'nil')..'; Tm='..math.floor(GetGameTimeSeconds()))
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(iSecondsBetweenShieldCycles)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': No longer have valid shields, so will flag that we have no active shield monitor, time='..GetGameTimeSeconds()) end
        tTableRef[M28Map.subrefGEbActiveShieldMonitor] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderFiringFirstLoadedNukeOnTeam(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderFiringFirstLoadedNukeOnTeam'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Called when an SMD has just been killed; wait 2 ticks in case the SMD was just being transferred
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(2)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local oSMLToConsiderFiring
    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
        if not(oBrain.M28Easy) then
            local tFriendlyNukes = oBrain:GetListOfUnits(M28UnitInfo.refCategorySML, true, false)
            if M28Utilities.IsTableEmpty(tFriendlyNukes) == false then
                for iNuke, oNuke in tFriendlyNukes do
                    if oNuke:GetFractionComplete() == 1 and oNuke.GetNukeSiloAmmoCount and oNuke:GetNukeSiloAmmoCount() >= 1 then
                        if not(oNuke[refiTimeLastFiredMissile]) or GetGameTimeSeconds() - oNuke[refiTimeLastFiredMissile] >= 10 then
                            oSMLToConsiderFiring = oNuke
                            break
                        end
                    end
                end
                if oSMLToConsiderFiring then break end
            end
        end
    end
    if oSMLToConsiderFiring then
        if bDebugMessages == true then LOG(sFunctionRef..': Will consider firing nuke launcher='..oSMLToConsiderFiring.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSMLToConsiderFiring)) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        --LOG('consideration of launching missile 5')
        ConsiderLaunchingMissile(oSMLToConsiderFiring)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordNukeTarget(iTeam, tLaunchLocation)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordNukeTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]) then
        if not(M28Team.tTeamData[iTeam]) then M28Team.tTeamData[iTeam] = {} end
        M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations] = {}
    end
    local iCurTime = math.floor(GetGameTimeSeconds())
    local iCycleCount = 0
    while M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations][iCurTime] do
        iCurTime = iCurTime - 0.0001
        iCycleCount = iCycleCount + 1
        if iCycleCount >= 30 then
            M28Utilities.ErrorHandler('Potential infinite loop, aborted recording nuke missile location')
            break
        end
    end
    M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations][iCurTime] = { tLaunchLocation[1],tLaunchLocation[2], tLaunchLocation[3] }
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iTeam='..iTeam..'; tLaunchLocation='..repru(tLaunchLocation)..'; Time='..GetGameTimeSeconds()..'; M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]='..repru(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function QuantumOpticsManager(aiBrain, oUnit)
    --Call via forkthread
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'QuantumOpticsManager'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28UnitInfo.IsUnitValid(oUnit) and not (oUnit[refbActiveOpticsManager]) then
        local iTeam = aiBrain.M28Team
        oUnit[refbActiveOpticsManager] = true
        local oBP = oUnit:GetBlueprint()
        local iIntelRange = (oBP.Intel.RemoteViewingRadius or oBP.Intel.VisionRadius)
        local iThresholdForAdjacentScry = iIntelRange * 2 * 1.3 --i.e. if we wouldnt cover all of the zone even with a 30% increase in the scry size, then we will scry the 4 corners
        local iDelayInSeconds = math.max(1, (oBP.Intel.ReactivateTime or 1) * 0.1)
        local iScryRelocationSize = iIntelRange * 1.45

        local iEntryCount
        local iEntryToScout
        local iCurLZOrWZ, iCurPlateauOrZero, iCurZoneSizeX, iCurZoneSizeZ
        function ReadyToScry()
            if aiBrain:GetEconomyStoredRatio('ENERGY') >= 1 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 250 and aiBrain:GetEconomyStored('ENERGY') >= 14000 and not (M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) then
                return true
            else
                return false
            end
        end
        local tAdjAreaToScout

        function ScryAdjacentAreaWhenReady(tBaseTarget, iXAdjust, iZAdjust)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(iDelayInSeconds)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            while not(ReadyToScry) do
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitSeconds(iDelayInSeconds)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
            tAdjAreaToScout = {tBaseTarget[1] + (iXAdjust or 0), tBaseTarget[2], tBaseTarget[3] + (iZAdjust or 0)}
            tAdjAreaToScout[2] = GetSurfaceHeight(tBaseTarget[1], tBaseTarget[3])
            if bDebugMessages == true then
                LOG(sFunctionRef..': Scrying adjacent area, tBaseTarget='..repru(tBaseTarget)..'; iXAdjust='..(iXAdjust or 'nil')..'; iZAdjust='..(iZAdjust or 'nil')..'; tAdjAreaToScout='..repru(tAdjAreaToScout)..'; Time='..GetGameTimeSeconds())
                M28Utilities.DrawLocation(tAdjAreaToScout, nil, nil, iIntelRange)
            end
            oUnit:OnTargetLocation(tAdjAreaToScout)
        end

        while M28UnitInfo.IsUnitValid(oUnit) do
            if oUnit:GetFractionComplete() == 1 then
                if ReadyToScry() then
                    M28Air.UpdateScoutingShortlist(iTeam)
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftLandAndWaterZoneScoutingShortlist]) == false then
                        --Pick a random location on the shortlist
                        iEntryCount = table.getn(M28Team.tTeamData[iTeam][M28Team.subreftLandAndWaterZoneScoutingShortlist])
                        iEntryToScout = math.random(1, iEntryCount)
                        iCurPlateauOrZero = M28Team.tTeamData[iTeam][M28Team.subreftLandAndWaterZoneScoutingShortlist][iEntryToScout][1]
                        iCurLZOrWZ = M28Team.tTeamData[iTeam][M28Team.subreftLandAndWaterZoneScoutingShortlist][iEntryToScout][2]
                        local tLZOrWZData, tLZOrWZTeamData
                        if iCurPlateauOrZero == 0 then
                            tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurLZOrWZ]][M28Map.subrefPondWaterZones][iCurLZOrWZ]
                            tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                            iCurZoneSizeX = ((tLZOrWZData[M28Map.subrefWZMaxSegX] or 0) - (tLZOrWZData[M28Map.subrefWZMinSegX] or 0)) * M28Map.iLandZoneSegmentSize
                            iCurZoneSizeZ = ((tLZOrWZData[M28Map.subrefWZMaxSegZ] or 0) - (tLZOrWZData[M28Map.subrefWZMinSegZ] or 0)) * M28Map.iLandZoneSegmentSize
                        else
                            tLZOrWZData = M28Map.tAllPlateaus[iCurPlateauOrZero][M28Map.subrefPlateauLandZones][iCurLZOrWZ]
                            tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                            iCurZoneSizeX = ((tLZOrWZData[M28Map.subrefLZMaxSegX] or 0) - (tLZOrWZData[M28Map.subrefLZMinSegX] or 0)) * M28Map.iLandZoneSegmentSize
                            iCurZoneSizeZ = ((tLZOrWZData[M28Map.subrefLZMaxSegZ] or 0) - (tLZOrWZData[M28Map.subrefLZMinSegZ] or 0)) * M28Map.iLandZoneSegmentSize
                        end

                        --Scout the midpoint
                        if bDebugMessages == true then LOG(sFunctionRef..': Scrying midpoint, tLZOrWZData[M28Map.subrefMidpoint]='..repru(tLZOrWZData[M28Map.subrefMidpoint])..'; iCurPlateauOrZero='..(iCurPlateauOrZero or 'nil')..'; iCurLZOrWZ='..(iCurLZOrWZ or 'nil'))
                            M28Utilities.DrawLocation(tLZOrWZData[M28Map.subrefMidpoint], nil, nil, iIntelRange)
                        end
                        oUnit:OnTargetLocation(tLZOrWZData[M28Map.subrefMidpoint]) --See M27 function ScryTarget for alternative ways of doing this that were attempted
                        --Update to reflect we have had visual of the target
                        tLZOrWZTeamData[M28Map.refiTimeLastHadVisual] = GetGameTimeSeconds()
                        --Large zones - scry to either side once ready
                        if iCurZoneSizeX > iThresholdForAdjacentScry then
                            --Scry each adjacent threshold; based on visualisation (sketchup as cant be bothered with the maths), for a 100 radius circle will cover most (but not all) of the surrounding area if the next scry location is 145 in each direction (north, east, south, west)
                            ScryAdjacentAreaWhenReady(tLZOrWZData[M28Map.subrefMidpoint], -iScryRelocationSize, 0)
                            ScryAdjacentAreaWhenReady(tLZOrWZData[M28Map.subrefMidpoint], iScryRelocationSize, 0)
                        end
                        if iCurZoneSizeZ > iThresholdForAdjacentScry then
                            ScryAdjacentAreaWhenReady(tLZOrWZData[M28Map.subrefMidpoint], 0, -iScryRelocationSize)
                            ScryAdjacentAreaWhenReady(tLZOrWZData[M28Map.subrefMidpoint], 0, iScryRelocationSize)
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': No locations on shortlist to scout')
                    end
                end
            end

            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(iDelayInSeconds)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end