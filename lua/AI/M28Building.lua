---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 29/01/2023 18:46
---

local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28Chat = import('/mods/M28AI/lua/AI/M28Chat.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')


--Global variables
iTMLMissileRange = 256 --e.g. use if dont have access to a unit blueprint
iEnergyStorageExpectedCapacity = 5000 --i.e. how much energy does an energy storage hold - for a long time for FAF was 5k, but beta balance changes (expected July 2023) are meant to be changing this
iTimeForSMDToBeConstructed = 45 --i.e. number of seconds we assume an SMD will be constructed in; even if it is built faster, it will be treated as having been built this many seconds ago so are being consistent with logic
bShieldsCanDischarge = true
bNovaxInGame = false
iLowestAirStagingTechAvailable = 3
iLowestMassStorageTechAvailable = 3
iLowestEnergyStorageTechAvailable = 3
tiWorstPDRangeByTech = {[1]=200,[2]=200,[3]=200,[4]=200}
iExperimentalShieldHealthValue = 90000 --i.e. if have shields with this much health or more in the game, will act as though there are overpowered shields and need to adjust approach
bHaveAllFactionExpPD = false --true if all 4 normal factions have access to T3+ PD
bHaveAllFactionExperimentalSAM = false --true if all 4 normal factions have access to experimental structure AA units

--Variables against a unit:
    --TML and TMD
reftTMLInRangeOfThisUnit = 'M28BuildTMLInRange' --Records table of TML in range of this unit
reftUnitsInRangeOfThisTML = 'M28BuildUnitsInRangeOfTML' --Records units threatened by this TML, from the perspective of the threatened unit's team
reftUnprotectedUnitTargetsForThisTML = 'M28BuildTargetsInRangeOfTML' --records units that TML should be able to hit, from the perspective of the TML owner's team
reftUnitsCoveredByThisTMD = 'M28BuildUnitsCoveredByTMD' --Against TMD, table of units that it provides TML coverage to
reftTMDCoveringThisUnit = 'M28BuildTMDCoveringUnit' --against unit, table of TMD providing TML coverage to it
refiLastDetailedTMDProtectionCount = 'M28BuildLstTMDPrC' --Records how many TMD are covering a unit from a specific TML - i.e. intended as part of TML battery logic, so only refresh this if the number isnt too high
refbUnitWantsMoreTMD = 'M28BuildUnitWantsTMD' --true if a unit wants more TMD
refiMinTMDWantedForUnit = 'M28BuildTMDMin' --number of TMD we want regardless of if there is a TML in range (i.e. preemptive TMD for a unit)
refbNoNearbyTMDBuildLocations = 'M28BuiltUnitHasNoNearbyTMDBuildLocations' --true if we buitl a TMD to cover this unit and the TMD ended up too far away
refbMissileRecentlyBuilt = 'M28BuildMissileBuiltRecently' --true if unit has recently built a missile
refbMissileChecker = 'M28BuildMissileChecker' --true if active missile builder checker for the unit
reftActiveNukeTarget = 'M28BuildLastTargetLaucnh' --Against oLauncher, returns location of the target we last launched a TML/Nuke at while the missile is still alive, set to nil once the missile dies
reftMobileTMLLastLocationChecked = 'M28BuildLastTMLLoc' --against mobile missile TMLs like ACU/SACU, to determine if shoudl rerun logic for identifying targets
refiTimeMobileTMLLastChecked = 'M28BuildLastTMLChk' --Gametimeseconds that we last refreshed a mobile TML's potential targets
refbTMDBuiltSinceLastChecked = 'M28BuildTMDMobChk' --true if we have built a TMD since the last time we checked mobile TML
refbActiveMissileChecker = 'M28BuildMissileTargetChecker' --true if active missile target checker for the unit
refbSpecialLauncherTargeting = 'M28BuildSpLnchTr' --true if we are using special logic to decide how to fire missiles (e.g. for TML batteries)
--iTMLHighPriorityCategories = M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryT3Mex * categories.CYBRAN + M28UnitInfo.refCategoryT2Mex + M28UnitInfo.refCategoryTML + M28UnitInfo.refCategorySML + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategoryT2Power + M28UnitInfo.refCategoryT3Radar
tbExpectMissileBlockedByCliff = 'M28BuildMisBlck' --true if missile firing at this has hit a cliff
refiTMLShotsFired = 'M28BuildTMLShtFird'
refiTMLShotsHit = 'M28TMLSnipeShtHt' --if TML missile damages a target or its shield then this should increase by 1
refoLastTMLTarget = 'M28BuildTMLLstTrg'
refoLastTMLLauncher = 'M28BuildTMLLastLnch' --When a TML targets a unit, this is recorded against that unit, so if we have 2 TML they shouldn't target the same unit at the same time
refiTimeOfLastLaunch = 'M28BuildTMLTimLstLnch' --Gametimeseconds that we last fired a missile at the unit, i.e. this is against the target, not the launcher
refiTimeLastFiredMissile = 'M28BuildTMLTmLstFir' --Gametimeseconds that the nuke last was given an order to fire a missile at something
refiTimeLastGotBestArtiTarget = 'M28BuildArtTgCh' --Gametimeseconds that the arti unit last was given an order to attack a unit/location
refiLastTMLMassKills = 'M28BuildTMLMssKil'
refbRecheckTMLAndTMDWhenConstructedByTeam = 'M28BuildRechckTMDTML' --if a unit is part complete then getunitsaroundpoint may not accurately pick it up (e.g. mex upgrading), so this falg is to make sure we have recorded all TM and TMD
refbPausedAsNoTargets = 'M28BuildPausNoT' --e.g. for SML use this to flag if we have paused it due to lack of targets
reftTerrainBlockedTargets = 'M28BuildTerrainBLock' --If a TML missile impacts terrain then record the original target
refbProtectedByTerrain = 'M28BuildUnitBlockByTer' --true if a target of a TML was protected by terrain
refbSalvoDelayActive = 'M28BuildSalvoDelayActive' --true if want to hold off on targets due to salvo
refiTimeTMDHitMissile = 'M28UTmHM' --Gametimeseconds that tmd intercepted enemy missile
toLaunchersIntercepted = 'M28BLnInt' --table of launchers that a TMD has intercepted

    --Shield related
reftoShieldsProvidingCoverage = 'M28BuildShieldsCoveringUnit' --Against unit being shielded, records the fixed shields that are covering it
reftoUnitsCoveredByShield = 'M28BuildUnitsCoveredByShield' --Against shield, returns table of units covered by shield
--refiShieldsWanted = 'M28BuildShieldsWanted' --number of fixed shield coverage wanted for the unit
refbUnitWantsShielding = 'M28BuildUnitWantsFixedShield' --true if unit wants a fixed shield
refbPriorityShield = 'M28BuildPriorityShield' --True if shield is a priority shield for assistance
refbRemoveShieldFromPriorityTableWhenFullHealth = 'M28BuildRemPrSh' --true if the shield should be removed from the table of shields wanting priority shielding when full health
refoPriorityShieldProvidingCoverage = 'M28BuildPriorityShieldCoveringUnit' --Against unit being shielded; If a shield marked as a priority shield is covering the unit, then this should return that shield
refoNearbyFactoryOfFaction = 'M28BuildNrFactionFac' --assigned against a gameender, to record that it can obtain engineers of a particular faction (for shielding purposes)
reftoUnitsWantingFactoryEngineers = 'M28BuildEngFac' --table of any units that have htis factory as their 'nearest' factory - intended for gamenders so can track which game enders assume this factory can provide engineers
reftLocationsForPriorityShield = 'M28BuildShdLoc' --against a unit (such as a game ender), [x] = 1,2,3...; returns the predetermined reserved location to build a shield in order to cover the game ender
reftoSpecialAssignedShields = 'M28BuildSpecAssShield' --against a unit (such as a game ender), [x] = 3 or 2 or 1 based on the reftLocationsForPriorityShield index; for special shielding gameender logic
refoGameEnderBeingShielded = 'M28BuildSpecShdlTarg' --against a shield, records the unit it has been assigned to (i.e. the corresponding variable for reftoSpecialAssignedShields)
reftArtiTemplateRefs = 'M28ArtiTemplateRef' --returns {iPlateau, iLandZone, iTemplateRef}, with tempalteref being the index for tLZTeamData[reftActiveGameEnderTemplates], assigned to any units that form part of it
refiTimeOfLastDischarge = 'M28ShLastDisc' --gametime that we gave a discharge order, so can check for redundancies
refbRecentlyCheckedTMDOrTML = 'M28BRChTm' --true if we have recently checked this unit for if it has tml/tmd coverage etc. against land zone
refiManuallyEnabledTime = 'M28ShLstMnEn' --gametimeseconds that we ran enableshield due to a potential bug
refiTimeOfLastAeonT3ArtiDamageToShield = 'M28ShLstAT3' --Gametimeseconds that an Aeon T3 arti last dealt damage to this shield


--T3 arti specific
reftiPlateauAndZonesInRange = 'M28BuildArtiPlatAndZInRange' --entries in order of distance, 1,2,3 etc, returns {iPlateauOrZero, iLandOrWaterZoneRef}
refbProtectingAllArtiAndShieldLocations = 'M28BuildShdProtAllArti' --true if a shield is covering the midpoint of all arti and shield locations (or arti units) - used os we avoid including in shield cycling shields like aeon shields that are too far away
refiLastTargetValue = 'M28ArtiTgVal' --value of the last target the arti targeted

--T2 arti specific
reftbTerrainBlockedTargetsBySegment = 'M28BTArtBl' --against our T2 arti, [x] is segmentX, returns {y}, where [y] is segmentZ, returns true (if blocked)

--Special buildings
refbActiveOpticsManager = 'M28BuildActOptMan' --true if have active quantum optics manager
reftScathisBuiltLocation = 'M28ScaBultLoc' --location that scathis construction was started

function CheckIfUnitWantsFixedShield(oUnit, bCheckForNearbyShields, iOptionalShieldsWantedOverride)
    --Intended to be called whenever something happens that means oUnit may want to change whehter it is recorded as wanting a shield, except for death which is handled elsewhere now
    --oUnit construction is started (done via OnConstructionStarted)
    --A shield covering oUnit dies (done via UpdateShieldCoverageOfUnits)
    --A shield covering oUnit has construction started (done via UpdateShieldCoverageOfUnits)
    --bCheckForNearbyShields - if this is true, then will check for any already constructed shields; i.e. this should be true if this function is called from oUnit's construction being started

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckIfUnitWantsFixedShield'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at game time '..GetGameTimeSeconds()..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bCheckForNearbyShields='..tostring(bCheckForNearbyShields or false)..'; oUnit[refbUnitWantsShielding] before update='..tostring(oUnit[refbUnitWantsShielding] or false)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; iOptionalShieldsWantedOverride='..(iOptionalShieldsWantedOverride or 'nil')..'; owner='..oUnit:GetAIBrain().Nickname..'; Enemy novax count='..M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiEnemyNovaxCount]..'; Enemy arti count='..M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiEnemyT3ArtiCount]) end

    local iShieldsWanted = 0
    local iShieldCoverage = 0

    if oUnit[reftoShieldsProvidingCoverage] and M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]) == false then
        iShieldCoverage = table.getn(oUnit[reftoShieldsProvidingCoverage])
    end

    --Determine shields wanted
    if M28UnitInfo.IsUnitValid(oUnit) then
        if iOptionalShieldsWantedOverride then iShieldsWanted = iOptionalShieldsWantedOverride
        elseif oUnit[reftArtiTemplateRefs] then
            iShieldsWanted = 0 --we will be relying on template instead
        else
            local oBP = oUnit:GetBlueprint()
            --Dont get shields for other shields (to avoid infinite shields)
            if bDebugMessages == true then LOG(sFunctionRef..': Unit mass cost='..oUnit[M28UnitInfo.refiUnitMassCost]..'; Shieldm ax health='..(oBP.Defense.Shield.ShieldMaxHealth or 0)) end
            local bT2ArtiOrTMLAgainstEnemyT2ArtiOrFatboy
            if EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) then
                local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, oUnit:GetAIBrain().M28Team)
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then bT2ArtiOrTMLAgainstEnemyT2ArtiOrFatboy = true
                elseif tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] >= 1500 then
                    bT2ArtiOrTMLAgainstEnemyT2ArtiOrFatboy = true
                end
            elseif EntityCategoryContains(M28UnitInfo.refCategoryTML, oUnit.UnitId) and M28Utilities.IsTableEmpty(M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.reftoLongRangeEnemyDFUnits]) == false then
                local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, oUnit:GetAIBrain().M28Team)
                if tLZTeamData[M28Map.refbGetTMLBattery] then
                    bT2ArtiOrTMLAgainstEnemyT2ArtiOrFatboy = true
                end
            end
            if (bT2ArtiOrTMLAgainstEnemyT2ArtiOrFatboy or (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) >= 2000 or (EntityCategoryContains(M28UnitInfo.refCategoryT2Mex, oUnit.UnitId) and M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiEnemyNovaxCount] > 0)) and (oBP.Defense.Shield.ShieldMaxHealth or 0) == 0 then
                local iTeam = oUnit:GetAIBrain().M28Team
                if bDebugMessages == true then LOG(sFunctionRef..': Unit health='..oBP.Defense.Health..'; Defending against t3 arti for iTeam'..oUnit:GetAIBrain().M28Team..'='..tostring(M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refbDefendAgainstArti] or false)) end
                if oBP.Defense.Health / (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) < 1
                        or EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryTML, oUnit.UnitId)
                        or ((M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refbDefendAgainstArti] or M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiEnemyAirToGroundThreat] >= 12000) and (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) >= 3000 and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId))
                        or (EntityCategoryContains(M28UnitInfo.refCategoryMex - categories.TECH1, oUnit.UnitId) and M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiEnemyNovaxCount] > 0) then

                    if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] and (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) >= 12000 and (M28Team.tTeamData[iTeam][M28Team.refiEnemyT3ArtiCount] >= 1 or M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] >= 2) and M28Utilities.IsTableEmpty(oUnit[reftoSpecialAssignedShields]) then iShieldsWanted = 2
                    else iShieldsWanted = 1
                    end
                end
            end
        end
    end

    --If have just started construction of oUnit then check if there are any existing shields that can help it
    if bCheckForNearbyShields and iShieldsWanted > 0 then
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
        if iPlateau > 0 and iLandZone > 0 then
            local tNearbyShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tNearbyShields) == false then
                if not(oUnit[reftoShieldsProvidingCoverage]) then oUnit[reftoShieldsProvidingCoverage] = {} end

                for iLZShield, oLZShield in tNearbyShields do
                    local iShieldRadius = oLZShield:GetBlueprint().Defense.Shield.ShieldSize * 0.5 - 0.1 -- - 1
                    RecordIfShieldIsProtectingUnit(oLZShield, oUnit, iShieldRadius, true)
                end

                if oUnit[reftoShieldsProvidingCoverage] and M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]) == false then
                    iShieldCoverage = table.getn(oUnit[reftoShieldsProvidingCoverage])
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': iShieldsWanted='..iShieldsWanted..'; iSHieldCoverage='..iShieldCoverage) end
    if iShieldsWanted > iShieldCoverage then
        --Want more shielding
        if not(oUnit[refbUnitWantsShielding]) then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
            if iPlateau > 0 and iLandZone > 0 then
                oUnit[refbUnitWantsShielding] = true
                local tUnitLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
                if not(tUnitLZTeamData[M28Map.reftoLZUnitWantingFixedShield]) then tUnitLZTeamData[M28Map.reftoLZUnitWantingFixedShield] = {} end
                table.insert(tUnitLZTeamData[M28Map.reftoLZUnitWantingFixedShield], oUnit)
                if bDebugMessages == true then LOG(sFunctionRef..': Have added unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of units wanting shielding to iPlateau='..iPlateau..'; iLandZOne='..iLandZone) end
            end
        end
    elseif M28UnitInfo.IsUnitValid(oUnit) then
        --Dont want more shielding
        if oUnit[refbUnitWantsShielding] then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
            if iPlateau > 0 and iLandZone > 0 then
                oUnit[refbUnitWantsShielding] = false
                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield]) == false then
                    for iRecordedUnit, oRecordedUnit in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield] do
                        if oRecordedUnit == oUnit then
                            table.remove(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield], iRecordedUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Removed unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from the table of units wanting fixed shielding') end
                            break
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
        LOG(sFunctionRef..': Is table of units wanting fixed shield empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield])))
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield]) == false then
            for iUnit, oUnit in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield] do
                LOG(sFunctionRef..': Listing out each unit wanting shielding for iLandZOne '..iLandZone..'; iUnit '..iUnit..' is oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordIfShieldIsProtectingUnit(oShield, oUnit, iShieldRadius, bDontCheckIfWantsFixedShield)
    --bDontCheckIfWantsFixedShield - true if calling from the 'CheckIfUnitWantsFixedShield' function to avoid infinite loop
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordIfShieldIsProtectingUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Checking if unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; is covered by oShield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; iShieldRadius='..iShieldRadius..'; Distance='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oShield:GetPosition())) end
    if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oShield:GetPosition()) <= iShieldRadius then
        local bAddToUnit = true
        --Record against unit
        if oUnit[reftoShieldsProvidingCoverage] and M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]) == false then
            --Redundancy in case something goes wrong with tracking:
            for iRecordedShield, oRecordedShield in oUnit[reftoShieldsProvidingCoverage] do
                if oRecordedShield == oShield then
                    bAddToUnit = false
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if already recorded this shield, bAddToUnit='..tostring(bAddToUnit)) end
        if bAddToUnit then
            if not(oUnit[reftoShieldsProvidingCoverage]) then oUnit[reftoShieldsProvidingCoverage] = {} end
            table.insert(oUnit[reftoShieldsProvidingCoverage], oShield)
            if bDebugMessages == true then LOG(sFunctionRef..': Recording shield as covering the unit; bDontCheckIfWantsFixedShield='..tostring(bDontCheckIfWantsFixedShield or false)) end
            if not(bDontCheckIfWantsFixedShield) then CheckIfUnitWantsFixedShield(oUnit) end
        end
        --Record against shield
        local bAddToShield = true
        if not(oShield[reftoUnitsCoveredByShield]) then oShield[reftoUnitsCoveredByShield] = {}
        else
            for iRecorded, oRecorded in oShield[reftoUnitsCoveredByShield] do
                if oRecorded == oUnit then bAddToShield = false break end
            end
        end
        if bAddToShield then
            table.insert(oShield[reftoUnitsCoveredByShield], oUnit)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateShieldCoverageOfUnits(oShield, bTreatAsDead)
    --If shield has died, then remove any units it was protecting; if shield has just started construction then instead record any units it can provide coverage to
    --Either way, clear any existing units from the shield (as redundancy - in theory should only be needed if shield is dead

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateShieldCoverageOfUnits'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through every unit that the shield is providing coverage to, and will update to remove this unit from that table, oShield='..(oShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oShield) or 'nil')..'; Is table of units empty='..tostring(M28Utilities.IsTableEmpty(oShield[reftoUnitsCoveredByShield])))
        if M28Utilities.IsTableEmpty(oShield[reftoUnitsCoveredByShield]) == false then LOG(sFunctionRef..': Number of units covered='..table.getn(oShield[reftoUnitsCoveredByShield])) end
    end
    if M28Conditions.IsTableOfUnitsStillValid(oShield[reftoUnitsCoveredByShield]) then
        for iUnit, oUnit in oShield[reftoUnitsCoveredByShield] do
            if M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Will update unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to no longer have the shield recorded as providing coverage to it') end
                for iRecordedShield, oRecordedShield in oUnit[reftoShieldsProvidingCoverage] do
                    if oRecordedShield == oShield then
                        if bDebugMessages == true then LOG(sFunctionRef..': We had recorded shield '..oRecordedShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRecordedShield)..' as covering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so will now remove it') end
                        table.remove(oUnit[reftoShieldsProvidingCoverage], iRecordedShield)
                        break
                    end
                end
                if M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]) then oUnit[reftoShieldsProvidingCoverage] = nil end
            end
            if oUnit:GetAIBrain().M28AI then
                CheckIfUnitWantsFixedShield(oUnit)
            end
        end
        oShield[reftoUnitsCoveredByShield] = nil
    end

    if not(bTreatAsDead) then
        --Record what units this shield can protect in t he LZ it is in
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oShield:GetPosition())
        if iPlateau > 0 and iLandZone > 0 then
            local tUnitsWantingShielding = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oShield:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield]
            if M28Utilities.IsTableEmpty(tUnitsWantingShielding) == false then
                local iShieldRadius = oShield:GetBlueprint().Defense.Shield.ShieldSize * 0.5 - 0.1 -- - 1
                oShield[reftoUnitsCoveredByShield] = {}
                local bAddToUnit = false
                local tUnitsToConsider = {}
                --Copy table so we dont have to fork thread to update each unit
                for iUnit, oUnit in tUnitsWantingShielding do
                    if M28UnitInfo.IsUnitValid(oUnit) then table.insert(tUnitsToConsider, oUnit) end
                end
                for iUnit, oUnit in tUnitsToConsider do
                    RecordIfShieldIsProtectingUnit(oShield, oUnit, iShieldRadius)
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code for oShield='..(oShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oShield) or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordUnitShieldCoverage(oUnit)
    --For all units, not just M28 specific, so e.g. a TML will recognise when it's firing at a shielded target
    --Intended to be called when a unit is created
    if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) then
        local aiBrain = oUnit:GetAIBrain()
        --Is this a shield? if so then update all units around it
        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oUnit.UnitId) then
            local iShieldRadius = oUnit:GetBlueprint().Defense.Shield.ShieldSize * 0.5 - 0.1 -- - 1 --removed the -1 as of v50 since now that are using this to track enemies it can lead to false results
            local tNearbyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure, oUnit:GetPosition(), iShieldRadius, 'Ally')
            if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                for iNearbyUnit, oNearbyUnit in tNearbyUnits do
                    RecordIfShieldIsProtectingUnit(oUnit, oNearbyUnit, iShieldRadius, true)
                end
            end
        else
            local iPotentialShieldRadius = 22 --seraphim is 23 radius
            local tNearbyShields = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedShield, oUnit:GetPosition(), iPotentialShieldRadius, 'Ally')
            if M28Utilities.IsTableEmpty(tNearbyShields) == false then
                local iShieldRadius
                for iShield, oShield in tNearbyShields do
                    if oShield:GetFractionComplete() == 1 then
                        iShieldRadius = oShield:GetBlueprint().Defense.Shield.ShieldSize * 0.5 -0.1 -- - 1
                        RecordIfShieldIsProtectingUnit(oShield, oUnit, iShieldRadius, true)
                    end
                end
            end
        end
    end
end

function ForkedCheckForAnotherMissile(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ForkedCheckForAnotherMissile'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[refbMissileChecker]='..tostring(oUnit[refbMissileChecker] or false)..'; Time='..GetGameTimeSeconds()) end
    if not(oUnit[refbMissileChecker]) then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1) --make sure we have an accurate number for missiles
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        local bUnpause
        if EntityCategoryContains(M28UnitInfo.refCategorySMD, oUnit.UnitId) then
            oUnit[refbMissileChecker] = true
            while M28UnitInfo.IsUnitValid(oUnit) do
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitSeconds(10)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if M28UnitInfo.IsUnitValid(oUnit) then
                    if not(M28Conditions.WantToPauseSMD(oUnit, false)) then
                        bUnpause = true
                        break
                    end
                end
            end
        else
            local iMissiles = 0
            if oUnit.GetTacticalSiloAmmoCount then iMissiles = iMissiles + oUnit:GetTacticalSiloAmmoCount() end
            if oUnit.GetNukeSiloAmmoCount then iMissiles = iMissiles + oUnit:GetNukeSiloAmmoCount() end
            if bDebugMessages == true then LOG(sFunctionRef..': iMissiles outside of loop='..iMissiles) end
            if iMissiles >= 2 and M28UnitInfo.IsUnitValid(oUnit) then
                oUnit[refbMissileChecker] = true
                local iTeam = oUnit:GetAIBrain().M28Team
                while M28UnitInfo.IsUnitValid(oUnit) do
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitSeconds(10)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        iMissiles = 0
                        if oUnit.GetTacticalSiloAmmoCount then iMissiles = iMissiles + oUnit:GetTacticalSiloAmmoCount() end
                        if oUnit.GetNukeSiloAmmoCount then iMissiles = iMissiles + oUnit:GetNukeSiloAmmoCount() end
                        if bDebugMessages == true then LOG(sFunctionRef..': iMissiles='..iMissiles..'; Time='..GetGameTimeSeconds()) end
                        if iMissiles < 2 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.8 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 400) then
                            bUnpause = true

                            if bDebugMessages == true then LOG(sFunctionRef..': Will change unit state so it isnt paused and set autobuild status to true, time='..GetGameTimeSeconds()) end
                            break
                        end
                    else
                        break
                    end

                end
            else
                if M28UnitInfo.IsUnitValid(oUnit) then
                    bUnpause = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Will unpause unit as not enough missiles') end
                end
            end
        end
        if bUnpause and M28UnitInfo.IsUnitValid(oUnit) then
            if bDebugMessages == true then LOG(sFunctionRef..': setting unit autobuild status to true, time='..GetGameTimeSeconds()) end
            --oUnit:SetPaused(false)
            M28UnitInfo.PauseOrUnpauseUnitWithoutTracking(oUnit, false)
            M28UnitInfo.SetUnitMissileAutoBuildStatus(oUnit, true)
        end
        if oUnit[refbMissileChecker] then oUnit[refbMissileChecker] = nil end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckIfWantToBuildAnotherMissile(oUnit)
    ForkThread(ForkedCheckForAnotherMissile, oUnit)
end

function RecordUnitsInRangeOfTMLAndAnyTMDProtection(oTML, tOptionalUnitsToConsider, bCalledDueToTMLDetection)
    --tOptionalUnitsToConsider - if nil then will get all nearby units on an opposing team to oTML
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordUnitsInRangeOfTMLAndAnyTMDProtection'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if M28UnitInfo.IsUnitValid(oTML) then
        --If this is a mobile TML then want to update any units not in range of it now that were recorded as being in range previously
        --[[local toMobilePrevRecordedUnitsToUpdate
        if EntityCategoryContains(categories.MOBILE, oTML.UnitId) and oTML[refbTMDBuiltSinceLastChecked] and M28Conditions.IsTableOfUnitsStillValid(oTML[reftUnitsInRangeOfThisTML]) then
            toMobilePrevRecordedUnitsToUpdate = {}
            for iRecorded, oRecorded in oTML[reftUnitsInRangeOfThisTML] do
                toMobilePrevRecordedUnitsToUpdate[GetUnitRef(oRecorded)] = oRecorded
            end
        end--]]

        local iTMLRange = math.max((oTML[M28UnitInfo.refiManualRange] or 0), (oTML[M28UnitInfo.refiIndirectRange] or 0))
        if iTMLRange == 0 then iTMLRange = iTMLMissileRange end
        --Increase range if mobile
        if EntityCategoryContains(categories.MOBILE, oTML.UnitId) then
            iTMLRange = iTMLRange + 10
        end
        --Increase range for aoe
        iTMLRange = iTMLRange + (oTML[M28UnitInfo.refiIndirectAOE] or 2)
        if bDebugMessages == true then LOG(sFunctionRef..': TMl range: Manual range='..(oTML[M28UnitInfo.refiManualRange] or 0)..'; IF range='..(oTML[M28UnitInfo.refiIndirectRange] or 0)..'; AOE='..(oTML[M28UnitInfo.refiIndirectAOE] or 2)..'; Is TML mobile='..tostring(EntityCategoryContains(categories.MOBILE, oTML.UnitId))..'; TML='..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)) end


        local iTMLTeam = oTML:GetAIBrain().M28Team
        local tNearbyTMD = {}
        local tUnitsToProtect = {}
        local tiTeamsWithUnitsThatMightWantTMD = {}
        if tOptionalUnitsToConsider then
            for iUnit, oUnit in tOptionalUnitsToConsider do
                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTML:GetPosition()) <= iTMLRange then
                    table.insert(tUnitsToProtect, oUnit)
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Near start of code for oTML='..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)..' at time of '..GetGameTimeSeconds()..'; Is tOptionalUnitsToConsider nil='..tostring(tOptionalUnitsToConsider == nil)) end
        for iTMDTeam = 1, M28Team.iTotalTeamCount do
            --Get all TMD that could stop this TML, and all units it could threaten
            if not(iTMDTeam == iTMLTeam) then
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTMDTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
                    local oTMDBrain
                    for iBrain, oBrain in M28Team.tTeamData[iTMDTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                        oTMDBrain = oBrain
                        break
                    end

                    local tTeamNearbyTMD = oTMDBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD, oTML:GetPosition(), iTMLRange + 13, 'Ally')
                    if M28Utilities.IsTableEmpty(tTeamNearbyTMD) == false then
                        for iUnit, oUnit in tTeamNearbyTMD do
                            table.insert(tNearbyTMD, oUnit)
                        end
                    end
                    if not(tOptionalUnitsToConsider) then
                        --i.e. this is the first time we are considering the TML; double-check we havent already recorded the TML
                        local bNotAlreadyRecordedInTeamData = EntityCategoryContains(M28UnitInfo.refCategoryTML, oTML.UnitId)
                        if bNotAlreadyRecordedInTeamData and M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTMDTeam][M28Team.reftEnemyTML]) then
                            for iUnit, oUnit in M28Team.tTeamData[iTMDTeam][M28Team.reftEnemyTML] do
                                if oUnit == oTML then
                                    bNotAlreadyRecordedInTeamData = false
                                    break
                                end
                            end
                        end
                        if bNotAlreadyRecordedInTeamData then
                            if bDebugMessages == true then LOG(sFunctionRef..': TML not already recorded in team data so will add for team '..iTMDTeam..', oTML='..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)) end
                            table.insert(M28Team.tTeamData[iTMDTeam][M28Team.reftEnemyTML], oTML)
                        end
                        local tTeamUnitsToProtect = oTMDBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryProtectFromTML, oTML:GetPosition(), iTMLRange, 'Ally')
                        if bDebugMessages == true then LOG(sFunctionRef..': Is tTeamUnitsToProtect empty='..tostring(M28Utilities.IsTableEmpty(tTeamUnitsToProtect))..'; iTMLRange='..iTMLRange..'; TML position='..repru(oTML:GetPosition())) end
                        if M28Utilities.IsTableEmpty(tTeamUnitsToProtect) == false then
                            for iUnit, oUnit in tTeamUnitsToProtect do
                                table.insert(tUnitsToProtect, oUnit)
                            end
                        end
                    end
                end
            end
        end
        --Below not needed - had put it in when thought was reason TML wasnt firing but the civilians in campaign were already assigned teams as had updated the iscivilian flag for campaign
        --[[if not(tOptionalUnitsToConsider) and M28Map.bIsCampaignMap then
            local iTMLIndex = oTML:GetAIBrain():GetArmyIndex()
            for iBrain, oBrain in ArmyBrains do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering oBrain='..oBrain.Nickname..'; M28Team='..(oBrain.M28Team or 'nil')..'; IsEnemy='..tostring(IsEnemy(iTMLIndex, oBrain:GetArmyIndex()))) end
                if not(oBrain.M28Team) and IsEnemy(iTMLIndex, oBrain:GetArmyIndex()) then
                    local tTeamUnitsToProtect = oBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryProtectFromTML, oTML:GetPosition(), iTMLRange, 'Ally')
                    if M28Utilities.IsTableEmpty(tTeamUnitsToProtect) == false then
                        for iUnit, oUnit in tTeamUnitsToProtect do
                            local bAlreadyIncluded = false
                            if M28Utilities.IsTableEmpty(tUnitsToProtect) == false then
                                for iRecorded, oRecorded in tUnitsToProtect do
                                    if oRecorded == oUnit then bAlreadyIncluded = true break end
                                end
                            end
                            if not(bAlreadyIncluded) then
                                table.insert(tUnitsToProtect, oUnit)
                            end
                        end
                    end
                end
            end
        end--]]

        if bDebugMessages == true then LOG(sFunctionRef..': Is table of units to protect empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToProtect))..'; Is table of TMD empty='..tostring(M28Utilities.IsTableEmpty(tNearbyTMD))) end
        if M28Utilities.IsTableEmpty(tUnitsToProtect) == false then
            local iCurTeam
            for iUnit, oUnit in tUnitsToProtect do
                --if toMobilePrevRecordedUnitsToUpdate then toMobilePrevRecordedUnitsToUpdate[GetUnitRef(oUnit)] = nil end
                if not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                    --Update various tracking variables based on whether TMD are protecting this unit or not (i.e. updates TML for potential targets, TMD for units theyre covering, and units for TML that have hte unit in their range)
                    RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oTML, tNearbyTMD)
                    iCurTeam = oUnit:GetAIBrain().M28Team
                    if iCurTeam then
                        if not(tiTeamsWithUnitsThatMightWantTMD[iCurTeam]) then tiTeamsWithUnitsThatMightWantTMD[iCurTeam] = {} end
                        table.insert(tiTeamsWithUnitsThatMightWantTMD[iCurTeam], oUnit)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering if unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is protected from the TML by TMD') end
                end
            end
            if M28Utilities.IsTableEmpty(tiTeamsWithUnitsThatMightWantTMD) == false then
                for iTeam, tUnits in tiTeamsWithUnitsThatMightWantTMD do
                    RecordIfUnitsWantTMDCoverageAgainstLandZone(iTeam, tUnits, bCalledDueToTMLDetection)
                end
            end
        end
        --[[if M28Utilities.IsTableEmpty(toMobilePrevRecordedUnitsToUpdate) == false then
            --Dealing with a mobile TML so check for units that we havent updated per the above since they may now have TMD to cover them
            for iRecorded, oRecorded in toMobilePrevRecordedUnitsToUpdate do
                local tNearbyTMD = oRecorded:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD, oRecorded:GetPosition(), iTMLRange + 30, 'Ally')
                if M28Utilities.IsTableEmpty(tNearbyTMD) == false then
                    RecordIfUnitIsProtectedFromTMLByTMD(oRecorded, oTML, tNearbyTMD)
                end
            end
        end--]]
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetUnitRef(oUnit)
    return oUnit.UnitId..'L'..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'B'..oUnit:GetAIBrain():GetArmyIndex()
end

function TMDJustBuilt(oTMD)
    --Searches for any enemy TML in range of the TMD, and any friendly units in range of the TMD
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TMDJustBuilt'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local oTMDBrain = oTMD:GetAIBrain()
    local iTMDTeam = oTMDBrain.M28Team
    if not(oTMD[M28UnitInfo.refiMissileDefenceRange]) then M28UnitInfo.RecordUnitRange(oTMD) end
    local iTMDRange = (oTMD[M28UnitInfo.refiMissileDefenceRange] or 12.5)
    local tNearbyTML = {}
    local iTMDPlateauOrZero, iTMDZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oTMD:GetPosition())
    local tTMDZoneData, tTMDZoneTeamData
    if (iTMDZone or 0) > 0 then
        if iTMDPlateauOrZero == 0 then
            tTMDZoneData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iTMDZone]][M28Map.subrefPondWaterZones][iTMDZone]
            tTMDZoneTeamData = tTMDZoneData[M28Map.subrefWZTeamData][iTMDTeam]
        else
            tTMDZoneData = M28Map.tAllPlateaus[iTMDPlateauOrZero][M28Map.subrefPlateauLandZones][iTMDZone]
            tTMDZoneTeamData = tTMDZoneData[M28Map.subrefLZTeamData][iTMDTeam]
        end
    end
    local bCheckForUnitsInZone = M28Utilities.IsTableEmpty(tTMDZoneTeamData[M28Map.reftUnitsWantingTMD]) == false
    local tbUnitRefsConsideredByTML
    local tbUnitRefsConsideredAllTML = {}
    local sCurUnitRef
    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, oTMD='..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' owned by '..oTMD:GetAIBrain().Nickname..'; TMD fraction complete='..oTMD:GetFractionComplete()..'; Time='..GetGameTimeSeconds()) end
    for iTMLTeam = 1, M28Team.iTotalTeamCount do
        --Get all TML in range of this TMD
        if not(iTMDTeam == iTMLTeam) then
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
                local oTMLBrain
                for iBrain, oBrain in M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                    oTMLBrain = oBrain
                    break
                end
                local tTeamNearbyTML = oTMLBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTML, oTMD:GetPosition(), iTMLMissileRange + iTMDRange - 3, 'Ally')
                if bDebugMessages == true then LOG(sFunctionRef..': Dealing with oTMD='..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..'; is table of nearby TML empty='..tostring(M28Utilities.IsTableEmpty(tTeamNearbyTML))..'; iTMLTeam='..iTMLTeam) end
                if M28Utilities.IsTableEmpty(tTeamNearbyTML) == false then
                    for iTML, oTML in tTeamNearbyTML do
                        tbUnitRefsConsideredByTML = {}
                        local tFriendlyUnitsInRangeOfTML = oTMDBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryProtectFromTML, oTML:GetPosition(), iTMLMissileRange + 2, 'Ally')
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of TMD friendly units in range of TML empty='..tostring(M28Utilities.IsTableEmpty(tFriendlyUnitsInRangeOfTML))) end
                        if M28Utilities.IsTableEmpty(tFriendlyUnitsInRangeOfTML) == false then
                            for iUnit, oUnit in tFriendlyUnitsInRangeOfTML do
                                sCurUnitRef = GetUnitRef(oUnit)

                                tbUnitRefsConsideredByTML[sCurUnitRef] = true
                                tbUnitRefsConsideredAllTML[sCurUnitRef] = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Will check if unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is in range of TML '..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)) end
                                RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oTML, { oTMD }, true) --This will do a distance check from the unit to the TMD
                            end
                        end
                        --Also check for any units wanting TMD coverage in the TMD zone (redundancy in case there are issues with getunitsaroundpoint not picking up upgrading units)
                        if bCheckForUnitsInZone and M28Utilities.IsTableEmpty(tTMDZoneTeamData[M28Map.reftUnitsWantingTMD]) == false then
                            for iUnit, oUnit in tTMDZoneTeamData[M28Map.reftUnitsWantingTMD] do
                                if M28UnitInfo.IsUnitValid(oUnit) then
                                    sCurUnitRef = GetUnitRef(oUnit)
                                    if not(tbUnitRefsConsideredByTML[sCurUnitRef]) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have unit in zone wanting TMD coverage that we havent considered with getunitsaroundpoint, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Unit fraction complete='..oUnit:GetFractionComplete()) end
                                        RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oTML, { oTMD }, true)
                                        tbUnitRefsConsideredAllTML[sCurUnitRef] = true
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of mobile TML empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTMDTeam][M28Team.reftEnemyMobileTML]))) end
    if M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTMDTeam][M28Team.reftEnemyMobileTML]) then
        for iMobileTML, oMobileTML in M28Team.tTeamData[iTMDTeam][M28Team.reftEnemyMobileTML] do
            if M28Conditions.IsTableOfUnitsStillValid(oMobileTML[reftUnitsInRangeOfThisTML]) then
                for iRecorded, oRecorded in oMobileTML[reftUnitsInRangeOfThisTML] do
                    sCurUnitRef = GetUnitRef(oRecorded)
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oMobileTML '..oMobileTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMobileTML)..'; oRecorded='..oRecorded.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRecorded)..'; is tbUnitRefsConsideredAllTML nil for this unit='..tostring(tbUnitRefsConsideredAllTML[sCurUnitRef] == nil)) end
                    if not(tbUnitRefsConsideredAllTML[sCurUnitRef]) then
                        RecordIfUnitIsProtectedFromTMLByTMD(oRecorded, oMobileTML, { oTMD }, true)
                        tbUnitRefsConsideredAllTML[sCurUnitRef] = true
                    end
                end
            end
            oMobileTML[refbTMDBuiltSinceLastChecked] = true
        end
    end

    --Also record TMD as covering any units in their range (allows for coverage to be recorded for preemptive TMD)
    local tNearbyAlliedUnits = oTMDBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryProtectFromTML, oTMD:GetPosition(), oTMD[M28UnitInfo.refiMissileDefenceRange] - 1, 'Ally')
    if M28Utilities.IsTableEmpty(tNearbyAlliedUnits) == false then
        for iUnit, oUnit in tNearbyAlliedUnits do
            if oUnit:GetAIBrain().M28AI then
                RecordThatTMDProtectsUnitFromTML(oTMD, oUnit)
            end
        end
    end


    --Reevaluate all units in the zone flagged as wanting TMD, due to issue where in some cases the unit would be recorded against the LZ despite loads of TMD covering it
    if M28Utilities.IsTableEmpty(tTMDZoneTeamData[M28Map.reftUnitsWantingTMD]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Will update tTMDZoneTeamData[M28Map.reftUnitsWantingTMD], iTMDTeam='..iTMDTeam) end
        RecordIfUnitsWantTMDCoverageAgainstLandZone(iTMDTeam, tTMDZoneTeamData[M28Map.reftUnitsWantingTMD], true)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, time='..GetGameTimeSeconds()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordTMLAndTMDForUnitJustBuilt(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordTMLAndTMDForUnitJustBuilt'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local oTMDBrain = oUnit:GetAIBrain()
    local iTMDTeam = oTMDBrain.M28Team
    local tNearbyTMD = oTMDBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD, oUnit:GetPosition(), iTMLMissileRange + 2, 'Ally')

    for iTMLTeam = 1, M28Team.iTotalTeamCount do
        --Get all TML in range of this TMD
        if not(iTMDTeam == iTMLTeam) then
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
                local oTMLBrain
                for iBrain, oBrain in M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                    oTMLBrain = oBrain
                    break
                end
                local tTeamNearbyTML = oTMLBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTML, oUnit:GetPosition(), iTMLMissileRange + 2, 'Ally')
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of TML in TML missile range of this unit empty='..tostring(M28Utilities.IsTableEmpty(tTeamNearbyTML))..'; iTMLMissileRange='..iTMLMissileRange..'; Unit position='..repru(oUnit:GetPosition())..'; oTMLBrain='..oTMLBrain.Nickname) end
                if M28Utilities.IsTableEmpty(tTeamNearbyTML) == false then
                    for iTML, oTML in tTeamNearbyTML do
                        RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oTML, tNearbyTMD) --This will do a distance check from the unit to the TMD
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordTMLAndTMDForEnemyUnitTargetJustDetected(oUnit, iTMLTeam)
    --Intended if an M28 TML owner detects an enemy target
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordTMLAndTMDForEnemyUnitTargetJustDetected'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local oTMDBrain = oUnit:GetAIBrain()
    local tNearbyTMD = oTMDBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD, oUnit:GetPosition(), iTMLMissileRange + 2, 'Ally')

    if oUnit:GetFractionComplete() < 1 and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) then
        if not(oUnit[refbRecheckTMLAndTMDWhenConstructedByTeam]) then oUnit[refbRecheckTMLAndTMDWhenConstructedByTeam] = {} end
        oUnit[refbRecheckTMLAndTMDWhenConstructedByTeam][iTMLTeam] = true
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Detected unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTMLTeam='..iTMLTeam..'; Is table of active brains empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains]))..'; Unit fraction complete='..oUnit:GetFractionComplete()..'; TimeOfGame='..GetGameTimeSeconds()) end

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
        local oTMLBrain
        for iBrain, oBrain in M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
            oTMLBrain = oBrain
            break
        end
        local tTeamNearbyTML = oTMLBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTML, oUnit:GetPosition(), iTMLMissileRange + 2, 'Ally')
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of TML in missile range of this unit empty='..tostring(M28Utilities.IsTableEmpty(tTeamNearbyTML))..'; iTMLMissileRange='..iTMLMissileRange..'; Unit position='..repru(oUnit:GetPosition())..'; oTMLBrain.Nickname='..oTMLBrain.Nickname) end
        if M28Utilities.IsTableEmpty(tTeamNearbyTML) == false then --NOTE: If TML is firing from a cliff (big height dif) then it might not detect a unit that appears within its range, assuming due to targeting of units not being straightline ignoring height, but also factoring in height difs, with getunitsaroundpoint appearing to factor this in as well
            for iTML, oTML in tTeamNearbyTML do
                if bDebugMessages == true then LOG(sFunctionRef..': Are in range of oTML='..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)..'; will record if is protected by TMD') end
                RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oTML, tNearbyTMD) --This will do a distance check from the unit to the TMD
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function IsTMDProtectingUnitFromTML(oTMD, oUnit, oTML, iOptionalBuildingSize, tTMLPositionOverride)
    --Dont need to have oTML existing if use tTMLPositionOverride, so e.g. can use for planning if a TML built at a certain position will be able to hit targets
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsTMDProtectingUnitFromTML'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, considering for oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..', oTMD='..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' owned by '..oTMD:GetAIBrain().Nickname..'; oTML='..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)..' owned by '..oTML:GetAIBrain().Nickname..'; Distance between TMD and unit='..M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), oUnit:GetPosition())) end
    if EntityCategoryContains(categories.AEON, oTMD.UnitId) and M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), oUnit:GetPosition()) > 120 then
        if bDebugMessages == true then LOG(sFunctionRef..': Aeon TMD that is so far away we wouldnt expect it to intercept TML missiles evne if it appears (ignoring height) to be able to intercept') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false
    end

    local iBuildingSize = iOptionalBuildingSize
    if not(iBuildingSize) then iBuildingSize = M28UnitInfo.GetBuildingSize(oUnit.UnitId) end
    local iUnitToTMD = M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), oUnit:GetPosition())
    if not(oTMD[M28UnitInfo.refiMissileDefenceRange]) then M28UnitInfo.RecordUnitRange(oTMD) end
    local iTMDRange = (oTMD[M28UnitInfo.refiMissileDefenceRange] or 12.5)


    if EntityCategoryContains(categories.AEON, oTMD.UnitId) then iTMDRange = iTMDRange + 0.5 end --to be prudent, may not be required as when made change (v169) there was a separate TMD issue (below reduction for building size) that was likely causing the issue of incorrectly thinking TMD didnt cover a target
    --Reduce range based on building size if we are considering whether we should build TMD to protect a target, if our TMD is further away than the unit in question (meaning we are more likely to be behind the unit, such that enemy could more easily 'edge-TML' the unit)
    if oUnit:GetAIBrain().M28AI and oTML and not(oTML:GetAIBrain().M28AI) and M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), oTML:GetPosition()) >= M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTML:GetPosition()) then
        iTMDRange = iTMDRange - iBuildingSize
    end


    local iUnitToTML = M28Utilities.GetDistanceBetweenPositions(tTMLPositionOverride or oTML:GetPosition(), oUnit:GetPosition())
    local iTMDToTML = M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), tTMLPositionOverride or oTML:GetPosition())

    local iAngleTMLToUnit = M28Utilities.GetAngleFromAToB(tTMLPositionOverride or oTML:GetPosition(), oUnit:GetPosition())
    local iAngleTMLToTMD = M28Utilities.GetAngleFromAToB(tTMLPositionOverride or oTML:GetPosition(), oTMD:GetPosition())
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if TMD '..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' is able to block the TML '..(oTML.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTML) or 'nil')..' for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; tTMLPositionOverride='..repru(tTMLPositionOverride)..'; iUnitToTMD='..iUnitToTMD..'; iTMDRange reduced by building size='..iTMDRange..'; TMD recorded range='..(oUnit[M28UnitInfo.refiMissileDefenceRange] or 'nil')..'; iUnitToTML='..iUnitToTML..'; iTMDToTML='..iTMDToTML..'; iAngleTMLToUnit='..iAngleTMLToUnit..'; iAngleTMLToTMD='..iAngleTMLToTMD..'; Is line result='..tostring(M28Utilities.IsLineFromAToBInRangeOfCircleAtC(iUnitToTML, iTMDToTML, iUnitToTMD, iAngleTMLToUnit, iAngleTMLToTMD, iTMDRange))) end
    if M28Utilities.IsLineFromAToBInRangeOfCircleAtC(iUnitToTML, iTMDToTML, iUnitToTMD, iAngleTMLToUnit, iAngleTMLToTMD, iTMDRange) then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false

end

function RecordThatTMDProtectsUnitFromTML(oTMD, oUnit, oTML)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordThatTMDProtectsUnitFromTML'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --If oTML is nil and oTMD is in range of oUnit then will record the TMD against the unit

    --TMD can block the TML
    local bAlreadyRecordedTMD = false
    if not(oUnit[reftTMDCoveringThisUnit]) then oUnit[reftTMDCoveringThisUnit] = {}
    else
        for iRecordedTMD, oRecordedTMD in oUnit[reftTMDCoveringThisUnit] do
            if oRecordedTMD == oTMD then bAlreadyRecordedTMD = true  break end
        end
    end
    if not(bAlreadyRecordedTMD) then
        table.insert(oUnit[reftTMDCoveringThisUnit], oTMD)
        if not(oTMD[reftUnitsCoveredByThisTMD]) then oTMD[reftUnitsCoveredByThisTMD] = {} end
        table.insert(oTMD[reftUnitsCoveredByThisTMD], oUnit)
        if bDebugMessages == true then LOG(sFunctionRef..': TMD '..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' owned by '..oTMD:GetAIBrain().Nickname..' with % complete='..oTMD:GetFractionComplete()..' recorded against oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..' as covering it from TML '..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)..' owned by '..oTML:GetAIBrain().Nickname) end
    end


    if oTML and M28Utilities.IsTableEmpty(oTML[reftUnprotectedUnitTargetsForThisTML]) == false then
        for iExistingUnit, oExistingUnit in oTML[reftUnprotectedUnitTargetsForThisTML] do
            if oExistingUnit == oUnit then
                if bDebugMessages == true then LOG(sFunctionRef..': This unit was previously recorded as an unprotected target, will remove') end
                table.remove(oTML[reftUnprotectedUnitTargetsForThisTML], iExistingUnit)
                break
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oTML, tTMDInRange, bOnlyIncludingSpecificTMD)
    --Updates the following variables: For TMD: reftUnitsCoveredByThisTMD; for TML: reftUnprotectedUnitTargetsForThisTML and reftUnitsInRangeOfThisTML; for units in range of TML: reftTMDCoveringThisUnit and reftTMLInRangeOfThisUnit
    --Assumes that oTML is in range of oUnit
    --bOnlyIncludingSpecificTMD - true if we are calling this function to just check a specific TMD (so we should be more careful about adding the unit as an unprotected target)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordIfUnitIsProtectedFromTMLByTMD'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(oUnit.UnitId) and not(M28Utilities.bFAFActive) and oUnit then --LOUD compatibility
        if not(oUnit.EntityId) then oUnit.EntityId = oUnit:GetEntityId() end
        oUnit.UnitId = oUnit:GetBlueprint().BlueprintId
    end

    local bTMLAlreadyRecordedAgainstUnit = false
    local bUpdateZoneForUnitsWantingTMD = false
    if M28Utilities.IsTableEmpty(oUnit[reftTMLInRangeOfThisUnit]) == false then
        for iExistingTML, oExistingTML in oUnit[reftTMLInRangeOfThisUnit] do
            if oExistingTML == oTML then
                bTMLAlreadyRecordedAgainstUnit = true
                break
            end
        end
    end
    if not(bTMLAlreadyRecordedAgainstUnit) then
        if not(oUnit[reftTMLInRangeOfThisUnit]) then oUnit[reftTMLInRangeOfThisUnit] = {} end
        table.insert(oUnit[reftTMLInRangeOfThisUnit], oTML)
    end
    local bIsBlockedByTMD
    if bDebugMessages == true then LOG(sFunctionRef..': Near start at time '..GetGameTimeSeconds()..'; Considering if oUnit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; is proitected from oTML '..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)..' owned by player '..oTML:GetAIBrain().Nickname..' by any of the TMD noted, is table of TMD empty='..tostring(M28Utilities.IsTableEmpty(tTMDInRange))..'; First TMD='..(tTMDInRange[1].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tTMDInRange[1]) or 'nil')) end
    local iBuildingSize = M28UnitInfo.GetBuildingSize(oUnit.UnitId)
    if M28Utilities.IsTableEmpty(tTMDInRange) == false then
        --[[local iUnitToTMD
        local iTMDRange
        local iUnitToTML, iTMDToTML, iAngleTMLToUnit, iAngleTMLToTMD--]]
        local bAlreadyRecordedTMD



        for iTMD, oTMD in tTMDInRange do
            if IsTMDProtectingUnitFromTML(oTMD, oUnit, oTML, iBuildingSize) then
                RecordThatTMDProtectsUnitFromTML(oTMD, oUnit, oTML)
                bIsBlockedByTMD = true
                if bDebugMessages == true then LOG(sFunctionRef..': oTMD='..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' can block the TML so will record it') end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': TMD '..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' doesnt block the TML') end
            end
        end
    end
    if not(bIsBlockedByTMD) then
        --None of the TMD are blocking the TML from hitting this unit; check if there are any other valid TMD that are covering this unit
        if M28Utilities.IsTableEmpty(oUnit[reftTMDCoveringThisUnit]) == false then
            for iTMD, oTMD in oUnit[reftTMDCoveringThisUnit] do
                if M28UnitInfo.IsUnitValid(oTMD) then
                    --Have we considered this TMD alreayd?
                    local bConsideredAbove = false
                    for iExistingTMD, oExistingTMD in tTMDInRange do
                        if oExistingTMD == oTMD then
                            bConsideredAbove = true
                            break
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': This unit has TMD recorded as covering it, oTMD='..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..'; bConsideredAbove='..tostring(bConsideredAbove)..'; Does the TMD cover the unit from this TML='..tostring(IsTMDProtectingUnitFromTML(oTMD, oUnit, oTML, iBuildingSize))..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; TML='..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)..' owned by brain '..oTML:GetAIBrain().Nickname) end
                    if not(bConsideredAbove) then
                        if IsTMDProtectingUnitFromTML(oTMD, oUnit, oTML, iBuildingSize) then
                            bIsBlockedByTMD = true
                            RecordThatTMDProtectsUnitFromTML(oTMD, oUnit, oTML)
                            break
                        end
                    end
                end
            end
        end
    end
    if not(bIsBlockedByTMD) then
        local bAlreadyIncluded = false
        if not(oTML[reftUnprotectedUnitTargetsForThisTML]) or M28Utilities.IsTableEmpty(oTML[reftUnprotectedUnitTargetsForThisTML]) then
            oTML[reftUnprotectedUnitTargetsForThisTML] = {}

        else
            for iRecordedUnit, oRecordedUnit in oTML[reftUnprotectedUnitTargetsForThisTML] do
                if oRecordedUnit == oUnit then
                    bAlreadyIncluded = true
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Will record this unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' against table of unprotected units for TML as it isnt blocked by any of the TMD, bAlreadyIncluded='..tostring(bAlreadyIncluded or false)) end
        if not(bAlreadyIncluded) then
            --Check if this is unprotected by other TMD as well, if we called this from just a single TMD event
            local bIsDefinitelyUnprotected = true
            if bOnlyIncludingSpecificTMD and M28Utilities.IsTableEmpty(oUnit[reftTMDCoveringThisUnit]) == false then
                for iTMD, oTMD in oUnit[reftTMDCoveringThisUnit] do
                    if not(oTMD == tTMDInRange[1]) and M28UnitInfo.IsUnitValid(oTMD) then
                        bIsDefinitelyUnprotected = false
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bIsDefinitelyUnprotected after checking if we have other TMD likely covering this unit='..tostring(bIsDefinitelyUnprotected)) end
            if bIsDefinitelyUnprotected then
                table.insert(oTML[reftUnprotectedUnitTargetsForThisTML], oUnit)
            end
            --Below function will factor in number of enemy TML vs number of friendly TMD so less that can go wrong if re-run when just called this for a single TMD
            if oUnit:GetAIBrain().M28AI then
                RecordIfUnitsWantTMDCoverageAgainstLandZone(oUnit:GetAIBrain().M28Team, { oUnit }, true)
            end
        end
    else
        --is covered by TMD, make sure not listed in reftUnprotectedUnitTargetsForThisTML, and reassess if we want the unit flagged as wanting TMD
        if bDebugMessages == true then LOG(sFunctionRef..': Unit is covered by TMD so will make sure not listed as an unprotected target against the TML, is table of unrptoected targets empty='..tostring(M28Utilities.IsTableEmpty(oTML[reftUnprotectedUnitTargetsForThisTML]))) end
        bUpdateZoneForUnitsWantingTMD = true
        --(we shouldave already updated to reflect no longer have an unprotected unit above)
    end
    --Either way record unit as being in range of TML
    local bAlreadyIncluded = false
    if not(oTML[reftUnitsInRangeOfThisTML]) or M28Utilities.IsTableEmpty(oTML[reftUnitsInRangeOfThisTML]) then
        oTML[reftUnitsInRangeOfThisTML] = {}

    else
        for iRecordedUnit, oRecordedUnit in oTML[reftUnitsInRangeOfThisTML] do
            if oRecordedUnit == oUnit then
                bAlreadyIncluded = true
                break
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Will record this unit against the TML as being in range, unless already included, bAlreadyIncluded='..tostring(bAlreadyIncluded)) end
    if not(bAlreadyIncluded) then
        table.insert(oTML[reftUnitsInRangeOfThisTML], oUnit)
    end
    if bUpdateZoneForUnitsWantingTMD and oUnit:GetAIBrain().M28AI then
        RecordIfUnitsWantTMDCoverageAgainstLandZone(oUnit:GetAIBrain().M28Team, { oUnit }, not(bAlreadyIncluded))
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, time='..GetGameTimeSeconds()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AlliedTMDFirstRecorded(iTeam, oTMD)
    --Have just recorded an allied TMD for a land zone - want to record all units within a long range that want protecting from TML if this provides protection from an enemy TML
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AlliedTMDFirstRecorded'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': oTMD '..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' has been identified, will reecord if are any enemy TML, is table of enemy TML empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyTML]))) end

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyTML]) == false then
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            if aiBrain then
                local tUnitsToProtect = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryProtectFromTML, oTMD:GetPosition(), iTMLMissileRange + 20, 'Ally')
                if M28Utilities.IsTableEmpty(tUnitsToProtect) == false then
                    local tOnLandUnits = {}
                    for iUnit, oUnit in tUnitsToProtect do
                        if not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                            table.insert(tOnLandUnits, oUnit)
                        end
                    end
                    if M28Utilities.IsTableEmpty(tOnLandUnits) == false then
                        UpdateTMDCoverageOfUnits(iTeam,{ oTMD }, tOnLandUnits)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TMLDied(oTML)
    --Updates tracking of the TML including for any units that had it recorded as being in range of them, and then checks if those units want TMD coverage (as there may no longer be any TML to protect from)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TMLDied'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': TML has just died, is the table of units in range of it empty='..tostring(M28Utilities.IsTableEmpty(oTML[reftUnitsInRangeOfThisTML]))) end
    local iTMLTeam = oTML:GetAIBrain().M28Team
    --Update each team that was tracking this
    for iTeam = 1, M28Team.iTotalTeamCount do
        if not(iTMLTeam == iTeam) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyTML]) == false then
            for iRecordedTML, oRecordedTML in M28Team.tTeamData[iTeam][M28Team.reftEnemyTML] do
                if oRecordedTML == oTML then
                    table.remove(M28Team.tTeamData[iTeam][M28Team.reftEnemyTML], iRecordedTML)
                end
            end
        end
    end
    --Update each unit that was tracking this:
    if M28Utilities.IsTableEmpty(oTML[reftUnitsInRangeOfThisTML]) == false then
        local tUnitsToUpdateByTeam = {}
        local iCurTeam
        for iUnit, oUnit in oTML[reftUnitsInRangeOfThisTML] do
            if M28UnitInfo.IsUnitValid(oUnit) then
                for iExistingTML, oExistingTML in oUnit[reftTMLInRangeOfThisUnit] do
                    if oExistingTML == oTML then
                        iCurTeam = oUnit:GetAIBrain().M28Team
                        if not(tUnitsToUpdateByTeam[iCurTeam]) then tUnitsToUpdateByTeam[iCurTeam] = {} end
                        table.insert(tUnitsToUpdateByTeam[iCurTeam], oUnit)
                        table.remove(oUnit[reftTMLInRangeOfThisUnit], iExistingTML)
                        break
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tUnitsToUpdateByTeam) == false then
            for iTeam, tUnitList in tUnitsToUpdateByTeam do
                RecordIfUnitsWantTMDCoverageAgainstLandZone(iTeam, tUnitList, true)
            end
        end
    end
end
function TMDDied(oTMD)
    --Updates any units that were relying on oTMD for protection from TML, and reassesses if those units want more TMD now
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TMDDied'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': TMD has just died, is the table of units covered by this TMD empty='..tostring(M28Utilities.IsTableEmpty(oTMD[reftUnitsCoveredByThisTMD]))) end
    if M28Utilities.IsTableEmpty(oTMD[reftUnitsCoveredByThisTMD]) == false then
        local tUnitsToCheckIfWantTMDCoverageByTeam = {}
        local iCurTeam
        for iUnit, oUnit in oTMD[reftUnitsCoveredByThisTMD] do
            if M28UnitInfo.IsUnitValid(oUnit) then
                for iRecordedTMD, oRecordedTMD in oUnit[reftTMDCoveringThisUnit] do
                    if oRecordedTMD == oTMD then
                        iCurTeam = oUnit:GetAIBrain().M28Team
                        if not(tUnitsToCheckIfWantTMDCoverageByTeam[iCurTeam]) then tUnitsToCheckIfWantTMDCoverageByTeam[iCurTeam] = {} end
                        table.insert(tUnitsToCheckIfWantTMDCoverageByTeam[iCurTeam], oUnit)
                        table.remove(oUnit[reftTMDCoveringThisUnit], iRecordedTMD)
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tUnitsToCheckIfWantTMDCoverageByTeam) == false then
            for iTeam, tUnitList in tUnitsToCheckIfWantTMDCoverageByTeam do
                RecordIfUnitsWantTMDCoverageAgainstLandZone(iTeam, tUnitList, true)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateTMDCoverageOfUnits(iTeam, tTMD, tUnitsToUpdate)
    --Goes through each unit in tUnitsToUpdate, and records any TMD in tTMD that can protect it from all TML in range of the unit
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateTMDCoverageOfUnits'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tAllEnemyTML = M28Team.tTeamData[iTeam][M28Team.reftEnemyTML]
    if M28Utilities.IsTableEmpty(tAllEnemyTML) == false then --redundancy
        local bTMDCoversFromAllTML
        local bCanBlockCurTML
        local bAlreadyRecordedTMD = false
        local bAlreadyRecordedAsWantingTMD
        local iUnitToTMD, iUnitToTML, iTMDToTML, iTMDRange, iBuildingSize, iAngleTMLToTMD, iAngleTMLToUnit
        local iUnitPlateau, iUnitLandZone
        for iUnit, oUnit in tUnitsToUpdate do
            if M28Utilities.IsTableEmpty(oUnit[reftTMLInRangeOfThisUnit]) == false then
                iBuildingSize = M28UnitInfo.GetBuildingSize(oUnit.UnitId)
                for iTMD, oTMD in tTMD do
                    bTMDCoversFromAllTML = true
                    iUnitToTMD = M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), oUnit:GetPosition())
                    if not(oTMD[M28UnitInfo.refiMissileDefenceRange]) then M28UnitInfo.RecordUnitRange(oTMD) end
                    iTMDRange = (oTMD[M28UnitInfo.refiMissileDefenceRange] or 12.5)

                    --Reduce TMDRange to the effective range
                    iTMDRange = iTMDRange - iBuildingSize

                    for iTML, oTML in oUnit[reftTMLInRangeOfThisUnit] do
                        bCanBlockCurTML = false
                        iUnitToTML = M28Utilities.GetDistanceBetweenPositions(oTML:GetPosition(), oUnit:GetPosition())
                        iTMDToTML = M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), oTML:GetPosition())

                        iAngleTMLToUnit = M28Utilities.GetAngleFromAToB(oTML:GetPosition(), oUnit:GetPosition())
                        iAngleTMLToTMD = M28Utilities.GetAngleFromAToB(oTML:GetPosition(), oTMD:GetPosition())
                        if M28Utilities.IsLineFromAToBInRangeOfCircleAtC(iUnitToTML, iTMDToTML, iUnitToTMD, iAngleTMLToUnit, iAngleTMLToTMD, iTMDRange) then
                            --TMD can block the TML
                            if bDebugMessages == true then LOG(sFunctionRef..': oTMD='..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' can block the TML so will record it') end
                            bCanBlockCurTML = true
                        end
                        if not(bCanBlockCurTML) then
                            bTMDCoversFromAllTML = false
                            break
                        end
                    end
                    if bTMDCoversFromAllTML then
                        if not(oUnit[reftTMDCoveringThisUnit]) then oUnit[reftTMDCoveringThisUnit] = {}
                        else
                            for iRecordedTMD, oRecordedTMD in oUnit[reftTMDCoveringThisUnit] do
                                if oRecordedTMD == oTMD then bAlreadyRecordedTMD = true  break end
                            end
                        end
                        if not(bAlreadyRecordedTMD) then
                            table.insert(oUnit[reftTMDCoveringThisUnit], oTMD)
                        end
                    end
                end
            end
        end
        RecordIfUnitsWantTMDCoverageAgainstLandZone(iTeam, tUnitsToUpdate, true)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordIfUnitsWantTMDCoverageAgainstLandZone(iTeam, tUnits, bCalledDueToTMLOrTMDEvent)
    --Cycles through each unit in tUnits and if it has less TMD covering it than TML in range, makes sure it is reecorded in its land zone as one of the units wanting TMD
    --If it has sufficient TMD coverage, then instead makes sure it isnt recorded in its land zone as one of the units wanting TMD
    --Relies on otherfunctions for accurately recording TML in range of it and TMD giving coverage
    --bCalledDueToTMLOrTMDEvent - if this is true, then will recheck if we want more TMD/how many we have in range even if we have recently checked for this

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordIfUnitsWantTMDCoverageAgainstLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTMDInRange, iUnitPlateau, iUnitLandZone
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; size of tUnits='..table.getn(tUnits)..'; iTeam='..iTeam) end
    local iVariableDelayInSeconds = math.max(10, M28Land.iTicksPerLandCycle * 0.25)
    for iUnit, oUnit in tUnits do
        if bCalledDueToTMLOrTMDEvent or not(oUnit[refbRecentlyCheckedTMDOrTML]) then
            oUnit[refbRecentlyCheckedTMDOrTML] = true
            M28Utilities.DelayChangeVariable(oUnit, refbRecentlyCheckedTMDOrTML, false, iVariableDelayInSeconds)
            --Does the unit need TMD coverage?
            iTMDInRange = 0
            if M28Utilities.IsTableEmpty(oUnit[reftTMDCoveringThisUnit]) == false then
                --Treat Aeon as having twice the TMD power as other factions
                for iRecordedTMD, oRecordedTMD in oUnit[reftTMDCoveringThisUnit] do
                    if M28UnitInfo.IsUnitValid(oRecordedTMD) then
                        if EntityCategoryContains(categories.AEON, oRecordedTMD.UnitId) then
                            iTMDInRange = iTMDInRange + 2
                        else
                            iTMDInRange = iTMDInRange + 1
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considierng unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTMDInRange='..iTMDInRange..'; TML in range='..table.getn((oUnit[reftTMLInRangeOfThisUnit] or {}))..'; oUnit[refbUnitWantsMoreTMD]='..tostring(oUnit[refbUnitWantsMoreTMD] or false)..'; Is oUnit[reftTMDCoveringThisUnit] empty='..tostring(M28Utilities.IsTableEmpty(oUnit[reftTMDCoveringThisUnit]))) end
            local iTMLValueInRangeOfUnit = 0
            if M28Utilities.IsTableEmpty(oUnit[reftTMLInRangeOfThisUnit]) == false then
                for iRecordedTML, oRecordedTML in oUnit[reftTMLInRangeOfThisUnit] do
                    if M28UnitInfo.IsUnitValid(oRecordedTML) then
                        --UEF ACU with billy nuke upgrade - increase value
                        if EntityCategoryContains(categories.COMMAND * categories.UEF, oRecordedTML.UnitId) and oRecordedTML.HasEnhancement and oRecordedTML:HasEnhancement('TacticalNukeMissile') then
                            if bDebugMessages == true then LOG(sFunctionRef..': ENemy unit owned by brain '..oRecordedTML:GetAIBrain().Nickname..' has a billy nuke') end
                            iTMLValueInRangeOfUnit = iTMLValueInRangeOfUnit + 4
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMissileShip * categories.AEON, oRecordedTML.UnitId) then
                            --Aeon missile ship
                            iTMLValueInRangeOfUnit = iTMLValueInRangeOfUnit + 3
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMML * categories.TECH2, oRecordedTML.UnitId) then
                            iTMLValueInRangeOfUnit = iTMLValueInRangeOfUnit + 0.75
                        elseif EntityCategoryContains(categories.EXPERIMENTAL, oRecordedTML.UnitId) then
                            if oRecordedTML.UnitId == 'uese0001' then
                                iTMLValueInRangeOfUnit = 5
                            else
                                iTMLValueInRangeOfUnit = 2.5
                            end
                        else
                            iTMLValueInRangeOfUnit = iTMLValueInRangeOfUnit + 1
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if want more TMD for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTMDInRange='..iTMDInRange..'; iTMLValueInRangeOfUnit='..iTMLValueInRangeOfUnit..'; oUnit[refiMinTMDWantedForUnit]='..(oUnit[refiMinTMDWantedForUnit] or 'nil'))  end
            if ((iTMDInRange < iTMLValueInRangeOfUnit) or (oUnit[refiMinTMDWantedForUnit] and iTMDInRange < oUnit[refiMinTMDWantedForUnit])) and not(oUnit[refbNoNearbyTMDBuildLocations]) then
                if not(oUnit[refbUnitWantsMoreTMD]) then --redundancy (i.e. will ahve already called below if unit is already flagged as wanting more TMD)
                    iUnitPlateau, iUnitLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': Want TMD for this unit, iUnitPlateau='..(iUnitPlateau or 'nil')..'; iUnitLandZone='..(iUnitLandZone or 'nil')..'; Unit owner='..oUnit:GetAIBrain().Nickname..'; iTMDInRange='..iTMDInRange..'; oUnit[refiMinTMDWantedForUnit]='..(oUnit[refiMinTMDWantedForUnit] or 'nil')) end
                    if iUnitLandZone > 0 then
                        local tLZTeamData = M28Map.tAllPlateaus[iUnitPlateau][M28Map.subrefPlateauLandZones][iUnitLandZone][M28Map.subrefLZTeamData][iTeam]
                        table.insert(tLZTeamData[M28Map.reftUnitsWantingTMD], oUnit)
                    end
                    oUnit[refbUnitWantsMoreTMD] = true
                end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Have enough TMD covering this unit, unit wants more TMD flag='..tostring(oUnit[refbUnitWantsMoreTMD] or false)) end
                if oUnit[refbUnitWantsMoreTMD] then --i.e. unit previously was flagged as needing more TMD (but now it doesnt)
                    --Remove this unit from the land zone list of units wanting TMD
                    iUnitPlateau, iUnitLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                    if iUnitLandZone > 0 then
                        local tLZTeamData = M28Map.tAllPlateaus[iUnitPlateau][M28Map.subrefPlateauLandZones][iUnitLandZone][M28Map.subrefLZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Dont want TMD for this unit, iUnitPlateau='..(iUnitPlateau or 'nil')..'; iUnitLandZone='..(iUnitLandZone or 'nil')..'; is table of LZ units wanting TMD empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]))) end
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]) == false then
                            --Remove htis unit from the list of units wanting TMD
                            for iRecordedUnit, oRecordedUnit in tLZTeamData[M28Map.reftUnitsWantingTMD] do
                                if bDebugMessages == true then LOG(sFunctionRef..': oRecordedUnit='..oRecordedUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRecordedUnit)) end
                                if oRecordedUnit == oUnit then
                                    table.remove(tLZTeamData[M28Map.reftUnitsWantingTMD], iRecordedUnit)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have removed from units wanting TMD in zone, is table of units wanting TMD empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]))) end
                                    break
                                end
                            end
                        end
                    end
                    oUnit[refbUnitWantsMoreTMD] = false
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateLZUnitsWantingTMDForUnitDeath(oUnit)
    --Updates any units currently recorded as wanting TMD to see if htey still want TMD based on TMD coverage
    local iUnitPlateau, iUnitLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
    if iUnitLandZone > 0 then
        local iTeam = oUnit:GetAIBrain().M28AITeam
        local tLZTeamData = M28Map.tAllPlateaus[iUnitPlateau][M28Map.subrefPlateauLandZones][iUnitLandZone][M28Map.subrefLZTeamData][iTeam]
        --Remove all dead units from the table (not just this one) as extra redundancy
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]) == false then
            local iRevisedIndex = 1
            local iTableSize = table.getn(tLZTeamData[M28Map.reftUnitsWantingTMD])

            for iOrigIndex=1, iTableSize do
                if tLZTeamData[M28Map.reftUnitsWantingTMD][iOrigIndex] then
                    if M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.reftUnitsWantingTMD][iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                        --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                        if (iOrigIndex ~= iRevisedIndex) then
                            tLZTeamData[M28Map.reftUnitsWantingTMD][iRevisedIndex] = tLZTeamData[M28Map.reftUnitsWantingTMD][iOrigIndex]
                            tLZTeamData[M28Map.reftUnitsWantingTMD][iOrigIndex] = nil
                        end
                        iRevisedIndex = iRevisedIndex + 1 --i.e. this will be the position of where the next value that we keep will be located
                    else
                        tLZTeamData[M28Map.reftUnitsWantingTMD][iOrigIndex] = nil
                    end
                end
            end
            if iRevisedIndex < iTableSize then
                --table.setn(tLZTeamData[M28Map.reftUnitsWantingTMD], iRevisedIndex - 1)
                for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
                    table.remove(tLZTeamData[M28Map.reftUnitsWantingTMD], iRemovalEntry)
                end
            end
        end
    end
    oUnit[refbUnitWantsMoreTMD] = false --redundancy
end

function GetUnitWantingTMD(tLZData, tLZTeamData, iTeam, iOptionalLandZone, bReturnTMLCountAsWell, iOptionalCategoryWanted, bGetClosestUnitToOurBase)
    --Gets the unit closest to the nearest enemy base that wants TMD; also refreshes the table for any dead units
    --bGetClosestUnitToOurBase - if this is true, then instead of nearest enemy base will get closest to our base
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnitWantingTMD'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Cap on number of TMD to prvent massiveo verbuilding - dont have more than 10 in a LZ unless enemy has lots of TML
    local tExistingTMD = EntityCategoryFilterDown(M28UnitInfo.refCategoryTMD, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
    local iExistingValidTMD = 0
    local iEnemyTotalTMLCount
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of existing TMD empty='..tostring(M28Utilities.IsTableEmpty(tExistingTMD))..'; iOptionalLandZone='..(iOptionalLandZone or 'nil')..'; Time='..GetGameTimeSeconds()) end

    if M28Utilities.IsTableEmpty(tExistingTMD) == false then
        iExistingValidTMD = table.getn(tExistingTMD)

        --Max TMD limit - no. of mexes in the zone * 0.5 if lower; also higher TMD if we have Aeon TMD
        local iTMDLimit = math.min(30, math.max(10, (tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3]) * 0.5, tLZTeamData[M28Map.subrefLZSValue] / 5000))
        if not(tLZTeamData[M28Map.subrefLZbCoreBase]) then iTMDLimit = math.min(iTMDLimit, math.max(4, tLZTeamData[M28Map.subrefMexCountByTech][3] * 2 + tLZTeamData[M28Map.subrefMexCountByTech][2], tLZTeamData[M28Map.subrefLZSValue] / 5000)) end
        if tLZTeamData[M28Map.subrefiTimeFriendlyTMDHitEnemyMissile] and GetGameTimeSeconds() - tLZTeamData[M28Map.subrefiTimeFriendlyTMDHitEnemyMissile] <= 40 then
            iTMDLimit = iTMDLimit + 2
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iExistingValidTMD='..iExistingValidTMD..'; iTMDLimit='..iTMDLimit..'; tLZTeamData[M28Map.subrefiTimeFriendlyTMDHitEnemyMissile]='..(tLZTeamData[M28Map.subrefiTimeFriendlyTMDHitEnemyMissile] or 'nil')) end
        if iExistingValidTMD >= iTMDLimit or bReturnTMLCountAsWell then
            iEnemyTotalTMLCount = 0
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyTML]) == false then
                iEnemyTotalTMLCount = table.getn(M28Team.tTeamData[iTeam][M28Team.reftEnemyTML])
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iEnemyTotalTMLCount='..iEnemyTotalTMLCount) end
            if iExistingValidTMD > math.max(15, iTMDLimit + (iEnemyTotalTMLCount - 1) * 3) then
                --Too much TMD already, clear any units wanting TMD; send error message if we have loads of TMD
                if iExistingValidTMD >= 10 then
                    M28Utilities.ErrorHandler('Have at least '..iExistingValidTMD..' TMD in land zone so wont build any more TMD, risk we may be overbuilding TMD, will clear entries', true)
                end
                tLZTeamData[M28Map.reftUnitsWantingTMD] = {}
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return nil
            end
        end
    end

    local iUnitsWantingTMD = table.getn(tLZTeamData[M28Map.reftUnitsWantingTMD])
    local iClosestDist = 10000
    local iCurDist
    local oClosestUnit
    local tBaseForDistanceCheck
    if bGetClosestUnitToOurBase then tBaseForDistanceCheck = tLZTeamData[M28Map.reftClosestFriendlyBase]
    else tBaseForDistanceCheck = tLZTeamData[M28Map.reftClosestEnemyBase]
    end
    for iEntry = iUnitsWantingTMD, 1, -1 do
        if not(M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry])) then
            table.remove(tLZTeamData[M28Map.reftUnitsWantingTMD], iEntry)
        elseif not(iOptionalCategoryWanted) or EntityCategoryContains(iOptionalCategoryWanted, tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry].UnitId) then
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tBaseForDistanceCheck, tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry]:GetPosition())
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if unit '..tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry].UnitId..M28UnitInfo.GetUnitLifetimeCount(tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry])..' is the closest, iCurDist='..iCurDist..'; iCLosestDist='..iClosestDist..'; refbUnitWantsMoreTMD='..tostring(tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry][refbUnitWantsMoreTMD])) end
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestUnit = tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry]
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': If dont have a unit to cover with TMD and TMD has intercepted enemy missile recently then build TMD to cover TMD, oClosestUnit='..(oClosestUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestUnit) or 'nil')..'; tLZTeamData[M28Map.subrefiTimeFriendlyTMDHitEnemyMissile]='..(tLZTeamData[M28Map.subrefiTimeFriendlyTMDHitEnemyMissile] or 'nil')..'; iExistingValidTMD='..iExistingValidTMD) end
    if not(oClosestUnit) and tLZTeamData[M28Map.subrefiTimeFriendlyTMDHitEnemyMissile] and iExistingValidTMD > 0 and iExistingValidTMD <= 10 and GetGameTimeSeconds() - tLZTeamData[M28Map.subrefiTimeFriendlyTMDHitEnemyMissile] <= 60 then
        --Consider doubling up on TMD by having a TMD request TMD if it has fired recently
        local oClosestTMDFiredRecently
        local iCurLaunchers, iCurTMD
        for iTMD, oTMD in tExistingTMD do
            if oTMD[refiTimeTMDHitMissile] and GetGameTimeSeconds() - oTMD[refiTimeTMDHitMissile] <= 60 and M28Conditions.IsTableOfUnitsStillValid(oTMD[toLaunchersIntercepted]) then

                iCurDist = M28Utilities.GetDistanceBetweenPositions(tBaseForDistanceCheck, oTMD:GetPosition())
                if iCurDist < iClosestDist then
                    --Do we have enough TMD already covering this unit?
                    iCurLaunchers = table.getn(oTMD[toLaunchersIntercepted])
                    if bDebugMessages == true then LOG(sFunctionRef..': iCurLaunchers='..iCurLaunchers..'; oTMD='..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..'; Is table of TMD covering this unit empty='..tostring(M28Utilities.IsTableEmpty(oTMD[reftTMDCoveringThisUnit]))) end
                    if iCurLaunchers > 1 then
                        iCurTMD = 1
                        for iLauncher, oLauncher in oTMD[toLaunchersIntercepted] do
                            RecordUnitsInRangeOfTMLAndAnyTMDProtection(oLauncher, { oTMD }, false)
                        end
                        if M28Utilities.IsTableEmpty(oTMD[reftTMDCoveringThisUnit]) then iCurTMD = 1
                        else iCurTMD = table.getn(oTMD[reftTMDCoveringThisUnit]) end
                        if iCurLaunchers > iCurTMD - 1 or (iCurLaunchers >= 4 and iCurLaunchers > math.min(iCurTMD - 2, iCurTMD * 0.6)) then
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurTMD='..iCurTMD..' so want to build more to cover this TMD and stop it being overwhelmed') end
                            iClosestDist = iCurDist
                            oClosestUnit = oTMD
                        end

                    end
                end
            end
        end
    end

    if bDebugMessages == true then
        LOG(sFunctionRef..': End of code, oClosestUnit='..(oClosestUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestUnit) or 'nil')..'; Is table of TML in range of this unit empty='..tostring(M28Utilities.IsTableEmpty(oClosestUnit[reftTMLInRangeOfThisUnit]))..'; Is reftTMDCoveringThisUnit empty='..tostring(M28Utilities.IsTableEmpty(oClosestUnit[reftTMDCoveringThisUnit])))
        if M28Utilities.IsTableEmpty(oClosestUnit[reftTMLInRangeOfThisUnit]) == false then
            for iTML, oTML in oClosestUnit[reftTMLInRangeOfThisUnit] do
                LOG(sFunctionRef..': oTML in range='..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)..'; Dist='..M28Utilities.GetDistanceBetweenPositions(oTML:GetPosition(), oClosestUnit:GetPosition())..'; TML range='..(oTML[M28UnitInfo.refiIndirectRange] or oTML[M28UnitInfo.refiManualRange] or 'nil'))
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bReturnTMLCountAsWell then return oClosestUnit, iEnemyTotalTMLCount
    else
        return oClosestUnit
    end
end


function RecordPriorityShields(iTeam, tLZTeamData)
    --Records shields that want to ahve engineers assisting
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordPriorityShields'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if GetGameTimeSeconds() - (tLZTeamData[M28Map.refiTimeOfLastShieldPriorityRefresh] or -100) >= 10 then
        tLZTeamData[M28Map.refiTimeOfLastShieldPriorityRefresh] = GetGameTimeSeconds()
        local tShieldsToAssist = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        --First clear any engineers assigned to shields that arent listed as a priority shield from the last update
        if bDebugMessages == true then LOG(sFunctionRef..': WIll refresh list of shields. Is table empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssist))..'; do we already have any priority shields when when last ran this? is table empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]))) end
        if M28Utilities.IsTableEmpty(tShieldsToAssist) == false then
            local tTemporaryPriorityShields = {}
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]) == false then
                for iShield, oShield in tShieldsToAssist do
                    if M28Utilities.IsTableEmpty(oShield[M28UnitInfo.reftoUnitsAssistingThis]) == false and not(oShield[refbPriorityShield]) then
                        local bClearShield = true
                        if oShield[refbRemoveShieldFromPriorityTableWhenFullHealth] then
                            bClearShield = false
                            local iCurShieldHealth, iCurShieldMaxHealth = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                            if iCurShieldHealth / iCurShieldMaxHealth >= 0.99 then
                                bClearShield = true
                            end
                            if not(bClearShield) then
                                table.insert(tTemporaryPriorityShields, oShield)
                            else
                                oShield[refbRemoveShieldFromPriorityTableWhenFullHealth] = nil
                            end
                        end
                        if bClearShield then
                            --Shield wasnt a priority shield in the last cycle but has engineers assigned to assist it - will clear these engineers
                            local tEngineersToClear = {}
                            for iEngi, oEngi in oShield[M28UnitInfo.reftoUnitsAssistingThis] do
                                table.insert(tEngineersToClear, oEngi)
                            end
                            for iAssistingEngineer, oAssistingEngineer in tEngineersToClear do
                                if M28UnitInfo.IsUnitValid(oAssistingEngineer) then M28Orders.IssueTrackedClearCommands(oAssistingEngineer) end
                            end
                            oShield[M28UnitInfo.reftoUnitsAssistingThis] = nil
                        end
                    end
                end
            end

            tLZTeamData[M28Map.reftPriorityShieldsToAssist] = {}
            if M28Utilities.IsTableEmpty(tTemporaryPriorityShields) == false then
                for iShield, oShield in tTemporaryPriorityShields do
                    table.insert(tLZTeamData[M28Map.reftPriorityShieldsToAssist], oShield)
                end
            end
            local iTotalUnitMassCoverage
            local iCurMassValue
            local bConsiderRecentlyDamagedShields = false
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates]) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 300 then bConsiderRecentlyDamagedShields = true end
            for iShield, oShield in tShieldsToAssist do
                iTotalUnitMassCoverage = 0
                if bDebugMessages == true then LOG(sFunctionRef..': Considering shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; size of table of units nearby='..table.getn(oShield[reftoUnitsCoveredByShield])) end
                if M28Utilities.IsTableEmpty(oShield[reftoUnitsCoveredByShield]) == false and not(oShield[reftArtiTemplateRefs]) and not(oShield[refbRemoveShieldFromPriorityTableWhenFullHealth]) then
                    --Only flag a shield for assistance if its health is <80%
                    local iCurShieldHealth, iMaxShieldHealth = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Shield health='..iCurShieldHealth..'; Max health='..iMaxShieldHealth) end
                    if iCurShieldHealth > 0 and (iCurShieldHealth / iMaxShieldHealth <= 0.8 or (bConsiderRecentlyDamagedShields and oShield[M28UnitInfo.refiTimeLastDamaged] and GetGameTimeSeconds() - (oShield[M28UnitInfo.refiTimeLastDamaged] or -100) <= 30)) then

                        for iUnit, oUnit in oShield[reftoUnitsCoveredByShield] do
                            if not(oUnit == oShield) then
                                if EntityCategoryContains(M28UnitInfo.refCategorySMD, oUnit.UnitId) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false then
                                    iCurMassValue = 30000
                                elseif EntityCategoryContains(M28UnitInfo.refCategorySML, oUnit.UnitId) then
                                    iCurMassValue = 27500
                                else
                                    iCurMassValue = (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
                                end
                                if not(oUnit[refoPriorityShieldProvidingCoverage] == oShield) and M28UnitInfo.IsUnitValid(oUnit[refoPriorityShieldProvidingCoverage]) then
                                    iCurMassValue = iCurMassValue * 0.1
                                    if bDebugMessages == true then LOG(sFunctionRef..': Already have a priority shield providing coverage='..oUnit[refoPriorityShieldProvidingCoverage].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[refoPriorityShieldProvidingCoverage])..' so will reduce mass value') end
                                end
                                iTotalUnitMassCoverage = iTotalUnitMassCoverage + iCurMassValue
                                if bDebugMessages == true then LOG(sFunctionRef..': Getting shield protection mass value of oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' for oShield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; iCurMassValue='..iCurMassValue..'; iTotalUnitMassCoverage='..iTotalUnitMassCoverage..'; Is there already a valid shield protecting it='..tostring(M28UnitInfo.IsUnitValid(oUnit[refoPriorityShieldProvidingCoverage]))) end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iTotalUnitMassCoverage='..iTotalUnitMassCoverage..'; refiAssignedFirebase='..(oShield[refiAssignedFirebase] or 'nil')) end
                        if iTotalUnitMassCoverage >= 25000 then
                            --Add as a priority shield
                            table.insert(tLZTeamData[M28Map.reftPriorityShieldsToAssist], oShield)
                            oShield[refbPriorityShield] = true
                            for iUnit, oUnit in oShield[reftoUnitsCoveredByShield] do
                                oUnit[refoPriorityShieldProvidingCoverage] = oShield --Deliberately overwrites existing value, means if 2 shields cover same area, and one can justify it even with the ot her, but the other cant, then we wont protect the other
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding the shield as a priority shield') end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderDelayedOnMexDeathCall(tUnitPosition, sUnitRef, sLifetimeCount, iOwnerArmyIndex, iOwnerTeam, bMexWasConstructed)
    --Due to a replay on LOUD where a mex was destroyed (fully constructed) and it showed up as being an upgrading mex so OnMexDeath never triggered, resulting in M28 thinkning there were no locations available to build (when there were)
    WaitSeconds(3)
    local rRect = M28Utilities.GetRectAroundLocation(tUnitPosition, 0.5)
    local tUnitsInRect = GetUnitsInRect(rRect)
    local bHaveMexThere = false
    if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
        local tMexesInRect = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tUnitPosition)
        if M28Utilities.IsTableEmpty(tMexesInRect) == false then
            bHaveMexThere = true
        end
    end
    if not(bHaveMexThere) then
        --Check we have fewer mexes recorded in this zone for all teams
        local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(tUnitPosition, true, iOwnerTeam)
        local iTeamMexes = 0
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefMexCountByTech]) == false then
            for iTech, iMexes in tLZOrWZTeamData[M28Map.subrefMexCountByTech] do
                iTeamMexes = iTeamMexes + iMexes
            end
        end
        if iTeamMexes < tLZOrWZData[M28Map.subrefLZOrWZMexCount] then
            --Have a risk of an inconsistency so run OnMexDeath to be safe
            OnMexDeath(tUnitPosition, sUnitRef, sLifetimeCount, iOwnerArmyIndex, bMexWasConstructed, true)
        end
    end
end

function OnMexDeath(tUnitPosition, sUnitRef, sLifetimeCount, iOwnerArmyIndex, bMexWasConstructed, bPotentiallyDuplicateCall)
    --Call via fork thread due to the WaitSeconds() in it; however note that as this is forked, the unit (mex) may not exist anymore, so tUnitPosition needs to be a copy of the position table, and dont want to pass the unit object
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OnMexDeath'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; tUnitPosition='..repru(tUnitPosition)) end



    --local tUnitPosition = {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]}
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tUnitPosition)
    local tMexLocations
    local tLZOrWZData
    local iWaterZone, iPond



    if iPlateau and not(iLandZone) then
        iWaterZone = M28Map.GetWaterZoneFromPosition(tUnitPosition)
        if iWaterZone then
            iPond = M28Map.tiPondByWaterZone[iWaterZone]
            tLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
            tMexLocations = tLZOrWZData[M28Map.subrefLZOrWZMexLocations]
        end
    else
        tLZOrWZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
        tMexLocations = tLZOrWZData[M28Map.subrefLZOrWZMexLocations]
    end


    if bDebugMessages == true then LOG(sFunctionRef..': is table of mex locations empty='..tostring( M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZOrWZMexLocations]))..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; tUnitPosition='..repru(tUnitPosition)..'; is tMexLocations empty='..tostring(M28Utilities.IsTableEmpty(tMexLocations))..'; iWaterZone='..(iWaterZone or 'nil')..'; Time='..GetGameTimeSeconds()) end
    if M28Utilities.IsTableEmpty(tMexLocations) == false then
        --Record time of last mex death against LZ data to help with error messages
        tLZOrWZData[M28Map.refiTimeOfLastMexDeath] = GetGameTimeSeconds()

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1) --dont treat mex as available for a second (this is to help cover scenarios where if a mex has 'died' due to being upgraded, the new building will be here) - was a 2s delay, are trying 1s delay now to see if causes an issue
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        local tClosestMexLocation
        local iClosestMexLocation = 2.1 --no point considering mexes further away
        local iCurAbsDif
        for iEntry, tMex in tLZOrWZData[M28Map.subrefLZOrWZMexLocations] do --(WZ uses same ref ID definition)
            iCurAbsDif = math.abs(tMex[1] - tUnitPosition[1]) + math.abs(tMex[3] - tUnitPosition[3])
            if iCurAbsDif < iClosestMexLocation then
                iClosestMexLocation = iCurAbsDif
                tClosestMexLocation = {tMex[1], tMex[2], tMex[3]}
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting a period of time and then searching for closest mex location, tClosestMexLocation='..repru(tClosestMexLocation)..'; Time='..GetGameTimeSeconds()..'; iPlateau='..iPlateau..'; iLandZone='..(iLandZone or 'nil')) end
        if not(tClosestMexLocation) then M28Utilities.ErrorHandler('Couldnt find a mex in this zone close enough to the unit position on death')
        else
            --for iMexLocation, tMexLocation in tMexLocations do
            --Prev line - redid at same time as changing approach for removing an unbuilt location to try and be more accurate
            --if M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition()) <= 0.9 then
            --Revised line:
            --if tMexLocation[1] == tClosestMexLocation[1] and tMexLocation[3] == tClosestMexLocation[3] then
            --Do we have any mexes in this location?
            local rRect = M28Utilities.GetRectAroundLocation(tClosestMexLocation, 0.9)
            local tUnitsInRect = GetUnitsInRect(rRect)
            if bDebugMessages == true then
                LOG(sFunctionRef..': Is tUnitsInRect empty='..tostring(M28Utilities.IsTableEmpty(tUnitsInRect)))
                if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                    LOG(sFunctionRef..': If filter to just mexes is the table empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tUnitsInRect))))
                end
            end
            local bNoMex = true
            if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                local tMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tUnitsInRect)
                if M28Utilities.IsTableEmpty(tMexes) == false then
                    for iMex, oMex in tMexes do
                        if M28UnitInfo.IsUnitValid(oMex) and not(oMex.UnitId == sUnitRef and M28UnitInfo.GetUnitLifetimeCount(oMex) == sLifetimeCount and oMex:GetAIBrain():GetArmyIndex() == iOwnerArmyIndex) then
                            local tMexPosition = oMex:GetPosition()
                            --Get closest mex to this, in case there's another mex that's closer
                            local iCurMexClosestLocation = 2.1
                            local tCurMexClosestLocation
                            for iEntry, tMex in tLZOrWZData[M28Map.subrefLZOrWZMexLocations] do --(WZ uses same ref ID definition)
                                iCurAbsDif = math.abs(tMex[1] - tMexPosition[1]) + math.abs(tMex[3] - tMexPosition[3])
                                if iCurAbsDif < iCurMexClosestLocation then
                                    iCurMexClosestLocation = iCurAbsDif
                                    tCurMexClosestLocation = {tMex[1], tMex[2], tMex[3]}
                                end
                            end
                            if tCurMexClosestLocation[1] == tClosestMexLocation[1] and tCurMexClosestLocation[3] == tClosestMexLocation[3] then
                                --double-check due to rare case where presumably an upgrading t3 mex has just started and the base mex died, and there's a delay?
                                if bDebugMessages == true then LOG(sFunctionRef..': Have a valid mex in this location, oMex='..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)..'; Is mex valid='..tostring(M28UnitInfo.IsUnitValid(oMex))..'; Army Index='..oMex:GetAIBrain():GetArmyIndex()..'; sUnitRef='..sUnitRef..'; sLifetimeCount='..sLifetimeCount..'; iOwnerArmyIndex='..(iOwnerArmyIndex or 'nil')..'; tCurMexClosestLocation='..repru(tCurMexClosestLocation)..'; Mex position='..repru(oMex:GetPosition())..'; tUnitPosition='..repru(tUnitPosition)..'; tClosestMexLocation='..repru(tClosestMexLocation)..'; oMex fraction complete='..oMex:GetFractionComplete()..'; OMex Owner army index='..oMex:GetAIBrain():GetArmyIndex()..'; iOwnerArmyIndex='..iOwnerArmyIndex) end
                                if oMex:GetFractionComplete() < 1 and oMex:GetAIBrain():GetArmyIndex() == iOwnerArmyIndex and M28Utilities.GetDistanceBetweenPositions(tUnitPosition, tCurMexClosestLocation) <= 0.5 and M28UnitInfo.GetUnitTechLevel(oMex) > M28UnitInfo.GetBlueprintTechLevel(sUnitRef) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Think we have a mex that has died while upgrading, and the upgrading mex hasnt had its death triggered yet, so wont treat there as being a mex here afterall') end
                                else
                                    bNoMex = false
                                    break
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if we have a mex at this location anymore, bNoMex='..tostring(bNoMex)) end
            if bNoMex then
                local bAlreadyRecorded = false
                if not(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) then
                    tLZOrWZData[M28Map.subrefMexUnbuiltLocations] = {}
                else
                    for iEntry, tUnbuiltLocation in tLZOrWZData[M28Map.subrefMexUnbuiltLocations] do --redundancy in case this code triggers more than once, as were comign across unbuilt locations with the same entry listed more than once (although it wasnt showing up with a reprs/repru)
                        if tUnbuiltLocation[1] == tClosestMexLocation[1] and tUnbuiltLocation[3] == tClosestMexLocation[3] then
                            bAlreadyRecorded = true
                            break
                        end
                    end
                end
                if not(bAlreadyRecorded) then
                    table.insert(tLZOrWZData[M28Map.subrefMexUnbuiltLocations], tClosestMexLocation)
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Recording location as being unbuilt as mex is dead and no mexes visible there now, tClosestMexLocation='..repru(tClosestMexLocation))
                        M28Utilities.DrawLocation(tClosestMexLocation)
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Already recorded this location as unbuilt') end
                end
            end
        end
        if bDebugMessages == true then
            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) then LOG(sFunctionRef..': tLZOrWZData[M28Map.subrefMexUnbuiltLocations] after update is empty')
            else LOG(sFunctionRef..': tLZOrWZData[M28Map.subrefMexUnbuiltLocations] after update has a size '..table.getn(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])..', table='..repru(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]))
            end
        end
    else
        M28Utilities.ErrorHandler('Mex has died but not in a recognised land or water zone that has mexes')
    end

    --Track mexes by team

    local iTeam
    local oOwnerBrain
    for iBrain, oBrain in ArmyBrains do
        if iBrain == iOwnerArmyIndex then
            oOwnerBrain = oBrain
            iTeam = oBrain.M28Team
            break
        end
    end
    if iTeam then
        if bMexWasConstructed then
            local iMexTech = M28UnitInfo.GetBlueprintTechLevel(sUnitRef)
            M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][iMexTech] = (M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][iMexTech] or 0) - 1
            if bPotentiallyDuplicateCall then
                local iCurrentCountOfMexOfTech = ArmyBrains[iOwnerArmyIndex]:GetCurrentUnits(M28UnitInfo.refCategoryMex * M28UnitInfo.ConvertTechLevelToCategory(iMexTech))
                if M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][iMexTech] < iCurrentCountOfMexOfTech then
                    M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][iMexTech] = iCurrentCountOfMexOfTech
                end
            end
            if bDebugMessages == true then
                local iUpgradingMexCount=0
                local iDeadUpgradingMexCount = 0
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) == false then
                    iUpgradingMexCount = table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes])
                    for iUpgradingMex, oUpgradingMex in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes] do
                        if not(M28UnitInfo.IsUnitValid(oUpgradingMex)) then iDeadUpgradingMexCount = iDeadUpgradingMexCount + 1 end
                    end
                end
                LOG(sFunctionRef..': Mex '..sUnitRef..sLifetimeCount..' has died for team '..iTeam..'; Revised mex count by tech='..(M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][iMexTech] or 'nil')..'; T2 mex count based on currentunits='..ArmyBrains[iOwnerArmyIndex]:GetCurrentUnits(M28UnitInfo.refCategoryMex * M28UnitInfo.ConvertTechLevelToCategory(iMexTech))..'; Upgrading mexes on team iUpgradingMexCount='..iUpgradingMexCount..'; iDeadUpgradingMexCount='..iDeadUpgradingMexCount)
            end
        end
    else
        if not(oOwnerBrain) or not(M28Conditions.IsCivilianBrain(oOwnerBrain)) then
            if GetGameTimeSeconds() - M28Overseer.iTimeLastPlayerDefeat > 5 and (not(M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) or GetGameTimeSeconds() - M28Overseer.iTimeLastPlayerDefeat > 40) then
                M28Utilities.ErrorHandler('Mex death for a brain that doesnt have a team, oOwnerBrain='..(oOwnerBrain.Nickname or 'nil'))
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function OnMexConstructionCompleted(oUnit)
    local sFunctionRef = 'OnMexConstructionCompleted'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Track mexes by team
    local iTeam = oUnit:GetAIBrain().M28Team
    if iTeam then
        local iMexTech = M28UnitInfo.GetUnitTechLevel(oUnit)
        if not(M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech]) then
            M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech] = {}
        end
        M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][iMexTech] = (M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][iMexTech] or 0) + 1
        if bDebugMessages == true then
            local iUpgradingMexCount=0
            local iDeadUpgradingMexCount = 0
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) == false then iUpgradingMexCount = table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) end
            for iUpgradingMex, oUpgradingMex in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes] do
                if not(M28UnitInfo.IsUnitValid(oUpgradingMex)) then iDeadUpgradingMexCount = iDeadUpgradingMexCount + 1
                end
            end
            LOG(sFunctionRef..': Mex '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has just had construction started for team '..iTeam..'; Revised mex count by tech='..(M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][iMexTech] or 'nil')..'; T2 mex count based on currentunits='..oUnit:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMex * M28UnitInfo.ConvertTechLevelToCategory(iMexTech))..'; Upgrading mexes on team iUpgradingMexCount='..iUpgradingMexCount..'; iDeadUpgradingMexCount='..iDeadUpgradingMexCount)
        end
    elseif not(M28Conditions.IsCivilianBrain(oUnit:GetAIBrain())) then
        M28Utilities.ErrorHandler('No brain for mex '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' owned by brain '..(oUnit:GetAIBrain().Nickname or 'nil')..' so wont record for that brain team')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function OnMexConstructionStarted(oUnit)
    --Run for all brains

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OnMexConstructionStarted'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --If 100% complete mex and fullshare is enabled then wait 2 ticks before running logic due to issue where the new unit cna be created before the logic re the old one dying triggers
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..'; Is game in full share='..tostring(ScenarioInfo.Options.Share == 'FullShare')..'; Time since last teammate death='..(GetGameTimeSeconds() - (M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiTimeOfLastTeammateDeath] or 0))..'; Fraction complete='..oUnit:GetFractionComplete()) end
    if oUnit:GetFractionComplete() == 1 and ScenarioInfo.Options.Share == 'FullShare' and GetGameTimeSeconds() - (M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiTimeOfLastTeammateDeath] or 0) <= 20 then
        if bDebugMessages == true then LOG(sFunctionRef..': A player has recently died so delaying logic for mex that is fully complete') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(3)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    if not(M28Map.bMapLandSetupComplete) or GetGameTimeSeconds() <= 5.1 or not(M28Map.bWaterZoneInitialCreation) then
        while (not(M28Map.bMapLandSetupComplete) or GetGameTimeSeconds() <= 5.1 or not(M28Map.bWaterZoneInitialCreation)) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if GetGameTimeSeconds() >= 6 then break end
        end
    end

    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
    local tMexLocations
    local tLZOrWZData
    local iWaterZone, iPond



    if iPlateau and not(iLandZone) then
        iWaterZone = M28Map.GetWaterZoneFromPosition(oUnit:GetPosition())
        if iWaterZone then
            iPond = M28Map.tiPondByWaterZone[iWaterZone]
            tLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
            tMexLocations = tLZOrWZData[M28Map.subrefLZOrWZMexLocations]
        end
    else
        tLZOrWZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
        tMexLocations = tLZOrWZData[M28Map.subrefLZOrWZMexLocations]
    end

    if bDebugMessages == true then LOG(sFunctionRef..': The time is '..GetGameTimeSeconds()..'; Have just started construction for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'; Is M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]))..'; Unit position='..repru(oUnit:GetPosition())..'; Unit brain='..oUnit:GetAIBrain().Nickname..'; on team '..(oUnit:GetAIBrain().M28Team or 'nil')..'; % complete='..oUnit:GetFractionComplete()) end
    local bFoundMexLocation = false
    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false then
        --Find the closest mex location in the zone
        local tClosestMexLocation
        local iClosestMexLocation = 2.1 --no point considering mexes further away
        local iCurAbsDif
        local tUnitPosition = oUnit:GetPosition()
        for iEntry, tMex in tLZOrWZData[M28Map.subrefLZOrWZMexLocations] do --(WZ uses same ref ID definition)
            iCurAbsDif = math.abs(tMex[1] - tUnitPosition[1]) + math.abs(tMex[3] - tUnitPosition[3])
            if iCurAbsDif < iClosestMexLocation then
                iClosestMexLocation = iCurAbsDif
                tClosestMexLocation = {tMex[1], tMex[2], tMex[3]}
            end
        end


        local iSizeBefore = table.getn(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])
        if bDebugMessages == true then LOG('About to loop through Mex locations; iPlateau='..iPlateau..'; iLandZone='..(iLandZone or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'; reprs='..reprs(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])..'; iSizeBefore='..iSizeBefore..'; tClosestMexLocation='..repru(tClosestMexLocation)) end
        --local iSizeAfter
        --local iLocationToRemove
        if bDebugMessages == true then
            for iMexLocation, tMexLocation in tLZOrWZData[M28Map.subrefMexUnbuiltLocations] do
                LOG(sFunctionRef..': iMexLocation='..iMexLocation..'; tMexLocation='..repru(tMexLocation))
            end
        end
        if tClosestMexLocation then
            for iEntry = iSizeBefore, 1, -1 do
                local tMexLocation = tLZOrWZData[M28Map.subrefMexUnbuiltLocations][iEntry]
                if bDebugMessages == true then LOG(sFunctionRef..': Comparing dist for iEntry '..iEntry..'; tMexLocation='..repru(tMexLocation)..'; tClosestMexLocation='..repru(tClosestMexLocation)) end
                if tMexLocation[1] == tClosestMexLocation[1] and tMexLocation[3] == tClosestMexLocation[3] then
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Have built a mex within 1 of a mex location so will treat this mex location as no longer available. iEntry='..iEntry)
                        M28Utilities.DrawLocation(tMexLocation, 2)
                    end
                    bFoundMexLocation = true
                    local vRemoved = table.remove(tLZOrWZData[M28Map.subrefMexUnbuiltLocations], iEntry)
                    if bDebugMessages == true then LOG(sFunctionRef..': tLZOrWZData[M28Map.subrefMexUnbuiltLocations] after removal='..repru(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])..'; vRemoved='..reprs(vRemoved)..'; iSizeBefore='..iSizeBefore) end
                    break
                end
            end
        else
            M28Utilities.ErrorHandler('Couldnt find a mex location close enough')
        end
        --Old code - had issues with this sometimes where e.g. would have a table that with reprs showed as only having 1 entry, but it actually had 2 and were identical
        --[[for iMexLocation, tMexLocation in tLZOrWZData[M28Map.subrefMexUnbuiltLocations] do
            --Old code commented out below caused issues on maps like sludge:
            --if M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition()) <= 2 then
            --Replaced with the following:
            if bDebugMessages == true then LOG(sFunctionRef..': Considering tMexLocation='..repru(tMexLocation)..'; compared with Unit position '..repru(oUnit:GetPosition())) end
            if math.abs(tMexLocation[1] - oUnit:GetPosition()[1]) < 1 and math.abs(tMexLocation[3] - oUnit:GetPosition()[3]) < 1 then
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Have built a mex within 1 of a mex location so will treat this mex location as no longer available. iMexLocation='..iMexLocation)
                    M28Utilities.DrawLocation(tMexLocation, 2)
                end
                bFoundMexLocation = true
                iLocationToRemove = iMexLocation
                break
            end
        end
        if iLocationToRemove then
            local vRemoved = table.remove(tLZOrWZData[M28Map.subrefMexUnbuiltLocations], iLocationToRemove)
            local iSizeAfter
            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) then iSizeAfter = 0
            else iSizeAfter = table.getn(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])
            end
            if bDebugMessages == true then LOG(sFunctionRef..': tLZOrWZData[M28Map.subrefMexUnbuiltLocations] after removal='..repru(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])..'; vRemoved='..reprs(vRemoved)..'; iSizeBefore='..iSizeBefore..'; iSizeAfter='..iSizeAfter) end
        end
        if iSizeAfter >= iSizeBefore then
            --Backup for strange case where table.remove would remove a table but the table would still remain

        end--]]
    end
    if not(bFoundMexLocation) then
        --Is the reason we cant find any unbuilt locations because a mex is being upgraded? Doing a reprs of a mex being upgraded, CanTakeDamage was false and IsUpgrade was true, so use these to check
        if bDebugMessages == true then LOG(sFunctionRef..': Dont have an unbuilt location that existed for this mex, is it because mex is upgrading? oUnit.CanTakeDamage='..tostring(oUnit.CanTakeDamage or false)..'; oUnit.IsUpgrade='..tostring(oUnit.IsUpgrade or false)..'; LZ time of last mex death='..(GetGameTimeSeconds() - (tLZOrWZData[M28Map.refiTimeOfLastMexDeath] or 0))..'; reprs of unit='..reprs(oUnit)) end
        local bCheckOnlyForLowerTechExistingMex = true
        if oUnit.CanTakeDamage and not(oUnit.IsUpgrade) and (GetGameTimeSeconds() - (tLZOrWZData[M28Map.refiTimeOfLastMexDeath] or 0)) > 2.1 then
            --Ignore if early game and is owned by non-human brain, or campaign and owned by non-M28AI non-human brain
            if oUnit:GetAIBrain().BrainType == 'Human' or oUnit:GetAIBrain().M28AI or (GetGameTimeSeconds() >= 10 and not(M28Map.bIsCampaignMap)) then bCheckOnlyForLowerTechExistingMex = false end
            local tNearbyRect = M28Utilities.GetRectAroundLocation(oUnit:GetPosition(), 0.49)
            local tNearbyUnits = GetUnitsInRect(tNearbyRect)
            local bHaveMexHere = false
            if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                for iBuilding, oBuilding in tNearbyUnits do
                    if not(oBuilding == oUnit) and EntityCategoryContains(M28UnitInfo.refCategoryMex, oBuilding.UnitId) and M28UnitInfo.IsUnitValid(oBuilding) then
                        if not(bCheckOnlyForLowerTechExistingMex) or M28UnitInfo.GetUnitTechLevel(oBuilding) < M28UnitInfo.GetUnitTechLevel(oUnit) then
                            bHaveMexHere = true
                            break
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bCheckOnlyForLowerTechExistingMex='..tostring(bCheckOnlyForLowerTechExistingMex)..'; bHaveMexHere='..tostring(bHaveMexHere)..'; Is table of nearby units empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnits))) end
            if not(bHaveMexHere) then
                --we have a 1s delay on a mex dying before checking for available locations, so this could explain this
                if tLZOrWZData[M28Map.refiTimeOfLastMexDeath] and GetGameTimeSeconds() - tLZOrWZData[M28Map.refiTimeOfLastMexDeath] > 1.01 then
                    M28Utilities.ErrorHandler('OnCreate triggered for a mex but no unbuilt locations near it, iPlateau='..iPlateau..'; iLandZone='..(iLandZone or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'; Map setup complete='..tostring(M28Map.bMapLandSetupComplete)..'; bWaterZoneInitialCreation='..tostring(M28Map.bWaterZoneInitialCreation or false), true)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': tLZOrWZData[M28Map.subrefMexUnbuiltLocations]='..repru(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit position='..repru(oUnit:GetPosition())) end
            end
        end
    end

    --Add mex to enemy unit table if underwater, due to flaw with current approach - i.e. to reduce overhead all AI regardless of team use the same table for if a mex has been built; engineers are meant to either build on unbuilt mexes, or try and reclaim if the enemy is there; however without this step they effectively end up thinking a teammate has the mex so they never tyr sending an engineer to build or capture.  For land it's not an issue as would expect land scouts or other land units to reveal the mexes anyway
    if iWaterZone > 0 then
        local tTeamsUpdated = {}
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.subreftoEnemyBrains]) == false then
            for iBrain, oBrain in M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.subreftoEnemyBrains] do
                if oBrain.M28AI and not(tTeamsUpdated[oBrain.M28Team]) then
                    tTeamsUpdated[oBrain.M28Team] = true
                    --(aiBrain, oUnit, bAlreadyUpdatedPosition, bAlreadyTriedReassignment, bIgnoreIfAssignedAlready)
                    M28Team.AssignUnitToLandZoneOrPond(oBrain, oUnit, false,                    false,                      true)
                end
            end
        else
            --E.g. civilians that own mexes
            local iMexBrainIndex = oUnit:GetAIBrain():GetArmyIndex()
            for iBrain, oBrain in ArmyBrains do
                if not(IsAlly(oBrain:GetArmyIndex(), iMexBrainIndex)) then
                    if oBrain.M28AI and not(tTeamsUpdated[oBrain.M28Team]) then
                        tTeamsUpdated[oBrain.M28Team] = true
                        --(aiBrain, oUnit, bAlreadyUpdatedPosition, bAlreadyTriedReassignment, bIgnoreIfAssignedAlready)
                        M28Team.AssignUnitToLandZoneOrPond(oBrain, oUnit, false,                    false,                      true)
                    end
                end
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tLZOrWZData[M28Map.subrefMexUnbuiltLocations]='..repru(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DecideToLaunchNukeSMLOrTMLMissile()  end --Done only to make it easier to find considerlaunchingmissile
function ConsiderLaunchingMissile(oLauncher, oOptionalWeapon)
    --Should be called via forkthread when missile created due to creating a loop
    --oOptioanlWeapon - if specified then can get the missile speed
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderLaunchingMissile'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28UnitInfo.IsUnitValid(oLauncher) and not(oLauncher[refbActiveMissileChecker]) then
        local aiBrain = oLauncher:GetAIBrain()
        local iSecondsToWaitIfNoTarget = 10
        if bDebugMessages == true then LOG(sFunctionRef..': aiBrain.HostileCampaignAI='..tostring(aiBrain.HostileCampaignAI or false)..'; ScenarioInfo.Options.CmpAIDelay='..tonumber((ScenarioInfo.Options.CmpAIDelay or 1))..'; ScenarioInfo.OpEnded='..tostring(ScenarioInfo.OpEnded or false)..'; Time='..GetGameTimeSeconds()) end
        if not(aiBrain.HostileCampaignAI) or tonumber(ScenarioInfo.Options.CmpAIDelay) <= GetGameTimeSeconds() then
            --Aeon SML - one case having 11s threshold was fine, another when it was 12.1s since it fired a nuke it ended up clearing the old order
            local iTimeToWaitBetweenLaunches = 6 --i.e. TML
            if EntityCategoryContains(M28UnitInfo.refCategorySML, oLauncher.UnitId) then
                if EntityCategoryContains(categories.AEON, oLauncher.UnitId) then
                    iTimeToWaitBetweenLaunches = 13
                else
                    iTimeToWaitBetweenLaunches = 8
                end
            end

            if bDebugMessages == true then
                LOG(sFunctionRef..': Start of code for oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..' owned by brain '..oLauncher:GetAIBrain().Nickname..' at time='..GetGameTimeSeconds()..'; launcher position='..repru(oLauncher:GetPosition())..'Unit missile count='..M28UnitInfo.GetMissileCount(oLauncher)..'; Time since last issued a nuke launch order='..GetGameTimeSeconds() - (oLauncher[refiTimeLastFiredMissile] or -1000)..'; iTimeToWaitBetweenLaunches='..iTimeToWaitBetweenLaunches)
            end

            if oLauncher[refbSpecialLauncherTargeting] == nil then
                oLauncher[refbSpecialLauncherTargeting] = false --default
                --TML special case - TML batteries for snipe targets - dont use this logic
                if EntityCategoryContains(M28UnitInfo.refCategoryTML, oLauncher.UnitId) then
                    local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oLauncher:GetPosition(), true, oLauncher:GetAIBrain().M28Team)
                    if tLZTeamData[M28Map.refbGetTMLBattery] then
                        oLauncher[refbSpecialLauncherTargeting] = true
                        ForkThread(TMLBatteryMonitor, tLZTeamData, oLauncher)
                    end
                end
            end
            if oLauncher[refbSpecialLauncherTargeting] then M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd) return end

            --If we have just tried giving an order to fire then wait longer
            if oLauncher[refiTimeLastFiredMissile] and GetGameTimeSeconds() - oLauncher[refiTimeLastFiredMissile] <= iTimeToWaitBetweenLaunches then
                if bDebugMessages == true then LOG(sFunctionRef..': we tried firing recently so will do a delayed launch instead') end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                --LOG('Forked consideration of launching missile Delay3')
                DelayedConsiderLaunchingMissile(oLauncher, iTimeToWaitBetweenLaunches - (GetGameTimeSeconds() - oLauncher[refiTimeLastFiredMissile]), true, true)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Beginning main launcher logic, setting active missile checker to true') end
                oLauncher[refbActiveMissileChecker] = true
                local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)

                local tTarget
                local iBestTargetValue
                local iCurTargetValue
                local tEnemyCategoriesOfInterest
                local aiBrain = oLauncher:GetAIBrain()
                local iMaxRange = 250 --basic default, should get overwritten
                local iMinRange = 0
                local iAOE, iDamage

                local bTML = false
                local bSML = false
                local bCheckForSMD = false
                local iMinDelayBetweenNukes = 15 + 40 * M28Map.iMapSize / 1024 --Aeon nuke takes 60s to get to corner of setons, think it takes 5s longer to fire, so will go with 55 for non-aeon; as a very rough approximation will allow 15s for non-Aeon to fire and then rise and then fall, and 40s for travelling, so are slightly better on 40km+ maps at not double-nuking the same spot

                local iTeam = aiBrain.M28Team
                local iTotalWaitCount = 0 --Nukes will spread calculations over a number of ticks, this tracks the ticks waited
                if EntityCategoryContains(M28UnitInfo.refCategoryTML, oLauncher.UnitId) then
                    bTML = true
                elseif EntityCategoryContains(M28UnitInfo.refCategorySML, oLauncher.UnitId) then
                    bSML = true
                    if not(EntityCategoryContains(categories.EXPERIMENTAL, oLauncher.UnitId)) then
                        bCheckForSMD = true --default
                        --If we have lots more nukes than enemy has SMD then consider overwhelming the SMD with nukes
                        local iNukeCount = 0
                        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                            iNukeCount = oBrain:GetCurrentUnits(M28UnitInfo.refCategorySML - categories.EXPERIMENTAL - M28UnitInfo.refCategoryBattleship) + oBrain:GetCurrentUnits(M28UnitInfo.refCategorySML * categories.EXPERIMENTAL) * 6
                        end
                        --Only consider overwhelming if we have 6 nukes
                        local iEnemySMD = 0
                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to check for SMD when deciding on targets for a non experimental nuke launcher, iNukeCount='..iNukeCount) end
                        if iNukeCount >= 4 then
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) == false then
                                for iSMD, oSMD in M28Team.tTeamData[iTeam][M28Team.reftEnemySMD] do
                                    if oSMD:GetFractionComplete() == 1 then
                                        iEnemySMD = iEnemySMD + 1
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iEnemySMD='..iEnemySMD) end
                            if iNukeCount >= iEnemySMD * 1.5 then
                                --Have enough nukes to overwhelm enemy
                                bCheckForSMD = false
                                if bDebugMessages == true then LOG(sFunctionRef..': Have more than 50% of enemy SMD in nuke launchers so will nuke regardless of SMD, iNukeCount='..iNukeCount..'; iEnemySMD='..iEnemySMD) end
                            else
                                --How many SMD does enemy have in one zone?
                                local tiSMDByPlateauAndZone = {}
                                local iCurSMDPlateauOrZero, iCurSMDZone
                                local iHighestSMDPerZone = 0
                                for iSMD, oSMD in M28Team.tTeamData[iTeam][M28Team.reftEnemySMD] do
                                    if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(oSMD:GetPosition()) then
                                        iCurSMDPlateauOrZero, iCurSMDZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oSMD:GetPosition())
                                        if not(tiSMDByPlateauAndZone[iCurSMDPlateauOrZero]) then tiSMDByPlateauAndZone[iCurSMDPlateauOrZero] = {} end
                                        tiSMDByPlateauAndZone[iCurSMDPlateauOrZero][iCurSMDZone] = (tiSMDByPlateauAndZone[iCurSMDPlateauOrZero][iCurSMDZone] or 0) + 1
                                        iHighestSMDPerZone = math.max(iHighestSMDPerZone, tiSMDByPlateauAndZone[iCurSMDPlateauOrZero][iCurSMDZone])
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': iNukeCount='..iNukeCount..'; iEnemySMD='..iEnemySMD..'; iHighestSMDPerZone='..iHighestSMDPerZone) end
                                if iNukeCount >= iHighestSMDPerZone * 1.5 then
                                    bCheckForSMD = false
                                end
                            end

                            if not(bCheckForSMD) and iEnemySMD > 0 then
                                iMinDelayBetweenNukes = math.min(10, math.max(5, 15 - iNukeCount/2))
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to ignore SMD, oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..'; iNukeCount='..iNukeCount..'; iEnemySMD (if we have lots of nukes)='..iEnemySMD..'; bCheckForSMD='..tostring(bCheckForSMD)..'; Time='..GetGameTimeSeconds()..'; iMinDelayBetweenNukes='..iMinDelayBetweenNukes) end
                        end

                        if EntityCategoryContains(categories.AEON, oLauncher.UnitId) then iMinDelayBetweenNukes = iMinDelayBetweenNukes + 5 end
                    else
                        --yolona - refuce min delay if enemy has lots of SMD as may be trying to overwhelm
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) == false then
                            local bAllowMultipleNukesAtTarget = false

                            if M28Team.tTeamData[iTeam][M28Team.refbSMDBlockingLastNukeTarget] then
                                bAllowMultipleNukesAtTarget = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy has SMDs and there was an SMD blockign the last nuke target so we want to reduce the delay between nuke targets') end
                            else
                                local bEnemyHasLoadedOrLotsOfSMD = false
                                if table.getn(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) >= 3 then
                                    bEnemyHasLoadedOrLotsOfSMD = true
                                else
                                    for iSMD, oSMD in M28Team.tTeamData[iTeam][M28Team.reftEnemySMD] do
                                        if oSMD:GetTacticalSiloAmmoCount() > 0 then
                                            bEnemyHasLoadedOrLotsOfSMD = true
                                            break
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': bEnemyHasLoadedOrLotsOfSMD='..tostring(bEnemyHasLoadedOrLotsOfSMD)) end

                                if bEnemyHasLoadedOrLotsOfSMD then
                                    --if any nuke target in the last 30s is currently covered by SMD, then remove min delay
                                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]) == false then
                                        local iThresholdTime = GetGameTimeSeconds() - 30
                                        for iTime, tLocation in M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations] do

                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering nuke launch location if it was fired within threshold time, fired in threshold='..tostring(iTime >= iThresholdTime)..'; IsSMDBlockingTarget='..tostring(IsSMDBlockingTarget(aiBrain, tLocation, oLauncher:GetPosition(), 30, 0, false))..'; iTime='..iTime..'; tLocation='..repru(tLocation)) end
                                            if iTime >= iThresholdTime and IsSMDBlockingTarget(aiBrain, tLocation, oLauncher:GetPosition(), 30, 0, false) then
                                                bAllowMultipleNukesAtTarget = true
                                                if bDebugMessages == true then LOG(sFunctionRef..': Want to allow multiple nukes at targets') end
                                            end
                                        end
                                    end
                                end
                            end
                            if bAllowMultipleNukesAtTarget then iMinDelayBetweenNukes = 0 end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished considering the min delay between nukes at the same location for a yolona, iMinDelayBetweenNukes='..iMinDelayBetweenNukes..'; Is table of enemy SMD empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]))) end
                    end


                elseif EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oLauncher.UnitId) then
                    M28Utilities.ErrorHandler('Are running TML logic on an ACU or SACU, but code not setup to work for this yet')
                else M28Utilities.ErrorHandler('Unknown type of launcher, code to fire a missile wont work; oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher))
                end

                if bTML or bSML then
                    iAOE, iDamage, iMinRange, iMaxRange = M28UnitInfo.GetLauncherAOEStrikeDamageMinAndMaxRange(oLauncher)

                    if bTML then
                        --tEnemyCategoriesOfInterest = iTMLHighPriorityCategories
                    else --SML
                        if oLauncher[M28UnitInfo.refbEasyBrain] then
                            tEnemyCategoriesOfInterest = {M28UnitInfo.refCategoryExperimentalStructure, M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategorySML + categories.COMMAND, M28UnitInfo.refCategoryT3Mex + M28UnitInfo.refCategoryT3Power}
                        else
                            tEnemyCategoriesOfInterest = {M28UnitInfo.refCategoryExperimentalStructure, M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategorySML + categories.COMMAND, M28UnitInfo.refCategoryT3Mex + M28UnitInfo.refCategoryT3Power, M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryStructure * categories.TECH3 + M28UnitInfo.refCategoryFixedT2Arti - M28UnitInfo.refCategoryExperimentalStructure - M28UnitInfo.refCategoryFixedT3Arti - M28UnitInfo.refCategorySML - M28UnitInfo.refCategoryT3Mex - M28UnitInfo.refCategorySMD - M28UnitInfo.refCategoryT3Power, M28UnitInfo.refCategoryNavalSurface * categories.TECH3 + M28UnitInfo.refCategoryNavalSurface * categories.EXPERIMENTAL}
                        end
                    end

                    if bDebugMessages == true then LOG(sFunctionRef..': Will consider missile target. iMinRange='..(iMinRange or 'nil')..'; iAOE='..(iAOE or 'nil')..'; iDamage='..(iDamage or 'nil')..'; bSML='..tostring((bSML or false))..'; bTML='..tostring(bTML or false)..'; Is laucher valid='..tostring(M28UnitInfo.IsUnitValid(oLauncher))..'; Time='..GetGameTimeSeconds()) end
                    if M28UnitInfo.IsUnitValid(oLauncher) then
                        local bHaveBlockingSMD = false
                        if bTML then
                            --DEALING WITH TML---------------------------------------------------
                            --local tHighHealthTargets = {}
                            local tStartPos = oLauncher:GetPosition()
                            local tPotentialTargets
                            local iValidTargets = 0
                            local tValidTargets = {}
                            local iTMLRange = (oLauncher[M28UnitInfo.refiManualRange] or iTMLMissileRange)
                            local iTMLAOE = math.max(oLauncher[M28UnitInfo.refiIndirectAOE] or 0, 2)
                            local iPotentialInRangeDistance = iTMLRange + iTMLAOE + 4 --unlikely to have larger buildings than this
                            local tNearbyEnemyTMD
                            if bDebugMessages == true then LOG(sFunctionRef..': Will consider enemy ACU in TML targets in FAF/steam, M28Utilities.bFAFActive='..tostring(M28Utilities.bFAFActive)..'; Is table of enemy ACUs empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]))) end
                            if M28Utilities.bFAFActive or M28Utilities.bSteamActive and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) == false then
                                local tACUsInRange = {}
                                local iCurDist
                                for iACU, oACU in M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs] do
                                    if M28UnitInfo.IsUnitValid(oACU) and ((oACU[refiTMLShotsFired] or 0) <= 2 or ((oACU[refiTMLShotsHit] or 0) > 0 and oACU[refiTMLShotsHit] / oACU[refiTMLShotsFired] >= 0.33))  then
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oLauncher:GetPosition())
                                        if iCurDist <= iTMLRange then
                                            --Track ACU positions
                                            ForkThread(MonitorUnitRecentPositions, oACU)
                                            --Is enemy ACU stationery?
                                            if oACU[M28UnitInfo.reftRecentUnitPositions][2] then
                                                --Is ACU stationery, and hasnt moved from when we last had intel of their position?
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering oACU owned by brain ='..oACU:GetAIBrain().Nickname..'; Dist to recent position2='..M28Utilities.GetDistanceBetweenPositions(oACU[M28UnitInfo.reftRecentUnitPositions][2], oACU:GetPosition())..'; Unit state='..M28UnitInfo.GetUnitState(oACU)..'; Dist to last known position='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oACU[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; iCurDist='..iCurDist..'; Shots fired='..(oACU[refiTMLShotsFired] or 0)..'; refiTMLShotsHit='..(oACU[refiTMLShotsHit] or 0)..'; Dist to position 4='..M28Utilities.GetDistanceBetweenPositions((oACU[M28UnitInfo.reftRecentUnitPositions][4] or {0,0,0}), oACU:GetPosition())) end
                                                if oACU:GetHealth() <= 18000 and (not(oACU.MyShield.GetHealth) or oACU.MyShield:GetHealth() <= 3000) and M28Utilities.GetDistanceBetweenPositions(oACU[M28UnitInfo.reftRecentUnitPositions][2], oACU:GetPosition()) <= 0.1 and not(oACU:IsUnitState('Moving')) and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oACU[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 2 then
                                                    --Check ACU doesnt have very high health or shield
                                                    if iCurDist <= 150 then iSecondsToWaitIfNoTarget = 1 elseif iCurDist <= 180 then iSecondsToWaitIfNoTarget = 2 else iSecondsToWaitIfNoTarget = 3 end
                                                    if iCurDist <= 60 or (oACU[refiTMLShotsFired] or 0) == 0 or (oACU[M28UnitInfo.reftRecentUnitPositions][4] and M28Utilities.GetDistanceBetweenPositions(oACU[M28UnitInfo.reftRecentUnitPositions][4], oACU:GetPosition()) <= 0.1) then
                                                        --Is there TMD protecting the ACU from us?
                                                        local tACULZData, tACULZTeamData = M28Map.GetLandOrWaterZoneData(oACU:GetPosition(), false, iTeam)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of TMD in ACU LZ empty='..tostring(M28Utilities.IsTableEmpty(tACULZTeamData[M28Map.subreftoEnemyTMD]))) end
                                                        if M28Utilities.IsTableEmpty(tACULZTeamData[M28Map.subreftoEnemyTMD]) then

                                                            local tNearbyTMD = oACU:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD, oACU:GetPosition(), iTMLMissileRange + 30, 'Ally')
                                                            local bProtectedByTMD = false
                                                            if M28Utilities.IsTableEmpty(tNearbyTMD) == false then
                                                                for iTMD, oTMD in tNearbyTMD do
                                                                    if IsTMDProtectingUnitFromTML(oTMD, oACU, oLauncher) then
                                                                        bProtectedByTMD = true
                                                                        break
                                                                    end
                                                                end
                                                            end
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby TMD empty='..tostring(M28Utilities.IsTableEmpty(tACULZTeamData[M28Map.subreftoEnemyTMD]))..'; bProtectedByTMD='..tostring(bProtectedByTMD)) end
                                                            if not(bProtectedByTMD) then
                                                                table.insert(tACUsInRange, oACU)
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                                if M28Utilities.IsTableEmpty(tACUsInRange) == false then
                                    tPotentialTargets = tACUsInRange
                                    if M28Utilities.IsTableEmpty(oLauncher[reftUnprotectedUnitTargetsForThisTML]) == false then
                                        for iTarget, oTarget in oLauncher[reftUnprotectedUnitTargetsForThisTML] do
                                            table.insert(oTarget, tPotentialTargets)
                                        end
                                    end
                                else
                                    tPotentialTargets = oLauncher[reftUnprotectedUnitTargetsForThisTML]
                                end
                            else
                                tPotentialTargets = oLauncher[reftUnprotectedUnitTargetsForThisTML]
                            end
                            --First refresh list of untis in range for any that are dead
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of potential targets empty='..tostring(M28Utilities.IsTableEmpty(tPotentialTargets))) end
                            if M28Utilities.IsTableEmpty(tPotentialTargets) == false then
                                local iPotentialTargets = table.getn(tPotentialTargets)
                                local iCurDist
                                for iCurEntry = iPotentialTargets, 1, -1 do
                                    if not(M28UnitInfo.IsUnitValid(tPotentialTargets[iCurEntry])) then
                                        table.remove(oLauncher[reftUnprotectedUnitTargetsForThisTML], iCurEntry)
                                    else
                                        if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tPotentialTargets[iCurEntry]:GetPosition()) then
                                            --Can we hit this unit factoring in AOE?
                                            iCurDist = M28Utilities.GetDistanceBetweenPositions(tPotentialTargets[iCurEntry]:GetPosition(), tStartPos)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry '..iCurEntry..'; Unit='..tPotentialTargets[iCurEntry].UnitId..M28UnitInfo.GetUnitLifetimeCount(tPotentialTargets[iCurEntry])..'; iCurDist='..iCurDist..'; iPotentialInRangeDistance='..iPotentialInRangeDistance..'; iTMLRange='..iTMLRange..'; iTMLAOE='..iTMLAOE..'; refiStrikeDamageAssigned='..(tPotentialTargets[iCurEntry][M28Air.refiStrikeDamageAssigned] or 0)) end
                                            if iCurDist <= iPotentialInRangeDistance then
                                                if iCurDist <= iTMLRange or iCurDist <= iTMLRange + math.max(iTMLAOE, 0.5 * math.min(tPotentialTargets[iCurEntry]:GetBlueprint().Physics.SkirtSizeX, tPotentialTargets[iCurEntry]:GetBlueprint().Physics.SkirtSizeZ)) then
                                                    table.insert(tValidTargets, tPotentialTargets[iCurEntry])
                                                    iValidTargets = iValidTargets + 1
                                                end
                                            end
                                        end
                                    end
                                end
                            end

                            local oBestTarget
                            if bDebugMessages == true then LOG(sFunctionRef..': iValidTargets='..iValidTargets) end
                            if iValidTargets == 0 then
                                --Disable autobuild and pause the TML since we have no targets - handled below to cover cases where for whatever reason we fail to find a valid target
                            else
                                --Have at least 1 valid target, so want to pick the best one

                                iBestTargetValue = 120 --wont consider targets worth less than this
                                local sLauncherLocationRef = M28Utilities.ConvertLocationToReference(oLauncher:GetPosition())
                                for iUnit, oUnit in tValidTargets do
                                    if M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]) == false then
                                        iCurTargetValue = 0
                                        if bDebugMessages == true then LOG(sFunctionRef..': Shields are covering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                    elseif oUnit.Dead or oUnit:GetFractionComplete() <= 0.6 and (oUnit:GetFractionComplete() <= 1 - 0.25 * M28UnitInfo.GetUnitTechLevel(oUnit)) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Unit under construction so TMD checks are less reliable (although we have a backup later on) and benefit reduced, with bomb damage potentially including other buildings nearby') end
                                    else
                                        --GetDamageFromBomb(aiBrain, tBaseLocation,         iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory, iOptionalReclaimFactor)
                                        iCurTargetValue = M28Logic.GetDamageFromBomb(aiBrain, oUnit:GetPosition(), iAOE, iDamage,       nil,                                nil,                true,                           nil,                nil,                            nil,                                        false,              nil,                            true,                               nil,                                nil,                    nil)
                                        if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then iCurTargetValue = iCurTargetValue * 1.5 end
                                        --Adjust value if we think the missile will hit a cliff
                                        if oUnit[tbExpectMissileBlockedByCliff][sLauncherLocationRef] == nil then
                                            if not(oUnit[tbExpectMissileBlockedByCliff]) then oUnit[tbExpectMissileBlockedByCliff] = {} end
                                            local tExpectedMissileVertical = M28Utilities.MoveInDirection(oLauncher:GetPosition(), M28Utilities.GetAngleFromAToB(oLauncher:GetPosition(), oUnit:GetPosition()), 31, true)
                                            tExpectedMissileVertical[2] = tExpectedMissileVertical[2] + 60 --Doing testing, it actually only goes up by 50, but I think it travels in an arc from here to the target, as in a test scenario doing at less than +60 meant it thought it would hit a cliff when it didnt
                                            -- {oLauncher:GetPosition()[1], oLauncher:GetPosition()[2] + 65, oLauncher:GetPosition()[3]}
                                            oUnit[tbExpectMissileBlockedByCliff][sLauncherLocationRef] = M28Logic.IsLineBlocked(aiBrain, tExpectedMissileVertical, oUnit:GetPosition(), iAOE, false)
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Potential TML target '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurTargetValue before adj for blocked='..iCurTargetValue..'; oUnit[tbExpectMissileBlockedByCliff][sLauncherLocationRef]='..tostring(oUnit[tbExpectMissileBlockedByCliff][sLauncherLocationRef])..'; oUnit[refiTMLShotsFired]='..(oUnit[refiTMLShotsFired] or 0)..'; refiTimeOfLastLaunch='..(oUnit[refiTimeOfLastLaunch] or 'nil')..'; oUnit[refbProtectedByTerrain]='..tostring(oUnit[refbProtectedByTerrain] or false)..'; oLauncher[reftTerrainBlockedTargets]='..repru(oLauncher[reftTerrainBlockedTargets] or {'nil'})..'; iDamage='..iDamage..'; iAOE='..iAOE..'; Unit health='..oUnit:GetHealth()..'; Unit position='..repru(oUnit:GetPosition())..'; Is reftoShieldsProvidingCoverage empty='..tostring(M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]))) end
                                        if oUnit[tbExpectMissileBlockedByCliff][sLauncherLocationRef] then iCurTargetValue = iCurTargetValue * 0.2 end
                                        --Check against actual terrain blocked blacklist
                                        if oUnit[refbProtectedByTerrain] then
                                            iCurTargetValue = 0
                                        elseif M28Utilities.IsTableEmpty(oLauncher[reftTerrainBlockedTargets]) == false then
                                            for iEntry, tLocation in oLauncher[reftTerrainBlockedTargets] do
                                                if M28Utilities.GetDistanceBetweenPositions(tLocation, oUnit:GetPosition()) <= 1.5 then
                                                    oUnit[refbProtectedByTerrain] = true
                                                    iCurTargetValue = 0
                                                    break
                                                end
                                            end
                                        end
                                        if oUnit[M28Air.refiStrikeDamageAssigned] and iCurTargetValue > 0 and oUnit[M28Air.refiStrikeDamageAssigned] > oUnit:GetHealth() then
                                            iCurTargetValue = iCurTargetValue * 0.1
                                            if bDebugMessages == true then LOG(sFunctionRef..': Reducing cur target to 10% as we have assigned bomber striked damage, oUnit[M28Air.refiStrikeDamageAssigned]='..oUnit[M28Air.refiStrikeDamageAssigned]..'; Health='..oUnit:GetHealth()) end
                                        end
                                        if iCurTargetValue > 0 then
                                            if (oUnit[refiTMLShotsFired] or 0) > 0 then
                                                --Reduce shots fired if we dealt damage with our last missile (as may have e.g. hit mass storage blocking us from reaching the target mex)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Last TML target='..(oLauncher[refoLastTMLTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oLauncher[refoLastTMLTarget]) or 'nil')..'; Launcher mass killed='..(oLauncher.VetExperience or oLauncher.Sync.totalMassKilled or 0)..'; TML mass kills='..(oLauncher[refiLastTMLMassKills] or 0)..'; is oUnit[refbRecheckTMLAndTMDWhenConstructedByTeam] nil='..tostring(oUnit[refbRecheckTMLAndTMDWhenConstructedByTeam] == nil)) end
                                                if oLauncher[refoLastTMLTarget] == oUnit and (oLauncher.VetExperience or oLauncher.Sync.totalMassKilled or 0) > (oLauncher[refiLastTMLMassKills] or 0) then
                                                    oLauncher[refiLastTMLMassKills] = (oLauncher.VetExperience or oLauncher.Sync.totalMassKilled or 0)
                                                    oUnit[refiTMLShotsFired] = oUnit[refiTMLShotsFired] - 1
                                                end
                                                if oUnit[refiTMLShotsFired] > math.min((oUnit[refiTMLShotsHit] or 0), 4) and (oUnit[refiTimeOfLastLaunch] or oUnit[refiTMLShotsFired] >= 2) then
                                                    if oUnit[refbRecheckTMLAndTMDWhenConstructedByTeam] then iCurTargetValue = 0
                                                    else
                                                        local iUnitMaxHealth = oUnit:GetMaxHealth()
                                                        local iUnitCurShield, iUnitMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit)
                                                        if (iUnitMaxHealth + iUnitMaxShield <= iDamage and M28UnitInfo.IsUnitValid(oUnit[refoLastTMLLauncher])) and (not(oUnit[refoLastTMLLauncher] == oLauncher) or GetGameTimeSeconds() - (oUnit[refiTimeOfLastLaunch] or -100) <= 35) then
                                                            iCurTargetValue = 0
                                                        else

                                                            local iExpectedShots = math.ceil((iUnitMaxHealth + iUnitMaxShield) / iDamage)
                                                            if oUnit[refiTMLShotsFired] - (oUnit[refiTMLShotsHit] or 0) > iExpectedShots then
                                                                --Reduce by 50% for each time are over
                                                                iCurTargetValue = iCurTargetValue * 0.5^(oUnit[refiTMLShotsFired] - iExpectedShots - math.min(4, (oUnit[refiTMLShotsHit] or 0)))
                                                                if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) and oUnit[refiTMLShotsFired] - iExpectedShots - (oUnit[refiTMLShotsHit] or 0) >= 3 then
                                                                    iCurTargetValue = 0
                                                                end
                                                            end
                                                        end
                                                        if bDebugMessages == true then LOG(sFunctionRef..': iUnitMaxHealth='..iUnitMaxHealth..'; iUnitMaxShield='..iUnitMaxShield..'; oUnit[refiTMLShotsFired]='..oUnit[refiTMLShotsFired]..'; refiTMLShotsHit='..(oUnit[refiTMLShotsHit] or 'nil')..'; oUnit[refiTimeOfLastLaunch]='..(oUnit[refiTimeOfLastLaunch] or 'nil')..'; iCurTargetValue after adjusting for excess='..iCurTargetValue) end
                                                    end
                                                end
                                            elseif oUnit[refbRecheckTMLAndTMDWhenConstructedByTeam] then
                                                iCurTargetValue = iCurTargetValue * 0.25
                                                if bDebugMessages == true then LOG(sFunctionRef..': Target was recorded when under construction, significantly decreasing value due to risk of enemy TMD as appears to be issue with logic not picking up tmd when unit is being upgraded') end
                                                if iCurTargetValue > iBestTargetValue then
                                                    --Do more detailed check
                                                    if not(tNearbyEnemyTMD) then tNearbyEnemyTMD = oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD, oLauncher:GetPosition(), iTMLMissileRange + 20, 'Ally') end
                                                    if M28Utilities.IsTableEmpty(tNearbyEnemyTMD) == false then
                                                        for iTMD, oTMD in tNearbyEnemyTMD do
                                                            RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oLauncher, tNearbyEnemyTMD, false)
                                                        end
                                                    end
                                                    if M28Utilities.IsTableEmpty(oUnit[reftTMDCoveringThisUnit]) == false then
                                                        if M28Utilities.IsTableEmpty(oLauncher[reftUnprotectedUnitTargetsForThisTML]) then
                                                            iCurTargetValue = 0
                                                            if bDebugMessages == true then LOG(sFunctionRef..': No longer an unrptoected target for this TML') end
                                                        else
                                                            local bRecordedStill = false
                                                            for iRecordedUnit, oRecordedUnit in oLauncher[reftUnprotectedUnitTargetsForThisTML] do
                                                                if oRecordedUnit == oUnit then
                                                                    bRecordedStill = true
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Still recorded as an unrptoected target for this TML') end
                                                                    break
                                                                end
                                                            end
                                                            if not(bRecordedStill) then
                                                                iCurTargetValue = 0
                                                            end
                                                        end
                                                    end

                                                end
                                            end
                                        end
                                    end
                                    if iBestTargetValue < iCurTargetValue then
                                        if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then iCurTargetValue = math.max(125, iCurTargetValue * 0.2) end
                                        iBestTargetValue = iCurTargetValue
                                        oBestTarget = oUnit
                                    end
                                end
                                if oBestTarget then
                                    tTarget = oBestTarget:GetPosition()
                                    --Target ground following FAF changes to TMLs
                                    tTarget[2] = GetSurfaceHeight(tTarget[1], tTarget[3])
                                    RecordTMLMissileTarget(oLauncher, oBestTarget)
                                    if bDebugMessages == true then LOG(sFunctionRef..': oBestTarget='..oBestTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestTarget)..'; iBestTargetValue='..iBestTargetValue..'; SHots fired afteri ncluding this one='..oBestTarget[refiTMLShotsFired]..'; refiTMLShotsHit='..(oBestTarget[refiTMLShotsHit] or 'nil')..'; Mass killed prior to missile impacting='..oLauncher[refiLastTMLMassKills]) end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iValidTargets='..iValidTargets..'; tTarget='..repru((tTarget or {'nil'}))..'; Is oBestTarget valid='..tostring(M28UnitInfo.IsUnitValid(oBestTarget))) end
                        else --SML - work out which location would deal the most damage - consider all high value structures and the enemy start position
                            --DEALING WITH NUKE---------------------------------------------------
                            --Reduce AOE by 0.5 if >10 to be more reliable (since height differences mean we might incorrectly think we will hit a high value target?)
                            if iAOE > 10 then iAOE = math.max(10, iAOE - 0.5) end
                            iBestTargetValue = 0
                            --Shortlist of locations we have recently nuked
                            local tRecentlyNuked = {}
                            local iTimeSMDNeedsToHaveBeenBuiltFor = 200 + iTimeForSMDToBeConstructed --default, will adjust
                            local iMissileSpeed
                            if oOptionalWeapon then iMissileSpeed = (__blueprints[oOptionalWeapon.Blueprint.ProjectileId].Physics.MaxSpeed or 40)
                            else iMissileSpeed = 40
                            end
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..'; Breakdown of the weapon table='..reprs(oOptionalWeapon)..'; iMissileSpeed='..iMissileSpeed..'; missile speed per BP='..(__blueprints[oOptionalWeapon.Blueprint.ProjectileId].Physics.MaxSpeed or 'nil'))
                            end

                            local iNukeSegmentSize = 15
                            local tiNukeSegmentsConsidered = {}
                            local iCurNukeSegmentX, iCurNukeSegmentZ
                            local bAlreadyConsideredBestAOETarget = true

                            local iPositionsConsideredThisTick = 0
                            local iAbortThreshold = 60000

                            function GetNukeSegmentsFromPosition(tPosition)
                                return math.ceil(tPosition[1] / iNukeSegmentSize), math.ceil(tPosition[3] / iNukeSegmentSize)
                            end
                            function RecordHaveConsideredNukeLocation(tPosition, bConsideredBestAOETarget)
                                iCurNukeSegmentX, iCurNukeSegmentZ = GetNukeSegmentsFromPosition(tPosition)
                                if not(tiNukeSegmentsConsidered[iCurNukeSegmentX]) then tiNukeSegmentsConsidered[iCurNukeSegmentX] = {} end
                                tiNukeSegmentsConsidered[iCurNukeSegmentX][iCurNukeSegmentZ] = true
                                if bConsideredBestAOETarget then
                                    iPositionsConsideredThisTick = iPositionsConsideredThisTick + 5 --approximation - will likely be more than this
                                else
                                    iPositionsConsideredThisTick = iPositionsConsideredThisTick + 1
                                end

                            end

                            if bDebugMessages == true then LOG(sFunctionRef..': Checking nuke launch locations, is table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]))..'; Time of check='..GetGameTimeSeconds()) end
                            function RefreshRecentlyNukedLocations()
                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]) == false and iMinDelayBetweenNukes > 0 then
                                    local iTimeSinceFired
                                    local iLoopCheck
                                    for iTime, tLocation in M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations] do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iTime='..iTime..'; tLocation='..repru(tLocation)..'; GameTime='..GetGameTimeSeconds()) end
                                        iTimeSinceFired = GetGameTimeSeconds() - iTime

                                        if iTimeSinceFired < iMinDelayBetweenNukes then --Testing with Aeon SML on setons it takes 60s to go from one corner to another roughly
                                            iLoopCheck = 0
                                            while tRecentlyNuked[iTimeSinceFired] do
                                                iTimeSinceFired = iTimeSinceFired - 0.0001
                                                iLoopCheck = iLoopCheck + 1
                                                if iLoopCheck >= 20 then M28Utilities.ErrorHandler('Potential infinite loop with nuke location recording, will stop attempting to record extra recently nuked locations') break end
                                            end
                                            tRecentlyNuked[iTimeSinceFired] = {tLocation[1], tLocation[2], tLocation[3]}
                                        end
                                    end
                                end
                            end

                            RefreshRecentlyNukedLocations()

                            if bDebugMessages == true then LOG(sFunctionRef..': tRecentlyNuked='..repru((tRecentlyNuked or {'nil'}))) end

                            function HaventRecentlyNukedLocation(tLocation )--, bIgnoreIfCoveredBySMD) --bIgnoreIfCoveredBySMD - removed from v46 (previously would set to true if want to ignore the fact that we have recenlty nuked the target if it is covered by SMD (i.e. if there is SMD then we likely want to overwhelm the target hence want to fire multiple nukes at the same location)

                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of recently nuked locations empty='..tostring(M28Utilities.IsTableEmpty(tRecentlyNuked))..'; tLocation='..repru(tLocation)) end
                                if M28Utilities.IsTableEmpty(tRecentlyNuked) then return true
                                else
                                    for iTimeSinceFired, tRecentLocation in tRecentlyNuked do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering tLocation='..repru(tLocation)..'; Distance to tRecentLocation='..M28Utilities.GetDistanceBetweenPositions(tLocation, tRecentLocation)..'; is smd blocking targeet='..tostring(IsSMDBlockingTarget(aiBrain, tLocation, oLauncher:GetPosition(), 180, 0))..'; iTimeSinceFired='..iTimeSinceFired) end
                                        --if iTimeSinceFired <= iMinDelayBetweenNukes then --(incorporated into refreshrecentlynukedlocations)
                                        if M28Utilities.GetDistanceBetweenPositions(tLocation, tRecentLocation) <= 50 then
                                            return false
                                            --[[ Old logic (removed v46 and replaced with iMinDelayBetweenNukes)
                                            if bIgnoreIfCoveredBySMD then
                                                if IsSMDBlockingTarget(aiBrain, tLocation, oLauncher:GetPosition(), 60, 0) then
                                                    return true --we have fired here recently but we want to fire multiple nukes to overwhelm smd
                                                else
                                                    return false --we have fired here recently and there's no smd to overwhelm
                                                end
                                            else
                                                return false --we have fired here recently and dont care about overwhelming smd
                                            end--]]
                                        end
                                        --end
                                    end
                                end
                                return true --we havent fired here recently
                            end

                            --Decide whether to value destroying reclaim
                            local iReclaimFactor
                            if M28Utilities.IsTableEmpty(M28Map.tiVeryHighValueReclaimSegments) == false and not(M28Map.bIsCampaignMap) then
                                iReclaimFactor = 0.4
                            end

                            --First get the best location if just target the start position or locations near here
                            if HaventRecentlyNukedLocation(M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) then--, not(bCheckForSMD)) then
                                iTimeSMDNeedsToHaveBeenBuiltFor = iTimeForSMDToBeConstructed + 190 - (M28Utilities.GetDistanceBetweenPositions( M28Map.GetPrimaryEnemyBaseLocation(aiBrain), oLauncher:GetPosition()) / iMissileSpeed + 10)
                                --GetBestAOETarget(aiBrain, tBaseLocation,                              iAOE, iDamage, bOptionalCheckForSMD, tSMLLocationForSMDCheck, iOptionalTimeSMDNeedsToHaveBeenBuiltFor, iSMDRangeAdjust, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, iOptionalMaxDistanceCheckOptions, iMobileValueOverrideFactorWithin75Percent, iOptionalShieldReductionFactor, iOptionalReclaimFactor)
                                tTarget, iBestTargetValue = M28Logic.GetBestAOETarget(aiBrain, M28Map.GetPrimaryEnemyBaseLocation(aiBrain), iAOE, iDamage, bCheckForSMD,        oLauncher:GetPosition(),    nil,                                    nil,                2,                                  2.5,                    nil,                            nil,                                        nil,                            iReclaimFactor)
                                RecordHaveConsideredNukeLocation(M28Map.GetPrimaryEnemyBaseLocation(aiBrain), true)
                            end

                            --Cycle through other start positions to see if can get a better target, but reduce value of target if we havent scouted it in the last 5 minutes
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering best target for nuke.  If target enemy base then iBestTargetValue='..iBestTargetValue) end
                            local iPlateauOrZero, iLandOrWaterZone
                            local bAbortLoop = false
                            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
                                local tEnemyStartPosition =  M28Map.PlayerStartPoints[oBrain:GetArmyIndex()]
                                if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tEnemyStartPosition)) and M28Utilities.GetDistanceBetweenPositions(tEnemyStartPosition, M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) >= 30 then
                                    --Have we scouted this location recently or do we have radar coverage
                                    local tLZOrWZTeamData
                                    iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tEnemyStartPosition)
                                    if iPlateauOrZero > 0 then
                                        tLZOrWZTeamData  = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
                                    else
                                        --Water zone
                                        tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
                                    end


                                    if bDebugMessages == true then LOG(sFunctionRef..': Cycling through start points, considering brain '..(oBrain.Nickname or 'nil')..' with start point '..repru(tEnemyStartPosition)) end
                                    if GetGameTimeSeconds() - (tLZOrWZTeamData[M28Map.refiTimeLastHadVisual] or -1000) <= 300 or tLZOrWZTeamData[M28Map.refiRadarCoverage] >= 20 then
                                        iCurNukeSegmentX, iCurNukeSegmentZ = GetNukeSegmentsFromPosition(tEnemyStartPosition)
                                        if not(tiNukeSegmentsConsidered[iCurNukeSegmentX][iCurNukeSegmentZ]) then
                                            if HaventRecentlyNukedLocation(tEnemyStartPosition) then --, not(bCheckForSMD)) then
                                                RecordHaveConsideredNukeLocation(tEnemyStartPosition, false)
                                                --GetDamageFromBomb(aiBrain, tBaseLocation,         iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory, iOptionalReclaimFactor)
                                                iCurTargetValue = M28Logic.GetDamageFromBomb(aiBrain, tEnemyStartPosition, iAOE, iDamage,   2,                                  2.5                     , nil,                          nil,                nil,                            nil,                                        false,                  nil,                            true,                       nil,                                    nil,                    iReclaimFactor)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering the start position '..repru( tEnemyStartPosition)..'; value ignroign SMD='..iCurTargetValue) end
                                                if iCurTargetValue > iBestTargetValue then
                                                    iTimeSMDNeedsToHaveBeenBuiltFor = iTimeForSMDToBeConstructed + 190 - (M28Utilities.GetDistanceBetweenPositions( tEnemyStartPosition, oLauncher:GetPosition()) / iMissileSpeed + 10)
                                                    if IsSMDBlockingTarget(aiBrain,  tEnemyStartPosition, oLauncher:GetPosition(), iTimeSMDNeedsToHaveBeenBuiltFor) then
                                                        iCurTargetValue = 4000
                                                        if bDebugMessages == true then LOG(sFunctionRef..': SMD is blocking target so reducing value to 4k. iTimeSMDNeedsToHaveBeenBuiltFor='..iTimeSMDNeedsToHaveBeenBuiltFor) end
                                                    end
                                                    if iCurTargetValue > iBestTargetValue then
                                                        bAlreadyConsideredBestAOETarget = false
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Have a better start position target, dealing damage of '..iCurTargetValue..' vs prev best value of '..iBestTargetValue..'; iTimeSMDNeedsToHaveBeenBuiltFor='..iTimeSMDNeedsToHaveBeenBuiltFor) end
                                                        iBestTargetValue = iCurTargetValue
                                                        tTarget = {tEnemyStartPosition[1], tEnemyStartPosition[2], tEnemyStartPosition[3]}
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            function ConsiderPotentialNukeLocation(tLocationToConsiderNuke, bOverrideCheckForSMD, iOptionalMobileOverrideFactor)
                                iCurNukeSegmentX, iCurNukeSegmentZ = GetNukeSegmentsFromPosition(tLocationToConsiderNuke)
                                if not(tiNukeSegmentsConsidered[iCurNukeSegmentX][iCurNukeSegmentZ]) then
                                    if HaventRecentlyNukedLocation(tLocationToConsiderNuke) then --, not(bOverrideCheckForSMD)) then
                                        RecordHaveConsideredNukeLocation(tLocationToConsiderNuke, false)
                                        if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLocationToConsiderNuke)) then
                                            --GetDamageFromBomb(aiBrain, tBaseLocation,         iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory, iOptionalReclaimFactor)
                                            iCurTargetValue = M28Logic.GetDamageFromBomb(aiBrain, tLocationToConsiderNuke, iAOE, iDamage,   2,                                  2.5,                    nil,                            nil,                nil,                            iOptionalMobileOverrideFactor,                  false,              nil,                            true,                       nil,                                    nil,                    iReclaimFactor)
                                            if bDebugMessages == true then LOG(sFunctionRef..': tLocationToConsiderNuke='..repru(tLocationToConsiderNuke)..'; iCurTargetValue='..iCurTargetValue..'; iPositionsConsideredThisTick='..iPositionsConsideredThisTick) end
                                            --Stop looking if tried >=10 targets and have one that is at least 20k of value
                                            if iCurTargetValue > iBestTargetValue then
                                                iTimeSMDNeedsToHaveBeenBuiltFor = iTimeForSMDToBeConstructed + 190 - (M28Utilities.GetDistanceBetweenPositions( tLocationToConsiderNuke, oLauncher:GetPosition()) / iMissileSpeed + 10)
                                                if bOverrideCheckForSMD and IsSMDBlockingTarget(aiBrain, tLocationToConsiderNuke, oLauncher:GetPosition(), iTimeSMDNeedsToHaveBeenBuiltFor) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': SMD is blocking the unit target '..repru(tLocationToConsiderNuke)..'; will limit damage to 4k; iTimeSMDNeedsToHaveBeenBuiltFor='..iTimeSMDNeedsToHaveBeenBuiltFor) end
                                                    iCurTargetValue = 4000 end
                                                if iCurTargetValue > iBestTargetValue then
                                                    bAlreadyConsideredBestAOETarget = false
                                                    iBestTargetValue = iCurTargetValue
                                                    tTarget = tLocationToConsiderNuke
                                                    if bDebugMessages == true then LOG(sFunctionRef..': New best target with value='..iBestTargetValue..'; iTimeSMDNeedsToHaveBeenBuiltFor='..iTimeSMDNeedsToHaveBeenBuiltFor) end
                                                end
                                            end
                                            --Note: Mass value of mexes is doubled, so 3 T3 mexes would give a value of 27600
                                            if iPositionsConsideredThisTick >= 8 and iBestTargetValue >= iAbortThreshold then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have a target with a decent amount of value and have already tried quite a few units.  iBestTargetValue='..iBestTargetValue..'; iPositionsConsideredThisTick='..iPositionsConsideredThisTick) end
                                                bAbortLoop = true
                                            end
                                        end
                                    end
                                end
                                --Spread out calculations over a number of ticks due to their intesnity
                                if iPositionsConsideredThisTick >= 10 and not(bAbortLoop) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considered '..iPositionsConsideredThisTick..' targets, will wait 1 tick before considering more for performance reasons. iBestTargetValue='..iBestTargetValue) end
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                    WaitTicks(1)
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                                    RefreshRecentlyNukedLocations()
                                    iPositionsConsideredThisTick = 0
                                    iTotalWaitCount = iTotalWaitCount + 1
                                    if not(M28UnitInfo.IsUnitValid(oLauncher)) then
                                        tTarget = nil
                                        bAbortLoop = true
                                    end
                                    --Lower requirements to stop searching over time
                                    if iTotalWaitCount >= 20 then
                                        iAbortThreshold = iAbortThreshold * 0.95
                                        if iTotalWaitCount >= 100 then
                                            iAbortThreshold = math.min(iAbortThreshold * 0.95, 1000)
                                            if iTotalWaitCount >= 150 then bAbortLoop = true end
                                        end
                                        if iBestTargetValue >= iAbortThreshold then bAbortLoop = true end
                                    end
                                end
                            end

                            function ConsiderTableOfPotentialTargets(tEnemyUnitsOfInterest, bOverrideCheckForSMD, iOptionalMobileOverrideFactor)
                                if M28Utilities.IsTableEmpty(tEnemyUnitsOfInterest) == false then
                                    for iUnit, oUnit in tEnemyUnitsOfInterest do
                                        if M28UnitInfo.IsUnitValid(oUnit) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iPositionsConsideredThisTick='..iPositionsConsideredThisTick..'; Have we recently nuked this location='..tostring((HaventRecentlyNukedLocation(oUnit:GetPosition())))) end
                                            ConsiderPotentialNukeLocation(oUnit:GetPosition(), bOverrideCheckForSMD, iOptionalMobileOverrideFactor)
                                            if bAbortLoop then break end
                                        end
                                    end
                                end
                            end

                            --Consider a defensive nuke as well if enemy has land experimentals or battleships that are relatively near a friendly base - treat as higher value than normal where not covered by SMD (e.g. if have yolona then only want defensive nukes if expect the nuke to land)
                            local tEnemyClosestLandAndNavalThreats = {}
                            local iDefensiveThreshold = 350
                            local iBestValueOfDefensiveNuke = 0
                            local iDefensiveNukePlateauAndZone = {}
                            if M28Map.iMapSize <= 512 then iDefensiveThreshold = 260 end
                            local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oLauncher:GetPosition(), true, iTeam)
                            if tLZTeamData then
                                iDefensiveThreshold = math.max(125, math.min(iDefensiveThreshold, M28Utilities.GetDistanceBetweenPositions(oLauncher:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase])) * 0.475)
                            end
                            local iCurUnitPlateauOrZero, iCurUnitZone
                            local toClosestEnemyUntisByPlateauAndZone = {}

                            if bDebugMessages == true then LOG(sFunctionRef..': Considering priority enemy land threats near our base, is table of enemy land experimenatls empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]))) end
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
                                for iUnit, oUnit in  M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
                                    if M28UnitInfo.IsUnitValid(oUnit) then
                                        iCurUnitPlateauOrZero, iCurUnitZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                                        if (iCurUnitZone or 0) > 0 and (iCurUnitPlateauOrZero or -1) >= 0 then
                                            local tUnitLZOrWZData, tUnitLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that is '..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tUnitLZOrWZTeamData[M28Map.reftClosestFriendlyBase])..' dist to the closest friendly base; iDefensiveThreshold='..iDefensiveThreshold) end
                                            if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tUnitLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) <= iDefensiveThreshold then
                                                table.insert(tEnemyClosestLandAndNavalThreats, oUnit)
                                                if not(toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero]) then toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero] = {} end
                                                if not(toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero][iCurUnitZone]) then toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero][iCurUnitZone] = {} end
                                                table.insert(toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero][iCurUnitZone], oUnit)
                                            end
                                        end
                                    end
                                end
                            end
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyBattleships]) == false then
                                for iUnit, oUnit in  M28Team.tTeamData[iTeam][M28Team.reftEnemyBattleships] do
                                    if M28UnitInfo.IsUnitValid(oUnit) then
                                        iCurUnitPlateauOrZero, iCurUnitZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                                        if (iCurUnitZone or 0) > 0 and (iCurUnitPlateauOrZero or -1) >= 0 then
                                            local tUnitLZOrWZData, tUnitLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                            if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tUnitLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) <= iDefensiveThreshold then
                                                table.insert(tEnemyClosestLandAndNavalThreats, oUnit)
                                                if not(toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero]) then toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero] = {} end
                                                if not(toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero][iCurUnitZone]) then toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero][iCurUnitZone] = {} end
                                                table.insert(toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero][iCurUnitZone], oUnit)
                                            end
                                        end
                                    end
                                end
                            end
                            if M28Utilities.IsTableEmpty(tEnemyClosestLandAndNavalThreats) == false then
                                local iMassValueOfThreats = M28UnitInfo.GetMassCostOfUnits(tEnemyClosestLandAndNavalThreats, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': Mass value of nearby threats='..iMassValueOfThreats) end
                                if iMassValueOfThreats * 2 > iBestTargetValue and iMassValueOfThreats > 24000 then
                                    --Go through the actual zones and consider targeting units in here, but always checking for SMD even with yolona
                                    for iPlateauOrZero, tSubtable in toClosestEnemyUntisByPlateauAndZone do
                                        for iZone, tUnits in tSubtable do
                                            if M28UnitInfo.GetMassCostOfUnits(tUnits, true) >= 24000 then
                                                local iBestValuePreCheck = iBestTargetValue
                                                if bDebugMessages == true then LOG(sFunctionRef..': Best target value pre check for experimental land untis in P'..iPlateauOrZero..'Z'..iZone..'='..iBestTargetValue) end
                                                ConsiderTableOfPotentialTargets(tUnits, true, 0.8)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Best target value post check for experimental land untis in P'..iPlateauOrZero..'Z'..iZone..'='..iBestTargetValue) end
                                                if iBestTargetValue > iBestValuePreCheck then
                                                    iBestValueOfDefensiveNuke = iBestTargetValue
                                                    iDefensiveNukePlateauAndZone = {iPlateauOrZero, iZone}
                                                end
                                            end
                                        end
                                    end
                                end
                            end



                            if bDebugMessages == true then LOG(sFunctionRef..': iBestTargetValue for enemy base='..iBestTargetValue..'; if <80k then will consider other targets. tTarget='..repru(tTarget)..'; iBestValueOfDefensiveNuke='..iBestValueOfDefensiveNuke) end
                            if iBestTargetValue < 80000 and (not(oLauncher[M28UnitInfo.refbEasyBrain]) or iBestTargetValue < 30000) then --If have high value location for nearest enemy start then just go with this
                                --Consider high reclaim segments
                                if M28Utilities.IsTableEmpty(M28Map.tiVeryHighValueReclaimSegments) == false then
                                    for iEntry, tSegmentXZ in M28Map.tiVeryHighValueReclaimSegments do
                                        local tSegmentMidpoint = M28Map.GetReclaimLocationFromSegment(tSegmentXZ[1], tSegmentXZ[2])
                                        local tReclaimLZData, tReclaimLZTeamData = M28Map.GetLandOrWaterZoneData(tSegmentMidpoint, true, iTeam)
                                        if tReclaimLZTeamData[M28Map.refiModDistancePercent] > 0.6 then --If changing 0.6 threshold also update getdamagefrombomb
                                            ConsiderPotentialNukeLocation(tSegmentMidpoint, bCheckForSMD)
                                            if bAbortLoop then break end
                                        end
                                    end
                                end



                                for iRef, iCategory in tEnemyCategoriesOfInterest do
                                    ConsiderTableOfPotentialTargets(aiBrain:GetUnitsAroundPoint(iCategory, oLauncher:GetPosition(), iMaxRange, 'Enemy'), bCheckForSMD)

                                end
                                if iBestTargetValue > iBestValueOfDefensiveNuke then
                                    --GetBestAOETarget(aiBrain, tBaseLocation, iAOE, iDamage, bOptionalCheckForSMD, tSMLLocationForSMDCheck, iOptionalTimeSMDNeedsToHaveBeenBuiltFor, iSMDRangeAdjust, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, iOptionalMaxDistanceCheckOptions, iMobileValueOverrideFactorWithin75Percent, iOptionalShieldReductionFactor, iOptionalReclaimFactor)

                                    if tTarget then
                                        local tOldTarget = {tTarget[1], tTarget[2], tTarget[3]}
                                        local iOldTargetValue = iBestTargetValue
                                        if bDebugMessages == true then
                                            local iTargetPlateauOrZero, iTargetZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tTarget)
                                            LOG(sFunctionRef..': Have a best target, tTarget before getting best aoe target='..repru(tTarget)..'; iTargetPlateauOrZero='..(iTargetPlateauOrZero or 'nil')..'; iTargetZone='..(iTargetZone or 'nil'))
                                        end
                                        --function GetBestAOETarget(aiBrain, tBaseLocation, iAOE, iDamage, bOptionalCheckForSMD, tSMLLocationForSMDCheck, iOptionalTimeSMDNeedsToHaveBeenBuiltFor, iSMDRangeAdjust, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, iOptionalMaxDistanceCheckOptions, iMobileValueOverrideFactorWithin75Percent, iOptionalShieldReductionFactor, iOptionalReclaimFactor)
                                        tTarget, iBestTargetValue = M28Logic.GetBestAOETarget(aiBrain, tTarget,         iAOE, iDamage, bCheckForSMD,        oLauncher:GetPosition(), nil,                                       nil,                2,                                      2.5,                    nil,                            nil,                                        nil,                            iReclaimFactor, true)
                                        --Redundancy for cases where best AOE target actually gives a worse outcome (hopefully ahve fixed issue in getbestaoe target to avoid this, so below is to be safe
                                        if bDebugMessages == true then LOG(sFunctionRef..': iBestTargetValue after getting best aoe target='..iBestTargetValue..'; iOldTargetValue='..iOldTargetValue) end
                                        if iBestTargetValue < iOldTargetValue then
                                            --Redundancy - make sure are comparing like with like
                                            local iRevisedTargetSimpleValue = M28Logic.GetDamageFromBomb(aiBrain, tTarget, iAOE, iDamage,       nil,                                nil,                true,                           nil,                nil,                            nil,                                        false,              nil,                            true,                               nil,                                nil,                    nil)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Revised target simple value='..iRevisedTargetSimpleValue..'; iBestTargetValue='..iBestTargetValue) end
                                            if iRevisedTargetSimpleValue < iBestTargetValue then
                                                tTarget = {tOldTarget[1], tOldTarget[2], tOldTarget[3]}
                                                iBestTargetValue = iOldTargetValue
                                                if bDebugMessages == true then LOG(sFunctionRef..': have switched to old target') end
                                            else
                                                --Increase old value target (so more likely to fire)
                                                iBestTargetValue = iOldTargetValue
                                            end
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': iBestTargetValue after getting best location='..iBestTargetValue..'; Best location for this target='..repru(tTarget)) end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': If value is <14k then will clear target unless have yolona; iBestTargetValue='..iBestTargetValue..'; tTarget='..repru(tTarget or {'nil'})) end
                            if iBestTargetValue < 20000 then --Mex is 4.6k base, with a 1.75 factor is 8050; with mass storage would be 9450; therefore if want to hit 3+ mex equivalents with a nuke, min value should be at least 19k (just over 2 capped T3 mexes)
                                if iBestTargetValue < 2000 or (not(EntityCategoryContains(categories.EXPERIMENTAL, oLauncher.UnitId)) and (iBestTargetValue <= 15000 or not(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]))) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': CLearing target as not valuable enough') end
                                    tTarget = nil
                                end
                            end --Increased vs M27 as will only apuse if no target


                            function ChangeTargetToClosestUnitToLauncher(tUnitsToConsider, iOptionalLeadingDistanceBaseAdjust)
                                local iClosestEnemyDist = 100000
                                local oClosestEnemyUnit
                                local iCurEnemyDist
                                local iBaseLeadingDistance = iOptionalLeadingDistanceBaseAdjust or iAOE * 0.7
                                for iUnit, oUnit in tUnitsToConsider do
                                    iCurEnemyDist = M28Utilities.GetDistanceBetweenPositions(oLauncher:GetPosition(), oUnit:GetPosition())
                                    if iCurEnemyDist < iClosestEnemyDist then
                                        iClosestEnemyDist = iCurEnemyDist
                                        oClosestEnemyUnit = oUnit
                                    end
                                end
                                if oClosestEnemyUnit then
                                    --Base target is this unit
                                    local tPotentialAltTarget = oClosestEnemyUnit:GetPosition()
                                    --Ajdust for unit facing direction if it is moving
                                    local iUnitFacingAngle = M28UnitInfo.GetUnitFacingAngle(oClosestEnemyUnit)
                                    if oClosestEnemyUnit:IsUnitState('Moving') then
                                        tPotentialAltTarget = M28Utilities.MoveInDirection(oClosestEnemyUnit:GetPosition(), M28UnitInfo.GetUnitFacingAngle(oClosestEnemyUnit), iBaseLeadingDistance, true, false, true)
                                    end
                                    --Check the value of this isn't negative (due to friendly fire)
                                    --GetDamageFromBomb(aiBrain, tBaseLocation,     iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory, iOptionalReclaimFactor)
                                    if M28Logic.GetDamageFromBomb(aiBrain, tPotentialAltTarget, iAOE, iDamage,   2,                                  2.5,                    nil,                            nil,                nil,                            0.6,                                       nil,                    nil,                            true,                           nil,                                nil,                    iReclaimFactor) > 0 then
                                        tTarget = tPotentialAltTarget
                                        --Adjust the target further if it is far away
                                        local iCurDist = M28Utilities.GetDistanceBetweenPositions(tTarget, oLauncher:GetPosition())
                                        if iCurDist >= 300 then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Target is far away so will adjust further, tTarget pre adjust='..repru(tTarget)) end
                                            tTarget = M28Utilities.MoveInDirection(tTarget, iUnitFacingAngle, math.min(iBaseLeadingDistance, (iCurDist - 300) / 30), true, false, true)
                                            if bDebugMessages == true then LOG(sFunctionRef..': tTarget post adjust='..repru(tTarget)) end
                                        end
                                    end

                                    if bDebugMessages == true then LOG(sFunctionRef..': tPotentialAltTarget='..repru(tPotentialAltTarget)..'; tTarget after update='..repru(tTarget)..' based on oClosestEnemyUnit='..oClosestEnemyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyUnit)..' at position '..repru(oClosestEnemyUnit:GetPosition())..' with unit state='..M28UnitInfo.GetUnitState(oClosestEnemyUnit)..' and facing angle='..M28UnitInfo.GetUnitFacingAngle(oClosestEnemyUnit)..'; iAOE='..iAOE..'; Damage of bomb at potential target='..M28Logic.GetDamageFromBomb(aiBrain, tPotentialAltTarget, iAOE, iDamage,   2,                                  2.5,                    nil,                            nil,                nil,                            0.6)) end
                                end
                            end

                            if tTarget and iBestTargetValue <= iBestValueOfDefensiveNuke and M28Utilities.IsTableEmpty(toClosestEnemyUntisByPlateauAndZone) == false and M28Utilities.IsTableEmpty(toClosestEnemyUntisByPlateauAndZone[toClosestEnemyUntisByPlateauAndZone[1]][toClosestEnemyUntisByPlateauAndZone[2]]) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will launch a defensive nuke, positio before adjust='..repru(tTarget)) end
                                --Doing a defensive nuke so target the enemy unit nearest us, and adjust slightly for its facing direction
                                ChangeTargetToClosestUnitToLauncher(toClosestEnemyUntisByPlateauAndZone[toClosestEnemyUntisByPlateauAndZone[1]][toClosestEnemyUntisByPlateauAndZone[2]])
                            elseif M28Utilities.IsTableEmpty(tTarget) == false then
                                --Still check if significant threat is made of mobile units

                                local tTargetZoneData, tTargetZoneTeamData = M28Map.GetLandOrWaterZoneData(tTarget, true, iTeam)
                                if bDebugMessages == true then LOG(sFunctionRef..': Arent firing as a defensvie unit, checking structure value in zone, tTargetZoneTeamData[M28Map.subrefThreatEnemyStructureTotalMass]='..(tTargetZoneTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 'nil')) end
                                if (tTargetZoneTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) <  iBestTargetValue * 0.5 then
                                    --Are there enemy experimentals or battleships in this zone?
                                    local tEnemyExperimentalsAndBattleships = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryNavalSurface * categories.BATTLESHIP,tTargetZoneTeamData[M28Map.subrefTEnemyUnits])
                                    M28Conditions.IsTableOfUnitsStillValid(tEnemyExperimentalsAndBattleships)
                                    if M28Utilities.IsTableEmpty(tEnemyExperimentalsAndBattleships) then
                                        tEnemyExperimentalsAndBattleships = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryNavalSurface * categories.BATTLESHIP, tTarget, iAOE, 'Enemy')
                                        if bDebugMessages == true then LOG(sFunctionRef..': No enemy experimentals in the zone being targeting, is units around point empty='..tostring(M28Utilities.IsTableEmpty(tEnemyExperimentalsAndBattleships))) end
                                    end
                                    if M28Utilities.IsTableEmpty( tEnemyExperimentalsAndBattleships) == false then
                                        local bHaveMobileUnitsAndNoUnderConstruction = false
                                        local bHaveAttackingOrPatrollingUnits = false

                                        for iUnit, oUnit in tEnemyExperimentalsAndBattleships do
                                            if bDebugMessages == true then LOG(sFunctionRef..': Checking enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; Dead='..tostring(oUnit.Dead or false)) end
                                            if oUnit:GetFractionComplete() < 1 and oUnit:GetFractionComplete() >= 0.05 then
                                                bHaveMobileUnitsAndNoUnderConstruction = false
                                                break
                                            else
                                                if oUnit:IsUnitState('Moving') then
                                                    bHaveMobileUnitsAndNoUnderConstruction = true
                                                elseif oUnit:IsUnitState('Attacking') or oUnit:IsUnitState('Patrolling') then
                                                    bHaveAttackingOrPatrollingUnits = true
                                                end
                                            end
                                        end
                                        local iDistanceAdjust
                                        if bHaveMobileUnitsAndNoUnderConstruction then iDistanceAdjust = iAOE * 0.75
                                        elseif bHaveAttackingOrPatrollingUnits then iDistanceAdjust = iAOE * 0.45
                                        end
                                        if iDistanceAdjust then
                                            if bDebugMessages == true then LOG(sFunctionRef..': tTarget before updating to nearest experimental or battleship='..repru(tTarget)) end
                                            ChangeTargetToClosestUnitToLauncher(tEnemyExperimentalsAndBattleships)
                                            if bDebugMessages == true then LOG(sFunctionRef..': tTarget after updating to nearest experimental or battleship='..repru(tTarget)) end
                                        end
                                    end
                                end
                            end
                            --Yolona target SMD that will stop us, if there are any, instead of our actual target, so we dont risk trying to take on loads of SMD in one go
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Checking if we are a yolona in which case we want to target any blocking SMD first, tTarget='..repru(tTarget)..'; bCheckForSMD='..tostring(bCheckForSMD)..'; Yolona='..tostring(EntityCategoryContains(categories.EXPERIMENTAL, oLauncher.UnitId))..'; Is table of enemy SMD empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]))..'; If enemy has more than 1 SMD will consider targeting SMD instead of the best target for the missile')
                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) == false then LOG(sFunctionRef..': Number of enemy SMD='..table.getn(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD])) end
                            end
                            if tTarget and not(bCheckForSMD) and EntityCategoryContains(categories.EXPERIMENTAL, oLauncher.UnitId) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) == false then
                                --WOrk out which SMD are intercepting our missile
                                local tSMDBlockingTarget = IsSMDBlockingTarget(aiBrain, tTarget, oLauncher:GetPosition(), 60, 0, true)
                                if bDebugMessages == true then
                                    LOG(sFunctionRef..': Is table of enemy SMD blocking target empty='..tostring(M28Utilities.IsTableEmpty(tSMDBlockingTarget)))
                                    if M28Utilities.IsTableEmpty(tSMDBlockingTarget) == false then LOG(sFunctionRef..': Number of SMD blocking target='..table.getn(tSMDBlockingTarget)) end
                                end
                                --Only target down SMD if we have 2+ SMD or a loaded SMD blocking our desired target (otherwise it may be better to just ignore)
                                if M28Utilities.IsTableEmpty(tSMDBlockingTarget) == false then
                                    local bLotsOfSMDOrLoaded = false
                                    if table.getn(tSMDBlockingTarget) >= 4 then
                                        bLotsOfSMDOrLoaded = true
                                    else
                                        local iSMDCount = 0
                                        for iBlockingSMD, oBlockingSMD in tSMDBlockingTarget do

                                            if oBlockingSMD:GetFractionComplete() == 1 then
                                                iSMDCount = iSMDCount + 1
                                                if oBlockingSMD:GetTacticalSiloAmmoCount() > 0 then
                                                    bLotsOfSMDOrLoaded = true
                                                end
                                            end
                                        end
                                        if not(bLotsOfSMDOrLoaded) and iSMDCount >= 2 then
                                            bLotsOfSMDOrLoaded = true
                                        end
                                    end
                                    if bLotsOfSMDOrLoaded then
                                        bHaveBlockingSMD = true
                                        local tAltTarget = GetBestAOETargetForSpecifiedBuildings(aiBrain, iTeam, oLauncher:GetPosition(), tSMDBlockingTarget, iAOE, iDamage)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Yolona target will be intercepted by SMD, want to take out the nearest blocking SMD first, tTarget='..repru(tTarget)..'; tAltTarget after facotirng in blockgin SMD='..repru(tAltTarget)) end
                                        if tAltTarget then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will now draw ttarget and talttarget, tTarget will be in blue, tAltTarget will be in gold')
                                                M28Utilities.DrawLocation(tTarget)
                                                M28Utilities.DrawLocation(tAltTarget, 4)
                                            end

                                            tTarget = tAltTarget
                                        end
                                    end
                                end
                            elseif not(tTarget) and EntityCategoryContains(categories.EXPERIMENTAL, oLauncher.UnitId) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) == false then
                                local tPotentialSMDTargets = {}
                                for iRecordedSMD, oRecordedSMD in M28Team.tTeamData[iTeam][M28Team.reftEnemySMD] do
                                    if M28UnitInfo.IsUnitValid(oRecordedSMD) and oRecordedSMD:GetFractionComplete() >= 0.9 then
                                        table.insert(tPotentialSMDTargets, oRecordedSMD)
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Is tPotentialSMDTargets empty='..tostring(M28Utilities.IsTableEmpty(tPotentialSMDTargets))) end
                                if M28Utilities.IsTableEmpty(tPotentialSMDTargets) == false then
                                    if table.getn(tPotentialSMDTargets) == 1 then
                                        tTarget = tPotentialSMDTargets[1]:GetPosition()
                                    else
                                        local bHaveNonRecentTarget = false
                                        for iRecordedSMD, oRecordedSMD in tPotentialSMDTargets do
                                            if not(HaventRecentlyNukedLocation(oRecordedSMD:GetPosition())) then
                                                tTarget = oRecordedSMD:GetPosition()
                                                bHaveNonRecentTarget = true
                                                break
                                            end
                                        end
                                        if not(bHaveNonRecentTarget) and not(tTarget) then tTarget = tPotentialSMDTargets[1]:GetPosition() end
                                    end
                                end
                            end
                        end

                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to launch at time '..GetGameTimeSeconds()..', tTarget='..repru(tTarget)) end
                        if oLauncher.Dead then
                            if bDebugMessages == true then LOG(sFunctionRef..': Launcher is dead now') end
                        elseif tTarget then
                            --Launch missile
                            if bDebugMessages == true then LOG(sFunctionRef..': Will launch missile at tTarget='..repru(tTarget)..'; Cur time='..GetGameTimeSeconds()) end
                            if bTML then
                                --Adjust target it outside our range but inside our AOE
                                if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oLauncher.UnitId) then --redundancy to make sure not dealing with mobile unit
                                    local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(tTarget, oLauncher:GetPosition())
                                    if iDistToTarget > oLauncher[M28UnitInfo.refiManualRange] then
                                        if iDistToTarget - oLauncher[M28UnitInfo.refiManualRange] > oLauncher[M28UnitInfo.refiIndirectAOE] then
                                            M28Utilities.ErrorHandler('Have a TML launcher with a target outside its range+manual range')
                                        else
                                            tTarget = M28Utilities.MoveInDirection(oLauncher:GetPosition(), M28Utilities.GetAngleFromAToB(oLauncher:GetPosition(), tTarget), oLauncher[M28UnitInfo.refiManualRange] - 0.01)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Updating target so we can hit the actual target with our aoe, tTarget='..repru(tTarget)..'; iDistToTarget pre this adjust='..iDistToTarget) end
                                        end
                                    end
                                end
                                M28Orders.IssueTrackedTMLMissileLaunch(oLauncher, tTarget, 0.25, false, 'TMLFire', true)
                                if M28UnitInfo.GetMissileCount(oLauncher) <= 1 then
                                    --oLauncher:SetAutoMode(true)
                                    M28UnitInfo.SetUnitMissileAutoBuildStatus(oLauncher, true)
                                end
                                --oLauncher:SetPaused(false)
                                M28UnitInfo.PauseOrUnpauseUnitWithoutTracking(oLauncher, false)
                                if bDebugMessages == true then
                                    local tExpectedMissileVertical = M28Utilities.MoveInDirection(oLauncher:GetPosition(), M28Utilities.GetAngleFromAToB(oLauncher:GetPosition(), tTarget), 31, true)
                                    tExpectedMissileVertical[2] = tExpectedMissileVertical[2] + 60 --Doing testing, it actually only goes up by 50, but I think it travels in an arc from here to the target, as in a test scenario doing at less than +60 meant it thought it would hit a cliff when it didnt
                                    local bShotBlocked = M28Logic.IsLineBlocked(aiBrain, tExpectedMissileVertical, tTarget, iAOE, false)
                                    LOG(sFunctionRef..': Just launched tactical missile at tTarget='..repru(tTarget)..'; oLauncher position='..repru(oLauncher:GetPosition())..'; dist to target='..M28Utilities.GetDistanceBetweenPositions(oLauncher:GetPosition(), tTarget)..'; launcher range='..oLauncher[M28UnitInfo.refiManualRange]..'; bShotBlocked='..tostring(bShotBlocked))
                                    --[[local iColour = 1
                                    if bShotBlocked then iColour = 2 end
                                    M28Utilities.DrawLocation(tTarget, nil, iColour)--]] --drawing locations will desync a replay, so only want to manually enable this debugging where we need it
                                end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Have a nuke target, tTarget='..repru(tTarget)..'; have we not recently nuked this location='..tostring(HaventRecentlyNukedLocation(tTarget))..'; iTotalWaitCount='..iTotalWaitCount) end
                                if iTotalWaitCount >= 1 then
                                    if not(HaventRecentlyNukedLocation(tTarget)) then --, true, iTotalWaitCount * 0.1 + 2)) then
                                        --Presumably the target we chose as the best target is no longer appropriate because another nuke has just nuked it
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will wait 1 second then try getting a target again since we are about to nuke a location that we just nuked') end
                                        oLauncher[refbActiveMissileChecker] = false
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        WaitSeconds(1)
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                                        tTarget = nil
                                        --LOG('Forked consideration of launching missile 1')
                                        ForkThread(ConsiderLaunchingMissile, oLauncher, oOptionalWeapon)
                                    end
                                end
                                if tTarget then
                                    if bDebugMessages == true then
                                        M28Utilities.DrawCircleAtTarget({ tTarget[1], tTarget[2], tTarget[3] }, 2, 200, iAOE)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Giving order to fire nuke at tTarget='..repru(tTarget)..'; Launcher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..' owend by brain '..oLauncher:GetAIBrain().Nickname..'; iBestTargetValue='..(iBestTargetValue or 'nil')..'; Is SMD blocking target='..tostring(IsSMDBlockingTarget(aiBrain, tTarget, oLauncher:GetPosition(), 60, 0))..'; Time='..GetGameTimeSeconds()) end
                                    end
                                    M28Orders.IssueTrackedNukeMissileLaunch(oLauncher, tTarget, 2, false, 'Nuke', false)
                                    --[[M28Orders.IssueTrackedClearCommands(oLauncher)
                                    IssueNuke({oLauncher}, tTarget)
                                    oLauncher[reftActiveNukeTarget] = {tTarget[1], tTarget[2], tTarget[3]}
                                    --Unpause incase we paused previously
                                    if oLauncher[refbPausedAsNoTargets] then
                                        oLauncher[refbPausedAsNoTargets] = false
                                        if M28UnitInfo.GetMissileCount(oLauncher) <= 1 then
                                            oLauncher:SetAutoMode(true)
                                        end
                                        oLauncher:SetPaused(false)
                                    end
                                    if not(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]) then M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations] = {} end

                                    M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations][math.floor(GetGameTimeSeconds())] = tTarget--]]
                                    if not(bHaveBlockingSMD) then bHaveBlockingSMD = IsSMDBlockingTarget(aiBrain, tTarget, oLauncher:GetPosition(), 60, 0) end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Launching nuke at tTarget='..repru(tTarget)..'; bHaveBlockingSMD='..tostring(bHaveBlockingSMD)..'; M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]='..repru(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations])..'; Time of game='..GetGameTimeSeconds()) end
                                    --Send a voice taunt if havent in last 10m and we expect to do significant damage
                                    if not(bHaveBlockingSMD) and iBestTargetValue >= (25000 + 5000 * M28Chat.iNukeGloatingMessagesSent) then
                                        if M28Orders.bDontConsiderCombinedArmy or oLauncher.M28Active then
                                            M28Chat.iNukeGloatingMessagesSent = M28Chat.iNukeGloatingMessagesSent + 1
                                            ForkThread(M28Chat.SendGloatingMessage, aiBrain, 20, 600)
                                        end
                                    elseif bHaveBlockingSMD then
                                        --Record that our last nuke target had a blocking SMD (so we allow any delay between nuke missiles)
                                        M28Team.tTeamData[iTeam][M28Team.refbSMDBlockingLastNukeTarget] = true
                                    end
                                end
                            end
                        else
                            --Disable autobuild and pause
                            if not(oLauncher[refbPausedAsNoTargets]) and not(EntityCategoryContains(categories.EXPERIMENTAL, oLauncher.UnitId)) then
                                --Dont pause if we have loads of resources
                                if M28Conditions.HaveLowPower(iTeam) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 400 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.8 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 30 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 25 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.99))) then
                                    oLauncher[refbPausedAsNoTargets] = true
                                    --oLauncher:SetAutoMode(false)
                                    --oLauncher:SetPaused(true)
                                    M28UnitInfo.SetUnitMissileAutoBuildStatus(oLauncher, false)
                                    M28UnitInfo.PauseOrUnpauseUnitWithoutTracking(oLauncher, true)
                                    if oLauncher.UnitId == 'xsb2401' then M28Utilities.ErrorHandler('Pausing Yolona') end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Pausing unit '..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..' as have no targets') end
                                end
                            end
                            oLauncher[refbActiveMissileChecker] = false
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitSeconds(iSecondsToWaitIfNoTarget)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                            if bDebugMessages == true then LOG(sFunctionRef..': Have waited '..iSecondsToWaitIfNoTarget..' seconds, will now reconsider launching the missile, time='..GetGameTimeSeconds()) end
                            --LOG('Forked consideration of launching missile 2')
                            ForkThread(ConsiderLaunchingMissile, oLauncher, oOptionalWeapon)
                        end
                    end
                    --Already have an else error handler above so dont need below
                    --else M28Utilities.ErrorHandler('Unrecognised launcher type, UnitID='..(oLauncher.UnitId or 'nil')..'; wont consider launching a missile')
                end
                oLauncher[refbActiveMissileChecker] = false
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function IsSMDBlockingTarget(aiBrain, tTarget, tSMLPosition, iIgnoreSMDCreatedThisManySecondsAgo, iSMDRangeAdjust, bOptionalReturnTableOfBlockingSMD)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsSMDBlockingTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bEnemySMDInRange = false
    local iSMLToTarget = M28Utilities.GetDistanceBetweenPositions(tTarget, tSMLPosition)
    local iAngleSMLToTarget = M28Utilities.GetAngleFromAToB(tSMLPosition, tTarget)
    local iTargetToSMD

    local iSMLToSMD
    local iSMDRange
    local iAngleToSMD
    local bSMDInRangeOfMissile

    if bDebugMessages == true then LOG(sFunctionRef..': Considering tTarget='..repru(tTarget)..'; iIgnoreSMDCreatedThisManySecondsAgo='..(iIgnoreSMDCreatedThisManySecondsAgo or 1)..'; Current game time='..GetGameTimeSeconds()) end
    local iTeam = aiBrain.M28Team
    local tBlockingSMD

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) == false then
        local iBuildRateMod = 1
        for iSMD, oSMD in M28Team.tTeamData[iTeam][M28Team.reftEnemySMD] do
            if M28UnitInfo.IsUnitValid(oSMD) then
                --Update SMD time to complete tracker
                if oSMD:GetFractionComplete() < 1 then
                    oSMD[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds() - iTimeForSMDToBeConstructed * oSMD:GetFractionComplete()
                    if bDebugMessages == true then LOG(sFunctionRef..': Just updated oSMD as it is constructed now,  oSMD='..oSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSMD)..'; Owner='..oSMD:GetAIBrain().Nickname..'; Time='..GetGameTimeSeconds()) end
                end
                if iIgnoreSMDCreatedThisManySecondsAgo then iBuildRateMod = (oSMD:GetAIBrain()[M28Economy.refiBrainBuildRateMultiplier] or 1) end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering oSMD='..oSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSMD)..'; Cur time less time of last check or -10='..GetGameTimeSeconds() - (oSMD[M28UnitInfo.refiTimeOfLastCheck] or (GetGameTimeSeconds() - 10))..'; iIgnoreSMDCreatedThisManySecondsAgo='..(iIgnoreSMDCreatedThisManySecondsAgo or 'nil')..'; iBuildRateMod='..iBuildRateMod..'; oSMD[M28UnitInfo.refiTimeOfLastCheck]='..(oSMD[M28UnitInfo.refiTimeOfLastCheck] or 'nil')) end
                if GetGameTimeSeconds() - (oSMD[M28UnitInfo.refiTimeOfLastCheck] or (GetGameTimeSeconds() - 10)) > (iIgnoreSMDCreatedThisManySecondsAgo or 0) / iBuildRateMod then

                    bSMDInRangeOfMissile = false
                    iSMDRange = (oSMD:GetBlueprint().Weapon[1].MaxRadius or 90) + 1 + (iSMDRangeAdjust or 0)
                    iTargetToSMD = M28Utilities.GetDistanceBetweenPositions(tTarget, oSMD:GetPosition())

                    iSMLToSMD = M28Utilities.GetDistanceBetweenPositions(oSMD:GetPosition(), tSMLPosition)
                    iAngleToSMD = M28Utilities.GetAngleFromAToB(tSMLPosition, oSMD:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': oSMD='..oSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSMD)..'; iTargetToSMD='..iTargetToSMD..'; iSMLToSMD='..iSMLToSMD..'; iSMLToTarget='..iSMLToTarget..'; iSMDRange='..iSMDRange..'; oSMD[M27UnitInfo.refiTimeOfLastCheck]='..(oSMD[M28UnitInfo.refiTimeOfLastCheck] or 'nil')..'; Distance from target to oSMD='..M28Utilities.GetDistanceBetweenPositions(tTarget, oSMD:GetPosition())..'; iSMDRange='..iSMDRange..'; iAngleToSMD='..iAngleToSMD..'; iAngleSMLToTarget='..iAngleSMLToTarget..'; SMD position='..repru(oSMD:GetPosition())..'; tSMLPosition='..repru(tSMLPosition)..'; TargetPos='..repru(tTarget)..'; iAngleFromAToB - iAngleFromAToC='..(iAngleSMLToTarget - iAngleToSMD)..'; ConvertAngleToRadians(iAngleFromAToB - iAngleFromAToC)='..M28Utilities.ConvertAngleToRadians(iAngleSMLToTarget - iAngleToSMD)..'; math.tan(math.abs(ConvertAngleToRadians(iAngleFromAToB - iAngleFromAToC)))='..math.tan(math.abs(M28Utilities.ConvertAngleToRadians(iAngleSMLToTarget - iAngleToSMD)))..'; iDistFromAToC='..iSMLToSMD..'; Tan result times this distance='..iSMLToSMD*math.tan(math.abs(M28Utilities.ConvertAngleToRadians(iAngleSMLToTarget - iAngleToSMD)))) end

                    bSMDInRangeOfMissile = M28Utilities.IsLineFromAToBInRangeOfCircleAtC(iSMLToTarget, iSMLToSMD, iTargetToSMD, iAngleSMLToTarget, iAngleToSMD, iSMDRange)

                    if bSMDInRangeOfMissile then
                        if bDebugMessages == true then LOG(sFunctionRef..': SMD is in range and was built a while ago') end
                        bEnemySMDInRange = true
                        if not(bOptionalReturnTableOfBlockingSMD) then
                            break
                        else
                            if not(tBlockingSMD) then tBlockingSMD = {} end
                            table.insert(tBlockingSMD, oSMD)
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding SMD to table of blocking SMD') end
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': SMD is not blocking the target')
                    end

                elseif bDebugMessages == true then LOG(sFunctionRef..': SMD was only recently built, time we think the SMD was active='..GetGameTimeSeconds() - (oSMD[M28UnitInfo.refiTimeOfLastCheck] or (GetGameTimeSeconds() - 10)))
                end
            end
        end
    elseif bDebugMessages == true then LOG(sFunctionRef..': No enemy SMD detected')
    end
    if bDebugMessages == true then LOG(sFunctionRef..': bEnemySMDInRange='..tostring(bEnemySMDInRange)..'; Is table of blocking SMD empty='..tostring(M28Utilities.IsTableEmpty(tBlockingSMD))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bOptionalReturnTableOfBlockingSMD then
        return tBlockingSMD
    else
        return bEnemySMDInRange
    end
end

function GetHighestNukeTargetValue(tLZOrWZData, tLZOrWZTeamData, iTeam)
    --Refresh list if havent calcualted before or SMD has been refreshed; returns highest value target
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        if aiBrain then
            local iBestValue = 0
            local iCurValue

            function GetZoneValue(iEnemyStructureMass, iEnemyCombatThreat)
                return iEnemyStructureMass + iEnemyCombatThreat * 0.25
            end
            local tSMLPosition = tLZOrWZData[M28Map.subrefMidpoint]
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones]) or M28Team.tTeamData[iTeam][M28Team.refbEnemySMDDiedSinceLastNukeCheck] then
                --Do full calculation
                tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones] = {}
                --Make sure we have recorded pathing in a straight line for this zone (will only run if table is empty)
                M28Air.RecordOtherLandAndWaterZonesByDistance(tLZOrWZData)
                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) then
                    M28Utilities.ErrorHandler('No other zones found')
                else
                    for iEntry, tSubtable in tLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                        local tAltLZOrWZData
                        local tAltLZOrWZTeamData
                        local sMidpointRef
                        local sCombatThreatRef
                        local iCurPlateauOrPond
                        local iCurLZOrWZRef = tSubtable[M28Map.subrefiLandOrWaterZoneRef]
                        if tSubtable[M28Map.subrefbIsWaterZone] then
                            sMidpointRef = M28Map.subrefMidpoint
                            sCombatThreatRef = M28Map.subrefTThreatEnemyCombatTotal
                            tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurLZOrWZRef]][M28Map.subrefPondWaterZones][iCurLZOrWZRef]
                            iCurPlateauOrPond = 0
                            tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                        else
                            sMidpointRef = M28Map.subrefMidpoint
                            sCombatThreatRef = M28Map.subrefTThreatEnemyCombatTotal
                            iCurPlateauOrPond = tSubtable[M28Map.subrefiPlateauOrPond]
                            tAltLZOrWZData = M28Map.tAllPlateaus[iCurPlateauOrPond][M28Map.subrefPlateauLandZones][iCurLZOrWZRef]
                            tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                        end
                        if not(IsSMDBlockingTarget(aiBrain, tAltLZOrWZData[sMidpointRef], tSMLPosition, 0, 0)) then
                            --Have a valid target
                            table.insert(tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones], {iCurPlateauOrPond, iCurLZOrWZRef })
                            iCurValue = GetZoneValue(tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass], tAltLZOrWZTeamData[sCombatThreatRef])
                            if iCurValue > iBestValue then
                                iBestValue = iCurValue
                            end
                        end
                    end
                end
            elseif M28Team.tTeamData[iTeam][M28Team.refbEnemySMDBuiltSinceLastNukeCheck] then
                --Check existing values for if still valid
                local iExistingEntries = table.getn(tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones])
                for iEntry = iExistingEntries, 1, -1 do
                    local tAltLZOrWZData
                    local tAltLZOrWZTeamData
                    local sMidpointRef
                    local sCombatThreatRef
                    local iCurPlateauOrPond = tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones][iEntry][1]
                    local iCurLZOrWZRef = tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones][iEntry][2]

                    if iCurPlateauOrPond == 0 then
                        sMidpointRef = M28Map.subrefMidpoint
                        sCombatThreatRef = M28Map.subrefTThreatEnemyCombatTotal
                        tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurLZOrWZRef]][M28Map.subrefPondWaterZones][iCurLZOrWZRef]
                        tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                    else
                        sMidpointRef = M28Map.subrefMidpoint
                        sCombatThreatRef = M28Map.subrefTThreatEnemyCombatTotal
                        tAltLZOrWZData = M28Map.tAllPlateaus[iCurPlateauOrPond][M28Map.subrefPlateauLandZones][iCurLZOrWZRef]
                        tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                    end
                    if IsSMDBlockingTarget(aiBrain, tAltLZOrWZData[sMidpointRef], tSMLPosition, 0, 0) then
                        --No longer have a valid target
                        table.remove(tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones], iEntry)
                    else
                        iCurValue = GetZoneValue(tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass], tAltLZOrWZTeamData[sCombatThreatRef])
                        if iCurValue > iBestValue then
                            iBestValue = iCurValue
                        end
                    end
                end
            end
            return iBestValue
        else
            M28Utilities.ErrorHandler('No alive M28 brain')
            return 0
        end
    else
        M28Utilities.ErrorHandler('No active M28 brains')
        return 0
    end
end

function RecheckForArtiTargetSoon(oArti)
    WaitSeconds(10)
    if M28UnitInfo.IsUnitValid(oArti) then
        M28UnitInfo.EnableUnitWeapon(oArti)
        GetT3ArtiTarget(oArti, false)
    end
end

function DontChangeCurrentScathisTarget(oArti)
    --returns true if we want to retain the current scathis target
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DontChangeCurrentScathisTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tLastOrder = oArti[M28Orders.reftiLastOrders][oArti[M28Orders.refiOrderCount]]
    local oCurTarget = tLastOrder[M28Orders.subrefoOrderUnitTarget]
    if M28UnitInfo.IsUnitValid(oCurTarget) then
        local iLowerTimeThreshold = 120
        local iUpperTimeThreshold = 300
        local iTimeSinceLastTargetAssessment = GetGameTimeSeconds() - (oArti[refiTimeLastGotBestArtiTarget] or -iUpperTimeThreshold)
        if bDebugMessages == true then LOG(sFunctionRef..': iTimeSinceLastTargetAssessment='..iTimeSinceLastTargetAssessment..'; oArti[refiLastTargetValue]='..(oArti[refiLastTargetValue] or 'nil')..'; tLastOrder[M28Orders.subreftOrderPosition]='..repru(tLastOrder[M28Orders.subreftOrderPosition])..'; oCurTarget='..(oCurTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oCurTarget) or 'nil')) end
        if iTimeSinceLastTargetAssessment < iUpperTimeThreshold and (iTimeSinceLastTargetAssessment < iLowerTimeThreshold or (oArti[refiLastTargetValue] or 0) >= 10000 + 30000 * (iUpperTimeThreshold - iTimeSinceLastTargetAssessment) / (iUpperTimeThreshold - iLowerTimeThreshold)) and (not(EntityCategoryContains(categories.MOBILE, tLastOrder[M28Orders.subrefoOrderUnitTarget].UnitId)) or M28Utilities.GetDistanceBetweenPositions(tLastOrder[M28Orders.subrefoOrderUnitTarget]:GetPosition(), tLastOrder[M28Orders.subreftOrderPosition]) <= 25) then
            IncreaseArtiShotCount(tLastOrder[M28Orders.subreftOrderPosition] or oCurTarget:GetPosition(), oArti:GetAIBrain().M28Team)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function IncreaseArtiShotCount(tActualTarget, iTeam, iOptionalShotCountOverride)
    --Increase shot count
    local iAltPlateauOrZero, iAltLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tActualTarget)
    local tAltLZOrWZTeamData
    if iAltPlateauOrZero == 0 then
        tAltLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAltLZOrWZ]][M28Map.subrefPondWaterZones][iAltLZOrWZ][M28Map.subrefWZTeamData][iTeam]
    else
        tAltLZOrWZTeamData = M28Map.tAllPlateaus[iAltPlateauOrZero][M28Map.subrefPlateauLandZones][iAltLZOrWZ][M28Map.subrefLZTeamData][iTeam]
    end

    tAltLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] = (tAltLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 0) + (iOptionalShotCountOverride or 1)
end

function DelayedScathisOrderChange(bAttackUnitNotGround, oArti, oBestTarget, tActualTarget)
    --E.g. for cases like LOUD where need to clear scathis orders when changing target to stop it moving around
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DelayedScathisOrderChange'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bWillIssueNewOrder = false

    local tLastOrder = oArti[M28Orders.reftiLastOrders][oArti[M28Orders.refiOrderCount]]
    if bAttackUnitNotGround then
        bWillIssueNewOrder = true
        if tLastOrder[M28Orders.subrefoOrderUnitTarget] == oBestTarget and tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAttack then bWillIssueNewOrder = false end
    else
        if tLastOrder[M28Orders.subreftOrderPosition] and M28Utilities.GetRoughDistanceBetweenPositions(tLastOrder, tActualTarget) > 1 then bWillIssueNewOrder = true end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Scathis oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)..'; bWillIssueNewOrder='..tostring(bWillIssueNewOrder or false)..'; oBestTarget='..(oBestTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBestTarget) or 'nil')..'; Time='..GetGameTimeSeconds()) end
    if bWillIssueNewOrder then
        local tAllWeapons = oArti:GetBlueprint().Weapon
        local iUnpackTime = 0
        if tAllWeapons then
            for iWeapon, tWeapon in tAllWeapons do
                iUnpackTime = math.max(iUnpackTime, (tWeapon.WeaponUnpackTimeout or 0))
            end
        end
        local bTrackForMovement = false
        if bDebugMessages == true then LOG(sFunctionRef..': iUnpackTime='..iUnpackTime) end
        if iUnpackTime > 0 then
            bTrackForMovement = true
            M28Orders.IssueTrackedClearCommands(oArti)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(iUnpackTime) --strangly when testing, if wait for unpack time + 1 tick, it causes scathis to move
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end

        function AttackOrigTarget(bQueuedOrder)
            if bDebugMessages == true then LOG(sFunctionRef..': About to issue attack order if target is still valid, is oBestTarget valid='..tostring(M28UnitInfo.IsUnitValid(oBestTarget))..'; Time='..GetGameTimeSeconds()) end
            if bAttackUnitNotGround then
                if M28UnitInfo.IsUnitValid(oBestTarget) then
                    M28Orders.IssueTrackedAttack(oArti, oBestTarget, bQueuedOrder, 'ScaAtU'..oBestTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestTarget), false)
                else
                    bTrackForMovement = false
                end
            else
                M28Orders.IssueTrackedGroundAttack(oArti, tActualTarget, 1, bQueuedOrder, 'ArtiSGF'..oBestTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestTarget), false, oBestTarget)
                --IncreaseArtiShotCount(tActualTarget, iTeam) --Dont call this here as woudlve already been called when doing the delayed order change
            end
        end
        AttackOrigTarget(false)

        if bTrackForMovement then
            --Redundancy - havent actually tested if it works as intended
            local iTimeToTrack = 5
            local iStartTime = GetGameTimeSeconds()
            while GetGameTimeSeconds() <= iStartTime + iTimeToTrack do
                WaitSeconds(1)
                if M28UnitInfo.IsUnitValid(oArti) and (not(bAttackUnitNotGround) or M28UnitInfo.IsUnitValid(oBestTarget)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Monitoring arti, Unit state='..M28UnitInfo.GetUnitState(oArti)..'; Time='..GetGameTimeSeconds()) end
                    if oArti:IsUnitState('Moving') then
                        M28Orders.IssueTrackedClearCommands(oArti)
                        if oArti[reftScathisBuiltLocation] and M28Utilities.GetDistanceBetweenPositions(oArti:GetPosition(), oArti[reftScathisBuiltLocation]) >= 15 then
                            M28Orders.IssueTrackedMove(oArti, oArti[reftScathisBuiltLocation], 1, false, 'ScathMvBk', false)
                        end
                        AttackOrigTarget(true)
                    end
                else
                    break
                end

            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetT3ArtiTarget(oArti, bCalledFromSalvoSize)
    --Gets oArti to fire an attack on the ground for where it thinks it will deal the most damage, works for t3 and experimental arti
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetT3ArtiTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bCalledFromSalvoSize then oArti[refbSalvoDelayActive] = false end
    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)..'; bCalledFromSalvoSize='..tostring(bCalledFromSalvoSize or false)..'; oArti[refbSalvoDelayActive]='..tostring(oArti[refbSalvoDelayActive] or false)..'; Time='..GetGameTimeSeconds()) end
    if not(oArti[refbSalvoDelayActive]) then
        local iPlateau, iLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oArti:GetPosition())
        local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
        local aiBrain = oArti:GetAIBrain()
        local iTeam = aiBrain.M28Team
        local iArtiFacingAngle = M28UnitInfo.GetUnitFacingAngle(oArti)
        local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
        local iShotCount = 1
        if oArti.UnitId == 'url0401' then iShotCount = 0.1 end

        local iAOE, iDamage, iMinRange, iMaxRange, iSalvoSize, iSalvoIndividualDelay = M28UnitInfo.GetLauncherAOEStrikeDamageMinAndMaxRange(oArti)
        --Wait if salvo size >1
        local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
        if iSalvoSize > 1 and not(bCalledFromSalvoSize) and oArti[M28UnitInfo.refiLastWeaponEvent] then
            --E.g. scathis - dont want to change targets after firing a single shot - we have fired the scathis before, and this has presumably been called from the onweaponevent trigger

            local iTimeToWait = 4
            if (iSalvoIndividualDelay or 0) > 0 then iTimeToWait = iSalvoSize * iSalvoIndividualDelay + 0.1 end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(iTimeToWait)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if M28UnitInfo.IsUnitValid(oArti) then
                oArti[refbSalvoDelayActive] = true
                ForkThread(GetT3ArtiTarget, oArti, true)
            end
            --Scathis outside of FAF - it doesnt have a salvo, but does have wierd behaviour where changing targets causes it to move towards the target
        elseif not(M28Utilities.bFAFActive) and oArti.UnitId == 'url0401' and DontChangeCurrentScathisTarget(oArti) then
            if bDebugMessages == true then LOG(sFunctionRef..': Dont want to change t3 arti target yet as think we have a scathis') end
        else
            if (iMaxRange or 0) == 0 or (iAOE or 0) == 0 then M28Utilities.ErrorHandler('Arti '..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)..' has no range or no aoe')
            end

            --First make sure pathing is setup
            if M28Utilities.IsTableEmpty(oArti[reftiPlateauAndZonesInRange]) then
                oArti[reftiPlateauAndZonesInRange] = {}
                M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData)
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) then
                    M28Utilities.ErrorHandler('No other zones located for oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti))
                else
                    local iPlateauOrZero
                    if bDebugMessages == true then LOG(sFunctionRef..': About to search through all zones for targets for oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)..'; iMinRange='..(iMinRange or 'nil')..'; iMaxRange='..(iMaxRange or 'nil')) end
                    for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                        --Stop searching once got past arti max range
                        if tSubtable[M28Map.subrefiDistance] > iMaxRange then
                            if bDebugMessages == true then LOG(sFunctionRef..': Are outside the max range so wil stop searching') end
                            break
                        end
                        --If outside min range then include
                        if tSubtable[M28Map.subrefiDistance] > iMinRange then
                            --Add to potential zone table
                            local tAltLZOrWZData
                            local tAltLZOrWZTeamData
                            if tSubtable[M28Map.subrefbIsWaterZone] then
                                iPlateauOrZero = 0

                                tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[tSubtable[M28Map.subrefiLandOrWaterZoneRef]]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                            else
                                iPlateauOrZero = tSubtable[M28Map.subrefiPlateauOrPond]
                                tAltLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Recording plateau '..iPlateauOrZero..' zone '..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..' as being within max range') end
                            table.insert(oArti[reftiPlateauAndZonesInRange], {iPlateauOrZero, tSubtable[M28Map.subrefiLandOrWaterZoneRef], M28Utilities.GetDistanceBetweenPositions(tAltLZOrWZData[M28Map.subrefMidpoint], tAltLZOrWZTeamData[M28Map.reftClosestFriendlyBase]), M28Utilities.GetAngleFromAToB(oArti:GetPosition(), tAltLZOrWZData[M28Map.subrefMidpoint])})
                        end
                    end
                end
            end

            --Cycle through each zone that may be in range and pick the best one
            local iCurValue
            local iBestValue = 0
            local iSecondBestValue = 0
            local iBestPlateauOrZero, iBestLZOrWZ, iSecondBestPlateauOrZero, iSecondBestLZOrWZ, iBestAngleFactor, iSecondBestAngleFactor
            local iCurMobileThreat
            local iCurAAThreat
            local iShotMissFactor
            local iArtiAngleFactor

            local iFriendlyUnitReductionFactor = 2
            local iFriendlyUnitAOEFactor = 2
            local iSizeAdjust = 0.25
            local iMultipleShotMod = 1
            local iMobileValueFactorInner = 0.4
            local iShieldReductionFactor = 0.25 --i.e. amount by which value of target will be reduced if it is under shielding
            if iDamage >= 7500 and iAOE >= 6 then iShieldReductionFactor = math.min(math.max(iShieldReductionFactor, 0.7), iShieldReductionFactor * 1.5, 0.9) end
            if not(M28Utilities.bFAFActive) then iShieldReductionFactor = math.max(0.4, iShieldReductionFactor * 0.5) end

            --First consider other T3 arti on team, and if target is in our range, then prefer to target that as well as synchronised targeting likely to be best (but only if the target had a value of 20k+)
            local tBestArtiSynchronisedGroundTarget, oArtiSynchronisedTarget
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                local tBrainT3Arti = oBrain:GetListOfUnits(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, false, true)
                if M28Utilities.IsTableEmpty(tBrainT3Arti) == false then
                    local iOtherDistToUs
                    local tLocationsConsidered = {}
                    local bConsiderCurOrder
                    for iOtherArti, oOtherArti in tBrainT3Arti do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering oOtherArti='..oOtherArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOtherArti)..'; Last target value='..(oOtherArti[refiLastTargetValue] or 0)..'; iBestValue='..iBestValue..'; Other arti order count='..(oOtherArti[M28Orders.refiOrderCount] or 'nil')..'; reprs of oOtherArti[M28Orders.reftiLastOrders][oOtherArti[M28Orders.refiOrderCount]]='..reprs(oOtherArti[M28Orders.reftiLastOrders][oOtherArti[M28Orders.refiOrderCount]])) end
                        if not(oOtherArti == oArti) and M28UnitInfo.IsUnitValid(oOtherArti) and (oOtherArti[refiLastTargetValue] or 0) >= math.max(iBestValue * 0.75, 10000) then
                            local tLastArtiOrder = oOtherArti[M28Orders.reftiLastOrders][oOtherArti[M28Orders.refiOrderCount]]
                            local oLastArtiUnitTarget = tLastArtiOrder[M28Orders.subrefoOrderUnitTarget]
                            local tLastArtiTarget
                            if M28Utilities.IsTableEmpty(tLastArtiOrder[M28Orders.subreftOrderPosition]) == false then
                                tLastArtiTarget = {tLastArtiOrder[M28Orders.subreftOrderPosition][1], tLastArtiOrder[M28Orders.subreftOrderPosition][2], tLastArtiOrder[M28Orders.subreftOrderPosition][3]}
                            elseif oLastArtiUnitTarget then
                                tLastArtiTarget = oLastArtiUnitTarget:GetPosition()
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Last arti order position='..repru(tLastArtiOrder[M28Orders.subreftOrderPosition])..'; Last arti order target='..(tLastArtiOrder[M28Orders.subrefoOrderUnitTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tLastArtiOrder[M28Orders.subrefoOrderUnitTarget]) or 'nil')) end
                            if M28Utilities.IsTableEmpty(tLastArtiTarget) == false then
                                bConsiderCurOrder = true
                                if M28Utilities.IsTableEmpty(tLocationsConsidered) == false then
                                    for iLocation, tLocation in tLocationsConsidered do
                                        if M28Utilities.GetRoughDistanceBetweenPositions(tLocation, oArti:GetPosition()) <= 10 then
                                            bConsiderCurOrder = false
                                            break
                                        end
                                    end
                                end
                                if bConsiderCurOrder then
                                    table.insert(tLocationsConsidered, tLastArtiTarget)
                                    iOtherDistToUs = M28Utilities.GetDistanceBetweenPositions(tLastArtiTarget, oArti:GetPosition())
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering order of other target oOtherArti='..oOtherArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOtherArti)..' with iOtherDistToUs='..iOtherDistToUs..'; Other arti position='..repru(tLastArtiTarget)) end
                                    if iOtherDistToUs >= iMinRange and iOtherDistToUs <= iMaxRange then
                                        local iTargetPlateauOrZero, iTargetZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tLastArtiTarget)
                                        local bDontConsiderIfUnderwater = true
                                        if iTargetPlateauOrZero == 0 then bDontConsiderIfUnderwater = true end
                                        iCurValue = M28Logic.GetDamageFromBomb(aiBrain, tLastArtiTarget, iAOE, iDamage, iFriendlyUnitReductionFactor,       iFriendlyUnitAOEFactor,     false,                      iSizeAdjust,        iMultipleShotMod,                   iMobileValueFactorInner,                true,                   iShieldReductionFactor,         true,                           nil,                                    nil,                    nil,                    not(bDontConsiderIfUnderwater))
                                        --Adjust curvalue for shot count as well
                                        local tAltLZOrWZData, tAltLZOrWZTeamData
                                        if iTargetPlateauOrZero == 0 then
                                            tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iTargetZone]][M28Map.subrefPondWaterZones][iTargetZone]
                                            tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                                        else
                                            tAltLZOrWZData = M28Map.tAllPlateaus[iTargetPlateauOrZero][M28Map.subrefPlateauLandZones][iTargetZone]
                                            tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                                        end
                                        iShotMissFactor = GetArtiValueFactorForShotFailures((tAltLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 0))
                                        --Reduce shot miss factor as have multiple arti firing at it
                                        if iShotMissFactor < 1 then iShotMissFactor = 1 - (1 - iShotMissFactor) * 0.5 end
                                        --Increase value by 25% due to synchronisation benefit, and ignore angle factor
                                        iCurValue = iCurValue * iShotMissFactor * 1.25
                                        if bDebugMessages == true then LOG(sFunctionRef..': iCurValue='..iCurValue..'; after applying iShotMissFactor='..iShotMissFactor..'; iBestValue so far='..iBestValue) end
                                        if iCurValue > iBestValue then
                                            iBestValue = iCurValue
                                            tBestArtiSynchronisedGroundTarget = {tLastArtiTarget[1], tLastArtiTarget[2], tLastArtiTarget[3]}
                                            oArtiSynchronisedTarget = oLastArtiUnitTarget
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will consider this as our preferred synchronised shot target') end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will cycle through each plateau and zone in range now, is oArti[reftiPlateauAndZonesInRange] empty='..tostring(M28Utilities.IsTableEmpty(oArti[reftiPlateauAndZonesInRange]))) end

            local iShieldFactor --Impact on value from enemy shields
            local iMinShieldFactor = 0.2 --I.e. if 0.05 then wouldn't reduce value below 5% of what we would have calculated ignoring shield when determining best and second best zones
            if M28Utilities.bFAFActive then
                iShieldFactor = 2
            else
                iMinShieldFactor = 0.1
                if M28Utilities.bQuietModActive then
                    iShieldFactor = 5
                else
                    iShieldFactor = 8
                end
            end
            local iDoubleShieldFactorThreshold = 4000 --If enemy has more than this much mass then will double the shield factor

            for iEntry, tPlateauZoneAndDist in oArti[reftiPlateauAndZonesInRange] do
                local tAltLZOrWZData
                local tAltLZOrWZTeamData
                if tPlateauZoneAndDist[1] == 0 then
                    tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[tPlateauZoneAndDist[2]]][M28Map.subrefPondWaterZones][tPlateauZoneAndDist[2]]
                    tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                else
                    tAltLZOrWZData = M28Map.tAllPlateaus[tPlateauZoneAndDist[1]][M28Map.subrefPlateauLandZones][tPlateauZoneAndDist[2]]
                    tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                end
                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAltLZOrWZData[M28Map.subrefMidpoint]) then
                    iCurMobileThreat = ((tAltLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) + (tAltLZOrWZTeamData[M28Map.subrefWZThreatEnemySurface] or 0))
                    --Get more precise calculation - i.e. the threat calculation above reduces threat for health, meaning if we attack say a fatboy, its threat decreases as its shield decreases, making it likely we switch targets when its shield is about to be destroyed; however dont bother with low threat values
                    if iCurMobileThreat >= 1000 then
                        if tPlateauZoneAndDist[1] == 0 then
                            iCurMobileThreat = M28UnitInfo.GetMassCostOfUnits(EntityCategoryFilterDown(categories.MOBILE - M28UnitInfo.refCategoryAmphibious - categories.SUBMERSIBLE, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits]), true)
                        else
                            iCurMobileThreat = M28UnitInfo.GetMassCostOfUnits(EntityCategoryFilterDown(categories.MOBILE, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits]), true)
                        end
                    end
                    if tPlateauZoneAndDist[1] == 0 and tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] > 0 then
                        iCurValue = M28UnitInfo.GetMassCostOfUnits(EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits]), true) + iCurMobileThreat * 0.2
                    else
                        iCurValue = tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] + iCurMobileThreat * 0.2
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering plateau and zone '..tPlateauZoneAndDist[1]..'Z'..tPlateauZoneAndDist[2]..'; tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]='..(tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 'nil')..'; iCurMobileThreat='..iCurMobileThreat..'; subrefThreatEnemyShield='..(tAltLZOrWZTeamData[M28Map.subrefThreatEnemyShield] or 0)) end
                    --Add extra mobile threat if enemy has long ranged units and is close to our nearest base
                    if iCurMobileThreat >= 4000 and tPlateauZoneAndDist[3] <= 300 and M28Utilities.IsTableEmpty(tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) == false then
                        local iLongRangeThreat = 0
                        for iRange, iThreat in tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] do
                            if iRange >= 65 then --i.e. just above a megaliths range
                                iLongRangeThreat = iLongRangeThreat + iThreat
                            end
                        end
                        if iLongRangeThreat >= 1500 then
                            iCurValue = iCurValue + iCurMobileThreat * 0.8 --want based on mobile threat so less likely to run into issue for units like fatboy where threat decreases as shield decreases
                        end
                    end
                    --Add extra mobile threat if enemy has large mobile MAA
                    iCurAAThreat = (tAltLZOrWZTeamData[M28Map.subrefiThreatEnemyGroundAA] or 0) + (tAltLZOrWZTeamData[M28Map.subrefiThreatEnemyGroundAA] or 0)
                    if iCurAAThreat >= 3000 then
                        local tEnemyMobileAA = EntityCategoryFilterDown(categories.MOBILE, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits])
                        if M28Utilities.IsTableEmpty( tEnemyMobileAA) == false then
                            iCurValue = iCurValue + iCurAAThreat * 0.2 + M28UnitInfo.GetMassCostOfUnits(tEnemyMobileAA, true) * 0.8
                        else
                            iCurValue = iCurValue + iCurAAThreat * 0.2
                        end
                    else
                        iCurValue = iCurValue + iCurAAThreat * 0.2
                    end

                    --Add extra threat if enemy has t2 arti near the nearest friendly base (relevant for team games, since 1v1 this hsould be inside the minimum rnage)
                    if tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] >= 4000 and tPlateauZoneAndDist[3] <= 200 and not(tPlateauZoneAndDist[1] == 0) then
                        local tEnemyT2ArtiAndMissileShips = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryTML + M28UnitInfo.refCategoryMissileShip, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits])
                        if M28Utilities.IsTableEmpty(tEnemyT2ArtiAndMissileShips) == false then
                            iCurValue = iCurValue + tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]
                        end
                    end

                    --Reduce value if shielded
                    if (tAltLZOrWZTeamData[M28Map.subrefThreatEnemyShield] or 0) > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Value before shield reduction factor='..iCurValue) end
                        if tAltLZOrWZTeamData[M28Map.subrefThreatEnemyShield] <= iMinShieldFactor then
                            iCurValue = math.max(iCurValue * iMinShieldFactor, iCurValue - tAltLZOrWZTeamData[M28Map.subrefThreatEnemyShield] * iShieldFactor)
                        else --Enemy likely has 2+ shields
                            iCurValue = math.max(iCurValue * iMinShieldFactor, iCurValue - tAltLZOrWZTeamData[M28Map.subrefThreatEnemyShield] * iShieldFactor * 2)
                        end
                    end

                    if bDebugMessages == true then LOG(sFunctionRef..': Considering plateau '..tPlateauZoneAndDist[1]..' and zone '..tPlateauZoneAndDist[2]..'; Dist='..tPlateauZoneAndDist[3]..'; iCurValue before factoring in ineffective shot count='..iCurValue..'; tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount]='..(tAltLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 'nil')..'; iCurAAThreat='..iCurAAThreat..'; iCurMobileThreat='..iCurMobileThreat..'; tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]='..tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]..'; iSecondBestValue='..iSecondBestValue) end

                    --Adjust value for number of times shots have hit
                    if iCurValue > iSecondBestValue then
                        --Adjust cur value for shot missed percentage
                        iShotMissFactor = GetArtiValueFactorForShotFailures((tAltLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 0))
                        --Adjust cur value for angle to target
                        iArtiAngleFactor = GetArtiValueFactorForFacingDifference(iArtiFacingAngle, tPlateauZoneAndDist[4])

                        iCurValue = iCurValue * iShotMissFactor * iArtiAngleFactor

                        --Record as best/second best
                        if iCurValue > iBestValue then
                            tBestArtiSynchronisedGroundTarget = nil
                            oArtiSynchronisedTarget = nil
                            iSecondBestValue = iBestValue
                            iSecondBestPlateauOrZero = iBestPlateauOrZero
                            iSecondBestLZOrWZ = iBestLZOrWZ
                            iSecondBestAngleFactor = iBestAngleFactor
                            iBestValue = iCurValue
                            iBestPlateauOrZero = tPlateauZoneAndDist[1]
                            iBestLZOrWZ = tPlateauZoneAndDist[2]
                            iBestAngleFactor = iArtiAngleFactor
                        elseif iCurValue > iSecondBestValue then
                            iSecondBestValue = iCurValue
                            iSecondBestPlateauOrZero = tPlateauZoneAndDist[1]
                            iSecondBestLZOrWZ = tPlateauZoneAndDist[2]
                            iSecondBestAngleFactor = iArtiAngleFactor
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iCurValue after adj='..iCurValue..'; iShotMissFactor='..iShotMissFactor..'; iArtiAngleFactor='..iArtiAngleFactor) end
                    end
                end
            end

            --Now have the best 2 zones on an aggregate basis, get the best location for the arti target within these zones
            --Reduce value of shields against high damage and aoe targets

            function GetBestUnitTargetAndValueInZone(iPlateauOrZero, iLZOrWZ, iAngleFactor)
                local tAltLZOrWZData
                local tAltLZOrWZTeamData
                local iCurValue
                local iBestCurValue = 0
                local oBestUnitTarget
                if iPlateauOrZero == 0 then
                    tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLZOrWZ]][M28Map.subrefPondWaterZones][iLZOrWZ]
                    tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                else
                    tAltLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLZOrWZ]
                    tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering best target in plateau '..iPlateauOrZero..'; Zone '..iLZOrWZ..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits]))) end
                if M28Utilities.IsTableEmpty(tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    local tPriorityUnits
                    local iMaxTargetsPerZone = 25
                    local bDontConsiderIfUnderwater = true
                    if iPlateauOrZero == 0 then bDontConsiderIfUnderwater = true end
                    if oArti[M28UnitInfo.refbEasyBrain] then
                        tPriorityUnits = EntityCategoryFilterDown(categories.EXPERIMENTAL + M28UnitInfo.refCategoryStructure * categories.TECH3 + M28UnitInfo.refCategoryStructure * categories.TECH2, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits])
                        iMaxTargetsPerZone = 10
                    else
                        tPriorityUnits = EntityCategoryFilterDown(categories.EXPERIMENTAL + categories.TECH3 + M28UnitInfo.refCategoryStructure * categories.TECH2 + M28UnitInfo.refCategoryCruiser * categories.TECH2, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits])
                    end

                    local iCurDist
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of priority units empty='..tostring(M28Utilities.IsTableEmpty(tPriorityUnits))) end
                    if M28Utilities.IsTableEmpty(tPriorityUnits) then tPriorityUnits = tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits] end
                    --Filter to the top 25 units in the zone by mass cost for performance reasons
                    local tiBaseValueOfPriorityUnits = {}
                    local iBaseValue

                    for iUnit, oUnit in tPriorityUnits do
                        --Double check are in range
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oArti:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering targeting oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..iCurDist..'; iMaxRange='..iMaxRange..'; iMinRange='..iMinRange..'; iAOE='..(iAOE or 'nil')..'; iDamage='..(iDamage or 'nil')..'; iFriendlyUnitReductionFactor='..(iFriendlyUnitReductionFactor or 'nil')..'; iFriendlyUnitAOEFactor='..(iFriendlyUnitAOEFactor or 'nil')..'; iSizeAdjust='..(iSizeAdjust or 'nil')..'; iMultipleShotMod='..(iMultipleShotMod or 'nil')..'; iMobileValueFactorInner='..(iMobileValueFactorInner or 'nil')..'; iShieldReductionFactor='..(iShieldReductionFactor or 'nil')) end
                            if iCurDist <= iMaxRange and iCurDist >= iMinRange and (bDontConsiderIfUnderwater or not(M28UnitInfo.IsUnitUnderwater(oUnit))) then
                                iBaseValue = (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * oUnit:GetFractionComplete()
                                if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) and oUnit:GetFractionComplete() >= 0.98 then iBaseValue = iBaseValue * iMobileValueFactorInner end
                                tiBaseValueOfPriorityUnits[iUnit] = iBaseValue
                            end
                        end
                    end
                    local iCurCount = 0
                    if M28Utilities.IsTableEmpty(tiBaseValueOfPriorityUnits) == false then
                        for iEntry, iValue in M28Utilities.SortTableByValue(tiBaseValueOfPriorityUnits, true) do
                            iCurCount = iCurCount + 1
                            if iCurCount > iMaxTargetsPerZone then break end
                            local oUnit = tPriorityUnits[iEntry]
                            --GetDamageFromBomb(aiBrain, tBaseLocation,     iAOE,   iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory, iOptionalReclaimFactor, bCheckIfUnderwater)
                            iCurValue = M28Logic.GetDamageFromBomb(aiBrain, oUnit:GetPosition(), iAOE, iDamage, iFriendlyUnitReductionFactor,       iFriendlyUnitAOEFactor,     false,                      iSizeAdjust,        iMultipleShotMod,                   iMobileValueFactorInner,                true,                   iShieldReductionFactor,         true,                           nil,                                    nil,                    nil,                    not(bDontConsiderIfUnderwater))
                            if bDebugMessages == true then LOG(sFunctionRef..': Damage from bomb if we target it at unit='..iCurValue..'; iBestCurValue='..(iBestCurValue or 'nil')) end
                            local iMinValue = 0
                            --Only set the min value if we dont have a negative value from the target (e.g. happens if targeting our own base or capture target)
                            if (iCurValue or 0) >= 0 and M28UnitInfo.IsUnitValid(oUnit) and oUnit.GetFractionComplete and (oUnit:GetFractionComplete() < 1 or EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId)) then
                                --redundancy for buildings and under construction units
                                iMinValue = (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * oUnit:GetFractionComplete()
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering increasing cur value to min basic value based on the unit target, iCurValue='..(iCurValue or 'nil')..'; iBestCurValue='..(iBestCurValue or 'nil')..'; iMinValue='..(iMinValue or 'nil')) end
                                iCurValue = math.max((iCurValue or 0), iMinValue)
                            end
                            if iCurValue > iBestCurValue then
                                tBestArtiSynchronisedGroundTarget = nil
                                oArtiSynchronisedTarget = nil
                                iBestCurValue = iCurValue
                                oBestUnitTarget = oUnit
                                if bDebugMessages == true then LOG(sFunctionRef..': Setting the best unit target to '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iBestCurValue='..iBestCurValue) end
                            end
                        end
                    end
                end
                return oBestUnitTarget, iBestCurValue
            end
            local oBestTarget
            if iBestLZOrWZ and iBestPlateauOrZero then
                oBestTarget, iBestValue = GetBestUnitTargetAndValueInZone(iBestPlateauOrZero, iBestLZOrWZ)
                if not(iBestAngleFactor) then iBestAngleFactor = GetArtiValueFactorForFacingDifference(0,180) end
                if not(iBestValue) then iBestValue = 0 end
                iBestValue = iBestAngleFactor * iBestValue
                if bDebugMessages == true then LOG(sFunctionRef..': iBestPlateauOrZero='..(iBestPlateauOrZero or 'nil')..'; iBestLZOrWZ='..(iBestLZOrWZ or 'nil')..'; iBestValue='..(iBestValue or 'nil')..'; oBestTarget='..(oBestTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBestTarget) or 'nil')..'; iBestAngleFactor='..(iBestAngleFactor or 'nil')) end
                if iSecondBestLZOrWZ then
                    local oAltTarget, iAltTargetValue = GetBestUnitTargetAndValueInZone(iSecondBestPlateauOrZero, iSecondBestLZOrWZ)
                    if bDebugMessages == true then LOG(sFunctionRef..': iSecondBestPlateauOrZero='..(iSecondBestPlateauOrZero or 'nil')..'; iSecondBestLZOrWZ='..(iSecondBestLZOrWZ or 'nil')..'; iAltTargetValue='..(iAltTargetValue or 'nil')..'; oAltTarget='..(oAltTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oAltTarget) or 'nil')..'; iBestValue before considering this='..(iBestValue or 'nil')..'; iSecondBestAngleFactor='..(iSecondBestAngleFactor or 'nil')) end
                    if not(iSecondBestAngleFactor) then iSecondBestAngleFactor = GetArtiValueFactorForFacingDifference(0,180) end
                    if not(iAltTargetValue) then iAltTargetValue = 0
                    elseif oAltTarget.GetPosition then
                        --Get value from targeting the best target in this alt zone
                        --GetDamageFromBomb(aiBrain, tBaseLocation,             iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory, bCheckIfUnderwater)
                        iAltTargetValue  = M28Logic.GetDamageFromBomb(aiBrain, oAltTarget:GetPosition(), iAOE, iDamage, iFriendlyUnitReductionFactor,       iFriendlyUnitAOEFactor,     false,                      iSizeAdjust,        iMultipleShotMod,                   iMobileValueFactorInner,                true,                   iShieldReductionFactor,         true)
                    end
                    iAltTargetValue = iAltTargetValue * iSecondBestAngleFactor
                    if bDebugMessages == true then LOG(sFunctionRef..': iAltTargetValue='..iAltTargetValue..'; iBestValue before reflecting this='..iBestValue) end
                    if iAltTargetValue > iBestValue then
                        oBestTarget = oAltTarget
                        iBestValue = iAltTargetValue
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished considering first and second best zones, oBestTarget='..(oBestTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBestTarget) or 'nil')..'; tBestArtiSynchronisedGroundTarget='..repru(tBestArtiSynchronisedGroundTarget)..'; oArtiSynchronisedTarget='..(oArtiSynchronisedTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oArtiSynchronisedTarget) or 'nil')) end
            if oArtiSynchronisedTarget and tBestArtiSynchronisedGroundTarget then oBestTarget = oArtiSynchronisedTarget end
            if not(oBestTarget) and not(tBestArtiSynchronisedGroundTarget) then
                M28Utilities.ErrorHandler('No target found for T3 arti, will fire at closest enemy base instead if we can hit it', true)
                local bGivenAltTarget = false
                local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                local iDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], oArti:GetPosition())
                if iDistToEnemyBase <= iMaxRange and iDistToEnemyBase >= iMinRange and ( bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZTeamData[M28Map.reftClosestEnemyBase])) then
                    --GetDamageFromBomb(aiBrain, tBaseLocation,                             iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory)
                    local iDamage = M28Logic.GetDamageFromBomb(aiBrain, tLZTeamData[M28Map.reftClosestEnemyBase], iAOE, iDamage, iFriendlyUnitReductionFactor, iFriendlyUnitAOEFactor,          false,                          iSizeAdjust,        iMultipleShotMod,               iMobileValueFactorInner,                    true,               iShieldReductionFactor,         true)
                    if iDamage >= 0 then --should mean dont have much in way of friendly forces there
                        --Check there are enemy units nearby
                        local bNearbyEnemyUnits = false
                        local tNearbyUnits = GetUnitsInRect(M28Utilities.GetRectAroundLocation(tLZTeamData[M28Map.reftClosestEnemyBase], iAOE * 1.3))
                        if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                            for iUnit, oUnit in tNearbyUnits do
                                if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategoryStructure - categories.TECH1 * categories.MOBILE, oUnit.UnitId) then
                                    if IsEnemy(oUnit:GetAIBrain():GetArmyIndex(), aiBrain:GetArmyIndex()) then
                                        bNearbyEnemyUnits = true
                                        break
                                    end
                                end
                            end
                        end
                        if bNearbyEnemyUnits then
                            iBestValue = iDamage
                            --Is this the same as the last target?
                            oArti[refiLastTargetValue] = iBestValue
                            local tLastOrder = oArti[M28Orders.reftiLastOrders][oArti[M28Orders.refiOrderCount]]
                            if M28Utilities.IsTableEmpty(tLastOrder[M28Orders.subreftOrderPosition]) == false and M28Utilities.GetRoughDistanceBetweenPositions(tLastOrder[M28Orders.subreftOrderPosition], tLZTeamData[M28Map.reftClosestEnemyBase]) > 1 then
                                oArti[refiTimeLastGotBestArtiTarget] = GetGameTimeSeconds()
                                M28Orders.IssueTrackedGroundAttack(oArti, tLZTeamData[M28Map.reftClosestEnemyBase], 1, false, 'ArtiEB'..'ALZ'..iLandZone, false)
                                IncreaseArtiShotCount(tLZTeamData[M28Map.reftClosestEnemyBase], iTeam, iShotCount)
                            end
                            bGivenAltTarget = true
                        end
                    end
                end
                if not(bGivenAltTarget) then M28Orders.IssueTrackedClearCommands(oArti) end
            else
                local tActualTarget
                local tLeadingTarget
                local bAttackUnitNotGround = false
                if bDebugMessages == true then LOG(sFunctionRef..': Considering oBestTarget='..oBestTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestTarget)..'; Does this contain mobile='..tostring(EntityCategoryContains(categories.MOBILE, oBestTarget.UnitId))..'; Fraction complete='..oBestTarget:GetFractionComplete()..'; Is moving unit state='..tostring(oBestTarget:IsUnitState('Moving'))..'; Unit state='..M28UnitInfo.GetUnitState(oBestTarget)) end
                if not(tBestArtiSynchronisedGroundTarget) and EntityCategoryContains(categories.MOBILE, oBestTarget.UnitId) and oBestTarget:GetFractionComplete() == 1 and oBestTarget:IsUnitState('Moving') and not(oArti[M28UnitInfo.refbEasyBrain]) and (M28Utilities.bFAFActive or not(oArti.UnitId == 'url0401')) then
                    --If best target is mobile and moving, then consider a leading shot instead
                    local oBP = oArti:GetBlueprint()
                    local iWeaponVelocity
                    if oBP.Weapon then
                        for iCurWeapon, oCurWeapon in oBP.Weapon do
                            if (oCurWeapon.DamageRadius or 0) > 0 and (oCurWeapon.MaxRadius or 0) >= iMaxRange then
                                iWeaponVelocity = oCurWeapon.MuzzleVelocity
                                break
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iWeaponVelocity='..(iWeaponVelocity or 'nil')) end
                    if (iWeaponVelocity or 0) > 0 then
                        local iDistToEnemy = M28Utilities.GetDistanceBetweenPositions(oBestTarget:GetPosition(), oArti:GetPosition())
                        local iTimeToImpact = 0.5 + iDistToEnemy * 1.75 / iWeaponVelocity
                        local iCurFacingDirection = M28UnitInfo.GetUnitFacingAngle(oBestTarget)
                        local iDistToLead = iTimeToImpact * (oBestTarget:GetBlueprint().Physics.MaxSpeed or 0)
                        tLeadingTarget = M28Utilities.MoveInDirection(oBestTarget:GetPosition(), iCurFacingDirection, iDistToLead, true, false, M28Map.bIsCampaignMap)
                        if bDebugMessages == true then LOG(sFunctionRef..': tLeadingTarget='..repru(tLeadingTarget)..'; Dist to best arti='..M28Utilities.GetDistanceBetweenPositions(tLeadingTarget, oArti:GetPosition())..'; Min range='..iMinRange) end
                        if not(tLeadingTarget and M28Utilities.GetDistanceBetweenPositions(tLeadingTarget, oArti:GetPosition()) >= iMinRange) then
                            tLeadingTarget = nil
                        end
                    end
                end
                if tBestArtiSynchronisedGroundTarget then
                    tActualTarget = tBestArtiSynchronisedGroundTarget
                elseif tLeadingTarget then
                    if bDebugMessages == true then LOG(sFunctionRef..': Changing Arti target for oBestTarget='..oBestTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestTarget)..' to try and lead target, oBestTarget position='..repru(oBestTarget:GetPosition())..'; tLeadingTarget='..repru(tLeadingTarget)..'; Time='..GetGameTimeSeconds()) end
                    tActualTarget = tLeadingTarget
                elseif M28Utilities.bFAFActive or not(oArti.UnitId == 'url0401') then
                    --GetBestAOETarget(aiBrain, tBaseLocation,            iAOE, iDamage, bOptionalCheckForSMD, tSMLLocationForSMDCheck, iOptionalTimeSMDNeedsToHaveBeenBuiltFor, iSMDRangeAdjust, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, iOptionalMaxDistanceCheckOptions, iMobileValueOverrideFactorWithin75Percent, iOptionalShieldReductionFactor, iOptionalReclaimFactor)
                    tActualTarget = M28Logic.GetBestAOETarget(aiBrain, oBestTarget:GetPosition(), iAOE, iDamage, false,                 nil,                    nil,                                    nil,            iFriendlyUnitReductionFactor,       iFriendlyUnitAOEFactor,     nil,                            iMobileValueFactorInner,                    iShieldReductionFactor,         nil)
                else
                    if M28UnitInfo.CanSeeUnit(aiBrain, oBestTarget, false) then
                        bAttackUnitNotGround = true
                    end
                    tActualTarget = oBestTarget:GetPosition()
                end



                --Double check are still in range
                local iTargetDist = M28Utilities.GetDistanceBetweenPositions(tActualTarget, oArti:GetPosition())
                if bDebugMessages == true then LOG(sFunctionRef..': tActualTarget='..repru(tActualTarget)..'; iTargetDist='..iTargetDist..'; iBestValue='..(iBestValue or 'nil')) end
                if iTargetDist > iMaxRange or iTargetDist < iMinRange then
                    if oBestTarget then
                        bAttackUnitNotGround = false --redundancy
                        tActualTarget = oBestTarget:GetPosition()
                    else
                        M28Utilities.ErrorHandler('Dont have oBestTarget, and our original target isnt in range, did we pick another t3 arti target that is out of range somehow?')
                    end
                end

                if M28Map.bIsCampaignMap and (iBestValue or 0) < 0 then
                    --Disable weapon
                    M28UnitInfo.DisableUnitWeapon(oArti)
                    if bDebugMessages == true then LOG(sFunctionRef..': Disabling Arti weapon, oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)) end
                    ForkThread(RecheckForArtiTargetSoon, oArti)
                else

                    --Issue attack order
                    oArti[refiLastTargetValue] = iBestValue
                    oArti[refiTimeLastGotBestArtiTarget] = GetGameTimeSeconds()
                    local tLastOrder = oArti[M28Orders.reftiLastOrders][oArti[M28Orders.refiOrderCount]]
                    if not(M28Utilities.bFAFActive) and oArti.UnitId == 'url0401' then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will do delayed order change for arti as it is scathis and not FAF') end
                        ForkThread(DelayedScathisOrderChange, bAttackUnitNotGround, oArti, oBestTarget, tActualTarget)
                    elseif bAttackUnitNotGround then
                        if bDebugMessages == true then LOG(sFunctionRef..': Issuing tracked attack for oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)..' to attack oBestTarget='..oBestTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestTarget)) end
                        M28Orders.IssueTrackedAttack(oArti, oBestTarget, false, 'ScaAtU', false)
                    else
                        if M28Utilities.IsTableEmpty(tLastOrder[M28Orders.subreftOrderPosition]) or M28Utilities.GetRoughDistanceBetweenPositions(tLastOrder[M28Orders.subreftOrderPosition], tActualTarget) > 1 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Issuing tracked ground attack for oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)..' to attack oBestTarget='..oBestTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestTarget)) end
                            M28Orders.IssueTrackedGroundAttack(oArti, tActualTarget, 1, false, 'ArtiGF'..'ALZ'..iLandZone, false, oBestTarget)
                        end
                    end
                    IncreaseArtiShotCount(tActualTarget, iTeam, iShotCount)
                    if bDebugMessages == true then LOG(sFunctionRef..': Sent order to attack to oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)..', iBestValue='..iBestValue..'; tActualTarget='..repru(tActualTarget)) end
                end
            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetArtiValueFactorForShotFailures(iShotFailedCount)
    --iShotFailedCount: Should be (tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 0)
    local iFactor
    local iInterval = 13
    if iShotFailedCount >= iInterval then
        iFactor = math.max(0.03, 1 - math.floor(iShotFailedCount / iInterval) * iInterval * 0.03)
    else
        --Have failed fewer than 15 shots
        iFactor = 1
    end
    return iFactor
end
function GetArtiValueFactorForFacingDifference(iArtiFacingAngle, iAngleToTarget)
    local iAngleDif = M28Utilities.GetAngleDifference(iArtiFacingAngle, iAngleToTarget)
    if iAngleDif <= 10 then
        return 1
    else
        return 1 - 0.4 * iAngleDif / 180
    end
end

function JustFiredMissile(oLauncher)
    --Wait 1 tick then check if sitll have missile loaded and if so then consider firing another missile
    if EntityCategoryContains(M28UnitInfo.refCategoryTML + M28UnitInfo.refCategorySML, oLauncher.UnitId) then
        WaitTicks(1)
        if M28UnitInfo.IsUnitValid(oLauncher) then
            local iMissiles = 0 --For some reason the count is off by 1, presumably a slight delay between the event being called and the below ammo counts working
            if oLauncher.GetTacticalSiloAmmoCount then iMissiles = iMissiles + oLauncher:GetTacticalSiloAmmoCount() end
            if oLauncher.GetNukeSiloAmmoCount then iMissiles = iMissiles + oLauncher:GetNukeSiloAmmoCount() end
            if iMissiles > 0 then
                --LOG('consideration of launching missile 3')
                ConsiderLaunchingMissile(oLauncher)
            end
            --Track SML launchers who have recently fired
            if M28UnitInfo.IsUnitValid(oLauncher) and oLauncher:GetAIBrain().M28AI then
                if EntityCategoryContains(M28UnitInfo.refCategorySML, oLauncher.UnitId) then
                    local iTeam = oLauncher:GetAIBrain().M28Team
                    local bAddToTable = true
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers]) then M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers] = {}
                    else
                        for iRecordedLauncher, oRecordedLauncher in M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers] do
                            if oRecordedLauncher == oLauncher then
                                bAddToTable = false
                                break
                            end
                        end
                    end
                    if bAddToTable then
                        table.insert(M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers], oLauncher)
                    end
                end
            end

        end
    end
end

function ReserveLocationsForGameEnder(oUnit)
    --Reserve locations to provide shield coverage for oUnit
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReserveLocationsForGameEnder'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(oUnit[reftArtiTemplateRefs]) then --redundancy as shouldve already checked before getting here

        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, gametimeseconds is '..GetGameTimeSeconds()..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; owned by '..oUnit:GetAIBrain().Nickname..' on team '..oUnit:GetAIBrain().M28Team) end

        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
        if iLandZone > 0 then
            local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
            local tiShieldBuildLocationOptions = {}
            local tiShieldLocationCountByOption = {}
            local sBlueprintToBuild = 'xsb4202'
            local iNewBuildingDiameter = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
            local iNewBuildingRadius = iNewBuildingDiameter * 0.5
            local iAdjacencyBuildingRadius = M28UnitInfo.GetBuildingSize(oUnit.UnitId) * 0.5
            local tAdjacencyBuildingPosition = oUnit:GetPosition()

            local iCurZ, iCurX
            local iCornerAdjust = math.min(iNewBuildingDiameter, iAdjacencyBuildingRadius * 2)

            local iCurOptionCount = 0

            if bDebugMessages == true then LOG(sFunctionRef..': tAdjacencyBuildingPosition='..repru(tAdjacencyBuildingPosition)..'; iAdjacencyBuildingRadius='..iAdjacencyBuildingRadius..'; iNewBuildingRadius='..iNewBuildingRadius..'; iCornerAdjust='..iCornerAdjust) end
            local aiBrain = oUnit:GetAIBrain()

            --First go along top and bottom:
            local iCurMod = 0
            local iMostBuildLocations = 0
            local iBestOptionCountRef
            for iZFactor = -1, 1, 2 do
                iCurOptionCount = iCurOptionCount + 1
                tiShieldBuildLocationOptions[iCurOptionCount] = {}
                iCurZ = tAdjacencyBuildingPosition[3] + (iAdjacencyBuildingRadius + iNewBuildingRadius) * iZFactor
                --Include corner positions even though not adjacent
                for iCurX = tAdjacencyBuildingPosition[1] - iCornerAdjust, tAdjacencyBuildingPosition[1] + iCornerAdjust, 1 do
                    if iCurMod > 0 then
                        iCurMod = iCurMod - 1
                    elseif M28Engineer.CanBuildAtLocation(aiBrain, sBlueprintToBuild, { iCurX, 0, iCurZ}, iPlateau, iLandZone, nil, false, true, false, true, false) then
                        tiShieldLocationCountByOption[iCurOptionCount] = (tiShieldLocationCountByOption[iCurOptionCount] or 0) + 1
                        tiShieldBuildLocationOptions[iCurOptionCount][tiShieldLocationCountByOption[iCurOptionCount]] = {iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ}
                        iCurMod = iCurMod + iNewBuildingDiameter - 1
                        if tiShieldLocationCountByOption[iCurOptionCount] > iMostBuildLocations then
                            iMostBuildLocations = tiShieldLocationCountByOption[iCurOptionCount]
                            iBestOptionCountRef = iCurOptionCount
                            if iMostBuildLocations >= 3 then break end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished considering top or bottom, iZFactor='..(iZFactor or 'nil')..'; iCurOptionCount='..(iCurOptionCount or 'nil')..'; tiShieldBuildLocationOptions[iCurOptionCount]='..repru(tiShieldBuildLocationOptions[iCurOptionCount])..'; tiShieldLocationCountByOption[iCurOptionCount]='..(tiShieldLocationCountByOption[iCurOptionCount] or 'nil')..'; iMostBuildLocations='..iMostBuildLocations) end
                if iMostBuildLocations >= 3 then break end
                iCurMod = 0
            end
            if iMostBuildLocations < 3 then
                --Next go along the sides:
                for iXFactor = -1, 1, 2 do
                    iCurMod = 0
                    iCurOptionCount = iCurOptionCount + 1
                    tiShieldBuildLocationOptions[iCurOptionCount] = {}

                    iCurX = tAdjacencyBuildingPosition[1] + (iAdjacencyBuildingRadius + iNewBuildingRadius) * iXFactor
                    for iCurZ = tAdjacencyBuildingPosition[3] - iCornerAdjust, tAdjacencyBuildingPosition[3] + iCornerAdjust, 1 do
                        if iCurMod > 0 then
                            iCurMod = iCurMod - 1
                        elseif M28Engineer.CanBuildAtLocation(aiBrain, sBlueprintToBuild, { iCurX, 0, iCurZ}, iPlateau, iLandZone, nil, false, true, false, true, false) then
                            tiShieldLocationCountByOption[iCurOptionCount] = (tiShieldLocationCountByOption[iCurOptionCount] or 0) + 1
                            tiShieldBuildLocationOptions[iCurOptionCount][tiShieldLocationCountByOption[iCurOptionCount]] = {iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ}
                            iCurMod = iCurMod + iNewBuildingDiameter - 1
                            if tiShieldLocationCountByOption[iCurOptionCount] > iMostBuildLocations then
                                iMostBuildLocations = tiShieldLocationCountByOption[iCurOptionCount]
                                iBestOptionCountRef = iCurOptionCount
                                if iMostBuildLocations >= 3 then break end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering left or right side, iXFactor='..(iXFactor or 'nil')..'; iCurOptionCount='..(iCurOptionCount or 'nil')..'; tiShieldBuildLocationOptions[iCurOptionCount]='..repru(tiShieldBuildLocationOptions[iCurOptionCount])..'; tiShieldLocationCountByOption[iCurOptionCount]='..(tiShieldLocationCountByOption[iCurOptionCount] or 'nil')..'; iMostBuildLocations='..iMostBuildLocations) end
                    if iMostBuildLocations >= 3 then break end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iMostBuildLocations='..iMostBuildLocations) end

            if iMostBuildLocations >= 1 then
                --Figure out the best faction engineer that could realistically build the shield by locating the closest factory of each faction type
                local tLZTeamData = tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
                local iRecordedCount = 0
                if not(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) then tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] = {} end
                table.insert(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection], oUnit)
                RecordNearbyFactoryForShieldEngineers(oUnit)

                if bDebugMessages == true then LOG(sFunctionRef..': Can build at least 2 shields close to each other and the gameender, will now pick the best set of shield options, unit position='..repru(oUnit:GetPosition())..'; iBestOptionCountRef='..(iBestOptionCountRef or 'nil')..'; tiShieldBuildLocationOptions for this='..repru(tiShieldBuildLocationOptions[iBestOptionCountRef])) end
                if iBestOptionCountRef then
                    oUnit[reftLocationsForPriorityShield] = {}
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording priority shield locations, tLocations='..repru(tiShieldBuildLocationOptions[iBestOptionCountRef])) end
                    for iLocation, tLocation in tiShieldBuildLocationOptions[iBestOptionCountRef] do
                        iRecordedCount = iRecordedCount + 1
                        table.insert(oUnit[reftLocationsForPriorityShield], {tLocation[1], tLocation[2], tLocation[3]})
                        --Blacklist the location
                        M28Engineer.RecordBlacklistLocation(tLocation, iNewBuildingRadius, 600, oUnit)
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Added shild build location '..repru(tLocation)..' against the game ender and will record blacklist, Will draw shield locations in black')
                            M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tLocation, iNewBuildingRadius), 3, 100)
                        end
                    end
                    --Add other shield locations if there are any and we want more to get to 3
                    if iRecordedCount < 3 then
                        for iShieldOption, tShieldLocations in tiShieldBuildLocationOptions do
                            if not(iShieldOption == iBestOptionCountRef) then
                                for iLocation, tLocation in tShieldLocations do
                                    if M28Engineer.CanBuildAtLocation(aiBrain, sBlueprintToBuild, tLocation, iPlateau, iLandZone, nil, false, true, true, true, false) then
                                        iRecordedCount = iRecordedCount + 1
                                        table.insert(oUnit[reftLocationsForPriorityShield], {tLocation[1], tLocation[2], tLocation[3]})
                                        --Blacklist the location
                                        M28Engineer.RecordBlacklistLocation(tLocation, iNewBuildingRadius, 600, oUnit)
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef..': Added further shild build location '..repru(tLocation)..' against the game ender and will record blacklist, Will draw shield location')
                                            M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tLocation, iNewBuildingRadius), 4, 100)
                                        end
                                    end
                                end
                            end
                        end
                    end

                    --Update any buildable locaitons around here
                    if iRecordedCount > 0 then
                        for iLocation, tLocation in oUnit[reftLocationsForPriorityShield] do
                            M28Engineer.CheckIfBuildableLocationsNearPositionStillValid(aiBrain, tLocation, true, 5)
                        end
                    end


                    --CLear any engineers with queued orders that will conflict with a shield location
                    local tEngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tEngineersInZone) == false then
                        local bClearEngineer
                        local tEngineersToClear = {}
                        for iEngineer, oEngineer in tEngineersInZone do
                            bClearEngineer = false
                            if M28Utilities.IsTableEmpty(oEngineer[M28Engineer.reftQueuedBuildings]) == false then
                                for iQueueRef, tQueueDetails in oEngineer[M28Engineer.reftQueuedBuildings] do
                                    if tQueueDetails[M28Engineer.subrefBuildingLocation] then
                                        for iReservedLocation, tReservedLocation in oUnit[reftLocationsForPriorityShield] do
                                            if M28Utilities.GetDistanceBetweenPositions(tReservedLocation, tQueueDetails[M28Engineer.subrefBuildingLocation]) - tQueueDetails[M28Engineer.subrefBuildingRadius] < 0 then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have queued building '..tQueueDetails[M28Engineer.subrefBuildingID]..' at location that is within '..M28Utilities.GetDistanceBetweenPositions(tReservedLocation, tQueueDetails[M28Engineer.subrefBuildingLocation])..' of a shield reserved location, with building radius of '..tQueueDetails[M28Engineer.subrefBuildingRadius]..' so will clear the engineer') end
                                                bClearEngineer = true
                                                table.insert(tEngineersToClear, oEngineer)
                                                break
                                            end
                                        end
                                        if bClearEngineer then break end
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of engineers to clear empty='..tostring(M28Utilities.IsTableEmpty(tEngineersToClear))) end
                        if M28Utilities.IsTableEmpty(tEngineersToClear) == false then
                            for iEngineer, oEngineer in tEngineersToClear do
                                M28Orders.IssueTrackedClearCommands(oEngineer)
                            end
                        end
                    end


                end
                --[[for iOption, tLocations in tiShieldBuildLocationOptions do
                    if (tiShieldBuildLocationOptions[iOption] or 0) >= iMostBuildLocations then
                        oUnit[reftLocationsForPriorityShield] = {}
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording priority shield locations, tLocations='..repru(tLocations)..'; tiShieldBuildLocationOptions[iOption]='..repru(tiShieldBuildLocationOptions[iOption])..'; iOption='..(iOption or 'nil')) end
                        for iLocation, tLocation in tLocations do
                            table.insert(oUnit[reftLocationsForPriorityShield], {tLocation[1], tLocation[2], tLocation[3]})
                            --Blacklist the location
                            M28Engineer.RecordBlacklistLocation(tLocation, iNewBuildingRadius, 600, oUnit)
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Will draw shield locations in black')
                                M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tLocation, iNewBuildingRadius), 3, 100)
                            end
                        end
                        break
                    end
                end--]]
                M28Team.tTeamData[aiBrain.M28Team][M28Team.refbStartedOnUnitWantingSpecialShielding] = true
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetBestFactionFactoryOfCategory(oUnitToGetTo, iCategory, iDistanceCap, iLandSubteam, iUnitPlateau, tLZData)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBestFactionFactoryOfCategory'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iClosestFactory = iDistanceCap
    local iCurDist, iCurPlateau, iCurLandZone, iCurZoneDist
    local iClosestZoneDist = iDistanceCap + 60
    local oBestFactory
    for iBrain, oBrain in M28Team.tLandSubteamData[iLandSubteam][M28Team.subreftoFriendlyM28Brains] do
        local tFactoriesOfCategory = oBrain:GetListOfUnits(iCategory, false, true)
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of factories of catory empty for brain '..oBrain.Nickname..'='..tostring(M28Utilities.IsTableEmpty(tFactoriesOfCategory))) end
        if M28Utilities.IsTableEmpty(tFactoriesOfCategory) == false then
            for iFactory, oFactory in tFactoriesOfCategory do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; Fraction complete='..oFactory:GetFractionComplete()..'; Is factory valid='..tostring(M28UnitInfo.IsUnitValid(oFactory))) end
                if oFactory:GetFractionComplete() == 1 and M28UnitInfo.IsUnitValid(oFactory) then
                    --Is this in the same plateau?
                    iCurPlateau, iCurLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oFactory:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': iCurPlateau='..(iCurPlateau or 'nil')..'; iUnitPlateau='..(iUnitPlateau or 'nil')) end
                    if iCurPlateau == iUnitPlateau then
                        --Get the travel distance
                        iCurZoneDist = tLZData[M28Map.subrefLZTravelDistToOtherLandZones][iCurPlateau][iCurLandZone]
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering factory with iCurZoneDist='..(iCurZoneDist or 'nil')..'; iClosestZoneDist='..iClosestZoneDist..'; Dist between factory and unit to cover='..M28Utilities.GetDistanceBetweenPositions(oUnitToGetTo:GetPosition(), oFactory:GetPosition())) end
                        if iCurZoneDist then
                            if iCurZoneDist <= iClosestZoneDist then
                                if iCurZoneDist < iClosestZoneDist then
                                    iClosestZoneDist = iCurZoneDist
                                    iClosestFactory = iDistanceCap + 100 --reset the distance so any factory in a closer zone will be preferred, even if the factory itself might be further away
                                end
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnitToGetTo:GetPosition(), oFactory:GetPosition())
                                if iCurDist < iClosestFactory then
                                    iClosestFactory = iCurDist
                                    oBestFactory = oFactory
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oBestFactory
end

function UnitNoLongerRequiresFactoryFactionShieldEngineers(oUnit)
    local oFactory = oUnit[refoNearbyFactoryOfFaction]
    if M28UnitInfo.IsUnitValid(oFactory) and M28Utilities.IsTableEmpty(oFactory[reftoUnitsWantingFactoryEngineers]) == false then
        for iEntry, oEntry in oFactory[reftoUnitsWantingFactoryEngineers] do
            if oEntry == oUnit then
                table.remove(oFactory[reftoUnitsWantingFactoryEngineers], iEntry)
                break
            end
        end
        oUnit[refoNearbyFactoryOfFaction] = nil
    end
end

function RecordNearbyFactoryForShieldEngineers(oUnit, tbOptionalFactionsWanted)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordNearbyFactoryForShieldEngineers'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iDistanceCap = 350 --Wont try and get engineers from factories further away than this.
    local aiBrain = oUnit:GetAIBrain()
    local iLandSubteam = aiBrain.M28LandSubteam
    local oBestFactory

    local iUnitPlateau, iUnitLandZone
    if oUnit[reftArtiTemplateRefs] then iUnitPlateau = oUnit[reftArtiTemplateRefs][1] iUnitLandZone = oUnit[reftArtiTemplateRefs][2]
    else
        iUnitPlateau, iUnitLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want a special factory for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; tbOptionalFactionsWanted='..repru(tbOptionalFactionsWanted)..'; iUnitPlateau='..(iUnitPlateau or 'nil')..'; iUnitLandZone='..(iUnitLandZone or 'nil')..'; Time='..GetGameTimeSeconds()) end
    if (iUnitLandZone or 0) > 0 then
        local tLZData = M28Map.tAllPlateaus[iUnitPlateau][M28Map.subrefPlateauLandZones][iUnitLandZone]
        --Seraphim factories
        if not(tbOptionalFactionsWanted) or tbOptionalFactionsWanted[M28UnitInfo.refFactionSeraphim] then
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have Seraphim T3 land on our land subteam, iLandSubteam='..iLandSubteam..'; M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionSeraphim]='..repru(M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionSeraphim])) end
            if (M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionSeraphim][3] or 0) > 0 then
                oBestFactory = GetBestFactionFactoryOfCategory(oUnit, M28UnitInfo.refCategoryLandFactory * categories.TECH3 * categories.SERAPHIM, iDistanceCap, iLandSubteam, iUnitPlateau, tLZData)
                if bDebugMessages == true then LOG(sFunctionRef..': oBestFactory after checking for seraphim='..(oBestFactory.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBestFactory) or 'nil')) end
            end
        end
        if not(oBestFactory) then
            --Aeon
            if not(tbOptionalFactionsWanted) or tbOptionalFactionsWanted[M28UnitInfo.refFactionAeon] then
                if (M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionAeon][3] or 0) > 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to try and get the best factory at time '..GetGameTimeSeconds()..'; iDistanceCap='..(iDistanceCap or 'nil')..'; iLandSubteam='..(iLandSubteam or 'nil')..'; iUnitPlateau='..(iUnitPlateau or 'nil')..'; is tLZData empty='..tostring(M28Utilities.IsTableEmpty(tLZData))) end
                    oBestFactory = GetBestFactionFactoryOfCategory(oUnit, M28UnitInfo.refCategoryLandFactory * categories.TECH3 * categories.AEON, iDistanceCap, iLandSubteam, iUnitPlateau, tLZData)
                end
            end
            if not(oBestFactory) then
                --UEF
                if not(tbOptionalFactionsWanted) or tbOptionalFactionsWanted[M28UnitInfo.refFactionUEF] then
                    if (M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionUEF][3] or 0) > 0 then
                        oBestFactory = GetBestFactionFactoryOfCategory(oUnit, M28UnitInfo.refCategoryLandFactory * categories.TECH3 * categories.UEF, iDistanceCap, iLandSubteam, iUnitPlateau, tLZData)
                    end
                end
                --If dont have any of these factions then dont worry about getting a faction specific shield
            end
        end
        --If have a best factory then record against the game ender
        oUnit[refoNearbyFactoryOfFaction] = oBestFactory
        if bDebugMessages == true then LOG(sFunctionRef..': Finished looking for nearby factories, oBestFactory='..(oBestFactory.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBestFactory) or 'nil')) end
        if oBestFactory then
            if not(oBestFactory[reftoUnitsWantingFactoryEngineers]) then
                oBestFactory[reftoUnitsWantingFactoryEngineers] = {}
            end

            table.insert(oBestFactory[reftoUnitsWantingFactoryEngineers], oUnit)
            local iFactoryPlateau, iFactoryLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oBestFactory:GetPosition())
            local tFactoryLZTeamData = M28Map.tAllPlateaus[iFactoryPlateau][M28Map.subrefPlateauLandZones][iFactoryLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
            local bRecordedInZoneAlready = false
            if not(tFactoryLZTeamData[M28Map.reftFactoriesWantedForEngineers]) then tFactoryLZTeamData[M28Map.reftFactoriesWantedForEngineers] = {}
            else
                for iExistingFactory, oExistingFactory in tFactoryLZTeamData[M28Map.reftFactoriesWantedForEngineers] do
                    if oExistingFactory == oBestFactory then
                        bRecordedInZoneAlready = true
                    end
                end
            end
            if not(bRecordedInZoneAlready) then
                table.insert(tFactoryLZTeamData[M28Map.reftFactoriesWantedForEngineers], oBestFactory)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RemoveFactoryFromZoneList(oFactory)
    --If a factory was assigned as providing engineers to a unit such as a gameender for shielding, it'd be recorded in the zone it was in - this removes it (e.g. intended where the factory ahs no units to assist, or the factory is dead)
    local iFactoryPlateau, iFactoryLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oFactory:GetPosition())
    if iFactoryLandZone > 0 then
        local tLZTeamData = M28Map.tAllPlateaus[iFactoryPlateau][M28Map.subrefPlateauLandZones][iFactoryLandZone][M28Map.subrefLZTeamData][oFactory:GetAIBrain().M28Team]
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftFactoriesWantedForEngineers]) == false then
            local iExistingEntries = table.getn(tLZTeamData[M28Map.reftFactoriesWantedForEngineers])
            for iCurEntry = iExistingEntries, 1, -1 do
                if tLZTeamData[M28Map.reftFactoriesWantedForEngineers][iCurEntry] == oFactory or not(M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.reftFactoriesWantedForEngineers][iCurEntry])) then
                    table.remove(tLZTeamData[M28Map.reftFactoriesWantedForEngineers], iCurEntry)
                end
            end
        end
    end
end

function ClearTrackingOfDeadUnitWantingFactoryEngineers(oUnit)
    --If a gameender had a factory assigned as providing engineers e.g. for shielding, and the gameender is dead, then this clears related tracking
    if M28Utilities.IsTableEmpty(oUnit[refoNearbyFactoryOfFaction][reftoUnitsWantingFactoryEngineers]) == false then
        local oFactory = oUnit[refoNearbyFactoryOfFaction]
        local iExistingEntries = table.getn(oFactory[reftoUnitsWantingFactoryEngineers])
        for iCurEntry = iExistingEntries, 1, -1 do
            if oFactory[reftoUnitsWantingFactoryEngineers][iCurEntry] == oUnit or not(M28UnitInfo.IsUnitValid(oFactory[reftoUnitsWantingFactoryEngineers][iCurEntry])) then
                table.remove(oFactory[reftoUnitsWantingFactoryEngineers], iCurEntry)
            end
        end
        if M28Utilities.IsTableEmpty(  oFactory[reftoUnitsWantingFactoryEngineers]) then
            RemoveFactoryFromZoneList(oFactory)
        end
    end
    --Remove this unit from the zone
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
    local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) == false then
        local iTotalEntries = table.getn(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection])
        for iCurEntry = iTotalEntries, 1, -1 do
            if tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection][iCurEntry] == oUnit or not(M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection][iCurEntry])) then
                table.remove(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection], iCurEntry)
            end
        end
    end
end

function UpdateTrackingOfDeadFactoryProvidingEngineers(oUnit)
    --If a factory that was providing engineers e.g. to a gameender for shielding dies, this updates the tracking variables and looks for a new factory to provide engineers
    local iExistingEntries = table.getn(oUnit[reftoUnitsWantingFactoryEngineers])
    for iCurEntry = iExistingEntries, 1, -1 do
        if oUnit[reftoUnitsWantingFactoryEngineers][iCurEntry][refoNearbyFactoryOfFaction] == oUnit then
            oUnit[reftoUnitsWantingFactoryEngineers][iCurEntry][refoNearbyFactoryOfFaction] = nil
            if M28UnitInfo.IsUnitValid(oUnit[reftoUnitsWantingFactoryEngineers][iCurEntry]) then
                --Get a new 'best factory to provide engineers' for the game ender
                RecordNearbyFactoryForShieldEngineers(oUnit[reftoUnitsWantingFactoryEngineers][iCurEntry])
            end
        end
    end
    --Remove this factory from the list of factories in the zone
    oUnit[reftoUnitsWantingFactoryEngineers] = nil
    RemoveFactoryFromZoneList(oUnit)
end

function AssignShieldToGameEnder(oConstruction, oEngineer, oOptionalBackupGameEnderToAssignTo)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignShieldToGameEnder'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oConstruction:GetPosition())

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at game time '..GetGameTimeSeconds()..'; oConstruction='..(oConstruction.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oConstruction) or 'nil')..'; oEngineer='..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil')..'; oConstruction iPlateau='..(iPlateau or 'nil')..'; Zone='..(iLandZone or 'nil')..'; oConstruction position='..repru(oConstruction:GetPosition())) end
    if (iLandZone or 0) > 0 then
        local oGameEnder
        local aiBrain = oEngineer:GetAIBrain()
        local iTeam = aiBrain.M28Team
        local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
        if not(oEngineer[M28Engineer.refoUnitActivelyShielding]) then
            oGameEnder = oOptionalBackupGameEnderToAssignTo
            if not(oGameEnder) then
                M28Utilities.ErrorHandler('Dont have a unit recorded that the engineer is actively shielding, will just get the first gameender in the zone')
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) == false then
                    for iUnit, oUnit in tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
                        oGameEnder = oUnit
                        break
                    end
                end
            end
        else
            oGameEnder = oEngineer[M28Engineer.refoUnitActivelyShielding]
            if bDebugMessages == true then LOG(sFunctionRef..': Engineer is actively shielding oGameEnder='..(oGameEnder.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oGameEnder) or 'nil')) end
        end
        if M28UnitInfo.IsUnitValid(oGameEnder) then
            if not(oGameEnder[reftoSpecialAssignedShields]) then
                oGameEnder[reftoSpecialAssignedShields] = {}
            end
            table.insert(oGameEnder[reftoSpecialAssignedShields], oConstruction)
            oConstruction[refoGameEnderBeingShielded] = oGameEnder
            if bDebugMessages == true then LOG(sFunctionRef..': Added oConstruction to the table of assigned shields for gameender') end
        else
            if oGameEnder then
                M28Utilities.ErrorHandler('Dont have a valid unit')
            end
        end
    else
        M28Utilities.ErrorHandler('Dont have valid land zone for construction')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateForNukeMissileDeath(oLauncher, tOptionalLikelyTarget)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateForNukeMissileDeath'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start at time ='..GetGameTimeSeconds()..'; oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..'; oLauncher[reftActiveNukeTarget] before reset='..repru(oLauncher[reftActiveNukeTarget])) end
    oLauncher[reftActiveNukeTarget] = nil

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function DetermineBuildingExpectedValues()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DetermineBuildingExpectedValues'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local tsT1EnergyStorageBlueprints = EntityCategoryGetUnitList(M28UnitInfo.refCategoryEnergyStorage)
    local iLowestTechTier = 5
    local iHighestEnergyStored = 0
    local iCurTechLevel
    if M28Utilities.IsTableEmpty(tsT1EnergyStorageBlueprints) == false then
        for _, sBlueprint in tsT1EnergyStorageBlueprints do
            local oBP = __blueprints[sBlueprint]
            if (oBP.Economy.StorageEnergy or 0) > 0 then
                iCurTechLevel = M28UnitInfo.GetBlueprintTechLevel(sBlueprint)
                if iCurTechLevel < iLowestTechTier then
                    iLowestTechTier = iCurTechLevel
                    iHighestEnergyStored = oBP.Economy.StorageEnergy
                elseif iCurTechLevel == iLowestTechTier and iHighestEnergyStored < oBP.Economy.StorageEnergy then
                    iHighestEnergyStored = oBP.Economy.StorageEnergy
                end
            end
        end
    end
    iEnergyStorageExpectedCapacity = (iHighestEnergyStored or 5000)
    if bDebugMessages == true then LOG(sFunctionRef..': end of code, iHighestEnergyStored='..iHighestEnergyStored..'; iLowestTechTier='..iLowestTechTier) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedConsiderLaunchingMissile(oLauncher, iSecondsToWait, bCheckIfStillLoaded, bOnlyConsiderIfNotFiredRecently)
    --Call via forkthread
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DelayedConsiderLaunchingMissile'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitSeconds(iSecondsToWait)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28UnitInfo.IsUnitValid(oLauncher) then
        local bProceed = true
        if bCheckIfStillLoaded then
            bProceed = false
            local iMissiles = 0
            if oLauncher.GetTacticalSiloAmmoCount then iMissiles = iMissiles + oLauncher:GetTacticalSiloAmmoCount() end
            if oLauncher.GetNukeSiloAmmoCount then iMissiles = iMissiles + oLauncher:GetNukeSiloAmmoCount() end
            if iMissiles > 0 then bProceed = true end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Dealing with oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..'; bProceed='..tostring(bProceed)..'; Time='..GetGameTimeSeconds()) end
        if bProceed then
            if bDebugMessages == true then LOG(sFunctionRef..': Time since last weapon event='..(GetGameTimeSeconds() - oLauncher[M28UnitInfo.refiLastWeaponEvent] or -100)..'; iSecondsToWait='..iSecondsToWait..'; bOnlyConsiderIfNotFiredRecently='..tostring(bOnlyConsiderIfNotFiredRecently or false)) end
            if not(bOnlyConsiderIfNotFiredRecently) or GetGameTimeSeconds() - (oLauncher[M28UnitInfo.refiLastWeaponEvent] or -100) > iSecondsToWait then
                if bDebugMessages == true then LOG(sFunctionRef..': Will consider launching a missile') end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                --LOG('consideration of launching missile 4')
                ConsiderLaunchingMissile(oLauncher)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AreUnitsAdjacent(oFirstUnit, oSecondUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AreUnitsAdjacent'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iFirstUnitSize = M28UnitInfo.GetBuildingSize(oFirstUnit.UnitId) * 0.5
    local iSecondUnitSize = M28UnitInfo.GetBuildingSize(oSecondUnit.UnitId) * 0.5
    local iMaxDif = iFirstUnitSize + iSecondUnitSize + 0.749 --assumed margin of error after where got to with mexes (where would go with 2.749 distance)
    local iMinDif = iFirstUnitSize + iSecondUnitSize - 0.749

    local iXDif = math.abs(oFirstUnit:GetPosition()[1] - oSecondUnit:GetPosition()[1])
    local iZDif = math.abs(oFirstUnit:GetPosition()[3] - oSecondUnit:GetPosition()[3])
    if bDebugMessages == true then LOG(sFunctionRef..': Considering oFirstUnit='..oFirstUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFirstUnit)..'; Position='..repru(oFirstUnit:GetPosition())..'; Size='..iFirstUnitSize..'; Second unit='..oSecondUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSecondUnit)..'; oSecondUnit position='..repru(oSecondUnit:GetPosition())..'; iSecondUnitSize='..iSecondUnitSize..'; iXDif='..iXDif..'; iZDif='..iZDif) end
    if (iXDif <= iMaxDif and iXDif >= iMinDif) or (iZDif <= iMaxDif and iZDif >= iMinDif) then
        --Are we in a corner position?
        --[[local iCornerDif = iFirstUnitSize + iSecondUnitSize - 0.1
        if bDebugMessages == true then LOG(sFunctionRef..': Units are close to each other, iXDif='..iXDif..'; iZDif='..iZDif..'; iCornerDif='..iCornerDif) end
        if iXDif < iCornerDif or iZDif < iCornerDif then--]]
        --Max smallest dif due to size dif
        local iMaxSmallestDif = math.abs(iFirstUnitSize - iSecondUnitSize) + 0.749
        if iXDif < iMaxSmallestDif or iZDif < iMaxSmallestDif then


            if bDebugMessages == true then LOG(sFunctionRef..': Units are adjacent') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end
        --end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Units are adjacent') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function ConsiderGiftingPowerToTeammateForAdjacency(oUnit)
    --Call when a t3 power has been constructed by an M28 brain
    --WARNING: Not tested fully, so only gives a rough approximation.  do further testing if more accuracy needed

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderGiftingPowerToTeammateForAdjacency'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Wait 1s, and then check if unit is upgrading and is still valid, as otherwise can have issues
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitSeconds(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then
        if M28UnitInfo.IsUnitValid(oUnit) then
            LOG(sFunctionRef..': Valid unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..' at time='..GetGameTimeSeconds()..'; Unit state='..M28UnitInfo.GetUnitState(oUnit))
        else LOG(sFunctionRef..': Unit is no longer valid, unit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil'))
        end
    end
    if M28UnitInfo.IsUnitValid(oUnit) and not(oUnit:IsUnitState('Upgrading')) and not(oUnit:IsUnitState('BeingUpgraded')) then
        local aiBrain = oUnit:GetAIBrain()
        local iTeam = aiBrain.M28Team
        if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 then
            local iPotentialAdjacencyCategories = M28UnitInfo.refCategoryExperimentalLevel + M28UnitInfo.refCategoryAirFactory + M28UnitInfo.refCategoryStructure * categories.TECH3

            if EntityCategoryContains(M28UnitInfo.refCategoryT3Power, oUnit.UnitId) then
                --Are we adjacent to any air factories, omni, nuke launchers, t3 arti, owned by another teammate, and have no adjacency of such units on our own?

                if bDebugMessages == true then LOG(sFunctionRef..': is table of adjacent units empty='..tostring(M28Utilities.IsTableEmpty(oUnit.AdjacentUnits))) end
                if M28Utilities.IsTableEmpty(oUnit.AdjacentUnits) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(iPotentialAdjacencyCategories, oUnit.AdjacentUnits)) then
                    --We have no existing adjacency
                    local tNearbyUnitsOfInterest = aiBrain:GetUnitsAroundPoint(iPotentialAdjacencyCategories, oUnit:GetPosition(), M28UnitInfo.GetBuildingSize(oUnit.UnitId) + 1, 'Ally')
                    if M28Utilities.IsTableEmpty(tNearbyUnitsOfInterest) == false then
                        for iNearbyUnit, oNearbyUnit in tNearbyUnitsOfInterest do
                            if not(oNearbyUnit:GetAIBrain() == aiBrain) and oNearbyUnit:GetAIBrain().M28Team == iTeam and (oNearbyUnit:GetAIBrain().M28AI or ScenarioInfo.Options.M28Teammate == 1) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oNearbyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearbyUnit)..'; Position='..repru(oNearbyUnit:GetPosition())..'; oUnit position='..repru(oUnit:GetPosition())) end
                                if AreUnitsAdjacent(oUnit, oNearbyUnit) then
                                    --Gift to other brain
                                    M28Team.TransferUnitsToPlayer({oUnit}, oNearbyUnit:GetAIBrain():GetArmyIndex(), false)
                                    break
                                end
                            end
                        end
                    end
                end
            else
                local iSpecificAdjacencyCategories = M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti - categories.MOBILE + M28UnitInfo.refCategorySML * categories.TECH3 + M28UnitInfo.refCategoryAirFactory * categories.TECH3 + M28UnitInfo.refCategoryMassFab * categories.TECH3 + M28UnitInfo.refCategoryT3Radar
                if EntityCategoryContains(iSpecificAdjacencyCategories, oUnit.UnitId) then
                    if bDebugMessages == true then LOG(sFunctionRef..': is table of adjacent units empty='..tostring(M28Utilities.IsTableEmpty(oUnit.AdjacentUnits))) end
                    if M28Utilities.IsTableEmpty(oUnit.AdjacentUnits) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryT3Power, oUnit.AdjacentUnits)) then
                        --We have no existing adjacency
                        local tNearbyUnitsOfInterest = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryT3Power, oUnit:GetPosition(), M28UnitInfo.GetBuildingSize(oUnit.UnitId) + 1, 'Ally')
                        if M28Utilities.IsTableEmpty(tNearbyUnitsOfInterest) == false then
                            for iNearbyUnit, oNearbyUnit in tNearbyUnitsOfInterest do
                                if not(oNearbyUnit:GetAIBrain() == aiBrain) and oNearbyUnit:GetAIBrain().M28Team == iTeam and (oNearbyUnit:GetAIBrain().M28AI or ScenarioInfo.Options.M28Teammate == 1) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oNearbyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearbyUnit)..'; Position='..repru(oNearbyUnit:GetPosition())..'; oUnit position='..repru(oUnit:GetPosition())) end
                                    if AreUnitsAdjacent(oUnit, oNearbyUnit) then
                                        --Gift nearby t3 power to this unit's brain owner
                                        M28Team.TransferUnitsToPlayer({oNearbyUnit}, oUnit:GetAIBrain():GetArmyIndex(), false)
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function JustBuiltParagon(oParagon)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'JustBuiltParagon'

    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28UnitInfo.IsUnitValid(oParagon) then
        if bDebugMessages == true then LOG(sFunctionRef..': oParagon owner='..oParagon:GetAIBrain().Nickname..'; Unit='..oParagon.UnitId..M28UnitInfo.GetUnitLifetimeCount(oParagon)..'; GameTime='..GetGameTimeSeconds()..'; Fraction complete='..oParagon:GetFractionComplete()..'; oParagon(M28BuiltParagon)='..tostring(oParagon['M28BuiltParagon'] or false)) end
        if not(oParagon['M28BuiltParagon']) then
            oParagon['M28BuiltParagon'] = true
            local aiBrain = oParagon:GetAIBrain()
            local iTeam = aiBrain.M28Team
            local oOtherBrain
            local bGiftedParagonToOtherBrain = false
            if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 then
                --If we now own 2+ paragons, then gift this to a teammate
                if bDebugMessages == true then LOG(sFunctionRef..': Cur paragon units owned by brain='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryParagon)) end
                if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryParagon) >= 2 then
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        if not(oBrain == aiBrain) and not(oBrain.M28IsDefeated) and not(oBrain[M28Economy.refbBuiltParagon]) then
                            if oBrain[M28Economy.refiGrossMassBaseIncome] <= 500 and oBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryEngineer) >= 2 then
                                oOtherBrain = oBrain
                                break
                            end
                        end
                    end
                    if not(oOtherBrain) and ScenarioInfo.Options.M28Teammate == 1 then
                        for iBrain, oBrain in ArmyBrains do
                            if oBrain.M28Team == iTeam and not(oBrain.M28AI) and not(oBrain[M28Economy.refbBuiltParagon]) and not(oBrain.CampaignAI) and oBrain[M28Economy.refiGrossMassBaseIncome] <= 500 and not(oBrain.M28IsDefeated) and oBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryEngineer) >= 3 and oBrain:GetCurrentUnits(M28UnitInfo.refCategoryParagon) == 0 then
                                oOtherBrain = oBrain
                                break
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is oOtherBrain nil='..tostring(oOtherBrain == nil)) end
                    if oOtherBrain then
                        bGiftedParagonToOtherBrain = true
                        if (M28Orders.bDontConsiderCombinedArmy or oParagon.M28Active) then
                            local tUnitsToGift = {oParagon}
                            M28Team.TransferUnitsToPlayer(tUnitsToGift, oOtherBrain:GetArmyIndex(), false)
                            if not(oOtherBrain.M28AI) then
                                M28Chat.SendMessage(aiBrain, 'ParagGift'..aiBrain:GetArmyIndex(), 'You look like you could use this resource generator more than me', 0, 300, true, true, nil, nil)
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Have gifted paragon to teammate') end
                        end
                    end
                end
                if not(bGiftedParagonToOtherBrain) then


                    --Gift mexes, mass storage, RAS SACUs, and half of our pgens to another teammate
                    local iMaxEngineersToGift = math.min(aiBrain[M28Overseer.refiExpectedRemainingCap] * 0.5, 30)
                    local iEngineersGifted = 0
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        if not(oBrain == aiBrain) and not(oBrain.M28IsDefeated) then
                            if oBrain[M28Economy.refiGrossMassBaseIncome] <= 500 then
                                oOtherBrain = oBrain
                                --Gift all non-land factories (retain land so we still build some units), fatboys, nukes, SMD, aircraft carriers
                                local tFactoriesToGift = oBrain:GetListOfUnits(M28UnitInfo.refCategoryNavalFactory + M28UnitInfo.refCategoryAirFactory + M28UnitInfo.refCategoryQuantumGateway + M28UnitInfo.refCategorySML + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryCarrier + M28UnitInfo.refCategoryHive, false, true)
                                if M28Utilities.IsTableEmpty(tFactoriesToGift) == false then
                                    local tUnitsToGift = {}
                                    for iUnit, oUnit in tFactoriesToGift do
                                        if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then
                                            table.insert(tUnitsToGift, oUnit)
                                        end
                                    end
                                    if M28Utilities.IsTableEmpty(tUnitsToGift) == false then
                                        M28Team.TransferUnitsToPlayer(tUnitsToGift, aiBrain:GetArmyIndex(), false)
                                    end
                                end
                                if iEngineersGifted < iMaxEngineersToGift then
                                    local tEngineersAvailable = oBrain:GetListOfUnits(M28UnitInfo.refCategoryEngineer, false, true)
                                    if M28Utilities.IsTableEmpty(tEngineersAvailable) == false then
                                        local tEngineersToGift = {}
                                        local iCurCount = 0


                                        for iUnit, oUnit in tEngineersAvailable do
                                            iCurCount = iCurCount + 1
                                            if iCurCount >= 2 then
                                                if not(oUnit:IsUnitState('Attached')) and not(oUnit[M28Engineer.refbPrimaryBuilder]) then
                                                    table.insert(tEngineersToGift, oUnit)
                                                    iEngineersGifted = iEngineersGifted + 1
                                                    if iEngineersGifted >= iMaxEngineersToGift then break end
                                                end
                                                iCurCount = 0
                                            end

                                        end
                                        if M28Utilities.IsTableEmpty(tEngineersToGift) == false then
                                            M28Team.TransferUnitsToPlayer(tEngineersToGift, aiBrain:GetArmyIndex(), false)
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if not(oOtherBrain) and ScenarioInfo.Options.M28Teammate == 1 then
                --Do we have other (non-M28) teammates we can gift to, that aren't campaign AI?
                local oFirstTeammateBrain
                local oFirstHumanBrain
                for iBrain, oBrain in ArmyBrains do
                    if not(oBrain.M28IsDefeated) and not(oBrain:IsDefeated()) and oBrain.M28Team == aiBrain.M28Team and not(oBrain == aiBrain) and not(oBrain.CampaignAI) then
                        if not(oFirstTeammateBrain) then oFirstTeammateBrain = oBrain end
                        if not(oBrain.BrainType == 'AI') and not(oFirstHumanBrain) then
                            oFirstHumanBrain = oBrain
                            break
                        end
                    end
                end
                if oFirstHumanBrain then oOtherBrain = oFirstHumanBrain else oOtherBrain = oFirstTeammateBrain end
            end
            if oOtherBrain and not(bGiftedParagonToOtherBrain) then
                local tUnitsToGift = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryT1Power + M28UnitInfo.refCategoryT2Power + M28UnitInfo.refCategoryMassStorage + M28UnitInfo.refCategoryRASSACU, false, true)
                if M28Utilities.IsTableEmpty(tUnitsToGift) then
                    tUnitsToGift = {}
                end
                local tT3Power = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryT3Power, false, true)
                if M28Utilities.IsTableEmpty(tT3Power) == false then
                    local iCurCount = -1
                    local iGiftThreshold = 1
                    for iUnit, oUnit in tT3Power do
                        iCurCount = iCurCount + 1
                        if iCurCount >= iGiftThreshold then
                            iCurCount = 0
                            table.insert(tUnitsToGift, oUnit)
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tUnitsToGift) == false then
                    M28Team.TransferUnitsToPlayer(tUnitsToGift, oOtherBrain:GetArmyIndex(), false)
                    if not(oOtherBrain.M28AI) then
                        M28Chat.SendMessage(aiBrain, 'ParagGift'..aiBrain:GetArmyIndex(), 'You look like you could use these resource buildings more than me', 0, 300, true, true, nil, nil)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function ConsiderManualT2ArtiTarget(oArti, oOptionalWeapon, iOptionalDelaySecondsAndWeaponFireCheck)
    --Considers giving manual orders to the T2 arti, so e.g. can use aoe and shot firing randomness to damage enemy shields just outside of our range

    --oOptionalWeapon - if called from the weapon fire event then this means we can check our last target
    --iOptionalDelaySecondsAndWeaponFireCheck - if specified, then will wait this many seconds then check if we have fired since the code started, and if not then proceed (used so if we are targeting a mobile unit and it goes out of our range we arent stuck with an invalid fire order)
    local sFunctionRef = 'ConsiderManualT2ArtiTarget'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if not(oArti[M28UnitInfo.refbEasyBrain]) then
        local bProceedWithLogic = true
        if iOptionalDelaySecondsAndWeaponFireCheck then
            --e.g. we have targeted a mobile unit, so only check again if we have failed to fire recently
            bProceedWithLogic = false
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(iOptionalDelaySecondsAndWeaponFireCheck)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if not(oArti[M28UnitInfo.refiLastWeaponEvent]) or GetGameTimeSeconds() - oArti[M28UnitInfo.refiLastWeaponEvent] >= iOptionalDelaySecondsAndWeaponFireCheck - 0.01 then
                bProceedWithLogic = true
            end
        elseif oArti[M28UnitInfo.refiTimeBetweenIFShots] and GetGameTimeSeconds() - (oArti[M28UnitInfo.refiLastWeaponEvent] or -100) < oArti[M28UnitInfo.refiTimeBetweenIFShots] - 2 then
            if bDebugMessages == true then LOG(sFunctionRef..': Want to wait until Arti almost ready to fire before choosing the next target, oArti[M28UnitInfo.refiTimeBetweenIFShots]='..(oArti[M28UnitInfo.refiTimeBetweenIFShots] or 'nil')..'; Time since last weapn event='..(GetGameTimeSeconds() - (oArti[M28UnitInfo.refiLastWeaponEvent] or -100))) end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(math.min(oArti[M28UnitInfo.refiTimeBetweenIFShots] - 2, oArti[M28UnitInfo.refiTimeBetweenIFShots] -2 - (GetGameTimeSeconds() - (oArti[M28UnitInfo.refiLastWeaponEvent] or -100))))
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to proceed for oArti='..(oArti.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oArti) or 'nil')..'; Is oArti valid='..tostring(M28UnitInfo.IsUnitValid(oArti))..'; bProceedWithLogic='..tostring(bProceedWithLogic)..'; iOptionalDelaySecondsAndWeaponFireCheck='..(iOptionalDelaySecondsAndWeaponFireCheck or 'nil')..'; Is oOptionalWeapon nil='..tostring(oOptionalWeapon == nil)..'; Time='..GetGameTimeSeconds()) end
        if bProceedWithLogic and M28UnitInfo.IsUnitValid(oArti) then


            local bGivenOrder = false
            local tLastTarget
            if oOptionalWeapon.GetCurrentTarget then
                local vLastTarget = oOptionalWeapon:GetCurrentTarget()
                if vLastTarget.GetPosition then
                    tLastTarget = vLastTarget:GetPosition()
                elseif vLastTarget[1] and vLastTarget[3] and not(vLastTarget[4]) then
                    tLastTarget = {vLastTarget[1], vLastTarget[2], vLastTarget[3]}
                end
            end

            --Are there T2 arti nearby? if so then want to target the closest t2 arti or shield covering the t2 arti
            local aiBrain = oArti:GetAIBrain()
            local iTeam = aiBrain.M28Team
            local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oArti:GetPosition(), true, iTeam)
            local oClosestTargetOfInterest
            local iClosestTargetOfInterest
            if not(oArti[M28UnitInfo.refiIndirectRange]) then
                M28Utilities.ErrorHandler('Dont have indirect fire range for T2 Arti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti))
                iClosestTargetOfInterest = 115 + 30
            else
                iClosestTargetOfInterest = oArti[M28UnitInfo.refiIndirectRange] + 30 --wont bother trying to fire at something further away than this (and in some cases will need to be closer - ie.. depends on shielding situation)
            end
            local iCurDist
            local tArtiPosition = oArti:GetPosition()
            --Set the min range so we avoid targets inside this
            local iMinRange = oArti[M28UnitInfo.refiArtiMinRange]
            if not(iMinRange) then
                if oOptionalWeapon then
                    oArti[M28UnitInfo.refiArtiMinRange] = (oOptionalWeapon.MinRadius or 1)
                else
                    for iWeapon, tWeapon in oArti:GetBlueprint().Weapon do
                        if tWeapon.MinRadius then
                            oArti[M28UnitInfo.refiArtiMinRange] = tWeapon.MinRadius
                            break
                        end
                    end
                    iMinRange = oArti[M28UnitInfo.refiArtiMinRange]
                    if not(iMinRange) then
                        iMinRange = math.min(oArti[M28UnitInfo.refiIndirectRange] * 0.7, 50)
                    end
                end
            end
            local iCurTargetSegmentX, iCurTargetSegmentZ
            local bDontConsiderBlockedShots = M28Utilities.IsTableEmpty(oArti[reftbTerrainBlockedTargetsBySegment])
            function UpdateClosestUnit(tUnits)
                for iUnit, oUnit in tUnits do
                    if not(oUnit.Dead) then
                        --Check unit is on land and not attached
                        if not(oUnit:IsUnitState('Attached')) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tArtiPosition)
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurDist='..repru(iCurDist)..'; iClosestTargetOfInterest='..repru(iClosestTargetOfInterest)..'; iMinRange='..repru(iMinRange)) end
                            if iCurDist < iClosestTargetOfInterest and iCurDist >= iMinRange then
                                if bDontConsiderBlockedShots then
                                    iClosestTargetOfInterest = iCurDist
                                    oClosestTargetOfInterest = oUnit
                                else
                                    --Check are shot isnt likely to be blocked
                                    iCurTargetSegmentX, iCurTargetSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnit:GetPosition())
                                    if bDebugMessages == true then LOG(sFunctionRef..': Is Cur target expected to be blocked='..tostring(oArti[reftbTerrainBlockedTargetsBySegment][iCurTargetSegmentX][iCurTargetSegmentZ] or false)) end
                                    if not(oArti[reftbTerrainBlockedTargetsBySegment][iCurTargetSegmentX][iCurTargetSegmentZ]) then
                                        --This doesnt cover the scenario where taret is out of our range; however since we prioritise the closest unit, to stick with that target means we have no targets in our range, so am ok not covering that eventuality
                                        iClosestTargetOfInterest = iCurDist
                                        oClosestTargetOfInterest = oUnit
                                    end
                                end
                            end
                        end
                    end
                end
            end

            --First consider enemy fatboys
            if (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0) > 0 then
                UpdateClosestUnit(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats])
            end

            if not(oClosestTargetOfInterest) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
                --Enemy has t2 arti nearby so consider groundfiring units unless they have a fatboy nearby
                UpdateClosestUnit(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits])
            end

            if not(oClosestTargetOfInterest) and tLastTarget then
                --No T2 arti but we were firing at something before, so check if any enemy shields or T2 arti or ravagers around the arti and (if so) if we want to ground fire them
                local tNearbyUnitsOfInterest = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryMissileShip + M28UnitInfo.refCategoryPD * categories.TECH3, tArtiPosition, iClosestTargetOfInterest - 1, 'Enemy')
                if M28Utilities.IsTableEmpty(tNearbyUnitsOfInterest) == false then
                    UpdateClosestUnit(tNearbyUnitsOfInterest)
                end
                if not(oClosestTargetOfInterest) then
                    tNearbyUnitsOfInterest = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryIndirectT2Plus + M28UnitInfo.refCategoryT2PlusPD + M28UnitInfo.refCategoryTMD + M28UnitInfo.refCategoryTML, oArti:GetPosition(), iClosestTargetOfInterest - 1, 'Enemy')
                    if M28Utilities.IsTableEmpty(tNearbyUnitsOfInterest) == false then
                        UpdateClosestUnit(tNearbyUnitsOfInterest)
                    end
                end
            end

            --If we have a unit consider attacking it, or groundfiring if it is out of our range
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for main target, oClosestTargetOfInterest='..(oClosestTargetOfInterest.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestTargetOfInterest) or 'nil')..'; iClosestTargetOfInterest='..iClosestTargetOfInterest) end
            if oClosestTargetOfInterest then
                --Is it covered by a fixed shield? if so then switch target to the closest shield that is covering it
                if M28Utilities.IsTableEmpty(oClosestTargetOfInterest[reftoShieldsProvidingCoverage]) == false then
                    local iOrigUnitDist = iClosestTargetOfInterest
                    local oOrigUnitTarget = oClosestTargetOfInterest
                    iClosestTargetOfInterest = 100000
                    UpdateClosestUnit(oClosestTargetOfInterest[reftoShieldsProvidingCoverage])
                    if iClosestTargetOfInterest >= 100000 then --Redundancy (e.g. shot might be blocked on the shield but not the unit being shielded)
                        iClosestTargetOfInterest = iOrigUnitDist
                        oClosestTargetOfInterest = oOrigUnitTarget
                    elseif bDebugMessages == true then LOG(sFunctionRef..': Original target was covered by a fixed shield so will target the shield instead, revised target='..oOrigUnitTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOrigUnitTarget)..'; iOrigUnitDist='..iOrigUnitDist)
                    end
                end

                --If target is out of our range then check if the planned target is in range
                local tGroundFireTarget
                if iClosestTargetOfInterest > oArti[M28UnitInfo.refiIndirectRange] then
                    if oClosestTargetOfInterest.MyShield or iClosestTargetOfInterest <= oArti[M28UnitInfo.refiIndirectRange] + 20 then
                        local iDistShortfall = 1
                        local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
                        if GetGameTimeSeconds() - (oArti[M28Events.refiLastWeaponEvent] or -100) >= 25 then iDistShortfall = 3 end --greater dist threshold in case are trying to fire at elevated position

                        tGroundFireTarget = M28Utilities.MoveInDirection(tArtiPosition, M28Utilities.GetAngleFromAToB(tArtiPosition, oClosestTargetOfInterest:GetPosition()), (oArti[M28UnitInfo.refiIndirectRange] or 115) - iDistShortfall, true, false, M28Map.bIsCampaignMap)
                        --Is shot blocked for this?
                        iCurTargetSegmentX, iCurTargetSegmentZ = M28Map.GetPathingSegmentFromPosition(tGroundFireTarget)

                        if bDebugMessages == true then LOG(sFunctionRef..': Is ground fire expected target expected to be blocked='..tostring(oArti[reftbTerrainBlockedTargetsBySegment][iCurTargetSegmentX][iCurTargetSegmentZ] or false)) end
                        if oArti[reftbTerrainBlockedTargetsBySegment][iCurTargetSegmentX][iCurTargetSegmentZ] then
                            tGroundFireTarget = nil
                            --Try searching for any enemy non-mobile air target
                            local tAllInRangeEnemyUnits = aiBrain:GetUnitsAroundPoint(categories.ALLUNITS - categories.MOBILE * categories.AIR, oArti:GetPosition(), oArti[M28UnitInfo.refiIndirectRange], 'Enemy')
                            if M28Utilities.IsTableEmpty(tAllInRangeEnemyUnits) == false then
                                local oOldClosestUnit = oClosestTargetOfInterest
                                UpdateClosestUnit(tAllInRangeEnemyUnits)
                                if oClosestTargetOfInterest == oOldClosestUnit then
                                    if bDebugMessages == true then LOG(sFunctionRef..': No targets in range that dont ahve blocked shots') end
                                    oClosestTargetOfInterest = nil
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will switch to the target '..oClosestTargetOfInterest.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestTargetOfInterest)) end
                                end
                            end
                        end
                    end
                end
                if oClosestTargetOfInterest then

                    --Now have selcted the unit we want to target - if its in our range then issue an attack order, otherwise issue a ground fire order
                    local bTargetingMobileUnit = EntityCategoryContains(categories.MOBILE, oClosestTargetOfInterest.UnitId)
                    bGivenOrder = true
                    --Consider whether to ground fire
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to do ground fire attack; iClosestTargetOfInterest='..iClosestTargetOfInterest..'; oArti[M28UnitInfo.refiIndirectRange]='..(oArti[M28UnitInfo.refiIndirectRange] or 'nil')) end
                    if iClosestTargetOfInterest <= oArti[M28UnitInfo.refiIndirectRange] then
                        if bDebugMessages == true then LOG(sFunctionRef..': Can we see the oClosestTargetOfInterest='..tostring(M28UnitInfo.CanSeeUnit(aiBrain, oClosestTargetOfInterest, false))..'; oClosestTargetOfInterest='..(oClosestTargetOfInterest.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestTargetOfInterest) or 'nil')) end
                        if M28UnitInfo.CanSeeUnit(aiBrain, oClosestTargetOfInterest, false) then
                            M28Orders.IssueTrackedAttack(oArti, oClosestTargetOfInterest, false, 'ArtAt', false)
                        else
                            M28Orders.IssueTrackedGroundAttack(oArti, oClosestTargetOfInterest:GetPosition(), 0.1, false, 'ArtXG', false, oClosestTargetOfInterest)
                            if bDebugMessages == true then LOG(sFunctionRef..': Will do ground attack as cant see the unit') end
                        end
                    else
                        --Ground fire as target is out of our range; dont even try ground firing if its not a shield and is well outside our range
                        if tGroundFireTarget then
                            M28Orders.IssueTrackedGroundAttack(oArti, tGroundFireTarget, 0.1, false, 'ArtGF', false, oClosestTargetOfInterest)
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Not targeting a shield and it is too far outside our range so will abort (or had error finding groundfiretarget)') end
                            bGivenOrder = false
                        end
                    end

                    --If we were targeting a mobile unit then reconsider targets 5s later if we have failed to fire a shot in the meantime
                    if bTargetingMobileUnit then
                        if bDebugMessages == true then LOG(sFunctionRef..': About to start a forked thread to re-consider t2 arti target as we are targeting a mobile unit') end
                        ForkThread(ConsiderManualT2ArtiTarget, oArti, oOptionalWeapon, 5)
                    end
                end
            end

            --Clear orders if last order was attack ground and we havent given any new order (so will revert to default weapon targeting)
            if not(bGivenOrder) then
                M28Orders.UpdateRecordedOrders(oArti)
                local iLastOrderType = oArti[M28Orders.reftiLastOrders][1][M28Orders.subrefiOrderType]
                if iLastOrderType == M28Orders.refiOrderIssueGroundAttack or iLastOrderType == M28Orders.refiOrderIssueAttack then
                    if bDebugMessages == true then LOG(sFunctionRef..': Couldnt find any targets and arti was given an attack or ground fire order so will clear the order') end
                    M28Orders.IssueTrackedClearCommands(oArti)
                else
                    --Give an attack ground order if we haven't fired a shot at all this game, so we are likely to be facing the right direction
                    local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
                    if bDebugMessages == true then LOG(sFunctionRef..': Last weapon event='..(oArti[M28Events.refiLastWeaponEvent] or 'nil')) end
                    if not(oArti[M28Events.refiLastWeaponEvent]) then
                        local tDirectionTowardsEnemy = M28Utilities.MoveInDirection(oArti:GetPosition(), M28Utilities.GetAngleFromAToB(oArti:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase]), (oArti[M28UnitInfo.refiIndirectRange] or 110) - 5, true, false, M28Map.bIsCampaignMap)
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and fire at tDirectionTowardsEnemy='..repru(tDirectionTowardsEnemy)..', Dist to arti='..M28Utilities.GetDistanceBetweenPositions(oArti:GetPosition(), tDirectionTowardsEnemy)) end
                        M28Orders.IssueTrackedGroundAttack(oArti, tDirectionTowardsEnemy, 0.1, false, 'ArtGF', false, oClosestTargetOfInterest)
                        --Clear this order in 5s if still not got a target
                        ForkThread(ConsiderManualT2ArtiTarget, oArti, oOptionalWeapon, 5)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetBestAOETargetForSpecifiedBuildings(aiBrain, iTeam, tLauncherPosition, tSMDBlockingTarget, iAOE, iDamage)
    --intended for yolona targeting blocking smds; start by getting the closest enemy SMD, returns revised target

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBestAOETargetForSpecifiedBuildings'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iClosestDist = 100000
    local oClosestSMD
    local iCurDist
    local tTarget
    local iClosestAltSMDToSMD = 100000
    local tNearbyAltSMD = {}

    if table.getn(tSMDBlockingTarget) == 1 then
        oClosestSMD = tSMDBlockingTarget[1]
    else
        for iSMD, oSMD in tSMDBlockingTarget do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tLauncherPosition, oSMD:GetPosition())
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestSMD = oSMD
            end
        end
    end

    --Competing concerns - if try to edge nuke SMD then might deal minimal damage to wider base once we break through; if instead target for max damage we might cause other SMD not previously in range to become in range
    --will therefore only consider best damage if there is only 1 SMD nearby

    local iNearbyThreshold = iAOE * 2
    local tiDistToClosestSMD = {}
    for iSMD, oSMD in M28Team.tTeamData[iTeam][M28Team.reftEnemySMD] do
        if not(oSMD == oClosestSMD) and M28UnitInfo.IsUnitValid(oSMD) then
            iCurDist = M28Utilities.GetDistanceBetweenPositions(oClosestSMD:GetPosition(), oSMD:GetPosition())
            if iCurDist < iNearbyThreshold then
                table.insert(tNearbyAltSMD, oSMD)
                table.insert(tiDistToClosestSMD, iCurDist)
            end
        end
    end
    if M28Utilities.IsTableEmpty(tNearbyAltSMD) == false then
        --work out the position that hits the max no. of units - approximate by taking the best midpoint between smd pairs that include the first
        local bCheckPlayableArea = M28Map.bIsCampaignMap
        local iBestSMDInRange = 0
        local tBestTarget
        for iSMD, oSMD in tNearbyAltSMD do
            local tCurMidpoint = M28Utilities.MoveInDirection(oClosestSMD:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestSMD:GetPosition(), oSMD:GetPosition()), tiDistToClosestSMD[iSMD] * 0.5, false, bCheckPlayableArea)
            local iSMDInRange = 2
            for iAltSMD, oAltSMD in tNearbyAltSMD do
                if not(oAltSMD == oSMD) then
                    if M28Utilities.GetDistanceBetweenPositions(tCurMidpoint, oAltSMD:GetPosition()) < iAOE then
                        if bDebugMessages == true then LOG(sFunctionRef..': IF target the midpoint between smd '..oSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSMD)..' and the closest SMD '..oClosestSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestSMD)..' then another SMD, oAltSMD='..oAltSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oAltSMD)..' is also in range. is alt smd valid='..tostring(M28UnitInfo.IsUnitValid(oAltSMD))) end
                        iSMDInRange = iSMDInRange + 1
                    end
                end
            end
            if iSMDInRange > iBestSMDInRange then
                tBestTarget = {tCurMidpoint[1], tCurMidpoint[2], tCurMidpoint[3]}
                iBestSMDInRange = iSMDInRange
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iBestSMDInRange='..iBestSMDInRange..'; oClosestSMD='..oClosestSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestSMD)) end
        if iBestSMDInRange >= 2 then
            tTarget = tBestTarget
        else
            tTarget = M28Logic.GetBestAOETarget(aiBrain, oClosestSMD:GetPosition(), iAOE, iDamage, false)
        end

    else
        tTarget = M28Logic.GetBestAOETarget(aiBrain, oClosestSMD:GetPosition(), iAOE, iDamage, false)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tTarget='..repru(tTarget)..'; Time='..GetGameTimeSeconds()) end
    return tTarget
end

function MonitorShieldsForCycling(tTableRef, iTeam, iLandZone, iTemplateRef)
    --Called from the gameender template logic
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MonitorShieldsForCycling'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(tTableRef[M28Map.subrefGEbActiveShieldMonitor]) and bShieldsCanDischarge then
        tTableRef[M28Map.subrefGEbActiveShieldMonitor] = true
        local oLowestHealthActiveShield, oHighestHealthActiveShield, iCompletedShieldCount, iCurHealth, iMaxHealth, iLowestHealth, iHighestHealth, iLongestRechargeTime
        local iSecondsBetweenShieldCycles = 1 --will change
        local M28Config = import('/mods/M28AI/lua/M28Config.lua')
        local bUpdateName = M28Config.M28ShowUnitNames
        local iCurShieldRadius, iShieldWithHealth

        local tArtiMidpoint, iLowestHealthDistToArtiMidpoint, iCurDistToArtiMidpoint
        if table.getn(tTableRef[M28Map.subrefGEArtiLocations]) == 1 then
            tArtiMidpoint = tTableRef[M28Map.subrefGEArtiLocations][1]
        else
            tArtiMidpoint = {}
            for iArtiLocation, tArtiLocation in tTableRef[M28Map.subrefGEArtiLocations] do
                tArtiMidpoint[1] = (tArtiMidpoint[1] or 0) + tArtiLocation[1]
                tArtiMidpoint[3] = (tArtiMidpoint[3] or 0) + tArtiLocation[3]
            end
            tArtiMidpoint[1] = tArtiMidpoint[1] / table.getn(tTableRef[M28Map.subrefGEArtiLocations])
            tArtiMidpoint[3] = tArtiMidpoint[3] / table.getn(tTableRef[M28Map.subrefGEArtiLocations])
            tArtiMidpoint[2] = GetTerrainHeight(tArtiMidpoint[1], tArtiMidpoint[3])
        end
        local iTimeOfLastDischarge

        while M28Conditions.IsTableOfUnitsStillValid(tTableRef[M28Map.subrefGEShieldUnits]) do
            --Get the highest and lowest health active shields
            iLowestHealth = 1000000
            iHighestHealth = 0
            oLowestHealthActiveShield = nil
            oHighestHealthActiveShield = nil
            iCompletedShieldCount = 0
            iLongestRechargeTime = 10
            iShieldWithHealth = 0
            for iShield, oShield in tTableRef[M28Map.subrefGEShieldUnits] do

                if oShield:GetFractionComplete() == 1 then
                    --Check we should include the shield (i.e. that it is covering the arti locations); assume UEF and seraphim T3+ are
                    if oShield[refbProtectingAllArtiAndShieldLocations] == nil or tTableRef[M28Map.subrefbHaveTooSmallShields] == nil then
                        oShield[refbProtectingAllArtiAndShieldLocations] = true --default
                        if not(EntityCategoryContains(categories.SERAPHIM + categories.UEF - categories.TECH2, oShield.UnitId)) and tTableRef[M28Map.subrefGESize] > 22 then
                            iCurShieldRadius = (oShield:GetBlueprint().Defense.Shield.ShieldSize or 0) * 0.5
                            if iCurShieldRadius < 10 then
                                oShield[refbProtectingAllArtiAndShieldLocations] = false
                            else
                                if M28Conditions.IsTableOfUnitsStillValid(tTableRef[M28Map.subrefGEArtiUnits]) then
                                    for iArti, oArti in tTableRef[M28Map.subrefGEArtiUnits] do
                                        if M28Utilities.GetDistanceBetweenPositions(oArti:GetPosition(), oShield:GetPosition()) > iCurShieldRadius then
                                            oShield[refbProtectingAllArtiAndShieldLocations] = false
                                            break
                                        end
                                    end
                                else
                                    --Use expected arti locations
                                    for iArti, tArti in tTableRef[M28Map.subrefGEArtiLocations] do
                                        if M28Utilities.GetDistanceBetweenPositions(tArti, oShield:GetPosition()) > iCurShieldRadius then
                                            oShield[refbProtectingAllArtiAndShieldLocations] = false
                                            break
                                        end
                                    end
                                end
                                if oShield[refbProtectingAllArtiAndShieldLocations] then
                                    --Cycle through shield locations
                                    for iShieldLocation, tShieldLocation in tTableRef[M28Map.subrefGEShieldLocations] do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' is covering all arti and shield locations, dist to tShieldLocation='..M28Utilities.GetDistanceBetweenPositions(tShieldLocation, oShield:GetPosition())..'; iCurShieldRadius='..iCurShieldRadius) end
                                        if M28Utilities.GetDistanceBetweenPositions(tShieldLocation, oShield:GetPosition()) > iCurShieldRadius then
                                            if bDebugMessages == true then LOG(sFunctionRef..': We cant cover other shields from this location') end
                                            oShield[refbProtectingAllArtiAndShieldLocations] = false
                                            break
                                        end
                                    end
                                end
                            end
                        end
                        if not(oShield[refbProtectingAllArtiAndShieldLocations]) then tTableRef[M28Map.subrefbHaveTooSmallShields] = true end
                        if tTableRef[M28Map.subrefbHaveTooSmallShields] == nil then
                            --Check every shield to see if any have this flagged
                            for iRecordedShield, oRecordedShield in tTableRef[M28Map.subrefGEShieldUnits] do
                                if oRecordedShield[refbProtectingAllArtiAndShieldLocations] == false then
                                    tTableRef[M28Map.subrefbHaveTooSmallShields] = true
                                end
                            end
                            if not(tTableRef[M28Map.subrefbHaveTooSmallShields]) then
                                tTableRef[M28Map.subrefbHaveTooSmallShields] = false
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; oShield[refbProtectingAllArtiAndShieldLocations]='..tostring(oShield[refbProtectingAllArtiAndShieldLocations] or false)) end
                    if oShield[refbProtectingAllArtiAndShieldLocations] then
                        iCompletedShieldCount = iCompletedShieldCount + 1
                        iCurHealth, iMaxHealth = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' at time='..GetGameTimeSeconds()..'; iCurHealth='..iCurHealth..'; iMaxHealth='..iMaxHealth..'; Is shield enabled='..tostring(M28UnitInfo.IsUnitShieldEnabled(oShield))..'; Time since last discharge='..GetGameTimeSeconds() - (oShield[refiTimeOfLastDischarge] or -100)..'; Is shield paused='..tostring(oShield[M28UnitInfo.refbPaused] or false)..'; Dist to arti midpoint='..M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), tArtiMidpoint)) end
                        if iCurHealth > 0 then
                            iShieldWithHealth = iShieldWithHealth + 1
                            if iCurHealth < iLowestHealth then
                                iLowestHealth = iCurHealth
                                oLowestHealthActiveShield = oShield
                            elseif iCurHealth == iLowestHealth then
                                if not(oLowestHealthActiveShield) then
                                    iLowestHealth = iCurHealth
                                    oLowestHealthActiveShield = oShield
                                else
                                    --Want to discharge the shield furthest from the midpoint if they both have equal health
                                    iLowestHealthDistToArtiMidpoint = M28Utilities.GetDistanceBetweenPositions(oHighestHealthActiveShield:GetPosition(), tArtiMidpoint)
                                    iCurDistToArtiMidpoint = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), tArtiMidpoint)
                                    if iCurDistToArtiMidpoint > iLowestHealthDistToArtiMidpoint then
                                        iLowestHealthDistToArtiMidpoint = iCurDistToArtiMidpoint
                                        oLowestHealthActiveShield = oShield
                                    end
                                end
                            end
                            if iCurHealth > iHighestHealth or (iCurHealth == iHighestHealth and (not(oHighestHealthActiveShield) or oLowestHealthActiveShield == oHighestHealthActiveShield)) then --want this to be >= and above to be < so that if we have 2 of the same shields at 100% health, we will have different shields recorded for lowest and highest health
                                iHighestHealth = iCurHealth
                                oHighestHealthActiveShield = oShield
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Time since last recharge='..GetGameTimeSeconds() - (oShield[refiTimeOfLastDischarge] or -100)..'; Is shield a transferred unit='..tostring(oShield[M28UnitInfo.refbTransferredUnit])..'; oUnit[refbShieldIsDisabled]='..repru(oShield[M28UnitInfo.refbShieldIsDisabled])) end
                            if not(oShield[refiManuallyEnabledTime]) or GetGameTimeSeconds() - oShield[refiManuallyEnabledTime] >= 30 then --as had a case where shields were stuck not recharging, so added in case due to running enableunitshield every tick
                                if (oShield[refiTimeOfLastDischarge] and GetGameTimeSeconds() - oShield[refiTimeOfLastDischarge] >= math.max(iLongestRechargeTime + 10, 40) and GetGameTimeSeconds() - (oShield[M28UnitInfo.refiTimeCreated] or 0) >= 5) then
                                    --Enable the shield incase it was somehow paused following the transfer, but only do this once every 10s
                                    if bDebugMessages == true then LOG(sFunctionRef..': Enabling shield as it has been a long time since it was discharged, shield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; Time='..GetGameTimeSeconds()) end
                                    M28UnitInfo.EnableUnitShield(oShield)
                                    oShield[refiManuallyEnabledTime] = GetGameTimeSeconds() --This is because also had a case where shield progress got stuck, which may have been due to this
                                elseif not(oShield[refiTimeOfLastDischarge]) and oShield[M28UnitInfo.refbTransferredUnit] and oShield[M28UnitInfo.refbShieldIsDisabled] == nil and iCurHealth == 0 and oShield:GetAIBrain():GetEconomyStoredRatio('ENERGY') >= 0.1 and not(oShield[M28UnitInfo.refbPaused]) and GetGameTimeSeconds() - (oShield[M28UnitInfo.refiTimeCreated] or 0) >= 5 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have 0 health shield that was transferred so will try enabling shield, shield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; Time='..GetGameTimeSeconds()) end
                                    M28UnitInfo.EnableUnitShield(oShield)
                                    oShield[refiManuallyEnabledTime] = GetGameTimeSeconds()
                                end
                            end
                        end

                        iLongestRechargeTime = math.max(iLongestRechargeTime, (oShield:GetBlueprint().Defense.Shield.ShieldRechargeTime or 0))
                    end
                end
            end
            if iCompletedShieldCount == 0 then break end
            if bDebugMessages == true then LOG(sFunctionRef..': Deciding how long to wait and whether to discharge a shield, iShieldWithHealth='..iShieldWithHealth..'; iCompletedShieldCount='..iCompletedShieldCount) end
            if not(oLowestHealthActiveShield) or oLowestHealthActiveShield == oHighestHealthActiveShield or iShieldWithHealth <= 1 then
                --We only have 1 shield active, so dont want to reset it
                iSecondsBetweenShieldCycles = 0.1 --review position next tick
                if bDebugMessages == true then LOG(sFunctionRef..': we either have no or 1 active shield so wont discharge but will check again in 1 tick') end
            else
                --If Aeon shell landed then the DOT effect could be beneath other shields; if we have 3+ shields active then seems unlikely, while if lowest health shield is <6k it wouldnt protect from the DOT effect either
                if oLowestHealthActiveShield[refiTimeOfLastAeonT3ArtiDamageToShield] and iCompletedShieldCount <= 2 and GetGameTimeSeconds() - oLowestHealthActiveShield[refiTimeOfLastAeonT3ArtiDamageToShield] <= 1 and iLowestHealth >= 6000 then
                    if bDebugMessages == true then LOG(sFunctionRef..': The lowest health shield took T3 arti fire from aeon recently, so a chance the shell DOT effect could destroy things if it occurred beneath the other shield currently active') end
                    iSecondsBetweenShieldCycles = 0.1 --review position next tick
                else
                    --We will presumably have waited the appropriate time before getting here, so can disable the lowest health shield; work out how long we want to wait for the next shield
                    if iCompletedShieldCount > 1 then
                        iSecondsBetweenShieldCycles = iLongestRechargeTime / (iCompletedShieldCount - 1)
                    else
                        --Redundancy - should be impossible to get here
                        iSecondsBetweenShieldCycles = 10
                    end
                    if iShieldWithHealth <= 3 and iTimeOfLastDischarge and GetGameTimeSeconds() - iTimeOfLastDischarge + 0.5 < iSecondsBetweenShieldCycles then
                        if bDebugMessages == true then LOG(sFunctionRef..': It hasnt been long enoug hsince our last discharge so will wait before discharing even if we have multiple shields active') end
                        iSecondsBetweenShieldCycles = 0.5
                    else
                        M28UnitInfo.DischargeShield(oLowestHealthActiveShield)
                        iTimeOfLastDischarge = GetGameTimeSeconds()
                        if bDebugMessages == true then LOG(sFunctionRef..': have just discharged shield '..oLowestHealthActiveShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLowestHealthActiveShield)..' at time='..GetGameTimeSeconds()) end
                        oLowestHealthActiveShield[refiTimeOfLastDischarge] = GetGameTimeSeconds()
                        if bUpdateName then
                            M28Orders.UpdateUnitNameForOrder(oLowestHealthActiveShield, 'DischZ'..(oLowestHealthActiveShield[reftArtiTemplateRefs][2] or 'nil')..'T'..(oLowestHealthActiveShield[reftArtiTemplateRefs][3] or 'nil')..'; Tm='..math.floor(GetGameTimeSeconds()))
                        end
                    end
                end

            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(iSecondsBetweenShieldCycles)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': No longer have valid shields, so will flag that we have no active shield monitor, time='..GetGameTimeSeconds()) end
        tTableRef[M28Map.subrefGEbActiveShieldMonitor] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MonitorSACUShieldsForCycling(tTableRef, iTeam, iLandZone, iTemplateRef)
    --Called from the gameender template logic for adding an engineer that is a shieldSACU; will enable/disable shields instead of discharging
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MonitorSACUShieldsForCycling'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(tTableRef[M28Map.subrefbActiveShieldSACUCycling]) and bShieldsCanDischarge then
        tTableRef[M28Map.subrefbActiveShieldSACUCycling] = true
        local oLowestHealthActiveShield, oHighestHealthActiveShield, iCompletedShieldCount, iCurHealth, iMaxHealth, iLowestHealth, iHighestHealth, iLongestRechargeTime
        local iSecondsBetweenShieldCycles = 1 --will change
        local iShieldWithHealth

        local tArtiMidpoint, iLowestHealthDistToArtiMidpoint, iCurDistToArtiMidpoint
        if table.getn(tTableRef[M28Map.subrefGEArtiLocations]) == 1 then
            tArtiMidpoint = tTableRef[M28Map.subrefGEArtiLocations][1]
        else
            tArtiMidpoint = {}
            for iArtiLocation, tArtiLocation in tTableRef[M28Map.subrefGEArtiLocations] do
                tArtiMidpoint[1] = (tArtiMidpoint[1] or 0) + tArtiLocation[1]
                tArtiMidpoint[3] = (tArtiMidpoint[3] or 0) + tArtiLocation[3]
            end
            tArtiMidpoint[1] = tArtiMidpoint[1] / table.getn(tTableRef[M28Map.subrefGEArtiLocations])
            tArtiMidpoint[3] = tArtiMidpoint[3] / table.getn(tTableRef[M28Map.subrefGEArtiLocations])
            tArtiMidpoint[2] = GetTerrainHeight(tArtiMidpoint[1], tArtiMidpoint[3])
        end
        local iTimeOfLastDischarge
        local bHaveRecentlyEnabledShield = false
        local iDisabledShieldCount, iEnabledShieldCount, iHighestEnabledShieldHealth

        while M28Conditions.IsTableOfUnitsStillValid(tTableRef[M28Map.subreftoGEShieldSACUs]) do
            --Get the highest and lowest health active shields
            iLowestHealth = 1000000
            iHighestHealth = 0
            oLowestHealthActiveShield = nil
            oHighestHealthActiveShield = nil
            iCompletedShieldCount = 0
            iLongestRechargeTime = 10
            iShieldWithHealth = 0
            iDisabledShieldCount = 0
            iEnabledShieldCount = 0
            for iShield, oShield in tTableRef[M28Map.subreftoGEShieldSACUs] do
                --if bDebugMessages == true and oShield.MyShield.GetMaxHealth and oShield.MyShield:GetMaxHealth() >= 30000 then LOG(sFunctionRef..': reprs of myshield='..reprs(oShield.MyShield)..'; (oShield.MyShield.Size or 0)='..(oShield.MyShield.Size or 0)..'; Blueprint equiv='..(oShield:GetBlueprint().Defense.Shield.ShieldSize or 'nil')) end
                if oShield:GetFractionComplete() == 1 and (oShield.MyShield.Size or 0) >= 5 then --redundancy
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)) end
                    iCompletedShieldCount = iCompletedShieldCount + 1
                    iCurHealth, iMaxHealth = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' at time='..GetGameTimeSeconds()..'; iCurHealth='..iCurHealth..'; iMaxHealth='..iMaxHealth..'; Is shield enabled='..tostring(M28UnitInfo.IsUnitShieldEnabled(oShield))..'; Time since last discharge='..GetGameTimeSeconds() - (oShield[refiTimeOfLastDischarge] or -100)..'; Is shield paused='..tostring(oShield[M28UnitInfo.refbPaused] or false)..'; Dist to arti midpoint='..M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), tArtiMidpoint)) end
                    --First check we are close enough to the midpoint
                    iCurDistToArtiMidpoint = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), tArtiMidpoint)
                    if iCurDistToArtiMidpoint >= 6 and not(oShield:IsUnitState('Upgrading')) and iCurDistToArtiMidpoint >= (oShield.MyShield.Size or 20) * 0.4 - 1 and (iCurHealth > 0 or iCurDistToArtiMidpoint > (oShield.MyShield.Size or 20) * 0.5) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Moving oShield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' to arti midpoint, artimidpoint='..repru(tArtiMidpoint)..'; is oShield valid='..tostring(M28UnitInfo.IsUnitValid(oShield))) end
                        M28Orders.IssueTrackedMove(oShield, tArtiMidpoint, 2, false, 'ShSCUMvToMd', true)
                        M28Micro.TrackTemporaryUnitMicro(oShield, 5)
                    end

                    if iCurHealth > 0 then
                        iShieldWithHealth = iShieldWithHealth + 1
                        if iCurHealth < iLowestHealth then
                            iLowestHealth = iCurHealth
                            oLowestHealthActiveShield = oShield
                        elseif iCurHealth == iLowestHealth then
                            if not(oLowestHealthActiveShield) then
                                iLowestHealth = iCurHealth
                                oLowestHealthActiveShield = oShield
                            else
                                --Want to discharge the shield furthest from the midpoint if they both have equal health
                                iLowestHealthDistToArtiMidpoint = M28Utilities.GetDistanceBetweenPositions(oHighestHealthActiveShield:GetPosition(), tArtiMidpoint)
                                if iCurDistToArtiMidpoint > iLowestHealthDistToArtiMidpoint then
                                    iLowestHealthDistToArtiMidpoint = iCurDistToArtiMidpoint
                                    oLowestHealthActiveShield = oShield
                                end
                            end
                        end
                        if not(oShield[M28UnitInfo.refbShieldIsDisabled]) and (iCurHealth > iHighestHealth or (iCurHealth == iHighestHealth and (not(oHighestHealthActiveShield) or oLowestHealthActiveShield == oHighestHealthActiveShield))) then --want this to be >= and above to be < so that if we have 2 of the same shields at 100% health, we will have different shields recorded for lowest and highest health
                            iHighestHealth = iCurHealth
                            oHighestHealthActiveShield = oShield
                        end
                    elseif iMaxHealth > 0 then --Might not have the shield upgrade yet
                        if bDebugMessages == true then LOG(sFunctionRef..': Time since last recharge='..GetGameTimeSeconds() - (oShield[refiTimeOfLastDischarge] or -100)..'; Is shield a transferred unit='..tostring(oShield[M28UnitInfo.refbTransferredUnit])..'; oUnit[refbShieldIsDisabled]='..repru(oShield[M28UnitInfo.refbShieldIsDisabled])) end
                        if not(oShield[M28UnitInfo.refbShieldIsDisabled]) and not(oShield[M28UnitInfo.refbShieldRecentlyEnabled]) and (not(oShield[refiManuallyEnabledTime]) or GetGameTimeSeconds() - oShield[refiManuallyEnabledTime] >= 30) then --as had a case where shields were stuck not recharging, so added in case due to running enableunitshield every tick
                            if (oShield[refiTimeOfLastDischarge] and GetGameTimeSeconds() - oShield[refiTimeOfLastDischarge] >= math.max(iLongestRechargeTime + 10, 40) and GetGameTimeSeconds() - (oShield[M28UnitInfo.refiTimeCreated] or 0) >= 5) then
                                --Enable the shield incase it was somehow paused following the transfer, but only do this once every 10s
                                if bDebugMessages == true then LOG(sFunctionRef..': Enabling shield as it has been a long time since it was discharged, shield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; Time='..GetGameTimeSeconds()) end
                                M28UnitInfo.EnableUnitShield(oShield)
                                oShield[refiManuallyEnabledTime] = GetGameTimeSeconds() --This is because also had a case where shield progress got stuck, which may have been due to this
                            elseif not(oShield[refiTimeOfLastDischarge]) and oShield[M28UnitInfo.refbTransferredUnit] and oShield[M28UnitInfo.refbShieldIsDisabled] == nil and iCurHealth == 0 and oShield:GetAIBrain():GetEconomyStoredRatio('ENERGY') >= 0.1 and not(oShield[M28UnitInfo.refbPaused]) and GetGameTimeSeconds() - (oShield[M28UnitInfo.refiTimeCreated] or 0) >= 5 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have 0 health shield that was transferred so will try enabling shield, shield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; Time='..GetGameTimeSeconds()) end
                                M28UnitInfo.EnableUnitShield(oShield)
                                oShield[refiManuallyEnabledTime] = GetGameTimeSeconds()
                            end
                        end
                    end
                    if oShield[M28UnitInfo.refbShieldIsDisabled] then iDisabledShieldCount = iDisabledShieldCount + 1
                    else
                        iEnabledShieldCount = iEnabledShieldCount + 1
                        if not(bHaveRecentlyEnabledShield) and oShield[M28UnitInfo.refbShieldRecentlyEnabled] then bHaveRecentlyEnabledShield = true end
                    end


                    iLongestRechargeTime = math.max(iLongestRechargeTime, (oShield.MyShield.ShieldRechargeTime or 215))
                elseif bDebugMessages == true then LOG(sFunctionRef..': Shield isnt complete or lacks a shield field, shield size='..(oShield.MyShield.Size or 0)..'; oShield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; Upgrade count='..(oShield[import('/mods/M28AI/lua/AI/M28ACU.lua').refiUpgradeCount] or 'nil'))
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Deciding how long to wait and whether to discharge a shield, iShieldWithHealth='..iShieldWithHealth..'; iCompletedShieldCount='..iCompletedShieldCount) end
            if iCompletedShieldCount == 0 or not(oHighestHealthActiveShield) or iHighestHealth == 0 then
                tTableRef[M28Map.subrefiHighestShieldACUHealthPercent] = 0
            elseif oHighestHealthActiveShield.MyShield.GetMaxHealth then
                tTableRef[M28Map.subrefiHighestShieldACUHealthPercent] = iHighestHealth / oHighestHealthActiveShield.MyShield:GetMaxHealth()
            else
                tTableRef[M28Map.subrefiHighestShieldACUHealthPercent] = iHighestHealth / (oHighestHealthActiveShield.MyShield.ShieldMaxHealth or 52000)
            end

            --Enable/disable shields instead of discharging
            if bDebugMessages == true then LOG(sFunctionRef..': iLongestRechargeTime='..iLongestRechargeTime..'; tTableRef[M28Map.subrefiHighestShieldACUHealthPercent]='..tTableRef[M28Map.subrefiHighestShieldACUHealthPercent]..'; iShieldWithHealth='..iShieldWithHealth..'; iEnabledShieldCount='..iEnabledShieldCount..'; iDisabledShieldCount='..iDisabledShieldCount..'; bHaveRecentlyEnabledShield='..tostring(bHaveRecentlyEnabledShield)) end
            if iCompletedShieldCount == 0 then
                iSecondsBetweenShieldCycles = 10
            elseif iLongestRechargeTime >= 40 then
                iSecondsBetweenShieldCycles = 1
                --First consider if want to disable a shield
                if iShieldWithHealth > 1 and iEnabledShieldCount > 1 then
                    local oShieldToDisable
                    --Disable shield
                    if (not(oLowestHealthActiveShield.MyShield.GetHealth) or oLowestHealthActiveShield.MyShield:GetHealth() < iHighestHealth or (iLowestHealth == iHighestHealth and not(oLowestHealthActiveShield == oHighestHealthActiveShield))) then
                        --Disable lowest health shield
                        oShieldToDisable = oLowestHealthActiveShield
                    elseif iEnabledShieldCount >= 2 and iShieldWithHealth >= 2 and tTableRef[M28Map.subrefiHighestShieldACUHealthPercent] >= 0.1 and (tTableRef[M28Map.subrefiHighestShieldACUHealthPercent] >= 0.25 or iShieldWithHealth >= 3) then
                        for iShield, oShield in tTableRef[M28Map.subreftoGEShieldSACUs] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Looking for shield to disable, oShield health='..oLowestHealthActiveShield.MyShield:GetHealth()..'; iHighestHealth='..iHighestHealth) end
                            if not(oShield[M28UnitInfo.refbShieldIsDisabled]) and oShield:GetFractionComplete() == 1 and not(oShield == oHighestHealthActiveShield) and (not(oLowestHealthActiveShield.MyShield.GetHealth) or oLowestHealthActiveShield.MyShield:GetHealth() < iHighestHealth or oLowestHealthActiveShield.MyShield:GetHealth() == oLowestHealthActiveShield.MyShield:GetMaxHealth()) then
                                oShieldToDisable = oShield
                                break
                            end
                        end
                    else
                        --Only have 2 enabled shields, and our lowest health shield appears to have more health than our highest health, but might be temporarily down, so dont disable either
                        iSecondsBetweenShieldCycles = 0.5
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Will disable or discharge oShieldToDisable='..(oShieldToDisable.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oShieldToDisable) or 'nil')..'; Time since last discharge='..GetGameTimeSeconds() - (iTimeOfLastDischarge or 0)) end
                    if oShieldToDisable then
                        local iShieldToDisableHealthPercent = oShieldToDisable.MyShield:GetHealth() / oShieldToDisable.MyShield:GetMaxHealth()
                        local iMinTimeBetweenDischargesWanted = iLongestRechargeTime / (iCompletedShieldCount - 1)
                        if oShieldToDisable.MyShield.GetHealth and iShieldToDisableHealthPercent < math.min(0.85, 0.65 + iCompletedShieldCount * 0.02) and (iShieldToDisableHealthPercent < 0.25 or not(iTimeOfLastDischarge) or GetGameTimeSeconds() - iTimeOfLastDischarge >= iMinTimeBetweenDischargesWanted or (iShieldToDisableHealthPercent < 0.5 and iCompletedShieldCount >= 0.4 and GetGameTimeSeconds() - iTimeOfLastDischarge >= iMinTimeBetweenDischargesWanted * 0.6)) then
                            --Discharge instead of disabling
                            M28UnitInfo.DischargeShield(oShieldToDisable)
                            iTimeOfLastDischarge = GetGameTimeSeconds()
                            if bDebugMessages == true then LOG(sFunctionRef..': Damaged shield so will discharge instead of disabling') end
                        else
                            --Disable instead of discharge
                            M28UnitInfo.DisableUnitShield(oShieldToDisable)
                            if bDebugMessages == true then LOG(sFunctionRef..': Shield has enough health that we will disable it and reuse in the future') end
                        end
                    end
                end
                --Then decide if want to enable a shield
                if not(bHaveRecentlyEnabledShield) and iDisabledShieldCount >= 1 and tTableRef[M28Map.subrefiHighestShieldACUHealthPercent] <= 0.75 and tTableRef[M28Map.subrefiHighestShieldACUHealthPercent] <= 0.1 + 0.2 * iDisabledShieldCount then
                    for iShield, oShield in tTableRef[M28Map.subreftoGEShieldSACUs] do
                        if oShield[M28UnitInfo.refbShieldIsDisabled] then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will enable oShield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)) end
                            M28UnitInfo.EnableUnitShield(oShield)
                        end
                    end
                end
            else --Redundancy - although this works shield discharge isnt as good due to E upkeep

                if not(oLowestHealthActiveShield) or oLowestHealthActiveShield == oHighestHealthActiveShield or iShieldWithHealth <= 1 then
                    --We only have 1 shield active, so dont want to reset it
                    iSecondsBetweenShieldCycles = 0.1 --review position next tick
                    if bDebugMessages == true then LOG(sFunctionRef..': we either have no or 1 active shield so wont discharge but will check again in 1 tick') end
                else
                    --If Aeon shell landed then the DOT effect could be beneath other shields; if we have 3+ shields active then seems unlikely, while if lowest health shield is <6k it wouldnt protect from the DOT effect either
                    if oLowestHealthActiveShield[refiTimeOfLastAeonT3ArtiDamageToShield] and iCompletedShieldCount <= 2 and GetGameTimeSeconds() - oLowestHealthActiveShield[refiTimeOfLastAeonT3ArtiDamageToShield] <= 1 and iLowestHealth >= 6000 then
                        if bDebugMessages == true then LOG(sFunctionRef..': The lowest health shield took T3 arti fire from aeon recently, so a chance the shell DOT effect could destroy things if it occurred beneath the other shield currently active') end
                        iSecondsBetweenShieldCycles = 0.1 --review position next tick
                    else
                        --We will presumably have waited the appropriate time before getting here, so can disable the lowest health shield; work out how long we want to wait for the next shield
                        if iCompletedShieldCount > 1 then
                            iSecondsBetweenShieldCycles = iLongestRechargeTime / (iCompletedShieldCount - 1)
                        else
                            --Redundancy - should be impossible to get here
                            iSecondsBetweenShieldCycles = 10
                        end
                        if iShieldWithHealth <= 3 and iTimeOfLastDischarge and GetGameTimeSeconds() - iTimeOfLastDischarge + 0.5 < iSecondsBetweenShieldCycles then
                            if bDebugMessages == true then LOG(sFunctionRef..': It hasnt been long enoug hsince our last discharge so will wait before discharing even if we have multiple shields active') end
                            iSecondsBetweenShieldCycles = 0.5
                        else
                            M28UnitInfo.DischargeShield(oLowestHealthActiveShield)
                            iTimeOfLastDischarge = GetGameTimeSeconds()
                            if bDebugMessages == true then LOG(sFunctionRef..': have just discharged shield '..oLowestHealthActiveShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLowestHealthActiveShield)..' at time='..GetGameTimeSeconds()) end
                            oLowestHealthActiveShield[refiTimeOfLastDischarge] = GetGameTimeSeconds()
                            --Dont want ot update name as we want to have the name refer to engineer orders
                            --[[if bUpdateName then
                                M28Orders.UpdateUnitNameForOrder(oLowestHealthActiveShield, 'DischZ'..(oLowestHealthActiveShield[reftArtiTemplateRefs][2] or 'nil')..'T'..(oLowestHealthActiveShield[reftArtiTemplateRefs][3] or 'nil')..'; Tm='..math.floor(GetGameTimeSeconds()))
                            end--]]
                        end
                    end

                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(iSecondsBetweenShieldCycles)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': No longer have valid shields, so will flag that we have no active shield monitor, time='..GetGameTimeSeconds()) end
        tTableRef[M28Map.subrefbActiveShieldSACUCycling] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderFiringFirstLoadedNukeOnTeam(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderFiringFirstLoadedNukeOnTeam'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Called when an SMD has just been killed; wait 2 ticks in case the SMD was just being transferred
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(2)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local oSMLToConsiderFiring
    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
        if not(oBrain.M28Easy) then
            local tFriendlyNukes = oBrain:GetListOfUnits(M28UnitInfo.refCategorySML, true, false)
            if M28Utilities.IsTableEmpty(tFriendlyNukes) == false then
                for iNuke, oNuke in tFriendlyNukes do
                    if oNuke:GetFractionComplete() == 1 and oNuke.GetNukeSiloAmmoCount and oNuke:GetNukeSiloAmmoCount() >= 1 then
                        if not(oNuke[refiTimeLastFiredMissile]) or GetGameTimeSeconds() - oNuke[refiTimeLastFiredMissile] >= 10 then
                            oSMLToConsiderFiring = oNuke
                            break
                        end
                    end
                end
                if oSMLToConsiderFiring then break end
            end
        end
    end
    if oSMLToConsiderFiring then
        if bDebugMessages == true then LOG(sFunctionRef..': Will consider firing nuke launcher='..oSMLToConsiderFiring.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSMLToConsiderFiring)) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        --LOG('consideration of launching missile 5')
        ConsiderLaunchingMissile(oSMLToConsiderFiring)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordNukeTarget(iTeam, tLaunchLocation)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordNukeTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local bCheckIfRecentlyRecorded = true
    if not(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]) then
        if not(M28Team.tTeamData[iTeam]) then M28Team.tTeamData[iTeam] = {} end
        M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations] = {}
        bCheckIfRecentlyRecorded = false
    end
    local iCurTime = math.floor(GetGameTimeSeconds())
    local bIgnoreAsRecentlyRecorded = false
    if bCheckIfRecentlyRecorded then
        for iTime, tRecordedLaunchLocation in M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations] do
            if bDebugMessages == true then LOG(sFunctionRef..': iCurTime-iTime='..(iCurTime - iTime)..'; Dist to tRecordedLaunchLocation='..M28Utilities.GetDistanceBetweenPositions(tLaunchLocation, tRecordedLaunchLocation)) end
            if iCurTime - iTime <= 2 and M28Utilities.GetDistanceBetweenPositions(tLaunchLocation, tRecordedLaunchLocation) <= 4 then
                bIgnoreAsRecentlyRecorded = true
                break
            end
        end
    end
    if not(bIgnoreAsRecentlyRecorded) then

        local iOrigCurTime = iCurTime
        local iCycleCount = 0
        if bDebugMessages == true then LOG(sFunctionRef..': Recording nuke target, iTeam='..iTeam..'; tLaunchLocation='..repru(tLaunchLocation)..'; Time='..GetGameTimeSeconds()..'; iCurTime='..iCurTime..'; M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]='..repru(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations])) end
        if M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations][iCurTime] then iCurTime = GetGameTimeSeconds() end
        while M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations][iCurTime] do
            iCurTime = iCurTime - 0.0001
            --Wierd issue where sometimes but not always iCurTime doesnt change (likely also rseolved by having iCurTime switch to gametimeseconds
            if iOrigCurTime == iCurTime then
                iCurTime = iCurTime - 0.1
            end
            iCycleCount = iCycleCount + 1
            if bDebugMessages == true then LOG(sFunctionRef..': iCycleCount='..iCycleCount..'; iCurTime='..iCurTime..'; is M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations][iCurTime] nil='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations][iCurTime] == nil)) end
            if iCycleCount >= 30 then
                M28Utilities.ErrorHandler('Potential infinite loop, aborted recording nuke missile location')
                break
            end
        end
        M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations][iCurTime] = { tLaunchLocation[1],tLaunchLocation[2], tLaunchLocation[3] }
        ForkThread(RemoveOldNukeTarget, iTeam, iCurTime, math.max(180, 60*M28Map.iMapSize / 1024))
        if bDebugMessages == true then LOG(sFunctionRef..': End of code, iTeam='..iTeam..'; tLaunchLocation='..repru(tLaunchLocation)..'; Time='..GetGameTimeSeconds()..'; iCurTime='..iCurTime..'; M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]='..repru(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations])) end
    elseif bDebugMessages == true then LOG(sFunctionRef..': End of code, not recording as have recenlty recorded this location or a very nearby one')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RemoveOldNukeTarget(iTeam, iRecordedTime, iDelayInSeconds)
    WaitSeconds(iDelayInSeconds)
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]) == false then
        for iTime, tLocation in M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations] do
            if iRecordedTime == iTime then
                M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations] = nil
                break
            end
        end
    end
end

function QuantumOpticsManager(aiBrain, oUnit)
    --Call via forkthread
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'QuantumOpticsManager'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28UnitInfo.IsUnitValid(oUnit) and not (oUnit[refbActiveOpticsManager]) then
        local iTeam = aiBrain.M28Team
        oUnit[refbActiveOpticsManager] = true
        local oBP = oUnit:GetBlueprint()
        local iIntelRange = (oBP.Intel.RemoteViewingRadius or oBP.Intel.VisionRadius)
        local iThresholdForAdjacentScry = iIntelRange * 2 * 1.3 --i.e. if we wouldnt cover all of the zone even with a 30% increase in the scry size, then we will scry the 4 corners
        local iDelayInSeconds = math.max(1, (oBP.Intel.ReactivateTime or 1) * 0.1)
        local iScryRelocationSize = iIntelRange * 1.45

        local iEntryCount
        local iEntryToScout
        local iCurLZOrWZ, iCurPlateauOrZero, iCurZoneSizeX, iCurZoneSizeZ
        function ReadyToScry()
            if M28Orders.bDontConsiderCombinedArmy or oUnit.M28Active and aiBrain:GetEconomyStoredRatio('ENERGY') >= 1 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 250 and aiBrain:GetEconomyStored('ENERGY') >= 14000 and not (M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) then
                return true
            else
                return false
            end
        end
        local tAdjAreaToScout

        function ScryAdjacentAreaWhenReady(tBaseTarget, iXAdjust, iZAdjust)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(iDelayInSeconds)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            while not(ReadyToScry) do
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitSeconds(iDelayInSeconds)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
            tAdjAreaToScout = {tBaseTarget[1] + (iXAdjust or 0), tBaseTarget[2], tBaseTarget[3] + (iZAdjust or 0)}
            tAdjAreaToScout[2] = GetSurfaceHeight(tBaseTarget[1], tBaseTarget[3])
            if bDebugMessages == true then
                LOG(sFunctionRef..': Scrying adjacent area, tBaseTarget='..repru(tBaseTarget)..'; iXAdjust='..(iXAdjust or 'nil')..'; iZAdjust='..(iZAdjust or 'nil')..'; tAdjAreaToScout='..repru(tAdjAreaToScout)..'; Time='..GetGameTimeSeconds())
                M28Utilities.DrawLocation(tAdjAreaToScout, nil, nil, iIntelRange)
            end
            oUnit:OnTargetLocation(tAdjAreaToScout)
        end

        while M28UnitInfo.IsUnitValid(oUnit) do
            if oUnit:GetFractionComplete() == 1 then
                if ReadyToScry() then
                    M28Air.UpdateScoutingShortlist(iTeam)
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftLandAndWaterZoneScoutingShortlist]) == false then
                        --Pick a random location on the shortlist
                        iEntryCount = table.getn(M28Team.tTeamData[iTeam][M28Team.subreftLandAndWaterZoneScoutingShortlist])
                        iEntryToScout = math.random(1, iEntryCount)
                        iCurPlateauOrZero = M28Team.tTeamData[iTeam][M28Team.subreftLandAndWaterZoneScoutingShortlist][iEntryToScout][1]
                        iCurLZOrWZ = M28Team.tTeamData[iTeam][M28Team.subreftLandAndWaterZoneScoutingShortlist][iEntryToScout][2]
                        local tLZOrWZData, tLZOrWZTeamData
                        if iCurPlateauOrZero == 0 then
                            tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurLZOrWZ]][M28Map.subrefPondWaterZones][iCurLZOrWZ]
                            tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                            iCurZoneSizeX = ((tLZOrWZData[M28Map.subrefWZMaxSegX] or 0) - (tLZOrWZData[M28Map.subrefWZMinSegX] or 0)) * M28Map.iLandZoneSegmentSize
                            iCurZoneSizeZ = ((tLZOrWZData[M28Map.subrefWZMaxSegZ] or 0) - (tLZOrWZData[M28Map.subrefWZMinSegZ] or 0)) * M28Map.iLandZoneSegmentSize
                        else
                            tLZOrWZData = M28Map.tAllPlateaus[iCurPlateauOrZero][M28Map.subrefPlateauLandZones][iCurLZOrWZ]
                            tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                            iCurZoneSizeX = ((tLZOrWZData[M28Map.subrefLZMaxSegX] or 0) - (tLZOrWZData[M28Map.subrefLZMinSegX] or 0)) * M28Map.iLandZoneSegmentSize
                            iCurZoneSizeZ = ((tLZOrWZData[M28Map.subrefLZMaxSegZ] or 0) - (tLZOrWZData[M28Map.subrefLZMinSegZ] or 0)) * M28Map.iLandZoneSegmentSize
                        end

                        --Scout the midpoint
                        if bDebugMessages == true then LOG(sFunctionRef..': Scrying midpoint, tLZOrWZData[M28Map.subrefMidpoint]='..repru(tLZOrWZData[M28Map.subrefMidpoint])..'; iCurPlateauOrZero='..(iCurPlateauOrZero or 'nil')..'; iCurLZOrWZ='..(iCurLZOrWZ or 'nil'))
                            M28Utilities.DrawLocation(tLZOrWZData[M28Map.subrefMidpoint], nil, nil, iIntelRange)
                        end
                        oUnit:OnTargetLocation(tLZOrWZData[M28Map.subrefMidpoint]) --See M27 function ScryTarget for alternative ways of doing this that were attempted
                        --Update to reflect we have had visual of the target
                        tLZOrWZTeamData[M28Map.refiTimeLastHadVisual] = GetGameTimeSeconds()
                        --Large zones - scry to either side once ready
                        if iCurZoneSizeX > iThresholdForAdjacentScry then
                            --Scry each adjacent threshold; based on visualisation (sketchup as cant be bothered with the maths), for a 100 radius circle will cover most (but not all) of the surrounding area if the next scry location is 145 in each direction (north, east, south, west)
                            ScryAdjacentAreaWhenReady(tLZOrWZData[M28Map.subrefMidpoint], -iScryRelocationSize, 0)
                            ScryAdjacentAreaWhenReady(tLZOrWZData[M28Map.subrefMidpoint], iScryRelocationSize, 0)
                        end
                        if iCurZoneSizeZ > iThresholdForAdjacentScry then
                            ScryAdjacentAreaWhenReady(tLZOrWZData[M28Map.subrefMidpoint], 0, -iScryRelocationSize)
                            ScryAdjacentAreaWhenReady(tLZOrWZData[M28Map.subrefMidpoint], 0, iScryRelocationSize)
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': No locations on shortlist to scout')
                    end
                end
            end

            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(iDelayInSeconds)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordExperimentalResourceGen(oUnit)
    if M28UnitInfo.IsUnitValid(oUnit) then
        local iPlateau, iZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
        if iPlateau then
            local iTeam = oUnit:GetAIBrain().M28Team
            local tStartLZOrWZData, tStartLZOrWZTeamData
            if iPlateau == 0 then
                tStartLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iZone]][M28Map.subrefPondWaterZones][iZone]
                tStartLZOrWZTeamData = tStartLZOrWZData[M28Map.subrefWZTeamData][iTeam]
            else
                tStartLZOrWZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iZone]
                tStartLZOrWZTeamData = tStartLZOrWZData[M28Map.subrefLZTeamData][iTeam]
            end
            M28Air.RecordOtherLandAndWaterZonesByDistance(tStartLZOrWZData)
            tStartLZOrWZTeamData[M28Map.refoNearbyExperimentalResourceGen] = oUnit
            if M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                for iEntry, tSubtable in tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                    if tSubtable[M28Map.subrefiDistance] <= 400 then
                        local tOtherLZOrWZData, tOtherLZOrWZTeamData
                        if tSubtable[M28Map.subrefbIsWaterZone] then
                            tOtherLZOrWZData = M28Map.tPondDetails[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                            tOtherLZOrWZTeamData = tOtherLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                        else
                            tOtherLZOrWZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                            tOtherLZOrWZTeamData = tOtherLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                        end
                        if not(M28UnitInfo.IsUnitValid(tOtherLZOrWZTeamData[M28Map.refoNearbyExperimentalResourceGen])) then
                            tOtherLZOrWZTeamData[M28Map.refoNearbyExperimentalResourceGen] = oUnit
                        end
                    else
                        break
                    end
                end
            end
        end
    end
end

function MonitorUnitRecentPositions(oUnit, iOptionalDelayInSecondsOverride, iOptionalCycleLimit)
    --Used to track positions for TML targeting - abort this function if we are already tracking for one of the units
    if not(oUnit[M28UnitInfo.reftRecentUnitPositions]) and M28UnitInfo.IsUnitValid(oUnit) then
        local iDelay = (iOptionalDelayInSecondsOverride or 2)
        local iCycleCount = 0
        oUnit[M28UnitInfo.reftRecentUnitPositions] = {[1] = {0,0,0},[2]={0,0,0},[3]={0,0,0},[4]={0,0,0}}
        while M28UnitInfo.IsUnitValid(oUnit) do
            oUnit[M28UnitInfo.reftRecentUnitPositions][4] = {oUnit[M28UnitInfo.reftRecentUnitPositions][3][1], oUnit[M28UnitInfo.reftRecentUnitPositions][3][2], oUnit[M28UnitInfo.reftRecentUnitPositions][3][3]}
            oUnit[M28UnitInfo.reftRecentUnitPositions][3] = {oUnit[M28UnitInfo.reftRecentUnitPositions][2][1], oUnit[M28UnitInfo.reftRecentUnitPositions][2][2], oUnit[M28UnitInfo.reftRecentUnitPositions][2][3]}
            oUnit[M28UnitInfo.reftRecentUnitPositions][2] = {oUnit[M28UnitInfo.reftRecentUnitPositions][1][1], oUnit[M28UnitInfo.reftRecentUnitPositions][1][2], oUnit[M28UnitInfo.reftRecentUnitPositions][1][3]}
            oUnit[M28UnitInfo.reftRecentUnitPositions][1] = {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]}
            WaitSeconds(iDelay)
            if iOptionalCycleLimit then
                iCycleCount = iCycleCount + 1
                if iCycleCount >= iOptionalCycleLimit then
                    oUnit[M28UnitInfo.reftRecentUnitPositions] = nil
                    break
                end
            end
        end
    end
end

function TMLBatteryMonitor(tLZTeamData, oLauncher)
    --Called the first time a TML is being assigned to the TML battery
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TMLBatteryMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bAlreadyRecorded = false --redundancy
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoTMLBatteryUnits]) == false then
        for iUnit, oUnit in tLZTeamData[M28Map.reftoTMLBatteryUnits] do
            if oUnit == oLauncher then
                bAlreadyRecorded = true
                break
            end
        end
    else
        tLZTeamData[M28Map.reftoTMLBatteryUnits] = {}
    end
    if not(bAlreadyRecorded) then table.insert(tLZTeamData[M28Map.reftoTMLBatteryUnits], oLauncher) end
    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, bAlreadyRecorded='..tostring(bAlreadyRecorded)..'; oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..'; tLZTeamData[M28Map.refbActiveTMLMonitor]='..tostring(tLZTeamData[M28Map.refbActiveTMLMonitor] or false)..'; Time='..GetGameTimeSeconds()) end
    if not(tLZTeamData[M28Map.refbActiveTMLMonitor]) then
        local iTeam = oLauncher:GetAIBrain().M28Team
        tLZTeamData[M28Map.refbActiveTMLMonitor] = true

        --Get the first TMl, and use this as the benchmark for deciding how close enemies are
        local tBasePosition = oLauncher:GetPosition()
        local iAOE, iStrikeDamage, iMinRange, iMaxRange, iSalvoSize, iSalvoIndividualDelay = M28UnitInfo.GetLauncherAOEStrikeDamageMinAndMaxRange(oLauncher)
        iMaxRange = (iMaxRange or iTMLMissileRange)
        local iMaxEffectiveRange = iMaxRange - 25 --want enemy to be a bit within our max range to consider, in case TML have been built further away, and to give somel eeway for tracking target
        local iClosestEnemy, iCurDist
        local iTimeToWaitBetweenLaunches = 6
        local iTimeToWaitInTicks


        function GetPredictedPositionForMobileTarget(oTML, oClosestEnemy, bAlwaysReturnTarget, iAngleDif, iAngleToTarget)
            local iHeightDifference = oTML:GetPosition()[2] + 40 - oClosestEnemy:GetPosition()[2]

            local iHeightAdjustedDistToEnemy = math.sqrt(iHeightDifference * iHeightDifference + iClosestEnemy * iClosestEnemy)
            local iEstTimeToTarget = 2.7 + iHeightAdjustedDistToEnemy / 12 --fa/projectiles/CIFMissileTactical03/CIFMissileTactical03_proj.bp has a max speed of 12; velocity is 10; so need to allow for the following: Time from giving the order to the missile releasing; slightly slower speed by traveling at 10 instead of 12; going vertical for a bit; will try and roughly approximate by saying itll take 5s; however after testing it looks like there is minimal/no launch time, and 3.2s is much closer to the point at which a full speed fatboy is hit roughly at hte middle; 3 seemed slightly better; now trying 2.7
            local iSpeed
            if iAngleDif < 90 then iSpeed = oClosestEnemy:GetBlueprint().Physics.MaxSpeed
            else iSpeed = (oClosestEnemy:GetBlueprint().Phsyics.MaxSpeedReverse or oClosestEnemy:GetBlueprint().Physics.MaxSpeed)
            end
            local iEstDistance = iEstTimeToTarget * iSpeed
            if bDebugMessages == true then LOG(sFunctionRef..': iEstDistance='..iEstDistance..'; iEstTimeToTarget='..iEstTimeToTarget..'; iHeightAdjustedDistToEnemy='..iHeightAdjustedDistToEnemy..'; iClosestEnemy='..iClosestEnemy..'; iHeightDifference='..iHeightDifference) end
            if not(bAlwaysReturnTarget) and iEstDistance > 30 and iClosestEnemy - 30 > oClosestEnemy[M28UnitInfo.refiDFRange] and (iClosestEnemy >= 170 or iAngleDif >= 5 or (iClosestEnemy >= 150 and iAngleDif >= 2)) then
                --Dont get target afterall as high risk enemy dodges
                return nil
            else
                return M28Utilities.MoveInDirection(oClosestEnemy:GetPosition(), iAngleToTarget, iEstDistance, true, false, not(M28Map.bIsCampaignMap))
            end
        end

        local oPrimaryTML
        local iMissileValueWanted = 300 --i.e. dont bother firing if we will do less mass damage than this*number of missiles we expect to fire; this means we should fire up to 3 tml missiles to killl a t2 mex

        if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop, is table of battery units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoTMLBatteryUnits]))) end
        while M28Conditions.IsTableOfUnitsStillValid(tLZTeamData[M28Map.reftoTMLBatteryUnits]) do
            --Does enemy have any targets for us to consider sniping?
            if bDebugMessages == true then LOG(sFunctionRef..': Start of TML loop, is table of long range enemy DF units empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoLongRangeEnemyDFUnits]))..'; Time='..GetGameTimeSeconds()) end
            iTimeToWaitInTicks = M28Land.iTicksPerLandCycle

            local oClosestEnemy
            iClosestEnemy = iMaxEffectiveRange
            if M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftoLongRangeEnemyDFUnits]) then
                local iCurShieldHealth, iMaxShieldHealth
                local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftoLongRangeEnemyDFUnits] do
                    if M28UnitInfo.IsUnitValid(oUnit) and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oUnit.UnitId) then
                        --Check target not under lots of fixed shielding (ignore mobile shields though since we might be targeting fatboy
                        --IsTargetUnderShield(aiBrain, oTarget, iIgnoreShieldsWithLessThanThisCurHealth, bReturnShieldHealthInstead, bIgnoreMobileShields, bTreatPartCompleteAsComplete, bCumulativeShieldHealth, bReturnShieldsCovringTargetInstead)
                        iCurShieldHealth, iMaxShieldHealth = M28Logic.IsTargetUnderShield(aiBrain, oUnit,   0,                                          true,                       true,              true,                           true,                   false)
                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy exp oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurShieldHealth (of fixed shields, cumulatively)='..iCurShieldHealth) end
                        if iCurShieldHealth <= 14000 then --seraphim t2 shield is 13k health
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(tBasePosition, oUnit:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': Dist from oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to tBasePosition='..iCurDist..'; oClosestEnemy[M28UnitInfo.reftRecentUnitPositions][4]='..repru(oClosestEnemy[M28UnitInfo.reftRecentUnitPositions][4])) end
                            if iCurDist < iClosestEnemy and not(M28UnitInfo.IsUnitUnderwater(oUnit)) and not(oUnit:IsUnitState('Attached')) then
                                --oClosestEnemy[M28UnitInfo.reftRecentUnitPositions][4]
                                iClosestEnemy = iCurDist
                                oClosestEnemy = oUnit
                            end
                        end
                    end
                end
            end
            local iAdditionalLoadedTMLNeeded = 0
            local bAttackingNormalTMLTarget = false
            if not(oClosestEnemy) then --Check for normal TML targets
                if not(M28UnitInfo.IsUnitValid(oPrimaryTML)) then
                    for iTML, oTML in tLZTeamData[M28Map.reftoTMLBatteryUnits] do
                        oPrimaryTML = oTML
                        break
                    end
                end
                if M28Conditions.IsTableOfUnitsStillValid(oPrimaryTML[reftUnitsInRangeOfThisTML]) then
                    local aiBrain = oPrimaryTML:GetAIBrain()
                    local iLeastTMDOrMissedShotsCoveringTarget = 3 --i.e. if a target has 4+ TMD covering it then we wont bother trying to target it
                    local iMissedShotsFactor = 4 --i.e. every 4 missiles fired at this target is treated as a 'missed shot' equivalent to 1 TMD in coverage mostly as a redundancy to stop constantly firing at the same target and failing
                    local iShieldFactor = 5500 --i.e. total shield health covering target divided by this is treated as an equivalent number of TMD
                    local iCurTMDOrMissedShotsCoveringTarget
                    local iBestValue = 0
                    local iCurValue, iCurShieldValue, iCurShieldHealth, iMaxShieldHealth
                    iClosestEnemy = iMaxEffectiveRange --redundancy
                    for iUnit, oUnit in oPrimaryTML[reftUnitsInRangeOfThisTML] do
                        iCurTMDOrMissedShotsCoveringTarget = 0
                        if M28Conditions.IsTableOfUnitsStillValid(oUnit[reftTMDCoveringThisUnit]) then
                            --Do detailed check
                            if (oUnit[refiLastDetailedTMDProtectionCount] or 0) <= iLeastTMDOrMissedShotsCoveringTarget then
                                for iTMD, oTMD in oUnit[reftTMDCoveringThisUnit] do
                                    if IsTMDProtectingUnitFromTML(oTMD, oUnit, oPrimaryTML, M28UnitInfo.GetBuildingSize(oUnit.UnitId)) then
                                        if EntityCategoryContains(categories.AEON, oTMD.UnitId) then
                                            if M28Utilities.bFAFActive then
                                                iCurTMDOrMissedShotsCoveringTarget = iCurTMDOrMissedShotsCoveringTarget + 3
                                            else
                                                iCurTMDOrMissedShotsCoveringTarget = iCurTMDOrMissedShotsCoveringTarget + 10
                                            end
                                        else
                                            iCurTMDOrMissedShotsCoveringTarget = iCurTMDOrMissedShotsCoveringTarget + 1
                                        end
                                    end
                                end
                                oUnit[refiLastDetailedTMDProtectionCount] = iCurTMDOrMissedShotsCoveringTarget
                            else
                                iCurTMDOrMissedShotsCoveringTarget = table.getn(oUnit[reftTMDCoveringThisUnit])
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Number of TMD against unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has a table size='..table.getn(oUnit[reftTMDCoveringThisUnit])..'; oUnit[refiLastDetailedTMDProtectionCount]='..(oUnit[refiLastDetailedTMDProtectionCount] or 'nil')) end
                        end
                        if iCurTMDOrMissedShotsCoveringTarget <= iLeastTMDOrMissedShotsCoveringTarget then
                            --Adjust for missed shots
                            if (oUnit[refiTMLShotsFired] or 0) > (oUnit[refiTMLShotsHit] or 0) then iCurTMDOrMissedShotsCoveringTarget = iCurTMDOrMissedShotsCoveringTarget + (oUnit[refiTMLShotsFired] - (oUnit[refiTMLShotsHit] or 0)) / iMissedShotsFactor end
                            if iCurTMDOrMissedShotsCoveringTarget <= iLeastTMDOrMissedShotsCoveringTarget then
                                --Adjust for blocking terrain
                                if M28Utilities.IsTableEmpty(oPrimaryTML[reftTerrainBlockedTargets]) == false then
                                    for iBlockedTerrain, tBlockedTerrain in oPrimaryTML[reftTerrainBlockedTargets] do
                                        if M28Utilities.GetRoughDistanceBetweenPositions(tBlockedTerrain, oUnit:GetPosition()) <= 1 then
                                            iCurTMDOrMissedShotsCoveringTarget = iCurTMDOrMissedShotsCoveringTarget + 10
                                            ForkThread(RemoveUnitFromTMLTargetsInRange, oPrimaryTML, oUnit)
                                        end
                                    end
                                end
                                --Avoid targeting if it will cost so many missiles that the damage done isnt worth it
                                iCurValue = M28UnitInfo.GetUnitMassCost(oUnit) * oUnit:GetFractionComplete() - iMissileValueWanted * (iCurTMDOrMissedShotsCoveringTarget + 1)
                                if iCurValue <= 2000 and oUnit:GetFractionComplete() <= 0.8 then iCurValue = 0
                                elseif EntityCategoryContains(categories.VOLATILE, oUnit.UnitId) then
                                    if oUnit:GetFractionComplete() < 1 then iCurValue = iCurValue * 0.1
                                    else iCurValue = iCurValue * 1.5
                                    end
                                end
                                if iCurValue > 0 and iCurTMDOrMissedShotsCoveringTarget <= iLeastTMDOrMissedShotsCoveringTarget and (iCurTMDOrMissedShotsCoveringTarget < iLeastTMDOrMissedShotsCoveringTarget or iCurValue > iBestValue) then
                                    --Adjust for fixed shields
                                                                                --IsTargetUnderShield(aiBrain, oTarget, iIgnoreShieldsWithLessThanThisCurHealth, bReturnShieldHealthInstead, bIgnoreMobileShields, bTreatPartCompleteAsComplete, bCumulativeShieldHealth, bReturnShieldsCovringTargetInstead)
                                    iCurShieldHealth, iMaxShieldHealth = M28Logic.IsTargetUnderShield(aiBrain, oUnit,   0,                                          true,                       false,              true,                           true,                   false)
                                    if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurTMDOrMissedShotsCoveringTarget before shield adj='..iCurTMDOrMissedShotsCoveringTarget..'; iCurShieldHealth='..(iCurShieldHealth or 'nil')..'; iMaxShieldHealth='..(iMaxShieldHealth or 'nil')..'; iLeastTMDOrMissedShotsCoveringTarget='..iLeastTMDOrMissedShotsCoveringTarget) end
                                    if iMaxShieldHealth > 0 then
                                        iCurShieldValue = math.min(iMaxShieldHealth, math.max(iCurShieldHealth * 2, iCurShieldHealth + iStrikeDamage)) / iShieldFactor
                                        iCurTMDOrMissedShotsCoveringTarget = iCurTMDOrMissedShotsCoveringTarget + iCurShieldValue
                                        iCurValue = iCurValue - iMissileValueWanted * iCurShieldValue
                                    else
                                        iCurShieldValue = 0
                                    end
                                    if iCurTMDOrMissedShotsCoveringTarget <= iLeastTMDOrMissedShotsCoveringTarget and (iCurTMDOrMissedShotsCoveringTarget == 0 or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oPrimaryTML:GetPosition()) < iTMLMissileRange - 10) then
                                        if iCurTMDOrMissedShotsCoveringTarget < iLeastTMDOrMissedShotsCoveringTarget then iBestValue = 0 end
                                        if iCurValue > iBestValue then
                                            iBestValue = iCurValue
                                            oClosestEnemy = oUnit
                                            iAdditionalLoadedTMLNeeded = iCurTMDOrMissedShotsCoveringTarget * 2
                                            bAttackingNormalTMLTarget = true
                                            if bDebugMessages == true then LOG(sFunctionRef..': Want to try targeting enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurValue='..iCurValue..'; iAdditionalLoadedTMLNeeded='..iAdditionalLoadedTMLNeeded) end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                if oClosestEnemy then bAttackingNormalTMLTarget = true end --redundancy
            end
            if bDebugMessages == true then LOG(sFunctionRef..': oClosestEnemy='..(oClosestEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestEnemy) or 'nil')..'; iClosestEnemy='..iClosestEnemy..'; oClosestEnemy[M28UnitInfo.reftRecentUnitPositions]='..repru(oClosestEnemy[M28UnitInfo.reftRecentUnitPositions])) end
            if oClosestEnemy then
                if not(oClosestEnemy[M28UnitInfo.reftRecentUnitPositions][4]) then
                    if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oClosestEnemy.UnitId) then
                        oClosestEnemy[M28UnitInfo.reftRecentUnitPositions] = {}
                        for iPosition = 1, 4 do
                            oClosestEnemy[M28UnitInfo.reftRecentUnitPositions][iPosition] = {oClosestEnemy:GetPosition()[1], oClosestEnemy:GetPosition()[2], oClosestEnemy:GetPosition()[3]}
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Will call MonitorUnitRecentPositions for the unit') end
                        ForkThread(MonitorUnitRecentPositions, oClosestEnemy) --has a check to make sure not already running
                    end
                end
                if not(oClosestEnemy[M28UnitInfo.reftRecentUnitPositions][4]) then
                else
                    --how many TML do we have with missiles?
                    local iLoadedTMLs = 0
                    local toLoadedTMLs = {}

                    for iTML, oTML in tLZTeamData[M28Map.reftoTMLBatteryUnits] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering oTML='..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)..'; Ammo count='..oTML:GetTacticalSiloAmmoCount()..'; Time since last fired='..GetGameTimeSeconds() - (oLauncher[refiTimeLastFiredMissile] or 0)) end
                        if M28UnitInfo.IsUnitValid(oTML) and oTML:GetTacticalSiloAmmoCount() > 0 then
                            if not(oLauncher[M28UnitInfo.refiLastWeaponEvent]) or GetGameTimeSeconds() - oLauncher[M28UnitInfo.refiLastWeaponEvent] > iTimeToWaitBetweenLaunches then
                                if not(oPrimaryTML) then
                                    oPrimaryTML = oTML
                                    tBasePosition = oTML:GetPosition()
                                end
                                table.insert(toLoadedTMLs, oTML)
                                iLoadedTMLs = iLoadedTMLs + 1
                            end
                        else
                            --Make sure autobuild is enabled
                            M28UnitInfo.SetUnitMissileAutoBuildStatus(oTML, true)
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iLoadedTMLs='..iLoadedTMLs) end
                    if iLoadedTMLs > 0 then
                        local iEnemyHealth = oClosestEnemy:GetHealth() + 10 --Add 5 as enemy hp regen might mean we think we will kill it but we wont
                        if oClosestEnemy.MyShield.GetHealth then
                            local iShield = oClosestEnemy.MyShield:GetHealth()
                            iEnemyHealth = iEnemyHealth + math.ceil(iShield / iStrikeDamage) * iStrikeDamage
                        end
                        --7 TMLs should be able to 1-shot a fatboy; for megalith will just have to do several salvos
                        if bDebugMessages == true then LOG(sFunctionRef..': iStrikeDamage * iLoadedTMLs='..iStrikeDamage * iLoadedTMLs..'; iEnemyHealth='..iEnemyHealth..'; iClosestEnemy='..iClosestEnemy..'; Enemy DF range='..(oClosestEnemy[M28UnitInfo.refiDFRange] or 0)) end
                        if iLoadedTMLs >= 8 or iStrikeDamage * (iLoadedTMLs - iAdditionalLoadedTMLNeeded) > iEnemyHealth or iClosestEnemy < (oClosestEnemy[M28UnitInfo.refiDFRange] or 0) + 6 or (iLoadedTMLs >= 7 and oClosestEnemy[M28UnitInfo.reftRecentUnitPositions][4] and M28Utilities.GetDistanceBetweenPositions(oClosestEnemy[M28UnitInfo.reftRecentUnitPositions][4], oClosestEnemy:GetPosition()) <= 1 and M28Utilities.GetDistanceBetweenPositions(oClosestEnemy[M28UnitInfo.reftRecentUnitPositions][2], oClosestEnemy:GetPosition()) <= 1) then
                            --We should be able to 1-shot the enemy, so try and attack them if they are close enough to warrant firing
                            --How many shots have we already attempted at this unit? If a lot, then wait for it to get really close
                            local iMinDistWanted
                            if bAttackingNormalTMLTarget or (oClosestEnemy[refiTMLShotsFired] or 0) - (oClosestEnemy[refiTMLShotsHit] or 0) < iLoadedTMLs + (oClosestEnemy[refiTMLShotsHit] or 0) then
                                iMinDistWanted = iMaxEffectiveRange
                            else
                                --Reduce range by up to 60% if we are missing all our shots
                                local iFactorAffected = 0.6
                                if not(M28Team.tTeamData[iTeam][M28Team.refbTMLBatteryMissedLots]) and oClosestEnemy[M28UnitInfo.reftRecentUnitPositions][4] and M28Utilities.GetDistanceBetweenPositions(oClosestEnemy[M28UnitInfo.reftRecentUnitPositions][4], oClosestEnemy:GetPosition()) <= 1 and not(oClosestEnemy:IsUnitState('Moving')) then
                                    iFactorAffected = 0.3
                                end
                                iMinDistWanted = math.max(iMaxEffectiveRange * ((1 - iFactorAffected) + iFactorAffected * math.max(iLoadedTMLs, (oClosestEnemy[refiTMLShotsHit] or iLoadedTMLs)) / oClosestEnemy[refiTMLShotsFired]), 60, math.min(iMaxEffectiveRange, (oClosestEnemy[M28UnitInfo.refiCombatRange] or 0) + 10))
                                if oClosestEnemy[refiTMLShotsFired] > 28 then --We have fired 28 TMLs at this enemy, so should switch to getting T2 arti
                                    M28Team.tTeamData[iTeam][M28Team.refbTMLBatteryMissedLots] = true
                                end
                            end
                            if iClosestEnemy <= iMinDistWanted then
                                local iCurFacingAngle, iAngleToTarget, iAngleDif
                                --Is unit stationery? Or is it moving, at a decent speed, and is facing its current goal direction (or at an opposite to it, as it may be backing up)? If so then it is vulnerable to a missile attack
                                local tPredictedPosition
                                local iCurSpeed = M28UnitInfo.GetUnitSpeed(oClosestEnemy)
                                if bDebugMessages == true then LOG(sFunctionRef..': Closest enemy iCurSpeed='..iCurSpeed..'; Is moving='..tostring(oClosestEnemy:IsUnitState('Moving'))..'; Unit state='..M28UnitInfo.GetUnitState(oClosestEnemy)) end
                                local bMobileTarget = false
                                if bAttackingNormalTMLTarget and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oClosestEnemy.UnitId) then
                                    tPredictedPosition = oClosestEnemy:GetPosition()
                                elseif iCurSpeed <= 0.25 and not(oClosestEnemy:IsUnitState('Moving')) then
                                    --Have we not been moving for a while?
                                    if bDebugMessages == true then LOG(sFunctionRef..': Dist to postiion from 2-4s ago='..M28Utilities.GetDistanceBetweenPositions(oClosestEnemy:GetPosition(), oClosestEnemy[M28UnitInfo.reftRecentUnitPositions][2])) end
                                    if M28Utilities.GetDistanceBetweenPositions(oClosestEnemy:GetPosition(), oClosestEnemy[M28UnitInfo.reftRecentUnitPositions][2]) <= 1 then
                                        tPredictedPosition = oClosestEnemy:GetPosition()
                                    end
                                elseif iCurSpeed >= 1 and (oClosestEnemy:IsUnitState('Moving') or oClosestEnemy:IsUnitState('Attacking')) and oClosestEnemy.GetNavigator then
                                    bMobileTarget = true
                                    local oNavigator = oClosestEnemy:GetNavigator()
                                    if oNavigator then
                                        iCurFacingAngle = M28UnitInfo.GetUnitFacingAngle(oClosestEnemy)
                                        local tCurNavigatorTarget = oNavigator:GetCurrentTargetPos()
                                        iAngleToTarget = M28Utilities.GetAngleFromAToB(oClosestEnemy:GetPosition(), tCurNavigatorTarget)
                                        iAngleDif = M28Utilities.GetAngleDifference(iCurFacingAngle, iAngleToTarget)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy iCurFacingAngle='..iCurFacingAngle..'; iAngleToTarget='..iAngleToTarget..'; iAngleDif='..iAngleDif) end
                                        if iAngleDif >= 174 or iAngleDif <= 8 then
                                            --Check we have moved in roughly this direction previously
                                            local iAngleToRecentPosition = M28Utilities.GetAngleFromAToB(oClosestEnemy:GetPosition(), oClosestEnemy[M28UnitInfo.reftRecentUnitPositions][4])
                                            if bDebugMessages == true then LOG(sFunctionRef..': iAngleToRecentPosition='..iAngleToRecentPosition..'; Angle dif to target='..M28Utilities.GetAngleDifference(iAngleToTarget, iAngleToRecentPosition)) end
                                            if M28Utilities.GetAngleDifference(iAngleToTarget, iAngleToRecentPosition) >= 170 then
                                                tPredictedPosition = GetPredictedPositionForMobileTarget(oPrimaryTML, oClosestEnemy, false, iAngleDif, iAngleToTarget)
                                            end
                                        end
                                    end
                                end
                                if tPredictedPosition then
                                    --Check our shot isn't blocked
                                    local tExpectedMissileVertical = M28Utilities.MoveInDirection(oPrimaryTML:GetPosition(), M28Utilities.GetAngleFromAToB(oPrimaryTML:GetPosition(), oClosestEnemy:GetPosition()), 31, true)
                                    tExpectedMissileVertical[2] = tExpectedMissileVertical[2] + 60 --Doing testing, it actually only goes up by 50, but I think it travels in an arc from here to the target, as in a test scenario doing at less than +60 meant it thought it would hit a cliff when it didnt
                                    -- {oLauncher:GetPosition()[1], oLauncher:GetPosition()[2] + 65, oLauncher:GetPosition()[3]}
                                    if bDebugMessages == true then LOG(sFunctionRef..': Is line blocked='..tostring(M28Logic.IsLineBlocked(oPrimaryTML:GetAIBrain(), tExpectedMissileVertical, oClosestEnemy:GetPosition(), iAOE, false))) end
                                    if not(M28Logic.IsLineBlocked(oPrimaryTML:GetAIBrain(), tExpectedMissileVertical, oClosestEnemy:GetPosition(), iAOE, false)) then
                                        --Check there arent lots of TMD that could intercept the missile
                                        local tNearbyEnemyTMD
                                        local iBlockingTMD
                                        if bAttackingNormalTMLTarget then
                                            iBlockingTMD = iAdditionalLoadedTMLNeeded
                                        else
                                            tNearbyEnemyTMD = oClosestEnemy:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD, oPrimaryTML:GetPosition(), iClosestEnemy + 15, 'Ally')
                                            iBlockingTMD = 0
                                            if M28Utilities.IsTableEmpty(tNearbyEnemyTMD) == false then
                                                RecordIfUnitIsProtectedFromTMLByTMD(oClosestEnemy, oPrimaryTML, tNearbyEnemyTMD)
                                                if M28Utilities.IsTableEmpty(oClosestEnemy[reftTMDCoveringThisUnit]) == false then
                                                    for iTMD, oTMD in oClosestEnemy[reftTMDCoveringThisUnit] do
                                                        --Distance check to act as basic protection from if for whatever reason the TMD aren't removed and the unit is moving around
                                                        if M28UnitInfo.IsUnitValid(oTMD) and M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), oPrimaryTML:GetPosition()) < 20+iClosestEnemy then
                                                            --Also do a more detailed check of each TMD as they may not actually be blocking this TML
                                                            if IsTMDProtectingUnitFromTML(oTMD, oClosestEnemy, oPrimaryTML) then
                                                                iBlockingTMD = iBlockingTMD + 1
                                                                if EntityCategoryContains(categories.AEON, oTMD.UnitId) then
                                                                    if M28Utilities.bFAFActive then
                                                                        iBlockingTMD = iBlockingTMD + 2
                                                                    else
                                                                        iBlockingTMD = iBlockingTMD + 100
                                                                        break
                                                                    end
                                                                end
                                                            elseif bMobileTarget then
                                                                iBlockingTMD = iBlockingTMD + 0.35 --Still a risk the TMD could be blocking the units expected position
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': iBlockingTMD='..iBlockingTMD) end
                                        if iBlockingTMD < math.min(iLoadedTMLs, 5) then
                                            local iTMLsToFire = iLoadedTMLs
                                            local iTMLsFired = 0
                                            local iTMLForAlternativeTarget = 0
                                            if bAttackingNormalTMLTarget then
                                                if iLoadedTMLs > math.floor(iEnemyHealth / iStrikeDamage) + 1 + iAdditionalLoadedTMLNeeded then
                                                    if iAdditionalLoadedTMLNeeded == 0 then
                                                        --Dont worry about multiple targets since no TMD/shields
                                                        if iEnemyHealth < iStrikeDamage then
                                                            --Just fire a single TML
                                                            iTMLsToFire = 1
                                                        else
                                                            --Fire 1 more missile than expect we need
                                                            iTMLsToFire = 2 + math.floor(iEnemyHealth / iStrikeDamage)
                                                        end
                                                    else
                                                        --Element of doubt whether we can kill in a single hit, fire 2 more missiles than we think we need
                                                        iTMLsToFire = iAdditionalLoadedTMLNeeded + 2 + math.floor(iEnemyHealth / iStrikeDamage)
                                                        if M28UnitInfo.GetUnitMassCost(oClosestEnemy) >= 2000 then iTMLsToFire = iTMLsToFire + 1 end
                                                        iTMLForAlternativeTarget = math.max(0, iLoadedTMLs - iTMLsToFire)
                                                    end
                                                end
                                            elseif iLoadedTMLs >= 3 and iBlockingTMD == 0 and iEnemyHealth < (iLoadedTMLs - 2) * iStrikeDamage then
                                                iTMLsToFire = math.floor(iEnemyHealth / iStrikeDamage) + 2
                                                if iTMLsToFire >= 5 then iTMLsToFire = iTMLsToFire + 1 end
                                            end
                                            --Megalith - adjust predicted position because if we hit at the midpoint of the megalith the shot does no damage, so we want to try and hit its back instead
                                            if oClosestEnemy.UnitId == 'xrl0403' then
                                                local iAngleToAdjust = M28UnitInfo.GetUnitFacingAngle(oClosestEnemy) - 180
                                                tPredictedPosition = M28Utilities.MoveInDirection(tPredictedPosition, iAngleToAdjust, 2, true, false, false)
                                                local iAngleFromTMLToPosition = M28Utilities.GetAngleFromAToB(oPrimaryTML:GetPosition(), tPredictedPosition)
                                                tPredictedPosition = M28Utilities.MoveInDirection(tPredictedPosition, iAngleFromTMLToPosition, 10, true, false, false) --Offset of 5 with no 'move back': 6/7 missiles hit. Offset of 10 with no 'move back': 7/7 hit but only just; offset of 10 with 2 move-back: 7/7 hit and looked a bit more central
                                            end
                                            if bDebugMessages == true then
                                                LOG(sFunctionRef..': Will fire TMLs at tPredictedPosition='..repru(tPredictedPosition)..'; oClosestEnemy='..oClosestEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemy)..'; Dist to oClosestEnemy='..M28Utilities.GetDistanceBetweenPositions(oClosestEnemy:GetPosition(), tPredictedPosition)..'; Angle from enemy to predicted position='..M28Utilities.GetAngleFromAToB(oClosestEnemy:GetPosition(), tPredictedPosition)..'; iLoadedTMLs='..iLoadedTMLs..'; iTMLsToFire='..iTMLsToFire..'; iLoadedTMLs='..iLoadedTMLs..'; iTMLForAlternativeTarget='..iTMLForAlternativeTarget..'; bAttackingNormalTMLTarget='..tostring(bAttackingNormalTMLTarget or false))
                                                M28Utilities.DrawLocation(tPredictedPosition)
                                            end
                                            local iLongestDistToTarget = 0
                                            local iDistToTarget
                                            for iTMl, oTML in toLoadedTMLs do
                                                CheckIfWantToBuildAnotherMissile(oTML)
                                                --If predicted position is outside our range then just fire as cose to it as we can
                                                iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oTML:GetPosition(), tPredictedPosition)
                                                iLongestDistToTarget = math.max(iLongestDistToTarget, iDistToTarget)
                                                if iDistToTarget > iTMLMissileRange then
                                                    M28Orders.IssueTrackedTMLMissileLaunch(oTML, M28Utilities.MoveInDirection(oTML:GetPosition(), M28Utilities.GetAngleFromAToB(oTML:GetPosition(), tPredictedPosition), iTMLMissileRange, true, false, false), 1, false, 'TMLOutRSn')
                                                else
                                                    if bDebugMessages == true then LOG(sFunctionRef..': oTML='..(oTML.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTML) or 'nil')..'; oClosestEnemy='..(oClosestEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestEnemy) or 'nil')..'; Is TML valid='..tostring(M28UnitInfo.IsUnitValid(oTML))..'; Is enemy valid='..tostring(M28UnitInfo.IsUnitValid(oClosestEnemy))..'; bMobileTarget='..tostring(bMobileTarget or false)) end
                                                    if bMobileTarget and iAngleToTarget and not(oTML == oPrimaryTML) and not(oClosestEnemy.UnitId == 'xrl0403') then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Will get position specific to the TML, iAngleDif='..(iAngleDif or 'nil')..'; iAngleToTarget='..(iAngleToTarget or 'nil')..'; iAngleDif='..(iAngleDif or 'nil')) end
                                                        M28Orders.IssueTrackedTMLMissileLaunch(oTML, GetPredictedPositionForMobileTarget(oPrimaryTML, oClosestEnemy, true,  M28Utilities.GetAngleDifference((iCurFacingAngle or M28UnitInfo.GetUnitFacingAngle(oClosestEnemy)), iAngleToTarget), iAngleToTarget), 1, false, 'TMLSnipe')
                                                    else
                                                        M28Orders.IssueTrackedTMLMissileLaunch(oTML, tPredictedPosition, 1, false, 'TMLSnipe')
                                                    end
                                                    RecordTMLMissileTarget(oTML, oClosestEnemy)
                                                    iTMLsFired = iTMLsFired + 1
                                                end
                                                if iTMLsFired >= iTMLsToFire then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Have fired all the TMLs we want to at this target, iTMLForAlternativeTarget='..iTMLForAlternativeTarget) end
                                                    if iTMLForAlternativeTarget > 0 then
                                                        --Switch to an alternative target - if have TMD covering the unit then try and kill the closest TMD to us
                                                        local oNewEnemy
                                                        local iClosestTMDOrShield = iTMLMissileRange - 3
                                                        if M28Utilities.IsTableEmpty(oClosestEnemy[reftTMDCoveringThisUnit]) == false then
                                                            for iTMD, oTMD in oClosestEnemy[reftTMDCoveringThisUnit] do
                                                                if M28UnitInfo.IsUnitValid(oTMD) then
                                                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), oTML:GetPosition())
                                                                    if iCurDist < iClosestTMDOrShield then
                                                                        oNewEnemy = oTMD
                                                                    end
                                                                end
                                                            end
                                                        end
                                                        if M28Utilities.IsTableEmpty(oClosestEnemy[reftoShieldsProvidingCoverage]) == false then
                                                            for iShield, oShield in oClosestEnemy[reftoShieldsProvidingCoverage] do
                                                                if M28UnitInfo.IsUnitValid(oShield) then
                                                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oTML:GetPosition())
                                                                    if iCurDist < iClosestTMDOrShield then
                                                                        oNewEnemy = oShield
                                                                    end
                                                                end
                                                            end
                                                        end
                                                        oClosestEnemy = oNewEnemy
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try firing at alternative target if have one, new oClosestEnemy='..(oClosestEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestEnemy) or 'nil')..'; iTMLsToFire for this='..iTMLsToFire..'; iTMLForAlternativeTarget='..iTMLForAlternativeTarget) end
                                                        if oClosestEnemy then
                                                            iTMLsToFire = math.max(math.min(iTMLForAlternativeTarget, 2), math.floor((M28UnitInfo.GetUnitCurHealthAndShield(oClosestEnemy) * 1.1 + 100) / iStrikeDamage) + 1)
                                                            iTMLForAlternativeTarget = math.max(0, iTMLForAlternativeTarget - iTMLsToFire)
                                                            bMobileTarget = false
                                                            tPredictedPosition = oClosestEnemy:GetPosition()
                                                            bAttackingNormalTMLTarget = true --redundancy
                                                            iTMLsFired = 0
                                                        else
                                                            break
                                                        end
                                                    else
                                                        break
                                                    end
                                                end
                                            end
                                            iTimeToWaitInTicks = iTimeToWaitBetweenLaunches * 10
                                            --If firing at normal target want to reduce overkilling
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to extent TML target, bAttackingNormalTMLTarget='..tostring(bAttackingNormalTMLTarget or false)..'; iLongestDistToTarget='..(iLongestDistToTarget or 'nil')..'; iTimeToWaitInTicks before potential extension='..iTimeToWaitInTicks..'; Cur time='..GetGameTimeSeconds()) end
                                            if bAttackingNormalTMLTarget and iLongestDistToTarget > 0 then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will extend time to wait as firing at normal TML target, iLongestDistToTarget='..iLongestDistToTarget) end
                                                iTimeToWaitInTicks = math.max(100, iTimeToWaitInTicks, 35 + iLongestDistToTarget / 1.2) --at +30 we stil had missiles sometimes firing twice
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            else
                --No closest enemy, increase delay to once every 5s if shorter so we arent constnatly searching for nearby targets where we are doing more calculations
                iTimeToWaitInTicks = math.max(iTimeToWaitInTicks, 50)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will wait iTimeToWaitInTicks='..iTimeToWaitInTicks..' before next cycle') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(iTimeToWaitInTicks)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        tLZTeamData[M28Map.refbActiveTMLMonitor] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordTMLMissileTarget(oLauncher, oBestTarget)
    if not(oLauncher.Dead) and oLauncher:IsUnitState('Busy') and (GetGameTimeSeconds() - (oLauncher[refiTimeOfLastLaunch] or -100)) < 5 and M28UnitInfo.IsUnitValid(oLauncher[refoLastTMLTarget]) then
        oLauncher[refoLastTMLTarget][refiTMLShotsFired] = (oLauncher[refoLastTMLTarget][refiTMLShotsFired] or 0) - 1 --ignore thel ast target as looks like we never actually fired the missile
    end
    oBestTarget[refiTMLShotsFired] = (oBestTarget[refiTMLShotsFired] or 0) + 1
    oLauncher[refoLastTMLTarget] = oBestTarget
    oLauncher[refiLastTMLMassKills] = (oLauncher.VetExperience or oLauncher.Sync.totalMassKilled or 0)
    oBestTarget[refoLastTMLLauncher] = oLauncher
    oBestTarget[refiTimeOfLastLaunch] = GetGameTimeSeconds()
end

function RemoveUnitFromTMLTargetsInRange(oTML, oUnit)
    --Intended where terrain is blocking shots, so we dont continue to consider for TML battery due to the risk of greater cpu load
    if M28Utilities.IsTableEmpty(oTML[reftUnitsInRangeOfThisTML]) == false then
        for iTarget, oTarget in oTML[reftUnitsInRangeOfThisTML] do
            if oTarget == oUnit then
                table.remove(oTML[reftUnitsInRangeOfThisTML], iTarget)
                break
            end
        end
    end
end

function GetTargetsWithoutTMDCoverageBasedOnZoneMidpoint(tTMLLZTeamData, tTargetLZTeamData, iTargetPlateauOrZero, iTargetZone, tPlannedTMLLocation, iOptionalTMDRequiredToBlock)
    --Only refresh once every 60s for performance reasons (or 10s if we have targets, since those targets may well die and would expect we cancel TML builder logic if we have a TML already)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TMLBatteryMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bRefresh = false
    if not(tTMLLZTeamData[M28Map.refiTimeOfLastDetailedTMLTMDCheckByPlateauAndZone][iTargetPlateauOrZero][iTargetZone]) then
        bRefresh = true
        if not(tTMLLZTeamData[M28Map.refiTimeOfLastDetailedTMLTMDCheckByPlateauAndZone][iTargetPlateauOrZero]) then
            if not(tTMLLZTeamData[M28Map.refiTimeOfLastDetailedTMLTMDCheckByPlateauAndZone]) then
                tTMLLZTeamData[M28Map.refiTimeOfLastDetailedTMLTMDCheckByPlateauAndZone] = {}
                tTMLLZTeamData[M28Map.refiDetailedTMLTargetWithoutTMDCheckByPlateauAndZone] = {}
            end
            tTMLLZTeamData[M28Map.refiTimeOfLastDetailedTMLTMDCheckByPlateauAndZone][iTargetPlateauOrZero] = {}
            tTMLLZTeamData[M28Map.refiDetailedTMLTargetWithoutTMDCheckByPlateauAndZone][iTargetPlateauOrZero] = {}
        end
    else
        local iTimeSinceLastUpdate = GetGameTimeSeconds() - tTMLLZTeamData[M28Map.refiTimeOfLastDetailedTMLTMDCheckByPlateauAndZone][iTargetPlateauOrZero][iTargetZone]
        if iTimeSinceLastUpdate >= 60 or (iTimeSinceLastUpdate >= 10 and tTMLLZTeamData[M28Map.refiDetailedTMLTargetWithoutTMDCheckByPlateauAndZone][iTargetPlateauOrZero][iTargetZone] > 0) then
            bRefresh = true
        end
    end
    if bRefresh then
        local iTargetsWithoutTMD = 0
        local iTMDRequiredToBlock = iOptionalTMDRequiredToBlock or 1
        local iBlockingTMD
        if M28Utilities.IsTableEmpty(tTargetLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets]) == false then
            for iTarget, oTarget in tTargetLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets] do
                iBlockingTMD = 0
                if M28UnitInfo.IsUnitValid(oTarget) and M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), tPlannedTMLLocation) <= iTMLMissileRange then
                    if M28Utilities.IsTableEmpty(oTarget[reftTMDCoveringThisUnit]) == false then
                        for iTMD, oTMD in oTarget[reftTMDCoveringThisUnit] do
                            if M28UnitInfo.IsUnitValid(oTMD) then
                                if IsTMDProtectingUnitFromTML(oTMD, oTarget, nil, nil, tPlannedTMLLocation) then
                                    iBlockingTMD = iBlockingTMD + 1
                                    if iBlockingTMD >= iTMDRequiredToBlock then
                                        break
                                    else
                                        if EntityCategoryContains(M28UnitInfo.refCategoryAeon, oTMD.UnitId) then
                                            if M28Utilities.bFAFActive then
                                                iBlockingTMD = iBlockingTMD + 2
                                            else
                                                iBlockingTMD = iBlockingTMD + 100
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    if iBlockingTMD < iTMDRequiredToBlock then
                        iTargetsWithoutTMD = iTargetsWithoutTMD + 1
                    end
                end
            end
        end
        tTMLLZTeamData[M28Map.refiTimeOfLastDetailedTMLTMDCheckByPlateauAndZone][iTargetPlateauOrZero][iTargetZone] = GetGameTimeSeconds()
        tTMLLZTeamData[M28Map.refiDetailedTMLTargetWithoutTMDCheckByPlateauAndZone][iTargetPlateauOrZero][iTargetZone] = iTargetsWithoutTMD
        if bDebugMessages == true then LOG(sFunctionRef..': Done detailed refresh for target P'..iTargetPlateauOrZero..'Z'..iTargetZone..'; iTargetsWithoutTMD='..iTargetsWithoutTMD) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tTMLLZTeamData[M28Map.refiDetailedTMLTargetWithoutTMDCheckByPlateauAndZone][iTargetPlateauOrZero][iTargetZone]
end

function ConsiderGettingPreemptiveTMD(oPD)
    --Called where we finish construction of T2 PD - check how many T2 PD we have in the zone, and flag all T2 PD to have TMD preemptively
    if M28UnitInfo.IsUnitValid(oPD) then
        local iTeam = oPD:GetAIBrain().M28Team
        --If enemy has T3 land then dont bother
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] < 3 then
            local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oPD:GetPosition(), true, iTeam)
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                local tFriendlyT2PD = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD - categories.TECH1, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if M28Utilities.IsTableEmpty(tFriendlyT2PD) == false then
                    local iT2PDInZone = 1
                    for iUnit, oUnit in tFriendlyT2PD do
                        if not(oUnit.Dead) and not(oUnit == oPD) then
                            iT2PDInZone = iT2PDInZone + 1
                        end
                    end
                    if iT2PDInZone >= 3 and ((iT2PDInZone >= 6 and tLZTeamData[M28Map.refiRadarCoverage] < 160) or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyMobileTML]) == false and (M28UnitInfo.IsUnitValid(M28Team.tTeamData[iTeam][M28Team.reftEnemyMobileTML][1]) or M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftEnemyMobileTML]))) then
                        local iTMDWanted = math.min(3, iT2PDInZone - 2)
                        local toPDUpdated = {}
                        oPD[refiMinTMDWantedForUnit] = iTMDWanted --redundancy in case for some reason we havent yet recorded against the LZTeamData
                        table.insert(toPDUpdated, oPD)
                        for iUnit, oUnit in tFriendlyT2PD do
                            if not(oUnit.Dead) and not(oUnit == oPD) then
                                if (oUnit[refiMinTMDWantedForUnit] or 0) < iTMDWanted then
                                    oUnit[refiMinTMDWantedForUnit] = iTMDWanted
                                    table.insert(toPDUpdated, oUnit)
                                end
                            end
                        end
                        RecordIfUnitsWantTMDCoverageAgainstLandZone(iTeam, toPDUpdated, true)
                    end
                end
            end
        end
    end
end

function GetManualPDTarget(oUnit, oOptionalTargetToIgnore)    
    --Intended for use where PD shot is blocked
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetManualPDTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28UnitInfo.IsUnitValid(oUnit) and (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then
        local aiBrain = oUnit:GetAIBrain()

        local tNearbyEnemies = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryNavalSurface, oUnit:GetPosition(), oUnit[M28UnitInfo.refiDFRange], 'Enemy')
        if bDebugMessages == true then LOG(sFunctionRef..': Is tNearbyEnemies empty='..tostring(M28Utilities.IsTableEmpty(tNearbyEnemies))..'; PD oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; owned by '..aiBrain.Nickname..'; Time='..GetGameTimeSeconds()) end
        if M28Utilities.IsTableEmpty(tNearbyEnemies) == false then
            local toUnitByPriorityType = {}
            local iPriorityExperimental = 1
            local iPriorityIndirect = 2
            local iPriorityCombat = 3
            local iPriorityOther = 4
            local iUnitPriority
            local oExperimentalToTarget
            local oIndirectToTarget
            local oCombatToTarget
            local oOtherToTarget

            for iEnemy, oEnemy in tNearbyEnemies do
                if not(oOptionalTargetToIgnore) or not(oOptionalTargetToIgnore == oEnemy) then
                    iUnitPriority = nil
                    if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oExperimentalToTarget.UnitId) then
                        iUnitPriority = 1
                    elseif not(oIndirectToTarget) then
                        if EntityCategoryContains(M28UnitInfo.refCategoryIndirect, oEnemy.UnitId) then
                            iUnitPriority = 2
                        elseif not(oCombatToTarget) then
                            if (oEnemy[M28UnitInfo.refiCombatRange] or 0) > 0 then
                                iUnitPriority = 3
                            elseif not(oOtherToTarget) then
                                iUnitPriority = 4
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if shot blocked for oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; is shot blocked='..tostring(M28Logic.IsShotBlocked(oUnit, oEnemy))..'; iUnitPriority='..(iUnitPriority or 'nil')) end
                    if iUnitPriority and not(M28Logic.IsShotBlocked(oUnit, oEnemy)) then
                        toUnitByPriorityType[iUnitPriority] = oEnemy
                        if iUnitPriority == 1 then break end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(toUnitByPriorityType) == false then
                local iLowestPriority = 100
                local oEnemyToTarget
                for iPriority, oEnemy in toUnitByPriorityType do
                    if iPriority < iLowestPriority then
                        iLowestPriority = iPriority
                        oEnemyToTarget = oEnemy
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Will try manual attack of unit '..oEnemyToTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToTarget)) end
                M28Orders.IssueTrackedAttack(oUnit, oEnemyToTarget, false, 'PDManAtck', false)
            end
        end
    end
end

function AssessT3EngineerConstructionOptions(oUnit)
    --Called when a t3 engi is created - so can check for certain buildings (without worrying about them being present in the list of blueprints but not actually buildable to us in the game due say to unit restrictions or only being available for a particular faction)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssessT3EngineerConstructionOptions'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain = oUnit:GetAIBrain()
    if aiBrain.M28AI then --redundancy
        --Can we build a super-powerful shield?
        local sMostExpensiveShield = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryFixedShield, oUnit, false, false, false, nil, false, nil, true)
        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; sMostExpensiveShield='..(sMostExpensiveShield or 'nil')) end
        if sMostExpensiveShield then
            local oBP = M28UnitInfo.GetBlueprintFromID(sMostExpensiveShield)
            if bDebugMessages == true then LOG(sFunctionRef..': oBP.Defense.Shield.ShieldMaxHealth='..(oBP.Defense.Shield.ShieldMaxHealth or 'nil')..'; iExperimentalShieldHealthValue='..iExperimentalShieldHealthValue) end
            local iMinShieldSize = 50 --sera t3 shield is 46, i.e. this means we have a very high health and large shield
            if oBP.Defense.Shield.ShieldMaxHealth >= iExperimentalShieldHealthValue and oBP.Defense.Shield.ShieldSize >= iMinShieldSize then
                --Get list of all shields we can build with this unit, and make sure the cheapest of them that satisfies the requirements is recorded
                local iMaxShieldCost = 20000 --If the shield costs more than 20k mass then there is no point building running our special logic as it'll lead to us just building loads of shields in our base while enemy overruns us with land units
                local iCheapestShield = iMaxShieldCost
                local tsShieldsOfInterest = {}
                local tAllShields = EntityCategoryGetUnitList(M28UnitInfo.refCategoryFixedShield)
                local oCurBP
                for _, sShieldBlueprint in  tAllShields do
                    oCurBP = M28UnitInfo.GetBlueprintFromID(sShieldBlueprint)
                    if (oCurBP.Defense.Shield.ShieldMaxHealth or 0) >= iExperimentalShieldHealthValue and oCurBP.Economy.BuildCostMass <= iMaxShieldCost then
                        table.insert(tsShieldsOfInterest, sShieldBlueprint)
                        iCheapestShield = math.min(iCheapestShield, (oCurBP.Economy.BuildCostMass or 10000000))
                    end
                end
                if M28Utilities.IsTableEmpty(tsShieldsOfInterest) == false then
                    local iMassThreshold = iCheapestShield * 1.2
                    for _, sShieldBlueprint in tsShieldsOfInterest do
                        oCurBP = M28UnitInfo.GetBlueprintFromID(sShieldBlueprint)
                        if oCurBP.Economy.BuildCostMass <= iMassThreshold then
                            if not(aiBrain[M28Overseer.reftbExperimentalShieldsConsidered][sShieldBlueprint]) then
                                aiBrain[M28Overseer.refbCanBuildExperimentalShields] = true
                                if not(aiBrain[M28Overseer.reftbExperimentalShieldsConsidered]) then aiBrain[M28Overseer.reftbExperimentalShieldsConsidered] = {} end
                                table.insert(aiBrain[M28Overseer.reftbExperimentalShieldsConsidered], sShieldBlueprint)
                                if not(aiBrain[M28Overseer.refiExperimentalShieldCategory]) then aiBrain[M28Overseer.refiExperimentalShieldCategory] = categories[sShieldBlueprint]
                                else aiBrain[M28Overseer.refiExperimentalShieldCategory] = aiBrain[M28Overseer.refiExperimentalShieldCategory] + categories[sShieldBlueprint]
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': recording that we can build experimental level shields for brain '..aiBrain.Nickname..'; recording sShieldBlueprint='..sShieldBlueprint..' with mass cost of '..oCurBP.Economy.BuildCostMass..' and a shield health of '..oCurBP.Defense.Shield.ShieldMaxHealth..' with a shield size of '..oCurBP.Defense.Shield.ShieldSize) end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderGiftingMassStorageToNearbyMexOwner(oJustBuilt)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderGiftingMassStorageToNearbyMexOwner'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --If just built a mass storage but we dont own the mex it is adjacent to, then gift the storage
    local rSearchRectangle = M28Utilities.GetRectAroundLocation(oJustBuilt:GetPosition(), 2.749)
    local tNearbyUnits = GetUnitsInRect(rSearchRectangle) --at 1.5 end up with storage thats not adjacent being gifted in some cases but not in others; at 1 none of it gets gifted; the mass storage should be exactly 2 from the mex; however even at 2.1, 2.25 and 2.499 had cases where the mex wasnt identified so will try 2.75 since distances can vary/be snapped to the nearest 0.5 I think
    local aiBrain = oJustBuilt:GetAIBrain()
    local iTeam = aiBrain.M28Team
    if bDebugMessages == true then
        LOG(sFunctionRef..': Storage gifting where built storage - oJustBuilt='..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; owner='..aiBrain.Nickname..'; is tNearbyUnits empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnits)))
        if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
            for iUnit, oUnit in tNearbyUnits do
                LOG(sFunctionRef..': iUnit '..iUnit..' in tNearbyUnits='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; owner='..oUnit:GetAIBrain().Nickname)
            end
        end
    end
    if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
        local tNearbyMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tNearbyUnits)
        if M28Utilities.IsTableEmpty(tNearbyMexes) == false then
            local bHaveMexWeOwnNearby = false
            local oBrainToTransferToIfWeOwnNoMexes
            for iUnit, oUnit in tNearbyMexes do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering nearby unit oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname) end
                if oUnit:GetAIBrain() == aiBrain then
                    bHaveMexWeOwnNearby = true
                elseif oUnit:GetAIBrain().M28Team == iTeam and (oUnit:GetAIBrain().M28AI or ScenarioInfo.Options.M28Teammate == 1) then
                    oBrainToTransferToIfWeOwnNoMexes = oUnit:GetAIBrain()
                end
            end
            if not(bHaveMexWeOwnNearby) and oBrainToTransferToIfWeOwnNoMexes then
                if bDebugMessages == true then LOG(sFunctionRef..': Will try and gift the storage to the player who owns the mex already there') end
                M28Team.TransferUnitsToPlayer({oJustBuilt}, oBrainToTransferToIfWeOwnNoMexes:GetArmyIndex(), false)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderUpgradingT2Radar(oRadar)
    --Consider getting omni in minor zones (as an upgrade of existing T2 radar), provided not close to the map edge, and still on our side of the map
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderUpgradingT2Radar'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start, is oRadar valid='..tostring(M28UnitInfo.IsUnitValid(oRadar))..'; Map size='..M28Map.iMapSize) end
    if M28UnitInfo.IsUnitValid(oRadar) and M28Map.iMapSize >= 800 then
        local aiBrain = oRadar:GetAIBrain()
        local iTeam = aiBrain.M28Team
        local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oRadar:GetPosition(), true, iTeam)
        if bDebugMessages == true then
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftClosestFriendlyBase]) == false then
                LOG(sFunctionRef..': Considering for oRadar='..oRadar.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRadar)..' owned by '..aiBrain.Nickname..' at time='..GetGameTimeSeconds()..'; Mod dist%='..tLZTeamData[M28Map.refiModDistancePercent]..'; Dist to friendly base='..M28Utilities.GetDistanceBetweenPositions(oRadar:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])..'; LZMexCount='..(tLZData[M28Map.subrefLZOrWZMexCount] or 'nil'))
            else
                LOG(sFunctionRef..': Dont have a valid closest friendly base')
            end
        end
        if tLZTeamData[M28Map.refiModDistancePercent] >= 0.15 and not(tLZTeamData[M28Map.subrefLZbCoreBase]) and tLZTeamData[M28Map.refiModDistancePercent] <= 0.45 and M28Utilities.GetDistanceBetweenPositions(oRadar:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) >= 200 and (tLZData[M28Map.subrefLZOrWZMexCount] or 0) > 0 then
            --Are we close to map edge?
            local iX = oRadar:GetPosition()[1]
            local iZ = oRadar:GetPosition()[3]
            local iMinDistFromMapEdge = 100
            if bDebugMessages == true then LOG(sFunctionRef..': iX='..iX..'; iZ='..iZ) end
            if iX >= iMinDistFromMapEdge and iZ >= iMinDistFromMapEdge and iX <= M28Map.iMapSize - iMinDistFromMapEdge and iZ <= M28Map.iMapSize - iMinDistFromMapEdge then
                local sUpgradeID = M28UnitInfo.GetUnitUpgradeBlueprint(oRadar, true)
                if bDebugMessages == true then
                    if sUpgradeID then LOG(sFunctionRef..': sUpgradeID='..(sUpgradeID or 'nil')..'; canbuild='..tostring(oRadar:CanBuild(sUpgradeID)))
                    else LOG(sFunctionRef..': No valid upgrade ID')
                    end
                end
                if sUpgradeID and oRadar:CanBuild(sUpgradeID) then
                    local iSecondsToWait = 30
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

                    WaitSeconds(iSecondsToWait * 2)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    while M28UnitInfo.IsUnitValid(oRadar) do
                        --Abort if we now have good radar coverage
                        if tLZTeamData[M28Map.refiRadarCoverage] > M28UnitInfo.iT2RadarSize + 80 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Radar coverage good enough that we dont need omni, tLZTeamData[M28Map.refiRadarCoverage]='..(tLZTeamData[M28Map.refiRadarCoverage] or 'nil')) end
                            break
                        else
                            --Do we have the eco to support an omni outside of our core base?
                            if bDebugMessages == true then LOG(sFunctionRef..': Checking if we want to upgrade t2 radar '..oRadar.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRadar)..' owned by '..oRadar:GetAIBrain().Nickname..' to omni radar, T3 mex count='..tLZTeamData[M28Map.subrefMexCountByTech][3]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Gross E='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Enemy combat in zone='..(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; Enemy air to ground='..(M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] or 'nil')..'; subrefiOurT1ToT3BomberThreat='..M28Team.tTeamData[iTeam][M28Team.subrefiOurT1ToT3BomberThreat]..'; our gunship threat='..M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat]..'; Time='..GetGameTimeSeconds()) end
                            if tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 40 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 1500 and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] == 0 and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] == 0 and (M28Team.tTeamData[iTeam][M28Team.subrefiOurT1ToT3BomberThreat] + (M28Team.tTeamData[iTeam][M28Team.subrefiOurExpBomberThreat] or 0) >= 25000 or M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] >= 35000) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have low power='..tostring(M28Conditions.HaveLowPower(iTeam))..'; Stalling mass='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] or false)) end
                                if not(M28Conditions.HaveLowPower(iTeam)) and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) then
                                    --Upgrade unless already upgrading a t3 radar
                                    if bDebugMessages == true then
                                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingOther]) then LOG(sFunctionRef..': No other upgrades active on team')
                                        else
                                            LOG(sFunctionRef..': Is table of T2+ radar getting upgrade empty on team='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryRadar - categories.TECH1, M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingOther]))))
                                        end

                                    end
                                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingOther]) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryRadar - categories.TECH1, M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingOther])) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try upgrading t2 radar to omni') end
                                        M28Economy.UpgradeUnit(oRadar, true)
                                        break
                                    else
                                        iSecondsToWait = 5
                                    end
                                else
                                    iSecondsToWait = 30
                                end
                            else
                                iSecondsToWait = 30
                            end

                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitSeconds(iSecondsToWait)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GEMobileShieldTeleDefence(oTeleportingUnit, tTeleportDestination, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GEMobileShieldTeleDefence'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28UnitInfo.IsUnitValid(oTeleportingUnit) then
        --Get target zone and check for nearby shields that are part of a GE template

        local oFirstM28Brain = M28Team.GetFirstActiveM28Brain(iTeam)
        if oFirstM28Brain then
            local teleport = import('/lua/shared/teleport.lua')
            local energyCost, time, teleDelay
            if teleport and rawget(teleport, 'TeleportCostFunction') then
                if bDebugMessages == true then LOG(sFunctionRef..': calculating precise teleport time for FAF') end
                energyCost, time, teleDelay = import('/lua/shared/teleport.lua').TeleportCostFunction(oTeleportingUnit, tTeleportDestination)
            else
                if M28Utilities.bFAFActive then
                    M28Utilities.ErrorHandler('Failed to calculate teleport time in FAF, will use hardcoded value')
                    time = 15
                    teleDelay = 15
                elseif M28Utilities.bQuietModActive or M28Utilities.bLoudModActive then
                    time = 30 --https://github.com/Team-QUIET/QUIET/blob/547c370c538208501807bb64a15dc7e624c6f9a1/gamedata/lua/lua/sim/Unit.lua#L5391 - Az thought c.30s for 6-7km
                    teleDelay = 30
                else
                    time = 10
                    teleDelay = 10
                end
            end
            --For now am assuming time is the time until teleport compeltes in seconds, not 100% sure though
            local iTimeUntilTeleport = time
            local iTimeForShieldRecharge = 5
            if bDebugMessages == true then LOG(sFunctionRef..': oTeleportingUnit='..oTeleportingUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTeleportingUnit)..'; iTimeUntilTeleport='..iTimeUntilTeleport..'; time='..time..';teleDelay='..teleDelay..'; GameTime='..GetGameTimeSeconds()) end
            if iTimeUntilTeleport > (iTimeForShieldRecharge - 0.1) then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitSeconds(iTimeUntilTeleport - iTimeForShieldRecharge + 1) --dont want shields to actually be enabled until after enemy has teleported, as highly unlikely we kill enemy in less than a second, and also unlikely enemy is quick enough to ctrlk in under a second
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
            if not(oFirstM28Brain.M28IsDefeated) then
                local tNearbyMobileShields = oFirstM28Brain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLandShield, tTeleportDestination, 60, 'Ally')
                if bDebugMessages == true then LOG(sFunctionRef..': is tNearbyMobileShields empty='..tostring(M28Utilities.IsTableEmpty(tNearbyMobileShields))) end
                if M28Utilities.IsTableEmpty(tNearbyMobileShields) == false then
                    local iMaxWaitTime = 60
                    for iShield, oShield in tNearbyMobileShields do
                        if bDebugMessages == true then LOG(sFunctionRef..': Will enable mobile shield if not already, oShield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; oShield[M28UnitInfo.refbShieldIsDisabled]='..tostring(oShield[M28UnitInfo.refbShieldIsDisabled] or false)) end
                        if oShield[M28UnitInfo.refbShieldIsDisabled] then
                            M28UnitInfo.EnableUnitShield(oShield)
                        end
                        M28Micro.EnableUnitMicroUntilManuallyTurnOff(oShield)
                    end
                    local iCurDistToTeleport, iMinDistWanted, iCurAngleToShieldTarget
                    local iTimeWaited = 0
                    local tTeleportOrUnitPosition, tCurShieldTarget, tTempMovePosition
                    while M28UnitInfo.IsUnitValid(oTeleportingUnit) and not(oFirstM28Brain.M28IsDefeated) do
                        --Enable all mobile shields around the target that are disabled, and if they are within 8 of their destination and also shield is overlapping the teleport destination have them move away
                        if M28Conditions.IsTableOfUnitsStillValid(tNearbyMobileShields) then
                            if iTimeWaited > iTimeForShieldRecharge then
                                tTeleportOrUnitPosition = oTeleportingUnit:GetPosition()
                            else tTeleportOrUnitPosition = tTeleportDestination
                            end
                            local bCampaignMap = M28Map.bIsCampaignMap
                            if bDebugMessages == true then LOG(sFunctionRef..': Will loop through shields and keep them away from the teleport destination, time='..GetGameTimeSeconds()..'; iTimeWaited='..iTimeWaited..'; iMaxWaitTime') end
                            for iShield, oShield in tNearbyMobileShields do
                                if oShield:GetAIBrain().M28AI then
                                    iCurDistToTeleport = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), tTeleportOrUnitPosition)
                                    iMinDistWanted = (oShield.MyShield.Size or oShield:GetBlueprint().Defense.Shield.ShieldSize or 17) * 0.5 + 3
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oShield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; CurShield health='..oShield.MyShield:GetHealth()..'; refbShieldIsDisabled='..tostring(oShield[M28UnitInfo.refbShieldIsDisabled] or false)..'; iCurDistToTeleport='..iCurDistToTeleport..'; iMinDistWanted='..iMinDistWanted..'; refbSpecialMicroActive='..tostring(oShield[M28UnitInfo.refbSpecialMicroActive] or false)) end
                                    if iCurDistToTeleport < iMinDistWanted then
                                        iCurAngleToShieldTarget = nil
                                        if M28UnitInfo.IsUnitValid(oShield[M28Land.refoMobileShieldTarget]) then
                                            tCurShieldTarget = oShield[M28Land.refoMobileShieldTarget]:GetPosition()
                                        elseif oShield[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition] then
                                            tCurShieldTarget = {oShield[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition][1], oShield[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition][2], oShield[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition][3]}
                                        else
                                            tCurShieldTarget = oShield:GetPosition()
                                            iCurAngleToShieldTarget = M28Utilities.GetAngleFromAToB(tTeleportOrUnitPosition, oShield:GetPosition())
                                        end
                                        if not(iCurAngleToShieldTarget) then iCurAngleToShieldTarget = M28Utilities.GetAngleFromAToB(oShield:GetPosition(), tCurShieldTarget)
                                            tTempMovePosition = M28Utilities.MoveInDirection(oShield:GetPosition(), iCurAngleToShieldTarget, math.max(4, iMinDistWanted - iCurDistToTeleport + 2), true, false, bCampaignMap)
                                            M28Orders.IssueTrackedMove(oShield, tTempMovePosition, 0.1, false, 'MobShTelMv', true)
                                        end
                                    end
                                end
                            end
                        end
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitSeconds(1)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        iTimeWaited = iTimeWaited + 1
                        if iTimeWaited > iMaxWaitTime then break end
                    end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitSeconds(0.5) --just in case there's a delay on an explosion
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    if M28Conditions.IsTableOfUnitsStillValid(tNearbyMobileShields) then
                        for iShield, oShield in tNearbyMobileShields do
                            --Disable shields again if part of GE template
                            if oShield[reftArtiTemplateRefs] then
                                if bDebugMessages == true then LOG(sFunctionRef..': Disabling shield, oShield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)) end
                                M28UnitInfo.DisableUnitShield(oShield)
                            end
                            oShield[M28UnitInfo.refbSpecialMicroActive] = false
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end