---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 29/01/2023 18:46
---

local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28Chat = import('/mods/M28AI/lua/AI/M28Chat.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')


--Global variables
iTMLMissileRange = 256 --e.g. use if dont have access to a unit blueprint
iEnergyStorageExpectedCapacity = 5000 --i.e. how much energy does an energy storage hold - for a long time for FAF was 5k, but beta balance changes (expected July 2023) are meant to be changing this

--Variables against a unit:
    --TML and TMD
reftTMLInRangeOfThisUnit = 'M28BuildTMLInRange' --Records table of TML in range of this unit
reftUnitsInRangeOfThisTML = 'M28BuildUnitsInRangeOfTML' --Records units threatened by this TML, from the perspective of the threatened unit's team
reftUnprotectedUnitTargetsForThisTML = 'M28BuildTargetsInRangeOfTML' --records units that TML should be able to hit, from the perspective of the TML owner's team
reftUnitsCoveredByThisTMD = 'M28BuildUnitsCoveredByTMD' --Against TMD, table of units that it provides TML coverage to
reftTMDCoveringThisUnit = 'M28BuildTMDCoveringUnit' --against unit, table of TMD providing TML coverage to it
refbUnitWantsMoreTMD = 'M28BuildUnitWantsTMD' --true if a unit wants more TMD
refbNoNearbyTMDBuildLocations = 'M28BuiltUnitHasNoNearbyTMDBuildLocations' --true if we buitl a TMD to cover this unit and the TMD ended up too far away
refbMissileRecentlyBuilt = 'M28BuildMissileBuiltRecently' --true if unit has recently built a missile
refbMissileChecker = 'M28BuildMissileChecker' --true if active missile builder checker for the unit
reftActiveNukeTarget = 'M28BuildLastTargetLaucnh' --Against oLauncher, returns location of the target we last launched a TML/Nuke at while the missile is still alive, set to nil once the missile dies
reftMobileTMLLastLocationChecked = 'M28BuildLastTMLLoc' --against mobile missile TMLs like ACU/SACU, to determine if shoudl rerun logic for identifying targets
refiTimeMobileTMLLastChecked = 'M28BuildLastTMLChk' --Gametimeseconds that we last refreshed a mobile TML's potential targets
refbTMDBuiltSinceLastChecked = 'M28BuildTMDMobChk' --true if we have built a TMD since the last time we checked mobile TML
--refbActiveMissileChecker = 'M28BuildMissileTargetChecker' --true if active missile target checker for the unit
--iTMLHighPriorityCategories = M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryT3Mex * categories.CYBRAN + M28UnitInfo.refCategoryT2Mex + M28UnitInfo.refCategoryTML + M28UnitInfo.refCategorySML + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategoryT2Power + M28UnitInfo.refCategoryT3Radar
tbExpectMissileBlockedByCliff = 'M28BuildMisBlck' --true if missile firing at this has hit a cliff
refiTMLShotsFired = 'M28BuildTMLShtFird'
refoLastTMLTarget = 'M28BuildTMLLstTrg'
refoLastTMLLauncher = 'M28BuildTMLLastLnch' --When a TML targets a unit, this is recorded against that unit, so if we have 2 TML they shouldn't target the same unit at the same time
refiTimeOfLastLaunch = 'M28BuildTMLTimLstLnch' --Gametimeseconds that we last fired a missile at the unit, i.e. this is against the target, not the launcher
refiTimeLastFiredMissile = 'M28BuildTMLTmLstFir' --Gametimeseconds that the TML last fired a missile at something
refiLastTMLMassKills = 'M28BuildTMLMssKil'
refbPausedAsNoTargets = 'M28BuildPausNoT' --e.g. for SML use this to flag if we have paused it due to lack of targets
reftTerrainBlockedTargets = 'M28BuildTerrainBLock' --If a TML missile impacts terrain then record the original target
refbProtectedByTerrain = 'M28BuildUnitBlockByTer' --true if a target of a TML was protected by terrain
refbSalvoDelayActive = 'M28BuildSalvoDelayActive' --true if want to hold off on targets due to salvo

    --Shield related
reftoShieldsProvidingCoverage = 'M28BuildShieldsCoveringUnit' --Against unit being shielded, records the fixed shields that are covering it
reftoUnitsCoveredByShield = 'M28BuildUnitsCoveredByShield' --Against shield, returns table of units covered by shield
--refiShieldsWanted = 'M28BuildShieldsWanted' --number of fixed shield coverage wanted for the unit
refbUnitWantsShielding = 'M28BuildUnitWantsFixedShield' --true if unit wants a fixed shield
refbPriorityShield = 'M28BuildPriorityShield' --True if shield is a priority shield for assistance
refoPriorityShieldProvidingCoverage = 'M28BuildPriorityShieldCoveringUnit' --Against unit being shielded; If a shield marked as a priority shield is covering the unit, then this should return that shield
refoNearbyFactoryOfFaction = 'M28BuildNrFactionFac' --assigned against a gameender, to record that it can obtain engineers of a particular faction (for shielding purposes)
reftoUnitsWantingFactoryEngineers = 'M28BuildEngFac' --table of any units that have htis factory as their 'nearest' factory - intended for gamenders so can track which game enders assume this factory can provide engineers
reftLocationsForPriorityShield = 'M28BuildShdLoc' --against a unit (such as a game ender), [x] = 1,2,3...; returns the predetermined reserved location to build a shield in order to cover the game ender
reftoSpecialAssignedShields = 'M28BuildSpecAssShield' --against a unit (such as a game ender), [x] = 3 or 2 or 1 based on the reftLocationsForPriorityShield index; for special shielding gameender logic
refoGameEnderBeingShielded = 'M28BuildSpecShdlTarg' --against a shield, records the unit it has been assigned to (i.e. the corresponding variable for reftoSpecialAssignedShields)
reftArtiTemplateRefs = 'M28ArtiTemplateRef' --returns {iPlateau, iLandZone, iTemplateRef}, with tempalteref being the index for tLZTeamData[reftActiveGameEnderTemplates], assigned to any units that form part of it
refiTimeOfLastDischarge = 'M28ShLastDisc' --gametime that we gave a discharge order, so can check for redundancies

--T3 arti specific
reftiPlateauAndZonesInRange = 'M28BuildArtiPlatAndZInRange' --entries in order of distance, 1,2,3 etc, returns {iPlateauOrZero, iLandOrWaterZoneRef}
refbProtectingAllArtiLocations = 'M28BuildShdProtAllArti' --true if a shield is covering the midpoint of all arti locations (or arti units) - used os we avoid including in shield cycling shields like aeon shields that are too far away

function CheckIfUnitWantsFixedShield(oUnit, bCheckForNearbyShields, iOptionalShieldsWantedOverride)
    --Intended to be called whenever something happens that means oUnit may want to change whehter it is recorded as wanting a shield, except for death which is handled elsewhere now
    --oUnit construction is started (done via OnConstructionStarted)
    --A shield covering oUnit dies (done via UpdateShieldCoverageOfUnits)
    --A shield covering oUnit has construction started (done via UpdateShieldCoverageOfUnits)
    --bCheckForNearbyShields - if true, then will check for any already constructed shields; i.e. this should be true if this function is called from oUnit's construction being started

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckIfUnitWantsFixedShield'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at game time '..GetGameTimeSeconds()..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bCheckForNearbyShields='..tostring(bCheckForNearbyShields or false)..'; oUnit[refbUnitWantsShielding] before update='..tostring(oUnit[refbUnitWantsShielding] or false)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; iOptionalShieldsWantedOverride='..(iOptionalShieldsWantedOverride or 'nil')..'; owner='..oUnit:GetAIBrain().Nickname..'; Enemy novax count='..M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiEnemyNovaxCount]..'; Enemy arti count='..M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiEnemyT3ArtiCount]) end

    local iShieldsWanted = 0
    local iShieldCoverage = 0

    if oUnit[reftoShieldsProvidingCoverage] and M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]) == false then
        iShieldCoverage = table.getn(oUnit[reftoShieldsProvidingCoverage])
    end

    --Determine shields wanted
    if M28UnitInfo.IsUnitValid(oUnit) then
        if iOptionalShieldsWantedOverride then iShieldsWanted = iOptionalShieldsWantedOverride
        elseif oUnit[reftArtiTemplateRefs] then
            iShieldsWanted = 0 --we will be relying on template instead
        else
            local oBP = oUnit:GetBlueprint()
            --Dont get shields for other shields (to avoid infinite shields)
            if bDebugMessages == true then LOG(sFunctionRef..': Unit mass cost='..oBP.Economy.BuildCostMass..'; Shieldm ax health='..(oBP.Defense.Shield.ShieldMaxHealth or 0)) end
            local bT2ArtiAgainstEnemyT2ArtiOrFatboy
            if EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) then
                local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, oUnit:GetAIBrain().M28Team)
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then bT2ArtiAgainstEnemyT2ArtiOrFatboy = true
                elseif tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] >= 1500 then
                    bT2ArtiAgainstEnemyT2ArtiOrFatboy = true
                end
            end
            if (bT2ArtiAgainstEnemyT2ArtiOrFatboy or oBP.Economy.BuildCostMass >= 2000 or (EntityCategoryContains(M28UnitInfo.refCategoryT2Mex, oUnit.UnitId) and M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiEnemyNovaxCount] > 0)) and (oBP.Defense.Shield.ShieldMaxHealth or 0) == 0 then
                local iTeam = oUnit:GetAIBrain().M28Team
                if bDebugMessages == true then LOG(sFunctionRef..': Unit health='..oBP.Defense.Health..'; Defending against t3 arti for iTeam'..oUnit:GetAIBrain().M28Team..'='..tostring(M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refbDefendAgainstArti] or false)) end
                if oBP.Defense.Health / oBP.Economy.BuildCostMass < 1
                        or EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId)
                        or ((M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refbDefendAgainstArti] or M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiEnemyAirToGroundThreat] >= 12000) and oBP.Economy.BuildCostMass >= 3000 and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId))
                        or (EntityCategoryContains(M28UnitInfo.refCategoryMex - categories.TECH1, oUnit.UnitId) and M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiEnemyNovaxCount] > 0) then

                    if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] and oBP.Economy.BuildCostMass >= 12000 and (M28Team.tTeamData[iTeam][M28Team.refiEnemyT3ArtiCount] >= 1 or M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] >= 2) and M28Utilities.IsTableEmpty(oUnit[reftoSpecialAssignedShields]) then iShieldsWanted = 2
                    else iShieldsWanted = 1
                    end
                end
            end
        end
    end

    --If have just started construction of oUnit then check if there are any existing shields that can help it
    if bCheckForNearbyShields and iShieldsWanted > 0 then
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
        if iPlateau > 0 and iLandZone > 0 then
            local tNearbyShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tNearbyShields) == false then
                if not(oUnit[reftoShieldsProvidingCoverage]) then oUnit[reftoShieldsProvidingCoverage] = {} end

                for iLZShield, oLZShield in tNearbyShields do
                    local iShieldRadius = oLZShield:GetBlueprint().Defense.Shield.ShieldSize * 0.5 - 0.1 -- - 1
                    RecordIfShieldIsProtectingUnit(oLZShield, oUnit, iShieldRadius, true)
                end

                if oUnit[reftoShieldsProvidingCoverage] and M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]) == false then
                    iShieldCoverage = table.getn(oUnit[reftoShieldsProvidingCoverage])
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': iShieldsWanted='..iShieldsWanted..'; iSHieldCoverage='..iShieldCoverage) end
    if iShieldsWanted > iShieldCoverage then
        --Want more shielding
        if not(oUnit[refbUnitWantsShielding]) then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
            if iPlateau > 0 and iLandZone > 0 then
                oUnit[refbUnitWantsShielding] = true
                local tUnitLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
                if not(tUnitLZTeamData[M28Map.reftoLZUnitWantingFixedShield]) then tUnitLZTeamData[M28Map.reftoLZUnitWantingFixedShield] = {} end
                table.insert(tUnitLZTeamData[M28Map.reftoLZUnitWantingFixedShield], oUnit)
                if bDebugMessages == true then LOG(sFunctionRef..': Have added unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of units wanting shielding to iPlateau='..iPlateau..'; iLandZOne='..iLandZone) end
            end
        end
    elseif M28UnitInfo.IsUnitValid(oUnit) then
        --Dont want more shielding
        if oUnit[refbUnitWantsShielding] then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
            if iPlateau > 0 and iLandZone > 0 then
                oUnit[refbUnitWantsShielding] = false
                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield]) == false then
                    for iRecordedUnit, oRecordedUnit in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield] do
                        if oRecordedUnit == oUnit then
                            table.remove(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield], iRecordedUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Removed unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from the table of units wanting fixed shielding') end
                            break
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
        LOG(sFunctionRef..': Is table of units wanting fixed shield empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield])))
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield]) == false then
            for iUnit, oUnit in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield] do
                LOG(sFunctionRef..': Listing out each unit wanting shielding for iLandZOne '..iLandZone..'; iUnit '..iUnit..' is oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordIfShieldIsProtectingUnit(oShield, oUnit, iShieldRadius, bDontCheckIfWantsFixedShield)
    --bDontCheckIfWantsFixedShield - true if calling from the 'CheckIfUnitWantsFixedShield' function to avoid infinite loop
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordIfShieldIsProtectingUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Checking if unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; is covered by oShield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; iShieldRadius='..iShieldRadius..'; Distance='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oShield:GetPosition())) end
    if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oShield:GetPosition()) <= iShieldRadius then
        local bAddToUnit = true
        --Record against unit
        if oUnit[reftoShieldsProvidingCoverage] and M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]) == false then
            --Redundancy in case something goes wrong with tracking:
            for iRecordedShield, oRecordedShield in oUnit[reftoShieldsProvidingCoverage] do
                if oRecordedShield == oShield then
                    bAddToUnit = false
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if already recorded this shield, bAddToUnit='..tostring(bAddToUnit)) end
        if bAddToUnit then
            if not(oUnit[reftoShieldsProvidingCoverage]) then oUnit[reftoShieldsProvidingCoverage] = {} end
            table.insert(oUnit[reftoShieldsProvidingCoverage], oShield)
            if bDebugMessages == true then LOG(sFunctionRef..': Recording shield as covering the unit; bDontCheckIfWantsFixedShield='..tostring(bDontCheckIfWantsFixedShield or false)) end
            if not(bDontCheckIfWantsFixedShield) then CheckIfUnitWantsFixedShield(oUnit) end
        end
        --Record against shield
        local bAddToShield = true
        if not(oShield[reftoUnitsCoveredByShield]) then oShield[reftoUnitsCoveredByShield] = {}
        else
            for iRecorded, oRecorded in oShield[reftoUnitsCoveredByShield] do
                if oRecorded == oUnit then bAddToShield = false break end
            end
        end
        if bAddToShield then
            table.insert(oShield[reftoUnitsCoveredByShield], oUnit)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateShieldCoverageOfUnits(oShield, bTreatAsDead)
    --If shield has died, then remove any units it was protecting; if shield has just started construction then instead record any units it can provide coverage to
    --Either way, clear any existing units from the shield (as redundancy - in theory should only be needed if shield is dead

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateShieldCoverageOfUnits'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through every unit that the shield is providing coverage to, and will update to remove this unit from that table, oShield='..(oShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oShield) or 'nil')..'; Is table of units empty='..tostring(M28Utilities.IsTableEmpty(oShield[reftoUnitsCoveredByShield])))
        if M28Utilities.IsTableEmpty(oShield[reftoUnitsCoveredByShield]) == false then LOG(sFunctionRef..': Number of units covered='..table.getn(oShield[reftoUnitsCoveredByShield])) end
    end
    if M28Conditions.IsTableOfUnitsStillValid(oShield[reftoUnitsCoveredByShield]) then
        for iUnit, oUnit in oShield[reftoUnitsCoveredByShield] do
            if M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Will update unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to no longer have the shield recorded as providing coverage to it') end
                for iRecordedShield, oRecordedShield in oUnit[reftoShieldsProvidingCoverage] do
                    if oRecordedShield == oShield then
                        if bDebugMessages == true then LOG(sFunctionRef..': We had recorded shield '..oRecordedShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRecordedShield)..' as covering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so will now remove it') end
                        table.remove(oUnit[reftoShieldsProvidingCoverage], iRecordedShield)
                        break
                    end
                end
                if M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]) then oUnit[reftoShieldsProvidingCoverage] = nil end
            end
            if oUnit:GetAIBrain().M28AI then
                CheckIfUnitWantsFixedShield(oUnit)
            end
        end
        oShield[reftoUnitsCoveredByShield] = nil
    end

    if not(bTreatAsDead) then
        --Record what units this shield can protect in t he LZ it is in
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oShield:GetPosition())
        if iPlateau > 0 and iLandZone > 0 then
            local tUnitsWantingShielding = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oShield:GetAIBrain().M28Team][M28Map.reftoLZUnitWantingFixedShield]
            if M28Utilities.IsTableEmpty(tUnitsWantingShielding) == false then
                local iShieldRadius = oShield:GetBlueprint().Defense.Shield.ShieldSize * 0.5 - 0.1 -- - 1
                oShield[reftoUnitsCoveredByShield] = {}
                local bAddToUnit = false
                local tUnitsToConsider = {}
                --Copy table so we dont have to fork thread to update each unit
                for iUnit, oUnit in tUnitsWantingShielding do
                    if M28UnitInfo.IsUnitValid(oUnit) then table.insert(tUnitsToConsider, oUnit) end
                end
                for iUnit, oUnit in tUnitsToConsider do
                    RecordIfShieldIsProtectingUnit(oShield, oUnit, iShieldRadius)
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code for oShield='..(oShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oShield) or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordUnitShieldCoverage(oUnit)
    --For all units, not just M28 specific, so e.g. a TML will recognise when it's firing at a shielded target
    --Intended to be called when a unit is created
    if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) then
        local aiBrain = oUnit:GetAIBrain()
        --Is this a shield? if so then update all units around it
        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oUnit.UnitId) then
            local iShieldRadius = oUnit:GetBlueprint().Defense.Shield.ShieldSize * 0.5 - 0.1 -- - 1 --removed the -1 as of v50 since now that are using this to track enemies it can lead to false results
            local tNearbyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure, oUnit:GetPosition(), iShieldRadius, 'Ally')
            if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                for iNearbyUnit, oNearbyUnit in tNearbyUnits do
                    RecordIfShieldIsProtectingUnit(oUnit, oNearbyUnit, iShieldRadius, true)
                end
            end
        else
            local iPotentialShieldRadius = 22 --seraphim is 23 radius
            local tNearbyShields = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedShield, oUnit:GetPosition(), iPotentialShieldRadius, 'Ally')
            if M28Utilities.IsTableEmpty(tNearbyShields) == false then
                local iShieldRadius
                for iShield, oShield in tNearbyShields do
                    if oShield:GetFractionComplete() == 1 then
                        iShieldRadius = oShield:GetBlueprint().Defense.Shield.ShieldSize * 0.5 -0.1 -- - 1
                        RecordIfShieldIsProtectingUnit(oShield, oUnit, iShieldRadius, true)
                    end
                end
            end
        end
    end
end

function ForkedCheckForAnotherMissile(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ForkedCheckForAnotherMissile'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if not(oUnit[refbMissileChecker]) then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1) --make sure we have an accurate number for missiles
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        local iMissiles = 0
        if oUnit.GetTacticalSiloAmmoCount then iMissiles = iMissiles + oUnit:GetTacticalSiloAmmoCount() end
        if oUnit.GetNukeSiloAmmoCount then iMissiles = iMissiles + oUnit:GetNukeSiloAmmoCount() end
        if iMissiles >= 2 then
            oUnit[refbMissileChecker] = true
            while M28UnitInfo.IsUnitValid(oUnit) do
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitSeconds(10)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if M28UnitInfo.IsUnitValid(oUnit) then
                    local iTeam = oUnit:GetAIBrain().M28Team
                    iMissiles = 0
                    if oUnit.GetTacticalSiloAmmoCount then iMissiles = iMissiles + oUnit:GetTacticalSiloAmmoCount() end
                    if oUnit.GetNukeSiloAmmoCount then iMissiles = iMissiles + oUnit:GetNukeSiloAmmoCount() end
                    if bDebugMessages == true then LOG(sFunctionRef..': iMissiles='..iMissiles) end
                    if iMissiles < 2 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.8 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 400) then
                        oUnit:SetPaused(false)
                        oUnit:SetAutoMode(true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Will change unit state so it isnt paused') end
                        break
                    end
                else
                    break
                end

            end
        else
            if M28UnitInfo.IsUnitValid(oUnit) then oUnit:SetPaused(false) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckIfWantToBuildAnotherMissile(oUnit)
    ForkThread(ForkedCheckForAnotherMissile, oUnit)
end

function RecordUnitsInRangeOfTMLAndAnyTMDProtection(oTML, tOptionalUnitsToConsider)
    --tOptionalUnitsToConsider - if nil then will get all nearby units on an opposing team to oTML
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordUnitsInRangeOfTMLAndAnyTMDProtection'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if M28UnitInfo.IsUnitValid(oTML) then
        --If this is a mobile TML then want to update any units not in range of it now that were recorded as being in range previously
        --[[local toMobilePrevRecordedUnitsToUpdate
        if EntityCategoryContains(categories.MOBILE, oTML.UnitId) and oTML[refbTMDBuiltSinceLastChecked] and M28Conditions.IsTableOfUnitsStillValid(oTML[reftUnitsInRangeOfThisTML]) then
            toMobilePrevRecordedUnitsToUpdate = {}
            for iRecorded, oRecorded in oTML[reftUnitsInRangeOfThisTML] do
                toMobilePrevRecordedUnitsToUpdate[GetUnitRef(oRecorded)] = oRecorded
            end
        end--]]

        local iTMLRange = math.max((oTML[M28UnitInfo.refiManualRange] or 0), (oTML[M28UnitInfo.refiIndirectRange] or 0))
        if iTMLRange == 0 then iTMLRange = iTMLMissileRange end
        --Increase range if mobile
        if EntityCategoryContains(categories.MOBILE, oTML.UnitId) then
            iTMLRange = iTMLRange + 10
        end
        --Increase range for aoe
        iTMLRange = iTMLRange + (oTML[M28UnitInfo.refiIndirectAOE] or 2)
        if bDebugMessages == true then LOG(sFunctionRef..': TMl range: Manual range='..(oTML[M28UnitInfo.refiManualRange] or 0)..'; IF range='..(oTML[M28UnitInfo.refiIndirectRange] or 0)..'; AOE='..(oTML[M28UnitInfo.refiIndirectAOE] or 2)..'; Is TML mobile='..tostring(EntityCategoryContains(categories.MOBILE, oTML.UnitId))..'; TML='..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)) end


        local iTMLTeam = oTML:GetAIBrain().M28Team
        local tNearbyTMD = {}
        local tUnitsToProtect = {}
        local tiTeamsWithUnitsThatMightWantTMD = {}
        if tOptionalUnitsToConsider then
            for iUnit, oUnit in tOptionalUnitsToConsider do
                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTML:GetPosition()) <= iTMLRange then
                    table.insert(tUnitsToProtect, oUnit)
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Near start of code for oTML='..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)..' at time of '..GetGameTimeSeconds()..'; Is tOptionalUnitsToConsider nil='..tostring(tOptionalUnitsToConsider == nil)) end
        for iTMDTeam = 1, M28Team.iTotalTeamCount do
            --Get all TMD that could stop this TML, and all units it could threaten
            if not(iTMDTeam == iTMLTeam) then
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTMDTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
                    local oTMDBrain
                    for iBrain, oBrain in M28Team.tTeamData[iTMDTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                        oTMDBrain = oBrain
                        break
                    end

                    local tTeamNearbyTMD = oTMDBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD, oTML:GetPosition(), iTMLRange + 13, 'Ally')
                    if M28Utilities.IsTableEmpty(tTeamNearbyTMD) == false then
                        for iUnit, oUnit in tTeamNearbyTMD do
                            table.insert(tNearbyTMD, oUnit)
                        end
                    end
                    if not(tOptionalUnitsToConsider) then
                        --i.e. this is the first time we are considering the TML; double-check we havent already recorded the TML
                        local bNotAlreadyRecordedInTeamData = EntityCategoryContains(M28UnitInfo.refCategoryTML, oTML.UnitId)
                        if bNotAlreadyRecordedInTeamData and M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTMDTeam][M28Team.reftEnemyTML]) then
                            for iUnit, oUnit in M28Team.tTeamData[iTMDTeam][M28Team.reftEnemyTML] do
                                if oUnit == oTML then
                                    bNotAlreadyRecordedInTeamData = false
                                    break
                                end
                            end
                        end
                        if bNotAlreadyRecordedInTeamData then
                            if bDebugMessages == true then LOG(sFunctionRef..': TML not already recorded in team data so will add for team '..iTMDTeam..', oTML='..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)) end
                            table.insert(M28Team.tTeamData[iTMDTeam][M28Team.reftEnemyTML], oTML)
                        end
                        local tTeamUnitsToProtect = oTMDBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryProtectFromTML, oTML:GetPosition(), iTMLRange, 'Ally')
                        if bDebugMessages == true then LOG(sFunctionRef..': Is tTeamUnitsToProtect empty='..tostring(M28Utilities.IsTableEmpty(tTeamUnitsToProtect))..'; iTMLRange='..iTMLRange..'; TML position='..repru(oTML:GetPosition())) end
                        if M28Utilities.IsTableEmpty(tTeamUnitsToProtect) == false then
                            for iUnit, oUnit in tTeamUnitsToProtect do
                                table.insert(tUnitsToProtect, oUnit)
                            end
                        end
                    end
                end
            end
        end
        --Below not needed - had put it in when thought was reason TML wasnt firing but the civilians in campaign were already assigned teams as had updated the iscivilian flag for campaign
        --[[if not(tOptionalUnitsToConsider) and M28Map.bIsCampaignMap then
            local iTMLIndex = oTML:GetAIBrain():GetArmyIndex()
            for iBrain, oBrain in ArmyBrains do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering oBrain='..oBrain.Nickname..'; M28Team='..(oBrain.M28Team or 'nil')..'; IsEnemy='..tostring(IsEnemy(iTMLIndex, oBrain:GetArmyIndex()))) end
                if not(oBrain.M28Team) and IsEnemy(iTMLIndex, oBrain:GetArmyIndex()) then
                    local tTeamUnitsToProtect = oBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryProtectFromTML, oTML:GetPosition(), iTMLRange, 'Ally')
                    if M28Utilities.IsTableEmpty(tTeamUnitsToProtect) == false then
                        for iUnit, oUnit in tTeamUnitsToProtect do
                            local bAlreadyIncluded = false
                            if M28Utilities.IsTableEmpty(tUnitsToProtect) == false then
                                for iRecorded, oRecorded in tUnitsToProtect do
                                    if oRecorded == oUnit then bAlreadyIncluded = true break end
                                end
                            end
                            if not(bAlreadyIncluded) then
                                table.insert(tUnitsToProtect, oUnit)
                            end
                        end
                    end
                end
            end
        end--]]

        if bDebugMessages == true then LOG(sFunctionRef..': Is table of units to protect empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToProtect))..'; Is table of TMD empty='..tostring(M28Utilities.IsTableEmpty(tNearbyTMD))) end
        if M28Utilities.IsTableEmpty(tUnitsToProtect) == false then
            local iCurTeam
            for iUnit, oUnit in tUnitsToProtect do
                --if toMobilePrevRecordedUnitsToUpdate then toMobilePrevRecordedUnitsToUpdate[GetUnitRef(oUnit)] = nil end
                if not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                    --Update various tracking variables based on whether TMD are protecting this unit or not (i.e. updates TML for potential targets, TMD for units theyre covering, and units for TML that have hte unit in their range)
                    RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oTML, tNearbyTMD)
                    iCurTeam = oUnit:GetAIBrain().M28Team
                    if iCurTeam then
                        if not(tiTeamsWithUnitsThatMightWantTMD[iCurTeam]) then tiTeamsWithUnitsThatMightWantTMD[iCurTeam] = {} end
                        table.insert(tiTeamsWithUnitsThatMightWantTMD[iCurTeam], oUnit)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering if unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is protected from the TML by TMD') end
                end
            end
            if M28Utilities.IsTableEmpty(tiTeamsWithUnitsThatMightWantTMD) == false then
                for iTeam, tUnits in tiTeamsWithUnitsThatMightWantTMD do
                    RecordIfUnitsWantTMDCoverageAgainstLandZone(iTeam, tUnits)
                end
            end
        end
        --[[if M28Utilities.IsTableEmpty(toMobilePrevRecordedUnitsToUpdate) == false then
            --Dealing with a mobile TML so check for units that we havent updated per the above since they may now have TMD to cover them
            for iRecorded, oRecorded in toMobilePrevRecordedUnitsToUpdate do
                local tNearbyTMD = oRecorded:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD, oRecorded:GetPosition(), iTMLRange + 30, 'Ally')
                if M28Utilities.IsTableEmpty(tNearbyTMD) == false then
                    RecordIfUnitIsProtectedFromTMLByTMD(oRecorded, oTML, tNearbyTMD)
                end
            end
        end--]]
    end
end

function GetUnitRef(oUnit)
    return oUnit.UnitId..'L'..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'B'..oUnit:GetAIBrain():GetArmyIndex()
end

function TMDJustBuilt(oTMD)
    --Searches for any enemy TML in range of the TMD, and any friendly units in range of the TMD
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TMDJustBuilt'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local oTMDBrain = oTMD:GetAIBrain()
    local iTMDTeam = oTMDBrain.M28Team
    if not(oTMD[M28UnitInfo.refiMissileDefenceRange]) then M28UnitInfo.RecordUnitRange(oTMD) end
    local iTMDRange = (oTMD[M28UnitInfo.refiMissileDefenceRange] or 12.5)
    local tNearbyTML = {}
    local iTMDPlateauOrZero, iTMDZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oTMD:GetPosition())
    local tTMDZoneData, tTMDZoneTeamData
    if (iTMDZone or 0) > 0 then
        if iTMDPlateauOrZero == 0 then
            tTMDZoneData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iTMDZone]][M28Map.subrefPondWaterZones][iTMDZone]
            tTMDZoneTeamData = tTMDZoneData[M28Map.subrefWZTeamData][iTMDTeam]
        else
            tTMDZoneData = M28Map.tAllPlateaus[iTMDPlateauOrZero][M28Map.subrefPlateauLandZones][iTMDZone]
            tTMDZoneTeamData = tTMDZoneData[M28Map.subrefLZTeamData][iTMDTeam]
        end
    end
    local bCheckForUnitsInZone = M28Utilities.IsTableEmpty(tTMDZoneTeamData[M28Map.reftUnitsWantingTMD]) == false
    local tbUnitRefsConsideredByTML
    local tbUnitRefsConsideredAllTML = {}
    local sCurUnitRef

    for iTMLTeam = 1, M28Team.iTotalTeamCount do
        --Get all TML in range of this TMD
        if not(iTMDTeam == iTMLTeam) then
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
                local oTMLBrain
                for iBrain, oBrain in M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                    oTMLBrain = oBrain
                    break
                end
                local tTeamNearbyTML = oTMLBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTML, oTMD:GetPosition(), iTMLMissileRange + iTMDRange - 3, 'Ally')
                if bDebugMessages == true then LOG(sFunctionRef..': Dealing with oTMD='..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..'; is table of nearby TML empty='..tostring(M28Utilities.IsTableEmpty(tTeamNearbyTML))..'; iTMLTeam='..iTMLTeam) end
                if M28Utilities.IsTableEmpty(tTeamNearbyTML) == false then
                    for iTML, oTML in tTeamNearbyTML do
                        tbUnitRefsConsideredByTML = {}
                        local tFriendlyUnitsInRangeOfTML = oTMDBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryProtectFromTML, oTML:GetPosition(), iTMLMissileRange + 2, 'Ally')
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of TMD friendly units in range of TML empty='..tostring(M28Utilities.IsTableEmpty(tFriendlyUnitsInRangeOfTML))) end
                        if M28Utilities.IsTableEmpty(tFriendlyUnitsInRangeOfTML) == false then
                            for iUnit, oUnit in tFriendlyUnitsInRangeOfTML do
                                sCurUnitRef = GetUnitRef(oUnit)

                                tbUnitRefsConsideredByTML[sCurUnitRef] = true
                                tbUnitRefsConsideredAllTML[sCurUnitRef] = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Will check if unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is in range of TML '..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)) end
                                RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oTML, { oTMD }) --This will do a distance check from the unit to the TMD
                            end
                        end
                        --Also check for any units wanting TMD coverage in the TMD zone (redundancy in case there are issues with getunitsaroundpoint not picking up upgrading units)
                        if bCheckForUnitsInZone and M28Utilities.IsTableEmpty(tTMDZoneTeamData[M28Map.reftUnitsWantingTMD]) == false then
                            for iUnit, oUnit in tTMDZoneTeamData[M28Map.reftUnitsWantingTMD] do
                                if M28UnitInfo.IsUnitValid(oUnit) then
                                    sCurUnitRef = GetUnitRef(oUnit)
                                    if not(tbUnitRefsConsideredByTML[sCurUnitRef]) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have unit in zone wanting TMD coverage that we havent considered with getunitsaroundpoint, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Unit fraction complete='..oUnit:GetFractionComplete()) end
                                        RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oTML, { oTMD })
                                        tbUnitRefsConsideredAllTML[sCurUnitRef] = true
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    if M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTMDTeam][M28Team.reftEnemyMobileTML]) then
        for iMobileTML, oMobileTML in M28Team.tTeamData[iTMDTeam][M28Team.reftEnemyMobileTML] do
            if M28Conditions.IsTableOfUnitsStillValid(oMobileTML[reftUnitsInRangeOfThisTML]) then
                for iRecorded, oRecorded in oMobileTML[reftUnitsInRangeOfThisTML] do
                    sCurUnitRef = GetUnitRef(oRecorded)
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oMobileTML '..oMobileTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMobileTML)..'; oRecorded='..oRecorded.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRecorded)..'; is tbUnitRefsConsideredAllTML nil for this unit='..tostring(tbUnitRefsConsideredAllTML[sCurUnitRef] == nil)) end
                    if not(tbUnitRefsConsideredAllTML[sCurUnitRef]) then
                        RecordIfUnitIsProtectedFromTMLByTMD(oRecorded, oMobileTML, { oTMD })
                        tbUnitRefsConsideredAllTML[sCurUnitRef] = true
                    end
                end
            end
            oMobileTML[refbTMDBuiltSinceLastChecked] = true
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordTMLAndTMDForUnitJustBuilt(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordTMLAndTMDForUnitJustBuilt'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local oTMDBrain = oUnit:GetAIBrain()
    local iTMDTeam = oTMDBrain.M28Team
    local tNearbyTMD = oTMDBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD, oUnit:GetPosition(), iTMLMissileRange + 2, 'Ally')

    for iTMLTeam = 1, M28Team.iTotalTeamCount do
        --Get all TML in range of this TMD
        if not(iTMDTeam == iTMLTeam) then
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
                local oTMLBrain
                for iBrain, oBrain in M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                    oTMLBrain = oBrain
                    break
                end
                local tTeamNearbyTML = oTMLBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTML, oUnit:GetPosition(), iTMLMissileRange + 2, 'Ally')
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of TML in TML missile range of this unit empty='..tostring(M28Utilities.IsTableEmpty(tTeamNearbyTML))..'; iTMLMissileRange='..iTMLMissileRange..'; Unit position='..repru(oUnit:GetPosition())..'; oTMLBrain='..oTMLBrain.Nickname) end
                if M28Utilities.IsTableEmpty(tTeamNearbyTML) == false then
                    for iTML, oTML in tTeamNearbyTML do
                        RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oTML, tNearbyTMD) --This will do a distance check from the unit to the TMD
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordTMLAndTMDForEnemyUnitTargetJustDetected(oUnit, iTMLTeam)
    --Intended if an M28 TML owner detects an enemy target
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordTMLAndTMDForEnemyUnitTargetJustDetected'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local oTMDBrain = oUnit:GetAIBrain()
    local iTMDTeam = oTMDBrain.M28Team
    local tNearbyTMD = oTMDBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD, oUnit:GetPosition(), iTMLMissileRange + 2, 'Ally')



    if bDebugMessages == true then LOG(sFunctionRef..': Detected unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTMLTeam='..iTMLTeam..'; Is table of active brains empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains]))..'; TimeOfGame='..GetGameTimeSeconds()) end

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
        local oTMLBrain
        for iBrain, oBrain in M28Team.tTeamData[iTMLTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
            oTMLBrain = oBrain
            break
        end
        local tTeamNearbyTML = oTMLBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTML, oUnit:GetPosition(), iTMLMissileRange + 2, 'Ally')
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of TML in missile range of this unit empty='..tostring(M28Utilities.IsTableEmpty(tTeamNearbyTML))..'; iTMLMissileRange='..iTMLMissileRange..'; Unit position='..repru(oUnit:GetPosition())..'; oTMLBrain.Nickname='..oTMLBrain.Nickname) end
        if M28Utilities.IsTableEmpty(tTeamNearbyTML) == false then --NOTE: If TML is firing from a cliff (big height dif) then it might not detect a unit that appears within its range, assuming due to targeting of units not being straightline ignoring height, but also factoring in height difs, with getunitsaroundpoint appearing to factor this in as well
            for iTML, oTML in tTeamNearbyTML do
                if bDebugMessages == true then LOG(sFunctionRef..': Are in range of oTML='..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)..'; will record if is protected by TMD') end
                RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oTML, tNearbyTMD) --This will do a distance check from the unit to the TMD
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function IsTMDProtectingUnitFromTML(oTMD, oUnit, oTML, iOptionalBuildingSize)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsTMDProtectingUnitFromTML'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iBuildingSize = iOptionalBuildingSize
    if not(iBuildingSize) then iBuildingSize = M28UnitInfo.GetBuildingSize(oUnit.UnitId) end
    local iUnitToTMD = M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), oUnit:GetPosition())
    if not(oTMD[M28UnitInfo.refiMissileDefenceRange]) then M28UnitInfo.RecordUnitRange(oTMD) end
    local iTMDRange = (oTMD[M28UnitInfo.refiMissileDefenceRange] or 12.5)

    --Reduce TMDRange to the effective range
    iTMDRange = iTMDRange - iBuildingSize


    local iUnitToTML = M28Utilities.GetDistanceBetweenPositions(oTML:GetPosition(), oUnit:GetPosition())
    local iTMDToTML = M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), oTML:GetPosition())

    local iAngleTMLToUnit = M28Utilities.GetAngleFromAToB(oTML:GetPosition(), oUnit:GetPosition())
    local iAngleTMLToTMD = M28Utilities.GetAngleFromAToB(oTML:GetPosition(), oTMD:GetPosition())
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if TMD '..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' is able to block the TML '..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)..' for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iUnitToTMD='..iUnitToTMD..'; iTMDRange reduced by building size='..iTMDRange..'; TMD recorded range='..(oUnit[M28UnitInfo.refiMissileDefenceRange] or 'nil')..'; iUnitToTML='..iUnitToTML..'; iTMDToTML='..iTMDToTML..'; iAngleTMLToUnit='..iAngleTMLToUnit..'; iAngleTMLToTMD='..iAngleTMLToTMD..'; Is line result='..tostring(M28Utilities.IsLineFromAToBInRangeOfCircleAtC(iUnitToTML, iTMDToTML, iUnitToTMD, iAngleTMLToUnit, iAngleTMLToTMD, iTMDRange))) end
    if M28Utilities.IsLineFromAToBInRangeOfCircleAtC(iUnitToTML, iTMDToTML, iUnitToTMD, iAngleTMLToUnit, iAngleTMLToTMD, iTMDRange) then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false

end

function RecordIfUnitIsProtectedFromTMLByTMD(oUnit, oTML, tTMDInRange)
    --Updates the following variables: For TMD: reftUnitsCoveredByThisTMD; for TML: reftUnprotectedUnitTargetsForThisTML and reftUnitsInRangeOfThisTML; for units in range of TML: reftTMDCoveringThisUnit and reftTMLInRangeOfThisUnit
    --Assumes that oTML is in range of oUnit

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordIfUnitIsProtectedFromTMLByTMD'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bTMLAlreadyRecordedAgainstUnit = false
    local bUpdateZoneForUnitsWantingTMD = false
    if M28Utilities.IsTableEmpty(oUnit[reftTMLInRangeOfThisUnit]) == false then
        for iExistingTML, oExistingTML in oUnit[reftTMLInRangeOfThisUnit] do
            if oExistingTML == oTML then
                bTMLAlreadyRecordedAgainstUnit = true
                break
            end
        end
    end
    if not(bTMLAlreadyRecordedAgainstUnit) then
        if not(oUnit[reftTMLInRangeOfThisUnit]) then oUnit[reftTMLInRangeOfThisUnit] = {} end
        table.insert(oUnit[reftTMLInRangeOfThisUnit], oTML)
    end
    local bIsBlockedByTMD
    if bDebugMessages == true then LOG(sFunctionRef..': Near start at time '..GetGameTimeSeconds()..'; Considering if oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; is proitected from oTML '..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)..' by any of the TMD noted, is table of TMD empty='..tostring(M28Utilities.IsTableEmpty(tTMDInRange))) end
    local iBuildingSize = M28UnitInfo.GetBuildingSize(oUnit.UnitId)
    if M28Utilities.IsTableEmpty(tTMDInRange) == false then
        --[[local iUnitToTMD
        local iTMDRange
        local iUnitToTML, iTMDToTML, iAngleTMLToUnit, iAngleTMLToTMD--]]
        local bAlreadyRecordedTMD



        for iTMD, oTMD in tTMDInRange do
            if IsTMDProtectingUnitFromTML(oTMD, oUnit, oTML, iBuildingSize) then

                --TMD can block the TML
                bAlreadyRecordedTMD = false
                bIsBlockedByTMD = true
                if bDebugMessages == true then LOG(sFunctionRef..': oTMD='..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' can block the TML so will record it') end
                if not(oUnit[reftTMDCoveringThisUnit]) then oUnit[reftTMDCoveringThisUnit] = {}
                else
                    for iRecordedTMD, oRecordedTMD in oUnit[reftTMDCoveringThisUnit] do
                        if oRecordedTMD == oTMD then bAlreadyRecordedTMD = true  break end
                    end
                end
                if not(bAlreadyRecordedTMD) then
                    table.insert(oUnit[reftTMDCoveringThisUnit], oTMD)
                    if not(oTMD[reftUnitsCoveredByThisTMD]) then oTMD[reftUnitsCoveredByThisTMD] = {} end
                    table.insert(oTMD[reftUnitsCoveredByThisTMD], oUnit)
                    if bDebugMessages == true then LOG(sFunctionRef..': TMD '..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' recorded against oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' as covering it from TML') end
                end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': TMD '..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' doesnt block the TML') end
            end
        end
    end
    if not(bIsBlockedByTMD) then
        --None of the TMD are blocking the TML from hitting this unit; check if there are any other valid TMD that are covering this unit
        if M28Utilities.IsTableEmpty(oUnit[reftTMDCoveringThisUnit]) == false then
            for iTMD, oTMD in oUnit[reftTMDCoveringThisUnit] do
                if M28UnitInfo.IsUnitValid(oTMD) then
                    --Have we considered this TMD alreayd?
                    local bConsideredAbove = false
                    for iExistingTMD, oExistingTMD in tTMDInRange do
                        if oExistingTMD == oTMD then
                            bConsideredAbove = true
                            break
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': This unit has TMD recorded as covering it, oTMD='..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..'; bConsideredAbove='..tostring(bConsideredAbove)..'; Does the TMD cover the unit from this TML='..tostring(IsTMDProtectingUnitFromTML(oTMD, oUnit, oTML, iBuildingSize))) end
                    if not(bConsideredAbove) then
                        if IsTMDProtectingUnitFromTML(oTMD, oUnit, oTML, iBuildingSize) then
                            bIsBlockedByTMD = true
                            break
                        end
                    end
                end
            end
        end
    end
    if not(bIsBlockedByTMD) then
        local bAlreadyIncluded = false
        if not(oTML[reftUnprotectedUnitTargetsForThisTML]) or M28Utilities.IsTableEmpty(oTML[reftUnprotectedUnitTargetsForThisTML]) then
            oTML[reftUnprotectedUnitTargetsForThisTML] = {}

        else
            for iRecordedUnit, oRecordedUnit in oTML[reftUnprotectedUnitTargetsForThisTML] do
                if oRecordedUnit == oUnit then
                    bAlreadyIncluded = true
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Will record this unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' against table of unprotected units for TML as it isnt blocked by any of the TMD, bAlreadyIncluded='..tostring(bAlreadyIncluded or false)) end
        if not(bAlreadyIncluded) then
            table.insert(oTML[reftUnprotectedUnitTargetsForThisTML], oUnit)
            if oUnit:GetAIBrain().M28AI then
                RecordIfUnitsWantTMDCoverageAgainstLandZone(oUnit:GetAIBrain().M28Team, { oUnit })
            end
        end
    else
        --is covered by TMD, make sure not listed in reftUnprotectedUnitTargetsForThisTML, and reassess if we want the unit flagged as wanting TMD
        if bDebugMessages == true then LOG(sFunctionRef..': Unit is covered by TMD so will make sure not listed as an unprotected target against the TML, is table of unrptoected targets empty='..tostring(M28Utilities.IsTableEmpty(oTML[reftUnprotectedUnitTargetsForThisTML]))) end
        bUpdateZoneForUnitsWantingTMD = true
        if M28Utilities.IsTableEmpty(oTML[reftUnprotectedUnitTargetsForThisTML]) == false then
            for iExistingUnit, oExistingUnit in oTML[reftUnprotectedUnitTargetsForThisTML] do
                if oExistingUnit == oUnit then
                    if bDebugMessages == true then LOG(sFunctionRef..': This unit was previously recorded as an unprotected target, will remove') end
                    table.remove(oTML[reftUnprotectedUnitTargetsForThisTML], iExistingUnit)
                    break
                end
            end
        end
    end
    --Either way record unit as being in range of TML
    local bAlreadyIncluded = false
    if not(oTML[reftUnitsInRangeOfThisTML]) or M28Utilities.IsTableEmpty(oTML[reftUnitsInRangeOfThisTML]) then
        oTML[reftUnitsInRangeOfThisTML] = {}

    else
        for iRecordedUnit, oRecordedUnit in oTML[reftUnitsInRangeOfThisTML] do
            if oRecordedUnit == oUnit then
                bAlreadyIncluded = true
                break
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Will record this unit against the TML as being in range, unless already included, bAlreadyIncluded='..tostring(bAlreadyIncluded)) end
    if not(bAlreadyIncluded) then
        table.insert(oTML[reftUnitsInRangeOfThisTML], oUnit)
    end
    if bUpdateZoneForUnitsWantingTMD and oUnit:GetAIBrain().M28AI then
        RecordIfUnitsWantTMDCoverageAgainstLandZone(oUnit:GetAIBrain().M28Team, { oUnit })
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AlliedTMDFirstRecorded(iTeam, oTMD)
    --Have just recorded an allied TMD for a land zone - want to record all units within a long range that want protecting from TML if this provides protection from an enemy TML
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AlliedTMDFirstRecorded'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': oTMD '..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' has been identified, will reecord if are any enemy TML, is table of enemy TML empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyTML]))) end

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyTML]) == false then
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            if aiBrain then
                local tUnitsToProtect = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryProtectFromTML, oTMD:GetPosition(), iTMLMissileRange + 20, 'Ally')
                if M28Utilities.IsTableEmpty(tUnitsToProtect) == false then
                    local tOnLandUnits = {}
                    for iUnit, oUnit in tUnitsToProtect do
                        if not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                            table.insert(tOnLandUnits, oUnit)
                        end
                    end
                    if M28Utilities.IsTableEmpty(tOnLandUnits) == false then
                        UpdateTMDCoverageOfUnits(iTeam,{ oTMD }, tOnLandUnits)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TMLDied(oTML)
    --Updates tracking of the TML including for any units that had it recorded as being in range of them, and then checks if those units want TMD coverage (as there may no longer be any TML to protect from)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TMLDied'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': TML has just died, is the table of units in range of it empty='..tostring(M28Utilities.IsTableEmpty(oTML[reftUnitsInRangeOfThisTML]))) end
    local iTMLTeam = oTML:GetAIBrain().M28Team
    --Update each team that was tracking this
    for iTeam = 1, M28Team.iTotalTeamCount do
        if not(iTMLTeam == iTeam) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyTML]) == false then
            for iRecordedTML, oRecordedTML in M28Team.tTeamData[iTeam][M28Team.reftEnemyTML] do
                if oRecordedTML == oTML then
                    table.remove(M28Team.tTeamData[iTeam][M28Team.reftEnemyTML], iRecordedTML)
                end
            end
        end
    end
    --Update each unit that was tracking this:
    if M28Utilities.IsTableEmpty(oTML[reftUnitsInRangeOfThisTML]) == false then
        local tUnitsToUpdateByTeam = {}
        local iCurTeam
        for iUnit, oUnit in oTML[reftUnitsInRangeOfThisTML] do
            if M28UnitInfo.IsUnitValid(oUnit) then
                for iExistingTML, oExistingTML in oUnit[reftTMLInRangeOfThisUnit] do
                    if oExistingTML == oTML then
                        iCurTeam = oUnit:GetAIBrain().M28Team
                        if not(tUnitsToUpdateByTeam[iCurTeam]) then tUnitsToUpdateByTeam[iCurTeam] = {} end
                        table.insert(tUnitsToUpdateByTeam[iCurTeam], oUnit)
                        table.remove(oUnit[reftTMLInRangeOfThisUnit], iExistingTML)
                        break
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tUnitsToUpdateByTeam) == false then
            for iTeam, tUnitList in tUnitsToUpdateByTeam do
                RecordIfUnitsWantTMDCoverageAgainstLandZone(iTeam, tUnitList)
            end
        end
    end
end
function TMDDied(oTMD)
    --Updates any units that were relying on oTMD for protection from TML, and reassesses if those units want more TMD now
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TMDDied'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': TMD has just died, is the table of units covered by this TMD empty='..tostring(M28Utilities.IsTableEmpty(oTMD[reftUnitsCoveredByThisTMD]))) end
    if M28Utilities.IsTableEmpty(oTMD[reftUnitsCoveredByThisTMD]) == false then
        local tUnitsToCheckIfWantTMDCoverageByTeam = {}
        local iCurTeam
        for iUnit, oUnit in oTMD[reftUnitsCoveredByThisTMD] do
            if M28UnitInfo.IsUnitValid(oUnit) then
                for iRecordedTMD, oRecordedTMD in oUnit[reftTMDCoveringThisUnit] do
                    if oRecordedTMD == oTMD then
                        iCurTeam = oUnit:GetAIBrain().M28Team
                        if not(tUnitsToCheckIfWantTMDCoverageByTeam[iCurTeam]) then tUnitsToCheckIfWantTMDCoverageByTeam[iCurTeam] = {} end
                        table.insert(tUnitsToCheckIfWantTMDCoverageByTeam[iCurTeam], oUnit)
                        table.remove(oUnit[reftTMDCoveringThisUnit], iRecordedTMD)
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tUnitsToCheckIfWantTMDCoverageByTeam) == false then
            for iTeam, tUnitList in tUnitsToCheckIfWantTMDCoverageByTeam do
                RecordIfUnitsWantTMDCoverageAgainstLandZone(iTeam, tUnitList)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateTMDCoverageOfUnits(iTeam, tTMD, tUnitsToUpdate)
    --Goes through each unit in tUnitsToUpdate, and records any TMD in tTMD that can protect it from all TML in range of the unit
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateTMDCoverageOfUnits'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tAllEnemyTML = M28Team.tTeamData[iTeam][M28Team.reftEnemyTML]
    if M28Utilities.IsTableEmpty(tAllEnemyTML) == false then --redundancy
        local bTMDCoversFromAllTML
        local bCanBlockCurTML
        local bAlreadyRecordedTMD = false
        local bAlreadyRecordedAsWantingTMD
        local iUnitToTMD, iUnitToTML, iTMDToTML, iTMDRange, iBuildingSize, iAngleTMLToTMD, iAngleTMLToUnit
        local iUnitPlateau, iUnitLandZone
        for iUnit, oUnit in tUnitsToUpdate do
            if M28Utilities.IsTableEmpty(oUnit[reftTMLInRangeOfThisUnit]) == false then
                iBuildingSize = M28UnitInfo.GetBuildingSize(oUnit.UnitId)
                for iTMD, oTMD in tTMD do
                    bTMDCoversFromAllTML = true
                    iUnitToTMD = M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), oUnit:GetPosition())
                    if not(oTMD[M28UnitInfo.refiMissileDefenceRange]) then M28UnitInfo.RecordUnitRange(oTMD) end
                    iTMDRange = (oTMD[M28UnitInfo.refiMissileDefenceRange] or 12.5)

                    --Reduce TMDRange to the effective range
                    iTMDRange = iTMDRange - iBuildingSize

                    for iTML, oTML in oUnit[reftTMLInRangeOfThisUnit] do
                        bCanBlockCurTML = false
                        iUnitToTML = M28Utilities.GetDistanceBetweenPositions(oTML:GetPosition(), oUnit:GetPosition())
                        iTMDToTML = M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), oTML:GetPosition())

                        iAngleTMLToUnit = M28Utilities.GetAngleFromAToB(oTML:GetPosition(), oUnit:GetPosition())
                        iAngleTMLToTMD = M28Utilities.GetAngleFromAToB(oTML:GetPosition(), oTMD:GetPosition())
                        if M28Utilities.IsLineFromAToBInRangeOfCircleAtC(iUnitToTML, iTMDToTML, iUnitToTMD, iAngleTMLToUnit, iAngleTMLToTMD, iTMDRange) then
                            --TMD can block the TML
                            if bDebugMessages == true then LOG(sFunctionRef..': oTMD='..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..' can block the TML so will record it') end
                            bCanBlockCurTML = true
                        end
                        if not(bCanBlockCurTML) then
                            bTMDCoversFromAllTML = false
                            break
                        end
                    end
                    if bTMDCoversFromAllTML then
                        if not(oUnit[reftTMDCoveringThisUnit]) then oUnit[reftTMDCoveringThisUnit] = {}
                        else
                            for iRecordedTMD, oRecordedTMD in oUnit[reftTMDCoveringThisUnit] do
                                if oRecordedTMD == oTMD then bAlreadyRecordedTMD = true  break end
                            end
                        end
                        if not(bAlreadyRecordedTMD) then
                            table.insert(oUnit[reftTMDCoveringThisUnit], oTMD)
                        end
                    end
                end
            end
        end
        RecordIfUnitsWantTMDCoverageAgainstLandZone(iTeam, tUnitsToUpdate)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordIfUnitsWantTMDCoverageAgainstLandZone(iTeam, tUnits)
    --Cycles through each unit in tUnits and if it has less TMD covering it than TML in range, makes sure it is reecorded in its land zone as one of the units wanting TMD
    --If it has sufficient TMD coverage, then instead makes sure it isnt recorded in its land zone as one of the units wanting TMD
    --Relies on otherfunctions for accurately recording TML in range of it and TMD giving coverage

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordIfUnitsWantTMDCoverageAgainstLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTMDInRange, iUnitPlateau, iUnitLandZone
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; size of tUnits='..table.getn(tUnits)..'; iTeam='..iTeam) end
    for iUnit, oUnit in tUnits do
        --Does the unit need TMD coverage?
        iTMDInRange = 0
        if M28Utilities.IsTableEmpty(oUnit[reftTMDCoveringThisUnit]) == false then
            --Treat Aeon as having twice the TMD power as other factions
            for iRecordedTMD, oRecordedTMD in oUnit[reftTMDCoveringThisUnit] do
                if M28UnitInfo.IsUnitValid(oRecordedTMD) then
                    if EntityCategoryContains(categories.AEON, oRecordedTMD.UnitId) then
                        iTMDInRange = iTMDInRange + 2
                    else
                        iTMDInRange = iTMDInRange + 1
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Considierng unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTMDInRange='..iTMDInRange..'; TML in range='..table.getn((oUnit[reftTMLInRangeOfThisUnit] or {}))..'; oUnit[refbUnitWantsMoreTMD]='..tostring(oUnit[refbUnitWantsMoreTMD] or false)) end
        local iTMLValueInRangeOfUnit = 0
        if M28Utilities.IsTableEmpty(oUnit[reftTMLInRangeOfThisUnit]) == false then
            for iRecordedTML, oRecordedTML in oUnit[reftTMLInRangeOfThisUnit] do
                if M28UnitInfo.IsUnitValid(oRecordedTML) then
                    --UEF ACU with billy nuke upgrade - increase value
                    if EntityCategoryContains(categories.COMMAND * categories.UEF, oRecordedTML.UnitId) and oRecordedTML.HasEnhancement and oRecordedTML:HasEnhancement('TacticalNukeMissile') then
                        if bDebugMessages == true then LOG(sFunctionRef..': ENemy unit owned by brain '..oRecordedTML:GetAIBrain().Nickname..' has a billy nuke') end
                        iTMLValueInRangeOfUnit = iTMLValueInRangeOfUnit + 4
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMissileShip * categories.AEON, oRecordedTML.UnitId) then
                        --Aeon missile ship
                        iTMLValueInRangeOfUnit = iTMLValueInRangeOfUnit + 3
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMML * categories.TECH2, oRecordedTML.UnitId) then
                        iTMLValueInRangeOfUnit = iTMLValueInRangeOfUnit + 0.75
                    else
                        iTMLValueInRangeOfUnit = iTMLValueInRangeOfUnit + 1
                    end
                end
            end
        end

        if iTMDInRange < iTMLValueInRangeOfUnit and not(oUnit[refbNoNearbyTMDBuildLocations]) then
            if not(oUnit[refbUnitWantsMoreTMD]) then --redundancy (i.e. will ahve already called below if unit is already flagged as wanting more TMD)
                iUnitPlateau, iUnitLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                if bDebugMessages == true then LOG(sFunctionRef..': Want TMD for this unit, iUnitPlateau='..(iUnitPlateau or 'nil')..'; iUnitLandZone='..(iUnitLandZone or 'nil')) end
                if iUnitLandZone > 0 then
                    local tLZTeamData = M28Map.tAllPlateaus[iUnitPlateau][M28Map.subrefPlateauLandZones][iUnitLandZone][M28Map.subrefLZTeamData][iTeam]
                    table.insert(tLZTeamData[M28Map.reftUnitsWantingTMD], oUnit)
                end
                oUnit[refbUnitWantsMoreTMD] = true
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Have enough TMD covering this unit, unit wants more TMD flag='..tostring(oUnit[refbUnitWantsMoreTMD] or false)) end
            if oUnit[refbUnitWantsMoreTMD] then --i.e. unit previously was flagged as needing more TMD (but now it doesnt)
                --Remove this unit from the land zone list of units wanting TMD
                iUnitPlateau, iUnitLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                if iUnitLandZone > 0 then
                    local tLZTeamData = M28Map.tAllPlateaus[iUnitPlateau][M28Map.subrefPlateauLandZones][iUnitLandZone][M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont want TMD for this unit, iUnitPlateau='..(iUnitPlateau or 'nil')..'; iUnitLandZone='..(iUnitLandZone or 'nil')..'; is table of LZ units wanting TMD empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]))) end
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]) == false then
                        --Remove htis unit from the list of units wanting TMD
                        for iRecordedUnit, oRecordedUnit in tLZTeamData[M28Map.reftUnitsWantingTMD] do
                            if bDebugMessages == true then LOG(sFunctionRef..': oRecordedUnit='..oRecordedUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRecordedUnit)) end
                            if oRecordedUnit == oUnit then
                                table.remove(tLZTeamData[M28Map.reftUnitsWantingTMD], iRecordedUnit)
                                if bDebugMessages == true then LOG(sFunctionRef..': Have removed from units wanting TMD in zone, is table of units wanting TMD empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]))) end
                                break
                            end
                        end
                    end
                end
                oUnit[refbUnitWantsMoreTMD] = false
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateLZUnitsWantingTMDForUnitDeath(oUnit)
    --Updates any units currently recorded as wanting TMD to see if htey still want TMD based on TMD coverage
    local iUnitPlateau, iUnitLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
    if iUnitLandZone > 0 then
        local iTeam = oUnit:GetAIBrain().M28AITeam
        local tLZTeamData = M28Map.tAllPlateaus[iUnitPlateau][M28Map.subrefPlateauLandZones][iUnitLandZone][M28Map.subrefLZTeamData][iTeam]
        --Remove all dead units from the table (not just this one) as extra redundancy
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]) == false then
            local iRevisedIndex = 1
            local iTableSize = table.getn(tLZTeamData[M28Map.reftUnitsWantingTMD])

            for iOrigIndex=1, iTableSize do
                if tLZTeamData[M28Map.reftUnitsWantingTMD][iOrigIndex] then
                    if M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.reftUnitsWantingTMD][iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                        --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                        if (iOrigIndex ~= iRevisedIndex) then
                            tLZTeamData[M28Map.reftUnitsWantingTMD][iRevisedIndex] = tLZTeamData[M28Map.reftUnitsWantingTMD][iOrigIndex]
                            tLZTeamData[M28Map.reftUnitsWantingTMD][iOrigIndex] = nil
                        end
                        iRevisedIndex = iRevisedIndex + 1 --i.e. this will be the position of where the next value that we keep will be located
                    else
                        tLZTeamData[M28Map.reftUnitsWantingTMD][iOrigIndex] = nil
                    end
                end
            end
        end
    end
    oUnit[refbUnitWantsMoreTMD] = false --redundancy
end

function GetUnitWantingTMD(tLZData, tLZTeamData, iTeam, iOptionalLandZone)
    --Gets the unit closest to the nearest enemy base that wants TMD; also refreshes the table for any dead units
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnitWantingTMD'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --Cap on number of TMD to prvent massiveo verbuilding - dont have more than 10 in a LZ
    local tExistingTMD = EntityCategoryFilterDown(M28UnitInfo.refCategoryTMD, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of existing TMD empty='..tostring(M28Utilities.IsTableEmpty(tExistingTMD))) end
    if M28Utilities.IsTableEmpty(tExistingTMD) == false then
        local iExistingValidTMD = table.getn(tExistingTMD)

        --Max TMD limit - no. of mexes in the zone * 0.5 if lower; also higher TMD if we have Aeon TMD
        local iTMDLimit = math.min(30, math.max(10, (tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3]) * 0.5, tLZTeamData[M28Map.subrefLZSValue] / 5000))
        if not(tLZTeamData[M28Map.subrefLZbCoreBase]) then iTMDLimit = math.min(iTMDLimit, math.max(4, tLZTeamData[M28Map.subrefMexCountByTech][3] * 2 + tLZTeamData[M28Map.subrefMexCountByTech][2], tLZTeamData[M28Map.subrefLZSValue] / 5000)) end
        if bDebugMessages == true then LOG(sFunctionRef..': iExistingValidTMD='..iExistingValidTMD..'; iTMDLimit='..iTMDLimit) end
        if iExistingValidTMD >= iTMDLimit then
            local iEnemyTotalTMLCount = 0
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyTML]) == false then
                iEnemyTotalTMLCount = table.getn(M28Team.tTeamData[iTeam][M28Team.reftEnemyTML])
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iEnemyTotalTMLCount='..iEnemyTotalTMLCount) end
            if iExistingValidTMD > math.min(31, iTMDLimit + (iEnemyTotalTMLCount - 1) * 2) then
                --Too much TMD already, clear any units wanting TMD; send error message if we have loads of TMD
                if iExistingValidTMD >= 10 then
                    M28Utilities.ErrorHandler('Have at least TMD in land zone so wont build any more TMD, risk we may be overbuilding TMD, will clear entries', true)
                end
                tLZTeamData[M28Map.reftUnitsWantingTMD] = {}
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return nil
            end
        end
    end

    local iUnitsWantingTMD = table.getn(tLZTeamData[M28Map.reftUnitsWantingTMD])
    local iClosestDist = 10000
    local iCurDist
    local oClosestUnit
    local tEnemyBase = tLZTeamData[M28Map.reftClosestEnemyBase]
    for iEntry = iUnitsWantingTMD, 1, -1 do
        if not(M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry])) then
            table.remove(tLZTeamData[M28Map.reftUnitsWantingTMD], iEntry)
        else
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tEnemyBase, tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry]:GetPosition())
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if unit '..tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry].UnitId..M28UnitInfo.GetUnitLifetimeCount(tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry])..' is the closest, iCurDist='..iCurDist..'; iCLosestDist='..iClosestDist..'; refbUnitWantsMoreTMD='..tostring(tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry][refbUnitWantsMoreTMD])) end
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestUnit = tLZTeamData[M28Map.reftUnitsWantingTMD][iEntry]
            end
        end
    end

    if bDebugMessages == true then
        LOG(sFunctionRef..': End of code, oClosestUnit='..(oClosestUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestUnit) or 'nil')..'; Is table of TML in range of this unit empty='..tostring(M28Utilities.IsTableEmpty(oClosestUnit[reftTMLInRangeOfThisUnit]))..'; Is reftTMDCoveringThisUnit empty='..tostring(M28Utilities.IsTableEmpty(oClosestUnit[reftTMDCoveringThisUnit])))
        if oClosestUnit then
            for iTML, oTML in oClosestUnit[reftTMLInRangeOfThisUnit] do
                LOG(sFunctionRef..': oTML in range='..oTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTML)..'; Dist='..M28Utilities.GetDistanceBetweenPositions(oTML:GetPosition(), oClosestUnit:GetPosition())..'; TML range='..(oTML[M28UnitInfo.refiIndirectRange] or oTML[M28UnitInfo.refiManualRange] or 'nil'))
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oClosestUnit
end


function RecordPriorityShields(iTeam, tLZTeamData)
    --Records shields that want to ahve engineers assisting
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordPriorityShields'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if GetGameTimeSeconds() - (tLZTeamData[M28Map.refiTimeOfLastShieldPriorityRefresh] or -100) >= 10 then
        tLZTeamData[M28Map.refiTimeOfLastShieldPriorityRefresh] = GetGameTimeSeconds()
        local tShieldsToAssist = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        --First clear any engineers assigned to shields that arent listed as a priority shield from the last update
        if bDebugMessages == true then LOG(sFunctionRef..': WIll refresh list of shields. Is table empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssist))..'; do we already have any priority shields when when last ran this? is table empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]))) end
        if M28Utilities.IsTableEmpty(tShieldsToAssist) == false then
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]) == false then
                for iShield, oShield in tShieldsToAssist do
                    if M28Utilities.IsTableEmpty(oShield[M28UnitInfo.reftoUnitsAssistingThis]) == false and not(oShield[refbPriorityShield]) then
                        --Shield wasnt a priority shield in the last cycle but has engineers assigned to assist it - will clear these engineers
                        local tEngineersToClear = {}
                        for iEngi, oEngi in oShield[M28UnitInfo.reftoUnitsAssistingThis] do
                            table.insert(tEngineersToClear, oEngi)
                        end
                        for iAssistingEngineer, oAssistingEngineer in tEngineersToClear do
                            if M28UnitInfo.IsUnitValid(oAssistingEngineer) then M28Orders.IssueTrackedClearCommands(oAssistingEngineer) end
                        end
                        oShield[M28UnitInfo.reftoUnitsAssistingThis] = nil
                    end
                end
            end

            tLZTeamData[M28Map.reftPriorityShieldsToAssist] = {}
            local iTotalUnitMassCoverage
            local iCurMassValue
            local bConsiderRecentlyDamagedShields = false
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates]) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 300 then bConsiderRecentlyDamagedShields = true end
            for iShield, oShield in tShieldsToAssist do
                iTotalUnitMassCoverage = 0
                if bDebugMessages == true then LOG(sFunctionRef..': Considering shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; size of table of units nearby='..table.getn(oShield[reftoUnitsCoveredByShield])) end
                if M28Utilities.IsTableEmpty(oShield[reftoUnitsCoveredByShield]) == false and not(oShield[reftArtiTemplateRefs]) then
                    --Only flag a shield for assistance if its health is <80%
                    local iCurShieldHealth, iMaxShieldHealth = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Shield health='..iCurShieldHealth..'; Max health='..iMaxShieldHealth) end
                    if iCurShieldHealth > 0 and (iCurShieldHealth / iMaxShieldHealth <= 0.8 or (bConsiderRecentlyDamagedShields and oShield[M28UnitInfo.refiTimeLastDamaged] and GetGameTimeSeconds() - (oShield[M28UnitInfo.refiTimeLastDamaged] or -100) <= 30)) then

                        for iUnit, oUnit in oShield[reftoUnitsCoveredByShield] do
                            if not(oUnit == oShield) then
                                if EntityCategoryContains(M28UnitInfo.refCategorySMD, oUnit.UnitId) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false then
                                    iCurMassValue = 30000
                                elseif EntityCategoryContains(M28UnitInfo.refCategorySML, oUnit.UnitId) then
                                    iCurMassValue = 27500
                                else
                                    iCurMassValue = (oUnit:GetBlueprint().Economy.BuildCostMass or 0)
                                end
                                if not(oUnit[refoPriorityShieldProvidingCoverage] == oShield) and M28UnitInfo.IsUnitValid(oUnit[refoPriorityShieldProvidingCoverage]) then
                                    iCurMassValue = iCurMassValue * 0.1
                                    if bDebugMessages == true then LOG(sFunctionRef..': Already have a priority shield providing coverage='..oUnit[refoPriorityShieldProvidingCoverage].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[refoPriorityShieldProvidingCoverage])..' so will reduce mass value') end
                                end
                                iTotalUnitMassCoverage = iTotalUnitMassCoverage + iCurMassValue
                                if bDebugMessages == true then LOG(sFunctionRef..': Getting shield protection mass value of oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' for oShield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; iCurMassValue='..iCurMassValue..'; iTotalUnitMassCoverage='..iTotalUnitMassCoverage..'; Is there already a valid shield protecting it='..tostring(M28UnitInfo.IsUnitValid(oUnit[refoPriorityShieldProvidingCoverage]))) end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iTotalUnitMassCoverage='..iTotalUnitMassCoverage..'; refiAssignedFirebase='..(oShield[refiAssignedFirebase] or 'nil')) end
                        if iTotalUnitMassCoverage >= 25000 then
                            --Add as a priority shield
                            table.insert(tLZTeamData[M28Map.reftPriorityShieldsToAssist], oShield)
                            oShield[refbPriorityShield] = true
                            for iUnit, oUnit in oShield[reftoUnitsCoveredByShield] do
                                oUnit[refoPriorityShieldProvidingCoverage] = oShield --Deliberately overwrites existing value, means if 2 shields cover same area, and one can justify it even with the ot her, but the other cant, then we wont protect the other
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding the shield as a priority shield') end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function OnMexDeath(tUnitPosition, sUnitRef, sLifetimeCount, iOwnerArmyIndex)
    --Call via fork thread due to the WaitSeconds() in it; however note that as this is forked, the unit (mex) may not exist anymore, so tUnitPosition needs to be a copy of the position table, and dont want to pass the unit object
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OnMexDeath'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; tUnitPosition='..repru(tUnitPosition)) end



    --local tUnitPosition = {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]}
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tUnitPosition)
    local tMexLocations
    local tLZOrWZData
    local iWaterZone, iPond



    if iPlateau and not(iLandZone) then
        iWaterZone = M28Map.GetWaterZoneFromPosition(tUnitPosition)
        if iWaterZone then
            iPond = M28Map.tiPondByWaterZone[iWaterZone]
            tLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
            tMexLocations = tLZOrWZData[M28Map.subrefWZMexLocations]
        end
    else
        tLZOrWZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
        tMexLocations = tLZOrWZData[M28Map.subrefLZMexLocations]
    end



    if bDebugMessages == true then LOG(sFunctionRef..': is table of mex locations empty='..tostring( M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]))..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; tUnitPosition='..repru(tUnitPosition)..'; is tMexLocations empty='..tostring(M28Utilities.IsTableEmpty(tMexLocations))..'; iWaterZone='..(iWaterZone or 'nil')) end
    if M28Utilities.IsTableEmpty(tMexLocations) == false then
        --Record time of last mex death against LZ data to help with error messages
        tLZOrWZData[M28Map.refiTimeOfLastMexDeath] = GetGameTimeSeconds()

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1) --dont treat mex as available for a second (this is to help cover scenarios where if a mex has 'died' due to being upgraded, the new building will be here) - was a 2s delay, are trying 1s delay now to see if causes an issue
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        local tClosestMexLocation
        local iClosestMexLocation = 2.1 --no point considering mexes further away
        local iCurAbsDif
        for iEntry, tMex in tLZOrWZData[M28Map.subrefLZMexLocations] do --(WZ uses same ref ID definition)
            iCurAbsDif = math.abs(tMex[1] - tUnitPosition[1]) + math.abs(tMex[3] - tUnitPosition[3])
            if iCurAbsDif < iClosestMexLocation then
                iClosestMexLocation = iCurAbsDif
                tClosestMexLocation = {tMex[1], tMex[2], tMex[3]}
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting a period of time and then searching for closest mex location, tClosestMexLocation='..repru(tClosestMexLocation)..'; Time='..GetGameTimeSeconds()..'; iPlateau='..iPlateau..'; iLandZone='..(iLandZone or 'nil')) end
        if not(tClosestMexLocation) then M28Utilities.ErrorHandler('Couldnt find a mex in this zone close enough to the unit position on death')
        else
            --for iMexLocation, tMexLocation in tMexLocations do
            --Prev line - redid at same time as changing approach for removing an unbuilt location to try and be more accurate
            --if M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition()) <= 0.9 then
            --Revised line:
            --if tMexLocation[1] == tClosestMexLocation[1] and tMexLocation[3] == tClosestMexLocation[3] then
            --Do we have any mexes in this location?
            local rRect = M28Utilities.GetRectAroundLocation(tClosestMexLocation, 0.9)
            local tUnitsInRect = GetUnitsInRect(rRect)
            if bDebugMessages == true then
                LOG(sFunctionRef..': Is tUnitsInRect empty='..tostring(M28Utilities.IsTableEmpty(tUnitsInRect)))
                if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                    LOG(sFunctionRef..': If filter to just mexes is the table empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tUnitsInRect))))
                end
            end
            local bNoMex = true
            if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                local tMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tUnitsInRect)
                if M28Utilities.IsTableEmpty(tMexes) == false then
                    for iMex, oMex in tMexes do
                        if M28UnitInfo.IsUnitValid(oMex) and not(oMex.UnitId == sUnitRef and M28UnitInfo.GetUnitLifetimeCount(oMex) == sLifetimeCount and oMex:GetAIBrain():GetArmyIndex() == iOwnerArmyIndex) then
                            local tMexPosition = oMex:GetPosition()
                            --Get closest mex to this, in case there's another mex that's closer
                            local iCurMexClosestLocation = 2.1
                            local tCurMexClosestLocation
                            for iEntry, tMex in tLZOrWZData[M28Map.subrefLZMexLocations] do --(WZ uses same ref ID definition)
                                iCurAbsDif = math.abs(tMex[1] - tMexPosition[1]) + math.abs(tMex[3] - tMexPosition[3])
                                if iCurAbsDif < iCurMexClosestLocation then
                                    iCurMexClosestLocation = iCurAbsDif
                                    tCurMexClosestLocation = {tMex[1], tMex[2], tMex[3]}
                                end
                            end
                            if tCurMexClosestLocation[1] == tClosestMexLocation[1] and tCurMexClosestLocation[3] == tClosestMexLocation[3] then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have a valid mex in this location, oMex='..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)..'; Army Index='..oMex:GetAIBrain():GetArmyIndex()..'; sUnitRef='..sUnitRef..'; sLifetimeCount='..sLifetimeCount..'; iOwnerArmyIndex='..(iOwnerArmyIndex or 'nil')..'; tCurMexClosestLocation='..repru(tCurMexClosestLocation)..'; Mex position='..repru(oMex:GetPosition())..'; tUnitPosition='..repru(tUnitPosition)..'; tClosestMexLocation='..repru(tClosestMexLocation)) end
                                bNoMex = false
                                break
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if we have a mex at this location anymore, bNoMex='..tostring(bNoMex)) end
            if bNoMex then
                local bAlreadyRecorded = false
                if not(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) then
                    tLZOrWZData[M28Map.subrefMexUnbuiltLocations] = {}
                else
                    for iEntry, tUnbuiltLocation in tLZOrWZData[M28Map.subrefMexUnbuiltLocations] do --redundancy in case this code triggers more than once, as were comign across unbuilt locations with the same entry listed more than once (although it wasnt showing up with a reprs/repru)
                        if tUnbuiltLocation[1] == tClosestMexLocation[1] and tUnbuiltLocation[3] == tClosestMexLocation[3] then
                            bAlreadyRecorded = true
                            break
                        end
                    end
                end
                if not(bAlreadyRecorded) then
                    table.insert(tLZOrWZData[M28Map.subrefMexUnbuiltLocations], tClosestMexLocation)
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Recording location as being unbuilt as mex is dead and no mexes visible there now')
                        M28Utilities.DrawLocation(tMexLocation)
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Already recorded this location as unbuilt') end
                end
                --break
            end
            --end
            --end
        end
        if bDebugMessages == true then
            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) then LOG(sFunctionRef..': tLZOrWZData[M28Map.subrefMexUnbuiltLocations] after update is empty')
            else LOG(sFunctionRef..': tLZOrWZData[M28Map.subrefMexUnbuiltLocations] after update has a size '..table.getn(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])..', table='..repru(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]))
            end
        end
    else
        M28Utilities.ErrorHandler('Mex has died but not in a recognised land or water zone that has mexes')
    end

    --Track mexes by team

    local iTeam
    local oOwnerBrain
    for iBrain, oBrain in ArmyBrains do
        if iBrain == iOwnerArmyIndex then
            oOwnerBrain = oBrain
            iTeam = oBrain.M28Team
            break
        end
    end
    if iTeam then
        local iMexTech = M28UnitInfo.GetBlueprintTechLevel(sUnitRef)
        M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][iMexTech] = (M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][iMexTech] or 0) - 1
    else
        if not(oOwnerBrain) or not(M28Conditions.IsCivilianBrain(oOwnerBrain)) then
            M28Utilities.ErrorHandler('Mex death for a brain that doesnt have a team, oOwnerBrain='..(oOwnerBrain.Nickname or 'nil'))
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function OnMexConstructionStarted(oUnit)
    --Run for all brains

    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OnMexConstructionStarted'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(M28Map.bMapLandSetupComplete) or GetGameTimeSeconds() <= 4 or not(M28Map.bWaterZoneInitialCreation) then
        while (not(M28Map.bMapLandSetupComplete) or GetGameTimeSeconds() <= 4 or not(M28Map.bWaterZoneInitialCreation)) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if GetGameTimeSeconds() >= 6 then break end
        end
    end

    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
    local tMexLocations
    local tLZOrWZData
    local iWaterZone, iPond



    if iPlateau and not(iLandZone) then
        iWaterZone = M28Map.GetWaterZoneFromPosition(oUnit:GetPosition())
        if iWaterZone then
            iPond = M28Map.tiPondByWaterZone[iWaterZone]
            tLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
            tMexLocations = tLZOrWZData[M28Map.subrefWZMexLocations]
        end
    else
        tLZOrWZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
        tMexLocations = tLZOrWZData[M28Map.subrefLZMexLocations]
    end

    if bDebugMessages == true then LOG(sFunctionRef..': The time is '..GetGameTimeSeconds()..'; Have just started construction for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'; Is M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]))..'; Unit position='..repru(oUnit:GetPosition())..'; Unit brain='..oUnit:GetAIBrain().Nickname..'; on team '..(oUnit:GetAIBrain().M28Team or 'nil')) end
    local bFoundMexLocation = false
    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false then
        --Find the closest mex location in the zone
        local tClosestMexLocation
        local iClosestMexLocation = 2.1 --no point considering mexes further away
        local iCurAbsDif
        local tUnitPosition = oUnit:GetPosition()
        for iEntry, tMex in tLZOrWZData[M28Map.subrefLZMexLocations] do --(WZ uses same ref ID definition)
            iCurAbsDif = math.abs(tMex[1] - tUnitPosition[1]) + math.abs(tMex[3] - tUnitPosition[3])
            if iCurAbsDif < iClosestMexLocation then
                iClosestMexLocation = iCurAbsDif
                tClosestMexLocation = {tMex[1], tMex[2], tMex[3]}
            end
        end


        local iSizeBefore = table.getn(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])
        if bDebugMessages == true then LOG('About to loop through Mex locations; iPlateau='..iPlateau..'; iLandZone='..(iLandZone or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'; reprs='..reprs(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])..'; iSizeBefore='..iSizeBefore..'; tClosestMexLocation='..repru(tClosestMexLocation)) end
        --local iSizeAfter
        --local iLocationToRemove
        if bDebugMessages == true then
            for iMexLocation, tMexLocation in tLZOrWZData[M28Map.subrefMexUnbuiltLocations] do
                LOG(sFunctionRef..': iMexLocation='..iMexLocation..'; tMexLocation='..repru(tMexLocation))
            end
        end
        if tClosestMexLocation then
            for iEntry = iSizeBefore, 1, -1 do
                local tMexLocation = tLZOrWZData[M28Map.subrefMexUnbuiltLocations][iEntry]
                if bDebugMessages == true then LOG(sFunctionRef..': Comparing dist for iEntry '..iEntry..'; tMexLocation='..repru(tMexLocation)..'; tClosestMexLocation='..repru(tClosestMexLocation)) end
                if tMexLocation[1] == tClosestMexLocation[1] and tMexLocation[3] == tClosestMexLocation[3] then
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Have built a mex within 1 of a mex location so will treat this mex location as no longer available. iEntry='..iEntry)
                        M28Utilities.DrawLocation(tMexLocation, 2)
                    end
                    bFoundMexLocation = true
                    local vRemoved = table.remove(tLZOrWZData[M28Map.subrefMexUnbuiltLocations], iEntry)
                    if bDebugMessages == true then LOG(sFunctionRef..': tLZOrWZData[M28Map.subrefMexUnbuiltLocations] after removal='..repru(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])..'; vRemoved='..reprs(vRemoved)..'; iSizeBefore='..iSizeBefore) end
                    break
                end
            end
        else
            M28Utilities.ErrorHandler('Couldnt find a mex location close enough')
        end
        --Old code - had issues with this sometimes where e.g. would have a table that with reprs showed as only having 1 entry, but it actually had 2 and were identical
        --[[for iMexLocation, tMexLocation in tLZOrWZData[M28Map.subrefMexUnbuiltLocations] do
            --Old code commented out below caused issues on maps like sludge:
            --if M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition()) <= 2 then
            --Replaced with the following:
            if bDebugMessages == true then LOG(sFunctionRef..': Considering tMexLocation='..repru(tMexLocation)..'; compared with Unit position '..repru(oUnit:GetPosition())) end
            if math.abs(tMexLocation[1] - oUnit:GetPosition()[1]) < 1 and math.abs(tMexLocation[3] - oUnit:GetPosition()[3]) < 1 then
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Have built a mex within 1 of a mex location so will treat this mex location as no longer available. iMexLocation='..iMexLocation)
                    M28Utilities.DrawLocation(tMexLocation, 2)
                end
                bFoundMexLocation = true
                iLocationToRemove = iMexLocation
                break
            end
        end
        if iLocationToRemove then
            local vRemoved = table.remove(tLZOrWZData[M28Map.subrefMexUnbuiltLocations], iLocationToRemove)
            local iSizeAfter
            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) then iSizeAfter = 0
            else iSizeAfter = table.getn(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])
            end
            if bDebugMessages == true then LOG(sFunctionRef..': tLZOrWZData[M28Map.subrefMexUnbuiltLocations] after removal='..repru(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])..'; vRemoved='..reprs(vRemoved)..'; iSizeBefore='..iSizeBefore..'; iSizeAfter='..iSizeAfter) end
        end
        if iSizeAfter >= iSizeBefore then
            --Backup for strange case where table.remove would remove a table but the table would still remain

        end--]]
    end
    if not(bFoundMexLocation) then
        --Is the reason we cant find any unbuilt locations because a mex is being upgraded? Doing a reprs of a mex being upgraded, CanTakeDamage was false and IsUpgrade was true, so use these to check
        if oUnit.CanTakeDamage and not(oUnit.IsUpgrade) and (GetGameTimeSeconds() - (tLZOrWZData[M28Map.refiTimeOfLastMexDeath] or 0)) > 2.1 then
            --Ignore if early game and is owned by non-human brain, or campaign and owned by non-M28AI non-human brain
            if oUnit:GetAIBrain().BrainType == 'Human' or oUnit:GetAIBrain().M28AI or (GetGameTimeSeconds() >= 10 and not(M28Map.bIsCampaignMap)) then
                local tNearbyRect = M28Utilities.GetRectAroundLocation(oUnit:GetPosition(), 0.49)
                local tUnitsWhereDied = GetUnitsInRect(tNearbyRect)
                local bHaveMexHere = false
                if M28Utilities.IsTableEmpty(tNearbyRect) == false then
                    for iBuilding, oBuilding in tNearbyRect do
                        if not(oBuilding == oUnit) and EntityCategoryContains(M28UnitInfo.refCategoryMex, oBuilding.UnitId) and M28UnitInfo.IsUnitValid(oBuilding) then
                            bHaveMexHere = true
                            break
                        end
                    end
                end
                if not(bHaveMexHere) then
                    --we have a 1s delay on a mex dying before checking for available locations, so this could explain this
                    if tLZOrWZData[M28Map.refiTimeOfLastMexDeath] and GetGameTimeSeconds() - tLZOrWZData[M28Map.refiTimeOfLastMexDeath] > 1.01 then
                        M28Utilities.ErrorHandler('OnCreate triggered for a mex but no unbuilt locations near it, iPlateau='..iPlateau..'; iLandZone='..(iLandZone or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'; Map setup complete='..tostring(M28Map.bMapLandSetupComplete)..'; bWaterZoneInitialCreation='..tostring(M28Map.bWaterZoneInitialCreation or false), true)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': tLZOrWZData[M28Map.subrefMexUnbuiltLocations]='..repru(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit position='..repru(oUnit:GetPosition())) end
                end
            end
        end
    end

    --Add mex to enemy unit table if underwater, due to flaw with current approach - i.e. to reduce overhead all AI regardless of team use the same table for if a mex has been built; engineers are meant to either build on unbuilt mexes, or try and reclaim if the enemy is there; however without this step they effectively end up thinking a teammate has the mex so they never tyr sending an engineer to build or capture.  For land it's not an issue as would expect land scouts or other land units to reveal the mexes anyway
    if iWaterZone > 0 then
        local tTeamsUpdated = {}
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.subreftoEnemyBrains]) == false then
            for iBrain, oBrain in M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.subreftoEnemyBrains] do
                if oBrain.M28AI and not(tTeamsUpdated[oBrain.M28Team]) then
                    tTeamsUpdated[oBrain.M28Team] = true
                    --(aiBrain, oUnit, bAlreadyUpdatedPosition, bAlreadyTriedReassignment, bIgnoreIfAssignedAlready)
                    M28Team.AssignUnitToLandZoneOrPond(oBrain, oUnit, false,                    false,                      true)
                end
            end
        else
            --E.g. civilians that own mexes
            local iMexBrainIndex = oUnit:GetAIBrain():GetArmyIndex()
            for iBrain, oBrain in ArmyBrains do
                if not(IsAlly(oBrain:GetArmyIndex(), iMexBrainIndex)) then
                    if oBrain.M28AI and not(tTeamsUpdated[oBrain.M28Team]) then
                        tTeamsUpdated[oBrain.M28Team] = true
                        --(aiBrain, oUnit, bAlreadyUpdatedPosition, bAlreadyTriedReassignment, bIgnoreIfAssignedAlready)
                        M28Team.AssignUnitToLandZoneOrPond(oBrain, oUnit, false,                    false,                      true)
                    end
                end
            end
        end
    end

    --Track mexes by team
    local iTeam = oUnit:GetAIBrain().M28Team
    if iTeam then
        local iMexTech = M28UnitInfo.GetUnitTechLevel(oUnit)
        if not(M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech]) then
            M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech] = {}
        end
        M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][iMexTech] = (M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][iMexTech] or 0) + 1
    elseif not(M28Conditions.IsCivilianBrain(oUnit:GetAIBrain())) then
        M28Utilities.ErrorHandler('No brain for mex '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' owned by brain '..(oUnit:GetAIBrain().Nickname or 'nil')..' so wont record for that brain team')
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tLZOrWZData[M28Map.subrefMexUnbuiltLocations]='..repru(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DecideToLaunchNukeSMLOrTMLMissile()  end --Done only to make it easier to find considerlaunchingmissile
function ConsiderLaunchingMissile(oLauncher, oOptionalWeapon)
    --Should be called via forkthread when missile created due to creating a loop
    --oOptioanlWeapon - if specified then can get the missile speed
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderLaunchingMissile'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if M28UnitInfo.IsUnitValid(oLauncher) then
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code for oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..' owned by brain '..oLauncher:GetAIBrain().Nickname..' at time='..GetGameTimeSeconds()..'; launcher position='..repru(oLauncher:GetPosition())) end
        --oLauncher[refbActiveMissileChecker] = true


        local tTarget
        local iBestTargetValue
        local iCurTargetValue
        local tEnemyCategoriesOfInterest
        local aiBrain = oLauncher:GetAIBrain()
        local iMaxRange = 250 --basic default, should get overwritten
        local iMinRange = 0
        local iAOE, iDamage

        local bTML = false
        local bSML = false
        local bCheckForSMD = false
        local iMinDelayBetweenNukes = 55 --Aeon nuke takes 60s to get to corner of setons, think it takes 5s longer to fire, so will go with 55 for non-aeon
        local iTeam = aiBrain.M28Team
        local iTotalWaitCount = 0 --Nukes will spread calculations over a number of ticks, this tracks the ticks waited
        if EntityCategoryContains(M28UnitInfo.refCategoryTML, oLauncher.UnitId) then bTML = true
        elseif EntityCategoryContains(M28UnitInfo.refCategorySML, oLauncher.UnitId) then

            bSML = true
            if not(EntityCategoryContains(categories.EXPERIMENTAL, oLauncher.UnitId)) then
                bCheckForSMD = true --default
                --If we have lots more nukes than enemy has SMD then consider overwhelming the SMD with nukes
                local iNukeCount = 0
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    iNukeCount = oBrain:GetCurrentUnits(M28UnitInfo.refCategorySML - categories.EXPERIMENTAL) + oBrain:GetCurrentUnits(M28UnitInfo.refCategorySML * categories.EXPERIMENTAL) * 6
                end
                --Only consider overwhelming if we have 6 nukes
                local iEnemySMD = 0
                if iNukeCount >= 4 then
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) == false then
                        for iSMD, oSMD in M28Team.tTeamData[iTeam][M28Team.reftEnemySMD] do
                            if oSMD:GetFractionComplete() == 1 then
                                iEnemySMD = iEnemySMD + 1
                            end
                        end
                    end
                    if iNukeCount >= iEnemySMD * 1.5 then
                        --Have enough nukes to overwhelm enemy
                        bCheckForSMD = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Have more than 50% of enemy SMD in nuke launchers so will nuke regardless of SMD, iNukeCount='..iNukeCount..'; iEnemySMD='..iEnemySMD) end
                    else
                        --How many SMD does enemy have in one zone?
                        local tiSMDByPlateauAndZone = {}
                        local iCurSMDPlateauOrZero, iCurSMDZone
                        local iHighestSMDPerZone = 0
                        for iSMD, oSMD in M28Team.tTeamData[iTeam][M28Team.reftEnemySMD] do
                            iCurSMDPlateauOrZero, iCurSMDZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oSMD:GetPosition())
                            if not(tiSMDByPlateauAndZone[iCurSMDPlateauOrZero]) then tiSMDByPlateauAndZone[iCurSMDPlateauOrZero] = {} end
                            tiSMDByPlateauAndZone[iCurSMDPlateauOrZero][iCurSMDZone] = (tiSMDByPlateauAndZone[iCurSMDPlateauOrZero][iCurSMDZone] or 0) + 1
                            iHighestSMDPerZone = math.max(iHighestSMDPerZone, tiSMDByPlateauAndZone[iCurSMDPlateauOrZero][iCurSMDZone])
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iNukeCount='..iNukeCount..'; iEnemySMD='..iEnemySMD..'; iHighestSMDPerZone='..iHighestSMDPerZone) end
                        if iNukeCount >= iHighestSMDPerZone * 1.5 then
                            bCheckForSMD = false
                        end
                    end

                    if not(bCheckForSMD) then
                        iMinDelayBetweenNukes = math.min(10, math.max(5, 15 - iNukeCount/2))
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to ignore SMD, oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..'; iNukeCount='..iNukeCount..'; iEnemySMD (if we have lots of nukes)='..iEnemySMD..'; bCheckForSMD='..tostring(bCheckForSMD)..'; Time='..GetGameTimeSeconds()..'; iMinDelayBetweenNukes='..iMinDelayBetweenNukes) end
                end

                if EntityCategoryContains(categories.AEON, oLauncher.UnitId) then iMinDelayBetweenNukes = iMinDelayBetweenNukes + 5 end
            else
                --yolona - refuce min delay if enemy has lots of SMD as may be trying to overwhelm
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) == false and table.getn(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) >= 3 then
                    iMinDelayBetweenNukes = 9
                end
            end



        else M28Utilities.ErrorHandler('Unknown type of launcher, code to fire a missile wont work; oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher))
        end

        if bTML or bSML then
            iAOE, iDamage, iMinRange, iMaxRange = M28UnitInfo.GetLauncherAOEStrikeDamageMinAndMaxRange(oLauncher)

            if bTML then
                --tEnemyCategoriesOfInterest = iTMLHighPriorityCategories
            else --SML
                tEnemyCategoriesOfInterest = {M28UnitInfo.refCategoryExperimentalStructure, M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategorySML + categories.COMMAND, M28UnitInfo.refCategoryT3Mex + M28UnitInfo.refCategoryT3Power, M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryStructure * categories.TECH3 + M28UnitInfo.refCategoryFixedT2Arti - M28UnitInfo.refCategoryExperimentalStructure - M28UnitInfo.refCategoryFixedT3Arti - M28UnitInfo.refCategorySML - M28UnitInfo.refCategoryT3Mex - M28UnitInfo.refCategorySMD - M28UnitInfo.refCategoryT3Power, M28UnitInfo.refCategoryNavalSurface * categories.TECH3 + M28UnitInfo.refCategoryNavalSurface * categories.EXPERIMENTAL}
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will consider missile target. iMinRange='..(iMinRange or 'nil')..'; iAOE='..(iAOE or 'nil')..'; iDamage='..(iDamage or 'nil')..'; bSML='..tostring((bSML or false))) end

            if M28UnitInfo.IsUnitValid(oLauncher) then
                if bTML then

                    local tHighHealthTargets = {}
                    local tStartPos = oLauncher:GetPosition()
                    local tPotentialTargets = oLauncher[reftUnprotectedUnitTargetsForThisTML]
                    local iValidTargets = 0
                    local tValidTargets = {}
                    local iTMLRange = (oLauncher[M28UnitInfo.refiManualRange] or iTMLMissileRange)
                    local iTMLAOE = math.max(oLauncher[M28UnitInfo.refiIndirectAOE] or 0, 2)
                    local iPotentialInRangeDistance = iTMLRange + iTMLAOE + 4 --unlikely to have larger buildings than this
                    --First refresh list of untis in range for any that are dead
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of potential targets empty='..tostring(M28Utilities.IsTableEmpty(tPotentialTargets))) end
                    if M28Utilities.IsTableEmpty(tPotentialTargets) == false then
                        local iPotentialTargets = table.getn(tPotentialTargets)
                        local iCurDist
                        for iCurEntry = iPotentialTargets, 1, -1 do
                            if not(M28UnitInfo.IsUnitValid(tPotentialTargets[iCurEntry])) then
                                table.remove(oLauncher[reftUnprotectedUnitTargetsForThisTML], iCurEntry)
                            else
                                --Can we hit this unit factoring in AOE?
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(tPotentialTargets[iCurEntry]:GetPosition(), tStartPos)
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering entry '..iCurEntry..'; Unit='..tPotentialTargets[iCurEntry].UnitId..M28UnitInfo.GetUnitLifetimeCount(tPotentialTargets[iCurEntry])..'; iCurDist='..iCurDist..'; iPotentialInRangeDistance='..iPotentialInRangeDistance..'; iTMLRange='..iTMLRange..'; iTMLAOE='..iTMLAOE) end
                                if iCurDist <= iPotentialInRangeDistance then
                                    if iCurDist <= iTMLRange or iCurDist <= iTMLRange + math.max(iTMLAOE, 0.5 * math.min(tPotentialTargets[iCurEntry]:GetBlueprint().Physics.SkirtSizeX, tPotentialTargets[iCurEntry]:GetBlueprint().Physics.SkirtSizeZ)) then
                                        table.insert(tValidTargets, tPotentialTargets[iCurEntry])
                                        iValidTargets = iValidTargets + 1
                                    end
                                end
                            end
                        end
                    end

                    local oBestTarget
                    --Below was M27's appraoch to getting TML targets
                    --[[aiBrain:GetUnitsAroundPoint(iTMLHighPriorityCategories, tStartPos, iMaxRange, 'Enemy')
                    local tEnemyTMD = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD, tStartPos, iMaxRange + 30, 'Enemy')

                    if M28Utilities.IsTableEmpty(tPotentialTargets) == false then
                        for iUnit, oUnit in tPotentialTargets do
                            if M27EngineerOverseer.IsValidTMLTarget(aiBrain, tStartPos, oUnit, tEnemyTMD) then
                               iValidTargets = iValidTargets + 1
                                tValidTargets[iValidTargets] = oUnit
                            end
                        end
                    end--]]
                    --[[if iValidTargets == 0 then
                        tPotentialTargets = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure * categories.TECH2 + M28UnitInfo.refCategoryStructure * categories.TECH3 + M28UnitInfo.refCategoryFatboy - iTMLHighPriorityCategories -M28UnitInfo.refCategoryTMD, tStartPos, iMaxRange, 'Enemy')
                        if M28Utilities.IsTableEmpty(tPotentialTargets) == false then
                            for iUnit, oUnit in tPotentialTargets do
                                if not(EntityCategoryContains(categories.MOBILE, oUnit.UnitId)) or not(oUnit:IsUnitState('Moving')) then
                                    if oUnit:GetHealth() <= 6000 then
                                        if M27EngineerOverseer.IsValidTMLTarget(aiBrain, tStartPos, oUnit, tEnemyTMD) then
                                            iValidTargets = iValidTargets + 1
                                            tValidTargets[iValidTargets] = oUnit
                                        end
                                    else
                                        table.insert(tHighHealthTargets, oUnit)
                                    end
                                end
                            end
                        end
                        if iValidTargets == 0 then
                            --Target valid high health targets
                            if M28Utilities.IsTableEmpty(tHighHealthTargets) == false then
                                for iUnit, oUnit in tHighHealthTargets do
                                    if M27EngineerOverseer.IsValidTMLTarget(aiBrain, tStartPos, oUnit, tEnemyTMD) then
                                        iValidTargets = iValidTargets + 1
                                        tValidTargets[iValidTargets] = oUnit
                                    end
                                end
                            end
                        end
                    end--]]

                    if iValidTargets == 0 then
                        --Disable autobuild and pause the TML since we have no targets - handled below to cover cases where for whatever reason we fail to find a valid target
                    else
                        --Have at least 1 valid target, so want to pick the best one

                        iBestTargetValue = 120 --wont consider targets worth less than this
                        local sLauncherLocationRef = M28Utilities.ConvertLocationToReference(oLauncher:GetPosition())
                        for iUnit, oUnit in tValidTargets do
                            if M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]) == false then
                                iCurTargetValue = 0
                                if bDebugMessages == true then LOG(sFunctionRef..': Shields are covering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                            else
                                --GetDamageFromBomb(aiBrain, tBaseLocation,         iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory)
                                iCurTargetValue = M28Logic.GetDamageFromBomb(aiBrain, oUnit:GetPosition(), iAOE, iDamage,       nil,                                nil,                true,                           nil,                nil,                            nil,                                        false,              nil,                            true)
                                if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then iCurTargetValue = iCurTargetValue * 1.5 end
                                --Adjust value if we think the missile will hit a cliff
                                if oUnit[tbExpectMissileBlockedByCliff][sLauncherLocationRef] == nil then
                                    if not(oUnit[tbExpectMissileBlockedByCliff]) then oUnit[tbExpectMissileBlockedByCliff] = {} end
                                    local tExpectedMissileVertical = M28Utilities.MoveInDirection(oLauncher:GetPosition(), M28Utilities.GetAngleFromAToB(oLauncher:GetPosition(), oUnit:GetPosition()), 31, true)
                                    tExpectedMissileVertical[2] = tExpectedMissileVertical[2] + 60 --Doing testing, it actually only goes up by 50, but I think it travels in an arc from here to the target, as in a test scenario doing at less than +60 meant it thought it would hit a cliff when it didnt
                                    -- {oLauncher:GetPosition()[1], oLauncher:GetPosition()[2] + 65, oLauncher:GetPosition()[3]}
                                    oUnit[tbExpectMissileBlockedByCliff][sLauncherLocationRef] = M28Logic.IsLineBlocked(aiBrain, tExpectedMissileVertical, oUnit:GetPosition(), iAOE, false)
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Potential TML target '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurTargetValue before adj for blocked='..iCurTargetValue..'; oUnit[tbExpectMissileBlockedByCliff][sLauncherLocationRef]='..tostring(oUnit[tbExpectMissileBlockedByCliff][sLauncherLocationRef])..'; oUnit[refiTMLShotsFired]='..(oUnit[refiTMLShotsFired] or 0)..'; refiTimeOfLastLaunch='..(oUnit[refiTimeOfLastLaunch] or 'nil')..'; oUnit[refbProtectedByTerrain]='..tostring(oUnit[refbProtectedByTerrain] or false)..'; oLauncher[reftTerrainBlockedTargets]='..repru(oLauncher[reftTerrainBlockedTargets] or {'nil'})..'; iDamage='..iDamage..'; iAOE='..iAOE..'; Unit health='..oUnit:GetHealth()..'; Unit position='..repru(oUnit:GetPosition())..'; Is reftoShieldsProvidingCoverage empty='..tostring(M28Utilities.IsTableEmpty(oUnit[reftoShieldsProvidingCoverage]))) end
                                if oUnit[tbExpectMissileBlockedByCliff][sLauncherLocationRef] then iCurTargetValue = iCurTargetValue * 0.2 end
                                --Check against actual terrain blocked blacklist
                                if oUnit[refbProtectedByTerrain] then
                                    iCurTargetValue = 0
                                elseif M28Utilities.IsTableEmpty(oLauncher[reftTerrainBlockedTargets]) == false then
                                    for iEntry, tLocation in oLauncher[reftTerrainBlockedTargets] do
                                        if M28Utilities.GetDistanceBetweenPositions(tLocation, oUnit:GetPosition()) <= 1.5 then
                                            oUnit[refbProtectedByTerrain] = true
                                            iCurTargetValue = 0
                                            break
                                        end
                                    end
                                end
                                if iCurTargetValue > 0 and (oUnit[refiTMLShotsFired] or 0) > 0 then
                                    --Reduce shots fired if we dealt damage with our last missile (as may have e.g. hit mass storage blocking us from reaching the target mex)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Last TML target='..(oLauncher[refoLastTMLTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oLauncher[refoLastTMLTarget]) or 'nil')..'; Launcher mass killed='..(oLauncher.VetExperience or oLauncher.Sync.totalMassKilled or 0)..'; TML mass kills='..(oLauncher[refiLastTMLMassKills] or 0)) end
                                    if oLauncher[refoLastTMLTarget] == oUnit and (oLauncher.VetExperience or oLauncher.Sync.totalMassKilled or 0) > (oLauncher[refiLastTMLMassKills] or 0) then
                                        oLauncher[refiLastTMLMassKills] = (oLauncher.VetExperience or oLauncher.Sync.totalMassKilled or 0)
                                        oUnit[refiTMLShotsFired] = oUnit[refiTMLShotsFired] - 1
                                    end
                                    if oUnit[refiTMLShotsFired] > 0 or oUnit[refiTimeOfLastLaunch] then
                                        local iUnitMaxHealth = oUnit:GetMaxHealth()
                                        local iUnitCurShield, iUnitMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit)
                                        if (iUnitMaxHealth + iUnitMaxShield <= iDamage and M28UnitInfo.IsUnitValid(oUnit[refoLastTMLLauncher])) and (not(oUnit[refoLastTMLLauncher] == oLauncher) or GetGameTimeSeconds() - (oUnit[refiTimeOfLastLaunch] or -100) <= 35) then
                                            iCurTargetValue = 0
                                        else

                                            local iExpectedShots = math.ceil((iUnitMaxHealth + iUnitMaxShield) / iDamage)
                                            if oUnit[refiTMLShotsFired] > iExpectedShots then
                                                --Reduce by 50% for each time are over
                                                iCurTargetValue = iCurTargetValue * 0.5^(oUnit[refiTMLShotsFired] - iExpectedShots)
                                                if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) and oUnit[refiTMLShotsFired] - iExpectedShots >= 3 then
                                                    iCurTargetValue = 0
                                                end
                                            end
                                        end

                                        if bDebugMessages == true then LOG(sFunctionRef..': iUnitMaxHealth='..iUnitMaxHealth..'; iUnitMaxShield='..iUnitMaxShield..'; oUnit[refiTMLShotsFired]='..oUnit[refiTMLShotsFired]..'; oUnit[refiTimeOfLastLaunch]='..(oUnit[refiTimeOfLastLaunch] or 'nil')..'; iCurTargetValue after adjusting for excess='..iCurTargetValue) end
                                    end
                                end
                            end
                            if iBestTargetValue < iCurTargetValue then
                                iBestTargetValue = iCurTargetValue
                                oBestTarget = oUnit
                            end
                        end
                        if oBestTarget then
                            tTarget = oBestTarget:GetPosition()
                            --Target ground following FAF changes to TMLs
                            tTarget[2] = GetSurfaceHeight(tTarget[1], tTarget[3])
                            if oLauncher:IsUnitState('Busy') and (GetGameTimeSeconds() - (oLauncher[refiTimeOfLastLaunch] or -100)) < 5 and M28UnitInfo.IsUnitValid(oLauncher[refoLastTMLTarget]) then
                                oLauncher[refoLastTMLTarget][refiTMLShotsFired] = (oLauncher[refoLastTMLTarget][refiTMLShotsFired] or 0) - 1
                            end
                            oBestTarget[refiTMLShotsFired] = (oBestTarget[refiTMLShotsFired] or 0) + 1
                            oLauncher[refoLastTMLTarget] = oBestTarget
                            oLauncher[refiLastTMLMassKills] = (oLauncher.VetExperience or oLauncher.Sync.totalMassKilled or 0)
                            oBestTarget[refoLastTMLLauncher] = oLauncher
                            oBestTarget[refiTimeOfLastLaunch] = GetGameTimeSeconds()
                            if bDebugMessages == true then LOG(sFunctionRef..': oBestTarget='..oBestTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestTarget)..'; iBestTargetValue='..iBestTargetValue..'; SHots fired afteri ncluding this one='..oBestTarget[refiTMLShotsFired]..'; Mass killed prior to missile impacting='..oLauncher[refiLastTMLMassKills]) end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iValidTargets='..iValidTargets..'; tTarget='..repru((tTarget or {'nil'}))..'; Is oBestTarget valid='..tostring(M28UnitInfo.IsUnitValid(oBestTarget))) end

                else --SML - work out which location would deal the most damage - consider all high value structures and the enemy start position
                    iBestTargetValue = 0
                    --Shortlist of locations we have recently nuked
                    local tRecentlyNuked = {}
                    local iTimeSMDNeedsToHaveBeenBuiltFor = 240 --default, will adjust
                    local iMissileSpeed
                    if oOptionalWeapon then iMissileSpeed = (__blueprints[oOptionalWeapon.Blueprint.ProjectileId].Physics.MaxSpeed or 40)
                    else iMissileSpeed = 40
                    end
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..'; Breakdown of the weapon table='..reprs(oOptionalWeapon)..'; iMissileSpeed='..iMissileSpeed..'; missile speed per BP='..(__blueprints[oOptionalWeapon.Blueprint.ProjectileId].Physics.MaxSpeed or 'nil'))
                    end

                    local iNukeSegmentSize = 15
                    local tiNukeSegmentsConsidered = {}
                    local iCurNukeSegmentX, iCurNukeSegmentZ
                    local bAlreadyConsideredBestAOETarget = true

                    local iPositionsConsideredThisTick = 0
                    local iAbortThreshold = 60000

                    function GetNukeSegmentsFromPosition(tPosition)
                        return math.ceil(tPosition[1] / iNukeSegmentSize), math.ceil(tPosition[3] / iNukeSegmentSize)
                    end
                    function RecordHaveConsideredNukeLocation(tPosition, bConsideredBestAOETarget)
                        iCurNukeSegmentX, iCurNukeSegmentZ = GetNukeSegmentsFromPosition(tPosition)
                        if not(tiNukeSegmentsConsidered[iCurNukeSegmentX]) then tiNukeSegmentsConsidered[iCurNukeSegmentX] = {} end
                        tiNukeSegmentsConsidered[iCurNukeSegmentX][iCurNukeSegmentZ] = true
                        if bConsideredBestAOETarget then
                            iPositionsConsideredThisTick = iPositionsConsideredThisTick + 5 --approximation - will likely be more than this
                        else
                            iPositionsConsideredThisTick = iPositionsConsideredThisTick + 1
                        end

                    end

                    if bDebugMessages == true then LOG(sFunctionRef..': Checking nuke launch locations, is table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]))..'; Time of check='..GetGameTimeSeconds()) end
                    function RefreshRecentlyNukedLocations()
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]) == false then
                            local iTimeSinceFired
                            local iLoopCheck
                            for iTime, tLocation in M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations] do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering iTime='..iTime..'; tLocation='..repru(tLocation)..'; GameTime='..GetGameTimeSeconds()) end
                                iTimeSinceFired = GetGameTimeSeconds() - iTime

                                if iTimeSinceFired < iMinDelayBetweenNukes then --Testing with Aeon SML on setons it takes 60s to go from one corner to another roughly
                                    iLoopCheck = 0
                                    while tRecentlyNuked[iTimeSinceFired] do
                                        iTimeSinceFired = iTimeSinceFired - 0.0001
                                        iLoopCheck = iLoopCheck + 1
                                        if iLoopCheck >= 20 then M28Utilities.ErrorHandler('Potential infinite loop with nuke location recording, will stop attempting to record extra recently nuked locations') break end
                                    end
                                    tRecentlyNuked[iTimeSinceFired] = {tLocation[1], tLocation[2], tLocation[3]}
                                end
                            end
                        end
                    end

                    RefreshRecentlyNukedLocations()

                    if bDebugMessages == true then LOG(sFunctionRef..': tRecentlyNuked='..repru((tRecentlyNuked or {'nil'}))) end

                    function HaventRecentlyNukedLocation(tLocation )--, bIgnoreIfCoveredBySMD) --bIgnoreIfCoveredBySMD - removed from v46 (previously would set to true if want to ignore the fact that we have recenlty nuked the target if it is covered by SMD (i.e. if there is SMD then we likely want to overwhelm the target hence want to fire multiple nukes at the same location)

                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of recently nuked locations empty='..tostring(M28Utilities.IsTableEmpty(tRecentlyNuked))..'; tLocation='..repru(tLocation)) end
                        if M28Utilities.IsTableEmpty(tRecentlyNuked) then return true
                        else
                            for iTimeSinceFired, tRecentLocation in tRecentlyNuked do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering tLocation='..repru(tLocation)..'; Distance to tRecentLocation='..M28Utilities.GetDistanceBetweenPositions(tLocation, tRecentLocation)..'; is smd blocking targeet='..tostring(IsSMDBlockingTarget(aiBrain, tLocation, oLauncher:GetPosition(), 60, 0))..'; iTimeSinceFired='..iTimeSinceFired) end
                                --if iTimeSinceFired <= iMinDelayBetweenNukes then --(incorporated into refreshrecentlynukedlocations)
                                if M28Utilities.GetDistanceBetweenPositions(tLocation, tRecentLocation) <= 50 then
                                    return false
                                    --[[ Old logic (removed v46 and replaced with iMinDelayBetweenNukes)
                                    if bIgnoreIfCoveredBySMD then
                                        if IsSMDBlockingTarget(aiBrain, tLocation, oLauncher:GetPosition(), 60, 0) then
                                            return true --we have fired here recently but we want to fire multiple nukes to overwhelm smd
                                        else
                                            return false --we have fired here recently and there's no smd to overwhelm
                                        end
                                    else
                                        return false --we have fired here recently and dont care about overwhelming smd
                                    end--]]
                                end
                                --end
                            end
                        end
                        return true --we havent fired here recently
                    end

                    --First get the best location if just target the start position or locations near here
                    if HaventRecentlyNukedLocation(M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) then--, not(bCheckForSMD)) then
                        --GetBestAOETarget(aiBrain, tBaseLocation, iAOE, iDamage, bOptionalCheckForSMD, tSMLLocationForSMDCheck, iOptionalTimeSMDNeedsToHaveBeenBuiltFor, iSMDRangeAdjust, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, iOptionalMaxDistanceCheckOptions, iMobileValueOverrideFactorWithin75Percent, iOptionalShieldReductionFactor)
                        iTimeSMDNeedsToHaveBeenBuiltFor = 200 --3m20
                        tTarget, iBestTargetValue = M28Logic.GetBestAOETarget(aiBrain, M28Map.GetPrimaryEnemyBaseLocation(aiBrain), iAOE, iDamage, bCheckForSMD, oLauncher:GetPosition(), nil, nil, 2, 2.5)
                        RecordHaveConsideredNukeLocation(M28Map.GetPrimaryEnemyBaseLocation(aiBrain), true)
                    end

                    --Cycle through other start positions to see if can get a better target, but reduce value of target if we havent scouted it in the last 5 minutes
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering best target for nuke.  If target enemy base then iBestTargetValue='..iBestTargetValue) end
                    local iPlateauOrZero, iLandOrWaterZone
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
                        local tEnemyStartPosition =  M28Map.PlayerStartPoints[oBrain:GetArmyIndex()]
                        if M28Utilities.GetDistanceBetweenPositions(tEnemyStartPosition, M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) >= 30 then
                            --Have we scouted this location recently or do we have radar coverage
                            local tLZOrWZTeamData
                            iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tEnemyStartPosition)
                            if iPlateauOrZero > 0 then
                                tLZOrWZTeamData  = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
                            else
                                --Water zone
                                tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
                            end


                            if bDebugMessages == true then LOG(sFunctionRef..': Cycling through start points, considering brain '..(oBrain.Nickname or 'nil')..' with start point '..repru(tEnemyStartPosition)) end
                            if GetGameTimeSeconds() - (tLZOrWZTeamData[M28Map.refiTimeLastHadVisual] or -1000) <= 300 or tLZOrWZTeamData[M28Map.refiRadarCoverage] >= 20 then
                                iCurNukeSegmentX, iCurNukeSegmentZ = GetNukeSegmentsFromPosition(tEnemyStartPosition)
                                if not(tiNukeSegmentsConsidered[iCurNukeSegmentX][iCurNukeSegmentZ]) then
                                    if HaventRecentlyNukedLocation(tEnemyStartPosition) then --, not(bCheckForSMD)) then
                                        RecordHaveConsideredNukeLocation(tEnemyStartPosition, false)
                                        --GetDamageFromBomb(aiBrain, tBaseLocation,         iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory)
                                        iCurTargetValue = M28Logic.GetDamageFromBomb(aiBrain, tEnemyStartPosition, iAOE, iDamage,   2,                                  2.5                     , nil,                          nil,                nil,                            nil,                                        false,                  nil,                            true)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering the start position '..repru( tEnemyStartPosition)..'; value ignroign SMD='..iCurTargetValue) end
                                        if iCurTargetValue > iBestTargetValue then
                                            iTimeSMDNeedsToHaveBeenBuiltFor = 230 - (M28Utilities.GetDistanceBetweenPositions( tEnemyStartPosition, oLauncher:GetPosition()) / iMissileSpeed + 10)
                                            if IsSMDBlockingTarget(aiBrain,  tEnemyStartPosition, oLauncher:GetPosition(), iTimeSMDNeedsToHaveBeenBuiltFor) then
                                                iCurTargetValue = 4000
                                                if bDebugMessages == true then LOG(sFunctionRef..': SMD is blocking target so reducing value to 4k. iTimeSMDNeedsToHaveBeenBuiltFor='..iTimeSMDNeedsToHaveBeenBuiltFor) end
                                            end
                                            if iCurTargetValue > iBestTargetValue then
                                                bAlreadyConsideredBestAOETarget = false
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have a better start position target, dealing damage of '..iCurTargetValue..' vs prev best value of '..iBestTargetValue..'; iTimeSMDNeedsToHaveBeenBuiltFor='..iTimeSMDNeedsToHaveBeenBuiltFor) end
                                                iBestTargetValue = iCurTargetValue
                                                tTarget = {tEnemyStartPosition[1], tEnemyStartPosition[2], tEnemyStartPosition[3]}
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end

                    function ConsiderTableOfPotentialTargets(tEnemyUnitsOfInterest, bOverrideCheckForSMD, iOptionalMobileOverrideFactor)
                        if M28Utilities.IsTableEmpty(tEnemyUnitsOfInterest) == false then
                            for iUnit, oUnit in tEnemyUnitsOfInterest do
                                if M28UnitInfo.IsUnitValid(oUnit) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iPositionsConsideredThisTick='..iPositionsConsideredThisTick..'; Have we recently nuked this location='..tostring((HaventRecentlyNukedLocation(oUnit:GetPosition())))) end
                                    iCurNukeSegmentX, iCurNukeSegmentZ = GetNukeSegmentsFromPosition(oUnit:GetPosition())
                                    if not(tiNukeSegmentsConsidered[iCurNukeSegmentX][iCurNukeSegmentZ]) then
                                        if HaventRecentlyNukedLocation(oUnit:GetPosition()) then --, not(bOverrideCheckForSMD)) then
                                            RecordHaveConsideredNukeLocation(oUnit:GetPosition(), false)
                                            --GetDamageFromBomb(aiBrain, tBaseLocation,         iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies)
                                            iCurTargetValue = M28Logic.GetDamageFromBomb(aiBrain, oUnit:GetPosition(), iAOE, iDamage,   2,                                  2.5,                    nil,                            nil,                nil,                            iOptionalMobileOverrideFactor,                  false,              nil,                            true)
                                            if bDebugMessages == true then LOG(sFunctionRef..': target oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurTargetValue='..iCurTargetValue..'; location='..repru(oUnit:GetPosition())..'; iPositionsConsideredThisTick='..iPositionsConsideredThisTick) end
                                            --Stop looking if tried >=10 targets and have one that is at least 20k of value
                                            if iCurTargetValue > iBestTargetValue then
                                                iTimeSMDNeedsToHaveBeenBuiltFor = 230 - (M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oLauncher:GetPosition()) / iMissileSpeed + 10)
                                                if bOverrideCheckForSMD and IsSMDBlockingTarget(aiBrain, oUnit:GetPosition(), oLauncher:GetPosition(), iTimeSMDNeedsToHaveBeenBuiltFor) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': SMD is blocking the unit target '..repru(oUnit:GetPosition())..'; will limit damage to 4k; iTimeSMDNeedsToHaveBeenBuiltFor='..iTimeSMDNeedsToHaveBeenBuiltFor) end
                                                    iCurTargetValue = 4000 end
                                                if iCurTargetValue > iBestTargetValue then
                                                    bAlreadyConsideredBestAOETarget = false
                                                    iBestTargetValue = iCurTargetValue
                                                    tTarget = oUnit:GetPosition()
                                                    if bDebugMessages == true then LOG(sFunctionRef..': New best target with value='..iBestTargetValue..'; iTimeSMDNeedsToHaveBeenBuiltFor='..iTimeSMDNeedsToHaveBeenBuiltFor) end
                                                end
                                            end
                                            --Note: Mass value of mexes is doubled, so 3 T3 mexes would give a value of 27600
                                            if iPositionsConsideredThisTick >= 8 and iBestTargetValue >= iAbortThreshold then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have a target with a decent amount of value and have already tried quite a few units.  iBestTargetValue='..iBestTargetValue..'; iPositionsConsideredThisTick='..iPositionsConsideredThisTick) end
                                                break
                                            end
                                        end
                                    end
                                    --Spread out calculations over a number of ticks due to their intesnity
                                    if iPositionsConsideredThisTick >= 10 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considered '..iPositionsConsideredThisTick..' targets, will wait 1 tick before considering more for performance reasons. iBestTargetValue='..iBestTargetValue) end
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        WaitTicks(1)
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                                        RefreshRecentlyNukedLocations()
                                        iPositionsConsideredThisTick = 0
                                        iTotalWaitCount = iTotalWaitCount + 1
                                        if not(M28UnitInfo.IsUnitValid(oLauncher)) then
                                            tTarget = nil
                                            break
                                        end
                                        --Lower requirements to stop searching over time
                                        if iTotalWaitCount >= 20 then
                                            iAbortThreshold = iAbortThreshold * 0.95
                                            if iTotalWaitCount >= 100 then
                                                iAbortThreshold = math.min(iAbortThreshold * 0.95, 1000)
                                                if iTotalWaitCount >= 150 then break end
                                            end
                                            if iBestTargetValue >= iAbortThreshold then break end
                                        end
                                    end
                                end
                            end
                        end
                    end

                    --Consider a defensive nuke as well if enemy has land experimentals or battleships that are relatively near a friendly base - treat as higher value than normal where not covered by SMD (e.g. if have yolona then only want defensive nukes if expect the nuke to land)
                    local tEnemyClosestLandAndNavalThreats = {}
                    local iDefensiveThreshold = 350
                    local iBestValueOfDefensiveNuke = 0
                    local iDefensiveNukePlateauAndZone = {}
                    if M28Map.iMapSize <= 512 then iDefensiveThreshold = 225 end
                    local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oLauncher:GetPosition(), true, iTeam)
                    if tLZTeamData then
                        iDefensiveThreshold = math.max(125, math.min(iDefensiveThreshold, M28Utilities.GetDistanceBetweenPositions(oLauncher:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase])) * 0.45)
                    end
                    local iCurUnitPlateauOrZero, iCurUnitZone
                    local toClosestEnemyUntisByPlateauAndZone = {}

                    if bDebugMessages == true then LOG(sFunctionRef..': Considering priority enemy land threats near our base, is table of enemy land experimenatls empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]))) end
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
                        for iUnit, oUnit in  M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
                            if M28UnitInfo.IsUnitValid(oUnit) then
                                iCurUnitPlateauOrZero, iCurUnitZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                                if (iCurUnitZone or 0) > 0 and (iCurUnitPlateauOrZero or -1) >= 0 then
                                    local tUnitLZOrWZData, tUnitLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that is '..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tUnitLZOrWZTeamData[M28Map.reftClosestFriendlyBase])..' dist to the closest friendly base; iDefensiveThreshold='..iDefensiveThreshold) end
                                    if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tUnitLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) <= iDefensiveThreshold then
                                        table.insert(tEnemyClosestLandAndNavalThreats, oUnit)
                                        if not(toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero]) then toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero] = {} end
                                        if not(toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero][iCurUnitZone]) then toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero][iCurUnitZone] = {} end
                                        table.insert(toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero][iCurUnitZone], oUnit)
                                    end
                                end
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyBattleships]) == false then
                        for iUnit, oUnit in  M28Team.tTeamData[iTeam][M28Team.reftEnemyBattleships] do
                            if M28UnitInfo.IsUnitValid(oUnit) then
                                iCurUnitPlateauOrZero, iCurUnitZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                                if (iCurUnitZone or 0) > 0 and (iCurUnitPlateauOrZero or -1) >= 0 then
                                    local tUnitLZOrWZData, tUnitLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                    if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tUnitLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) <= iDefensiveThreshold then
                                        table.insert(tEnemyClosestLandAndNavalThreats, oUnit)
                                        if not(toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero]) then toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero] = {} end
                                        if not(toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero][iCurUnitZone]) then toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero][iCurUnitZone] = {} end
                                        table.insert(toClosestEnemyUntisByPlateauAndZone[iCurUnitPlateauOrZero][iCurUnitZone], oUnit)
                                    end
                                end
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tEnemyClosestLandAndNavalThreats) == false then
                        local iMassValueOfThreats = M28UnitInfo.GetCombatThreatRating(tEnemyClosestLandAndNavalThreats, true, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Mass value of nearby threats='..iMassValueOfThreats) end
                        if iMassValueOfThreats * 2 > iBestTargetValue and iMassValueOfThreats > 24000 then
                            --Go through the actual zones and consider targeting units in here, but always checking for SMD even with yolona
                            for iPlateauOrZero, tSubtable in toClosestEnemyUntisByPlateauAndZone do
                                for iZone, tUnits in tSubtable do
                                    if M28UnitInfo.GetCombatThreatRating(tUnits, true, true) >= 24000 then
                                        local iBestValuePreCheck = iBestTargetValue
                                        if bDebugMessages == true then LOG(sFunctionRef..': Best target value pre check for experimental land untis in P'..iPlateauOrZero..'Z'..iZone..'='..iBestTargetValue) end
                                        ConsiderTableOfPotentialTargets(tUnits, true, 0.8)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Best target value post check for experimental land untis in P'..iPlateauOrZero..'Z'..iZone..'='..iBestTargetValue) end
                                        if iBestTargetValue > iBestValuePreCheck then
                                            iBestValueOfDefensiveNuke = iBestTargetValue
                                            iDefensiveNukePlateauAndZone = {iPlateauOrZero, iZone}
                                        end
                                    end
                                end
                            end
                        end
                    end




                    if bDebugMessages == true then LOG(sFunctionRef..': iBestTargetValue for enemy base='..iBestTargetValue..'; if <80k then will consider other targets. tTarget='..repru(tTarget)) end
                    if iBestTargetValue < 80000 then --If have high value location for nearest enemy start then just go with this
                        for iRef, iCategory in tEnemyCategoriesOfInterest do
                            ConsiderTableOfPotentialTargets(aiBrain:GetUnitsAroundPoint(iCategory, oLauncher:GetPosition(), iMaxRange, 'Enemy'), bCheckForSMD)

                        end
                        if iBestTargetValue > iBestValueOfDefensiveNuke then
                            if tTarget then tTarget, iBestTargetValue = M28Logic.GetBestAOETarget(aiBrain, tTarget, iAOE, iDamage, bCheckForSMD, oLauncher:GetPosition(), nil, nil, 2, 2.5) end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iBestTargetValue after getting best location='..iBestTargetValue..'; Best location for this target='..repru(tTarget)) end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': If value is <14k then will clear target unless have yolona; iBestTargetValue='..iBestTargetValue..'; tTarget='..repru(tTarget or {'nil'})) end
                    if iBestTargetValue < 14000 then
                        if iBestTargetValue < 4000 or not(EntityCategoryContains(categories.EXPERIMENTAL, oLauncher.UnitId)) then
                            tTarget = nil
                        end
                    end --Increased vs M27 as will only apuse if no target


                    function ChangeTargetToClosestUnitToLauncher(tUnitsToConsider, iOptionalLeadingDistanceBaseAdjust)
                        local iClosestEnemyDist = 100000
                        local oClosestEnemyUnit
                        local iCurEnemyDist
                        local iBaseLeadingDistance = iOptionalLeadingDistanceBaseAdjust or iAOE * 0.7
                        for iUnit, oUnit in tUnitsToConsider do
                            iCurEnemyDist = M28Utilities.GetDistanceBetweenPositions(oLauncher:GetPosition(), oUnit:GetPosition())
                            if iCurEnemyDist < iClosestEnemyDist then
                                iClosestEnemyDist = iCurEnemyDist
                                oClosestEnemyUnit = oUnit
                            end
                        end
                        if oClosestEnemyUnit then
                            --Base target is this unit
                            local tPotentialAltTarget = oClosestEnemyUnit:GetPosition()
                            --Ajdust for unit facing direction if it is moving
                            local iUnitFacingAngle = M28UnitInfo.GetUnitFacingAngle(oClosestEnemyUnit)
                            if oClosestEnemyUnit:IsUnitState('Moving') then
                                tPotentialAltTarget = M28Utilities.MoveInDirection(oClosestEnemyUnit:GetPosition(), M28UnitInfo.GetUnitFacingAngle(oClosestEnemyUnit), iBaseLeadingDistance, true, false, true)
                            end
                            --Check the value of this isn't negative (due to friendly fire)
                            --GetDamageFromBomb(aiBrain, tBaseLocation,     iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory)
                            if M28Logic.GetDamageFromBomb(aiBrain, tPotentialAltTarget, iAOE, iDamage,   2,                                  2.5,                    nil,                            nil,                nil,                            0.6,                                       nil,                    nil,                            true) > 0 then
                                tTarget = tPotentialAltTarget
                                --Adjust the target further if it is far away
                                local iCurDist = M28Utilities.GetDistanceBetweenPositions(tTarget, oLauncher:GetPosition())
                                if iCurDist >= 300 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Target is far away so will adjust further, tTarget pre adjust='..repru(tTarget)) end
                                    tTarget = M28Utilities.MoveInDirection(tTarget, iUnitFacingAngle, math.min(iBaseLeadingDistance, (iCurDist - 300) / 30), true, false, true)
                                    if bDebugMessages == true then LOG(sFunctionRef..': tTarget post adjust='..repru(tTarget)) end
                                end
                            end

                            if bDebugMessages == true then LOG(sFunctionRef..': tPotentialAltTarget='..repru(tPotentialAltTarget)..'; tTarget after update='..repru(tTarget)..' based on oClosestEnemyUnit='..oClosestEnemyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyUnit)..' at position '..repru(oClosestEnemyUnit:GetPosition())..' with unit state='..M28UnitInfo.GetUnitState(oClosestEnemyUnit)..' and facing angle='..M28UnitInfo.GetUnitFacingAngle(oClosestEnemyUnit)..'; iAOE='..iAOE..'; Damage of bomb at potential target='..M28Logic.GetDamageFromBomb(aiBrain, tPotentialAltTarget, iAOE, iDamage,   2,                                  2.5,                    nil,                            nil,                nil,                            0.6)) end
                        end
                    end

                    if tTarget and iBestTargetValue <= iBestValueOfDefensiveNuke and M28Utilities.IsTableEmpty(toClosestEnemyUntisByPlateauAndZone) == false and M28Utilities.IsTableEmpty(toClosestEnemyUntisByPlateauAndZone[toClosestEnemyUntisByPlateauAndZone[1]][toClosestEnemyUntisByPlateauAndZone[2]]) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will launch a defensive nuke, positio before adjust='..repru(tTarget)) end
                        --Doing a defensive nuke so target the enemy unit nearest us, and adjust slightly for its facing direction
                        ChangeTargetToClosestUnitToLauncher(toClosestEnemyUntisByPlateauAndZone[toClosestEnemyUntisByPlateauAndZone[1]][toClosestEnemyUntisByPlateauAndZone[2]])
                    elseif M28Utilities.IsTableEmpty(tTarget) == false then
                        --Still check if significant threat is made of mobile units

                        local tTargetZoneData, tTargetZoneTeamData = M28Map.GetLandOrWaterZoneData(tTarget, true, iTeam)
                        if bDebugMessages == true then LOG(sFunctionRef..': Arent firing as a defensvie unit, checking structure value in zone, tTargetZoneTeamData[M28Map.subrefThreatEnemyStructureTotalMass]='..(tTargetZoneTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 'nil')) end
                        if (tTargetZoneTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) <  iBestTargetValue * 0.5 then
                            --Are there enemy experimentals or battleships in this zone?
                            local tEnemyExperimentalsAndBattleships = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryNavalSurface * categories.BATTLESHIP,tTargetZoneTeamData[M28Map.subrefTEnemyUnits])
                            if M28Utilities.IsTableEmpty(tEnemyExperimentalsAndBattleships) then
                                tEnemyExperimentalsAndBattleships = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryNavalSurface * categories.BATTLESHIP, tTarget, iAOE, 'Enemy')
                                if bDebugMessages == true then LOG(sFunctionRef..': No enemy experimentals in the zone being targeting, is units around point empty='..tostring(M28Utilities.IsTableEmpty(tEnemyExperimentalsAndBattleships))) end
                            end
                            if M28Utilities.IsTableEmpty( tEnemyExperimentalsAndBattleships) == false then
                                local bHaveMobileUnitsAndNoUnderConstruction = false
                                local bHaveAttackingOrPatrollingUnits = false

                                for iUnit, oUnit in tEnemyExperimentalsAndBattleships do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Checking enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)) end
                                    if oUnit:GetFractionComplete() < 1 and oUnit:GetFractionComplete() >= 0.05 then
                                        bHaveMobileUnitsAndNoUnderConstruction = false
                                        break
                                    else
                                        if oUnit:IsUnitState('Moving') then
                                            bHaveMobileUnitsAndNoUnderConstruction = true
                                        elseif oUnit:IsUnitState('Attacking') or oUnit:IsUnitState('Patrolling') then
                                            bHaveAttackingOrPatrollingUnits = true
                                        end
                                    end
                                end
                                local iDistanceAdjust
                                if bHaveMobileUnitsAndNoUnderConstruction then iDistanceAdjust = iAOE * 0.75
                                elseif bHaveAttackingOrPatrollingUnits then iDistanceAdjust = iAOE * 0.45
                                end
                                if iDistanceAdjust then
                                    if bDebugMessages == true then LOG(sFunctionRef..': tTarget before updating to nearest experimental or battleship='..repru(tTarget)) end
                                    ChangeTargetToClosestUnitToLauncher(tEnemyExperimentalsAndBattleships)
                                    if bDebugMessages == true then LOG(sFunctionRef..': tTarget after updating to nearest experimental or battleship='..repru(tTarget)) end
                                end
                            end
                        end
                    end
                    --Yolona target SMD that will stop us, if there are any, instead of our actual target, so we dont risk trying to take on loads of SMD in one go
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Checking if we are a yolona in which case we want to target any blocking SMD first, tTarget='..repru(tTarget)..'; bCheckForSMD='..tostring(bCheckForSMD)..'; Yolona='..tostring(EntityCategoryContains(categories.EXPERIMENTAL, oLauncher.UnitId))..'; Is table of enemy SMD empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]))..'; If enemy has more than 1 SMD will consider targeting SMD instead of the best target for the missile')
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) == false then LOG(sFunctionRef..': Number of enemy SMD='..table.getn(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD])) end
                    end
                    if tTarget and not(bCheckForSMD) and EntityCategoryContains(categories.EXPERIMENTAL, oLauncher.UnitId) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) == false and table.getn(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) > 1 then
                        --WOrk out which SMD are intercepting our missile
                        local tSMDBlockingTarget = IsSMDBlockingTarget(aiBrain, tTarget, oLauncher:GetPosition(), 60, 0, true)
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Is table of enemy SMD blocking target empty='..tostring(M28Utilities.IsTableEmpty(tSMDBlockingTarget)))
                            if M28Utilities.IsTableEmpty(tSMDBlockingTarget) == false then LOG(sFunctionRef..': Number of SMD blocking target='..table.getn(tSMDBlockingTarget)) end
                        end
                        --Only target down SMD if we have 2+ SMD blocking our desired target (otherwise it may be better to just ignore)
                        if M28Utilities.IsTableEmpty(tSMDBlockingTarget) == false and table.getn(tSMDBlockingTarget) > 1 then
                            local tAltTarget = GetBestAOETargetForSpecifiedBuildings(aiBrain, iTeam, oLauncher:GetPosition(), tSMDBlockingTarget, iAOE, iDamage)
                            if bDebugMessages == true then LOG(sFunctionRef..': Yolona target will be intercepted by SMD, want to take out the nearest blocking SMD first, tTarget='..repru(tTarget)..'; tAltTarget after facotirng in blockgin SMD='..repru(tAltTarget)) end
                            if tAltTarget and (table.getn(tSMDBlockingTarget) >= 3 or HaventRecentlyNukedLocation(tAltTarget)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will now draw ttarget and talttarget, tTarget will be in blue, tAltTarget will be in gold')
                                    M28Utilities.DrawLocation(tTarget)
                                    M28Utilities.DrawLocation(tAltTarget, 4)
                                end

                                tTarget = tAltTarget
                            end
                        end
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to launch at time '..GetGameTimeSeconds()..', tTarget='..repru(tTarget)) end
                if tTarget then
                    --Launch missile
                    if bDebugMessages == true then LOG(sFunctionRef..': Will launch missile at tTarget='..repru(tTarget)..'; Cur time='..GetGameTimeSeconds()) end
                    if bTML then
                        --Adjust target it outside our range but inside our AOE
                        if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oLauncher.UnitId) then --redundancy to make sure not dealing with mobile unit
                            local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(tTarget, oLauncher:GetPosition())
                            if iDistToTarget > oLauncher[M28UnitInfo.refiManualRange] then
                                if iDistToTarget - oLauncher[M28UnitInfo.refiManualRange] > oLauncher[M28UnitInfo.refiIndirectAOE] then
                                    M28Utilities.ErrorHandler('Have a TML launcher with a target outside its range+manual range')
                                else
                                    tTarget = M28Utilities.MoveInDirection(oLauncher:GetPosition(), M28Utilities.GetAngleFromAToB(oLauncher:GetPosition(), tTarget), oLauncher[M28UnitInfo.refiManualRange] - 0.01)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Updating target so we can hit the actual target with our aoe, tTarget='..repru(tTarget)..'; iDistToTarget pre this adjust='..iDistToTarget) end
                                end
                            end
                        end
                        M28Orders.IssueTrackedTMLMissileLaunch(oLauncher, tTarget, 0.25, false, 'TMLFire', true)
                        if M28UnitInfo.GetMissileCount(oLauncher) <= 1 then
                            oLauncher:SetAutoMode(true)
                        end
                        oLauncher:SetPaused(false)
                        if bDebugMessages == true then
                            local tExpectedMissileVertical = M28Utilities.MoveInDirection(oLauncher:GetPosition(), M28Utilities.GetAngleFromAToB(oLauncher:GetPosition(), tTarget), 31, true)
                            tExpectedMissileVertical[2] = tExpectedMissileVertical[2] + 60 --Doing testing, it actually only goes up by 50, but I think it travels in an arc from here to the target, as in a test scenario doing at less than +60 meant it thought it would hit a cliff when it didnt
                            local bShotBlocked = M28Logic.IsLineBlocked(aiBrain, tExpectedMissileVertical, tTarget, iAOE, false)
                            LOG(sFunctionRef..': Just launched tactical missile at tTarget='..repru(tTarget)..'; oLauncher position='..repru(oLauncher:GetPosition())..'; will draw in blue if think shot will hit, red if think shot blocked. dist to target='..M28Utilities.GetDistanceBetweenPositions(oLauncher:GetPosition(), tTarget)..'; launcher range='..oLauncher[M28UnitInfo.refiManualRange]..'; bShotBlocked='..tostring(bShotBlocked))
                            local iColour = 1
                            if bShotBlocked then iColour = 2 end
                            M28Utilities.DrawLocation(tTarget, nil, iColour)
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Have a nuke target, tTarget='..repru(tTarget)..'; have we not recently nuked this location='..tostring(HaventRecentlyNukedLocation(tTarget))..'; iTotalWaitCount='..iTotalWaitCount) end
                        if iTotalWaitCount >= 1 then
                            if not(HaventRecentlyNukedLocation(tTarget)) then --, true, iTotalWaitCount * 0.1 + 2)) then
                                --Presumably the target we chose as the best target is no longer appropriate because another nuke has just nuked it
                                if bDebugMessages == true then LOG(sFunctionRef..': Will wait 1 second then try getting a target again since we are about to nuke a location that we just nuked') end
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                WaitSeconds(1)
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                                tTarget = nil
                                ForkThread(ConsiderLaunchingMissile, oLauncher, oOptionalWeapon)
                            end
                        end
                        if tTarget then
                            if bDebugMessages == true then
                                M28Utilities.DrawCircleAtTarget({ tTarget[1], tTarget[2], tTarget[3] }, 2, 200, iAOE)
                            end
                            M28Orders.IssueTrackedNukeMissileLaunch(oLauncher, tTarget, 2, false, 'Nuke', false)
                            --[[M28Orders.IssueTrackedClearCommands(oLauncher)
                            IssueNuke({oLauncher}, tTarget)
                            oLauncher[reftActiveNukeTarget] = {tTarget[1], tTarget[2], tTarget[3]}
                            --Unpause incase we paused previously
                            if oLauncher[refbPausedAsNoTargets] then
                                oLauncher[refbPausedAsNoTargets] = false
                                if M28UnitInfo.GetMissileCount(oLauncher) <= 1 then
                                    oLauncher:SetAutoMode(true)
                                end
                                oLauncher:SetPaused(false)
                            end
                            if not(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]) then M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations] = {} end

                            M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations][math.floor(GetGameTimeSeconds())] = tTarget--]]
                            if bDebugMessages == true then LOG(sFunctionRef..': Launching nuke at tTarget='..repru(tTarget)..'; M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]='..repru(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations])..'; Time of game='..GetGameTimeSeconds()) end
                            --Send a voice taunt if havent in last 10m and we expect to do significant damage
                            if iBestTargetValue >= 25000 then
                                ForkThread(M28Chat.SendGloatingMessage, aiBrain, 20, 600)
                            end
                        end
                    end
                else
                    --Disable autobuild and pause
                    if not(oLauncher[refbPausedAsNoTargets]) and not(EntityCategoryContains(categories.EXPERIMENTAL, oLauncher.UnitId)) then
                        --Dont pause if we have loads of resources
                        if M28Conditions.HaveLowPower(iTeam) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 400 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.8 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 30 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 25 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.99))) then
                            oLauncher[refbPausedAsNoTargets] = true
                            oLauncher:SetAutoMode(false)
                            oLauncher:SetPaused(true)
                            if oLauncher.UnitId == 'xsb2401' then M28Utilities.ErrorHandler('Pausing Yolona') end
                            if bDebugMessages == true then LOG(sFunctionRef..': Pausing unit '..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..' as have no targets') end
                        end
                    end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitSeconds(10)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    if bDebugMessages == true then LOG(sFunctionRef..': Have waited 10s, will now reconsider launching the missile, time='..GetGameTimeSeconds()) end
                    ForkThread(ConsiderLaunchingMissile, oLauncher, oOptionalWeapon)
                end
            end
            --Already have an else error handler above so dont need below
        --else M28Utilities.ErrorHandler('Unrecognised launcher type, UnitID='..(oLauncher.UnitId or 'nil')..'; wont consider launching a missile')
        end
        --oLauncher[refbActiveMissileChecker] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function IsSMDBlockingTarget(aiBrain, tTarget, tSMLPosition, iIgnoreSMDCreatedThisManySecondsAgo, iSMDRangeAdjust, bOptionalReturnTableOfBlockingSMD)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsSMDBlockingTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bEnemySMDInRange = false
    local iSMLToTarget = M28Utilities.GetDistanceBetweenPositions(tTarget, tSMLPosition)
    local iAngleSMLToTarget = M28Utilities.GetAngleFromAToB(tSMLPosition, tTarget)
    local iTargetToSMD

    local iSMLToSMD
    local iSMDRange
    local iAngleToSMD
    local bSMDInRangeOfMissile

    if bDebugMessages == true then LOG(sFunctionRef..': Considering tTarget='..repru(tTarget)..'; iIgnoreSMDCreatedThisManySecondsAgo='..(iIgnoreSMDCreatedThisManySecondsAgo or 1)..'; Current game time='..GetGameTimeSeconds()) end
    local iTeam = aiBrain.M28Team
    local tBlockingSMD

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemySMD]) == false then
        local iBuildRateMod = 1
        for iSMD, oSMD in M28Team.tTeamData[iTeam][M28Team.reftEnemySMD] do
            if M28UnitInfo.IsUnitValid(oSMD) then
                if iIgnoreSMDCreatedThisManySecondsAgo then iBuildRateMod = (oSMD:GetAIBrain()[M28Economy.refiBrainBuildRateMultiplier] or 1) end
                if bDebugMessages == true then LOG(sFunctionRef..': Cur time less time of last check or -10='..GetGameTimeSeconds() - (oSMD[M28UnitInfo.refiTimeOfLastCheck] or (GetGameTimeSeconds() - 10))..'; iIgnoreSMDCreatedThisManySecondsAgo='..(iIgnoreSMDCreatedThisManySecondsAgo or 'nil')..'; iBuildRateMod='..iBuildRateMod) end
                if GetGameTimeSeconds() - (oSMD[M28UnitInfo.refiTimeOfLastCheck] or (GetGameTimeSeconds() - 10)) > (iIgnoreSMDCreatedThisManySecondsAgo or 0) / iBuildRateMod then

                    bSMDInRangeOfMissile = false
                    iSMDRange = (oSMD:GetBlueprint().Weapon[1].MaxRadius or 90) + 1 + (iSMDRangeAdjust or 0)
                    iTargetToSMD = M28Utilities.GetDistanceBetweenPositions(tTarget, oSMD:GetPosition())

                    iSMLToSMD = M28Utilities.GetDistanceBetweenPositions(oSMD:GetPosition(), tSMLPosition)
                    iAngleToSMD = M28Utilities.GetAngleFromAToB(tSMLPosition, oSMD:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': oSMD='..oSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSMD)..'; iTargetToSMD='..iTargetToSMD..'; iSMLToSMD='..iSMLToSMD..'; iSMLToTarget='..iSMLToTarget..'; iSMDRange='..iSMDRange..'; oSMD[M27UnitInfo.refiTimeOfLastCheck]='..(oSMD[M28UnitInfo.refiTimeOfLastCheck] or 'nil')..'; Distance from target to oSMD='..M28Utilities.GetDistanceBetweenPositions(tTarget, oSMD:GetPosition())..'; iSMDRange='..iSMDRange..'; iAngleToSMD='..iAngleToSMD..'; iAngleSMLToTarget='..iAngleSMLToTarget..'; SMD position='..repru(oSMD:GetPosition())..'; tSMLPosition='..repru(tSMLPosition)..'; TargetPos='..repru(tTarget)..'; iAngleFromAToB - iAngleFromAToC='..(iAngleSMLToTarget - iAngleToSMD)..'; ConvertAngleToRadians(iAngleFromAToB - iAngleFromAToC)='..M28Utilities.ConvertAngleToRadians(iAngleSMLToTarget - iAngleToSMD)..'; math.tan(math.abs(ConvertAngleToRadians(iAngleFromAToB - iAngleFromAToC)))='..math.tan(math.abs(M28Utilities.ConvertAngleToRadians(iAngleSMLToTarget - iAngleToSMD)))..'; iDistFromAToC='..iSMLToSMD..'; Tan result times this distance='..iSMLToSMD*math.tan(math.abs(M28Utilities.ConvertAngleToRadians(iAngleSMLToTarget - iAngleToSMD)))) end

                    bSMDInRangeOfMissile = M28Utilities.IsLineFromAToBInRangeOfCircleAtC(iSMLToTarget, iSMLToSMD, iTargetToSMD, iAngleSMLToTarget, iAngleToSMD, iSMDRange)

                    if bSMDInRangeOfMissile then
                        if bDebugMessages == true then LOG(sFunctionRef..': SMD is in range and was built a while ago') end
                        bEnemySMDInRange = true
                        if not(bOptionalReturnTableOfBlockingSMD) then
                            break
                        else
                            if not(tBlockingSMD) then tBlockingSMD = {} end
                            table.insert(tBlockingSMD, oSMD)
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding SMD to table of blocking SMD') end
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': SMD is not blocking the target')
                    end

                elseif bDebugMessages == true then LOG(sFunctionRef..': SMD was only recently built, time we think the SMD was active='..GetGameTimeSeconds() - (oSMD[M28UnitInfo.refiTimeOfLastCheck] or (GetGameTimeSeconds() - 10)))
                end
            end
        end
    elseif bDebugMessages == true then LOG(sFunctionRef..': No enemy SMD detected')
    end
    if bDebugMessages == true then LOG(sFunctionRef..': bEnemySMDInRange='..tostring(bEnemySMDInRange)..'; Is table of blocking SMD empty='..tostring(M28Utilities.IsTableEmpty(tBlockingSMD))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bOptionalReturnTableOfBlockingSMD then
        return tBlockingSMD
    else
        return bEnemySMDInRange
    end
end

function GetHighestNukeTargetValue(tLZOrWZData, tLZOrWZTeamData, iTeam)
    --Refresh list if havent calcualted before or SMD has been refreshed; returns highest value target
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        if aiBrain then
            local iBestValue = 0
            local iCurValue

            function GetZoneValue(iEnemyStructureMass, iEnemyCombatThreat)
                return iEnemyStructureMass + iEnemyCombatThreat * 0.25
            end
            local tSMLPosition = tLZOrWZData[M28Map.subrefMidpoint]
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones]) or M28Team.tTeamData[iTeam][M28Team.refbEnemySMDDiedSinceLastNukeCheck] then
                --Do full calculation
                tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones] = {}
                --Make sure we have recorded pathing in a straight line for this zone (will only run if table is empty)
                M28Air.RecordOtherLandAndWaterZonesByDistance(tLZOrWZData, tLZOrWZData[M28Map.subrefMidpoint])
                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) then
                    M28Utilities.ErrorHandler('No other zones found')
                else
                    for iEntry, tSubtable in tLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                        local tAltLZOrWZData
                        local tAltLZOrWZTeamData
                        local sMidpointRef
                        local sCombatThreatRef
                        local iCurPlateauOrPond
                        local iCurLZOrWZRef = tSubtable[M28Map.subrefiLandOrWaterZoneRef]
                        if tSubtable[M28Map.subrefbIsWaterZone] then
                            sMidpointRef = M28Map.subrefMidpoint
                            sCombatThreatRef = M28Map.subrefTThreatEnemyCombatTotal
                            tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurLZOrWZRef]][M28Map.subrefPondWaterZones][iCurLZOrWZRef]
                            iCurPlateauOrPond = 0
                            tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                        else
                            sMidpointRef = M28Map.subrefMidpoint
                            sCombatThreatRef = M28Map.subrefTThreatEnemyCombatTotal
                            iCurPlateauOrPond = tSubtable[M28Map.subrefiPlateauOrPond]
                            tAltLZOrWZData = M28Map.tAllPlateaus[iCurPlateauOrPond][M28Map.subrefPlateauLandZones][iCurLZOrWZRef]
                            tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                        end
                        if not(IsSMDBlockingTarget(aiBrain, tAltLZOrWZData[sMidpointRef], tSMLPosition, 0, 0)) then
                            --Have a valid target
                            table.insert(tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones], {iCurPlateauOrPond, iCurLZOrWZRef })
                            iCurValue = GetZoneValue(tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass], tAltLZOrWZTeamData[sCombatThreatRef])
                            if iCurValue > iBestValue then
                                iBestValue = iCurValue
                            end
                        end
                    end
                end
            elseif M28Team.tTeamData[iTeam][M28Team.refbEnemySMDBuiltSinceLastNukeCheck] then
                --Check existing values for if still valid
                local iExistingEntries = table.getn(tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones])
                for iEntry = iExistingEntries, 1, -1 do
                    local tAltLZOrWZData
                    local tAltLZOrWZTeamData
                    local sMidpointRef
                    local sCombatThreatRef
                    local iCurPlateauOrPond = tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones][iEntry][1]
                    local iCurLZOrWZRef = tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones][iEntry][2]

                    if iCurPlateauOrPond == 0 then
                        sMidpointRef = M28Map.subrefMidpoint
                        sCombatThreatRef = M28Map.subrefTThreatEnemyCombatTotal
                        tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurLZOrWZRef]][M28Map.subrefPondWaterZones][iCurLZOrWZRef]
                        tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                    else
                        sMidpointRef = M28Map.subrefMidpoint
                        sCombatThreatRef = M28Map.subrefTThreatEnemyCombatTotal
                        tAltLZOrWZData = M28Map.tAllPlateaus[iCurPlateauOrPond][M28Map.subrefPlateauLandZones][iCurLZOrWZRef]
                        tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                    end
                    if IsSMDBlockingTarget(aiBrain, tAltLZOrWZData[sMidpointRef], tSMLPosition, 0, 0) then
                        --No longer have a valid target
                        table.remove(tLZOrWZTeamData[M28Map.subreftiPotentialNukeTargetZones], iEntry)
                    else
                        iCurValue = GetZoneValue(tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass], tAltLZOrWZTeamData[sCombatThreatRef])
                        if iCurValue > iBestValue then
                            iBestValue = iCurValue
                        end
                    end
                end
            end
            return iBestValue
        else
            M28Utilities.ErrorHandler('No alive M28 brain')
            return 0
        end
    else
        M28Utilities.ErrorHandler('No active M28 brains')
        return 0
    end
end

function RecheckForArtiTargetSoon(oArti)
    WaitSeconds(10)
    if M28UnitInfo.IsUnitValid(oArti) then
        M28UnitInfo.EnableUnitWeapon(oArti)
        GetT3ArtiTarget(oArti, false)
    end
end

function GetT3ArtiTarget(oArti, bCalledFromSalvoSize)
    --Gets oArti to fire an attack on the ground for where it thinks it will deal the most damage, works for t3 and experimental arti
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetT3ArtiTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bCalledFromSalvoSize then oArti[refbSalvoDelayActive] = false end
    if not(oArti[refbSalvoDelayActive]) then
        local iPlateau, iLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oArti:GetPosition())
        local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
        local aiBrain = oArti:GetAIBrain()
        local iTeam = aiBrain.M28Team
        local iArtiFacingAngle = M28UnitInfo.GetUnitFacingAngle(oArti)

        local iAOE, iDamage, iMinRange, iMaxRange, iSalvoSize, iSalvoIndividualDelay = M28UnitInfo.GetLauncherAOEStrikeDamageMinAndMaxRange(oArti)
        --Wait if salvo size >1
        local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
        if iSalvoSize > 1 and not(bCalledFromSalvoSize) and oArti[M28UnitInfo.refiLastWeaponEvent] then
            --E.g. scathis - dont want to change targets after firing a single shot - we have fired the scathis before, and this has presumably been called from the onweaponevent trigger

            local iTimeToWait = 4
            if (iSalvoIndividualDelay or 0) > 0 then iTimeToWait = iSalvoSize * iSalvoIndividualDelay + 0.1 end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(iTimeToWait)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if M28UnitInfo.IsUnitValid(oArti) then
                oArti[refbSalvoDelayActive] = true
                ForkThread(GetT3ArtiTarget, oArti, true)
            end
        else
            if (iMaxRange or 0) == 0 or (iAOE or 0) == 0 then M28Utilities.ErrorHandler('Arti '..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)..' has no range or no aoe')
            end

            --First make sure pathing is setup
            if M28Utilities.IsTableEmpty(oArti[reftiPlateauAndZonesInRange]) then
                oArti[reftiPlateauAndZonesInRange] = {}
                M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint])
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) then
                    M28Utilities.ErrorHandler('No other zones located for oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti))
                else
                    local iPlateauOrZero
                    if bDebugMessages == true then LOG(sFunctionRef..': About to search through all zones for targets for oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)..'; iMinRange='..(iMinRange or 'nil')..'; iMaxRange='..(iMaxRange or 'nil')) end
                    for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                        --Stop searching once got past arti max range
                        if tSubtable[M28Map.subrefiDistance] > iMaxRange then
                            if bDebugMessages == true then LOG(sFunctionRef..': Are outside the max range so wil stop searching') end
                            break
                        end
                        --If outside min range then include
                        if tSubtable[M28Map.subrefiDistance] > iMinRange then
                            --Add to potential zone table
                            local tAltLZOrWZData
                            local tAltLZOrWZTeamData
                            if tSubtable[M28Map.subrefbIsWaterZone] then
                                iPlateauOrZero = 0

                                tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[tSubtable[M28Map.subrefiLandOrWaterZoneRef]]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                            else
                                iPlateauOrZero = tSubtable[M28Map.subrefiPlateauOrPond]
                                tAltLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Recording plateau '..iPlateauOrZero..' zone '..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..' as being within max range') end
                            table.insert(oArti[reftiPlateauAndZonesInRange], {iPlateauOrZero, tSubtable[M28Map.subrefiLandOrWaterZoneRef], M28Utilities.GetDistanceBetweenPositions(tAltLZOrWZData[M28Map.subrefMidpoint], tAltLZOrWZTeamData[M28Map.reftClosestFriendlyBase]), M28Utilities.GetAngleFromAToB(oArti:GetPosition(), tAltLZOrWZData[M28Map.subrefMidpoint])})
                        end
                    end
                end
            end

            --Cycle through each zone that may be in range and pick the best one
            local iCurValue
            local iBestValue = 0
            local iSecondBestValue = 0
            local iBestPlateauOrZero, iBestLZOrWZ, iSecondBestPlateauOrZero, iSecondBestLZOrWZ, iBestAngleFactor, iSecondBestAngleFactor
            local iCurMobileThreat
            local iCurAAThreat
            local iShotMissFactor
            local iArtiAngleFactor
            for iEntry, tPlateauZoneAndDist in oArti[reftiPlateauAndZonesInRange] do
                local tAltLZOrWZData
                local tAltLZOrWZTeamData
                if tPlateauZoneAndDist[1] == 0 then
                    tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[tPlateauZoneAndDist[2]]][M28Map.subrefPondWaterZones][tPlateauZoneAndDist[2]]
                    tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                else
                    tAltLZOrWZData = M28Map.tAllPlateaus[tPlateauZoneAndDist[1]][M28Map.subrefPlateauLandZones][tPlateauZoneAndDist[2]]
                    tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                end
                iCurMobileThreat = ((tAltLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) + (tAltLZOrWZTeamData[M28Map.subrefWZThreatEnemySurface] or 0))
                --Get more precise calculation - i.e. the threat calculation above reduces threat for health, meaning if we attack say a fatboy, its threat decreases as its shield decreases, making it likely we switch targets when its shield is about to be destroyed; however dont bother with low threat values
                if iCurMobileThreat >= 1000 then
                    iCurMobileThreat = M28UnitInfo.GetCombatThreatRating(EntityCategoryFilterDown(categories.MOBILE, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits]), true, true)
                end
                iCurValue = tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] + iCurMobileThreat * 0.2
                if bDebugMessages == true then LOG(sFunctionRef..': Considering plateau and zone '..tPlateauZoneAndDist[1]..'Z'..tPlateauZoneAndDist[2]..'; tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]='..(tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 'nil')..'; iCurMobileThreat='..iCurMobileThreat) end
                --Add extra mobile threat if enemy has long ranged units and is close to our nearest base
                if iCurMobileThreat >= 4000 and tPlateauZoneAndDist[3] <= 300 and M28Utilities.IsTableEmpty(tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) == false then
                    local iLongRangeThreat = 0
                    for iRange, iThreat in tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] do
                        if iRange >= 65 then --i.e. just above a megaliths range
                            iLongRangeThreat = iLongRangeThreat + iThreat
                        end
                    end
                    if iLongRangeThreat >= 1500 then
                        iCurValue = iCurValue + iCurMobileThreat * 0.8 --want based on mobile threat so less likely to run into issue for units like fatboy where threat decreases as shield decreases
                    end
                end
                --Add extra mobile threat if enemy has large mobile MAA
                iCurAAThreat = (tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) + (tAltLZOrWZTeamData[M28Map.subrefWZThreatEnemyAA] or 0)
                if iCurAAThreat >= 3000 then
                    local tEnemyMobileAA = EntityCategoryFilterDown(categories.MOBILE, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits])
                    if M28Utilities.IsTableEmpty( tEnemyMobileAA) == false then
                        iCurValue = iCurValue + iCurAAThreat * 0.2 + M28UnitInfo.GetCombatThreatRating(tEnemyMobileAA, true, true) * 0.8
                    else
                        iCurValue = iCurValue + iCurAAThreat * 0.2
                    end
                else
                    iCurValue = iCurValue + iCurAAThreat * 0.2
                end

                --Add extra threat if enemy has t2 arti near the nearest friendly base (relevant for team games, since 1v1 this hsould be inside the minimum rnage)
                if tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] >= 4000 and tPlateauZoneAndDist[3] <= 200 then
                    local tEnemyT2ArtiAndMissileShips = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryTML + M28UnitInfo.refCategoryMissileShip, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits])
                    if M28Utilities.IsTableEmpty(tEnemyT2ArtiAndMissileShips) == false then
                        iCurValue = iCurValue + tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Considering plateau '..tPlateauZoneAndDist[1]..' and zone '..tPlateauZoneAndDist[2]..'; Dist='..tPlateauZoneAndDist[3]..'; iCurValue before factoring in ineffective shot count='..iCurValue..'; tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount]='..(tAltLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 'nil')..'; iCurAAThreat='..iCurAAThreat..'; iCurMobileThreat='..iCurMobileThreat..'; tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]='..tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]..'; iSecondBestValue='..iSecondBestValue) end

                --Adjust value for number of times shots have hit
                if iCurValue > iSecondBestValue then
                    --Adjust cur value for shot missed percentage
                    iShotMissFactor = GetArtiValueFactorForShotFailures((tAltLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 0))
                    --Adjust cur value for angle to target
                    iArtiAngleFactor = GetArtiValueFactorForFacingDifference(iArtiFacingAngle, tPlateauZoneAndDist[4])

                    iCurValue = iCurValue * iShotMissFactor * iArtiAngleFactor

                    --Record as best/second best
                    if iCurValue > iBestValue then
                        iSecondBestValue = iBestValue
                        iSecondBestPlateauOrZero = iBestPlateauOrZero
                        iSecondBestLZOrWZ = iBestLZOrWZ
                        iSecondBestAngleFactor = iBestAngleFactor
                        iBestValue = iCurValue
                        iBestPlateauOrZero = tPlateauZoneAndDist[1]
                        iBestLZOrWZ = tPlateauZoneAndDist[2]
                        iBestAngleFactor = iArtiAngleFactor
                    elseif iCurValue > iSecondBestValue then
                        iSecondBestValue = iCurValue
                        iSecondBestPlateauOrZero = tPlateauZoneAndDist[1]
                        iSecondBestLZOrWZ = tPlateauZoneAndDist[2]
                        iSecondBestAngleFactor = iArtiAngleFactor
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iCurValue after adj='..iCurValue..'; iShotMissFactor='..iShotMissFactor..'; iArtiAngleFactor='..iArtiAngleFactor) end
                end
            end

            --Now have the best 2 zones on an aggregate basis, get the best location for the arti target within these zones
            local iFriendlyUnitReductionFactor = 2
            local iFriendlyUnitAOEFactor = 2
            local iSizeAdjust = 0.25
            local iMultipleShotMod = 1
            local iMobileValueFactorInner = 0.4
            local iShieldReductionFactor = 0.25 --i.e. amount by which value of target will be reduced if it is under shielding
            --Reduce value of shields against high damage and aoe targets
            if iDamage >= 7500 and iAOE >= 6 then iShieldReductionFactor = math.min(math.max(iShieldReductionFactor, 0.8), iShieldReductionFactor * 1.5) end

            function GetBestUnitTargetAndValueInZone(iPlateauOrZero, iLZOrWZ, iAngleFactor)
                local tAltLZOrWZData
                local tAltLZOrWZTeamData
                local iCurValue
                local iBestValue = 0
                local oBestUnitTarget
                if iPlateauOrZero == 0 then
                    tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLZOrWZ]][M28Map.subrefPondWaterZones][iLZOrWZ]
                    tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                else
                    tAltLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLZOrWZ]
                    tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering best target in plateau '..iPlateauOrZero..'; Zone '..iLZOrWZ..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits]))) end
                if M28Utilities.IsTableEmpty(tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    local tPriorityUnits = EntityCategoryFilterDown(categories.EXPERIMENTAL + categories.TECH3 + M28UnitInfo.refCategoryStructure * categories.TECH2 + M28UnitInfo.refCategoryCruiser * categories.TECH2, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits])
                    local iCurDist
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of priority units empty='..tostring(M28Utilities.IsTableEmpty(tPriorityUnits))) end
                    if M28Utilities.IsTableEmpty(tPriorityUnits) then tPriorityUnits = tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits] end
                    --Filter to the top 25 units in the zone by mass cost for performance reasons
                    local tiBaseValueOfPriorityUnits = {}
                    local iBaseValue
                    for iUnit, oUnit in tPriorityUnits do
                        --Double check are in range
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oArti:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering targeting oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..iCurDist..'; iMaxRange='..iMaxRange..'; iMinRange='..iMinRange..'; iAOE='..(iAOE or 'nil')..'; iDamage='..(iDamage or 'nil')..'; iFriendlyUnitReductionFactor='..(iFriendlyUnitReductionFactor or 'nil')..'; iFriendlyUnitAOEFactor='..(iFriendlyUnitAOEFactor or 'nil')..'; iSizeAdjust='..(iSizeAdjust or 'nil')..'; iMultipleShotMod='..(iMultipleShotMod or 'nil')..'; iMobileValueFactorInner='..(iMobileValueFactorInner or 'nil')..'; iShieldReductionFactor='..(iShieldReductionFactor or 'nil')) end
                            if iCurDist <= iMaxRange and iCurDist >= iMinRange then
                                iBaseValue = (oUnit:GetBlueprint().Economy.BuildCostMass or 0) * oUnit:GetFractionComplete()
                                if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) and oUnit:GetFractionComplete() >= 0.98 then iBaseValue = iBaseValue * iMobileValueFactorInner end
                                tiBaseValueOfPriorityUnits[iUnit] = iBaseValue
                            end
                        end
                    end
                    local iCurCount = 0
                    if M28Utilities.IsTableEmpty(tiBaseValueOfPriorityUnits) == false then
                        for iEntry, iValue in M28Utilities.SortTableByValue(tiBaseValueOfPriorityUnits, true) do
                            iCurCount = iCurCount + 1
                            if iCurCount > 25 then break end
                            local oUnit = tPriorityUnits[iEntry]
                            --GetDamageFromBomb(aiBrain, tBaseLocation,     iAOE,   iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies)
                            iCurValue = M28Logic.GetDamageFromBomb(aiBrain, oUnit:GetPosition(), iAOE, iDamage, iFriendlyUnitReductionFactor,       iFriendlyUnitAOEFactor,     false,                      iSizeAdjust,        iMultipleShotMod,                   iMobileValueFactorInner,                true,                   iShieldReductionFactor,         true)
                            if bDebugMessages == true then LOG(sFunctionRef..': Damage from bomb if we target it at unit='..iCurValue..'; iBestValue='..(iBestValue or 'nil')) end
                            local iMinValue = 0
                            --Only set the min value if we dont have a negative value from the target (e.g. happens if targeting our own base or capture target)
                            if (iCurValue or 0) >= 0 and M28UnitInfo.IsUnitValid(oUnit) and oUnit.GetFractionComplete and (oUnit:GetFractionComplete() < 1 or EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId)) then
                                --redundancy for buildings and under construction units
                                iMinValue = (M28UnitInfo.GetCombatThreatRating({ oUnit }, true, true) or 0) * oUnit:GetFractionComplete()
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering increasing cur value to min basic value based on the unit target, iCurValue='..(iCurValue or 'nil')..'; iBestValue='..(iBestValue or 'nil')..'; iMinValue='..(iMinValue or 'nil')) end
                                iCurValue = math.max((iCurValue or 0), iMinValue)
                            end
                            if iCurValue > iBestValue then
                                iBestValue = iCurValue
                                oBestUnitTarget = oUnit
                                if bDebugMessages == true then LOG(sFunctionRef..': Setting the best unit target to '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iBestValue='..iBestValue) end
                            end
                        end
                    end
                end
                return oBestUnitTarget, iBestValue
            end

            local oBestTarget, iBestTargetValue = GetBestUnitTargetAndValueInZone(iBestPlateauOrZero, iBestLZOrWZ)
            if not(iBestAngleFactor) then iBestAngleFactor = GetArtiValueFactorForFacingDifference(0,180) end
            if not(iBestTargetValue) then iBestTargetValue = 0 end
            iBestTargetValue = iBestAngleFactor * iBestTargetValue
            if bDebugMessages == true then LOG(sFunctionRef..': iBestPlateauOrZero='..(iBestPlateauOrZero or 'nil')..'; iBestLZOrWZ='..(iBestLZOrWZ or 'nil')..'; iBestTargetValue='..(iBestTargetValue or 'nil')..'; oBestTarget='..(oBestTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBestTarget) or 'nil')..'; iBestAngleFactor='..(iBestAngleFactor or 'nil')) end
            if iSecondBestLZOrWZ then
                local oAltTarget, iAltTargetValue = GetBestUnitTargetAndValueInZone(iSecondBestPlateauOrZero, iSecondBestLZOrWZ)
                if bDebugMessages == true then LOG(sFunctionRef..': iSecondBestPlateauOrZero='..(iSecondBestPlateauOrZero or 'nil')..'; iSecondBestLZOrWZ='..(iSecondBestLZOrWZ or 'nil')..'; iAltTargetValue='..(iAltTargetValue or 'nil')..'; oAltTarget='..(oAltTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oAltTarget) or 'nil')..'; iBestTargetValue before considering this='..(iBestTargetValue or 'nil')..'; iSecondBestAngleFactor='..(iSecondBestAngleFactor or 'nil')) end
                if not(iSecondBestAngleFactor) then iSecondBestAngleFactor = GetArtiValueFactorForFacingDifference(0,180) end
                if not(iAltTargetValue) then iAltTargetValue = 0
                elseif oAltTarget.GetPosition then
                    --Get value from targeting the best target in this alt zone
                    --GetDamageFromBomb(aiBrain, tBaseLocation,             iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory)
                    iAltTargetValue  = M28Logic.GetDamageFromBomb(aiBrain, oAltTarget:GetPosition(), iAOE, iDamage, iFriendlyUnitReductionFactor,       iFriendlyUnitAOEFactor,     false,                      iSizeAdjust,        iMultipleShotMod,                   iMobileValueFactorInner,                true,                   iShieldReductionFactor,         true)
                end
                iAltTargetValue = iAltTargetValue * iSecondBestAngleFactor
                if bDebugMessages == true then LOG(sFunctionRef..': iAltTargetValue='..iAltTargetValue..'; iBestTargetValue before reflecting this='..iBestTargetValue) end
                if iAltTargetValue > iBestTargetValue then
                    oBestTarget = oAltTarget
                    iBestTargetValue = iAltTargetValue
                end
            end
            if not(oBestTarget) then
                M28Utilities.ErrorHandler('No target found for T3 arti, will fire at closest enemy base instead if we can hit it', true)
                local bGivenAltTarget = false
                local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                local iDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], oArti:GetPosition())
                if iDistToEnemyBase <= iMaxRange and iDistToEnemyBase >= iMinRange then
                    --GetDamageFromBomb(aiBrain, tBaseLocation,                             iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory)
                    local iDamage = M28Logic.GetDamageFromBomb(aiBrain, tLZTeamData[M28Map.reftClosestEnemyBase], iAOE, iDamage, iFriendlyUnitReductionFactor, iFriendlyUnitAOEFactor,          false,                          iSizeAdjust,        iMultipleShotMod,               iMobileValueFactorInner,                    true,               iShieldReductionFactor,         true)
                    if iDamage >= 0 then --should mean dont have much in way of friendly forces there
                        --Check there are enemy units nearby
                        local bNearbyEnemyUnits = false
                        local tNearbyUnits = GetUnitsInRect(M28Utilities.GetRectAroundLocation(tLZTeamData[M28Map.reftClosestEnemyBase], iAOE * 1.3))
                        if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                            for iUnit, oUnit in tNearbyUnits do
                                if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategoryStructure - categories.TECH1 * categories.MOBILE, oUnit.UnitId) then
                                    if IsEnemy(oUnit:GetAIBrain():GetArmyIndex(), aiBrain:GetArmyIndex()) then
                                        bNearbyEnemyUnits = true
                                        break
                                    end
                                end
                            end
                        end
                        if bNearbyEnemyUnits then
                            iBestTargetValue = iDamage
                            M28Orders.IssueTrackedGroundAttack(oArti, tLZTeamData[M28Map.reftClosestEnemyBase], 1, false, 'ArtiEB'..'ALZ'..iLandZone, false)
                            bGivenAltTarget = true
                        end
                    end
                end
                if not(bGivenAltTarget) then M28Orders.IssueTrackedClearCommands(oArti) end
            else
                local tActualTarget
                local tLeadingTarget
                if bDebugMessages == true then LOG(sFunctionRef..': Considering oBestTarget='..oBestTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestTarget)..'; Does this contain mobile='..tostring(EntityCategoryContains(categories.MOBILE, oBestTarget.UnitId))..'; Fraction complete='..oBestTarget:GetFractionComplete()..'; Is moving unit state='..tostring(oBestTarget:IsUnitState('Moving'))..'; Unit state='..M28UnitInfo.GetUnitState(oBestTarget)) end
                if EntityCategoryContains(categories.MOBILE, oBestTarget.UnitId) and oBestTarget:GetFractionComplete() == 1 and oBestTarget:IsUnitState('Moving') then
                    --If best target is mobile and moving, then consider a leading shot instead
                    local oBP = oArti:GetBlueprint()
                    local iWeaponVelocity
                    if oBP.Weapon then
                        for iCurWeapon, oCurWeapon in oBP.Weapon do
                            if (oCurWeapon.DamageRadius or 0) > 0 and (oCurWeapon.MaxRadius or 0) >= iMaxRange then
                                iWeaponVelocity = oCurWeapon.MuzzleVelocity
                                break
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iWeaponVelocity='..(iWeaponVelocity or 'nil')) end
                    if (iWeaponVelocity or 0) > 0 then
                        local iDistToEnemy = M28Utilities.GetDistanceBetweenPositions(oBestTarget:GetPosition(), oArti:GetPosition())
                        local iTimeToImpact = 0.5 + iDistToEnemy * 1.75 / iWeaponVelocity
                        local iCurFacingDirection = M28UnitInfo.GetUnitFacingAngle(oBestTarget)
                        local iDistToLead = iTimeToImpact * (oBestTarget:GetBlueprint().Physics.MaxSpeed or 0)
                        tLeadingTarget = M28Utilities.MoveInDirection(oBestTarget:GetPosition(), iCurFacingDirection, iDistToLead, true, false, M28Map.bIsCampaignMap)
                        if bDebugMessages == true then LOG(sFunctionRef..': tLeadingTarget='..repru(tLeadingTarget)..'; Dist to best arti='..M28Utilities.GetDistanceBetweenPositions(tLeadingTarget, oArti:GetPosition())..'; Min range='..iMinRange) end
                        if not(tLeadingTarget and M28Utilities.GetDistanceBetweenPositions(tLeadingTarget, oArti:GetPosition()) >= iMinRange) then
                            tLeadingTarget = nil
                        end
                    end
                end
                if tLeadingTarget then
                    if bDebugMessages == true then LOG(sFunctionRef..': Changing Arti target for oBestTarget='..oBestTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestTarget)..' to try and lead target, oBestTarget position='..repru(oBestTarget:GetPosition())..'; tLeadingTarget='..repru(tLeadingTarget)..'; Time='..GetGameTimeSeconds()) end
                    tActualTarget = tLeadingTarget
                else
                    tActualTarget = M28Logic.GetBestAOETarget(aiBrain, oBestTarget:GetPosition(), iAOE, iDamage, false, nil, nil, nil, iFriendlyUnitReductionFactor, iFriendlyUnitAOEFactor, nil, iMobileValueFactorInner, iShieldReductionFactor)
                end



                --Double check are still in range
                local iTargetDist = M28Utilities.GetDistanceBetweenPositions(tActualTarget, oArti:GetPosition())
                if bDebugMessages == true then LOG(sFunctionRef..': tActualTarget='..repru(tActualTarget)..'; iTargetDist='..iTargetDist..'; iBestTargetValue='..(iBestTargetValue or 'nil')) end
                if iTargetDist > iMaxRange or iTargetDist < iMinRange then
                    tActualTarget = oBestTarget:GetPosition()
                end

                if M28Map.bIsCampaignMap and (iBestTargetValue or 0) < 0 then
                    --Disable weapon
                    M28UnitInfo.DisableUnitWeapon(oArti)
                    if bDebugMessages == true then LOG(sFunctionRef..': Disabling Arti weapon, oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)) end
                    ForkThread(RecheckForArtiTargetSoon, oArti)
                else

                    --Issue attack order
                    M28Orders.IssueTrackedGroundAttack(oArti, tActualTarget, 1, false, 'ArtiGF'..'ALZ'..iLandZone, false)

                    --Increase shot count
                    local iAltPlateauOrZero, iAltLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tActualTarget)
                    local tAltLZOrWZTeamData
                    if iAltPlateauOrZero == 0 then
                        tAltLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAltLZOrWZ]][M28Map.subrefPondWaterZones][iAltLZOrWZ][M28Map.subrefWZTeamData][iTeam]
                    else
                        tAltLZOrWZTeamData = M28Map.tAllPlateaus[iAltPlateauOrZero][M28Map.subrefPlateauLandZones][iAltLZOrWZ][M28Map.subrefLZTeamData][iTeam]
                    end

                    tAltLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] = (tAltLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 0) + 1
                end
            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetArtiValueFactorForShotFailures(iShotFailedCount)
    --iShotFailedCount: Should be (tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 0)
    local iFactor
    local iInterval = 13
    if iShotFailedCount >= iInterval then
        iFactor = math.max(0.03, 1 - math.floor(iShotFailedCount / iInterval) * iInterval * 0.03)
    else
        --Have failed fewer than 15 shots
        iFactor = 1
    end
    return iFactor
end
function GetArtiValueFactorForFacingDifference(iArtiFacingAngle, iAngleToTarget)
    local iAngleDif = M28Utilities.GetAngleDifference(iArtiFacingAngle, iAngleToTarget)
    if iAngleDif <= 10 then
        return 1
    else
        return 1 - 0.4 * iAngleDif / 180
    end
end

function JustFiredMissile(oLauncher)
    --Wait 1 tick then check if sitll have missile loaded and if so then consider firing another missile
    if EntityCategoryContains(M28UnitInfo.refCategoryTML + M28UnitInfo.refCategorySML, oLauncher.UnitId) then
        WaitTicks(1)
        if M28UnitInfo.IsUnitValid(oLauncher) then
            local iMissiles = 0 --For some reason the count is off by 1, presumably a slight delay between the event being called and the below ammo counts working
            if oLauncher.GetTacticalSiloAmmoCount then iMissiles = iMissiles + oLauncher:GetTacticalSiloAmmoCount() end
            if oLauncher.GetNukeSiloAmmoCount then iMissiles = iMissiles + oLauncher:GetNukeSiloAmmoCount() end
            if iMissiles > 0 then
                ConsiderLaunchingMissile(oLauncher)
            end
            --Track SML launchers who have recently fired
            if M28UnitInfo.IsUnitValid(oLauncher) and oLauncher:GetAIBrain().M28AI then
                if EntityCategoryContains(M28UnitInfo.refCategorySML, oLauncher.UnitId) then
                    local iTeam = oLauncher:GetAIBrain().M28Team
                    local bAddToTable = true
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers]) then M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers] = {}
                    else
                        for iRecordedLauncher, oRecordedLauncher in M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers] do
                            if oRecordedLauncher == oLauncher then
                                bAddToTable = false
                                break
                            end
                        end
                    end
                    if bAddToTable then
                        table.insert(M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers], oLauncher)
                    end
                end
            end

        end
    end
end

function ReserveLocationsForGameEnder(oUnit)
    --Reserve locations to provide shield coverage for oUnit
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReserveLocationsForGameEnder'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(oUnit[reftArtiTemplateRefs]) then --redundancy as shouldve already checked before getting here

        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, gametimeseconds is '..GetGameTimeSeconds()..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; owned by '..oUnit:GetAIBrain().Nickname..' on team '..oUnit:GetAIBrain().M28Team) end

        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
        if iLandZone > 0 then
            local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
            local tiShieldBuildLocationOptions = {}
            local tiShieldLocationCountByOption = {}
            local sBlueprintToBuild = 'xsb4202'
            local iNewBuildingDiameter = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
            local iNewBuildingRadius = iNewBuildingDiameter * 0.5
            local iAdjacencyBuildingRadius = M28UnitInfo.GetBuildingSize(oUnit.UnitId) * 0.5
            local tAdjacencyBuildingPosition = oUnit:GetPosition()

            local iCurZ, iCurX
            local iCornerAdjust = math.min(iNewBuildingDiameter, iAdjacencyBuildingRadius * 2)

            local iCurOptionCount = 0

            if bDebugMessages == true then LOG(sFunctionRef..': tAdjacencyBuildingPosition='..repru(tAdjacencyBuildingPosition)..'; iAdjacencyBuildingRadius='..iAdjacencyBuildingRadius..'; iNewBuildingRadius='..iNewBuildingRadius..'; iCornerAdjust='..iCornerAdjust) end
            local aiBrain = oUnit:GetAIBrain()

            --First go along top and bottom:
            local iCurMod = 0
            local iMostBuildLocations = 0
            local iBestOptionCountRef
            for iZFactor = -1, 1, 2 do
                iCurOptionCount = iCurOptionCount + 1
                tiShieldBuildLocationOptions[iCurOptionCount] = {}
                iCurZ = tAdjacencyBuildingPosition[3] + (iAdjacencyBuildingRadius + iNewBuildingRadius) * iZFactor
                --Include corner positions even though not adjacent
                for iCurX = tAdjacencyBuildingPosition[1] - iCornerAdjust, tAdjacencyBuildingPosition[1] + iCornerAdjust, 1 do
                    if iCurMod > 0 then
                        iCurMod = iCurMod - 1
                    elseif M28Engineer.CanBuildAtLocation(aiBrain, sBlueprintToBuild, { iCurX, 0, iCurZ}, iPlateau, iLandZone, nil, false, true, false, true) then
                        tiShieldLocationCountByOption[iCurOptionCount] = (tiShieldLocationCountByOption[iCurOptionCount] or 0) + 1
                        tiShieldBuildLocationOptions[iCurOptionCount][tiShieldLocationCountByOption[iCurOptionCount]] = {iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ}
                        iCurMod = iCurMod + iNewBuildingDiameter - 1
                        if tiShieldLocationCountByOption[iCurOptionCount] > iMostBuildLocations then
                            iMostBuildLocations = tiShieldLocationCountByOption[iCurOptionCount]
                            iBestOptionCountRef = iCurOptionCount
                            if iMostBuildLocations >= 3 then break end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished considering top or bottom, iZFactor='..(iZFactor or 'nil')..'; iCurOptionCount='..(iCurOptionCount or 'nil')..'; tiShieldBuildLocationOptions[iCurOptionCount]='..repru(tiShieldBuildLocationOptions[iCurOptionCount])..'; tiShieldLocationCountByOption[iCurOptionCount]='..(tiShieldLocationCountByOption[iCurOptionCount] or 'nil')..'; iMostBuildLocations='..iMostBuildLocations) end
                if iMostBuildLocations >= 3 then break end
                iCurMod = 0
            end
            if iMostBuildLocations < 3 then
                --Next go along the sides:
                for iXFactor = -1, 1, 2 do
                    iCurMod = 0
                    iCurOptionCount = iCurOptionCount + 1
                    tiShieldBuildLocationOptions[iCurOptionCount] = {}

                    iCurX = tAdjacencyBuildingPosition[1] + (iAdjacencyBuildingRadius + iNewBuildingRadius) * iXFactor
                    for iCurZ = tAdjacencyBuildingPosition[3] - iCornerAdjust, tAdjacencyBuildingPosition[3] + iCornerAdjust, 1 do
                        if iCurMod > 0 then
                            iCurMod = iCurMod - 1
                        elseif M28Engineer.CanBuildAtLocation(aiBrain, sBlueprintToBuild, { iCurX, 0, iCurZ}, iPlateau, iLandZone, nil, false, true, false, true) then
                            tiShieldLocationCountByOption[iCurOptionCount] = (tiShieldLocationCountByOption[iCurOptionCount] or 0) + 1
                            tiShieldBuildLocationOptions[iCurOptionCount][tiShieldLocationCountByOption[iCurOptionCount]] = {iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ}
                            iCurMod = iCurMod + iNewBuildingDiameter - 1
                            if tiShieldLocationCountByOption[iCurOptionCount] > iMostBuildLocations then
                                iMostBuildLocations = tiShieldLocationCountByOption[iCurOptionCount]
                                iBestOptionCountRef = iCurOptionCount
                                if iMostBuildLocations >= 3 then break end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering left or right side, iXFactor='..(iXFactor or 'nil')..'; iCurOptionCount='..(iCurOptionCount or 'nil')..'; tiShieldBuildLocationOptions[iCurOptionCount]='..repru(tiShieldBuildLocationOptions[iCurOptionCount])..'; tiShieldLocationCountByOption[iCurOptionCount]='..(tiShieldLocationCountByOption[iCurOptionCount] or 'nil')..'; iMostBuildLocations='..iMostBuildLocations) end
                    if iMostBuildLocations >= 3 then break end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iMostBuildLocations='..iMostBuildLocations) end

            if iMostBuildLocations >= 1 then
                --Figure out the best faction engineer that could realistically build the shield by locating the closest factory of each faction type
                local tLZTeamData = tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
                local iRecordedCount = 0
                if not(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) then tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] = {} end
                table.insert(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection], oUnit)
                RecordNearbyFactoryForShieldEngineers(oUnit)

                if bDebugMessages == true then LOG(sFunctionRef..': Can build at least 2 shields close to each other and the gameender, will now pick the best set of shield options, unit position='..repru(oUnit:GetPosition())..'; iBestOptionCountRef='..(iBestOptionCountRef or 'nil')..'; tiShieldBuildLocationOptions for this='..repru(tiShieldBuildLocationOptions[iBestOptionCountRef])) end
                if iBestOptionCountRef then
                    oUnit[reftLocationsForPriorityShield] = {}
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording priority shield locations, tLocations='..repru(tiShieldBuildLocationOptions[iBestOptionCountRef])) end
                    for iLocation, tLocation in tiShieldBuildLocationOptions[iBestOptionCountRef] do
                        iRecordedCount = iRecordedCount + 1
                        table.insert(oUnit[reftLocationsForPriorityShield], {tLocation[1], tLocation[2], tLocation[3]})
                        --Blacklist the location
                        M28Engineer.RecordBlacklistLocation(tLocation, iNewBuildingRadius, 600, oUnit)
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Added shild build location '..repru(tLocation)..' against the game ender and will record blacklist, Will draw shield locations in black')
                            M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tLocation, iNewBuildingRadius), 3, 100)
                        end
                    end
                    --Add other shield locations if there are any and we want more to get to 3
                    if iRecordedCount < 3 then
                        for iShieldOption, tShieldLocations in tiShieldBuildLocationOptions do
                            if not(iShieldOption == iBestOptionCountRef) then
                                for iLocation, tLocation in tShieldLocations do
                                    if M28Engineer.CanBuildAtLocation(aiBrain, sBlueprintToBuild, tLocation, iPlateau, iLandZone, nil, false, true, true, true) then
                                        iRecordedCount = iRecordedCount + 1
                                        table.insert(oUnit[reftLocationsForPriorityShield], {tLocation[1], tLocation[2], tLocation[3]})
                                        --Blacklist the location
                                        M28Engineer.RecordBlacklistLocation(tLocation, iNewBuildingRadius, 600, oUnit)
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef..': Added further shild build location '..repru(tLocation)..' against the game ender and will record blacklist, Will draw shield location')
                                            M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tLocation, iNewBuildingRadius), 4, 100)
                                        end
                                    end
                                end
                            end
                        end
                    end

                    --Update any buildable locaitons around here
                    if iRecordedCount > 0 then
                        for iLocation, tLocation in oUnit[reftLocationsForPriorityShield] do
                            M28Engineer.CheckIfBuildableLocationsNearPositionStillValid(aiBrain, tLocation, true, 5)
                        end
                    end


                    --CLear any engineers with queued orders that will conflict with a shield location
                    local tEngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tEngineersInZone) == false then
                        local bClearEngineer
                        local tEngineersToClear = {}
                        for iEngineer, oEngineer in tEngineersInZone do
                            bClearEngineer = false
                            if M28Utilities.IsTableEmpty(oEngineer[M28Engineer.reftQueuedBuildings]) == false then
                                for iQueueRef, tQueueDetails in oEngineer[M28Engineer.reftQueuedBuildings] do
                                    if tQueueDetails[M28Engineer.subrefBuildingLocation] then
                                        for iReservedLocation, tReservedLocation in oUnit[reftLocationsForPriorityShield] do
                                            if M28Utilities.GetDistanceBetweenPositions(tReservedLocation, tQueueDetails[M28Engineer.subrefBuildingLocation]) - tQueueDetails[M28Engineer.subrefBuildingRadius] < 0 then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have queued building '..tQueueDetails[M28Engineer.subrefBuildingID]..' at location that is within '..M28Utilities.GetDistanceBetweenPositions(tReservedLocation, tQueueDetails[M28Engineer.subrefBuildingLocation])..' of a shield reserved location, with building radius of '..tQueueDetails[M28Engineer.subrefBuildingRadius]..' so will clear the engineer') end
                                                bClearEngineer = true
                                                table.insert(tEngineersToClear, oEngineer)
                                                break
                                            end
                                        end
                                        if bClearEngineer then break end
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of engineers to clear empty='..tostring(M28Utilities.IsTableEmpty(tEngineersToClear))) end
                        if M28Utilities.IsTableEmpty(tEngineersToClear) == false then
                            for iEngineer, oEngineer in tEngineersToClear do
                                M28Orders.IssueTrackedClearCommands(oEngineer)
                            end
                        end
                    end


                end
                --[[for iOption, tLocations in tiShieldBuildLocationOptions do
                    if (tiShieldBuildLocationOptions[iOption] or 0) >= iMostBuildLocations then
                        oUnit[reftLocationsForPriorityShield] = {}
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording priority shield locations, tLocations='..repru(tLocations)..'; tiShieldBuildLocationOptions[iOption]='..repru(tiShieldBuildLocationOptions[iOption])..'; iOption='..(iOption or 'nil')) end
                        for iLocation, tLocation in tLocations do
                            table.insert(oUnit[reftLocationsForPriorityShield], {tLocation[1], tLocation[2], tLocation[3]})
                            --Blacklist the location
                            M28Engineer.RecordBlacklistLocation(tLocation, iNewBuildingRadius, 600, oUnit)
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Will draw shield locations in black')
                                M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tLocation, iNewBuildingRadius), 3, 100)
                            end
                        end
                        break
                    end
                end--]]
                M28Team.tTeamData[aiBrain.M28Team][M28Team.refbStartedOnUnitWantingSpecialShielding] = true
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetBestFactionFactoryOfCategory(oUnitToGetTo, iCategory, iDistanceCap, iLandSubteam, iUnitPlateau, tLZData)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBestFactionFactoryOfCategory'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iClosestFactory = iDistanceCap
    local iCurDist, iCurPlateau, iCurLandZone, iCurZoneDist
    local iClosestZoneDist = iDistanceCap + 60
    local oBestFactory
    for iBrain, oBrain in M28Team.tLandSubteamData[iLandSubteam][M28Team.subreftoFriendlyM28Brains] do
        local tFactoriesOfCategory = oBrain:GetListOfUnits(iCategory, false, true)
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of factories of catory empty for brain '..oBrain.Nickname..'='..tostring(M28Utilities.IsTableEmpty(tFactoriesOfCategory))) end
        if M28Utilities.IsTableEmpty(tFactoriesOfCategory) == false then
            for iFactory, oFactory in tFactoriesOfCategory do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; Fraction complete='..oFactory:GetFractionComplete()..'; Is factory valid='..tostring(M28UnitInfo.IsUnitValid(oFactory))) end
                if oFactory:GetFractionComplete() == 1 and M28UnitInfo.IsUnitValid(oFactory) then
                    --Is this in the same plateau?
                    iCurPlateau, iCurLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oFactory:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': iCurPlateau='..(iCurPlateau or 'nil')..'; iUnitPlateau='..(iUnitPlateau or 'nil')) end
                    if iCurPlateau == iUnitPlateau then
                        --Get the travel distance
                        iCurZoneDist = tLZData[M28Map.subrefLZTravelDistToOtherLandZones][iCurPlateau][iCurLandZone]
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering factory with iCurZoneDist='..(iCurZoneDist or 'nil')..'; iClosestZoneDist='..iClosestZoneDist..'; Dist between factory and unit to cover='..M28Utilities.GetDistanceBetweenPositions(oUnitToGetTo:GetPosition(), oFactory:GetPosition())) end
                        if iCurZoneDist then
                            if iCurZoneDist <= iClosestZoneDist then
                                if iCurZoneDist < iClosestZoneDist then
                                    iClosestZoneDist = iCurZoneDist
                                    iClosestFactory = iDistanceCap + 100 --reset the distance so any factory in a closer zone will be preferred, even if the factory itself might be further away
                                end
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnitToGetTo:GetPosition(), oFactory:GetPosition())
                                if iCurDist < iClosestFactory then
                                    iClosestFactory = iCurDist
                                    oBestFactory = oFactory
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oBestFactory
end

function UnitNoLongerRequiresFactoryFactionShieldEngineers(oUnit)
    local oFactory = oUnit[refoNearbyFactoryOfFaction]
    if M28UnitInfo.IsUnitValid(oFactory) and M28Utilities.IsTableEmpty(oFactory[reftoUnitsWantingFactoryEngineers]) == false then
        for iEntry, oEntry in oFactory[reftoUnitsWantingFactoryEngineers] do
            if oEntry == oUnit then
                table.remove(oFactory[reftoUnitsWantingFactoryEngineers], iEntry)
                break
            end
        end
        oUnit[refoNearbyFactoryOfFaction] = nil
    end
end

function RecordNearbyFactoryForShieldEngineers(oUnit, tbOptionalFactionsWanted)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordNearbyFactoryForShieldEngineers'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iDistanceCap = 350 --Wont try and get engineers from factories further away than this.
    local aiBrain = oUnit:GetAIBrain()
    local iLandSubteam = aiBrain.M28LandSubteam
    local oBestFactory

    local iUnitPlateau, iUnitLandZone
    if oUnit[reftArtiTemplateRefs] then iUnitPlateau = oUnit[reftArtiTemplateRefs][1] iUnitLandZone = oUnit[reftArtiTemplateRefs][2]
    else
        iUnitPlateau, iUnitLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want a special factory for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; tbOptionalFactionsWanted='..repru(tbOptionalFactionsWanted)..'; iUnitPlateau='..(iUnitPlateau or 'nil')..'; iUnitLandZone='..(iUnitLandZone or 'nil')..'; Time='..GetGameTimeSeconds()) end
    if (iUnitLandZone or 0) > 0 then
        local tLZData = M28Map.tAllPlateaus[iUnitPlateau][M28Map.subrefPlateauLandZones][iUnitLandZone]
        --Seraphim factories
        if not(tbOptionalFactionsWanted) or tbOptionalFactionsWanted[M28UnitInfo.refFactionSeraphim] then
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have Seraphim T3 land on our land subteam, iLandSubteam='..iLandSubteam..'; M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionSeraphim]='..repru(M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionSeraphim])) end
            if (M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionSeraphim][3] or 0) > 0 then
                oBestFactory = GetBestFactionFactoryOfCategory(oUnit, M28UnitInfo.refCategoryLandFactory * categories.TECH3 * categories.SERAPHIM, iDistanceCap, iLandSubteam, iUnitPlateau, tLZData)
                if bDebugMessages == true then LOG(sFunctionRef..': oBestFactory after checking for seraphim='..(oBestFactory.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBestFactory) or 'nil')) end
            end
        end
        if not(oBestFactory) then
            --Aeon
            if not(tbOptionalFactionsWanted) or tbOptionalFactionsWanted[M28UnitInfo.refFactionAeon] then
                if (M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionAeon][3] or 0) > 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to try and get the best factory at time '..GetGameTimeSeconds()..'; iDistanceCap='..(iDistanceCap or 'nil')..'; iLandSubteam='..(iLandSubteam or 'nil')..'; iUnitPlateau='..(iUnitPlateau or 'nil')..'; is tLZData empty='..tostring(M28Utilities.IsTableEmpty(tLZData))) end
                    oBestFactory = GetBestFactionFactoryOfCategory(oUnit, M28UnitInfo.refCategoryLandFactory * categories.TECH3 * categories.AEON, iDistanceCap, iLandSubteam, iUnitPlateau, tLZData)
                end
            end
            if not(oBestFactory) then
                --UEF
                if not(tbOptionalFactionsWanted) or tbOptionalFactionsWanted[M28UnitInfo.refFactionUEF] then
                    if (M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionUEF][3] or 0) > 0 then
                        oBestFactory = GetBestFactionFactoryOfCategory(oUnit, M28UnitInfo.refCategoryLandFactory * categories.TECH3 * categories.UEF, iDistanceCap, iLandSubteam, iUnitPlateau, tLZData)
                    end
                end
                --If dont have any of these factions then dont worry about getting a faction specific shield
            end
        end
        --If have a best factory then record against the game ender
        oUnit[refoNearbyFactoryOfFaction] = oBestFactory
        if bDebugMessages == true then LOG(sFunctionRef..': Finished looking for nearby factories, oBestFactory='..(oBestFactory.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBestFactory) or 'nil')) end
        if oBestFactory then
            if not(oBestFactory[reftoUnitsWantingFactoryEngineers]) then
                oBestFactory[reftoUnitsWantingFactoryEngineers] = {}
            end

            table.insert(oBestFactory[reftoUnitsWantingFactoryEngineers], oUnit)
            local iFactoryPlateau, iFactoryLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oBestFactory:GetPosition())
            local tFactoryLZTeamData = M28Map.tAllPlateaus[iFactoryPlateau][M28Map.subrefPlateauLandZones][iFactoryLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
            local bRecordedInZoneAlready = false
            if not(tFactoryLZTeamData[M28Map.reftFactoriesWantedForEngineers]) then tFactoryLZTeamData[M28Map.reftFactoriesWantedForEngineers] = {}
            else
                for iExistingFactory, oExistingFactory in tFactoryLZTeamData[M28Map.reftFactoriesWantedForEngineers] do
                    if oExistingFactory == oBestFactory then
                        bRecordedInZoneAlready = true
                    end
                end
            end
            if not(bRecordedInZoneAlready) then
                table.insert(tFactoryLZTeamData[M28Map.reftFactoriesWantedForEngineers], oBestFactory)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RemoveFactoryFromZoneList(oFactory)
    --If a factory was assigned as providing engineers to a unit such as a gameender for shielding, it'd be recorded in the zone it was in - this removes it (e.g. intended where the factory ahs no units to assist, or the factory is dead)
    local iFactoryPlateau, iFactoryLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oFactory:GetPosition())
    if iFactoryLandZone > 0 then
        local tLZTeamData = M28Map.tAllPlateaus[iFactoryPlateau][M28Map.subrefPlateauLandZones][iFactoryLandZone][M28Map.subrefLZTeamData][oFactory:GetAIBrain().M28Team]
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftFactoriesWantedForEngineers]) == false then
            local iExistingEntries = table.getn(tLZTeamData[M28Map.reftFactoriesWantedForEngineers])
            for iCurEntry = iExistingEntries, 1, -1 do
                if tLZTeamData[M28Map.reftFactoriesWantedForEngineers][iCurEntry] == oFactory or not(M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.reftFactoriesWantedForEngineers][iCurEntry])) then
                    table.remove(tLZTeamData[M28Map.reftFactoriesWantedForEngineers], iCurEntry)
                end
            end
        end
    end
end

function ClearTrackingOfDeadUnitWantingFactoryEngineers(oUnit)
    --If a gameender had a factory assigned as providing engineers e.g. for shielding, and the gameender is dead, then this clears related tracking
    if M28Utilities.IsTableEmpty(oUnit[refoNearbyFactoryOfFaction][reftoUnitsWantingFactoryEngineers]) == false then
        local oFactory = oUnit[refoNearbyFactoryOfFaction]
        local iExistingEntries = table.getn(oFactory[reftoUnitsWantingFactoryEngineers])
        for iCurEntry = iExistingEntries, 1, -1 do
            if oFactory[reftoUnitsWantingFactoryEngineers][iCurEntry] == oUnit or not(M28UnitInfo.IsUnitValid(oFactory[reftoUnitsWantingFactoryEngineers][iCurEntry])) then
                table.remove(oFactory[reftoUnitsWantingFactoryEngineers], iCurEntry)
            end
        end
        if M28Utilities.IsTableEmpty(  oFactory[reftoUnitsWantingFactoryEngineers]) then
            RemoveFactoryFromZoneList(oFactory)
        end
    end
    --Remove this unit from the zone
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
    local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) == false then
        local iTotalEntries = table.getn(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection])
        for iCurEntry = iTotalEntries, 1, -1 do
            if tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection][iCurEntry] == oUnit or not(M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection][iCurEntry])) then
                table.remove(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection], iCurEntry)
            end
        end
    end
end

function UpdateTrackingOfDeadFactoryProvidingEngineers(oUnit)
    --If a factory that was providing engineers e.g. to a gameender for shielding dies, this updates the tracking variables and looks for a new factory to provide engineers
    local iExistingEntries = table.getn(oUnit[reftoUnitsWantingFactoryEngineers])
    for iCurEntry = iExistingEntries, 1, -1 do
        if oUnit[reftoUnitsWantingFactoryEngineers][iCurEntry][refoNearbyFactoryOfFaction] == oUnit then
            oUnit[reftoUnitsWantingFactoryEngineers][iCurEntry][refoNearbyFactoryOfFaction] = nil
            if M28UnitInfo.IsUnitValid(oUnit[reftoUnitsWantingFactoryEngineers][iCurEntry]) then
                --Get a new 'best factory to provide engineers' for the game ender
                RecordNearbyFactoryForShieldEngineers(oUnit[reftoUnitsWantingFactoryEngineers][iCurEntry])
            end
        end
    end
    --Remove this factory from the list of factories in the zone
    oUnit[reftoUnitsWantingFactoryEngineers] = nil
    RemoveFactoryFromZoneList(oUnit)
end

function AssignShieldToGameEnder(oConstruction, oEngineer, oOptionalBackupGameEnderToAssignTo)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignShieldToGameEnder'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oConstruction:GetPosition())

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at game time '..GetGameTimeSeconds()..'; oConstruction='..(oConstruction.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oConstruction) or 'nil')..'; oEngineer='..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil')..'; oConstruction iPlateau='..(iPlateau or 'nil')..'; Zone='..(iLandZone or 'nil')..'; oConstruction position='..repru(oConstruction:GetPosition())) end
    if (iLandZone or 0) > 0 then
        local oGameEnder
        local aiBrain = oEngineer:GetAIBrain()
        local iTeam = aiBrain.M28Team
        local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
        if not(oEngineer[M28Engineer.refoUnitActivelyShielding]) then
            oGameEnder = oOptionalBackupGameEnderToAssignTo
            if not(oGameEnder) then
                M28Utilities.ErrorHandler('Dont have a unit recorded that the engineer is actively shielding, will just get the first gameender in the zone')
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) == false then
                    for iUnit, oUnit in tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
                        oGameEnder = oUnit
                        break
                    end
                end
            end
        else
            oGameEnder = oEngineer[M28Engineer.refoUnitActivelyShielding]
            if bDebugMessages == true then LOG(sFunctionRef..': Engineer is actively shielding oGameEnder='..(oGameEnder.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oGameEnder) or 'nil')) end
        end
        if M28UnitInfo.IsUnitValid(oGameEnder) then
            if not(oGameEnder[reftoSpecialAssignedShields]) then
                oGameEnder[reftoSpecialAssignedShields] = {}
            end
            table.insert(oGameEnder[reftoSpecialAssignedShields], oConstruction)
            oConstruction[refoGameEnderBeingShielded] = oGameEnder
            if bDebugMessages == true then LOG(sFunctionRef..': Added oConstruction to the table of assigned shields for gameender') end
        else
            if oGameEnder then
                M28Utilities.ErrorHandler('Dont have a valid unit')
            end
        end
    else
        M28Utilities.ErrorHandler('Dont have valid land zone for construction')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateForNukeMissileDeath(oLauncher, tOptionalLikelyTarget)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateForNukeMissileDeath'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start at time ='..GetGameTimeSeconds()..'; oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..'; oLauncher[reftActiveNukeTarget] before reset='..repru(oLauncher[reftActiveNukeTarget])) end
    oLauncher[reftActiveNukeTarget] = nil

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function DetermineBuildingExpectedValues()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DetermineBuildingExpectedValues'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local tsT1EnergyStorageBlueprints = EntityCategoryGetUnitList(M28UnitInfo.refCategoryEnergyStorage)
    local iLowestTechTier = 5
    local iHighestEnergyStored = 0
    local iCurTechLevel
    if M28Utilities.IsTableEmpty(tsT1EnergyStorageBlueprints) == false then
        for _, sBlueprint in tsT1EnergyStorageBlueprints do
            local oBP = __blueprints[sBlueprint]
            if (oBP.Economy.StorageEnergy or 0) > 0 then
                iCurTechLevel = M28UnitInfo.GetBlueprintTechLevel(sBlueprint)
                if iCurTechLevel < iLowestTechTier then
                    iLowestTechTier = iCurTechLevel
                    iHighestEnergyStored = oBP.Economy.StorageEnergy
                elseif iCurTechLevel == iLowestTechTier and iHighestEnergyStored < oBP.Economy.StorageEnergy then
                    iHighestEnergyStored = oBP.Economy.StorageEnergy
                end
            end
        end
    end
    iEnergyStorageExpectedCapacity = (iHighestEnergyStored or 5000)
    if bDebugMessages == true then LOG(sFunctionRef..': end of code, iHighestEnergyStored='..iHighestEnergyStored..'; iLowestTechTier='..iLowestTechTier) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedConsiderLaunchingMissile(oLauncher, iSecondsToWait, bCheckIfStillLoaded)
    --Call via forkthread
    WaitSeconds(iSecondsToWait)
    if M28UnitInfo.IsUnitValid(oLauncher) then
        local bProceed = true
        if bCheckIfStillLoaded then
            bProceed = false
            local iMissiles = 0
            if oLauncher.GetTacticalSiloAmmoCount then iMissiles = iMissiles + oLauncher:GetTacticalSiloAmmoCount() end
            if oLauncher.GetNukeSiloAmmoCount then iMissiles = iMissiles + oLauncher:GetNukeSiloAmmoCount() end
            if iMissiles > 0 then bProceed = true end
        end
        if bProceed then
            ConsiderLaunchingMissile(oLauncher)
        end
    end
end

function AreUnitsAdjacent(oFirstUnit, oSecondUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AreUnitsAdjacent'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iFirstUnitSize = M28UnitInfo.GetBuildingSize(oFirstUnit.UnitId) * 0.5
    local iSecondUnitSize = M28UnitInfo.GetBuildingSize(oSecondUnit.UnitId) * 0.5
    local iMaxDif = iFirstUnitSize + iSecondUnitSize + 0.749 --assumed margin of error after where got to with mexes (where would go with 2.749 distance)
    local iMinDif = iFirstUnitSize + iSecondUnitSize - 0.749

    local iXDif = math.abs(oFirstUnit:GetPosition()[1] - oSecondUnit:GetPosition()[1])
    local iZDif = math.abs(oFirstUnit:GetPosition()[3] - oSecondUnit:GetPosition()[3])
    if bDebugMessages == true then LOG(sFunctionRef..': Considering oFirstUnit='..oFirstUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFirstUnit)..'; Position='..repru(oFirstUnit:GetPosition())..'; Size='..iFirstUnitSize..'; Second unit='..oSecondUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSecondUnit)..'; oSecondUnit position='..repru(oSecondUnit:GetPosition())..'; iSecondUnitSize='..iSecondUnitSize..'; iXDif='..iXDif..'; iZDif='..iZDif) end
    if (iXDif <= iMaxDif and iXDif >= iMinDif) or (iZDif <= iMaxDif and iZDif >= iMinDif) then
        --Are we in a corner position?
        --[[local iCornerDif = iFirstUnitSize + iSecondUnitSize - 0.1
        if bDebugMessages == true then LOG(sFunctionRef..': Units are close to each other, iXDif='..iXDif..'; iZDif='..iZDif..'; iCornerDif='..iCornerDif) end
        if iXDif < iCornerDif or iZDif < iCornerDif then--]]
        --Max smallest dif due to size dif
        local iMaxSmallestDif = math.abs(iFirstUnitSize - iSecondUnitSize) + 0.749
        if iXDif < iMaxSmallestDif or iZDif < iMaxSmallestDif then


            if bDebugMessages == true then LOG(sFunctionRef..': Units are adjacent') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end
        --end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Units are adjacent') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function ConsiderGiftingPowerToTeammateForAdjacency(oUnit)
    --Call when a t3 power has been constructed by an M28 brain
    --WARNING: Not tested fully, so only gives a rough approximation.  do further testing if more accuracy needed

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderGiftingPowerToTeammateForAdjacency'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain = oUnit:GetAIBrain()
    local iTeam = aiBrain.M28Team
    if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 then
        local iPotentialAdjacencyCategories = M28UnitInfo.refCategoryExperimentalLevel + M28UnitInfo.refCategoryAirFactory + M28UnitInfo.refCategoryStructure * categories.TECH3

        if EntityCategoryContains(M28UnitInfo.refCategoryT3Power, oUnit.UnitId) then
            --Are we adjacent to any air factories, omni, nuke launchers, t3 arti, owned by another teammate, and have no adjacency of such units on our own?

            if bDebugMessages == true then LOG(sFunctionRef..': is table of adjacent units empty='..tostring(M28Utilities.IsTableEmpty(oUnit.AdjacentUnits))) end
            if M28Utilities.IsTableEmpty(oUnit.AdjacentUnits) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(iPotentialAdjacencyCategories, oUnit.AdjacentUnits)) then
                --We have no existing adjacency
                local tNearbyUnitsOfInterest = aiBrain:GetUnitsAroundPoint(iPotentialAdjacencyCategories, oUnit:GetPosition(), M28UnitInfo.GetBuildingSize(oUnit.UnitId) + 1, 'Ally')
                if M28Utilities.IsTableEmpty(tNearbyUnitsOfInterest) == false then
                    for iNearbyUnit, oNearbyUnit in tNearbyUnitsOfInterest do
                        if not(oNearbyUnit:GetAIBrain() == aiBrain) and oNearbyUnit:GetAIBrain().M28Team == iTeam then
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oNearbyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearbyUnit)..'; Position='..repru(oNearbyUnit:GetPosition())..'; oUnit position='..repru(oUnit:GetPosition())) end
                            if AreUnitsAdjacent(oUnit, oNearbyUnit) then
                                --Gift to other brain
                                M28Team.TransferUnitsToPlayer({oUnit}, oNearbyUnit:GetAIBrain():GetArmyIndex(), false)
                                break
                            end
                        end
                    end
                end
            end
        else
            local iSpecificAdjacencyCategories = M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti - categories.MOBILE + M28UnitInfo.refCategorySML * categories.TECH3 + M28UnitInfo.refCategoryAirFactory * categories.TECH3 + M28UnitInfo.refCategoryMassFab * categories.TECH3 + M28UnitInfo.refCategoryT3Radar
            if EntityCategoryContains(iSpecificAdjacencyCategories, oUnit.UnitId) then
                if bDebugMessages == true then LOG(sFunctionRef..': is table of adjacent units empty='..tostring(M28Utilities.IsTableEmpty(oUnit.AdjacentUnits))) end
                if M28Utilities.IsTableEmpty(oUnit.AdjacentUnits) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryT3Power, oUnit.AdjacentUnits)) then
                    --We have no existing adjacency
                    local tNearbyUnitsOfInterest = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryT3Power, oUnit:GetPosition(), M28UnitInfo.GetBuildingSize(oUnit.UnitId) + 1, 'Ally')
                    if M28Utilities.IsTableEmpty(tNearbyUnitsOfInterest) == false then
                        for iNearbyUnit, oNearbyUnit in tNearbyUnitsOfInterest do
                            if not(oNearbyUnit:GetAIBrain() == aiBrain) and oNearbyUnit:GetAIBrain().M28Team == iTeam then
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oNearbyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearbyUnit)..'; Position='..repru(oNearbyUnit:GetPosition())..'; oUnit position='..repru(oUnit:GetPosition())) end
                                if AreUnitsAdjacent(oUnit, oNearbyUnit) then
                                    --Gift nearby t3 power to this unit's brain owner
                                    M28Team.TransferUnitsToPlayer({oNearbyUnit}, oUnit:GetAIBrain():GetArmyIndex(), false)
                                    break
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function JustBuiltParagon(oParagon)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'JustBuiltParagon'

    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28UnitInfo.IsUnitValid(oParagon) then
        if bDebugMessages == true then LOG(sFunctionRef..': oParagon owner='..oParagon:GetAIBrain().Nickname..'; Unit='..oParagon.UnitId..M28UnitInfo.GetUnitLifetimeCount(oParagon)..'; GameTime='..GetGameTimeSeconds()..'; Fraction complete='..oParagon:GetFractionComplete()..'; oParagon(M28BuiltParagon)='..tostring(oParagon['M28BuiltParagon'] or false)) end
        if not(oParagon['M28BuiltParagon']) then
            oParagon['M28BuiltParagon'] = true
            local aiBrain = oParagon:GetAIBrain()
            local iTeam = aiBrain.M28Team
            if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 then
                --Gift mexes, mass storage, RAS SACUs, and half of our pgens to another teammate
                local oOtherBrain
                local iMaxEngineersToGift = math.min(aiBrain[M28Overseer.refiExpectedRemainingCap] * 0.5, 30)
                local iEngineersGifted = 0
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    if not(oBrain == aiBrain) and not(aiBrain.M28IsDefeated) then
                        if oBrain[M28Economy.refiGrossMassBaseIncome] <= 500 then
                            oOtherBrain = oBrain
                            --Gift all non-land factories (retain land so we still build some units), fatboys, nukes, SMD, aircraft carriers
                            local tFactoriesToGift = oBrain:GetListOfUnits(M28UnitInfo.refCategoryNavalFactory + M28UnitInfo.refCategoryAirFactory + M28UnitInfo.refCategoryQuantumGateway + M28UnitInfo.refCategorySML + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryCarrier + M28UnitInfo.refCategoryHive, false, true)
                            if M28Utilities.IsTableEmpty(tFactoriesToGift) == false then
                                local tUnitsToGift = {}
                                for iUnit, oUnit in tFactoriesToGift do
                                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then
                                        table.insert(tUnitsToGift, oUnit)
                                    end
                                end
                                if M28Utilities.IsTableEmpty(tUnitsToGift) == false then
                                    M28Team.TransferUnitsToPlayer(tUnitsToGift, aiBrain:GetArmyIndex(), false)
                                end
                            end
                            if iEngineersGifted < iMaxEngineersToGift then
                                local tEngineersAvailable = oBrain:GetListOfUnits(M28UnitInfo.refCategoryEngineer, false, true)
                                if M28Utilities.IsTableEmpty(tEngineersAvailable) == false then
                                    local tEngineersToGift = {}
                                    local iCurCount = 0


                                    for iUnit, oUnit in tEngineersAvailable do
                                        iCurCount = iCurCount + 1
                                        if iCurCount >= 2 then
                                            if not(oUnit:IsUnitState('Attached')) and not(oUnit[M28Engineer.refbPrimaryBuilder]) then
                                                table.insert(tEngineersToGift, oUnit)
                                                iEngineersGifted = iEngineersGifted + 1
                                                if iEngineersGifted >= iMaxEngineersToGift then break end
                                            end
                                            iCurCount = 0
                                        end

                                    end
                                    if M28Utilities.IsTableEmpty(tEngineersToGift) == false then
                                        M28Team.TransferUnitsToPlayer(tEngineersToGift, aiBrain:GetArmyIndex(), false)
                                    end
                                end
                            end
                        end
                    end
                end
                if oOtherBrain then
                    local tUnitsToGift = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryT1Power + M28UnitInfo.refCategoryT2Power + M28UnitInfo.refCategoryMassStorage + M28UnitInfo.refCategoryRASSACU, false, true)
                    if M28Utilities.IsTableEmpty(tUnitsToGift) then
                        tUnitsToGift = {}
                    end
                    local tT3Power = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryT3Power, false, true)
                    if M28Utilities.IsTableEmpty(tT3Power) == false then
                        local iCurCount = -1
                        local iGiftThreshold = 1
                        for iUnit, oUnit in tT3Power do
                            iCurCount = iCurCount + 1
                            if iCurCount >= iGiftThreshold then
                                iCurCount = 0
                                table.insert(tUnitsToGift, oUnit)
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tUnitsToGift) == false then

                        M28Team.TransferUnitsToPlayer(tUnitsToGift, oOtherBrain:GetArmyIndex(), false)

                    end
                end

            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function ConsiderManualT2ArtiTarget(oArti, oOptionalWeapon, iOptionalDelaySecondsAndWeaponFireCheck)
    --Considers giving manual orders to the T2 arti, so e.g. can use aoe and shot firing randomness to damage enemy shields just outside of our range

    --oOptionalWeapon - if called from the weapon fire event then this means we can check our last target
    --iOptionalDelaySecondsAndWeaponFireCheck - if specified, then will wait this many seconds then check if we have fired since the code started, and if not then proceed (used so if we are targeting a mobile unit and it goes out of our range we arent stuck with an invalid fire order)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderManualT2ArtiTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bProceedWithLogic = true
    if iOptionalDelaySecondsAndWeaponFireCheck then
        --e.g. we have targeted a mobile unit, so only check again if we have failed to fire recently
        bProceedWithLogic = false
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(iOptionalDelaySecondsAndWeaponFireCheck)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if not(oArti[M28UnitInfo.refiLastWeaponEvent]) or GetGameTimeSeconds() - oArti[M28UnitInfo.refiLastWeaponEvent] >= iOptionalDelaySecondsAndWeaponFireCheck - 0.01 then
            bProceedWithLogic = true
        end
    elseif oArti[M28UnitInfo.refiTimeBetweenIFShots] and GetGameTimeSeconds() - (oArti[M28UnitInfo.refiLastWeaponEvent] or -100) < oArti[M28UnitInfo.refiTimeBetweenIFShots] - 2 then
        if bDebugMessages == true then LOG(sFunctionRef..': Want to wait until Arti almost ready to fire before choosing the next target, oArti[M28UnitInfo.refiTimeBetweenIFShots]='..(oArti[M28UnitInfo.refiTimeBetweenIFShots] or 'nil')..'; Time since last weapn event='..(GetGameTimeSeconds() - (oArti[M28UnitInfo.refiLastWeaponEvent] or -100))) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(math.min(oArti[M28UnitInfo.refiTimeBetweenIFShots] - 2, oArti[M28UnitInfo.refiTimeBetweenIFShots] -2 - (GetGameTimeSeconds() - (oArti[M28UnitInfo.refiLastWeaponEvent] or -100))))
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to proceed for oArti='..(oArti.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oArti) or 'nil')..'; Is oArti valid='..tostring(M28UnitInfo.IsUnitValid(oArti))..'; bProceedWithLogic='..tostring(bProceedWithLogic)..'; iOptionalDelaySecondsAndWeaponFireCheck='..(iOptionalDelaySecondsAndWeaponFireCheck or 'nil')..'; Is oOptionalWeapon nil='..tostring(oOptionalWeapon == nil)..'; Time='..GetGameTimeSeconds()) end
    if bProceedWithLogic and M28UnitInfo.IsUnitValid(oArti) then


        local bGivenOrder = false
        local tLastTarget
        if oOptionalWeapon.GetCurrentTarget then
            local vLastTarget = oOptionalWeapon:GetCurrentTarget()
            if vLastTarget.GetPosition then
                tLastTarget = vLastTarget:GetPosition()
            elseif vLastTarget[1] and vLastTarget[3] and not(vLastTarget[4]) then
                tLastTarget = {vLastTarget[1], vLastTarget[2], vLastTarget[3]}
            end
        end

        --Are there T2 arti nearby? if so then want to target the closest t2 arti or shield covering the t2 arti
        local aiBrain = oArti:GetAIBrain()
        local iTeam = aiBrain.M28Team
        local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oArti:GetPosition(), true, iTeam)
        local oClosestTargetOfInterest
        local iClosestTargetOfInterest
        if not(oArti[M28UnitInfo.refiIndirectRange]) then
            M28Utilities.ErrorHandler('Dont have indirect fire range for T2 Arti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti))
            iClosestTargetOfInterest = 115 + 30
        else
            iClosestTargetOfInterest = oArti[M28UnitInfo.refiIndirectRange] + 30 --wont bother trying to fire at something further away than this (and in some cases will need to be closer - ie.. depends on shielding situation)
        end
        local iCurDist
        local tArtiPosition = oArti:GetPosition()
        --Set the min range so we avoid targets inside this
        local iMinRange = oArti[M28UnitInfo.refiArtiMinRange]
        if not(iMinRange) then
            if oOptionalWeapon then
                oArti[M28UnitInfo.refiArtiMinRange] = (oOptionalWeapon.MinRadius or 1)
            else
                for iWeapon, tWeapon in oArti:GetBlueprint().Weapon do
                    if tWeapon.MinRadius then
                        oArti[M28UnitInfo.refiArtiMinRange] = tWeapon.MinRadius
                        break
                    end
                end
                iMinRange = oArti[M28UnitInfo.refiArtiMinRange]
                if not(iMinRange) then
                    iMinRange = math.min(oArti[M28UnitInfo.refiIndirectRange] * 0.7, 50)
                end
            end
        end

        function UpdateClosestUnit(tUnits)
            for iUnit, oUnit in tUnits do
                if not(oUnit.Dead) then
                    --Check unit is on land and not attached
                    if not(oUnit:IsUnitState('Attached')) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tArtiPosition)
                        if bDebugMessages == true then LOG(sFunctionRef..': iCurDist='..repru(iCurDist)..'; iClosestTargetOfInterest='..repru(iClosestTargetOfInterest)..'; iMinRange='..repru(iMinRange)) end
                        if iCurDist < iClosestTargetOfInterest and iCurDist >= iMinRange then
                            iClosestTargetOfInterest = iCurDist
                            oClosestTargetOfInterest = oUnit
                        end
                    end
                end
            end
        end

        --First consider enemy fatboys
        if (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) > 0 then
            UpdateClosestUnit(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats])
        end

        if not(oClosestTargetOfInterest) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
            --Enemy has t2 arti nearby so consider groundfiring units unless they have a fatboy nearby
            UpdateClosestUnit(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits])
        end

        if not(oClosestTargetOfInterest) and tLastTarget then
            --No T2 arti but we were firing at something before, so check if any enemy shields or T2 arti or ravagers around the arti and (if so) if we want to ground fire them
            local tNearbyUnitsOfInterest = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryMissileShip + M28UnitInfo.refCategoryPD * categories.TECH3, tArtiPosition, iClosestTargetOfInterest - 1, 'Enemy')
            if M28Utilities.IsTableEmpty(tNearbyUnitsOfInterest) == false then
                UpdateClosestUnit(tNearbyUnitsOfInterest)
            end
            if not(oClosestTargetOfInterest) then
                tNearbyUnitsOfInterest = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryIndirectT2Plus + M28UnitInfo.refCategoryT2PlusPD + M28UnitInfo.refCategoryTMD + M28UnitInfo.refCategoryTML, oArti:GetPosition(), iClosestTargetOfInterest - 1, 'Enemy')
                if M28Utilities.IsTableEmpty(tNearbyUnitsOfInterest) == false then
                    UpdateClosestUnit(tNearbyUnitsOfInterest)
                end
            end
        end

        --If we have a unit consider attacking it, or groundfiring if it is out of our range
        if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for main target, oClosestTargetOfInterest='..(oClosestTargetOfInterest.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestTargetOfInterest) or 'nil')..'; iClosestTargetOfInterest='..iClosestTargetOfInterest) end
        if oClosestTargetOfInterest then
            --Is it covered by a fixed shield? if so then switch target to the closest shield that is covering it
            if M28Utilities.IsTableEmpty(oClosestTargetOfInterest[reftoShieldsProvidingCoverage]) == false then
                local iOrigUnitDist = iClosestTargetOfInterest
                local oOrigUnitTarget = oClosestTargetOfInterest
                iClosestTargetOfInterest = 100000
                UpdateClosestUnit(oClosestTargetOfInterest[reftoShieldsProvidingCoverage])
                if iClosestTargetOfInterest >= 100000 then --Redundancy
                    iClosestTargetOfInterest = iOrigUnitDist
                    oClosestTargetOfInterest = oOrigUnitTarget
                elseif bDebugMessages == true then LOG(sFunctionRef..': Original target was covered by a fixed shield so will target the shield instead, revised target='..oOrigUnitTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOrigUnitTarget)..'; iOrigUnitDist='..iOrigUnitDist)
                end
            end

            --Now have selcted the unit we want to target - if its in our range then issue an attack order, otherwise issue a ground fire order
            local bTargetingMobileUnit = EntityCategoryContains(categories.MOBILE, oClosestTargetOfInterest.UnitId)
            bGivenOrder = true
            --Consider whether to ground fire
            if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to do ground fire attack; iClosestTargetOfInterest='..iClosestTargetOfInterest..'; oArti[M28UnitInfo.refiIndirectRange]='..(oArti[M28UnitInfo.refiIndirectRange] or 'nil')) end
            if iClosestTargetOfInterest <= oArti[M28UnitInfo.refiIndirectRange] then
                if bDebugMessages == true then LOG(sFunctionRef..': Can we see the oClosestTargetOfInterest='..tostring(M28UnitInfo.CanSeeUnit(aiBrain, oClosestTargetOfInterest, false))..'; oClosestTargetOfInterest='..(oClosestTargetOfInterest.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestTargetOfInterest) or 'nil')) end
                if M28UnitInfo.CanSeeUnit(aiBrain, oClosestTargetOfInterest, false) then
                    M28Orders.IssueTrackedAttack(oArti, oClosestTargetOfInterest, false, 'ArtAt', false)
                else
                    M28Orders.IssueTrackedGroundAttack(oArti, oClosestTargetOfInterest:GetPosition(), 0.1, false, 'ArtXG', false, oClosestTargetOfInterest)
                    if bDebugMessages == true then LOG(sFunctionRef..': Will do ground attack as cant see the unit') end
                end
            else
                --Ground fire as target is out of our range; dont even try ground firing if its not a shield and is well outside our range
                if oClosestTargetOfInterest.MyShield or iClosestTargetOfInterest <= oArti[M28UnitInfo.refiIndirectRange] + 20 then

                    local iDistShortfall = 1
                    local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
                    if GetGameTimeSeconds() - (oArti[M28Events.refiLastWeaponEvent] or -100) >= 25 then iDistShortfall = 3 end --greater dist threshold in case are trying to fire at elevated position
                    local tGroundFireTarget = M28Utilities.MoveInDirection(tArtiPosition, M28Utilities.GetAngleFromAToB(tArtiPosition, oClosestTargetOfInterest:GetPosition()), (oArti[M28UnitInfo.refiIndirectRange] or 115) - iDistShortfall, true, false, M28Map.bIsCampaignMap)
                    if bDebugMessages == true then LOG(sFunctionRef..': Will gorund fire as target unit is outside our range, tGroundFireTarget='..repru(tGroundFireTarget)) end
                    if tGroundFireTarget then
                        M28Orders.IssueTrackedGroundAttack(oArti, tGroundFireTarget, 0.1, false, 'ArtGF', false, oClosestTargetOfInterest)
                    else
                        M28Utilities.ErrorHandler('Failed to calculate valid ground fire target for arti '..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti))
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Not targeting a shield and it is too far outside our range so will abort') end
                    bGivenOrder = false
                end
            end

            --If we were targeting a mobile unit then reconsider targets 5s later if we have failed to fire a shot in the meantime
            if bTargetingMobileUnit then
                if bDebugMessages == true then LOG(sFunctionRef..': About to start a forked thread to re-consider t2 arti target as we are targeting a mobile unit') end
                ForkThread(ConsiderManualT2ArtiTarget, oArti, oOptionalWeapon, 5)
            end
        end

        --Clear orders if last order was attack ground and we havent given any new order (so will revert to default weapon targeting)
        if not(bGivenOrder) then
            M28Orders.UpdateRecordedOrders(oArti)
            local iLastOrderType = oArti[M28Orders.reftiLastOrders][1][M28Orders.subrefiOrderType]
            if iLastOrderType == M28Orders.refiOrderIssueGroundAttack or iLastOrderType == M28Orders.refiOrderIssueAttack then
                if bDebugMessages == true then LOG(sFunctionRef..': Couldnt find any targets and arti was given an attack or ground fire order so will clear the order') end
                M28Orders.IssueTrackedClearCommands(oArti)
            else
                --Give an attack ground order if we haven't fired a shot at all this game, so we are likely to be facing the right direction
                local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
                if bDebugMessages == true then LOG(sFunctionRef..': Last weapon event='..(oArti[M28Events.refiLastWeaponEvent] or 'nil')) end
                if not(oArti[M28Events.refiLastWeaponEvent]) then
                    local tDirectionTowardsEnemy = M28Utilities.MoveInDirection(oArti:GetPosition(), M28Utilities.GetAngleFromAToB(oArti:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase]), (oArti[M28UnitInfo.refiIndirectRange] or 110) - 5, true, false, M28Map.bIsCampaignMap)
                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and fire at tDirectionTowardsEnemy='..repru(tDirectionTowardsEnemy)..', Dist to arti='..M28Utilities.GetDistanceBetweenPositions(oArti:GetPosition(), tDirectionTowardsEnemy)) end
                    M28Orders.IssueTrackedGroundAttack(oArti, tDirectionTowardsEnemy, 0.1, false, 'ArtGF', false, oClosestTargetOfInterest)
                    --Clear this order in 5s if still not got a target
                    ForkThread(ConsiderManualT2ArtiTarget, oArti, oOptionalWeapon, 5)
                end
            end
        end
    end
end

function GetBestAOETargetForSpecifiedBuildings(aiBrain, iTeam, tLauncherPosition, tSMDBlockingTarget, iAOE, iDamage)
    --intended for yolona targeting blocking smds; start by getting the closest enemy SMD, returns revised target

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBestAOETargetForSpecifiedBuildings'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iClosestDist = 100000
    local oClosestSMD
    local iCurDist
    local tTarget
    local iClosestAltSMDToSMD = 100000
    local tNearbyAltSMD = {}

    if table.getn(tSMDBlockingTarget) == 1 then
        oClosestSMD = tSMDBlockingTarget[1]
    else
        for iSMD, oSMD in tSMDBlockingTarget do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tLauncherPosition, oSMD:GetPosition())
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestSMD = oSMD
            end
        end
    end

    --Competing concerns - if try to edge nuke SMD then might deal minimal damage to wider base once we break through; if instead target for max damage we might cause other SMD not previously in range to become in range
    --will therefore only consider best damage if there is only 1 SMD nearby

    local iNearbyThreshold = iAOE * 2
    local tiDistToClosestSMD = {}
    for iSMD, oSMD in M28Team.tTeamData[iTeam][M28Team.reftEnemySMD] do
        if not(oSMD == oClosestSMD) and M28UnitInfo.IsUnitValid(oSMD) then
            iCurDist = M28Utilities.GetDistanceBetweenPositions(oClosestSMD:GetPosition(), oSMD:GetPosition())
            if iCurDist < iNearbyThreshold then
                table.insert(tNearbyAltSMD, oSMD)
                table.insert(tiDistToClosestSMD, iCurDist)
            end
        end
    end
    if M28Utilities.IsTableEmpty(tNearbyAltSMD) == false then
        --work out the position that hits the max no. of units - approximate by taking the best midpoint between smd pairs that include the first
        local bCheckPlayableArea = M28Map.bIsCampaignMap
        local iBestSMDInRange = 0
        local tBestTarget
        for iSMD, oSMD in tNearbyAltSMD do
            local tCurMidpoint = M28Utilities.MoveInDirection(oClosestSMD:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestSMD:GetPosition(), oSMD:GetPosition()), tiDistToClosestSMD[iSMD] * 0.5, false, bCheckPlayableArea)
            local iSMDInRange = 2
            for iAltSMD, oAltSMD in tNearbyAltSMD do
                if not(oAltSMD == oSMD) then
                    if M28Utilities.GetDistanceBetweenPositions(tCurMidpoint, oAltSMD:GetPosition()) < iAOE then
                        if bDebugMessages == true then LOG(sFunctionRef..': IF target the midpoint between smd '..oSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSMD)..' and the closest SMD '..oClosestSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestSMD)..' then another SMD, oAltSMD='..oAltSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oAltSMD)..' is also in range. is alt smd valid='..tostring(M28UnitInfo.IsUnitValid(oAltSMD))) end
                        iSMDInRange = iSMDInRange + 1
                    end
                end
            end
            if iSMDInRange > iBestSMDInRange then
                tBestTarget = {tCurMidpoint[1], tCurMidpoint[2], tCurMidpoint[3]}
                iBestSMDInRange = iSMDInRange
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iBestSMDInRange='..iBestSMDInRange..'; oClosestSMD='..oClosestSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestSMD)) end
        if iBestSMDInRange >= 2 then
            tTarget = tBestTarget
        else
            tTarget = M28Logic.GetBestAOETarget(aiBrain, oClosestSMD:GetPosition(), iAOE, iDamage, false)
        end

    else
        tTarget = M28Logic.GetBestAOETarget(aiBrain, oClosestSMD:GetPosition(), iAOE, iDamage, false)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tTarget='..repru(tTarget)..'; Time='..GetGameTimeSeconds()) end
    return tTarget
end

function MonitorShieldsForCycling(tTableRef, iTeam, iLandZone)
    --Called from the gameender template logic
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MonitorShieldsForCycling'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(tTableRef[M28Map.subrefGEbActiveShieldMonitor]) then
        tTableRef[M28Map.subrefGEbActiveShieldMonitor] = true
        local oLowestHealthActiveShield, oHighestHealthActiveShield, iCompletedShieldCount, iCurHealth, iMaxHealth, iLowestHealth, iHighestHealth, iLongestRechargeTime
        local iSecondsBetweenShieldCycles = 1 --will change
        local M28Config = import('/mods/M28AI/lua/M28Config.lua')
        local bUpdateName = M28Config.M28ShowUnitNames
        local iCurShieldRadius, iShieldWithHealth

        while M28Conditions.IsTableOfUnitsStillValid(tTableRef[M28Map.subrefGEShieldUnits]) do
            --Get the highest and lowest health active shields
            iLowestHealth = 1000000
            iHighestHealth = 0
            oLowestHealthActiveShield = nil
            oHighestHealthActiveShield = nil
            iCompletedShieldCount = 0
            iLongestRechargeTime = 10
            iShieldWithHealth = 0
            for iShield, oShield in tTableRef[M28Map.subrefGEShieldUnits] do

                if oShield:GetFractionComplete() == 1 then
                    --Check we should include the shield (i.e. that it is covering the arti locations); assume UEF and seraphim T3+ are
                    if oShield[refbProtectingAllArtiLocations] == nil then
                        oShield[refbProtectingAllArtiLocations] = true --default
                        if not(EntityCategoryContains(categories.SERAPHIM + categories.UEF - categories.TECH2, oShield.UnitId)) then

                            iCurShieldRadius = (oShield:GetBlueprint().Defense.Shield.ShieldSize or 0) * 0.5
                            if iCurShieldRadius < 10 then
                                oShield[refbProtectingAllArtiLocations] = false
                            else
                                if M28Conditions.IsTableOfUnitsStillValid(tTableRef[M28Map.subrefGEArtiUnits]) then
                                    for iArti, oArti in tTableRef[M28Map.subrefGEArtiUnits] do
                                        if M28Utilities.GetDistanceBetweenPositions(oArti:GetPosition(), oShield:GetPosition()) > iCurShieldRadius then
                                            oShield[refbProtectingAllArtiLocations] = false
                                            break
                                        end
                                    end
                                else
                                    --Use expected arti locations
                                    for iArti, tArti in tTableRef[M28Map.subrefGEArtiLocations] do
                                        if M28Utilities.GetDistanceBetweenPositions(tArti, oShield:GetPosition()) > iCurShieldRadius then
                                            oShield[refbProtectingAllArtiLocations] = false
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; oShield[refbProtectingAllArtiLocations]='..tostring(oShield[refbProtectingAllArtiLocations] or false)) end
                    if oShield[refbProtectingAllArtiLocations] then
                        iCompletedShieldCount = iCompletedShieldCount + 1
                        iCurHealth, iMaxHealth = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' at time='..GetGameTimeSeconds()..'; iCurHealth='..iCurHealth..'; iMaxHealth='..iMaxHealth..'; Is shield enabled='..tostring(M28UnitInfo.IsUnitShieldEnabled(oShield))..'; Time since last discharge='..GetGameTimeSeconds() - (oShield[refiTimeOfLastDischarge] or -100)..'; Is shield paused='..tostring(oShield[M28UnitInfo.refbPaused] or false)) end
                        if iCurHealth > 0 then
                            iShieldWithHealth = iShieldWithHealth + 1
                            if iCurHealth < iLowestHealth then
                                iLowestHealth = iCurHealth
                                oLowestHealthActiveShield = oShield
                            end
                            if iCurHealth >= iHighestHealth then --want this to be >= and above to be < so that if we have 2 of the same shields at 100% health, we will have different shields recorded for lowest and highest health
                                iHighestHealth = iCurHealth
                                oHighestHealthActiveShield = oShield
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Time since last recharge='..GetGameTimeSeconds() - (oShield[refiTimeOfLastDischarge] or -100)..'; Is shield a transferred unit='..tostring(oShield[M28UnitInfo.refbTransferredUnit])..'; oUnit[refbShieldIsDisabled]='..repru(oShield[M28UnitInfo.refbShieldIsDisabled])) end

                            if oShield[refiTimeOfLastDischarge] and GetGameTimeSeconds() - oShield[refiTimeOfLastDischarge] >= math.max(iLongestRechargeTime + 10, 40) and GetGameTimeSeconds() - (oShield[M28UnitInfo.refiTimeCreated] or 0) >= 5 then
                                --Enable the shield incase it was somehow paused following the transfer
                                if bDebugMessages == true then LOG(sFunctionRef..': Enabling shield as it has been a long time since it was discharged, shield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; Time='..GetGameTimeSeconds()) end
                                M28UnitInfo.EnableUnitShield(oShield)
                            elseif not(oShield[refiTimeOfLastDischarge]) and oShield[M28UnitInfo.refbTransferredUnit] and oShield[M28UnitInfo.refbShieldIsDisabled] == nil and iCurHealth == 0 and oShield:GetAIBrain():GetEconomyStoredRatio('ENERGY') >= 0.1 and not(oShield[M28UnitInfo.refbPaused]) and GetGameTimeSeconds() - (oShield[M28UnitInfo.refiTimeCreated] or 0) >= 5 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have 0 health shield that was transferred so will try enabling shield, shield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; Time='..GetGameTimeSeconds()) end
                                M28UnitInfo.EnableUnitShield(oShield)
                            end
                        end

                        iLongestRechargeTime = math.max(iLongestRechargeTime, (oShield:GetBlueprint().Defense.Shield.ShieldRechargeTime or 0))
                    end
                end
            end
            if iCompletedShieldCount == 0 then break end
            if bDebugMessages == true then LOG(sFunctionRef..': Deciding how long to wait and whether to discharge a shield, iShieldWithHealth='..iShieldWithHealth..'; iCompletedShieldCount='..iCompletedShieldCount) end
            if not(oLowestHealthActiveShield) or oLowestHealthActiveShield == oHighestHealthActiveShield or iShieldWithHealth <= 1 then
                --We only have 1 shield active, so dont want to reset it
                iSecondsBetweenShieldCycles = 0.1 --review position next tick
                if bDebugMessages == true then LOG(sFunctionRef..': we either have no or 1 active shield so wont discharge but will check again in 1 tick') end
            else
                --We will presumably have waited the appropriate time before getting here, so can disable the lowest health shield; work out how long we want to wait for the next shield
                if iCompletedShieldCount > 1 then
                    iSecondsBetweenShieldCycles = iLongestRechargeTime / (iCompletedShieldCount - 1)
                else
                    --Redundancy - should be impossible to get here
                    iSecondsBetweenShieldCycles = 10
                end
                M28UnitInfo.DischargeShield(oLowestHealthActiveShield)
                if bDebugMessages == true then LOG(sFunctionRef..': have just discharged shield '..oLowestHealthActiveShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLowestHealthActiveShield)..' at time='..GetGameTimeSeconds()) end
                oLowestHealthActiveShield[refiTimeOfLastDischarge] = GetGameTimeSeconds()
                if bUpdateName then
                    M28Orders.UpdateUnitNameForOrder(oLowestHealthActiveShield, 'DischZ'..(oLowestHealthActiveShield[reftArtiTemplateRefs][2] or 'nil')..'T'..(oLowestHealthActiveShield[reftArtiTemplateRefs][3] or 'nil')..'; Tm='..math.floor(GetGameTimeSeconds()))
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(iSecondsBetweenShieldCycles)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': No longer have valid shields, so will flag that we have no active shield monitor, time='..GetGameTimeSeconds()) end
        tTableRef[M28Map.subrefGEbActiveShieldMonitor] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end