---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 05/12/2022 21:39
---
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local NavUtils = M28Utilities.NavUtils
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')

refiEngineerStuckCheckCount = 'M28CEngSC' --time since last recorded the engineer's position when moving; also used by GE Template logic for when an engi is getting in range of building something via move order (due to rare issue wehre it is given move+buidl order and doesnt move or build)
reftEngineerStuckCheckLastPosition = 'M28CEngSP' --Position engineer was at when last did the stuck check
refiEngineerBuildWithoutFocusUnitCount = 'M28CEngBSc' --times that engineer has had a building status without a focus object
--reftEngineerBuildWithoutFocusUnitPosition = 'M28CEngBSt' --removed part of logic relating to this as realised the issue it was trying to solve was likely a unit cap issue

function AreMobileLandUnitsInRect(rRectangleToSearch)
    --returns true if have mobile land units in rRectangleToSearch
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AreMobileUnitsInRect'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tBlockingUnits = GetUnitsInRect(rRectangleToSearch)
    if M28Utilities.IsTableEmpty(tBlockingUnits) then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false
    else
        for iUnit, oUnit in tBlockingUnits do
            if oUnit.UnitId and EntityCategoryContains(categories.MOBILE * categories.LAND, oUnit.UnitId) then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function GetAirSubteamLifetimeBuildCount(iAirSubteam, category)
    local iTotalBuild = 0
    if M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains]) == false then
        for iBrain, oBrain in M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains] do
            --LOG('Lifetime build count for brain '..oBrain.Nickname..'='..GetLifetimeBuildCount(oBrain, category))
            iTotalBuild = iTotalBuild + GetLifetimeBuildCount(oBrain, category)
        end
    end
    return iTotalBuild
end

function GetTeamLifetimeBuildCount(iTeam, category)
    --Intended for use for M28 teams only
    local iTotalBuild = 0
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            iTotalBuild = iTotalBuild + GetLifetimeBuildCount(oBrain, category)
        end
    end
    return iTotalBuild
end

function GetLifetimeBuildCount(aiBrain, category)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetLifetimeBuildCount'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iTotalBuilt = 0
    local testCat = category
    if type(category) == 'string' then
        testCat = ParseEntityCategory(category)
    end
    local tUnitBPIDs = EntityCategoryGetUnitList(category)
    local oCurBlueprint
    local iCurCount

    if tUnitBPIDs == nil then
        M28Utilities.ErrorHandler('tUnitBPIDs is nil, so wont have built any')
        iTotalBuilt = 0
    else
        if bDebugMessages == true then LOG(sFunctionRef..': cycling through tUnitBPIDs') end
        for _, sBPID in tUnitBPIDs do
            oCurBlueprint = __blueprints[sBPID]
            iCurCount = aiBrain.M28LifetimeUnitCount[sBPID]
            if iCurCount == nil then iCurCount = 0 end
            if bDebugMessages == true then LOG(sFunctionRef..': sBPID='..sBPID..'; LifetimeCount='..iCurCount) end
            iTotalBuilt = iTotalBuilt + iCurCount
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iTotalBuilt
end

function IsCivilianBrain(aiBrain)
    --Is this an AI brain?
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsCivilianBrain'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if aiBrain.M28IsCivilian == nil then
        if M28Utilities.bSteamActive then import('/mods/M28AI/lua/AI/Steam/SteamCompatibility.lua').OtherSteamCompatibilityInformation() end
        local bIsCivilian = false
        if bDebugMessages == true then
            LOG(sFunctionRef..': Brain index='..aiBrain:GetArmyIndex()..'; BrainType='..(aiBrain.BrainType or 'nil')..'; Personality='..ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality..'; Nickname='..(aiBrain.Nickname or 'nil')..'; reprs of brain='..reprs(aiBrain))
        end
        --Basic check that it appears to have the values we'd expect
        --if aiBrain.BrainType and aiBrain.Name then
        if aiBrain.BrainType == nil or aiBrain.BrainType == "AI" or string.find(aiBrain.BrainType, "AI") then
            if bDebugMessages == true then LOG('Dealing with an AI brain') end
            --Does it have no personality?
            if not(ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality) or ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == "" then
                if bDebugMessages == true then LOG(sFunctionRef..': Index='..aiBrain:GetArmyIndex()..'; Has no AI personality so will treat as being a civilian brain unless nickname contains AI or AIX and doesnt contain civilian') end
                bIsCivilian = true
                if string.find(aiBrain.Nickname or aiBrain.Name, '%(AI') and not(string.find(aiBrain.Nickname or aiBrain.Name, "civilian")) then
                    if bDebugMessages == true then LOG(sFunctionRef..': AI nickanme suggests its an actual AI and the developer has forgotten to give it a personality') end
                    bIsCivilian = false
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': campaign adjust - treat most civilians as actual brains, rely on nickname (not precise method). bIsCampaignMap='..tostring(M28Map.bIsCampaignMap)..'; bIsCivilian before adjust='..tostring(bIsCivilian)) end
        if bIsCivilian and not(M28Map.bIsCampaignMap) then
            --Redundancy - make sure we have checked if this is a campaign map first (compatibility with 4z0ts map)
            M28Overseer.CheckIfScenarioMap()
            if bDebugMessages == true then LOG(sFunctionRef..': Is campaign map after making sure the check has been run='..tostring(M28Map.bIsCampaignMap)) end
        end
        if bIsCivilian and M28Map.bIsCampaignMap then
            bIsCivilian = false
            if bDebugMessages == true then LOG(sFunctionRef..': brain name='..aiBrain.Name..'; Nickname='..aiBrain.Nickname..'; does nickanme contain "civilian"='..repru(string.find(aiBrain.Name, "civilian"))) end
            if string.find(aiBrain.Nickname, "civilian") or string.find(aiBrain.Name, "civilian") or string.find(aiBrain.Nickname, "Civilian") or string.find(aiBrain.Nickname, "Civilian") then
                bIsCivilian = true
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bIsCivilian after campaign adjust (if relevant)='..tostring(bIsCivilian)) end
        aiBrain.M28IsCivilian = bIsCivilian
    elseif aiBrain.M28AI then
        aiBrain.M28IsCivilian = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return aiBrain.M28IsCivilian
end

function GetLifetimeBuildCount(aiBrain, category)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetLifetimeBuildCount'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iTotalBuilt = 0
    local testCat = category
    if type(category) == 'string' then
        testCat = ParseEntityCategory(category)
    end
    local tUnitBPIDs = EntityCategoryGetUnitList(category)
    local oCurBlueprint
    local iCurCount

    if tUnitBPIDs == nil then
        M28Utilities.ErrorHandler('tUnitBPIDs is nil, so wont have built any')
        iTotalBuilt = 0
    else
        if bDebugMessages == true then LOG(sFunctionRef..': cycling through tUnitBPIDs') end
        for _, sBPID in tUnitBPIDs do
            oCurBlueprint = __blueprints[sBPID]
            iCurCount = aiBrain.M28LifetimeUnitCount[sBPID]
            if iCurCount == nil then iCurCount = 0 end
            if bDebugMessages == true then LOG(sFunctionRef..': sBPID='..sBPID..'; LifetimeCount='..iCurCount) end
            iTotalBuilt = iTotalBuilt + iCurCount
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iTotalBuilt
end

function GetFactoryLifetimeCount(oFactory, iCategory, bAllUnitsInsteadOfCategory)
    if bAllUnitsInsteadOfCategory then
        return (oFactory[M28Factory.refiTotalBuildCount] or 0)
    else
        local iTotalCount = 0
        if oFactory[M28Factory.refiBuildCountByBlueprint] then
            for sBPID, iCurCount in oFactory[M28Factory.refiBuildCountByBlueprint] do
                if EntityCategoryContains(iCategory, sBPID) then
                    iTotalCount = iTotalCount + iCurCount
                end
            end
        end
        return iTotalCount
    end
end

function IsEngineerAvailable(oEngineer, bDebugOnly)
    --If bDebugOnly is true then wont adjust counts/tracking (i.e. set to true if are calling for logging purposes, so we dont desync the replay)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsEngineerAvailable'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then
        local iCurPlateau, iCurLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
        LOG(sFunctionRef..': GameTIme '..GetGameTimeSeconds()..': Engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' owned by '..oEngineer:GetAIBrain().Nickname..': oEngineer:GetFractionComplete()='..oEngineer:GetFractionComplete()..'; Unit state='..M28UnitInfo.GetUnitState(oEngineer)..'; Are last orders empty='..tostring(oEngineer[M28Orders.reftiLastOrders] == nil)..'; Engineer Plateau='..(iCurPlateau or 'nil')..'; LZ='..(iCurLZ or 'nil')..'; Is unit state moving='..tostring(oEngineer:IsUnitState('Moving'))..'; Engineer position='..repru(oEngineer:GetPosition())..'; Engineer assigned action='..(oEngineer[M28Engineer.refiAssignedAction] or 'nil')..'; Special micro active='..tostring(oEngineer[M28UnitInfo.refbSpecialMicroActive] or false)..'; oEngineer[refiEngineerStuckCheckCount]='..(oEngineer[refiEngineerStuckCheckCount] or 'nil')..'; refiSequentialReclaimCount='..(oEngineer[M28Engineer.refiSequentialReclaimCount] or 'nil'))
    end
    if oEngineer:GetFractionComplete() == 1 and not(oEngineer:IsUnitState('Attached')) and not(oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionSpecialShieldDefence) and not(oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionManageGameEnderTemplate) and not(oEngineer:IsUnitState('Capturing')) then
        --Spare engineers - always treat as available even if in the middle of something
        if oEngineer[M28Engineer.refbHasSpareAction] then
            if bDebugMessages == true then LOG(sFunctionRef..': Engineer given spare action so marking as available') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        elseif not(oEngineer:IsUnitState('Building')) and not(oEngineer:IsUnitState('Repairing')) then
            if oEngineer:IsUnitState('Reclaiming') then
                --Cover rare scenario where engineer shows as reclaiming but has nothing to reclaim
                if oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionReclaimArea then
                    local tUnitsReclaiming = oEngineer[M28Engineer.reftUnitsWeAreReclaiming]
                    local bNotReclaiming = true
                    if M28Utilities.IsTableEmpty(tUnitsReclaiming) == false then
                        for iReclaiming, oReclaiming in tUnitsReclaiming do
                            if not(oReclaiming.Dead) and (not(oReclaiming.BeenDestroyed) or not(oReclaiming:BeenDestroyed())) then
                                bNotReclaiming = false
                                break
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Engineer is reclaiming, bNotReclaiming='..tostring(bNotReclaiming)..'; Stuck check='..(oEngineer[refiEngineerStuckCheckCount] or 'nil')) end
                    if bNotReclaiming then
                        oEngineer[refiEngineerStuckCheckCount] = (oEngineer[refiEngineerStuckCheckCount] or 0) + 1
                        if oEngineer[refiEngineerStuckCheckCount] >= 3 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Engi might be stuck trying to reclaim so making available') end
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        end
                    end
                    --if got here then havent flagged that have nothing to reclaim
                    if oEngineer[refiEngineerStuckCheckCount] then oEngineer[refiEngineerStuckCheckCount] = 0 end
                elseif oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionAttackMoveToLandZone and (oEngineer[M28Engineer.refiSequentialReclaimCount] or 0) >= 30 then
                    if oEngineer[M28Engineer.refiSequentialReclaimCount] >= 100 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Engi has been reclaiming a long time, will make available') end
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return true
                    else
                        local iCurPlateau, iCurLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
                        if bDebugMessages == true then LOG(sFunctionRef..': Engineer on attack move has action to move to LZ, reftiPlateauAndLZToMoveTo='..reprs(oEngineer[M28Land.reftiPlateauAndLZToMoveTo])..'; Eng position iCurPlateau='..(iCurPlateau or 'nil')..'; iCurLZ='..(iCurLZ or 'nil')) end
                        if iCurPlateau == oEngineer[M28Land.reftiPlateauAndLZToMoveTo][1] and iCurLZ == oEngineer[M28Land.reftiPlateauAndLZToMoveTo][2] then
                            if bDebugMessages == true then LOG(sFunctionRef..': Engi is in its target zone and has reclaimed a reasonable amount so will make available again to check for new orders') end
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Engineer is reclaiming so will treat as unavailable') end

                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return false
            else
                M28Orders.UpdateRecordedOrders(oEngineer)
                if not(oEngineer[M28Orders.reftiLastOrders]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Engineer has no last orders active so is available') end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                else
                    --If engineer is moving but it doesnt have an assignment, or its assignment isnt to move, then make it available, unless it has special micro active
                    if oEngineer[M28UnitInfo.refbSpecialMicroActive] then
                        if bDebugMessages == true then LOG(sFunctionRef..': Special micro is active') end
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return false
                    else
                        local iLastOrderType = oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType]
                        if bDebugMessages == true then LOG(sFunctionRef..': Engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' owned by '..oEngineer:GetAIBrain().Nickname..' has a last order type of '..(iLastOrderType or 'nil')..'; and an action assigned of '..(oEngineer[M28Engineer.refiAssignedAction] or 'nil')..'; Order for this action='..(M28Engineer.tiActionOrder[oEngineer[M28Engineer.refiAssignedAction]] or 'nil')..'; oEngineer[refiEngineerStuckCheckCount]='..(oEngineer[refiEngineerStuckCheckCount] or 'nil')) end
                        --Rare case where engineer acn be given a move order yet doesn't move - below is to try and mitigate it
                        if oEngineer:IsUnitState('Moving') and oEngineer[M28Orders.reftiLastOrders][1][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueMove and not(bDebugOnly) then
                            if (oEngineer[refiEngineerStuckCheckCount] or 0) == 0 then
                                oEngineer[refiEngineerStuckCheckCount] = 1
                                oEngineer[reftEngineerStuckCheckLastPosition] = {oEngineer:GetPosition()[1], oEngineer:GetPosition()[2], oEngineer:GetPosition()[3]}
                            else
                                oEngineer[refiEngineerStuckCheckCount] = oEngineer[refiEngineerStuckCheckCount] + 1
                                if oEngineer[refiEngineerStuckCheckCount] >= 10 then
                                    oEngineer[refiEngineerStuckCheckCount] = 0
                                    if M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(),oEngineer[reftEngineerStuckCheckLastPosition]) <= 0.01 then
                                        --Engineer is stuck, clear its orders and treat as available
                                        if bDebugMessages == true then LOG(sFunctionRef..': Engineer appears stuck, oEngineer[refiEngineerStuckCheckCount]='..oEngineer[refiEngineerStuckCheckCount]) end
                                        M28Orders.IssueTrackedClearCommands(oEngineer)
                                        oEngineer[reftEngineerStuckCheckLastPosition] = nil
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        return true
                                    end
                                end
                            end
                        end

                        if iLastOrderType == M28Orders.refiOrderIssueMove then
                            if oEngineer[M28Engineer.refiAssignedAction] and (M28Engineer.tiActionOrder[oEngineer[M28Engineer.refiAssignedAction]] == iLastOrderType or oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionLoadOntoTransport) then
                                --Engineer not available, unless its order was to move to a land or water zone, in which case check if it is now in that land or water zone (or if it has reclaimed 30+ things on route)
                                if oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionMoveToLandZone or (oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionAttackMoveToLandZone and (oEngineer[M28Engineer.refiSequentialReclaimCount] or 0) <= 30) then
                                    local iCurPlateau, iCurLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Engineer has action to move to LZ, reftiPlateauAndLZToMoveTo='..reprs(oEngineer[M28Land.reftiPlateauAndLZToMoveTo])..'; Eng position iCurPlateau='..(iCurPlateau or 'nil')..'; iCurLZ='..(iCurLZ or 'nil')) end
                                    if iCurPlateau == oEngineer[M28Land.reftiPlateauAndLZToMoveTo][1] and iCurLZ == oEngineer[M28Land.reftiPlateauAndLZToMoveTo][2] then
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        return true
                                    else
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        return false
                                    end
                                elseif oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionMoveToWaterZone then
                                    local iCurWaterZone = M28Map.GetWaterZoneFromPosition(oEngineer:GetPosition(), true, oEngineer)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Engineer has action to move to WZ, refiWZToMoveTo='..(oEngineer[M28Navy.refiWZToMoveTo] or 'nil')..'; Eng position iCurWaterZone='..(iCurWaterZone or 'nil')) end
                                    if iCurWaterZone and iCurWaterZone == oEngineer[M28Navy.refiWZToMoveTo] then
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        return true
                                    else
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        return false
                                    end
                                elseif oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionRunToLandZone then --Make available if no enemies in cur LZ and adjacent LZ, or alternatively none in cur LZ, and have friendly cmobat in cur LZ and dont need more
                                    local iCurPlateau, iCurLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Engineer has action to run to LZ, reftiPlateauAndLZToMoveTo='..reprs(oEngineer[M28Land.reftiPlateauAndLZToMoveTo])..'; Eng position iCurPlateau='..(iCurPlateau or 'nil')..'; iCurLZ='..(iCurLZ or 'nil')) end
                                    if iCurPlateau == oEngineer[M28Land.reftiPlateauAndLZToMoveTo][1] and iCurLZ == oEngineer[M28Land.reftiPlateauAndLZToMoveTo][2] then
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        return true
                                    else
                                        local tLZTeamData = M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLZ][M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
                                        if bDebugMessages == true then LOG(sFunctionRef..': Engineer isnt at LZ to run to yet, are there enemies in this or adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ])) end
                                        if not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
                                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                            return true
                                        else
                                            if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 10 then
                                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                                return false
                                            else
                                                local iTotalEnemyThreatNearby = tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]
                                                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLZ][M28Map.subrefLZAdjacentLandZones]) == false then
                                                    for _, iAdjLZ in M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLZ][M28Map.subrefLZAdjacentLandZones] do
                                                        iTotalEnemyThreatNearby = iTotalEnemyThreatNearby + M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team][M28Map.subrefTThreatEnemyCombatTotal]
                                                    end
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': iTotalEnemyThreatNearby='..iTotalEnemyThreatNearby..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]) end
                                                if iTotalEnemyThreatNearby * 5 < tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] then
                                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                                    return true
                                                end
                                            end
                                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                            return false
                                        end
                                    end
                                elseif oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionRunToWaterZone then --Make available if no enemies in cur WZ and adjacent LZ, or alternatively none in cur WZ, and have friendly cmobat in cur WZ and dont need more
                                    local iCurWaterZone = M28Map.GetWaterZoneFromPosition(oEngineer:GetPosition(), true, oEngineer)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Engineer has action to run to WZ, refiWZToMoveTo='..(oEngineer[M28Navy.refiWZToMoveTo] or 'nil')..'; Eng position iCurWaterZone='..(iCurWaterZone or 'nil')) end
                                    if iCurWaterZone and iCurWaterZone == oEngineer[M28Navy.refiWZToMoveTo] then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Engi has reached the WZ it wants to run to') end
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        return true
                                    else
                                        local iPond = M28Map.tiPondByWaterZone[iCurWaterZone]
                                        local iTeam = oEngineer:GetAIBrain().M28Team
                                        local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iCurWaterZone]
                                        local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                                        if bDebugMessages == true then LOG(sFunctionRef..': Engineer isnt at WZ to run to yet, are there enemies in this or adjacent WZ='..tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])) end
                                        if not(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) then
                                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                            return true
                                        else
                                            if tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 10 then
                                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                                return false
                                            else
                                                local iTotalEnemyThreatNearby = tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]
                                                if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                                                    for iEntry, tSubtable in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                                                        local iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                                                        iTotalEnemyThreatNearby = iTotalEnemyThreatNearby + (M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] or 0)
                                                    end
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': iTotalEnemyThreatNearby='..iTotalEnemyThreatNearby..'; tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]='..tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]) end
                                                if iTotalEnemyThreatNearby * 5 < tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] then
                                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                                    return true
                                                end
                                            end
                                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                            return false
                                        end
                                    end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': Engineer doesnt appear to be available') end
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                    return false
                                end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Engineer either doesnt have an assigned action or its current orders are inconsistent with that action, so returning true') end
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return true
                            end
                        elseif (iLastOrderType == M28Orders.refiOrderIssueGuard or iLastOrderType == M28Orders.refiOrderIssueCapture) then
                            if not(M28UnitInfo.IsUnitValid(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.subrefoOrderUnitTarget]])) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Guard or capture order where target no longer valid so available') end
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return true
                                --Redundancy if assisting engineer with no action (shouldnt be needed)
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.subrefoOrderUnitTarget]].UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': We are assisting an engineer, engineer action we are assisting='..(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.subrefoOrderUnitTarget]][M28Engineer.refiAssignedAction] or 'nil')..'; Unit state='..M28UnitInfo.GetUnitState(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.subrefoOrderUnitTarget]])) end
                                if not(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.subrefoOrderUnitTarget]][M28Engineer.refiAssignedAction]) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': We are assisting an engineer with no action so will make us available again') end
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                    return true
                                end
                            end
                        elseif iLastOrderType == M28Orders.refiOrderIssueBuild and oEngineer:IsUnitState('Moving') and not(EntityCategoryContains(M28UnitInfo.refCategoryWall + M28UnitInfo.refCategoryPD * categories.TECH1 + M28UnitInfo.refCategoryStructureAA * categories.TECH1, oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint])) then
                            --Check if there is already a constructed building at the build location
                            local tLastOrderPosition = oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition]
                            local rRect = M28Utilities.GetRectAroundLocation(tLastOrderPosition, 0.49)
                            local tUnitsInRect = GetUnitsInRect(rRect)
                            if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                                for iUnit, oUnit in tUnitsInRect do
                                    if oUnit:GetFractionComplete() == 1 and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) and M28UnitInfo.GetBuildingSize(oUnit.UnitId) > 1 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Engineer has a constructed building at its target location so making it available') end
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        return true
                                    end
                                end
                            end
                        elseif iLastOrderType == M28Orders.refiOrderIssueRepair then
                            local oUnitRepairing = oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefoOrderUnitTarget]
                            if not(M28UnitInfo.IsUnitValid(oUnitRepairing)) or (oUnitRepairing:GetFractionComplete() == 1 and (oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionRepairAllyUnit or M28UnitInfo.GetUnitHealthPercent(oUnitRepairing) == 1)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Are repairing a unit that is completed and full health or was an ally unit to repair, so are available') end
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return true
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Are assigned to repair a unit that isnt complete or healed yet so not available') end
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return false
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..'; Will return false') end
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return false
                        end
                    end
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Engineer is building or repairing so treating as unavailable') end --, refiEngineerBuildWithoutFocusUnitCount='..(oEngineer[refiEngineerBuildWithoutFocusUnitCount] or 0)) end
            if oEngineer:IsUnitState('Building') then
                local oFocusObject = oEngineer:GetFocusUnit()
                if oFocusObject then
                    if bDebugMessages == true then LOG(sFunctionRef..': Engineer oFocusObject='..(oFocusObject.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oFocusObject) or 'nil')) end
                    if oEngineer[refiEngineerBuildWithoutFocusUnitCount] then oEngineer[refiEngineerBuildWithoutFocusUnitCount] = 0 end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Engi is building without a focus object, will increase refiEngineerBuildWithoutFocusUnitCount') end
                    if (oEngineer[refiEngineerBuildWithoutFocusUnitCount] or 0) == 0 then
                        oEngineer[refiEngineerBuildWithoutFocusUnitCount] = 1
                        --oEngineer[reftEngineerBuildWithoutFocusUnitPosition] = {oEngineer:GetPosition()[1], oEngineer:GetPosition()[2], oEngineer:GetPosition()[3]}
                    else
                        oEngineer[refiEngineerBuildWithoutFocusUnitCount] = oEngineer[refiEngineerBuildWithoutFocusUnitCount] + 1
                        if oEngineer[refiEngineerBuildWithoutFocusUnitCount] >= 30 then
                            --If close to unit cap consider killing units
                            if bDebugMessages == true then LOG(sFunctionRef..': refbCloseToUnitCap='..tostring(oEngineer:GetAIBrain()[M28Overseer.refbCloseToUnitCap] or false)..'; will check unit cap in case that is why we are unable to build') end
                            oEngineer[refiEngineerBuildWithoutFocusUnitCount] = 0
                            M28Overseer.CheckUnitCap(oEngineer:GetAIBrain())
                        end
                    end
                end
            end

            --Below was to try and resolve issue with engi appearing to try and build somewhere and failing, but realised likely was just unit cap
            --if not(oEngineer[M28Engineer.refbHasSpareAction]) then
            --local tLastOrderPosition = oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition]
            --if M28Utilities.IsTableEmpty(tLastOrderPosition) == false then

            --local sLastBlueprint = oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint]
            --if sLastBlueprint then
            --local oOrderTarget = oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefoOrderUnitTarget]
            --[[if not(M28UnitInfo.IsUnitValid(oOrderTarget)) then --i.e. make sure we werent trying to repair a building that is valid
                local tLZOrWZData = M28Map.GetLandOrWaterZoneData(tLastOrderPosition)
                if tLZOrWZData then
                    M28Engineer.RecordBlacklistLocation(tLastOrderPosition, 1, 120, nil)
                    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tLastOrderPosition)
                    local tPotentialBuildLocations = M28Engineer.GetPotentialBuildLocationsNearLocation(oEngineer:GetAIBrain(), tLZOrWZData, iPlateauOrZero, iLandOrWaterZone, M28UnitInfo.GetBuildingSize(sLastBlueprint), nil)
                    if M28Utilities.IsTableEmpty(tPotentialBuildLocations) == false then
                        local tBestLocation = M28Engineer.GetBestBuildLocationForTarget(oEngineer, sLastBlueprint, tLastOrderPosition, tPotentialBuildLocations, 50, false, false)
                        if M28Utilities.IsTableEmpty(tBestLocation) == false then
                            local iPriority = (oEngineer[M28Engineer.refiAssignedActionPriority] or 1000)
                            local bIsPrimaryEngi = oEngineer[M28Engineer.refbPrimaryBuilder]
                            local iEngiAction = oEngineer[M28Engineer.refiAssignedAction]
                            if bDebugMessages == true then LOG(sFunctionRef..': Will try and get engi to redo building in a different location, have recorded blacklist, tBestLocation='..repru(tBestLocation)) end
                            M28Orders.IssueTrackedBuild(oEngineer, tBestLocation, sLastBlueprint, false, 'StuckBuild')
                            --TrackEngineerAction(oEngineer, iActionToAssign, bIsPrimaryBuilder, iCurPriority, tOptionalPlatAndLandToMoveTo, vOptionalOtherVariable, bMarkAsSpare)
                            M28Engineer.TrackEngineerAction(oEngineer, iEngiAction, bIsPrimaryEngi, iPriority, nil, nil, false)
                        end
                    end
                end
            end
        end
    end
end

elseif oEngineer[refiEngineerBuildWithoutFocusUnitCount] >= 45 then

oEngineer[refiEngineerBuildWithoutFocusUnitCount] = 0
if M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(),oEngineer[reftEngineerBuildWithoutFocusUnitPosition]) <= 0.01 then
    --Engineer is stuck, clear its orders and treat as available
    if bDebugMessages == true then LOG(sFunctionRef..': Engineer appears stuck, oEngineer[refiEngineerBuildWithoutFocusUnitCount]='..oEngineer[refiEngineerBuildWithoutFocusUnitCount]) end
    M28Orders.IssueTrackedClearCommands(oEngineer)
    oEngineer[reftEngineerBuildWithoutFocusUnitPosition] = nil
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return true
end
end
end
end
end--]]

            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return false
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Core unit state or construciton means engineer unavailable') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd) --redundancy for profiling
end

function IsResourceBlockedByResourceBuilding(iResourceCategory, sResourceBlueprint, tResourceLocation)
    --True if there is a mex or hydro at the location - used since CanBuildStructureAt can return false if reclaim is on the resource location (but we can sitll build there)
    local rRectangleToSearch = M28Utilities.GetRectAroundLocation(tResourceLocation, M28UnitInfo.GetBuildingSize(sResourceBlueprint) * 0.5)
    local tUnitsInRect = GetUnitsInRect(rRectangleToSearch)
    if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
        if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(iResourceCategory, tUnitsInRect)) == false then
            --if sResourceBlueprint == 'ueb1102' then LOG('Have units in rectangle around tResourceLocation='..repru(tResourceLocation)) end
            return true
        end
    end
    return false
end

function CanBuildStorageAtLocation(tLocation)
    if M28Overseer.GetFirstActiveBrain().CanBuildStructureAt and M28Overseer.GetFirstActiveBrain():CanBuildStructureAt('ueb1106', tLocation) == true then
        return true
    else
        return not(IsResourceBlockedByResourceBuilding(M28UnitInfo.refCategoryStructure, 'ueb1106', tLocation))
    end
end

function CanBuildOnMexLocation(tMexLocation)
    --True if can build on mex location; will return true if aiBrain result is true
    --Want to use a function in case t urns out reclaim on a mex means aibrain canbuild returns false
    if M28Overseer.GetFirstActiveBrain().CanBuildStructureAt and M28Overseer.GetFirstActiveBrain():CanBuildStructureAt('urb1103', tMexLocation) == true then
        return true
    else
        return not(IsResourceBlockedByResourceBuilding(M28UnitInfo.refCategoryMex, 'urb1103', tMexLocation))
    end
end

function CanBuildOnHydroLocation(tHydroLocation)
    --True if can build on hydro; will return true if aiBrain result is true
    --Want to use a function in case t urns out reclaim on a hydro means aibrain canbuild returns false
    if M28Overseer.GetFirstActiveBrain().CanBuildStructureAt and M28Overseer.GetFirstActiveBrain():CanBuildStructureAt('ueb1102', tHydroLocation) == true then
        return true
    else
        --local iPlateau, iLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tHydroLocation)
        --LOG('CanBuildOnHydroLocation: Considering for tHydroLocation='..repru(tHydroLocation)..' at iPlateau='..iPlateau..'; iLZ='..iLZ..'; IsResourceBlockedByResourceBuilding='..tostring(IsResourceBlockedByResourceBuilding(M28UnitInfo.refCategoryHydro, 'ueb1102', tHydroLocation)))
        return not(IsResourceBlockedByResourceBuilding(M28UnitInfo.refCategoryHydro, 'ueb1102', tHydroLocation))
    end
end

function IsUnitVisibleSEEUNITINFOCanSeeUnit()  end --To help with finding canseeunit

function SafeToUpgradeUnit(oUnit)
    --Returns true if safe to upgrade oUnit

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SafeToUpgradeUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Overseer.bNoRushActive and M28Overseer.iNoRushTimer - GetGameTimeSeconds() >= 120 then --have al ower 60s timer later on which just flags the zone as safe but does other checks after that
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    end

    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
    local bSafeZone = false
    if (iLandOrWaterZone or 'nil') > 0 and not(iPlateauOrZero == 0) then
        local tLZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        if M28Utilities.IsTableEmpty(tLZData) == false then
            local tLZTeamData = tLZData[M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
            if not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
                bSafeZone = true
            elseif tLZTeamData[M28Map.subrefLZbCoreBase] and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < 150 then
                bSafeZone = true
            end
            --ACU specific:
            if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and tLZTeamData[M28Map.reftClosestFriendlyBase] then
                if bDebugMessages == true then LOG(sFunctionRef..': Considering upgrading ACU, iLandOrWaterZone='..iLandOrWaterZone..'; bSafeZone before extra checks='..tostring(bSafeZone or false)..'; tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or false)..'; ACU health='..M28UnitInfo.GetUnitHealthPercent(oUnit)..'; Is table of nearby friendly T2 PD empty='..tostring(M28Utilities.IsTableEmpty(oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryT2PlusPD, oUnit:GetPosition(), 15, 'Ally')))) end
                -- dont treat as safe if low health unless close to a base
                local iDistToClosestFriendlyBase = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                if bSafeZone and iDistToClosestFriendlyBase > 10 then
                    if M28UnitInfo.GetUnitHealthPercent(oUnit) < 0.5 then
                        bSafeZone = false
                    elseif iDistToClosestFriendlyBase >= 50 then
                        --ACU out of base, check slightly further afield than just adjacent zone for indirect fire enemies that coudl cause us problems
                        local iMaxSearchRange = math.min(iDistToClosestFriendlyBase*1.5, 150)
                        local iOtherPlateauOrZero
                        local iTeam = oUnit:GetAIBrain().M28Team
                        local iEnemyRangeThreshold = oUnit[M28UnitInfo.refiDFRange]
                        local bEnemyHasLongerRangedUnits = false
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                            for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                                if tSubtable[M28Map.subrefiDistance] > iMaxSearchRange then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Are outside the max range so wil stop searching') end
                                    break
                                end
                                --Add to potential zone table
                                local tAltLZOrWZData
                                local tAltLZOrWZTeamData
                                if tSubtable[M28Map.subrefbIsWaterZone] then
                                    iOtherPlateauOrZero = 0

                                    tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[tSubtable[M28Map.subrefiLandOrWaterZoneRef]]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                    tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                                    if (tAltLZOrWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0) > iEnemyRangeThreshold then bEnemyHasLongerRangedUnits = true break end
                                else
                                    iOtherPlateauOrZero = tSubtable[M28Map.subrefiPlateauOrPond]
                                    tAltLZOrWZData = M28Map.tAllPlateaus[iOtherPlateauOrZero][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                    tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering other land zone '..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..'; Enemy best mobile DF range='..tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]..'; Enemy best mobile indirect range='..tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange]..'; Enemy combat='..tAltLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Ally mobile DF='..tAltLZOrWZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]) end
                                    if tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] > iEnemyRangeThreshold or tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] > iEnemyRangeThreshold then
                                        if tAltLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > tAltLZOrWZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] * 0.5 then
                                            bEnemyHasLongerRangedUnits = true break
                                        end
                                    end
                                end
                            end
                        end
                        if bEnemyHasLongerRangedUnits then bSafeZone = false end
                    end
                end
                --Treat as safe if are near T2 PD and have at least 40% health
                if not(bSafeZone) and M28UnitInfo.GetUnitHealthPercent(oUnit) >= 0.4 then
                    if M28Utilities.IsTableEmpty(oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryT2PlusPD, oUnit:GetPosition(), 15, 'Ally')) == false then
                        bSafeZone = true
                    elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
                        local iTotalLongRangePDThreat = 0
                        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                            if iRange >= 50 then
                                iTotalLongRangePDThreat = iTotalLongRangePDThreat + iThreat
                            end
                        end
                        --If have decent amount of T2 PD in this zone then even if we arent close to the PD still  consider this safe if we are close to the midpoint which ought to be covered by said PD
                        if bDebugMessages == true then LOG(sFunctionRef..': iTotalLongRangePDThreat='..iTotalLongRangePDThreat..'; Distance to midpoint='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])) end
                        if iTotalLongRangePDThreat >= 1500 then
                            if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= 10 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of T2+ PD in longer range empty='..tostring(M28Utilities.IsTableEmpty(oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryT2PlusPD, oUnit:GetPosition(), 40, 'Ally')))) end
                                if M28Utilities.IsTableEmpty(oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryT2PlusPD, oUnit:GetPosition(), 40, 'Ally')) == false then
                                    bSafeZone = true
                                end
                            end
                        end
                    end
                end
            end

            --If this mex has survived 5 mins and has no enemies in this zone itself, then treat as safe
            if not(bSafeZone) and EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeCreated] or 0) >= 300 then
                bSafeZone = true
            end

            --Treat as safe if we are under a shield
            if not(bSafeZone) and M28Utilities.IsTableEmpty(oUnit[M28Building.reftoShieldsProvidingCoverage]) == false then
                local iCurShieldHealth, iMaxShieldHealth
                for iShield, oShield in oUnit[M28Building.reftoShieldsProvidingCoverage] do
                    if M28UnitInfo.IsUnitValid(oShield) then
                        iCurShieldHealth, iMaxShieldHealth = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, false)
                        if (iCurShieldHealth or 0) >= (iMaxShieldHealth or -1) and iCurShieldHealth >= 2000 then
                            bSafeZone = true
                            break
                        end
                    end
                end
            end

            --If are within range of enemy t2 arti and not a core base then dont trear as safe unless both mex and arti alive for at least 8m
            if bDebugMessages == true then LOG(sFunctionRef..': Checking if enemy T2 arti in range if we think this is safe, bSafeZone='..tostring(bSafeZone)..'; iPlateau='..iPlateauOrZero..'; Is core base='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])..'; Zone='..(iLandOrWaterZone or 'nil')..'; Is table of enemy t2 arti empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]))) end
            if bSafeZone and iPlateauOrZero > 0 and not(tLZTeamData[M28Map.subrefLZbCoreBase]) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
                local bBothAliveForAWhile = true
                if GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeCreated] or 0) <= 480 then bBothAliveForAWhile = false
                else
                    for iArti, oArti in tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Time since Arti created='..GetGameTimeSeconds() - (oArti[M28UnitInfo.refiTimeCreated] or 0)) end
                        if GetGameTimeSeconds() - (oArti[M28UnitInfo.refiTimeCreated] or 0) <= 480 then bBothAliveForAWhile = false break end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': bBothAliveForAWhile='..tostring(bBothAliveForAWhile)) end
                if not(bBothAliveForAWhile) then
                    local bEnemyArtiInRange = false
                    for iArti, oArti in tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Dist of enemy Arti to unit position='..M28Utilities.GetDistanceBetweenPositions(oArti:GetPosition(), oUnit:GetPosition())..'; Arti combat range='..oArti[M28UnitInfo.refiCombatRange]) end
                        if M28Utilities.GetDistanceBetweenPositions(oArti:GetPosition(), oUnit:GetPosition()) <= oArti[M28UnitInfo.refiCombatRange] then
                            bSafeZone = false
                            break
                        end
                    end
                end
            end
        else
            M28Utilities.ErrorHandler('Dont have a valid LZData table for iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Unit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; will treat as safe for non-mobilre units only')
            if bDebugMessages == true then M28Utilities.DrawLocation(oUnit:GetPosition()) end
            if not(EntityCategoryContains(categories.MOBILE, oUnit.UnitId)) then
                bSafeZone = true
            end
        end
    else
        --probably have a water zone - consider if safe to upgrade
        local iWaterZone = M28Map.GetWaterZoneFromPosition(oUnit:GetPosition())
        if (iWaterZone or 0) > 0 then
            local iPond = M28Map.tiPondByWaterZone[iWaterZone]
            local tWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][oUnit:GetAIBrain().M28Team]
            if not(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) then bSafeZone = true end
        end
    end
    if M28Overseer.bNoRushActive then
        if M28Overseer.iNoRushTimer - GetGameTimeSeconds() > 60 then
            bSafeZone = true
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Nearing end of code, before TML check, bSafeZone='..tostring(bSafeZone)) end
    if bSafeZone then
        local bDangerousTML = false
        --TML adjust
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.reftEnemyTML]) == false and not(IsTableOfUnitsStillValid(oUnit[M28Building.reftoShieldsProvidingCoverage])) then
            --Buildings alreayd record TML in range and if covered by TMD
            if EntityCategoryContains(M28UnitInfo.refCategoryProtectFromTML, oUnit.UnitId) then
                if M28Utilities.IsTableEmpty(oUnit[M28Building.reftTMDCoveringThisUnit]) and M28Utilities.IsTableEmpty(oUnit[M28Building.reftTMLInRangeOfThisUnit]) == false then
                    bDangerousTML = true
                end
            end
        else
            --Is this an ACU? If so dont want to upgrade in range of enemy TML unless we have TMD nearby
            if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                local bTMLInRange = false
                for iTML, oTML in M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.reftEnemyTML] do
                    if M28UnitInfo.IsUnitValid(oTML) and M28Utilities.GetDistanceBetweenPositions(oTML:GetPosition(), oUnit:GetPosition()) <= M28Building.iTMLMissileRange + 2 then
                        bTMLInRange = true
                        break
                    end
                end
                if bTMLInRange then
                    --Do we have TMD nearby?
                    local tNearbyTMD = oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD, oUnit:GetPosition(), 25, 'Ally')
                    local bNearbyTMD = false
                    if M28Utilities.IsTableEmpty(tNearbyTMD) == false then
                        for iTMD, oTMD in tNearbyTMD do
                            if M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), oUnit:GetPosition()) <= math.max(12, (oTMD[M28UnitInfo.refiMissileDefenceRange] or 12.5) - 5) then
                                bNearbyTMD = true
                                break
                            end
                        end
                    end
                    if not(bNearbyTMD) then
                        bDangerousTML = true
                    end
                end
            end
        end
        if not(bDangerousTML) then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false

end

function HaveLowMass(aiBrain)
    --Not actually used as yet
    local bHaveLowMass = false
    if aiBrain[M28Economy.refiGrossMassBaseIncome] <= math.min(1000, 400 * aiBrain[M28Economy.refiBrainBuildRateMultiplier]) then --i.e. we dont ahve a paragon or crazy amount of SACUs
        local iMassStoredRatio = aiBrain:GetEconomyStoredRatio('MASS')
        if (iMassStoredRatio <= 0.15 or aiBrain:GetEconomyStored('MASS') <= 300) then
            if aiBrain[M28Economy.refiNetMassBaseIncome] < 0.2 then bHaveLowMass = true
            elseif iMassStoredRatio <= 0.05 and aiBrain[M28Economy.refiNetMassBaseIncome] < aiBrain[M28Economy.refiGrossMassBaseIncome] * 0.05 then bHaveLowMass = true
            end
        end
    elseif aiBrain:GetEconomyStoredRatio('MASS') < 0.01 and aiBrain[M28Economy.refiNetMassBaseIncome] < aiBrain[M28Economy.refiGrossMassBaseIncome] * 0.01 and not(aiBrain[M28Economy.refbBuiltParagon]) then
        bHaveLowMass = true
    end
    return bHaveLowMass
end

function TeamHasLowMass(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TeamHasLowMass'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bHaveLowMass = false
    if not(M28Team.tTeamData[iTeam][M28Team.refbBuiltParagon]) then
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 400 * (M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or 1) * (M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier] or 1) then --i.e. we dont ahve a paragon or crazy amount of SACUs
            local iMassStoredRatio = M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]

            if (iMassStoredRatio <= 0.15 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] <= 300 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] < 0.2 then bHaveLowMass = true
                elseif iMassStoredRatio <= 0.05 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] < M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 0.05 then bHaveLowMass = true
                elseif GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] or -10) < 10 then
                    bHaveLowMass = true
                end
            end
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.01 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] < M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 0.01 then
            bHaveLowMass = true
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; End of code, bHaveLowMass='..tostring(bHaveLowMass)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]='..M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]..'; Net mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]..'; Time of last mass stall='..(M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bHaveLowMass
end

function HaveLowPower(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'HaveLowPower'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..', team='..iTeam..'; Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] or false)..'; M28Team.tTeamDta[iTeam][M28Team.subrefiGrossEnergyWhenStalled]='..(M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] or 'nil')..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; Just built lots of power='..tostring(M28Team.tTeamData[iTeam][M28Team.refbJustBuiltLotsOfPower])..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; M28Team.tTeamData[iTeam][M28Team.subrefbTooLittleEnergyForUpgrade]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTooLittleEnergyForUpgrade])..'; Min energy per tech='..M28Economy.tiMinEnergyPerTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]) end
    local bHaveLowPower = false

    if (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 80000 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 80000 * (M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or 1) * (M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier] or 1) and not(M28Team.tTeamData[iTeam][M28Team.refbBuiltParagon]))) or (M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= 0.5) then --Paragon gives 1000000 per sec I think
        if not(M28Team.tTeamData[iTeam][M28Team.refbJustBuiltLotsOfPower]) then
            if (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= 0.95) or M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] then
                bHaveLowPower = true
            else
                if M28Map.bIsLowMexMap and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 2 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > 0 then
                    --Do nothing
                    --Dont have much more energy than when we last stalled - sometimes treat as low power (i.e. if we have low net energy, or dont have 100% energy stored)
                elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] * 1.05 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= 0.99 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.1 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.1)) then
                    bHaveLowPower = true
                    --Low power levels - apply slightly different test where it's ok to not have 100% energy
                elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 25 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 2.2 then
                    --if bDebugMessages == true then LOG(sFunctionRef..': iTeam='..iTeam..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored]='..( M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] or 'nil')..'; Lowest mass% stored='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] or 'nil')..'; Team net energy='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] or 'nil')) end
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] >= math.max(0.35, math.min(0.9, M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] * 2.5)) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 0.5 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] >= 0.9 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= -9)) then
                        --Do nothing (false)
                    else
                        bHaveLowPower = true
                    end
                elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.15 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] < 0.5 or M28Team.tTeamData[iTeam][M28Team.subrefbTooLittleEnergyForUpgrade] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < M28Economy.tiMinEnergyPerTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]) then
                    bHaveLowPower = true
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bHaveLowPower='..tostring(bHaveLowPower)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bHaveLowPower
end

function GetNumberOfConstructedUnitsMeetingCategoryInZone(tLZOrWZTeamData, iCategoryWanted)
    local iCount = 0
    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        local tUnitsOfCategory = EntityCategoryFilterDown(iCategoryWanted, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tUnitsOfCategory) == false then
            for iUnit, oUnit in tUnitsOfCategory do
                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then
                    iCount = iCount + 1
                end
            end
        end
    end
    return iCount
end

function GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, iCategoryWanted, bAllConstructionNotFactory)
    --Returns the number of factories that are building a unit meeting iCategoryWanted
    --if bAllConstructionNotFactory then instead returns number of part-complete units of iCategoryWanted
    local iAlreadyBuilding = 0
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        if bAllConstructionNotFactory then
            local tUnitsOfCategory = EntityCategoryFilterDown(iCategoryWanted, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tUnitsOfCategory) == false then
                for iUnit, oUnit in tUnitsOfCategory do
                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() < 1 then
                        iAlreadyBuilding = iAlreadyBuilding + 1
                    end
                end
            end
        else
            local tLZFactories = EntityCategoryFilterDown(categories.FACTORY, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tLZFactories) == false then
                local oCurUnitBuilding
                for iFactory, oFactory in tLZFactories do
                    oCurUnitBuilding = oFactory:GetFocusUnit()
                    if oCurUnitBuilding and EntityCategoryContains(iCategoryWanted, oCurUnitBuilding) then
                        --LOG('Temp to check we have a factory building the category wanted - we do, oFactory='..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; Unit building='..oCurUnitBuilding.UnitId)
                        iAlreadyBuilding = iAlreadyBuilding + 1
                    end
                end
            end
        end
    end
    return iAlreadyBuilding
end

function WantMorePower(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'WantMorePower'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bWantMorePower = true
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Energy when last unable to build air='..(M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0)..'; Highest factory tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier]='..M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier]..'; M28Team.tTeamData[iTeam][M28Team.refbJustBuiltLotsOfPower]='..tostring(M28Team.tTeamData[iTeam][M28Team.refbJustBuiltLotsOfPower] or false)..'; HaveLowPower(iTeam)='..tostring(HaveLowPower(iTeam))..'; M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled]='..(M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] or 'nil')) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 100000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] >= 0.5 and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and (M28Team.tTeamData[iTeam][M28Team.refbBuiltParagon] or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] >= 0.95)) then
        bWantMorePower = false
    elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 1.25 * (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < math.max(250, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.25) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0) + 150) then
        --No change - want more power
        if bDebugMessages == true then LOG(sFunctionRef..': Want more given amount we had when unable to build air units') end
    elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= (30 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] + 160 * math.max(0, (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] - 2))) * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier] * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
        --We dont have 1 pgen of our cur tech level (roughly) per brain so want more; i.e. no change
        if bDebugMessages == true then LOG(sFunctionRef..': Want base level of power given our tech level') end
        --Have re recently build lots of power, and at a high level it looks like we should have a decent amount of power for our mass income?
    elseif M28Team.tTeamData[iTeam][M28Team.refbJustBuiltLotsOfPower] and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.3 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.6 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] > 20 * M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.98 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] > 30 * M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass])) then
        bWantMorePower = false
        if bDebugMessages == true then LOG(sFunctionRef..': Just built lots of power so dont want more') end
    else
        if HaveLowPower(iTeam) then
            bWantMorePower = true
            if bDebugMessages == true then LOG(sFunctionRef..': Have low power') end
        else
            local iExtraFactor = 1.1
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.5 then iExtraFactor = 1.5 end
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < (M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] or 0) * iExtraFactor then bWantMorePower = true
            else
                local iNetPowerWanted
                local iHighestTeamTech = M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]
                local iUpgradingMexAdditionalFactor = 0
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) == false then
                    local iUpgradingMexes = 0
                    if iHighestTeamTech <= 2 then
                        iUpgradingMexes = table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes])
                    else
                        local tUpgradingT2PlusMexes = EntityCategoryFilterDown(categories.TECH2 + categories.TECH3, M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes])
                        if M28Utilities.IsTableEmpty(tUpgradingT2PlusMexes) == false then
                            iUpgradingMexes = table.getn(tUpgradingT2PlusMexes)
                        end
                    end
                    if iUpgradingMexes >= 3 then
                        iUpgradingMexAdditionalFactor = iUpgradingMexes * 0.02
                    end
                end
                if iHighestTeamTech >= 3 then

                    iNetPowerWanted = math.max(50, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.2 + iUpgradingMexAdditionalFactor)

                elseif iHighestTeamTech == 2 then
                    iNetPowerWanted = math.max(15, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.15 + iUpgradingMexAdditionalFactor)
                elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 20 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                    iNetPowerWanted = math.max(3, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.1 + iUpgradingMexAdditionalFactor)
                else
                    iNetPowerWanted = 2
                end
                if M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier] > 1 then
                    iNetPowerWanted = iNetPowerWanted * (1 + (M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier] - 1) * 0.5)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iNetPowerWanted='..iNetPowerWanted..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]) end
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < iNetPowerWanted then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want more net power') end
                    bWantMorePower = true
                else
                    bWantMorePower = false
                end
            end
        end
    end
    --Override if close to the unit cap and have good net energy already
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if should hold off building due to unit cap, bWantMorePower='..tostring(bWantMorePower)..'; Time since near unit cap='..(GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] or -100))..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]) end
    if bWantMorePower and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] or -100) < 60 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > math.min(250, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.4) then
        bWantMorePower = false
        if bDebugMessages == true then LOG(sFunctionRef..': Dont want more power due to unit cap') end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bWantMorePower='..tostring(bWantMorePower)..'; Just built lots of power='..tostring(M28Team.tTeamData[iTeam][M28Team.refbJustBuiltLotsOfPower] or false)..'; HaveLowPower='..tostring(HaveLowPower(iTeam))..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] or 'nil')..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bWantMorePower
end

function WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'WantToReclaimEnergyNotMass'
    if not(iPlateau) and not(iLandZone) then M28Utilities.ErrorHandler('Invalid arguments for if want to reclaim energy not mass') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; iTeam='..(iTeam or 'nil')..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; Lowest % energy='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] or 'nil')..'; Gross energy='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] or 'nil')..'; Reclaim total energy='..(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTotalEnergyReclaim] or 'nil')..'; Net team energy='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] or 'nil')) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= 0.7 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 80 and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTotalEnergyReclaim] >= 100 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < 2 then
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.05 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] >= 0.3 then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return false
        --LOUD specific - more likely to have lower % stored due to higher E storage
        elseif (M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= math.min(0.25, M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] * 3) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 40 then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return false
        end

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end


function HaveFactionTech(iSubteam, iFactoryType, iFactionWanted, iMinTechLevelNeeded)
    for iCurTech = iMinTechLevelNeeded, 3 do
        if M28Team.tLandSubteamData[iSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactionWanted][iCurTech] > 0 then
            return true
        end
    end
    return false
end

function EnemyTeamHasFaction(iM28Team, iEnemyFaction)
    for iBrain, oBrain in M28Team.tTeamData[iM28Team][M28Team.subreftoEnemyBrains] do
        if oBrain:GetFactionIndex() == iEnemyFaction then return true end
    end
    return false
end

function CloseToEnemyUnit(tStartPosition, tUnitsToCheck, iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
    --Returns true if our distance to any of tUnitsToCheck is <= iDistThreshold; if bIncludeEnemyDFRange is true then our distance to the units is reduced by the enemy unit's DF range (meaning it returns true if we are within iDistThreshold of the enemy unit being able to shoot at us)
    --iAltThresholdToDFRange - if bIncludeEnemyDFRange is true and this also has a value specified, then if we are within iAltThresholdToDFRange will return true regardless of the iDistThreshold test
    --oUnitIfConsideringAngleAndLastShot - if we have a unit that is very vulnerable at lcose range (e.g. a skirmisher unit), then including this here will mean a check is done of the enemy unit facing angle and unit state (to factor in how easily it could close in to us) to decide whether to run or not

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CloseToEnemyUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iCurDist
    if bDebugMessages == true then
        LOG(sFunctionRef..': tStartPosition='..repru(tStartPosition)..'; Size of tUnitsToCheck='..table.getn(tUnitsToCheck)..'; iDistThreshold='..iDistThreshold..'; bIncludeEnemyDFRange='..tostring(bIncludeEnemyDFRange or false))
        for iUnit, oUnit in tUnitsToCheck do
            LOG(sFunctionRef..': Dist to oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' = '..M28Utilities.GetDistanceBetweenPositions(tStartPosition, oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..' based on last known position of '..repru(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; actual unit position='..repru(oUnit:GetPosition())..'; Unit range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Is distance less tahn threshold='..tostring(M28Utilities.GetDistanceBetweenPositions(tStartPosition, oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) < iDistThreshold))
        end
    end
    local bIncludeAngleChecks, iAngleDistMod, iAngleDifferenceThreshold, iMiniAngleDistMod, iMiniAngleThreshold, iCurAngleDif
    local bAreCloseToUnit = false
    if M28UnitInfo.IsUnitValid(oUnitIfConsideringAngleAndLastShot) then
        bIncludeAngleChecks = true
        iAngleDistMod = -3 --i.e. will decrease enemy unit range to us by this amount if they are facing a similar angle to us
        iAngleDifferenceThreshold = 25 --if angle dif is less than this amount, will reduce enemy distance to us by iAngleDistMod
        iMiniAngleDistMod = -1.5
        iMiniAngleThreshold = iAngleDifferenceThreshold + 10
        --iOurFacingAngle = M28UnitInfo.GetUnitFacingAngle(oUnitIfConsideringAngleAndLastShot)

        --Adjust distance threshold if we have fired recently since being in range to fire again is less important
        if bDebugMessages == true then LOG(sFunctionRef..': About to adjust dist threshold based on if we have fired recently, iDistThreshold before adjustment='..iDistThreshold..'; Time='..GetGameTimeSeconds()..'; Last weapon event='..(oUnitIfConsideringAngleAndLastShot[M28UnitInfo.refiLastWeaponEvent] or -100)..'; Time between DF shots='..(oUnitIfConsideringAngleAndLastShot[M28UnitInfo.refiTimeBetweenDFShots] or 'nil')) end
        if GetGameTimeSeconds() - (oUnitIfConsideringAngleAndLastShot[M28UnitInfo.refiLastWeaponEvent] or -100) < (oUnitIfConsideringAngleAndLastShot[M28UnitInfo.refiTimeBetweenDFShots] or oUnitIfConsideringAngleAndLastShot[M28UnitInfo.refiTimeBetweenIFShots] or 100) then
            iDistThreshold = iDistThreshold * 1.06
        else iDistThreshold = iDistThreshold * 0.94
        end
    end
    local iClosestEnemyDist
    if oOptionalFriendlyUnitToRecordClosestEnemy then
        iClosestEnemyDist = 100000
        oOptionalFriendlyUnitToRecordClosestEnemy[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] = nil
    end
    for iUnit, oUnit in tUnitsToCheck do
        if M28UnitInfo.IsUnitValid(oUnit) then
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tStartPosition, oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
            if oOptionalFriendlyUnitToRecordClosestEnemy and iCurDist < iClosestEnemyDist then
                iClosestEnemyDist = iCurDist
                oOptionalFriendlyUnitToRecordClosestEnemy[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] = oUnit
            end
            if bIncludeAngleChecks and EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then
                iCurAngleDif = M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tStartPosition), M28UnitInfo.GetUnitFacingAngle(oUnit))
                if iCurAngleDif <= iAngleDifferenceThreshold then
                    if bDebugMessages == true then LOG(sFunctionRef..': Unit facing angle='..M28UnitInfo.GetUnitFacingAngle(oUnit)..'; Angle to start position='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tStartPosition)..'; so will adjust iCurDist '..iCurDist..' by iAngleDistMod='..iAngleDistMod..'; will adjust further if it is moving, unit state='..M28UnitInfo.GetUnitState(oUnit)) end
                    iCurDist = iCurDist + iAngleDistMod
                elseif iCurAngleDif <= iMiniAngleThreshold then
                    iCurDist = iCurDist + iMiniAngleDistMod
                    if bDebugMessages == true then LOG(sFunctionRef..': iCurAngleDif is below mini angle threshold, iCurAngleDif='..iCurAngleDif..'; iMiniAngleThreshold='..iMiniAngleThreshold..'; will adjust dist by iMiniAngleDistMod='..iMiniAngleDistMod) end
                elseif bDebugMessages == true then LOG(sFunctionRef..': Angle dif is large enough that we wont adjust the distance, iCurAngleDif='..iCurAngleDif)
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bIncludeEnemyDFRange='..tostring(bIncludeEnemyDFRange or false)..'; Unit range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; iCurDist='..iCurDist..'; iDistThreshold='..iDistThreshold..'; iAltThresholdToDFRange='..(iAltThresholdToDFRange or 'nil')) end
            if (bIncludeEnemyDFRange and (iCurDist - (oUnit[M28UnitInfo.refiDFRange] or 0) <= iDistThreshold or iCurDist <= (iAltThresholdToDFRange or 0) or (bIncludeEnemyAntiNavyRange and iCurDist - (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) <= iDistThreshold))) or (not(bIncludeEnemyDFRange) and iCurDist <= iDistThreshold) then
                --Structure specific
                if not(iOptionalDistThresholdForStructure) or iCurDist <= iOptionalDistThresholdForStructure or not(EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Are close to unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                    bAreCloseToUnit = true
                    --Want to keep searching to get the closest enemy unit if dont have one in range and have specified the closest unit be recorded
                    if not(oOptionalFriendlyUnitToRecordClosestEnemy) or iClosestEnemyDist <= -5 + math.max((oOptionalFriendlyUnitToRecordClosestEnemy[M28UnitInfo.refiDFRange] or 0), (oOptionalFriendlyUnitToRecordClosestEnemy[M28UnitInfo.refiIndirectRange] or 0)) then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return true
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Are close to structure but not too close yet, iOptionalDistThresholdForStructure='..iOptionalDistThresholdForStructure) end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bAreCloseToUnit
end

function TeamHasAirControl(iTeam)
--Returns true if any of the air subteams has air control
    local tbSubteams = {}
    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
        tbSubteams[oBrain.M28AirSubteam] = true
    end
    for iAirSubteam, bTrue in tbSubteams do
        if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] then return true end
    end
    return false
end

function TeamIsFarBehindOnAir(iTeam)
    --Returns true if any of the air subteams is far behind on air
    local tbSubteams = {}
    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
        tbSubteams[oBrain.M28AirSubteam] = true
    end
    for iAirSubteam, bTrue in tbSubteams do
        if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir] then return true end
    end
    return false

end

function ZoneWantsT1Spam(tLZTeamData, iTeam)
    if M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam] then
        return true
    elseif IsTableOfUnitsStillValid(tLZTeamData[M28Map.subrefoNearbyEnemyLandFacs]) and GetGameTimeSeconds() <= 900 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] <= 2 then
        return true
    elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] < 3 then
        local aiBrain = ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]]
        if aiBrain[M28Overseer.refbPrioritiseLowTech] and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] and M28Team.tTeamData[iTeam][M28Team.subrefiLowestFriendlyLandFactoryTech] < 2 then
            return true
        end
    end
    return false
end

function WantMoreFactories(iTeam, iPlateau, iLandZone, bIgnoreMainEcoConditions)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'WantMoreFactories'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --e.g. 1 t1 land factory building tank uses 0.4 mass per tick, so would want 1 factory for every 0.8 mass as a rough baseline; T2 is 0.9 mass per tick, T3 is 1.6; probably want ratio to be 50%-50%-33%
    local tiFactoryToMassByTechRatioWanted = {[1] = 1.2, [2] = 2.2, [3] = 5.5} --i.e. how much mass we want per tick for each factory of the tech level
    --Adjust factory T1 ratios if we cant path to enemy by land
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
    local aiBrain = ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]]

    local iCurIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint])
    local iEnemyIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase])
    if iCurIsland ~= iEnemyIsland and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.35 then
        tiFactoryToMassByTechRatioWanted = {[1]=3.5, [2] = 3.5, [3] = 6.5}
    elseif M28Map.iMapSize <= 256 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 60 then
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 120 then
            tiFactoryToMassByTechRatioWanted[1] = 0.4
        else
            tiFactoryToMassByTechRatioWanted[1] = 0.6
        end
    elseif M28Map.iMapSize >= 1024 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] < 3 and tLZTeamData[M28Map.subrefMexCountByTech][3] < tLZData[M28Map.subrefLZMexCount] then
        for iTech, iValue in tiFactoryToMassByTechRatioWanted do
            if not(M28Utilities.bQuietModActive) or M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.02) or aiBrain[M28Overseer.refbPrioritiseNavy] or aiBrain[M28Overseer.refbPrioritiseHighTech] then
                iValue = iValue * 2
            else
                iValue = iValue * 1.5
            end
        end
    end
    local iTeamCount = M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]
    if iTeamCount > 1 then
        for iEntry, iFactoryCountWanted in tiFactoryToMassByTechRatioWanted do
            tiFactoryToMassByTechRatioWanted[iEntry] = iFactoryCountWanted / iTeamCount
        end
    end
    local iAverageCurAirAndLandFactories = (M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeLand] or 0) / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] + (M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeAir] or 0) / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]
    local iFactoriesInZone --will change value from nil if needed
    local iAirFacsInZone --will change value from nil if needed
    local iLandFacsInZone
    local bWantMoreFactories = false
    local bDontWantDueToUnitCap = false
    local bCanBuildAirFac = true
    --Are air facs restricted?
    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] == 0 then
        bCanBuildAirFac = false
        if not(aiBrain.GetFactionIndex) then aiBrain = M28Team.GetFirstActiveM28Brain(iTeam) end
        local tsAirFacs = EntityCategoryGetUnitList(M28UnitInfo.refCategoryAirFactory * categories.TECH1 * M28UnitInfo.ConvertFactionToCategory(aiBrain:GetFactionIndex()))
        if M28Utilities.IsTableEmpty(tsAirFacs) == false then
            for iAirFac, sAirFac in tsAirFacs do
                if not(M28UnitInfo.IsUnitRestricted(sAirFac)) then
                    bCanBuildAirFac = true
                    break
                end
            end
        end
    end


    --Unit cap - want max of 2 factories in the core LZ and no more factories in non-core LZs
    if M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] then
        if not(tLZTeamData[M28Map.subrefLZbCoreBase]) then
            --Dont wnat more factories (no change to default)
            bDontWantDueToUnitCap = true
        else
            local tFactoriesInZone
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                tFactoriesInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if M28Utilities.IsTableEmpty(tFactoriesInZone) == false then
                    if not(iFactoriesInZone) then iFactoriesInZone = table.getn(tFactoriesInZone) end
                    if iFactoriesInZone >= 5 then
                        bDontWantDueToUnitCap = true
                    elseif iFactoriesInZone >= 2 then
                        if not(iAirFacsInZone) or not(iLandFacsInZone) then
                            iAirFacsInZone = 0
                            iLandFacsInZone = 0
                            for iFactory, oFactory in tFactoriesInZone do
                                if oFactory:GetFractionComplete() == 1 then
                                    if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oFactory.UnitId) then iLandFacsInZone = iLandFacsInZone + 1
                                    elseif EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oFactory.UnitId) then iAirFacsInZone = iAirFacsInZone + 1
                                    end

                                end
                            end
                        end
                        if (iAirFacsInZone > 0 or not(bCanBuildAirFac)) and iLandFacsInZone > 0 then bDontWantDueToUnitCap = true end

                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if close to unit cap, bDontWantDueToUnitCap='..tostring(bDontWantDueToUnitCap)..'; M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap]='..(M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] or 'nil')..'; iAverageCurAirAndLandFactories='..iAverageCurAirAndLandFactories..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]) end

    --Norush or eco slot at T2 and lower when arent overflowing mass
    if (M28Overseer.bNoRushActive and M28Overseer.iNoRushTimer - GetGameTimeSeconds() >= 30) or (tLZTeamData[M28Map.refbBaseInSafePosition] and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] < 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.7) then
        --Only want more factories if we dont have 1 land and 1 air in this LZ
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) then
            bWantMoreFactories = true
            if bDebugMessages == true then LOG(sFunctionRef..': No units in the zone so want more factories') end
        else
            if not(iLandFacsInZone) or not(iAirFacsInZone) then
                iLandFacsInZone = 0
                iAirFacsInZone = 0
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                    local tFriendlyFactory = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tFriendlyFactory) == false then
                        for iUnit, oUnit in tFriendlyFactory do
                            if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) then
                                iLandFacsInZone = iLandFacsInZone + 1
                            else
                                iAirFacsInZone = iAirFacsInZone + 1
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': NoRush: iLandFacsInZone='..iLandFacsInZone..'; iAirFacsInZone='..iAirFacsInZone..'; Do we want air fac instead of land fac='..tostring(DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData))) end
            if iLandFacsInZone > 0 and (iAirFacsInZone > 0 or not(bCanBuildAirFac) or not(DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData))) then
                --Dont want more factories
                bWantMoreFactories = false --redundancy
            else
                bWantMoreFactories = true
            end
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if want more factories at gamttime '..GetGameTimeSeconds()..' for iTeam='..iTeam..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; Mass % stored='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] or 'nil')..'; Land fac count='..(M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeLand] or 'nil')..'; Gross mass count='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] or 'nil')..'; Highest factory tech='..(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 'nil')..'; iAverageCurAirAndLandFactories='..(iAverageCurAirAndLandFactories or 'nil')..'; Factories wanted based on gross mass='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] or 0) * (tiFactoryToMassByTechRatioWanted[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] or 0)..'; iCurIsland='..(iCurIsland or 0)..'; iEnemyIsland='..(iEnemyIsland or 0)..'; Time since air fac last failed to have osmething to build='..(GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForAirFactory] or -100))..'; Time since land fac last failed to have something to build='..(GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForLandFactory] or -100))) end
        if not(bWantMoreFactories) and not(bDontWantDueToUnitCap) then
            --Failure to build at both land and air facs and have a significant number of factories already (at least 5)
            if (iAverageCurAirAndLandFactories >= 5 or (iAverageCurAirAndLandFactories >= 2.5 and M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 2 and iAverageCurAirAndLandFactories * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 8)) and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForAirFactory] or -100) <= 10 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForLandFactory] or -100) <= 10 and GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeLandFacHadNothingToBuild] or -100) <= 10 then
                --Dont want more factories unless we want an air fac, have T3 air, and arent mass stalling, and are building air units
                if bDebugMessages == true then LOG(sFunctionRef..': Have high average number of factories so dont want more') end
                --Stalling E and have factory in zone - dont want more factories early game
            elseif M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] and iAverageCurAirAndLandFactories >= 1 and (iAverageCurAirAndLandFactories >= 2 or not(tLZTeamData[M28Map.subrefLZbCoreBase])) and (not(M28Utilities.bQuietModActive) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] < 0.3) then
                if bDebugMessages == true then LOG(sFunctionRef..': Stalling E so dont want more factories at the moment as already have at least one') end
            else
                --If core base then make sure we have an air fac
                if tLZTeamData[M28Map.subrefLZbCoreBase] and bCanBuildAirFac and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 2 and not(iAirFacsInZone) and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                    iAirFacsInZone = 0
                    iLandFacsInZone = 0
                    local tFactoriesInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tFactoriesInZone) == false then
                        for iFactory, oFactory in tFactoriesInZone do
                            if oFactory:GetFractionComplete() == 1 then
                                if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oFactory.UnitId) then iLandFacsInZone = iLandFacsInZone + 1
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oFactory.UnitId) then iAirFacsInZone = iAirFacsInZone + 1
                                end
                            end
                        end
                    end
                end
                if (iAirFacsInZone > 0 or not(bCanBuildAirFac)) and iLandFacsInZone > 0 then bDontWantDueToUnitCap = true end

                --Have we failed to build something at existing land and air factories recently?
                if bDebugMessages == true then LOG(sFunctionRef..': M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; iAverageCurAirAndLandFactories='..iAverageCurAirAndLandFactories..'; Map size='..(M28Map.iMapSize or 'nil')..'; % Stored='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] or 'nil')..'; AIx='..(M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier] or 'nil')..'; Gross mass='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] or 'nil')..'; Time of last stall='..(M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] or 'nil')..'; Highest air fac tech='..(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] or 'nil')..'; Mex count by tech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; Time of last energy stall='..(M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or 'nil')..'; Team has air control='..tostring(TeamHasAirControl(iTeam))..'; iAirFacsInZone (if calculated)='..(iAirFacsInZone or 'nil')..'; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] or false)) end
                if iAirFacsInZone == 0 and tLZTeamData[M28Map.subrefLZbCoreBase] and DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) then
                    if bDebugMessages == true then LOG(sFunctionRef..': we have a core base with no air fac so want to rebuild it') end
                    bWantMoreFactories = true
                elseif iAverageCurAirAndLandFactories >= 2 and ((GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForLandFactory] or -100)) <= 10 and (TeamHasLowMass(iTeam) or GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeLandFacHadNothingToBuild] or -100) <= 10)) and ((GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForAirFactory] or -100)) <= 10 or not(DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData))) then
                    --Dont want more factories
                    if bDebugMessages == true then LOG(sFunctionRef..': Failed ot build anythign at land factory recently, and either failed to build at air factory or want land fac instead of air fac') end
                    --Lots of facs and are stalling
                elseif iAverageCurAirAndLandFactories >= 4 and ((M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] <= 50 and not(bIgnoreMainEcoConditions)) or (M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] and (not(bIgnoreMainEcoConditions) or iAverageCurAirAndLandFactories * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / 4))) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have too little mass stored and atl east 4 factories per player so wont build more even if we lack air') end
                    --Reached experimental stage of game and have <20% mass stored
                elseif iAverageCurAirAndLandFactories >= 4 and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= 2 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.2 or TeamHasLowMass(iTeam)) and (M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= 4 or M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] or 0) <= 30) and not(M28Team.tTeamData[iTeam][M28Team.refbBuiltParagon]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont get more factories than already have as have built several experimentals') end
                    --Teamgame with high number of factories
                elseif iTeamCount > 1 and iAverageCurAirAndLandFactories >= 3 and iAverageCurAirAndLandFactories * iTeamCount >= 10 and iAverageCurAirAndLandFactories >= (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] or 0) * (tiFactoryToMassByTechRatioWanted[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] or 0) and TeamHasLowMass(iTeam) then
                    --Dont want more factories
                    if bDebugMessages == true then LOG(sFunctionRef..': Have lots of factories in teamgame and have low mass so dont want more') end
                    --More air fac if enemy or us has large air to ground threat and we dont have air control, and have good gross eco (regardless of current eco)
                elseif iAverageCurAirAndLandFactories <= math.max(M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat], M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiOurBomberThreat]) * 0.003 / M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] and M28Map.iMapSize >= 512 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.1 or iAverageCurAirAndLandFactories * 2.25 * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier] <= M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] - 3) and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] or -100) >= 10 and (M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] > 0 or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 500 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech]) and not(TeamHasAirControl(iTeam)) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 6 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or -100) >= 10 and (not(bCanBuildAirFac) or GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForAirFactory] or -100) > 10) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy has large air to ground threat so want more factories (on the assumption we will end up getting more air factories) to deal with it') end
                    bWantMoreFactories = true
                elseif not(TeamHasAirControl(iTeam)) and bCanBuildAirFac and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 and DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 1000 or iAverageCurAirAndLandFactories < tiFactoryToMassByTechRatioWanted[3] * 0.5 * M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                    bWantMoreFactories = true
                elseif bCanBuildAirFac and (M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeAir] or 0) / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] < 1 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForAirFactory] or -100) > 10  and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) then
                    --Fewer than 1 air fac per player; if have no air facs in this zone then get more factories
                    bWantMoreFactories = true
                elseif iAverageCurAirAndLandFactories >= 3 and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= 1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.4 and ( M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.05 or not(DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData))) then
                    if bDebugMessages == true then LOG(sFunctionRef..': We have constructed at least 1 experimental and arent about to overflow mass so wont get any more factories') end
                elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 250 and ZoneWantsT1Spam(tLZTeamData, iTeam) then
                    if bDebugMessages == true then LOG(sFunctionRef..': In t1 spam mode with at least 250 mass stored so want more factories') end
                    bWantMoreFactories = true
                elseif (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.6 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] or -120) >= 120 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or -120) >= 120 and (GetGameTimeSeconds() >= 300 or GetGameTimeSeconds() >= 300 / M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier]))
                        or ((iCurIsland == iEnemyIsland or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 or iAverageCurAirAndLandFactories <= (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] or 0) * (tiFactoryToMassByTechRatioWanted[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] or 0))
                        and     (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.05 or
                        (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.01 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) == false and table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) >= 3))
                        and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.4 or (iAverageCurAirAndLandFactories <= math.max(4 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount], M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * tiFactoryToMassByTechRatioWanted[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]])) or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 and GetGameTimeSeconds() <= 600))) then
                    --If enemy has a firebase then dont want more factories if dont have lots of mass
                    if not(WantToEcoDueToEnemyFirebase(iTeam, tLZTeamData, iPlateau)) then
                        --Do we have the energy to support another factory?
                        if bDebugMessages == true then LOG(sFunctionRef..': iAverageCurAirAndLandFactories='..iAverageCurAirAndLandFactories..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]..'; Playable area iMapSize='..M28Map.iMapSize..' Team mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]) end

                        --Small map specific - want loads of land factories
                        if M28Map.iMapSize <= 256 and iAverageCurAirAndLandFactories <= M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * tiFactoryToMassByTechRatioWanted[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 30 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0) then
                            bWantMoreFactories = true

                        elseif iAverageCurAirAndLandFactories >= 2 and not(bIgnoreMainEcoConditions) and iCurIsland == iEnemyIsland and ((M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeAir] or 0) > 0 and HaveLowPower(iTeam)) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.6 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= 0.5 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < 1) and (not(M28Utilities.bQuietModActive) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= 0.2 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] <= -10) then
                            --Dont want more factories
                            if bDebugMessages == true then LOG(sFunctionRef..': Have low power so dont want more factories') end

                            --Cap on no. of factories on larger maps
                        elseif iAverageCurAirAndLandFactories >= 4 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] < 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] > 0 and M28Map.iMapSize > 256 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] < 8000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= math.min(0.75, 0.25 + 0.05 * iAverageCurAirAndLandFactories) and (M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] > 0 or M28Team.iPlayersAtGameStart >= 5 or iAverageCurAirAndLandFactories >= 10 or iAverageCurAirAndLandFactories * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / 4 or (not(bIgnoreMainEcoConditions) and TeamHasLowMass(iTeam))) then --1 t3 land fac is 2.4 mass per tick; if want to allow 50% of mass going on land/air, then means want 5 gross mass income per fac
                            --Dont want more factories
                            if bDebugMessages == true then LOG(sFunctionRef..': Cap on number of factories for larger maps, M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount]='..M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; iAverageCurAirAndLandFactories='..iAverageCurAirAndLandFactories) end
                        elseif iAverageCurAirAndLandFactories < 2 and (iAverageCurAirAndLandFactories * 0.8 < M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 200) then
                            if bDebugMessages == true then LOG(sFunctionRef..': We have equiv of 3 mexes per player or 200 mass stored so want at least 2 factories') end
                            bWantMoreFactories = true
                            --If we dont have at least 25% mass stored, do we have an enemy in the same plateau as us who is within 350 land travel distance (225 if cant path by land)?
                        elseif (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.25 and not(bIgnoreMainEcoConditions)) or (iAverageCurAirAndLandFactories == 1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.4 and GetGameTimeSeconds() <= 300) then
                            --Just get nearest enemy base
                            local iStartPlateau, iStartLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tLZTeamData[M28Map.reftClosestEnemyBase])
                            if iStartPlateau == iPlateau and iStartLandZone > 0 then
                                local iTravelDist = (M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iStartLandZone) or 10000)
                                if iTravelDist <= 350 and (iTravelDist <= 225 or NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) == tLZData[M28Map.subrefLZIslandRef]) then
                                    bWantMoreFactories = true
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': iTravelDist='..iTravelDist..'; This island='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..'; Closest enemy base island='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) or 'nil')) end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if have enemy within 350 of us, bWantMoreFactories after this check='..tostring(bWantMoreFactories)) end
                            --Can only path to enemy with navy, and we lack T3 air, and have <50% mass stored - then dont get more facs at core base
                        elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] < 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.5 and not(iCurIsland == iEnemyIsland) and tLZTeamData[M28Map.subrefLZbCoreBase] and (iAverageCurAirAndLandFactories >= 3 or not(DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData))) then
                            if bDebugMessages == true then LOG(sFunctionRef..': No more facs at core base as not at risk of overflowing and want to consderve resources for navy') end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Want more factories general') end
                            bWantMoreFactories = true
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': We dont have enough eco to justify more factories due to enemy firebase, bIgnoreMainEcoConditions='..tostring(bIgnoreMainEcoConditions or false)) end
                        if bIgnoreMainEcoConditions then bWantMoreFactories = true end
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': We dont have enough eco to justify more factories, bIgnoreMainEcoConditions='..tostring(bIgnoreMainEcoConditions or false)) end
                    if bIgnoreMainEcoConditions then bWantMoreFactories = true end
                end
            end
        end
    end
    --Exception - get more factories if base level of mass income per brain
    if not(bWantMoreFactories) and not(bDontWantDueToUnitCap) and iAverageCurAirAndLandFactories == 1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2 then
        if bDebugMessages == true then LOG(sFunctionRef..': We have at least 20 mass per sec so want to have more than 1 factory') end
        bWantMoreFactories = true
    end
    --decent eco and air fac count is < 1 on average in teamgame (ie want every player to consider getting air fac) and dealing with core base
    if not(bWantMoreFactories) and iTeamCount > 1 and bCanBuildAirFac and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 8 * iTeamCount and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 100 and tLZTeamData[M28Map.subrefLZbCoreBase] and not(HaveLowPower(iTeam)) then
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            local tAirFacs = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tAirFacs) then

                bWantMoreFactories = true
                if bDebugMessages == true then LOG(sFunctionRef..': Want to build more land factories as have no air fac in this zone, bCanBuildAirFac='..tostring(bCanBuildAirFac or false)) end
            end
        end
    end
    if bWantMoreFactories then
        --Double-check - if we would want an air fac, and already have one, and arent at T2 air yet, then dont get more factories unless we have at least 40% stored mass and 99% energy
        if iAverageCurAirAndLandFactories >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] == 1 and DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) then
            local iAirFacsInLZ = 0
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                local tFriendlyAirFac = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if M28Utilities.IsTableEmpty(tFriendlyAirFac) == false then
                    for iAirFac, oAirFac in tFriendlyAirFac do
                        if M28UnitInfo.IsUnitValid(oAirFac) and oAirFac:GetFractionComplete() == 1 then
                            iAirFacsInLZ = iAirFacsInLZ + 1
                        end
                    end
                end
            end
            if iAirFacsInLZ >= 1 and (iAirFacsInLZ >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.4 or ((iAirFacsInLZ >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.55) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= 0.9)) then
                bWantMoreFactories = false
                if bDebugMessages == true then LOG(sFunctionRef..': We already have '..iAirFacsInLZ..' air fac and dont have t2 air yet, so will hold off getting more air facs') end
            end
        end
    end

    --More factories in cases where overflowing and have no T3 engineers or active upgrades (e.g. campaign missions with unit restrictions)
    if not(bWantMoreFactories) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.99 and tLZTeamData[M28Map.subrefLZbCoreBase] and iAverageCurAirAndLandFactories <= 15 and not(HaveLowPower(iTeam)) then
        bWantMoreFactories = true
        if bDebugMessages == true then LOG(sFunctionRef..': Overflowing mass with no t3 engineers so want to build more factories') end
    end

    --AI personality adjustments - get fewer factories for certain AI types
    if bWantMoreFactories and aiBrain[M28Economy.refiOurHighestAirFactoryTech] > 0 and aiBrain[M28Economy.refiOurHighestLandFactoryTech] > 0 then
        --Tech and turtle, and navy (except for water zones, but i think this condition is only used for land zones) - dont want as many
        if aiBrain[M28Overseer.refbPrioritiseHighTech] or aiBrain[M28Overseer.refbPrioritiseDefence] then
            --Only get more if have lots of mass
            if aiBrain:GetEconomyStoredRatio('MASS') < 0.2 or (aiBrain:GetEconomyStoredRatio('MASS') < 0.35 and aiBrain[M28Economy.refiNetMassBaseIncome] < 0) then
                if aiBrain[M28Overseer.refbPrioritiseDefence] or aiBrain[M28Economy.refiOurHighestAirFactoryTech] < 3 or aiBrain[M28Economy.refiOurHighestLandFactoryTech] < 3
                        --Naval facs - want to get more land/air facs if we have lost navy
                        or (aiBrain[M28Overseer.refbPrioritiseNavy] and iPlateau > 0 and (aiBrain[M28Economy.refiOurHighestFactoryTechLevel] < 3 or aiBrain[M28Economy.refiOurHighestNavalFactoryTech] > 0 or (GetGameTimeSeconds() <= 600 and GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryNavalFactory) == 0))) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont want more facs as want to tech or turtle, unless this zone has no factories') end
                    bWantMoreFactories = false
                    if not(iLandFacsInZone) or not(iAirFacsInZone) then
                        iLandFacsInZone = 0
                        iAirFacsInZone = 0
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                            local tFriendlyFactory = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                            if M28Utilities.IsTableEmpty(tFriendlyFactory) == false then
                                for iUnit, oUnit in tFriendlyFactory do
                                    if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) then
                                        iLandFacsInZone = iLandFacsInZone + 1
                                    else
                                        iAirFacsInZone = iAirFacsInZone + 1
                                    end
                                end
                            end
                        end
                    end
                    if iLandFacsInZone + iAirFacsInZone == 0 then
                        bWantMoreFactories = true --i.e. revert back to previous conclusion
                    end
                end
            end
        end
    end

    --Override - if we dont have a HQ for the factory type then want to rebuild it
    if not(bWantMoreFactories) and ((M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] == 0 and bCanBuildAirFac) or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] == 0) then
        --Is it likely we have built and then lost the factory?
        if bCanBuildAirFac and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] == 0 and (M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeAir] or 0) > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': Want to rebuild air factory as have no HQ') end
            bWantMoreFactories = true
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] == 0 and (M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeLand] or 0) > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': Want to rebuild land factory as have no HQ') end
            bWantMoreFactories = true
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bWantMoreFactories='..tostring(bWantMoreFactories)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bWantMoreFactories
end

function GetActiveMexUpgrades(tLZTeamData)
    local iActiveMexUpgrades = 0
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoActiveUpgrades]) == false then
        for iUpgrade, oUpgrade in tLZTeamData[M28Map.subreftoActiveUpgrades] do
            if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUpgrade.UnitId) then iActiveMexUpgrades = iActiveMexUpgrades + 1 end
        end
    end
    return iActiveMexUpgrades
end

function CanUnitUseOvercharge(aiBrain, oUnit, tLZTeamDataIfACU)
    --For now checks if enough energy and not underwater and not fired in last 5s; separate function used as may want to expand this with rate of fire check in future
    local sFunctionRef = 'CanUnitUseOvercharge'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local bCanUseOC = false
    if oUnit and (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then --and (oUnit[M28UnitInfo.refiFailedOCCount] or 0) < 2 then
        local oBP = oUnit:GetBlueprint()
        local iEnergyNeeded
        if GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastOverchargeShot] or -100) >= 5 then
            local bHaveOverchargeWeapon = false
            for iWeapon, oWeapon in oBP.Weapon do
                if oWeapon.OverChargeWeapon then
                    bHaveOverchargeWeapon = true
                    if oWeapon.EnergyRequired then
                        iEnergyNeeded = oWeapon.EnergyRequired
                        break
                    end
                end
            end

            if bHaveOverchargeWeapon then
                if aiBrain:GetEconomyStored('ENERGY') >= (iEnergyNeeded or 7500) then bCanUseOC = true end
                if bDebugMessages == true then LOG(sFunctionRef..': iEnergyNeeded='..iEnergyNeeded..'; aiBrain:GetEconomyStored='..aiBrain:GetEconomyStored('ENERGY')..'; bCanUseOC='..tostring(bCanUseOC)) end
                if bCanUseOC == true then
                    --Check if underwater
                    local oUnitPosition = oUnit:GetPosition()
                    local iHeightAtWhichConsideredUnderwater = M28Map.IsUnderwater(oUnitPosition, true) + 0.25 --small margin of error
                    local tFiringPositionStart = M28Logic.GetDirectFireWeaponPosition(oUnit)
                    if tFiringPositionStart then
                        local iFiringHeight = tFiringPositionStart[2]
                        if iFiringHeight <= iHeightAtWhichConsideredUnderwater then
                            if bDebugMessages == true then LOG(sFunctionRef..': ACU is underwater; iFiringHeight='..iFiringHeight..'; iHeightAtWhichConsideredUnderwater='..iHeightAtWhichConsideredUnderwater) end
                            bCanUseOC = false
                        end
                    end
                else
                    --Cant use overcharge due to lack of energy - do we want to flag as such for power stall purposes?
                    local iTeam = aiBrain.M28Team
                    if bDebugMessages == true then LOG(sFunctionRef..': Team gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Active M28 brain count='..M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]..'; Economy stored ratio='..aiBrain:GetEconomyStoredRatio('ENERGY')..'; Mex E storage='..aiBrain[M28Economy.refiMaxEnergyStorage]..'; iEnergyNeeded='..(iEnergyNeeded or 'nil')..'; Is tLZTeamDataIfACU nil='..tostring(tLZTeamDataIfACU == nil)) end
                    if tLZTeamDataIfACU and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 50 + 20 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and aiBrain:GetEconomyStoredRatio('ENERGY') <= 0.9 and aiBrain[M28Economy.refiMaxEnergyStorage] >= (iEnergyNeeded or 7500) and EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                        --Is ACU in dangerous zone?
                        if tLZTeamDataIfACU[M28Map.subrefLZThreatEnemyMobileDFTotal] >= 400 and (tLZTeamDataIfACU[M28Map.subrefLZThreatEnemyMobileDFTotal] >= 1000 or M28UnitInfo.GetUnitHealthPercent(oUnit) <= 0.75) then
                            --Do we have dangerous enemies within our combat range that we could be overcharging?
                            local tNearbyEnemies = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat * categories.RECLAIMABLE, oUnit:GetPosition(), oUnit[M28UnitInfo.refiDFRange], 'Enemy')
                            if M28Utilities.IsTableEmpty(tNearbyEnemies) == false then
                                --Need to get power asap
                                M28Team.tTeamData[iTeam][M28Team.refiTimeLastNeededEnergyForOvercharge] = GetGameTimeSeconds()
                                if bDebugMessages == true then LOG(sFunctionRef..': Flagging we need power asap for overcharge') end
                            end
                        end
                    end
                end
            elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then M28Utilities.ErrorHandler('Dealing with an ACU with ID '..oUnit.UnitId..' but dont think it has an overcharge weapon')
            end
        elseif bDebugMessages == true then LOG(sFunctionRef..': Has been less tahn 5s since last overcharged')
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bCanUseOC
end

function WantToEcoDueToEnemyFirebase(iTeam, tLZTeamData, iPlateau)
    local bEnemyHasFirebaseAwayFromCoreLZ = false --true if enemy both has a firebase, and we dont have a firebase in range of this LZ or a core LZ
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau]) == false then
        bEnemyHasFirebaseAwayFromCoreLZ = true
        for iFBLZ, tSubtable in M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau] do
            if tSubtable[M28Team.subrefbInRangeOfCoreLZ] then bEnemyHasFirebaseAwayFromCoreLZ = false end
        end
        if bEnemyHasFirebaseAwayFromCoreLZ then
            --If we have any <T3 mexes in this LZ then eco
            if tLZTeamData[M28Map.subrefMexCountByTech][1] + tLZTeamData[M28Map.subrefMexCountByTech][2] > 0 then
                if TeamHasLowMass(iTeam) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.4 then
                    return true
                end
            end
        end
    end
    return false
end

function HaveEnoughThreatToAttack(iPlateau, iLandZone, tLZData, tLZTeamData, iOurCombatThreat, iEnemyCombatThreat, iFirebaseThreatAdjust, bHaveSignificantCombatCloserToFirebase, iTeam, iOptionalOverrideDefaultThreatRatioWanted)
    local sFunctionRef = 'HaveEnoughThreatToAttack'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end



    local iDefaultThreatRatioWanted = iOptionalOverrideDefaultThreatRatioWanted or 1.4

    if bDebugMessages == true then LOG(sFunctionRef..': Deciding if have enough combat threat to attack, iOurCombatThreat='..iOurCombatThreat..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; iFirebaseThreatAdjust='..iFirebaseThreatAdjust..'; bHaveSignificantCombatCloserToFirebase='..tostring(bHaveSignificantCombatCloserToFirebase)..'; iTeam='..(iTeam or 'nil')..'; LZ value='..tLZTeamData[M28Map.subrefLZTValue]..'; Map size='..M28Map.iMapSize..'; Time='..GetGameTimeSeconds()..'; subrefLZSValue='..tLZTeamData[M28Map.subrefLZSValue]..'; tLZTeamData[M28Map.refiModDistancePercent]='..tLZTeamData[M28Map.refiModDistancePercent]) end
    if iOurCombatThreat > iEnemyCombatThreat * iDefaultThreatRatioWanted then
        if bDebugMessages == true then LOG(sFunctionRef..': Have more than the default threat ratio wanted') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    elseif  iOurCombatThreat > iEnemyCombatThreat and ((iFirebaseThreatAdjust > 0 and bHaveSignificantCombatCloserToFirebase) or (iOurCombatThreat > (iEnemyCombatThreat + iFirebaseThreatAdjust) * 0.9 and (tLZTeamData[M28Map.subrefLZTValue] > iOurCombatThreat * 0.5 or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false)) or (M28Map.iMapSize <= 256 and tLZTeamData[M28Map.refiModDistancePercent] <= 0.55 and tLZTeamData[M28Map.subrefLZSValue] > 0)) then
        if bDebugMessages == true then LOG(sFunctionRef..': Have more threat than the enemy') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    elseif tLZTeamData[M28Map.subrefLZbCoreBase] and iOurCombatThreat > iEnemyCombatThreat * 0.8 then
        if bDebugMessages == true then LOG(sFunctionRef..': Core base so applying a lower threshold to attack the enemy') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
        --Wnat to be more aggressive if we have friendly buildings in the zone or engineers and we have a chance of beating the enemy
    elseif iOurCombatThreat >= iEnemyCombatThreat and iFirebaseThreatAdjust == 0 and ((tLZTeamData[M28Map.subrefLZSValue] or 0) > 0 or (iEnemyCombatThreat <= 200 and (tLZTeamData[M28Map.subrefLZTValue] >= iOurCombatThreat or (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false)))) then
        if bDebugMessages == true then LOG(sFunctionRef..': Have a chance of beating enemy and friendly buildings') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    elseif M28Team.tTeamData[iTeam][M28Team.refbDontHaveBuildingsOrACUInPlayableArea] then
        if bDebugMessages == true then LOG(sFunctionRef..': Dont have any buildings left so might as well attack') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    elseif IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets]) and AreAnyOfTableOfUnitsInAdjacentLandZone(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets], iPlateau, iLandZone, tLZData, tLZTeamData, iTeam) then
        if bDebugMessages == true then LOG(sFunctionRef..': Have snipe target nearby so want to target as high priority') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    elseif iOurCombatThreat >= 15000 and iOurCombatThreat > (iEnemyCombatThreat + iFirebaseThreatAdjust) * 0.9 and (M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure]) == false) then
        --Does enemy have gameender or lots of T3 arti? in which case want to lower threshold
        if M28Team.tTeamData[iTeam][M28Team.refiEnemyT3ArtiCount] + M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] * 0.5 >= 3 then
            local iEnemyArtiCount = 0
            if bDebugMessages == true then LOG(sFunctionRef..': Enemy has gameender or t3 arti so will be more aggressive') end
            for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure] do
                if M28UnitInfo.IsUnitValid(oUnit) then
                    if oUnit:GetFractionComplete() >= 0.8 then
                        if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder, oUnit.UnitId) then
                            iEnemyArtiCount = iEnemyArtiCount + 3
                        else
                            iEnemyArtiCount = iEnemyArtiCount + 1
                        end
                        if iEnemyArtiCount >= 3 then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyMobileSatellites]) == false then
                local iNovaxCount = 0
                for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyMobileSatellites] do
                    iNovaxCount = iNovaxCount + 1
                end
                iEnemyArtiCount = math.max(iEnemyArtiCount, iNovaxCount * 0.5)
                if iEnemyArtiCount >= 3 then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)
    --Returns true if want an air factory - to be used where we want more production, so we can decide whether to get +1 air fac or +1 land fac

    local sFunctionRef = 'DoWeWantAirFactoryInsteadOfLandFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --First check in case of unit restrictions
    if M28Overseer.bAirFactoriesCantBeBuilt then
        if bDebugMessages == true then LOG(sFunctionRef..': Air factories seem to be disabled so wont try to build') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false
    else
        local iLandFactoriesHave = 0
        if (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] or 0) > 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            local tLandFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if bDebugMessages == true then LOG(sFunctionRef..': Is tLandFactories empty='..tostring(M28Utilities.IsTableEmpty(tLandFactories))) end
            if M28Utilities.IsTableEmpty(tLandFactories) == false then
                iLandFactoriesHave = table.getn(tLandFactories)
            end
        end
        local aiBrain = ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]]
        if bDebugMessages == true then LOG(sFunctionRef..': Near start, iLandFactoriesHave='..iLandFactoriesHave..'; Highest air fac tech='..(ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Economy.refiOurHighestAirFactoryTech] or 'nil')..'; bGoingSecondAir='..tostring(ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Economy.refbGoingSecondAir] or false)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Focus on T1 spam='..tostring(M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam] or false)) end

        --Early game where ACU wants to go second air - build air fac if low on mass to avoid a case where we stall mass while trying to build 2 different factories at once
        if GetGameTimeSeconds() <= 240 then
            if bDebugMessages == true then LOG(sFunctionRef..': Mass stored for brain '..aiBrain.Nickname..'='..aiBrain:GetEconomyStored('MASS')..'; Net mass income='..aiBrain[M28Economy.refiNetMassBaseIncome]..'; aiBrain[M28Economy.refiGrossMassBaseIncome]='..aiBrain[M28Economy.refiGrossMassBaseIncome]) end
            if aiBrain[M28Economy.refiOurHighestAirFactoryTech] == 0 and aiBrain[M28Economy.refbGoingSecondAir] and aiBrain:GetEconomyStored('MASS') <= 40 and aiBrain[M28Economy.refiNetMassBaseIncome] < 0 and aiBrain[M28Economy.refiGrossMassBaseIncome] < 2 and M28Map.iMapSize >= 512 and iLandFactoriesHave > 0 and not(M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam]) and not(aiBrain[M28Overseer.refbPrioritiseLowTech]) then
                --We have a land fac and no air fac, and are in the early game; get the ACU and if it is still doing its initial build order, then check if it is trying to build a land or an air fac
                if bDebugMessages == true then LOG(sFunctionRef..': Want to go second air') end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            end
        end

        --Air personality - get air; land personality - get land if have air
        if aiBrain[M28Overseer.refbPrioritiseAir] and iLandFactoriesHave > 0 and aiBrain[M28Economy.refiOurHighestLandFactoryTech] > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': Assigned brain is air, so want to get air fac') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        elseif aiBrain[M28Overseer.refbPrioritiseLand] and aiBrain[M28Economy.refiOurHighestAirFactoryTech] > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': Assigned brain is land, so want to get land fac') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return false
        end


        --Recently failed to build anything at air fac, and either dont have low power or are on the same island as the nearest enemy base, or have dangerous enemies nearby, or are overflowing mass
        if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForAirFactory] or -100) <= 10 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] or 0) > 0
                and ((GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeAirFacHadNothingToBuild] or -100) <= 5 or tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) or (not(HaveLowPower(iTeam) and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForAirFactory] or -100) <= 1.5)))
                and (tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or iLandFactoriesHave < 3 or NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint]) == NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= math.min(0.5 + 0.1 * iLandFactoriesHave, 0.95)))
        then
            if bDebugMessages == true then LOG(sFunctionRef..': Recently failed to find anything to build for air factory so will get land factory instead') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return false
        else
            --Norush
            if M28Overseer.bNoRushActive and M28Overseer.iNoRushTimer - GetGameTimeSeconds() >= 30 then

                if bDebugMessages == true then LOG(sFunctionRef..': No rush mode is active, iLandFactories='..iLandFactoriesHave) end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                if iLandFactoriesHave >= 1 then return true else return false end
            else
                if iLandFactoriesHave >= 1 and M28Map.bIsLowMexMap and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 2 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] == 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': low eco want air fac') end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                else
                    --Late game - get lots of air facs
                    if iLandFactoriesHave >= 1 and (not(M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) or (M28Utilities.bQuietModActive and M28Team.tTeamData[iTeam][M28Team.refiGunshipLosses] < math.max(20000, M28Team.tTeamData[iTeam][M28Team.refiGunshipKills] * 1.2))) and (M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= 2 or (M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false and (M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= 1 or table.getn(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) >= 2))) then
                        if bDebugMessages == true then LOG(sFunctionRef..': In late game, enemy has experimentals or we do, and we already have al and fac, so want to focus on air') end
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return true
                        --Also get lots of air facs if we have high gunship/bomber threat and lack air control
                    elseif iLandFactoriesHave >= 1 and M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiOurBomberThreat] >= 15000 and not(TeamHasAirControl(iTeam)) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 and (M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= 1 or iLandFactoriesHave >= 3) and (not(M28Utilities.bLoudModActive) or iLandFactoriesHave >= 4) then
                        if bDebugMessages == true then LOG(sFunctionRef..': T3 air, lack air contorl, and have isgnificant gunship/bomber threat, so want more air facs') end
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return true
                    else

                        local iOurIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint])
                        if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Is this core base='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase] or false)..'; iOurIsland='..iOurIsland..'; Closest friendly base island='..NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestFriendlyBase])) end
                        if tLZTeamData[M28Map.subrefLZbCoreBase] or iOurIsland == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestFriendlyBase]) then
                            --If are low on power and can path to enemy with land that isn't far away and dont have T2 air yet but do have t1 air then get land factory; also get land if air facs arent able to build air units and we have lots of mass
                            local iEnemyIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase])
                            local iOurPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tLZData[M28Map.subrefMidpoint])
                            local iEnemyPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tLZTeamData[M28Map.reftClosestEnemyBase])
                            local iLandFactoriesHave = 0
                            local iAirFactoriesForEveryLandFactory = 1
                            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                local tLandFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                if M28Utilities.IsTableEmpty(tLandFactories) == false then
                                    for iFactory, oFactory in tLandFactories do
                                        if M28UnitInfo.IsUnitValid(oFactory) and oFactory:GetFractionComplete() == 1 then iLandFactoriesHave = iLandFactoriesHave + 1 end
                                    end
                                end
                            end

                            if bDebugMessages == true then LOG(sFunctionRef..': iOurIsland='..iOurIsland..'; iEnemyIsland='..(iEnemyIsland or 'nil')..'; iOurPlateau='..iOurPlateau..'; iEnemyPlateau='..(iEnemyPlateau or 'nil')..'; air fac tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]) end
                            --If already ahve an air fac (or 5km map) then consider building land fac if we have fewer than 3 land facs or dont have full energy, or have less gross energy than when our air facs last failed ot build air:
                            if (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] > 0 or M28Map.iMapSize < 512) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= 0.9 or iLandFactoriesHave < 2 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0)) and
                                    --Also require 1 of the following:
                                    --Same island as enemy base with fewer than 4 land facs
                                    ((iOurIsland == iEnemyIsland and iLandFactoriesHave < 4 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] < 3 or M28Map.iMapSize < 512)) or
                                            --alternatively, same plateau as enemy, and low energy
                                            (iOurPlateau == iEnemyPlateau and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0) and ((iLandFactoriesHave < 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.4) or (iLandFactoriesHave < 4 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.65)))) then
                                if bDebugMessages == true then LOG(sFunctionRef..': We want land fac1') end
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return false
                            else
                                --Are in core base or we are in same island as core base
                                local iLandFactoriesWantedBeforeAir = 1

                                if bDebugMessages == true then LOG(sFunctionRef..': iLandFactoriesHave='..iLandFactoriesHave) end
                                if iLandFactoriesHave < 1 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': We want land fac2') end
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                    return false
                                else
                                    --How many land factories do we want
                                    if not(iOurIsland == iEnemyIsland) then
                                        if not(iOurPlateau == iEnemyPlateau) and iLandFactoriesHave >= 2 then
                                            --cant path to enemy even with amphibious so land facs are only for engis, so want max of 2
                                            if bDebugMessages == true then LOG(sFunctionRef..': We want air fac1') end
                                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                            return true
                                        else
                                            --Cant path to enemy except with amphibious, so dont want lots of land factories
                                            iLandFactoriesWantedBeforeAir = 1
                                            --Exception if low gross power
                                            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 22 then
                                                iLandFactoriesWantedBeforeAir = 2
                                            end
                                            iAirFactoriesForEveryLandFactory = 5
                                            if bDebugMessages == true then LOG(sFunctionRef..': We cant path to enemy by land so eant lots if air relative to land') end
                                        end
                                    else
                                        --Can path to enemy with land, base number of factories wanted on distance to enemy base
                                        local iEnemyBaseDist = M28Utilities.GetDistanceBetweenPositions(  tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase])
                                        --Campaign - enemy base location can be messed up, at higher tech levels treat base as furhter away so we get more air instead of land
                                        if M28Map.bIsCampaignMap and iEnemyBaseDist < 500 and M28Map.iMapSize >= 512 and iLandFactoriesHave >= 2 then
                                            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 2 then
                                                iEnemyBaseDist = math.max(iEnemyBaseDist, M28Map.iMapSize * 0.75)
                                            end
                                        end
                                        if iEnemyBaseDist >= 500 then
                                            if M28Map.iMapSize < 512 and iEnemyBaseDist <= 512 then
                                                iLandFactoriesWantedBeforeAir = 4
                                                iAirFactoriesForEveryLandFactory = 1
                                            elseif iEnemyBaseDist <= 650 and M28Map.iMapSize <= 512 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] < 3 then
                                                iLandFactoriesWantedBeforeAir = 3
                                                iAirFactoriesForEveryLandFactory = 1
                                            else
                                                -- and iEnemyBaseDist <=
                                                iLandFactoriesWantedBeforeAir = 1
                                                iAirFactoriesForEveryLandFactory = 4
                                                if M28Map.iMapSize >= 1024 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 then iAirFactoriesForEveryLandFactory = 6 end
                                            end
                                        elseif iEnemyBaseDist >= 350 then
                                            iLandFactoriesWantedBeforeAir = 2
                                            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] <= 2 or M28Map.iMapSize < 512 then
                                                iAirFactoriesForEveryLandFactory = 1
                                            else
                                                iAirFactoriesForEveryLandFactory = 4
                                            end
                                        else
                                            iLandFactoriesWantedBeforeAir = 4
                                            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] <= 1 and not(M28Map.bIsCampaignMap) then
                                                iAirFactoriesForEveryLandFactory = 0.25
                                                if M28Map.iMapSize == 256 and iEnemyBaseDist <= 210 then --Dont apply for <256 (e.g. winter duel) where if enemy goes T2 then T1 spam becomes very weak
                                                    iLandFactoriesWantedBeforeAir = 7
                                                elseif M28Map.iMapSize < 210 then --e.g. winter duel
                                                    iLandFactoriesWantedBeforeAir = 3 --will be increased to 4 below due to only being 1 M28 player
                                                end
                                            else
                                                if iEnemyBaseDist <= 250 then
                                                    --Somtimes on campaign map thenearest enemy base is messed up
                                                    if M28Map.bIsCampaignMap then
                                                        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 2 then
                                                            iAirFactoriesForEveryLandFactory = 1.25
                                                        else
                                                            iAirFactoriesForEveryLandFactory = 0.75
                                                        end
                                                    else
                                                        iAirFactoriesForEveryLandFactory = 0.5
                                                    end
                                                else
                                                    iAirFactoriesForEveryLandFactory = 3
                                                end
                                            end
                                        end
                                        if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 0 and not(TeamHasAirControl(iTeam)) then
                                            if M28Map.iMapSize <= 256 then
                                                iLandFactoriesWantedBeforeAir = math.max(math.min(2, iLandFactoriesWantedBeforeAir), iLandFactoriesWantedBeforeAir * 0.5)
                                                iAirFactoriesForEveryLandFactory = math.max(0.5, iAirFactoriesForEveryLandFactory)
                                            else
                                                iLandFactoriesWantedBeforeAir = 1
                                                iAirFactoriesForEveryLandFactory = math.min(math.max(iAirFactoriesForEveryLandFactory, 6), iAirFactoriesForEveryLandFactory * 1.5)
                                            end
                                        end
                                    end
                                    if iAirFactoriesForEveryLandFactory > 0.5 and (M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) and (not(M28Utilities.bQuietModActive) or M28Team.tTeamData[iTeam][M28Team.refiGunshipLosses] > math.max(20000, M28Team.tTeamData[iTeam][M28Team.refiGunshipKills] * 1.2)) then
                                        if NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) == tLZData[M28Map.subrefLZIslandRef] then
                                            --If enemy has significant AA threat then want to get land more than air, so apply more of a reduction
                                            local iEnemyNearbyAA = (M28Team.tLandSubteamData[ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].M28LandSubteam][M28Team.refiEnemyGroundAAThreatNearOurSide] or 0)
                                            if iEnemyNearbyAA >= 8000 or (iEnemyNearbyAA >= 3000 and iEnemyNearbyAA * 3 >= M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] +  M28Team.tTeamData[iTeam][M28Team.subrefiOurBomberThreat]) then
                                                iAirFactoriesForEveryLandFactory = 0.5
                                            else
                                                iAirFactoriesForEveryLandFactory = math.min(iAirFactoriesForEveryLandFactory, 1)
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Can path to enemy with land, iEnemyNearbyAA='..iEnemyNearbyAA..'; iAirFactoriesForEveryLandFactory='..iAirFactoriesForEveryLandFactory) end
                                        else
                                            iAirFactoriesForEveryLandFactory = math.min(iAirFactoriesForEveryLandFactory, 2)
                                        end
                                        if M28Utilities.bQuietModActive then
                                            --If we have seraphim on team will want more air to support bombers
                                            local bHaveSeraphimOnTeam = false
                                            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                                if oBrain:GetFactionIndex() == M28UnitInfo.refFactionSeraphim then
                                                    bHaveSeraphimOnTeam = true
                                                    break
                                                end
                                            end
                                            if bHaveSeraphimOnTeam then iAirFactoriesForEveryLandFactory = iAirFactoriesForEveryLandFactory * 2 end
                                        end
                                        if not(M28Team.tTeamData[iTeam][M28Team.refbHaveAirControl]) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 12000 then
                                            iAirFactoriesForEveryLandFactory = iAirFactoriesForEveryLandFactory * 1.5
                                            --[[local iNearbyEnemyGroundAAThreat = 0
                                            local tbLandSubteams = {}
                                            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                                tbLandSubteams[oBrain.M28LandSubteam] = true
                                            end
                                            for iLandSubteam, _ in tbLandSubteams do
                                                iNearbyEnemyGroundAAThreat = iNearbyEnemyGroundAAThreat + (M28Team.tLandSubteamData[iLandSubteam][M28Team.refiEnemyGroundAAThreatNearOurSide] or 0)
                                            end
                                            if iNearbyEnemyGroundAAThreat > math.max(4000, M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] * 0.25, M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat] * 0.08) + M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiOurBomberThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat] * 0.1 then
                                                iAirFactoriesForEveryLandFactory = math.min(1.5, iAirFactoriesForEveryLandFactory)
                                                if M28Map.iMapSize <= 1024 or M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) <= 800 then
                                                    iAirFactoriesForEveryLandFactory = 1
                                                end
                                            end--]]
                                        end
                                    end
                                    if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] == 1 then
                                        iLandFactoriesWantedBeforeAir = iLandFactoriesWantedBeforeAir + 1
                                        iAirFactoriesForEveryLandFactory = iAirFactoriesForEveryLandFactory * 0.8
                                    end
                                    if iLandFactoriesHave >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 1 and M28Map.bIsCampaignMap then
                                        iAirFactoriesForEveryLandFactory = math.max(iAirFactoriesForEveryLandFactory, 1)
                                        iLandFactoriesWantedBeforeAir = math.min(iLandFactoriesWantedBeforeAir, 3)
                                    end
                                    if (not(M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) or (M28Utilities.bQuietModActive and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 and M28Team.tTeamData[iTeam][M28Team.refiGunshipLosses] < math.max(20000, M28Team.tTeamData[iTeam][M28Team.refiGunshipKills] * 1.2))) and iLandFactoriesWantedBeforeAir > 3 and M28Team.tTeamData[iTeam][M28Team.subrefiLowestFriendlyLandFactoryTech] >= 2 and (M28Map.iMapSize > 256 or iLandFactoriesWantedBeforeAir > 4 or M28Team.tTeamData[iTeam][M28Team.subrefiLowestFriendlyLandFactoryTech] >= 3) then
                                        iLandFactoriesWantedBeforeAir = math.max(3, iLandFactoriesWantedBeforeAir * 0.5)
                                        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] > 1 then
                                            iAirFactoriesForEveryLandFactory = math.max(iAirFactoriesForEveryLandFactory, 0.75)
                                        else
                                            iAirFactoriesForEveryLandFactory = math.max(iAirFactoriesForEveryLandFactory, 0.5)
                                        end
                                    end
                                    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] == 0 and iLandFactoriesWantedBeforeAir >= 2 then
                                        if M28Team.tTeamData[iTeam][M28Team.subrefiLowestFriendlyLandFactoryTech] >= 2 or tLZTeamData[M28Map.refbBaseInSafePosition] then
                                            iLandFactoriesWantedBeforeAir = 1
                                            --If enemy has land combat units but no airforce then consider getting air fac earlier even on smaller maps - for simplicity will just do a count of units (could consider in future refining to cycle through all nearby zones)
                                        elseif iLandFactoriesWantedBeforeAir > 2 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] == 0 and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] == 0 then
                                            local iEnemyLandCombatCount = 0
                                            local iEnemyGroundAACount = 0
                                            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
                                                iEnemyLandCombatCount = iEnemyLandCombatCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandCombat)
                                                iEnemyGroundAACount = iEnemyGroundAACount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryGroundAA)
                                            end
                                            if iEnemyLandCombatCount > iEnemyGroundAACount * 12 then
                                                iLandFactoriesWantedBeforeAir = 1
                                            end
                                        end
                                    end

                                    if bDebugMessages == true then LOG(sFunctionRef..': iAirFactoriesForEveryLandFactory='..iAirFactoriesForEveryLandFactory..'; iLandFactoriesWantedBeforeAir='..iLandFactoriesWantedBeforeAir..'; iLandFactoriesHave='..iLandFactoriesHave) end
                                    if iLandFactoriesHave < iLandFactoriesWantedBeforeAir then
                                        if bDebugMessages == true then LOG(sFunctionRef..': We want land fac3') end
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        return false
                                    else
                                        --Have min number of land factories, now check how many air factories we have
                                        local iAirFactoriesHave = 0
                                        if (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] or 0) > 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                            local tAirFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                            if M28Utilities.IsTableEmpty(tAirFactories) == false then
                                                iAirFactoriesHave = table.getn(tAirFactories)
                                            end
                                        end
                                        local iAirFactoriesWanted = math.ceil(iLandFactoriesHave * iAirFactoriesForEveryLandFactory)
                                        if bDebugMessages == true then LOG(sFunctionRef..': iAirFactoriesWanted='..iAirFactoriesWanted..'; iAirFactoriesHave='..iAirFactoriesHave..'; In t1 spam mode='..tostring(M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam])) end
                                        if iAirFactoriesHave >= 1 and ZoneWantsT1Spam(tLZTeamData, iTeam) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Want to focus on t1 spam so want more land facs') end
                                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                            return false
                                        elseif iAirFactoriesWanted > iAirFactoriesHave then
                                            --If we have 1 air fac, and want to save mass for mmls, then get land fac instead
                                            if iAirFactoriesHave > 0 and iLandFactoriesHave > 0 and iLandFactoriesHave < 7 and M28Team.tTeamData[iTeam][M28Team.subrefiLowestFriendlyLandFactoryTech] >= 2 and SaveMassForMMLOrMobileT3ArtiForFirebase(tLZData, tLZTeamData, NavUtils.GetLabel(M28Map.refPathingTypeHover, tLZData[M28Map.subrefMidpoint]), iTeam, TeamHasLowMass(iTeam)) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Want MMLs so will try and get more land facs instead of air') end
                                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                                return false
                                            else
                                                if bDebugMessages == true then LOG(sFunctionRef..': We want air fac2') end
                                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                                return true
                                            end
                                        else
                                            if bDebugMessages == true then LOG(sFunctionRef..': We want land fac4') end
                                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                            return false
                                        end
                                    end
                                end
                            end

                        else
                            --Dif island to nearest start position so presumably want land factories to take contorl of island/plateau
                            if bDebugMessages == true then LOG(sFunctionRef..': Different island to start position so want land factories to take control of the island, we want land fac5') end
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return false
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetThreatOfApproachingEnemyACUsAndNearestACU(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    --Will return the combat threat of any approaching enemy ACUs and the position of the nearest ACU (usfficiently in range); also updates the time of hte appraoching threat
    local sFunctionRef = 'GetThreatOfApproachingEnemyACUsAndNearestACU'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end

    local iTotalACUThreat = 0
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Is table of enemy ACUs empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) == false then
        local tMidpoint = tLZData[M28Map.subrefMidpoint]
        local iDistanceThreshold = math.max(math.min(M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tMidpoint) * 0.75, 250), 140)
        if M28Map.iMapSize > 256 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 4 then iDistanceThreshold = math.max(iDistanceThreshold, 175) end
        if bDebugMessages == true then LOG(sFunctionRef..': iDistanceThreshold='..iDistanceThreshold..'; iMapSize='..M28Map.iMapSize..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]..'; Dist to closest enemy base='..M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tMidpoint)) end
        local tACUsInRange = {}
        local iNearestACUDist = 100000
        local oNearestACU
        local iCurDist
        for iACU, oACU in M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs] do
            if M28UnitInfo.IsUnitValid(oACU) then
                iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tMidpoint)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy ACU '..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' owned by '..oACU:GetAIBrain().Nickname..'; iCurDist Distance to midpoint='..iCurDist..'; iDistanceThreshold='..iDistanceThreshold) end
                if iCurDist <= iDistanceThreshold then
                    table.insert(tACUsInRange, oACU)
                    if bDebugMessages == true then LOG(sFunctionRef..': Adding ACU as an in range enemy unit') end
                    if iCurDist < iNearestACUDist then
                        iNearestACUDist = iCurDist
                        oNearestACU = oACU
                    end
                end
            end
        end
        iTotalACUThreat = M28UnitInfo.GetCombatThreatRating(tACUsInRange, true)
        if bDebugMessages == true then LOG(sFunctionRef..': iTotalACUThreat='..iTotalACUThreat) end
        if iTotalACUThreat > 0 and tLZTeamData[M28Map.subrefLZbCoreBase] then
            if not(M28Team.tTeamData[iTeam][M28Team.reftCoreLZsTimeOfApproachingACUByPlateauAndZone]) then M28Team.tTeamData[iTeam][M28Team.reftCoreLZsTimeOfApproachingACUByPlateauAndZone] = {} end
            if not(M28Team.tTeamData[iTeam][M28Team.reftCoreLZsTimeOfApproachingACUByPlateauAndZone][iPlateau]) then M28Team.tTeamData[iTeam][M28Team.reftCoreLZsTimeOfApproachingACUByPlateauAndZone][iPlateau] = {} end
            M28Team.tTeamData[iTeam][M28Team.reftCoreLZsTimeOfApproachingACUByPlateauAndZone][iPlateau][iLandZone] = GetGameTimeSeconds()
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            if oNearestACU then return iTotalACUThreat, oNearestACU end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iTotalACUThreat, nil
end

function SaveMassForMMLOrMobileT3ArtiForFirebase(tLZData, tLZTeamData, iPlateau, iTeam, bHaveLowMass)
    --Returns x and y; x is true if want to build MMLs or T3 mobile arti to deal with a firebase; y is true if need T3 (e.g. dealing with ravagers)
    --If we have low mass then will prioritise building MML with what little mass we have, unless enemy has long range units (like ravagers and fatboys)
    local sFunctionRef = 'SaveMassForMMLOrMobileT3ArtiForFirebase'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bSaveMassForFirebase = false
    local bNeedT3 = false

    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, bHaveLowMass='..tostring(bHaveLowMass)..'; Is table of LR enemy DF units empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftLongRangeEnemyDFUnits]))..'; Highest firneldy land fac tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]..'; T3 mex count='..tLZTeamData[M28Map.subrefMexCountByTech][3]..'; Mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]) end
    if bHaveLowMass then
        --MML for enemy firebase, when enemy lacks fatboy/ravagers
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftLongRangeEnemyDFUnits]) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] < 3 or tLZTeamData[M28Map.subrefMexCountByTech][3] == 0 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] <= 300) then
            --Are there T2 arti in range?
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Number of T2 arti in range='..table.getn(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits])) end
                if table.getn(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) <= 6 then --If enemy has 7+ T2 arti then probably reached the point where MMLs wont cut it even in very large numbers
                    bSaveMassForFirebase = true
                end
            else
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
                    bSaveMassForFirebase = true
                else
                    --Is closest ACU an ACU with T2 and no gun?
                    local bNearbyGuncom = false
                    local bNearbyT2ACU = false
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) == false then
                        local iDistThreshold = 220
                        if M28Map.iMapSize <= 256 then iDistThreshold = 180 end
                        local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
                        for iACU, oACU in M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs] do
                            if M28UnitInfo.IsUnitValid(oACU) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy ACU owned by brain '..oACU:GetAIBrain().Nickname..'; ACU DF range='..(oACU[M28UnitInfo.refiDFRange] or 0)..'; ACU unit state='..M28UnitInfo.GetUnitState(oACU)..'; Dist from ACU to midpoint='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZData[M28Map.subrefMidpoint])) end
                                if (oACU[M28UnitInfo.refiDFRange] or 0) >= 26 then
                                    if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= iDistThreshold then
                                        if bDebugMessages == true then LOG(sFunctionRef..': enemy has nearby guncom') end
                                        bNearbyGuncom = true
                                        break
                                    end
                                    --If enemy ACU is upgrading fairnly nearby then assume it is upgrading to get T2 to be prudent
                                elseif not(bNearbyT2ACU) and (oACU:HasEnhancement('AdvancedEngineering') or oACU:HasEnhancement('T3Engineering') or ((oACU[M28ACU.refiUpgradeCount] or 0) == 0 and oACU:IsUnitState('Upgrading'))) then
                                    if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= iDistThreshold then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy Has nearby T2 ACU') end
                                        bNearbyT2ACU = true
                                    end
                                end
                            end
                        end
                        if bNearbyT2ACU and not(bNearbyGuncom) then
                            bSaveMassForFirebase = true
                        end
                    end
                end
            end
            --T3 mobile arti for if enemy has nearby ravagers and we havent built many experimentals
        elseif M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftLongRangeEnemyDFUnits]) == false and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] <= 1 then
            --Do we have ravagers in this or adjacent zone, but not fatboy or megalith?
            --First check if enemy has any ravagers, or a constructed fatboy
            local bEnemyHasRavagerSomewhere = false
            local bEnemyHasFatboySomewhere = false
            for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftLongRangeEnemyDFUnits] do
                if not(oUnit.Dead) then

                    if not(bEnemyHasRavagerSomewhere) and (oUnit[M28UnitInfo.refiDFRange] or 0) >= 60 and EntityCategoryContains(M28UnitInfo.refCategoryPD, oUnit.UnitId) then
                        bEnemyHasRavagerSomewhere = true
                        if bEnemyHasFatboySomewhere then break end
                    end
                    if not(bEnemyHasFatboySomewhere) and (oUnit[M28UnitInfo.refiDFRange] or 0) >= 80 and oUnit:GetFractionComplete() == 1 and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oUnit.UnitId) then
                        bEnemyHasFatboySomewhere = true
                        if bEnemyHasRavagerSomewhere then break end
                    end
                end
            end
            if bEnemyHasRavagerSomewhere and not(bEnemyHasFatboySomewhere) then
                local bHaveNearbyRavager = false
                function CheckIfZoneHasRavagers(tZoneTeamData)
                    if tZoneTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] > 0 and M28Utilities.IsTableEmpty(tZoneTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats]) == false then
                        for iUnit, oUnit in tZoneTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats] do
                            if not(oUnit.Dead) and oUnit[M28UnitInfo.refiDFRange] >= 60 and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) then
                                return true
                            end
                        end
                    end
                    return false
                end
                CheckIfZoneHasRavagers(tLZTeamData)
                if not(bHaveNearbyRavager) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                        local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                        CheckIfZoneHasRavagers(tAdjLZTeamData)
                        if bHaveNearbyRavager then break end
                    end
                end
                if bHaveNearbyRavager then
                    --Exception - very high LC for t3 mobile arti, suggesting enemy is able to kill them, or campaign map with T3 land but no T3 mobile arti count
                    local iArtiLC = GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryIndirect * categories.TECH3)
                    if iArtiLC == 0 and (M28Overseer.bUnitRestrictionsArePresent or M28Map.bIsCampaignMap) then
                        --Do nothing - we might not be able to build t3 arti
                    elseif iArtiLC >= 20 and iArtiLC >= 10 + 10 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                        --Do nothing - enemy might be countering with t2 arti as well
                    elseif tLZTeamData[M28Map.refbBaseInSafePosition] and M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 3 and tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] == 0 then
                        --Do nothing - in an air slot so want to prioritise air instead, and leave t3 mobile arti to other zones
                    else
                        bSaveMassForFirebase = true
                        bNeedT3 = true
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': end of code, bSaveMassForFirebase='..tostring(bSaveMassForFirebase)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bSaveMassForFirebase, bNeedT3
end

function IsLocationInNoRushArea(tLocation)
    for iStart, tStart in M28Overseer.reftNoRushM28StartPoints do
        if M28Utilities.GetDistanceBetweenPositions(tLocation, tStart) < M28Overseer.iNoRushRange then
            return true
        end
    end
    return false
end

function IsLocationInNoRushArea(tLocation)
    local sFunctionRef = 'IsLocationInNoRushArea'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end

    local bInNoRush = false
    for iStart, tStart in M28Overseer.reftNoRushM28StartPoints do
        if M28Utilities.GetDistanceBetweenPositions(tLocation, tStart) <= M28Overseer.iNoRushRange then
            if bDebugMessages == true then LOG(sFunctionRef..': Dist to tStart '..repru(tStart)..' is '..M28Utilities.GetDistanceBetweenPositions(tLocation, tStart)..' so are inside norush range') end
            bInNoRush = true
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bInNoRush
end

function NoRushPreventingHydroOrMex(tLZOrWZData, bMexNotHydro)
    --If norush is active then returns true if all unbuilt hydro points (mex points if bMexNotHydro is true) in this LZ/WZ are outside the norush radius of the nearest allied base
    local sFunctionRef = 'NoRushPreventingHydroOrMex'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end

    local sResourceRef
    if bMexNotHydro then sResourceRef = M28Map.subrefMexUnbuiltLocations
    else sResourceRef = M28Map.subrefHydroUnbuiltLocations
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Is table of hydro or mex unbuilt locations empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[sResourceRef]))..'; bMexNotHydro='..tostring(bMexNotHydro or false)) end
    if M28Utilities.IsTableEmpty(tLZOrWZData[sResourceRef]) == false then
        local bAllResourceOutsidePlayableArea = true
        for iEntry, tResource in tLZOrWZData[sResourceRef] do
            if bDebugMessages == true then LOG(sFunctionRef..': tResource='..repru(tResource)..'; Norush range='..M28Overseer.iNoRushRange..'; repru of M28Overseer.reftNoRushM28StartPoints='..repru(M28Overseer.reftNoRushM28StartPoints)) end
            if IsLocationInNoRushArea(tResource) then
                bAllResourceOutsidePlayableArea = false
                break
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return bAllResourceOutsidePlayableArea
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function IsLocationInPlayableArea(tLocation)
    if tLocation[1] > M28Map.rMapPlayableArea[1] and  tLocation[1] < M28Map.rMapPlayableArea[3] and tLocation[3] > M28Map.rMapPlayableArea[2] and  tLocation[3] < M28Map.rMapPlayableArea[4] then
        return true
    else
        return false
    end
end

function IsLocationInMap(tLocation)
    --NOT the playable area, just the map itself, e.g. for air units so can ignore updating their assigtned zone if they are outside the map entirely
    if tLocation[1] < 0 or tLocation[3] < 0 or tLocation[1] > M28Map.iMapSize or tLocation[3] > M28Map.iMapSize then
        return false
    else
        return true
    end
end

function DoesACUHaveValidOrder(oACU)
    --Checks if either hte ACU has no last order, or the last order is to build something that it cant build
    local sFunctionRef = 'DoesACUHaveValidOrder'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tLastOrders = oACU[M28Orders.reftiLastOrders]
    if bDebugMessages == true then LOG(sFunctionRef..': tLastOrders='..reprs(tLastOrders)) end
    if not(tLastOrders) then
        if bDebugMessages == true then LOG(sFunctionRef..': Last orders is empty') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false
    elseif M28Utilities.IsTableEmpty(tLastOrders) then
        if bDebugMessages == true then LOG(sFunctionRef..': Table of last orders is empty') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false
    else
        local tLastOrder = tLastOrders[oACU[M28Orders.refiOrderCount]]
        if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild then
            if bDebugMessages == true then LOG(sFunctionRef..': Last order was to build somethingw ith blueprint '..(tLastOrder[M28Orders.subrefsOrderBlueprint] or 'nil')..'; Can build='..tostring(oACU:CanBuild(tLastOrder[M28Orders.subrefsOrderBlueprint]))) end
            if oACU:CanBuild(tLastOrder[M28Orders.subrefsOrderBlueprint]) then
                --We can build last order, but are we trying to build a mex somewhere that already has a completed mex?
                if bDebugMessages == true then LOG(sFunctionRef..': We can build the blueprint, is last order to build a mex?='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryMex, tLastOrder[M28Orders.subrefsOrderBlueprint]))) end
                if EntityCategoryContains(M28UnitInfo.refCategoryMex, tLastOrder[M28Orders.subrefsOrderBlueprint]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': We are trying to build a mex, Last position='..repru(tLastOrder[M28Orders.subreftOrderPosition])..'; CanBuildOnMexLocation='..tostring(CanBuildOnMexLocation(tLastOrder[M28Orders.subreftOrderPosition]))..'; playable area='..repru(M28Map.rMapPlayableArea)..'; Dist to ACU='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLastOrder[M28Orders.subreftOrderPosition])..'; In playable area='..tostring(M28Map.InPlayableArea(tLastOrder[M28Orders.subreftOrderPosition]))) end
                    if M28Map.InPlayableArea(tLastOrder[M28Orders.subreftOrderPosition]) then
                        if CanBuildOnMexLocation(tLastOrder[M28Orders.subreftOrderPosition]) then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        else
                            --Cant build the mex, is it because there is a mex there?
                            local tUnitsNearPosition = GetUnitsInRect(M28Utilities.GetRectAroundLocation(tLastOrder[M28Orders.subreftOrderPosition], 1.8))
                            local bBlockedByCompletedMexOnOurTeam = false
                            if M28Utilities.IsTableEmpty(tUnitsNearPosition) == false then
                                local tMexesNearPosition = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tUnitsNearPosition)
                                if M28Utilities.IsTableEmpty(tMexesNearPosition) == false then
                                    for iMex, oMex in tMexesNearPosition do
                                        if oMex:GetFractionComplete() == 1 and IsAlly(oMex:GetAIBrain():GetArmyIndex(), oACU:GetAIBrain():GetArmyIndex()) then
                                            bBlockedByCompletedMexOnOurTeam = true
                                            break
                                        end
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Trying to build a mex, bBlockedByCompletedMexOnOurTeam='..tostring(bBlockedByCompletedMexOnOurTeam)) end
                            if bBlockedByCompletedMexOnOurTeam then
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return false
                            else
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return true
                            end
                        end
                    else
                        --Not in playable area
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return false
                    end
                else
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                end
            else
                --Cant build last order
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return false
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return true
end

function DoWeWantToSynchroniseMMLShots(iPlateau, iLandZone, tLZData, tLZTeamData, iTeam, iFriendlyBestMobileIndirectRange, iEnemyBestDFRange, iAvailableMMLThreat, oClosestUnitFromAllFirebases)
    --Consider synchronising shots with MML if we have enough to warrant it and they are faced with non-Aeon TMD
    local sFunctionRef = 'DoWeWantToSynchroniseMMLShots'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bConsiderSpecialMMLLogic = false
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; iPlateau '..iPlateau..'; iLandZOne '..iLandZone..'; tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield]='..(tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or 'nil')..'; iAvailableMMLThreat='..iAvailableMMLThreat..'; oClosestUnitFromAllFirebases='..(oClosestUnitFromAllFirebases.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestUnitFromAllFirebases) or 'nil')) end
    if iAvailableMMLThreat >= 700 and (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) == 0 and (iFriendlyBestMobileIndirectRange or 0) > (iEnemyBestDFRange or 0) and iFriendlyBestMobileIndirectRange > (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0) then
        local bFiredRecentlyNearTMDOrShield = false
        if GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -100) <= 30 then bFiredRecentlyNearTMDOrShield = true
        elseif oClosestUnitFromAllFirebases then
            local tFirebaseLZData, tFirebaseLZTeamData = M28Map.GetLandOrWaterZoneData(oClosestUnitFromAllFirebases:GetPosition(), true, iTeam)
            if GetGameTimeSeconds() - (tFirebaseLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -100) <= 30 then bFiredRecentlyNearTMDOrShield = true end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bFiredRecentlyNearTMDOrShield='..tostring(bFiredRecentlyNearTMDOrShield)) end
        if bFiredRecentlyNearTMDOrShield then

            local bEnemyHasAeonTMD = false --also includes loyalists and naval TMD
            local bEnemyHasNonAeonTMD = false
            function UpdateNearbyTMD(iAdjLZ)
                local tAdjLZTeamData
                if iAdjLZ == iLandZone then tAdjLZTeamData = tLZTeamData else tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam] end
                if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    local tZoneTMD = EntityCategoryFilterDown(M28UnitInfo.refCategoryTMD + categories.ANTIMISSILE * categories.MOBILE, tAdjLZTeamData[M28Map.subrefTEnemyUnits])
                    if M28Utilities.IsTableEmpty(tZoneTMD) == false then
                        bEnemyHasNonAeonTMD = true
                        if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.AEON + categories.ANTIMISSILE * categories.MOBILE, tZoneTMD)) == false then
                            bEnemyHasAeonTMD = true
                        end
                    end
                end
            end
            UpdateNearbyTMD(iLandZone)
            if not(bEnemyHasAeonTMD) then
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        UpdateNearbyTMD(iAdjLZ)
                        if bEnemyHasAeonTMD then break end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bEnemyHasAeonTMD='..tostring(bEnemyHasAeonTMD)..'; bEnemyHasNonAeonTMD='..tostring(bEnemyHasNonAeonTMD)) end
            if not(bEnemyHasAeonTMD) and bEnemyHasNonAeonTMD then
                bConsiderSpecialMMLLogic = true
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bConsiderSpecialMMLLogic='..tostring(bConsiderSpecialMMLLogic)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bConsiderSpecialMMLLogic
end

function IsTargetNearActiveNukeTarget(tTarget, iTeam, iDistThreshold, iOptionalTimeThreshold)
    --Returns true if are within iDistThreshold of an active nuke target
    local sFunctionRef = 'IsTargetNearActiveNukeTarget'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bNearTarget = false
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Is table of recently fired nuke launchers empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers]) == false then
        local iLauncherCount = table.getn(M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers])
        for iCurLauncher = iLauncherCount, 1, -1 do
            local oLauncher = M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers][iCurLauncher]
            if bDebugMessages == true then LOG(sFunctionRef..': Considering oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..'; Is launcher still valid='..tostring(M28UnitInfo.IsUnitValid(oLauncher))..'; Active nuke target='..repru(oLauncher[M28Building.reftActiveNukeTarget])) end
            if not(M28UnitInfo.IsUnitValid(oLauncher)) or not(oLauncher[M28Building.reftActiveNukeTarget]) then
                table.remove(M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers], iCurLauncher)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Launcher target='..repru(oLauncher[M28Building.reftActiveNukeTarget])..'; tTarget='..repru(tTarget)..'; Dist='..M28Utilities.GetDistanceBetweenPositions(oLauncher[M28Building.reftActiveNukeTarget], tTarget)..'; iDistThreshold='..iDistThreshold) end
                if M28Utilities.GetDistanceBetweenPositions(oLauncher[M28Building.reftActiveNukeTarget], tTarget) <= iDistThreshold then
                    bNearTarget = true
                    break
                end
            end

        end
    end
    if not(bNearTarget) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations]) == false then
        --Cycle through nuke targets from the last 60s on our team as well (since looking at the above ignores non-M28 teammates, while just looking at the reftoRecentlyFiredAlliedNukeLaunchers table ignores nukes that are about to fire but havent yet fired)
        local iTimeThreshold = GetGameTimeSeconds() - (iOptionalTimeThreshold or 60)
        for iTimeLaunched, tNukeTarget in M28Team.tTeamData[iTeam][M28Team.subrefNukeLaunchLocations] do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering launch target with iTimeLaunched='..iTimeLaunched..'; iTimeThreshold='..iTimeThreshold..'; Dist between here and tTarget='..M28Utilities.GetDistanceBetweenPositions(tTarget, tNukeTarget)) end
            if iTimeLaunched >= iTimeThreshold and M28Utilities.GetDistanceBetweenPositions(tTarget, tNukeTarget) <= iDistThreshold then
                bNearTarget = true
                break
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tTarget='..repru(tTarget)..'; bNearTarget='..tostring(bNearTarget)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bNearTarget
end

function IsTableOfUnitsStillValid(tUnits, bInvalidIfFullHealth)
    --bInvalidIfFullHealth - e.g. if have a table of units to repair, set this to true
    local sFunctionRef = 'IsTableOfUnitsStillValid'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(tUnits) == false then
        local iEntryCount = table.getn(tUnits)
        for iCurEntry = iEntryCount, 1, -1 do
            local oUnit = tUnits[iCurEntry]
            --if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Is oUnit.GetHealth nil='..tostring(oUnit.GetHealth == nil)) end
            if not(M28UnitInfo.IsUnitValid(oUnit)) or (bInvalidIfFullHealth and M28UnitInfo.GetUnitHealthPercent(oUnit) == 1) then
                if bDebugMessages == true then LOG(sFunctionRef..': Removing unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' at time '..GetGameTimeSeconds()..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; bInvalidIfFullHealth='..tostring(bInvalidIfFullHealth or false)) end
                table.remove(tUnits, iCurEntry)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Do we still have a table of valid units? is it empty='..tostring(M28Utilities.IsTableEmpty(tUnits))) end
        if M28Utilities.IsTableEmpty(tUnits) == false then
            return true
        end
    end
    return false
end

function IsPositionCloseToZoneEdge(iPlateauOrZero, iLandOrWaterZone, iMaxDistToEdgeOfAdjacentZone, tStartPoint)
    --returns true if are within iMaxDistToEdgeOfAdjacentZone of the edge of iLandOrWaterZone, i.e. if this is positive, then will return true if are anywhere in that zone, or outside it by iMaxDistToEdgeOfAdjacentZone; if is a negative number then must be inside the zone by the negativenumber amount
    --Only an approximation - does a square around the outer edges of the zone to estimate
    local tLZOrWZData

    local tMinPosition, tMaxPosition
    if iPlateauOrZero == 0 then
        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        tMinPosition = M28Map.GetPositionFromPathingSegments(tLZOrWZData[M28Map.subrefWZMinSegX], tLZOrWZData[M28Map.subrefWZMinSegZ])
        tMaxPosition = M28Map.GetPositionFromPathingSegments(tLZOrWZData[M28Map.subrefWZMaxSegX], tLZOrWZData[M28Map.subrefWZMaxSegZ])
    else
        tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        tMinPosition = M28Map.GetPositionFromPathingSegments(tLZOrWZData[M28Map.subrefLZMinSegX], tLZOrWZData[M28Map.subrefLZMinSegZ])
        tMaxPosition = M28Map.GetPositionFromPathingSegments(tLZOrWZData[M28Map.subrefLZMaxSegX], tLZOrWZData[M28Map.subrefLZMaxSegX])
    end
    local iMinX = tMinPosition[1]
    local iMaxX = tMaxPosition[1]
    local iMinZ = tMinPosition[3]
    local iMaxZ = tMaxPosition[3]
    --Really could simplify the below into just one formula, but separating it out makes it slightl yeasier to conceptualise
    if iMaxDistToEdgeOfAdjacentZone > 0 then
        --Want to be outside the box
        if tStartPoint[1] >= iMinX - iMaxDistToEdgeOfAdjacentZone and tStartPoint[1] <= iMaxX + iMaxDistToEdgeOfAdjacentZone then
            if tStartPoint[3] >= iMinZ - iMaxDistToEdgeOfAdjacentZone and tStartPoint[3] <= iMaxZ + iMaxDistToEdgeOfAdjacentZone then
                return true
            end
        end
    else
        --Wnat to be inside the zone box
        if tStartPoint[1] >= iMinX + iMaxDistToEdgeOfAdjacentZone and tStartPoint[1] <= iMaxX - iMaxDistToEdgeOfAdjacentZone then
            if tStartPoint[3] >= iMinZ + iMaxDistToEdgeOfAdjacentZone and tStartPoint[3] <= iMaxZ - iMaxDistToEdgeOfAdjacentZone then
                return true
            end
        end
    end
    return false
end

function WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iNearbyFriendlySubThreat, iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, bConsideringSubmarinesNotSurface, iOptionalThreatAbsolutePercentIncrease, iEnemyNearbySubmersibleThreat, iAvailableAntiNavyThreat)
    --iOptionalThreatAbsolutePercentIncrease - will increase enemy threat factors by this (absolute increase), e.g. set to 0.1 and instead of wanting 1.3 * enemy threat to attack, will want 1.4 * enemy threat
    local sFunctionRef = 'WantToAttackWithNavyEvenIfOutranged'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bAreInScenario2 = false
    if M28Team.tTeamData[iTeam][M28Team.refbDontHaveBuildingsOrACUInPlayableArea] then bAreInScenario2 = true
    else
        local iModMod = (iOptionalThreatAbsolutePercentIncrease or 0)
        if not(bConsideringSubmarinesNotSurface) and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
            iModMod = iModMod + 0.75
            local iRoughSurfaceThreat = iAdjacentAlliedCombatThreat + tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] - iAdjacentAlliedSubmersibleThreat
            if iRoughSurfaceThreat > 6000 then iModMod = iModMod - 0.5 * math.min(1, (iRoughSurfaceThreat / 30000)) end
        end
        local iEnemyAntiNavyMod = 1.5 + iModMod
        local iEnemyCombatModHigh = 1.3 + iModMod
        local iEnemyCombatModLow = 1.1 + iModMod
        if bDebugMessages == true then LOG(sFunctionRef..': Near start, bConsideringSubmarinesNotSurface='..tostring(bConsideringSubmarinesNotSurface)..'; iAdjacentAlliedCombatThreat='..iAdjacentAlliedCombatThreat..'; iAdjacentAlliedSubmersibleThreat='..iAdjacentAlliedSubmersibleThreat..'; iAdjacentEnemyCombatThreat='..iAdjacentEnemyCombatThreat..'; iEnemyCombatModHigh='..iEnemyCombatModHigh..'; tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]='..(tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0)..'; iEnemyCombatModLow='..iEnemyCombatModLow..'; iAdjacentEnemyAntiNavyThreat='..iAdjacentEnemyAntiNavyThreat..'; iEnemyAntiNavyMod='..iEnemyAntiNavyMod..'; iNearbyFriendlySubThreat='..iNearbyFriendlySubThreat) end
        if (bConsideringSubmarinesNotSurface and (iNearbyFriendlySubThreat >= iAdjacentEnemyAntiNavyThreat or iNearbyFriendlySubThreat >= 20000) and ((tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] or 0) * 0.8 + iAdjacentAlliedSubmersibleThreat >= 40000 or ((tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] or 0) * 0.8 + iAdjacentAlliedSubmersibleThreat > ((tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] or 0) + iAdjacentEnemyAntiNavyThreat) * iEnemyAntiNavyMod or (iAdjacentAlliedSubmersibleThreat + (tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] or 0) * 0.8 > (tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] or 0) + iAdjacentEnemyAntiNavyThreat and iAdjacentAlliedCombatThreat > iAdjacentEnemyCombatThreat * iEnemyCombatModHigh)))) or
                --Surface level consideration - want tobe similar to sub so we dont end up attacking with subs and not surface if reason for attacking with subs is our surface threat
                (not(bConsideringSubmarinesNotSurface) and ((iAdjacentAlliedCombatThreat - iAdjacentAlliedSubmersibleThreat) > iAdjacentEnemyCombatThreat * iEnemyCombatModHigh or (tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] - iAdjacentAlliedSubmersibleThreat) > iAdjacentEnemyCombatThreat * iEnemyCombatModLow))  then
            if bDebugMessages == true then LOG(sFunctionRef..': Main scenario 2 condition satisfied') end
            bAreInScenario2 = true
        elseif tWZTeamData[M28Map.subrefWZbCoreBase] then
            --Consider attacking if naval fac is vulnerable, or we have slightly more threat
            if  iAdjacentAlliedCombatThreat > iAdjacentEnemyCombatThreat then
                if bDebugMessages == true then LOG(sFunctionRef..': We have significantly more threat than enemy so want to attack') end
                bAreInScenario2 = true
            else
                --Are in core zone, and have enemies either in this zone ro an adjacent one; if enemies are in this zone still attack; if they are in adjacent zone then only attack if nearest enemy is almost in range of our naval fac
                if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy has units in oure core water zone so want to attack') end
                    bAreInScenario2 = true
                elseif M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]) == false then
                    --No enemies in this water zone, so must only be in adjacent zone, check if are close to being in range of our naval factory

                    local tFriendlyNavalFac
                    if tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits] == false then tFriendlyNavalFac = EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) end
                    if M28Utilities.IsTableEmpty(tFriendlyNavalFac) then
                        --Greater search range as dont know how close to midpoint the naval fac build location would be
                        if CloseToEnemyUnit(tWZData[M28Map.subrefMidpoint], tWZTeamData[M28Map.reftoNearestCombatEnemies], 30, iTeam, true) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy has units almost in range of our core zone midpoint so will attack') end
                            bAreInScenario2 = true
                        end
                    else
                        --Cycle through each naval fac and see if enemy is close
                        for iNavalFac, oNavalFac in tFriendlyNavalFac do
                            if CloseToEnemyUnit(oNavalFac:GetPosition(), tWZTeamData[M28Map.reftoNearestCombatEnemies], 15, iTeam, true) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy has units almost in range of our naval fac so will attack') end
                                bAreInScenario2 = true
                                break
                            end
                        end
                    end
                end
            end

        end
    end
    if bAreInScenario2 and not(bConsideringSubmarinesNotSurface) then
        --Adjust if enemy has significant submersible threat and we dont have enough antinavy threat, or if enemy has nearby firebase and we dont have a decent force
        if iEnemyNearbySubmersibleThreat > iAvailableAntiNavyThreat and iEnemyNearbySubmersibleThreat * 5 > iAdjacentAlliedCombatThreat and (iEnemyNearbySubmersibleThreat > 500 or iEnemyNearbySubmersibleThreat * 2 > iAdjacentAlliedCombatThreat) then
            bAreInScenario2 = false
        elseif M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
            if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false and iAdjacentAlliedCombatThreat + tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] <= 6000 and tWZTeamData[M28Map.subrefWZBestAlliedDFRange] < 100 then
                bAreInScenario2 = false
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bAreInScenario2
end


--NOTE: REFER TO GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, iCategoryWanted, bAllConstructionNotFactory) WHICH IS MORE VERSATILE
function GetNumberOfUnitsCurrentlyBeingBuiltOfCategoryInZone(tLZTeamData, iCategory)

    local iCount = 0
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        local tFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory,tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tFactories) == false then
            local sBeingBuilt
            for iFactory, oFactory in tFactories do
                sBeingBuilt = oFactory[M28Orders.reftiLastOrders][1][M28Orders.subrefsOrderBlueprint]
                if sBeingBuilt and EntityCategoryContains(iCategory, sBeingBuilt) then
                    if M28UnitInfo.IsUnitValid(oFactory) and oFactory.GetWorkProgress then
                        if oFactory:GetWorkProgress() > 0 or M28UnitInfo.IsUnitValid(oFactory:GetFocusUnit()) then
                            iCount = iCount + 1
                        end
                    end
                end
            end
        end
    end
    return iCount

end

function IsNearbyStructureThatWeCanReachWithIndirect(tLZData, tLZTeamData, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsNearbyStructureThatWeCanReachWithIndirect'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bWantIndirectReinforcements = false

    local iAngleToMidpoint = M28Utilities.GetAngleFromAToB(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]:GetPosition(), tLZData[M28Map.subrefMidpoint])
    local iDistToMidpoint = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]:GetPosition(), tLZData[M28Map.subrefMidpoint])
    local tMoveTowardsMidpoint = M28Utilities.MoveInDirection(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]:GetPosition(), iAngleToMidpoint, math.min(70, iDistToMidpoint), false, false, false)
    local iCurLZIslandRef = tLZData[M28Map.subrefLZIslandRef]
    if not(iCurLZIslandRef) then
        iCurLZIslandRef = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint]) --We dont record island refs for all plateaus hence the redundancy
        if iCurLZIslandRef then tLZData[M28Map.subrefLZIslandRef] = iCurLZIslandRef end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Nearest structure='..tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere].UnitId..M28UnitInfo.GetUnitLifetimeCount(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere])..' at position '..repru(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]:GetPosition())..'; This LZ midpoint='..repru(tLZData[M28Map.subrefMidpoint])..'; iAngleToMidpoint='..iAngleToMidpoint..'; iDistToMidpoint='..iDistToMidpoint..'; tMoveTowardsMidpoint='..repru(tMoveTowardsMidpoint)..'; Island pathing of tMoveTowardsMidpoint='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tMoveTowardsMidpoint) or -1)..'; Island ref of LZ='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..'; iCurLZIslandRef='..(iCurLZIslandRef or 'nil')) end
    if (NavUtils.GetLabel(M28Map.refPathingTypeLand, tMoveTowardsMidpoint) or -1) == iCurLZIslandRef then
        --Can we build T3 mobile arti?
        if not(M28Map.bIsCampaignMap or M28Overseer.bUnitRestrictionsArePresent) then
            bWantIndirectReinforcements = true
        else
            --local oFirstM28Brain = M28Team.GetFirstActiveM28Brain(iTeam)
            if ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].GetCurrentUnits and ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]]:GetCurrentUnits(M28UnitInfo.refCategoryIndirect * categories.TECH3) > 0 then
                bWantIndirectReinforcements = true
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bWantIndirectReinforcements after checking for nearby structure='..tostring(bWantIndirectReinforcements)) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bWantIndirectReinforcements
end

function GetNumberOfUnderConstructionUnitsOfCategoryInOtherZones(tLZTeamData, iTeam, iCategory, iOptionalMinConstruction)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNumberOfUnderConstructionUnitsOfCategoryInOtherZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iUnderConstructionInOtherZones = 0
    local tUnitsOfCategory
    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
        local tStartLZData, tStartLZTeamData = M28Map.GetLandOrWaterZoneData(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], true, iTeam)
        if not(tStartLZTeamData == tLZTeamData) then
            if M28Utilities.IsTableEmpty(tStartLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                tUnitsOfCategory = EntityCategoryFilterDown(iCategory, tStartLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of units of cateogyr empty for brain '..oBrain.Nickname..'='..tostring(M28Utilities.IsTableEmpty(tUnitsOfCategory))) end
                if M28Utilities.IsTableEmpty(tUnitsOfCategory) == false then
                    for iUnit, oUnit in tUnitsOfCategory do
                        if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetAIBrain().M28AI and oUnit:GetFractionComplete() < 1 then
                            if not(iOptionalMinConstruction) or oUnit:GetFractionComplete() >= iOptionalMinConstruction then
                                iUnderConstructionInOtherZones = iUnderConstructionInOtherZones + 1
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iUnderConstructionInOtherZones
end

function GetEnemyOmniCoverageOfZone(iPlateauOrZero, iLandOrWaterZone, iTeam)
    local tLZOrWZData
    if iPlateauOrZero == 0 then

        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
    else tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
    end
    local iEnemyOmniCoverage = 0
    if (tLZOrWZData[M28Map.refiAllOmniCoverage] or 0) > 0 then
        local iCurOmniCoverage = 0
        if IsTableOfUnitsStillValid(tLZOrWZData[M28Map.reftoAllOmniRadar]) then
            for iUnit, oUnit in tLZOrWZData[M28Map.reftoAllOmniRadar] do
                if not(oUnit:GetAIBrain().M28Team == iTeam) then
                    iCurOmniCoverage = (oUnit:GetBlueprint().Intel.OmniRadius or 0) - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZOrWZData[M28Map.subrefMidpoint])
                    if iCurOmniCoverage > iEnemyOmniCoverage then
                        iEnemyOmniCoverage = iCurOmniCoverage
                    end
                end
            end
        else
            tLZOrWZData[M28Map.refiAllOmniCoverage] = 0
        end
    end
    return iEnemyOmniCoverage
end

function GetEnemyT3ArtiEquivalent(iTeam, iNovaxFactor, iNonArtiGameEnderFactor, bApplyFractionComplete, iOptionalMinFractionComplete)
    local iT3ArtiEquivalent = 0
    local iBaseValue
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure]) == false then
        if IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure], false) then
            for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure] do
                iBaseValue = 0
                if EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti, oUnit.UnitId) then
                    iBaseValue = 1
                elseif EntityCategoryContains(M28UnitInfo.refCategoryNovaxCentre, oUnit.UnitId) then
                    iBaseValue = iNovaxFactor
                elseif EntityCategoryContains(categories.ARTILLERY * categories.EXPERIMENTAL, oUnit.UnitId) then
                    iBaseValue = 3
                elseif EntityCategoryContains(M28UnitInfo.refCategoryGameEnder, oUnit.UnitId) then
                    iBaseValue = iNonArtiGameEnderFactor
                end
                if iBaseValue > 0 then
                    if not(iOptionalMinFractionComplete) or oUnit:GetFractionComplete() >= iOptionalMinFractionComplete then
                        if bApplyFractionComplete then iT3ArtiEquivalent = iT3ArtiEquivalent + iBaseValue * oUnit:GetFractionComplete()
                        else iT3ArtiEquivalent = iT3ArtiEquivalent + iBaseValue
                        end
                    end
                end
            end
        end
    end
    if IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftEnemyMobileSatellites]) then
        local iNovaxCount = 0
        for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyMobileSatellites] do
            iNovaxCount = iNovaxCount + 1
        end
        iT3ArtiEquivalent = math.max(iT3ArtiEquivalent, iNovaxCount * iNovaxFactor)
    end
    return iT3ArtiEquivalent
end

function GetMexesNotNearPlayerStartingZone()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetMexesNotNearPlayerStartingZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iMexesNotInStartZone = 0
    if bDebugMessages == true then LOG(sFunctionRef..': is table of mass poitns empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tMassPoints))) end
    if M28Utilities.IsTableEmpty(M28Map.tMassPoints) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Total mass points='..table.getn(M28Map.tMassPoints)..'; M28Map.PlayerStartPoints='..repru(M28Map.PlayerStartPoints)) end
        local tbStartPointPlateauAndZones = {}
        local iCurPlateauOrZero, iCurLandOrWaterZone
        for iIndex, tStartPoint in M28Map.PlayerStartPoints do
            iCurPlateauOrZero, iCurLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tStartPoint)
            if not(tbStartPointPlateauAndZones[iCurPlateauOrZero]) then tbStartPointPlateauAndZones[iCurPlateauOrZero] = {} end
            tbStartPointPlateauAndZones[iCurPlateauOrZero][iCurPlateauOrZero] = true
            if bDebugMessages == true then LOG(sFunctionRef..': recording start point for index '..iIndex..'; tStartPoint='..repru(tStartPoint)) end
        end

        for iMex, tMex in M28Map.tMassPoints do
            iCurPlateauOrZero, iCurLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tMex)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering tMex='..repru(tMex)..'; tbStartPointPlateauAndZones[iCurPlateauOrZero][iCurPlateauOrZero]='..tostring(tbStartPointPlateauAndZones[iCurPlateauOrZero][iCurPlateauOrZero] or false)) end
            if not(tbStartPointPlateauAndZones[iCurPlateauOrZero][iCurLandOrWaterZone]) then
                iMexesNotInStartZone = iMexesNotInStartZone + 1
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iMexesNotInStartZone
end

function GetNearbyACUForAirFacBomberSnipe(oFactory, iTeam)
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets]) == false then
        for iACU, oACU in M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets] do
            if M28UnitInfo.IsUnitValid(oACU) and (oACU[M28UnitInfo.refiRecentBomberSnipeAttempts] or 0) == 0 then
                return oACU
            end
        end
    end
end

function BrainIsUpgradingNavalHQ(aiBrain)
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftTeamUpgradingHQs]) == false then
        for iUpgrading, oUpgrading in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftTeamUpgradingHQs] do
            if not(oUpgrading.Dead) and oUpgrading:GetAIBrain() == aiBrain and EntityCategoryContains(M28UnitInfo.refCategoryNavalHQ, oUpgrading.UnitId) then
                return true
            end
        end
    end
    return false
end

function CheckIfNeedMoreEngineersOrSnipeUnitsBeforeUpgrading(oFactory)
    --Returns true if we want more engineers (e.g. for more power or nearby unclaimed mexes) before upgrading
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckIfNeedMoreEngineersOrSnipeUnitsBeforeUpgrading'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bWantMoreEngineers = false
    oFactory[M28Factory.refbWantMoreEngineersBeforeUpgrading] = false

    if EntityCategoryContains(M28UnitInfo.refCategoryFactory,oFactory.UnitId) then
        local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
        if bDebugMessages == true then LOG(sFunctionRef..': Considering factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; Total build count='..(oFactory[M28Factory.refiTotalBuildCount] or 0)..'; iFactoryTechLevel='..iFactoryTechLevel..'; Time='..GetGameTimeSeconds()) end
        local aiBrain = oFactory:GetAIBrain()
        if not(aiBrain[M28Overseer.refbCloseToUnitCap]) and iFactoryTechLevel < 3 then
            local iTeam = aiBrain.M28Team
            local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oFactory:GetPosition(), true, iTeam)

            local iBuildCountAdjust = 0
            if iFactoryTechLevel == 2 then

                --Want to build more units at a T2 factory if we outtech the enemy, unless dealing with air fac in a safe location
                if bDebugMessages == true then LOG(sFunctionRef..': T2 factory - build more units if we outtech enemy, unless air fac in safe location, Highest friendly fac tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; Map size='..M28Map.iMapSize..'; Enemy ground tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]..'; Enemy air tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech]..'; Enemy naval tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech]) end
                if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] <= 2 and M28Map.iMapSize <= 1024 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] > math.max(M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech], M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech], M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech]) then
                    --We outtech enemy and have decent mass and power, so want more factories to make use of our advantage, if enemy base is relatively near
                    if M28Utilities.GetDistanceBetweenPositions(tLZOrWZTeamData[M28Map.reftClosestEnemyBase], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) <= 550 and NavUtils.GetTerrainLabel(tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) == NavUtils.GetTerrainLabel(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) then
                        if not(tLZOrWZTeamData[M28Map.refbBaseInSafePosition]) or (M28Map.iMapSize <= 512 and not(EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oFactory.UnitId))) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Increasing units want to build by 4') end
                            iBuildCountAdjust = 4
                        end
                    end
                end
                --Also want to build more units if we want production over tech
                if M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbNoAvailableTorpsForEnemies] then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want torp bombers so increasing number of units to build') end
                    iBuildCountAdjust = iBuildCountAdjust + 10
                end
            end
            if aiBrain[M28Overseer.refbPrioritiseLowTech] then iBuildCountAdjust = iBuildCountAdjust + math.max(10, iBuildCountAdjust * 0.5)
            elseif aiBrain[M28Overseer.refbPrioritiseHighTech] then iBuildCountAdjust = iBuildCountAdjust - math.max(5, math.min(10, iBuildCountAdjust * 0.5))
            end
            --Naval fac and this brain doesnt have any upgrading to T2 yet, and enemy has torps
            if EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oFactory.UnitId) and iFactoryTechLevel == 1 then
                local bUpgradingHQForBrain = false
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]) == false then
                    for iHQ, oHQ in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs] do
                        if M28UnitInfo.IsUnitValid(oHQ) and oHQ:GetAIBrain() == aiBrain then
                            bUpgradingHQForBrain = true
                        end
                    end
                end
                if not(bUpgradingHQForBrain) then
                    if M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] > 0 then
                        iBuildCountAdjust = iBuildCountAdjust - math.max(20, iBuildCountAdjust * 0.5)
                    else
                        iBuildCountAdjust = iBuildCountAdjust - math.max(10, iBuildCountAdjust * 0.25)
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Naval fac, bUpgradingHQForBrain='..tostring(bUpgradingHQForBrain)..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat]='..M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat]..'; iBuildCountAdjust='..iBuildCountAdjust) end
            end

            if (oFactory[M28Factory.refiTotalBuildCount] or 0) <= 25 - iFactoryTechLevel * 5 + iBuildCountAdjust or ((oFactory[M28Factory.refiTotalBuildCount] or 0) <= 30 + iBuildCountAdjust and GetLifetimeBuildCount(oFactory:GetAIBrain(), M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) <= math.max(5, aiBrain[M28Economy.refiGrossMassBaseIncome] * 3 / iFactoryTechLevel) + iBuildCountAdjust) then
                if bDebugMessages == true then LOG(sFunctionRef..': iTeam='..iTeam..'; Brain='..aiBrain.Nickname..'; Want BP='..tostring(tLZOrWZTeamData[M28Map.subrefTbWantBP] or false)..'; Engineer lifetime build count for brain='..GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer)..'; Mexes in zone='..(tLZOrWZData[M28Map.subrefLZMexCount] or 0)) end
                if tLZOrWZTeamData[M28Map.subrefTbWantBP] then
                    --If are in core zone and T1 and have T3 of this factory type, then just upgrade
                    if not(iFactoryTechLevel == 1 and tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and ((EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oFactory.UnitId) and aiBrain[M28Economy.refiOurHighestLandFactoryTech] >= 3) or (EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oFactory.UnitId) and aiBrain[M28Economy.refiOurHighestAirFactoryTech] >= 3))) then

                        --Do we have enough energy?
                        local tiMinEnergyByTech = {[0]=20,[1]=20,[2]=60,[3]=60,[4]=90}
                        local iMinEnergyWanted = (tiMinEnergyByTech[iFactoryTechLevel] or 60)
                        local bHaveLowPower = HaveLowPower(iTeam)
                        local bHaveLowMass = HaveLowMass(aiBrain)

                        if not(EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oFactory.UnitId)) then iMinEnergyWanted = iMinEnergyWanted * 2 end
                        iMinEnergyWanted = iMinEnergyWanted * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] *  (aiBrain[M28Economy.refiBrainBuildRateMultiplier] or 1)
                        if bHaveLowPower and not(bHaveLowMass) and aiBrain:GetEconomyStoredRatio('MASS') >= 0.3 then
                            iMinEnergyWanted = iMinEnergyWanted * 1.5
                            if aiBrain:GetEconomyStoredRatio('MASS') >= 0.6 then iMinEnergyWanted = iMinEnergyWanted * 1.5 end
                        end
                        if tLZOrWZTeamData[M28Map.refbBaseInSafePosition] and EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oFactory.UnitId) then
                            if iFactoryTechLevel == 1 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 45 then
                                iMinEnergyWanted = iMinEnergyWanted * 0.6
                            elseif iFactoryTechLevel == 2 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 90 then
                                iMinEnergyWanted = iMinEnergyWanted * 0.6
                            else
                                iMinEnergyWanted = iMinEnergyWanted * 0.85
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iMinEnergyWanted='..iMinEnergyWanted..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] or false)..'; tLZOrWZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex]='..tostring(tLZOrWZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] or false)..'; T2 engi lifetime count='..GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * categories.TECH2)..'; Mass gross income='..aiBrain[M28Economy.refiGrossMassBaseIncome]) end
                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < iMinEnergyWanted or M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] or (iFactoryTechLevel == 2 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= 150 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryT2Power + M28UnitInfo.refCategoryT3Power) == 0) or (bHaveLowPower and not(bHaveLowMass) and aiBrain:GetEconomyStoredRatio('MASS') >= 0.3 and GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel) + M28UnitInfo.refCategoryEngineer*categories.TECH3) < iBuildCountAdjust + math.min(12, math.max(4, aiBrain[M28Economy.refiGrossMassBaseIncome] * 1.5))) then
                            M28Team.tTeamData[iTeam][M28Team.subrefbTooLittleEnergyForUpgrade] = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Dont have enough power to upgrade') end
                            bWantMoreEngineers = true
                        elseif tLZOrWZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have adj zones wanting engineer for mex') end
                            bWantMoreEngineers = true
                        elseif (oFactory[M28Factory.refiTotalBuildCount] or 0) <= iBuildCountAdjust + 10 then

                            local iMinBuildCountWanted = iBuildCountAdjust
                            local iOurHighestTech = 1
                            if GetGameTimeSeconds() - (oFactory[M28Factory.refiTimeSinceLastFailedToGetOrder] or -100) <= 1 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Recently failed to get order so dont want to wait to build more units') end
                                iMinBuildCountWanted = 0
                            else

                                if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oFactory.UnitId) then
                                    if not(tLZOrWZTeamData[M28Map.refbBaseInSafePosition]) or tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 10 or tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                                        if iFactoryTechLevel >= iOurHighestTech then
                                            iOurHighestTech = aiBrain[M28Economy.refiOurHighestAirFactoryTech]
                                            iMinBuildCountWanted = iMinBuildCountWanted + 1
                                            if tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then iMinBuildCountWanted = iMinBuildCountWanted + 5 end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Highest air fac tech so increasing build count min wanted') end
                                        elseif tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Enemies in adj LZ so increasing build count wanted') end
                                            iMinBuildCountWanted = iMinBuildCountWanted + 2
                                        end
                                    end
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oFactory.UnitId) then
                                    iOurHighestTech = aiBrain[M28Economy.refiOurHighestLandFactoryTech]
                                    if iFactoryTechLevel >= iOurHighestTech then   iMinBuildCountWanted = iMinBuildCountWanted + 5 end
                                    if tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then iMinBuildCountWanted = iMinBuildCountWanted + 5 end
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oFactory.UnitId) then
                                    iOurHighestTech = aiBrain[M28Economy.refiOurHighestNavalFactoryTech]
                                    iMinBuildCountWanted = iMinBuildCountWanted + 3
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iMinBuildCountWanted='..iMinBuildCountWanted..'; iBuildCountAdjust='..iBuildCountAdjust..'; Lifetime engi count='..GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer)..'; iOurHighestTech (if we calculated it)='..iOurHighestTech) end
                            if (oFactory[M28Factory.refiTotalBuildCount] or 0) < iMinBuildCountWanted then
                                bWantMoreEngineers = true
                            elseif GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer) <= ((tLZOrWZData[M28Map.subrefLZMexCount] or 0) + 1) * 1.5 then
                                bWantMoreEngineers = true
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': For larger maps on LOUD/QUIET will consider override to delay upgrade, bWantMoreEngineers='..tostring(bWantMoreEngineers)..'; LOUD active='..tostring(M28Utilities.bLoudModActive)..'; Map size='..M28Map.iMapSize) end
            if not(bWantMoreEngineers) and (M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) and not(aiBrain[M28Overseer.refbPrioritiseHighTech]) then
                --LOUD favours slightly slower upgrades in favour of getting more mexes, so aim to have at least 3 mexes of a higher tech level first
                local bWantMoreMexes = true
                local iLifetimeCount = math.min(4, M28UnitInfo.GetUnitLifetimeCount(oFactory))
                if oFactory[M28Factory.refiTotalBuildCount] >= 60 + iBuildCountAdjust then
                    bWantMoreMexes = false
                elseif iFactoryTechLevel == 1 then
                    if tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] > 0 or (tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] >= math.min(3, (tLZOrWZData[M28Map.subrefLZMexCount] or 0)) and (tLZOrWZData[M28Map.subrefLZMexCount] >= 2 + iLifetimeCount or aiBrain[M28Economy.refiGrossMassBaseIncome] >= 6 + iLifetimeCount)) then
                        bWantMoreMexes = false
                    end
                elseif tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] >= math.min(3, (tLZOrWZData[M28Map.subrefLZMexCount] or 0)) and (tLZOrWZData[M28Map.subrefLZMexCount] >= 2 + iLifetimeCount or aiBrain[M28Economy.refiGrossMassBaseIncome] >= 10 + 2 * iLifetimeCount) then
                    bWantMoreMexes = false
                end
                if bWantMoreMexes then
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.5 and tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] >= (tLZOrWZData[M28Map.subrefLZMexCount] or 0) and GetGameTimeSeconds() - M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] >= 40 + 20 * iLifetimeCount then
                        bWantMoreMexes = false
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oFactory.UnitId) and ((tLZOrWZData[M28Map.subrefWZMexCount] or 0) == 0 or (tLZOrWZTeamData[M28Map.subrefWZbCoreBase] and (oFactory[M28Factory.refiTotalBuildCount] >= 20 and aiBrain[M28Economy.refiGrossMassBaseIncome] >= 8 * iFactoryTechLevel))) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Naval factory, is core base='..tostring(tLZOrWZTeamData[M28Map.subrefWZbCoreBase])..'; Brain mass income gross='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; iFactoryTechLevel='..iFactoryTechLevel..'; subrefbDangerousEnemiesInAdjacentWZ='..tostring(tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] or false)..'; Team fgrigate+sub build count='..GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryFrigate + M28UnitInfo.refCategorySubmarine)) end
                        if tLZOrWZTeamData[M28Map.subrefWZbCoreBase] and
                                ((oFactory[M28Factory.refiTotalBuildCount] >= 20 or aiBrain[M28Economy.refiGrossMassBaseIncome] >= 7 * iFactoryTechLevel or (iFactoryTechLevel == 1 and aiBrain[M28Economy.refiGrossMassBaseIncome] >= 4 and (oFactory[M28Factory.refiTotalBuildCount] >= 6 or GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategorySubmarine) >= 6) and not(tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) and not(BrainIsUpgradingNavalHQ(aiBrain))))
                                or (iFactoryTechLevel == 1 and oFactory[M28Factory.refiTotalBuildCount] > 0 and not(tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) and M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] > 0 and aiBrain[M28Economy.refiGrossMassBaseIncome] >= 3.5 + 1 * aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalFactory - categories.TECH1) and not(BrainIsUpgradingNavalHQ(aiBrain)))) then
                            bWantMoreMexes = false
                        elseif not(tLZOrWZTeamData[M28Map.subrefWZbCoreBase]) and (oFactory[M28Factory.refiTotalBuildCount] >= 40 or aiBrain[M28Economy.refiGrossMassBaseIncome] >= 10 * iFactoryTechLevel) then
                            bWantMoreMexes = false
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': LOUD/QUIET - considering if want to hold off  on factory upgrade until we have more mexes, oFactory='..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; bWantMoreMexes='..tostring(bWantMoreMexes)..'; tLZOrWZData[M28Map.subrefWZMexCount]='..(tLZOrWZData[M28Map.subrefWZMexCount] or 'nil')..'; WZ core base='..tostring(tLZOrWZTeamData[M28Map.subrefWZbCoreBase] or false)..'; Factory build count='..oFactory[M28Factory.refiTotalBuildCount]..'; Dangerous enemies in adj WZ='..tostring(tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ])..'; Enemy torp bomber threat='..M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat]..'; Brain is upgrading naval HQ='..tostring(BrainIsUpgradingNavalHQ(aiBrain))) end
                if bWantMoreMexes then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                end
            end
        end
        if not(bWantMoreEngineers) then
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.toActiveSnipeTargets]) == false and EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oFactory.UnitId) then
                local oACUToSnipe = GetNearbyACUForAirFacBomberSnipe(oFactory, aiBrain.M28Team)

                if oACUToSnipe then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to do an ACU snipe') end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                end
            elseif aiBrain[M28Overseer.refbBomberSnipe] and M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.toBomberSnipeTargets]) == false and EntityCategoryContains(M28UnitInfo.refCategoryAirFactory - categories.UEF - categories.AEON - categories.TECH1, oFactory.UnitId) then
                --Havea  T2+ cybran or sera factory and want to do a t2 air snipe
                if bDebugMessages == true then LOG(sFunctionRef..': Want to do a t2 air snipe') end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': End of code, bWantMoreEngineers='..tostring(bWantMoreEngineers or false)) end --here since lower down means not a factory
    end
    if bWantMoreEngineers and M28Map.bIsCampaignMap then
        --FA M5 - strange case where we are restricted from building T1-T2 engineers for fletcher, so want to check not relevant
        local sEngineerBlueprint = M28Factory.GetBlueprintThatCanBuildOfCategory(oFactory:GetAIBrain(), M28UnitInfo.refCategoryEngineer, oFactory)
        if not(sEngineerBlueprint) then bWantMoreEngineers = false end
    end
    oFactory[M28Factory.refbWantMoreEngineersBeforeUpgrading] = bWantMoreEngineers
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bWantMoreEngineers
end

function GetPowerInsteadOfHydroEvenIfHydroAvailable(iTeam, tLZData, tLZTeamData, iPlateau, iLandZone, bHaveLowMass, bHaveLowPower)
    if not(tLZTeamData[M28Map.subrefLZbCoreBase]) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 7 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or bHaveLowMass or not(bHaveLowPower) or table.getn(tLZData[M28Map.subrefHydroLocations]) <= 2 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 then
        return false
    end
    return true
end

function GetHighestTechInZone(iTeam, tLZTeamData)
    local iHighestTech = 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] > 1 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        local tFactoriesAndEngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryAllHQFactories + M28UnitInfo.refCategoryEngineer - categories.TECH1, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tFactoriesAndEngineersInZone) == false then
            for iUnit, oUnit in tFactoriesAndEngineersInZone do
                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then
                    iHighestTech = math.max(iHighestTech, M28UnitInfo.GetUnitTechLevel(oUnit))
                    if iHighestTech >= 3 then break end
                end
            end
        end
    end
    return iHighestTech
end

function ApplyM28ToOtherAI(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ApplyM28ToOtherAI'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': aiBrain.BrainType='..(aiBrain.BrainType or 'nil')..'; aiBrain nickname='..(aiBrain.Nickname or 'nil')..'; Is civilian='..tostring(IsCivilianBrain(aiBrain))..'; Is scenario type skirmish='..tostring(ScenarioInfo.type == "skirmish")..'; DoesAINicknameContainM28='..tostring(M28Utilities.DoesAINicknameContainM28(aiBrain.Nickname))) end
    if M28Utilities.DoesAINicknameContainM28(aiBrain.Nickname) then
        if bDebugMessages == true then LOG(sFunctionRef..': Have M28 in the name so will apply M28 logic to the brain') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    elseif not(M28Orders.bDontConsiderCombinedArmy) and aiBrain.BrainType == 'Human' then
        if bDebugMessages == true then LOG(sFunctionRef..': Have shared armies so treating brain as human') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    else
        local iCampaignAISetting = ScenarioInfo.Options.CampAI
        local refiNone = 1
        local refiAllies = 2
        local refiEnemies = 3
        local refiAlliesAndEnemies = 4
        local bIsEnemyOfSomeone = false
        if not(iCampaignAISetting == refiNone) then
            --Hostile brains in campaign (i.e. non-player brains) should return true to the IsCivilianBrain check if theyve not yet been set as being a M28AI brain
            if (aiBrain.BrainType == "AI" or not(aiBrain.BrainType)) and not(ScenarioInfo.type == "skirmish") then
                --Do we have any brains that are hostile to this?

                local bEnemyOfPlayer = false
                local bAllyOfPlayerWithEnemy = false
                --FAF requires a humna player to be in the player 1 slot; therefore look for a human player and if cant find one then pick the brain with a braintype (since looks like this can be nil for some campaign missions for the built in AI)
                local oFirstPlayer
                for iBrain, oBrain in ArmyBrains do
                    if oBrain.BrainType == 'Human' then oFirstPlayer = oBrain break end
                end
                if not(oFirstPlayer) then
                    for iBrain, oBrain in ArmyBrains do
                        if aiBrain.BrainType then
                            oFirstPlayer = oBrain break
                        end
                    end
                end

                local bEnemyOfPlayerAlly = false
                local bEnemyOfPlayerEnemy = false

                if IsEnemy(oFirstPlayer:GetArmyIndex(), aiBrain:GetArmyIndex()) then
                    bEnemyOfPlayer = true
                    bIsEnemyOfSomeone = true
                elseif IsAlly(oFirstPlayer:GetArmyIndex(), aiBrain:GetArmyIndex()) then
                    --Check there is a brain this is an enemy of
                    for iBrain, oBrain in ArmyBrains do
                        if IsEnemy(aiBrain:GetArmyIndex(), oBrain:GetArmyIndex()) then
                            bIsEnemyOfSomeone = true
                            bAllyOfPlayerWithEnemy = true
                            break
                        end
                    end
                else
                    --Not ally or enemy of player; if enemy of the same faction the player is enemy of, then still consider an ally

                    for iBrain, oBrain in ArmyBrains do
                        if IsEnemy(aiBrain:GetArmyIndex(), oBrain:GetArmyIndex()) then
                            if IsEnemy(oFirstPlayer:GetArmyIndex(), oBrain:GetArmyIndex()) then
                                bEnemyOfPlayerEnemy = true
                            elseif IsAlly(oFirstPlayer:GetArmyIndex(), oBrain:GetArmyIndex()) then
                                bEnemyOfPlayerAlly = true
                            end
                            bIsEnemyOfSomeone = true
                        end
                    end
                end
                if not(bIsEnemyOfSomeone) then
                    for iBrain, oBrain in ArmyBrains do
                        if IsEnemy(aiBrain:GetArmyIndex(), oBrain:GetArmyIndex()) then
                            bIsEnemyOfSomeone = true
                            break
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering brain, bIsEnemyOfSomeone='..tostring(bIsEnemyOfSomeone)..'; bEnemyOfPlayer='..tostring(bEnemyOfPlayer)..'; bAllyOfPlayerWithEnemy='..tostring(bAllyOfPlayerWithEnemy)..'; bEnemyOfPlayerAlly='..tostring(bEnemyOfPlayerAlly)..'; bEnemyOfPlayerEnemy='..tostring(bEnemyOfPlayerEnemy)) end
                local bUseM28AI = false
                if bEnemyOfPlayer and (iCampaignAISetting == refiEnemies or iCampaignAISetting == refiAlliesAndEnemies) then
                    bUseM28AI = true
                    if aiBrain.CampaignAI then aiBrain.HostileCampaignAI = true end
                elseif (bAllyOfPlayerWithEnemy or (bIsEnemyOfSomeone and not(bEnemyOfPlayer) and not(bEnemyOfPlayerAlly) and bEnemyOfPlayerEnemy)) and (iCampaignAISetting == refiAllies or iCampaignAISetting == refiAlliesAndEnemies) then
                    bUseM28AI = true
                end


                if bUseM28AI then
                    --override for brackman on FA M5 so we dont control the megalith:
                    if aiBrain.Nickname == 'Brackman' and ScenarioInfo.Brackman and ScenarioInfo.Fletcher and ScenarioInfo.Hex5 then
                        bUseM28AI = false
                    end
                    if aiBrain.Nickname == 'Dostya' and ScenarioInfo.Wreckage_Holding and ScenarioInfo.FauxUEF and ScenarioInfo.Symbiont and ScenarioInfo.Aeon then
                        --override for Dostya on SC Cybran M1 sine she starts with an ACU but isn't hostile to UEF or Aeon:
                        bUseM28AI = false
                    end
                end

                --[[for iBrain, oBrain in ArmyBrains do
                    if not(oBrain == aiBrain) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if oBrain '..oBrain.Nickname..' is an enemy to aiBrain '..aiBrain.Nickname..'; IsEnemy='..tostring(IsEnemy(iBrainIndex, oBrain:GetArmyIndex()))) end

                        if IsEnemy(oBrain:GetArmyIndex(), iBrainIndex) then bHaveEnemy = true end
                        --if IsAlly(oBrain:GetArmyIndex(), iBrainIndex) then bHaveAlly = true end
                    end
                end--]]
                --Removedl ogic re IsAlly, since even if it is an ally to one of us if it has no enemies there's nothign to attack
                if bDebugMessages == true then LOG(sFunctionRef..': oFirstPlayer='..(oFirstPlayer.Nickname or 'nil')..'; bUseM28AI='..tostring(bUseM28AI)..'; bEnemyofPlayer='..tostring(bEnemyOfPlayer)..'; bAllyOfPlayerWithEnemy='..tostring(bAllyOfPlayerWithEnemy)) end
                if bUseM28AI then --or bHaveAlly then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will apply M28 override to the brain') end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Brain doesnt meet the ally or enemy settings so wont give M28 logic to it') end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Wont apply M28 override to the brain '..aiBrain.Nickname..'; iCampaignAISetting='..(iCampaignAISetting or 'nil')..'; refiNone='..refiNone) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function HaveSentOrderToRunAwayFromLocationToAvoid(oUnit, tLocationsToAvoid, iDistanceThreshold)
    --If are close to a location to avoid then gives the unit an order to run in the opposite direction
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'HaveSentOrderToRunAwayFromLocationToAvoid'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    for iLocation, tLocation in tLocationsToAvoid do
        if bDebugMessages == true then LOG(sFunctionRef..': Dist from unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at position '..repru(oUnit:GetPosition())..' to tLocation='..repru(tLocation)..'='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLocation)..'; iDistanceThreshold='..iDistanceThreshold) end
        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLocation) <= iDistanceThreshold then
            local tLocationToMoveTo = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(tLocation, oUnit:GetPosition()), 5, true, false, M28Map.bIsCampaignMap)
            M28Orders.IssueTrackedMove(oUnit, tLocationToMoveTo, 1, false, 'AvdAr', false)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function GetCurrentM28UnitsOfCategoryInTeam(iCategory, iTeam)
    local iCount = 0
    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
        iCount = iCount + oBrain:GetCurrentUnits(iCategory)
    end
    return iCount
end

function WantMoreEngineersToAssistMexUpgradeAsPriority(tLZOrWZTeamData, iTeam)
    if tLZOrWZTeamData[M28Map.subrefTbWantBP] and (tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] or 0) >= 2 and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and not(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and not(tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftLZEnemyAirUnits]) then
        local iEngineersWantedInZone = 7 + 3 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]
        local tEngineersInZone
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then tEngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) end
        local iEngineersInZone = 0
        if M28Utilities.IsTableEmpty(tEngineersInZone) == false then
            iEngineersInZone = table.getn(tEngineersInZone)
        end
        if iEngineersInZone < iEngineersWantedInZone then
            --Check we dont already have 3+ engineers under construction
            local iUnderConstruction = GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZOrWZTeamData, M28UnitInfo.refCategoryEngineer, false)
            if iUnderConstruction < 1 + tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] then
                return true
            end
        end
    end
    return false
end

function GetHighestOtherTeamT3MexCount(iTeam)
    local iHighestCount = 0
    for iCurTeam = 1, M28Team.iTotalTeamCount do
        if not(iCurTeam == iTeam) then
            iHighestCount = math.max(iHighestCount, (M28Team.tTeamData[iCurTeam][M28Team.refiMexCountByTech][3] or 0))
        end
    end
    return iHighestCount
end

function GetHighestOtherTeamT2AndT3MexCount(iTeam)
    local iHighestCount = 0
    for iCurTeam = 1, M28Team.iTotalTeamCount do
        if not(iCurTeam == iTeam) then
            iHighestCount = math.max(iHighestCount, (M28Team.tTeamData[iCurTeam][M28Team.refiMexCountByTech][3] or 0) + (M28Team.tTeamData[iCurTeam][M28Team.refiMexCountByTech][2] or 0))
        end
    end
    return iHighestCount
end

function HaveTemplateSpaceForGameEnder(iCategoryWanted, tLZOrWZData, tLZOrWZTeamData, tbEngineersOfFactionOrNilIfAlreadyAssigned, iTeam)
    --Returns true if we have space for a gameender of iCategoryWanted using the special shielding template logic
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'HaveTemplateSpaceForGameEnder'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(M28Team.tTeamData[iTeam][M28Team.refbUnableToBuildArtiOrGameEnders]) then

        --First check if we have that size available generally (without using backup template)
        local iSmallestSizeNeeded = 22
        --if tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionUEF] or tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionSeraphim] then iSmallestSizeNeeded = 20 end
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefBuildLocationsBySizeAndSegment][iSmallestSizeNeeded]) == false then
            for iSegmentX, tSubtable in tLZOrWZTeamData[M28Map.subrefBuildLocationsBySizeAndSegment][iSmallestSizeNeeded] do
                for iSegmentZ, bValid in tSubtable do
                    if bValid then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have valid size '..iSmallestSizeNeeded..' for iSegmentX='..iSegmentX..'Z'..iSegmentZ) end
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return true
                    end
                end
            end
        end

        --Do we have any active locations?
        local bActiveLocationButDoesntWantEngineers = false
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftActiveGameEnderTemplates]) == false then
            for iEntry, tSubtable in tLZOrWZTeamData[M28Map.reftActiveGameEnderTemplates] do
                if bDebugMessages == true then LOG(sFunctionRef..': Have active gameender template, does it no longer need engineers='..tostring(tSubtable[M28Map.subrefGEbDontNeedEngineers] or false)) end
                if not(tSubtable[M28Map.subrefGEbDontNeedEngineers]) then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                else
                    bActiveLocationButDoesntWantEngineers = true
                end
            end
        end



        --We dont have any locations large enough that are free, check if we have a recorded template, and if so are we already using it
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of gameender tempalte backup locations empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefGameEnderTemplateBackupLocationSizeAndSegment]))) end
        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefGameEnderTemplateBackupLocationSizeAndSegment]) == false then
            --Check the active location doesn't cross into this location
            local bRecordedIsAlreadyUsed = false
            if bDebugMessages == true then LOG(sFunctionRef..': Checking if this location overlaps with an existing active template, bActiveLocationButDoesntWantEngineers='..tostring(bActiveLocationButDoesntWantEngineers or false)) end
            if bActiveLocationButDoesntWantEngineers then
                if bDebugMessages == true then LOG(sFunctionRef..': tLZOrWZData[M28Map.subrefGameEnderTemplateBackupLocationSizeAndSegment]='..repru(tLZOrWZData[M28Map.subrefGameEnderTemplateBackupLocationSizeAndSegment])) end
                local tBackupMidpoint = M28Map.GetPositionFromPathingSegments(tLZOrWZData[M28Map.subrefGameEnderTemplateBackupLocationSizeAndSegment][M28Map.subrefiSegX], tLZOrWZData[M28Map.subrefGameEnderTemplateBackupLocationSizeAndSegment][M28Map.subrefiSegZ])

                for iEntry, tSubtable in tLZOrWZTeamData[M28Map.reftActiveGameEnderTemplates] do
                    if bDebugMessages == true then LOG(sFunctionRef..': tBackupMidpoint='..repru(tBackupMidpoint)..'; tSubtable midpoint='..repru(tSubtable[M28Map.subrefGEMidpoint])..'; Subtable size='..tSubtable[M28Map.subrefGESize]..'; Abs X dif='..math.abs(tSubtable[M28Map.subrefGEMidpoint][1] - tBackupMidpoint[1])..'; Abs Z dif='..math.abs(tSubtable[M28Map.subrefGEMidpoint][3] - tBackupMidpoint[3])) end
                    if math.abs(tSubtable[M28Map.subrefGEMidpoint][1] - tBackupMidpoint[1]) <= tSubtable[M28Map.subrefGESize] and math.abs(tSubtable[M28Map.subrefGEMidpoint][3] - tBackupMidpoint[3]) <= tSubtable[M28Map.subrefGESize] then
                        bRecordedIsAlreadyUsed = true
                        break
                    end

                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bRecordedIsAlreadyUsed='..tostring(bRecordedIsAlreadyUsed or false)) end
            if not(bRecordedIsAlreadyUsed) then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Coudlnt find any suitable locations, returning false') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function HaveActiveGameEnderTemplateLogic(tLZOrWZTeamData, bOptionalOnlyTrueIfNeedUEFOrSeraEngineers)
    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftActiveGameEnderTemplates]) == false then
        for iTemplate, tSubtable in tLZOrWZTeamData[M28Map.reftActiveGameEnderTemplates] do
            if not(tSubtable[M28Map.subrefGEbDontNeedEngineers]) then
                if not(bOptionalOnlyTrueIfNeedUEFOrSeraEngineers) then
                    return true
                else
                    --Only return true if this location has 2+ arti slots, and fewer than 7 shields (i.e. it wants UEF/Sera engineers)
                    if (tSubtable[M28Map.subrefiCyclesWaitingForEngineer] or 0) > 0 or (table.getn(tSubtable[M28Map.subrefGEArtiLocations]) > 1 and (M28Utilities.IsTableEmpty(tSubtable[M28Map.subrefGEShieldUnits]) or table.getn(tSubtable[M28Map.subrefGEShieldUnits]) >= 3)) then
                        return true
                    end
                end
            end
        end
    end
    return false
end

function WillBlockTemplateLocation(tLZTeamData, iCurSegmentX, iCurSegmentZ, iBuildingAdjustedRadius)
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates]) == false then
        local tBasePosition = M28Map.GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
        local iDistancethreshold
        for iTemplate, tSubtable in tLZTeamData[M28Map.reftActiveGameEnderTemplates] do
            iDistancethreshold = tSubtable[M28Map.subrefGESize] + iBuildingAdjustedRadius
            if math.abs(tSubtable[M28Map.subrefGEMidpoint][1] - tBasePosition[1]) <= iDistancethreshold and math.abs(tSubtable[M28Map.subrefGEMidpoint][3] - tBasePosition[3]) then
                return true
            end
        end
    end
    return false
end

function WantT3MAAInsteadOfT2(oFactory, iTeam)
    if M28UnitInfo.GetUnitTechLevel(oFactory) == 3 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 3000) and (oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA) >= 20 or (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] >= 1000 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.TECH3 * M28UnitInfo.refCategoryBomber, M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround])) == false) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 0 and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA - categories.TECH3) >  oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) * 2) then
        return true
    end
    return false
end

function PrioritiseSniperBots(tLZData, iTeam, tLZTeamData, bHaveAeonOrSeraFactoryInZoneOverride)
    --Returns true if we want to prioritise building sniperbots as a counter to enemy land experimentals
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'PrioritiseSniperBots'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then
        LOG(sFunctionRef..': Stat of code, time='..GetGameTimeSeconds())
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then LOG(sFunctionRef..': Enemy has land exp, is table of enemy mega and fatboy empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMegalith + M28UnitInfo.refCategoryFatboy,M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]))))
        else LOG(sFunctionRef..': Enemy has no land exp')
        end
    end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMegalith + M28UnitInfo.refCategoryFatboy,M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals])) then
        --Dont get if enemy has t2 arti near this zone
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy nearby t2 arti empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]))) end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) then
            local aiBrain = ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]]
            local iLandSubteam = aiBrain.M28LandSubteam
            if bDebugMessages == true then LOG(sFunctionRef..': Number of T3 aeon and sera factories on team='..((M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionAeon][3] or 0) + (M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionSeraphim][3] or 0)..'; Is table of aeon and sera factories in this zone empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory * categories.AEON + M28UnitInfo.refCategoryLandFactory * categories.SERAPHIM, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))))) end
            if bHaveAeonOrSeraFactoryInZoneOverride or ((M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionAeon][3] or 0) + (M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionSeraphim][3] or 0) > 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory * categories.AEON + M28UnitInfo.refCategoryLandFactory * categories.SERAPHIM, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false) then
                local bEnemyHasLandExpOnSameIsland = false
                for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
                    if M28UnitInfo.IsUnitValid(oUnit) and NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition()) == (tLZData[M28Map.subrefLZIslandRef] or 0) then
                        bEnemyHasLandExpOnSameIsland = true
                        break
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': bEnemyHasLandExpOnSameIsland='..tostring(bEnemyHasLandExpOnSameIsland or false)..'; LC sniperbot='..GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategorySniperBot)..'; Active brain count='..M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) end
                if bEnemyHasLandExpOnSameIsland then
                    --We have access to Aeon/Seraphim tech, and enemy has land experimentals but not a megalith or fatboy; prioritise sniperbots if we have a build count of less than 20
                    if GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategorySniperBot) <= 13 + 7 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                        --If we arent far behind on air and enemy lacks much in the way of T3 MAA then dont prioritise sniperbots since air likely better
                        if bDebugMessages == true then LOG(sFunctionRef..': Is team far behind on air='..tostring(TeamIsFarBehindOnAir(iTeam))..'; Our gunship threat='..M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat]..'; Enemy T3 MAA count='..M28Team.tTeamData[iTeam][M28Team.iEnemyT3MAAActiveCount]..'; Gunship losses='..M28Team.tTeamData[iTeam][M28Team.refiGunshipLosses]..'; Gunship kills='..M28Team.tTeamData[iTeam][M28Team.refiGunshipKills]) end
                        if TeamIsFarBehindOnAir(iTeam) or M28Team.tTeamData[iTeam][M28Team.iEnemyT3MAAActiveCount] >= 12 or (M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] <= 20000 and M28Team.tTeamData[iTeam][M28Team.iEnemyT3MAAActiveCount] >= 4) or M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] <= 5000 or M28Team.tTeamData[iTeam][M28Team.refiGunshipLosses] > math.max(10000, M28Team.tTeamData[iTeam][M28Team.refiGunshipKills] * 1.5) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Want sniperbots') end
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Dont want sniperbots') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function GetNumberOfUnitsOfCategoryInAdjacentLandZones(tLZData, iPlateau, iTeam, iCategory, bIncludeOnlyConstructed, bReturnOnceOnlyOneUnit)
    --Only considers adjacent land zones, not the current zone; assumes dealing with land zone
    local iCount = 0
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
            local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
            if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                local tUnitsOfCategory
                if iCategory then tUnitsOfCategory = EntityCategoryFilterDown(iCategory, tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                else tUnitsOfCategory = tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]
                end
                if M28Utilities.IsTableEmpty(tUnitsOfCategory) == false then
                    for iUnit, oUnit in tUnitsOfCategory do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            if not(bIncludeOnlyConstructed) or oUnit:GetFractionComplete() == 1 then
                                iCount = iCount + 1
                                if bReturnOnceOnlyOneUnit then return iCount end
                            end
                        end
                    end
                end
            end
        end
    end
    return iCount
end


function AreAnyOfTableOfUnitsInAdjacentLandZone(tUnits, iPlateau, iLandZone, tLZData, tLZTeamData, iTeam)
    if M28Utilities.IsTableEmpty(tUnits) == false then --redundancy
        local tbZonesWithUnits = {}
        local iCurPlateau, iCurLZ
        for iUnit, oUnit in tUnits do
            iCurPlateau = oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1]
            if iCurPlateau == iPlateau then
                iCurLZ = oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]
                if not(tbZonesWithUnits[iCurLZ]) then tbZonesWithUnits[iCurLZ] = true end
            end
        end
        if M28Utilities.IsTableEmpty(tbZonesWithUnits) == false then
            if tbZonesWithUnits[iLandZone] then
                return true
            elseif M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    if tbZonesWithUnits[iAdjLZ] then
                        return true
                    end
                end

            end
        end
    end
    return false
end

function HaveEngineersOrFactoriesInZone(tLZOrWZTeamData)
    local bHaveEngiOrFactory = false
    if M28Utilities.IsTableEmpty(tLZOrWZTeamData) == false then
        for iUnit, oUnit in tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do
            if EntityCategoryContains(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryFactory, oUnit.UnitId) then
                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then
                    return true
                end
            end
        end
    end
    return false
end


function HaveSignificantEnemyThreatWithinRange(tLZData, tLZTeamData, iPlateau, iTeam, iSearchDistance, tStartPoint, iEnemyMassTotalThreshold, iOptionalSearchCategory, tOptionalAdditionalUnits, bOnlyIncludeDFUnits, bIncludeEnemyCombatRange)
    --Essentially a much more cpu intesnive version of getunitsaroundpoint, that will make use of M28's memory of where units are; will search current zone and adjacent zones; can also pass it tOptionalAdditionalUnits for further away units
    --iEnemyMassTotalThreshold - if >= this in mass then returns true, otherwise returns false
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'HaveSignificantEnemyThreatWithinRange'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCumulativeUnitValue = 0
    local iCurDist
    local bSignificantEnemyThreat = false
    function ConsiderUnitTable(tUnits)
        if M28Utilities.IsTableEmpty(tUnits) == false then
            local tUnitTable
            if iOptionalSearchCategory then tUnitTable = EntityCategoryFilterDown(iOptionalSearchCategory, tUnits)
            else tUnitTable = tUnits
            end
            if M28Utilities.IsTableEmpty(tUnitTable) == false then
                for iUnit, oUnit in tUnitTable do
                    if M28UnitInfo.IsUnitValid(oUnit) and (not(bOnlyIncludeDFUnits) or oUnit[M28UnitInfo.refiDFRange] > 0) then
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tStartPoint)
                        if iCurDist <= iSearchDistance or (bIncludeEnemyCombatRange and iCurDist - oUnit[M28UnitInfo.refiCombatRange] <= iSearchDistance) then
                            iCumulativeUnitValue = iCumulativeUnitValue + math.max((oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)), (M28UnitInfo.tUnitThreatByIDAndType[oUnit.UnitId]['1000000'] or 0))
                            if bDebugMessages == true then LOG(sFunctionRef..': iCumulativeUnitValue after considering oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'='..iCumulativeUnitValue..'; iEnemyMassTotalThreshold='..iEnemyMassTotalThreshold..'; M28UnitInfo.tUnitThreatByIDAndType[oUnit.UnitId]='..(M28UnitInfo.tUnitThreatByIDAndType[oUnit.UnitId]['1000000'] or 'nil')) end
                            if iCumulativeUnitValue >= iEnemyMassTotalThreshold then
                                bSignificantEnemyThreat = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Enoguh targets of interest so will return true') end
                                break
                            end
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy units in the base LZ') end
    ConsiderUnitTable(tLZTeamData[M28Map.subrefTEnemyUnits])
    if bSignificantEnemyThreat then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    end
    if tOptionalAdditionalUnits then  ConsiderUnitTable(tOptionalAdditionalUnits) end
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
        if bSignificantEnemyThreat then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end
        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy units in the adjacent landzone='..iAdjLZ) end
            ConsiderUnitTable(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits])
            if bSignificantEnemyThreat then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function ACULikelyToWantCombatUpgradeOrShield(oACU)
    --used to decide if we want to go down combat path of upgrades for ACU, or if enemy has novax such that we want more defence for acu
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ACULikelyToWantCombatUpgradeOrShield'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..'; Start of code, ACU health%='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs]='..tostring(M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refbDangerousForACUs])..'; aiBrain[M28Map.refbCanPathToEnemyBaseWithAmphibious]='..tostring(oACU:GetAIBrain()[M28Map.refbCanPathToEnemyBaseWithAmphibious])..'; Time='..GetGameTimeSeconds()) end
    if M28UnitInfo.GetUnitHealthPercent(oACU) < 0.7 then
        if bDebugMessages == true then LOG(sFunctionRef..': ACU damaged so returning true to use in combat') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    else
        local aiBrain = oACU:GetAIBrain()
        local iTeam = aiBrain.M28Team
        if M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] > 0 then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        elseif GetGameTimeSeconds() <= 1200 then
            if aiBrain[M28Map.refbCanPathToEnemyBaseWithAmphibious] then
                if not(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs]) then
                    --If enemy has dangerous ACU that is on the same plateau as us then go defensive
                    if M28Team.tTeamData[iTeam][M28Team.refbEnemyHasDangerousACU] and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) == false then
                        local iOurPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, oACU:GetPosition())
                        local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
                        for iEnemyACU, oEnemyACU in M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs] do
                            if iOurPlateau == NavUtils.GetLabel(M28Map.refPathingTypeHover, oEnemyACU:GetPosition()) and oEnemyACU[M28ACU.refiUpgradeCount] >= 2 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy has dangerous ACU on the team, and one of the ACUs on this plateau has 2+ upgrades so assuming it is dangerous') end
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return true
                            end
                        end
                    end

                    --How close is nearest enemy base to our nearest friendly base (dont want to do based on ACU position as ACU might retreat to get upgrade then the upgrade changes as a result of htis flag
                    local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oACU:GetPosition(), true, iTeam)
                    if not(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) then
                        tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(M28Map.GetPlayerStartPosition(aiBrain), true, iTeam)
                    end
                    local iDistBetweenBases = M28Utilities.GetDistanceBetweenPositions(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], tLZOrWZTeamData[M28Map.reftClosestEnemyBase])
                    if bDebugMessages == true then LOG(sFunctionRef..': iDistBetweenBases='..iDistBetweenBases..'; aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]='..tostring(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand])..'; Cur T3 mex='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryT3Mex)) end
                    if iDistBetweenBases <= 300 or (aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] and iDistBetweenBases <= 500) then
                        if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryT3Mex) < 3 then
                            --Check start LZ isnt in a safe position
                            local tStartLZOrWZData, tStartLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(M28Map.GetPlayerStartPosition(aiBrain), true, iTeam)
                            if bDebugMessages == true then LOG(sFunctionRef..': tStartLZOrWZTeamData[M28Map.refbBaseInSafePosition]='..tostring(tStartLZOrWZTeamData[M28Map.refbBaseInSafePosition])) end
                            if not(tStartLZOrWZTeamData[M28Map.refbBaseInSafePosition]) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Likely we will want to use ACU in combat, returning true') end
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return true
                            end
                        end
                    end
                end
            end

        end
    end
        if bDebugMessages == true then LOG(sFunctionRef..': Unlikely we will want to use ACU in combat, returning false') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false
end

function AdjacentToPacifistZone(iPlateauOrZero, iLandOrWaterZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AdjacentToPacifistZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tLZOrWZData
    if iPlateauOrZero == 0 then
        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
    else
        tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Near start, iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Is tLZOrWZData empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData))) end
    if tLZOrWZData[M28Map.subrefbPacifistArea] then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    else
        M28Air.RecordOtherLandAndWaterZonesByDistance(tLZOrWZData)
        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
            for iEntry, tSubtable in tLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                if tSubtable[M28Map.subrefiDistance] > 200 then break end
                local tAltLZOrWZData
                local iCurLZOrWZRef = tSubtable[M28Map.subrefiLandOrWaterZoneRef]
                if tSubtable[M28Map.subrefbIsWaterZone] then
                    tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurLZOrWZRef]][M28Map.subrefPondWaterZones][iCurLZOrWZRef]
                else
                    tAltLZOrWZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][iCurLZOrWZRef]
                end
                if tAltLZOrWZData[M28Map.subrefbPacifistArea] then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DoesAINicknameContainM28(sNickname, bOnlyM28Easy)
    return M28Utilities.DoesAINicknameContainM28(sNickname, bOnlyM28Easy)
end

function HaveEcoToSupportGETemplate(iTeam)
    if M28Utilities.bLoudModActive or M28Utilities.bQuietModActive then
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 250*math.min(10, (2* M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] + 4)) and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= math.max(2, M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
            return true
        end
    else
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 250*math.min(4, (M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] * 1.5)) and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= 1 then
            return true
        end
    end
    return false
end

function GiveAttackMoveAsWeaponStuck(oUnit)
    --Currently intended for DF units such as ACU (battleships manually added some logic already before did this so at some poitn could look to combine if wanted to be consistent, e.g. in event is an issue with below approach)
    --For LOUD games due to LOUD changes making it much harder for units to kite
    if M28Utilities.bLoudModActive and (oUnit[M28UnitInfo.refbAttackMoveInsteadOfKiting] or (oUnit[M28UnitInfo.refiTimeBetweenDFShots] and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0) >= 4 + oUnit[M28UnitInfo.refiTimeBetweenDFShots])) then
        if not(oUnit[M28UnitInfo.refbAttackMoveInsteadOfKiting]) then
            oUnit[M28UnitInfo.refbAttackMoveInsteadOfKiting] = true
            M28Utilities.DelayChangeVariable(oUnit, M28UnitInfo.refbAttackMoveInsteadOfKiting, false, 25)
        end
        return true
    end
end

function GroundAttackTargetUnitInsteadOfAttackMove(oUnit, oEnemyToFocusOn)
    if (M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) and (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) == 0 and ((oEnemyToFocusOn:GetFractionComplete() < 1 and EntityCategoryContains(categories.AEON, oEnemyToFocusOn.UnitId)) or EntityCategoryContains(M28UnitInfo.refCategoryTorpedoLauncher, oEnemyToFocusOn.UnitId)) and M28Utilities.GetDistanceBetweenPositions(oEnemyToFocusOn:GetPosition(), oUnit:GetPosition()) <= oUnit[M28UnitInfo.refiCombatRange] then
        return true
    end
end

function DoesWaterZoneHaveUnitsThatCounterTorpDefence(tWZTeamData, iOptionalAlliedCumulativeCombatThreatToReturn)
    if iOptionalAlliedCumulativeCombatThreatToReturn then iOptionalAlliedCumulativeCombatThreatToReturn = iOptionalAlliedCumulativeCombatThreatToReturn + (tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0) end
    local bEnemyHasLongRangeOrHover = false
    if tWZTeamData[M28Map.subrefbWZOnlyHoverEnemies] or (((tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] or 0) >= 50 or (tWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0) >= 50) and (not(M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) or math.max((tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] or 0), (tWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0)) >= 64)) then
        bEnemyHasLongRangeOrHover = true
    else
        local iEnemyCombatThreat = (tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
        if iEnemyCombatThreat > 15 and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
            local tEnemyHover = EntityCategoryFilterDown(categories.HOVER - categories.ENGINEER, tWZTeamData[M28Map.subrefTEnemyUnits])
            if M28Utilities.IsTableEmpty(tEnemyHover) == false then
                if not(M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) then
                    bEnemyHasLongRangeOrHover = true
                elseif tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] == 0 then
                    --More detailed check due to how much better torp launchers are
                    bEnemyHasLongRangeOrHover = true
                else
                    local iHoverThreat = M28UnitInfo.GetMassCostOfUnits(tEnemyHover)
                    if iHoverThreat > 500 or iHoverThreat * 2 > tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] then
                        bEnemyHasLongRangeOrHover = true
                    end

                end
            end
        end
    end
    return bEnemyHasLongRangeOrHover, iOptionalAlliedCumulativeCombatThreatToReturn
end

function IsUnitLongRangeThreat(oUnit)
    if (oUnit[M28UnitInfo.refiDFRange] or 0) > 50 and ((oUnit[M28UnitInfo.refiDFRange] or 0) >= 72 or EntityCategoryContains(M28UnitInfo.refCategoryPD , oUnit.UnitId) or (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) >= 15000 and oUnit[M28UnitInfo.refiDFRange] >= 60) and EntityCategoryContains(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryPD, oUnit.UnitId) and (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) >= 600 and not(oUnit.UnitId == 'url0402') then
        return true
    end
end

function IsM28AIPersonality(aiBrain)
    local sPersonality = ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality
    if string.sub(sPersonality, 1, 3) == 'm28' then return true else return false end
    --Prev code: (ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28ai' or ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28aicheat' or ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28aie' or ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28aiecheat')
end

function DoesTableContainUnderConstructionUnits(tUnits)
    for iUnit, oUnit in tUnits do
        if oUnit:GetFractionComplete() < 1 then return true end
    end
    return false
end

function BuildingWasBeingBuiltButCanBeReclaimedNow(oUnit)
    --Crude way of estimating if a building is no longer being constructed, and hence can be
    if oUnit:GetFractionComplete() < 1 and EntityCategoryContains(M28UnitInfo.refCategoryStructure * M28UnitInfo.refCategoryReclaimable, oUnit.UnitId) then
        local aiBrain = oUnit:GetAIBrain()
        local iTeam = aiBrain.M28Team
        local rRect = M28Utilities.GetRectAroundLocation(oUnit:GetPosition(), 25) --A hive can build from 25 away
        local tUnitsInRect = GetUnitsInRect(rRect)
        if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
            for iRectUnit, oRectUnit in tUnitsInRect do
                if oRectUnit:GetAIBrain().M28Team == iTeam and oRectUnit:GetFractionComplete() == 1 then
                    if oRectUnit:IsUnitState('Repairing') or oRectUnit:IsUnitState('Building') then
                        return false
                    end
                end
            end
        end
    end
    return true
end

function EnemyZoneHasTooMuchAAForBaseBomber(tTargetLZTeamData)
    if tTargetLZTeamData[M28Map.subrefiThreatEnemyGroundAA] >= 15 then return true
    elseif M28Utilities.IsTableEmpty(tTargetLZTeamData[M28Map.subrefTEnemyUnits]) == false then
        local tEnemyGroundAA = EntityCategoryFilterDown(M28UnitInfo.refCategoryGroundAA, tTargetLZTeamData[M28Map.subrefTEnemyUnits])
        if M28Utilities.IsTableEmpty(tEnemyGroundAA) == false then
            for iAA, oAA in tEnemyGroundAA do
                if M28UnitInfo.IsUnitValid(oAA) then
                    if oAA:GetFractionComplete() >= 0.75 or (oAA:GetFractionComplete() >= 0.6 and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oAA.UnitId)) then
                        return true
                    end
                end
            end
        end
    end
    return false
end

function GetBestMobileDFRangeInZone(tLZTeamData)
    local iBestRange = 0
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
            if iRange > iBestRange and iThreat > 0 then iBestRange = iRange end
        end
    end
    return iBestRange
end