---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 05/12/2022 21:39
---
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')

refiEngineerStuckCheckCount = 'M28CEngSC' --time since last recorded the engineer's position when moving
reftEngineerStuckCheckLastPosition = 'M28CEngSP' --Position engineer was at when last did the stuck check

function AreMobileLandUnitsInRect(rRectangleToSearch)
    --returns true if have mobile land units in rRectangleToSearch
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end

    local sFunctionRef = 'AreMobileUnitsInRect'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local tBlockingUnits = GetUnitsInRect(rRectangleToSearch)
    if M28Utilities.IsTableEmpty(tBlockingUnits) then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false
    else
        for iUnit, oUnit in tBlockingUnits do
            if oUnit.UnitId and EntityCategoryContains(categories.MOBILE * categories.LAND, oUnit.UnitId) then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function GetTeamLifetimeBuildCount(iTeam, category)
    --Intended for use for M28 teams only
    local iTotalBuild = 0
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            iTotalBuild = iTotalBuild + GetLifetimeBuildCount(oBrain, category)
        end
    end
    return iTotalBuild
end

function GetLifetimeBuildCount(aiBrain, category)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetLifetimeBuildCount'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iTotalBuilt = 0
    local testCat = category
    if type(category) == 'string' then
        testCat = ParseEntityCategory(category)
    end
    local tUnitBPIDs = EntityCategoryGetUnitList(category)
    local oCurBlueprint
    local iCurCount

    if tUnitBPIDs == nil then
        M28Utilities.ErrorHandler('tUnitBPIDs is nil, so wont have built any')
        iTotalBuilt = 0
    else
        if bDebugMessages == true then LOG(sFunctionRef..': cycling through tUnitBPIDs') end
        for _, sBPID in tUnitBPIDs do
            oCurBlueprint = __blueprints[sBPID]
            iCurCount = aiBrain.M28LifetimeUnitCount[sBPID]
            if iCurCount == nil then iCurCount = 0 end
            if bDebugMessages == true then LOG(sFunctionRef..': sBPID='..sBPID..'; LifetimeCount='..iCurCount) end
            iTotalBuilt = iTotalBuilt + iCurCount
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iTotalBuilt
end

function IsCivilianBrain(aiBrain)
    --Is this an AI brain?
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsCivilianBrain'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if aiBrain.M28IsCivilian == nil then
        local bIsCivilian = false
        if bDebugMessages == true then
            LOG(sFunctionRef..': Brain index='..aiBrain:GetArmyIndex()..'; BrainType='..(aiBrain.BrainType or 'nil')..'; Personality='..ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality..'; Nickname='..(aiBrain.Nickname or 'nil')..'; reprs of brain='..reprs(aiBrain))
        end
        --Basic check that it appears to have the values we'd expect
        --if aiBrain.BrainType and aiBrain.Name then
        if aiBrain.BrainType == nil or aiBrain.BrainType == "AI" or string.find(aiBrain.BrainType, "AI") then
            if bDebugMessages == true then LOG('Dealing with an AI brain') end
            --Does it have no personality?
            if not(ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality) or ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == "" then
                if bDebugMessages == true then LOG(sFunctionRef..': Index='..aiBrain:GetArmyIndex()..'; Has no AI personality so will treat as being a civilian brain unless nickname contains AI or AIX and doesnt contain civilian') end
                bIsCivilian = true
                if string.find(aiBrain.Nickname or aiBrain.Name, '%(AI') and not(string.find(aiBrain.Nickname or aiBrain.Name, "civilian")) then
                    if bDebugMessages == true then LOG(sFunctionRef..': AI nickanme suggests its an actual AI and the developer has forgotten to give it a personality') end
                    bIsCivilian = false
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': campaign adjust - treat most civilians as actual brains, rely on nickname (not precise method). bIsCampaignMap='..tostring(M28Map.bIsCampaignMap)..'; bIsCivilian before adjust='..tostring(bIsCivilian)) end
        if bIsCivilian and M28Map.bIsCampaignMap then
            bIsCivilian = false
            if bDebugMessages == true then LOG(sFunctionRef..': brain name='..aiBrain.Name..'; Nickname='..aiBrain.Nickname..'; does nickanme contain "civilian"='..repru(string.find(aiBrain.Name, "civilian"))) end
            if string.find(aiBrain.Nickname, "civilian") or string.find(aiBrain.Name, "civilian") or string.find(aiBrain.Nickname, "Civilian") or string.find(aiBrain.Nickname, "Civilian") then
                bIsCivilian = true
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bIsCivilian after campaign adjust (if relevant)='..tostring(bIsCivilian)) end
        aiBrain.M28IsCivilian = bIsCivilian
    end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return aiBrain.M28IsCivilian
    end

function GetLifetimeBuildCount(aiBrain, category)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetLifetimeBuildCount'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iTotalBuilt = 0
    local testCat = category
    if type(category) == 'string' then
        testCat = ParseEntityCategory(category)
    end
    local tUnitBPIDs = EntityCategoryGetUnitList(category)
    local oCurBlueprint
    local iCurCount

    if tUnitBPIDs == nil then
        M28Utilities.ErrorHandler('tUnitBPIDs is nil, so wont have built any')
        iTotalBuilt = 0
    else
        if bDebugMessages == true then LOG(sFunctionRef..': cycling through tUnitBPIDs') end
        for _, sBPID in tUnitBPIDs do
            oCurBlueprint = __blueprints[sBPID]
            iCurCount = aiBrain.M28LifetimeUnitCount[sBPID]
            if iCurCount == nil then iCurCount = 0 end
            if bDebugMessages == true then LOG(sFunctionRef..': sBPID='..sBPID..'; LifetimeCount='..iCurCount) end
            iTotalBuilt = iTotalBuilt + iCurCount
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iTotalBuilt
end

function GetFactoryLifetimeCount(oFactory, iCategory, bAllUnitsInsteadOfCategory)
    if bAllUnitsInsteadOfCategory then
        return (oFactory[M28Factory.refiTotalBuildCount] or 0)
    else
        local iTotalCount = 0
        if oFactory[M28Factory.refiBuildCountByBlueprint] then
            for sBPID, iCurCount in oFactory[M28Factory.refiBuildCountByBlueprint] do
                if EntityCategoryContains(iCategory, sBPID) then
                    iTotalCount = iTotalCount + iCurCount
                end
            end
        end
        return iTotalCount
    end
end

function IsEngineerAvailable(oEngineer, bDebugOnly)
    --If bDebugOnly is true then wont adjust counts/tracking (i.e. set to true if are calling for logging purposes, so we dont desync the replay)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsEngineerAvailable'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then
        local iCurPlateau, iCurLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
        LOG(sFunctionRef..': GameTIme '..GetGameTimeSeconds()..': Engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' owned by '..oEngineer:GetAIBrain().Nickname..': oEngineer:GetFractionComplete()='..oEngineer:GetFractionComplete()..'; Unit state='..M28UnitInfo.GetUnitState(oEngineer)..'; Are last orders empty='..tostring(oEngineer[M28Orders.reftiLastOrders] == nil)..'; Engineer Plateau='..(iCurPlateau or 'nil')..'; LZ='..(iCurLZ or 'nil')..'; Is unit state moving='..tostring(oEngineer:IsUnitState('Moving'))..'; Engineer position='..repru(oEngineer:GetPosition()))
    end
    if oEngineer:GetFractionComplete() == 1 and not(oEngineer:IsUnitState('Attached')) and not(oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionSpecialShieldDefence) and not(oEngineer:IsUnitState('Capturing')) and not(oEngineer:IsUnitState('Reclaiming')) and not(oEngineer:IsUnitState('Building')) and not(oEngineer:IsUnitState('Repairing')) then
        M28Orders.UpdateRecordedOrders(oEngineer)
        if not(oEngineer[M28Orders.reftiLastOrders]) then
            if bDebugMessages == true then LOG(sFunctionRef..': Engineer has no last orders active so is available') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        else
            --If engineer is moving but it doesnt have an assignment, or its assignment isnt to move, then make it available, unless it has special micro active
            if oEngineer[M28UnitInfo.refbSpecialMicroActive] then return false
            else
                local iLastOrderType = oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType]
                if bDebugMessages == true then LOG(sFunctionRef..': Engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' owned by '..oEngineer:GetAIBrain().Nickname..' has a last order type of '..(iLastOrderType or 'nil')..'; and an action assigned of '..(oEngineer[M28Engineer.refiAssignedAction] or 'nil')..'; Order for this action='..(M28Engineer.tiActionOrder[oEngineer[M28Engineer.refiAssignedAction]] or 'nil')) end
                --Rare case where engineer acn be given a move order yet doesn't move - below is to try and mitigate it
                if oEngineer:IsUnitState('Moving') and oEngineer[M28Orders.reftiLastOrders][1][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueMove and not(bDebugOnly) then
                    if (oEngineer[refiEngineerStuckCheckCount] or 0) == 0 then
                        oEngineer[refiEngineerStuckCheckCount] = 1
                        oEngineer[reftEngineerStuckCheckLastPosition] = {oEngineer:GetPosition()[1], oEngineer:GetPosition()[2], oEngineer:GetPosition()[3]}
                    else
                        oEngineer[refiEngineerStuckCheckCount] = oEngineer[refiEngineerStuckCheckCount] + 1
                        if oEngineer[refiEngineerStuckCheckCount] >= 10 then
                            oEngineer[refiEngineerStuckCheckCount] = 0
                            if M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(),oEngineer[reftEngineerStuckCheckLastPosition]) <= 0.01 then
                                --Engineer is stuck, clear its orders and treat as available
                                M28Orders.IssueTrackedClearCommands(oEngineer)
                                oEngineer[reftEngineerStuckCheckLastPosition] = nil
                                return true
                            end
                        end
                    end
                end

                if iLastOrderType == M28Orders.refiOrderIssueMove then
                    if oEngineer[M28Engineer.refiAssignedAction] and M28Engineer.tiActionOrder[oEngineer[M28Engineer.refiAssignedAction]] == iLastOrderType then
                        --Engineer not available, unless its order was to move to a land or water zone, in which case check if it is now in that land or water zone
                        if oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionMoveToLandZone then
                            local iCurPlateau, iCurLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
                            if bDebugMessages == true then LOG(sFunctionRef..': Engineer has action to move to LZ, reftiPlateauAndLZToMoveTo='..reprs(oEngineer[M28Land.reftiPlateauAndLZToMoveTo])..'; Eng position iCurPlateau='..(iCurPlateau or 'nil')..'; iCurLZ='..(iCurLZ or 'nil')) end
                            if iCurPlateau == oEngineer[M28Land.reftiPlateauAndLZToMoveTo][1] and iCurLZ == oEngineer[M28Land.reftiPlateauAndLZToMoveTo][2] then
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return true
                            else
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return false
                            end
                        elseif oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionMoveToWaterZone then
                            local iCurWaterZone = M28Map.GetWaterZoneFromPosition(oEngineer:GetPosition(), true, oEngineer)
                            if bDebugMessages == true then LOG(sFunctionRef..': Engineer has action to move to WZ, refiWZToMoveTo='..(oEngineer[M28Navy.refiWZToMoveTo] or 'nil')..'; Eng position iCurWaterZone='..(iCurWaterZone or 'nil')) end
                            if iCurWaterZone and iCurWaterZone == oEngineer[M28Navy.refiWZToMoveTo] then
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return true
                            else
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return false
                            end
                        elseif oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionRunToLandZone then --Make available if no enemies in cur LZ and adjacent LZ, or alternatively none in cur LZ, and have friendly cmobat in cur LZ and dont need more
                            local iCurPlateau, iCurLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
                            if bDebugMessages == true then LOG(sFunctionRef..': Engineer has action to run to LZ, reftiPlateauAndLZToMoveTo='..reprs(oEngineer[M28Land.reftiPlateauAndLZToMoveTo])..'; Eng position iCurPlateau='..(iCurPlateau or 'nil')..'; iCurLZ='..(iCurLZ or 'nil')) end
                            if iCurPlateau == oEngineer[M28Land.reftiPlateauAndLZToMoveTo][1] and iCurLZ == oEngineer[M28Land.reftiPlateauAndLZToMoveTo][2] then
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return true
                            else
                                local tLZTeamData = M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLZ][M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
                                if bDebugMessages == true then LOG(sFunctionRef..': Engineer isnt at LZ to run to yet, are there enemies in this or adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ])) end
                                if not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                    return true
                                else
                                    if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 10 then
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        return false
                                    else
                                        local iTotalEnemyThreatNearby = tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]
                                        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLZ][M28Map.subrefLZAdjacentLandZones]) == false then
                                            for _, iAdjLZ in M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLZ][M28Map.subrefLZAdjacentLandZones] do
                                                iTotalEnemyThreatNearby = iTotalEnemyThreatNearby + M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team][M28Map.subrefTThreatEnemyCombatTotal]
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': iTotalEnemyThreatNearby='..iTotalEnemyThreatNearby..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]) end
                                        if iTotalEnemyThreatNearby * 5 < tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] then
                                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                            return true
                                        end
                                    end
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                    return false
                                end
                            end
                        elseif oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionRunToWaterZone then --Make available if no enemies in cur WZ and adjacent LZ, or alternatively none in cur WZ, and have friendly cmobat in cur WZ and dont need more
                            local iCurWaterZone = M28Map.GetWaterZoneFromPosition(oEngineer:GetPosition(), true, oEngineer)
                            if bDebugMessages == true then LOG(sFunctionRef..': Engineer has action to run to WZ, refiWZToMoveTo='..(oEngineer[M28Navy.refiWZToMoveTo] or 'nil')..'; Eng position iCurWaterZone='..(iCurWaterZone or 'nil')) end
                            if iCurWaterZone and iCurWaterZone == oEngineer[M28Navy.refiWZToMoveTo] then
                                if bDebugMessages == true then LOG(sFunctionRef..': Engi has reached the WZ it wants to run to') end
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return true
                            else
                                local iPond = M28Map.tiPondByWaterZone[iCurWaterZone]
                                local iTeam = oEngineer:GetAIBrain().M28Team
                                local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iCurWaterZone]
                                local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                                if bDebugMessages == true then LOG(sFunctionRef..': Engineer isnt at WZ to run to yet, are there enemies in this or adjacent WZ='..tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])) end
                                if not(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) then
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                    return true
                                else
                                    if tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 10 then
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        return false
                                    else
                                        local iTotalEnemyThreatNearby = tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]
                                        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                                            for iEntry, tSubtable in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                                                local iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                                                iTotalEnemyThreatNearby = iTotalEnemyThreatNearby + (M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] or 0)
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': iTotalEnemyThreatNearby='..iTotalEnemyThreatNearby..'; tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]='..tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]) end
                                        if iTotalEnemyThreatNearby * 5 < tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] then
                                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                            return true
                                        end
                                    end
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                    return false
                                end
                            end
                        else
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return false
                        end
                    else
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return true
                    end
                elseif (iLastOrderType == M28Orders.refiOrderIssueGuard or iLastOrderType == M28Orders.refiOrderIssueCapture) and not(M28UnitInfo.IsUnitValid(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.subrefoOrderUnitTarget]])) then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                else
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return false
                end
            end
        end
    else
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false
    end
end

function IsResourceBlockedByResourceBuilding(iResourceCategory, sResourceBlueprint, tResourceLocation)
    --True if there is a mex or hydro at the location - used since CanBuildStructureAt can return false if reclaim is on the resource location (but we can sitll build there)
    local rRectangleToSearch = M28Utilities.GetRectAroundLocation(tResourceLocation, M28UnitInfo.GetBuildingSize(sResourceBlueprint) * 0.5)
    local tUnitsInRect = GetUnitsInRect(rRectangleToSearch)
    if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
        if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(iResourceCategory, tUnitsInRect)) == false then
            --if sResourceBlueprint == 'ueb1102' then LOG('Have units in rectangle around tResourceLocation='..repru(tResourceLocation)) end
            return true
        end
    end
    return false
end

function CanBuildStorageAtLocation(tLocation)
    if M28Overseer.tAllActiveM28Brains[1].CanBuildStructureAt and M28Overseer.tAllActiveM28Brains[1]:CanBuildStructureAt('ueb1106', tLocation) == true then
        return true
    else
        return not(IsResourceBlockedByResourceBuilding(M28UnitInfo.refCategoryStructure, 'ueb1106', tLocation))
    end
end

function CanBuildOnMexLocation(tMexLocation)
    --True if can build on mex location; will return true if aiBrain result is true
    --Want to use a function in case t urns out reclaim on a mex means aibrain canbuild returns false
    if M28Overseer.tAllActiveM28Brains[1].CanBuildStructureAt and M28Overseer.tAllActiveM28Brains[1]:CanBuildStructureAt('urb1103', tMexLocation) == true then
        return true
    else
        return not(IsResourceBlockedByResourceBuilding(M28UnitInfo.refCategoryMex, 'urb1103', tMexLocation))
    end
end

function CanBuildOnHydroLocation(tHydroLocation)
    --True if can build on hydro; will return true if aiBrain result is true
    --Want to use a function in case t urns out reclaim on a hydro means aibrain canbuild returns false
    if M28Overseer.tAllActiveM28Brains[1].CanBuildStructureAt and M28Overseer.tAllActiveM28Brains[1]:CanBuildStructureAt('ueb1102', tHydroLocation) == true then
        return true
    else
        --local iPlateau, iLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tHydroLocation)
        --LOG('CanBuildOnHydroLocation: Considering for tHydroLocation='..repru(tHydroLocation)..' at iPlateau='..iPlateau..'; iLZ='..iLZ..'; IsResourceBlockedByResourceBuilding='..tostring(IsResourceBlockedByResourceBuilding(M28UnitInfo.refCategoryHydro, 'ueb1102', tHydroLocation)))
        return not(IsResourceBlockedByResourceBuilding(M28UnitInfo.refCategoryHydro, 'ueb1102', tHydroLocation))
    end
end

function IsUnitVisibleSEEBELOW()  end --To help with finding canseeunit
function CanSeeUnit(aiBrain, oUnit, bReturnFalseIfOnlySeeBlip)
    --returns true if aiBrain can see oUnit
    --bReturnFalseIfOnlySeeBlip - if true, then returns false if can see the blip but have never seen what the unit was for the blip; defaults to false
    local iUnitBrain = oUnit:GetAIBrain()
    if iUnitBrain == aiBrain then return true
    else
        local iArmyIndex = aiBrain:GetArmyIndex()
        if not(oUnit.Dead) then
            if not(oUnit.GetBlip) then
                --ErrorHandler('oUnit with UnitID='..(oUnit.UnitId or 'nil')..' has no blip, will assume can see it')
                return true
            else
                local oBlip = oUnit:GetBlip(iArmyIndex)
                if oBlip then
                    if bReturnFalseIfOnlySeeBlip and not(oBlip:IsSeenEver(iArmyIndex)) then return false
                    else return true
                    end
                end
            end
        end
    end
    return false
end

function SafeToUpgradeUnit(oUnit)
    --Returns true if safe to upgrade oUnit:
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
    local bSafeZone = false
    if (iLandZone or 'nil') > 0 then
        local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
        if not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
            bSafeZone = true
        elseif tLZTeamData[M28Map.subrefLZbCoreBase] and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < 150 then
            bSafeZone = true
        end
        --ACU specific:
        if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and tLZTeamData[M28Map.reftClosestFriendlyBase] then
            -- dont treat as safe if low health unless close to a base
            if bSafeZone and M28UnitInfo.GetUnitHealthPercent(oUnit) < 0.5 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) > 10 then
                bSafeZone = false
            end
            --Treat as safe if are near T2 PD and have at least 40% health
            if not(bSafeZone) and M28UnitInfo.GetUnitHealthPercent(oUnit) >= 0.4 and M28Utilities.IsTableEmpty(oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryT2PlusPD, oUnit:GetPosition(), 15, 'Ally')) == false then
                bSafeZone = true
            end
        end

        --If this mex has survived 5 mins and has no enemies in this zone itself, then treat as safe
        if not(bSafeZone) and EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeCreated] or 0) >= 300 then
            bSafeZone = true
        end
    else
        --probably have a water zone - consider if safe to upgrade
        local iWaterZone = M28Map.GetWaterZoneFromPosition(oUnit:GetPosition())
        if (iWaterZone or 0) > 0 then
            local iPond = M28Map.tiPondByWaterZone[iWaterZone]
            local tWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][oUnit:GetAIBrain().M28Team]
            if not(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) then bSafeZone = true end
        end
    end
    if M28Overseer.bNoRushActive then
        if M28Overseer.iNoRushTimer - GetGameTimeSeconds() > 60 then
            bSafeZone = true
        end
    end
    if bSafeZone then
        local bDangerousTML = false
        --TML adjust
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.reftEnemyTML]) == false then
            --Buildings alreayd record TML in range and if covered by TMD
            if EntityCategoryContains(M28UnitInfo.refCategoryProtectFromTML, oUnit.UnitId) then
                if M28Utilities.IsTableEmpty(oUnit[M28Building.reftTMDCoveringThisUnit]) and M28Utilities.IsTableEmpty(oUnit[M28Building.reftTMLInRangeOfThisUnit]) == false then
                    bDangerousTML = true
                end
            end
        else
            --Is this an ACU? If so dont want to upgrade in range of enemy TML unless we have TMD nearby
            if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                local bTMLInRange = false
                for iTML, oTML in M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.reftEnemyTML] do
                    if M28UnitInfo.IsUnitValid(oTML) and M28Utilities.GetDistanceBetweenPositions(oTML:GetPosition(), oUnit:GetPosition()) <= M28Building.iTMLMissileRange + 2 then
                        bTMLInRange = true
                        break
                    end
                end
                if bTMLInRange then
                    --Do we have TMD nearby?
                    local tNearbyTMD = oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD, oUnit:GetPosition(), 25, 'Ally')
                    local bNearbyTMD = false
                    if M28Utilities.IsTableEmpty(tNearbyTMD) == false then
                        for iTMD, oTMD in tNearbyTMD do
                            if M28Utilities.GetDistanceBetweenPositions(oTMD:GetPosition(), oUnit:GetPosition()) <= math.max(12, (oTMD[M28UnitInfo.refiMissileDefenceRange] or 12.5) - 5) then
                                bNearbyTMD = true
                                break
                            end
                        end
                    end
                    if not(bNearbyTMD) then
                        bDangerousTML = true
                    end
                end
            end
        end
        if not(bDangerousTML) then
            return true
        end
    end
    return false

end

function HaveLowMass(aiBrain)
    --Not actually used as yet
    local bHaveLowMass = false
    if aiBrain[M28Economy.refiGrossMassBaseIncome] <= 400 then --i.e. we dont ahve a paragon or crazy amount of SACUs
        local iMassStoredRatio = aiBrain:GetEconomyStoredRatio('MASS')
        if (iMassStoredRatio <= 0.15 or aiBrain:GetEconomyStored('MASS') <= 300) then
            if aiBrain[M28Economy.refiNetMassBaseIncome] < 0.2 then bHaveLowMass = true
            elseif iMassStoredRatio <= 0.05 and aiBrain[M28Economy.refiNetMassBaseIncome] < aiBrain[M28Economy.refiGrossMassBaseIncome] * 0.05 then bHaveLowMass = true
            end
        end
    end
    return bHaveLowMass
end

function TeamHasLowMass(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TeamHasLowMass'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bHaveLowMass = false
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 400 then --i.e. we dont ahve a paragon or crazy amount of SACUs
        local iMassStoredRatio = M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]

        if (iMassStoredRatio <= 0.15 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] <= 300 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] < 0.2 then bHaveLowMass = true
            elseif iMassStoredRatio <= 0.05 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] < M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 0.05 then bHaveLowMass = true
            elseif GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] or -10) < 10 then
                bHaveLowMass = true
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; End of code, bHaveLowMass='..tostring(bHaveLowMass)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]='..M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]..'; Net mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]..'; Time of last mass stall='..(M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bHaveLowMass
end

function HaveLowPower(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'HaveLowPower'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..', team='..iTeam..'; Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] or false)..'; M28Team.tTeamDta[iTeam][M28Team.subrefiGrossEnergyWhenStalled]='..(M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] or 'nil')..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; Just built lots of power='..tostring(M28Team.tTeamData[iTeam][M28Team.refbJustBuiltLotsOfPower])..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; M28Team.tTeamData[iTeam][M28Team.subrefbTooLittleEnergyForUpgrade]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTooLittleEnergyForUpgrade])..'; Min energy per tech='..M28Economy.tiMinEnergyPerTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]) end
    local bHaveLowPower = false
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 80000 then --Paragon gives 1000000 per sec I think
        if not(M28Team.tTeamData[iTeam][M28Team.refbJustBuiltLotsOfPower]) then
            if (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= 0.95) or M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] then
                bHaveLowPower = true
            else
                --Dont have much more energy than when we last stalled - sometimes treat as low power (i.e. if we have low net energy, or dont have 100% energy stored)
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] * 1.05 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= 0.99 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.1 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.1)) then
                    bHaveLowPower = true
                    --Low power levels - apply slightly different test where it's ok to not have 100% energy
                elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 25 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 2.2 then
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] >= math.max(0.35, math.min(0.9, M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] * 2.5)) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 0.5 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] >= 0.9 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= -9)) then
                        --Do nothing (false)
                    else
                        bHaveLowPower = true
                    end
                elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.15 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] < 0.5 or M28Team.tTeamData[iTeam][M28Team.subrefbTooLittleEnergyForUpgrade] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < M28Economy.tiMinEnergyPerTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]) then
                    bHaveLowPower = true
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bHaveLowPower='..tostring(bHaveLowPower)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bHaveLowPower
end

function GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, iCategoryWanted)
    --Returns the number of factories that are building a unit meeting iCategoryWanted
    local iAlreadyBuilding = 0
    local tLZFactories = EntityCategoryFilterDown(categories.FACTORY, tLZTeamData[M28Map.subrefLZTAlliedUnits])
    if M28Utilities.IsTableEmpty(tLZFactories) == false then
        local oCurUnitBuilding
        for iFactory, oFactory in tLZFactories do
            oCurUnitBuilding = oFactory:GetFocusUnit()
            if oCurUnitBuilding and EntityCategoryContains(iCategoryWanted, oCurUnitBuilding) then
                --LOG('Temp to check we have a factory building the category wanted - we do, oFactory='..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; Unit building='..oCurUnitBuilding.UnitId)
                iAlreadyBuilding = iAlreadyBuilding + 1
            end
        end
    end
    return iAlreadyBuilding
end

function WantMorePower(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'WantMorePower'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bWantMorePower = true
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Energy when last unable to build air='..(M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0)..'; Highest factory tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultipler]='..M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultipler]..'; M28Team.tTeamData[iTeam][M28Team.refbJustBuiltLotsOfPower]='..tostring(M28Team.tTeamData[iTeam][M28Team.refbJustBuiltLotsOfPower] or false)..'; HaveLowPower(iTeam)='..tostring(HaveLowPower(iTeam))..'; M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled]='..(M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] or 'nil')) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 1.25 * (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < math.max(250, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.25) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0) + 150) then
        --No change - want more power
        if bDebugMessages == true then LOG(sFunctionRef..': Want more given amount we had when unable to build air units') end
    elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= (30 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] + 160 * math.max(0, (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] - 2))) * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultipler] * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
        --We dont have 1 pgen of our cur tech level (roughly) per brain so want more; i.e. no change
        if bDebugMessages == true then LOG(sFunctionRef..': Want base level of power given our tech level') end
        --Have re recently build lots of power, and at a high level it looks like we should have a decent amount of power for our mass income?
    elseif M28Team.tTeamData[iTeam][M28Team.refbJustBuiltLotsOfPower] and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.3 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.6 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] > 20 * M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.98 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] > 30 * M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass])) then
        bWantMorePower = false
        if bDebugMessages == true then LOG(sFunctionRef..': Just built lots of power so dont want more') end
    else
        if HaveLowPower(iTeam) then
            bWantMorePower = true
            if bDebugMessages == true then LOG(sFunctionRef..': Have low power') end
        else
            local iExtraFactor = 1.1
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 then iExtraFactor = 1.5 end
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < (M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] or 0) * iExtraFactor then bWantMorePower = true
            else
                local iNetPowerWanted
                local iHighestTeamTech = M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]
                if iHighestTeamTech >= 3 then
                    iNetPowerWanted = math.max(50, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.2)
                elseif iHighestTeamTech == 2 then
                    iNetPowerWanted = math.max(15, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.15)
                elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 20 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                    iNetPowerWanted = math.max(3, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.1)
                else
                    iNetPowerWanted = 2
                end
                if M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultipler] > 1 then
                    iNetPowerWanted = iNetPowerWanted * (1 + (M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultipler] - 1) * 0.5)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iNetPowerWanted='..iNetPowerWanted..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]) end
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < iNetPowerWanted then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want more net power') end
                    bWantMorePower = true
                else
                    bWantMorePower = false
                end
            end
        end
    end
    --Override if close to the unit cap and have good net energy already
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if should hold off building due to unit cap, bWantMorePower='..tostring(bWantMorePower)..'; Time since near unit cap='..(GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] or -100))..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]) end
    if bWantMorePower and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] or -100) < 60 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > math.min(250, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.4) then
        bWantMorePower = false
        if bDebugMessages == true then LOG(sFunctionRef..': Dont want more power due to unit cap') end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bWantMorePower='..tostring(bWantMorePower)..'; Just built lots of power='..tostring(M28Team.tTeamData[iTeam][M28Team.refbJustBuiltLotsOfPower] or false)..'; HaveLowPower='..tostring(HaveLowPower(iTeam))..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] or 'nil')..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bWantMorePower
end

function WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'WantToReclaimEnergyNotMass'
    if not(iPlateau) and not(iLandZone) then M28Utilities.ErrorHandler('Invalid arguments for if want to reclaim energy not mass') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; iTeam='..(iTeam or 'nil')..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; Lowest % energy='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] or 'nil')..'; Gross energy='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] or 'nil')..'; Reclaim total energy='..(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTotalEnergyReclaim] or 'nil')..'; Net team energy='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] or 'nil')) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= 0.7 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 80 and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTotalEnergyReclaim] >= 100 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < 2 then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end


function HaveFactionTech(iSubteam, iFactoryType, iFactionWanted, iMinTechLevelNeeded)
    for iCurTech = iMinTechLevelNeeded, 3 do
        if M28Team.tLandSubteamData[iSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactionWanted][iCurTech] > 0 then
            return true
        end
    end
    return false
end

function CloseToEnemyUnit(tStartPosition, tUnitsToCheck, iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
    --Returns true if our distance to any of tUnitsToCheck is <= iDistThreshold; if bIncludeEnemyDFRange is true then our distance to the units is reduced by the enemy unit's DF range (meaning it returns true if we are within iDistThreshold of the enemy unit being able to shoot at us)
    --iAltThresholdToDFRange - if bIncludeEnemyDFRange is true and this also has a value specified, then if we are within iAltThresholdToDFRange will return true regardless of the iDistThreshold test
    --oUnitIfConsideringAngleAndLastShot - if we have a unit that is very vulnerable at lcose range (e.g. a skirmisher unit), then including this here will mean a check is done of the enemy unit facing angle and unit state (to factor in how easily it could close in to us) to decide whether to run or not

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CloseToEnemyUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iCurDist
    if bDebugMessages == true then
        LOG(sFunctionRef..': tStartPosition='..repru(tStartPosition)..'; Size of tUnitsToCheck='..table.getn(tUnitsToCheck)..'; iDistThreshold='..iDistThreshold..'; bIncludeEnemyDFRange='..tostring(bIncludeEnemyDFRange or false))
        for iUnit, oUnit in tUnitsToCheck do
            LOG(sFunctionRef..': Dist to oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' = '..M28Utilities.GetDistanceBetweenPositions(tStartPosition, oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..' based on last known position of '..repru(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; actual unit position='..repru(oUnit:GetPosition())..'; Unit range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Is distance less tahn threshold='..tostring(M28Utilities.GetDistanceBetweenPositions(tStartPosition, oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) < iDistThreshold))
        end
    end
    local bIncludeAngleChecks, iAngleDistMod, iAngleDifferenceThreshold
    local bAreCloseToUnit = false
    if M28UnitInfo.IsUnitValid(oUnitIfConsideringAngleAndLastShot) then
        bIncludeAngleChecks = true
        iAngleDistMod = -3 --i.e. will decrease enemy unit range to us by this amount if they are facing a similar angle to us
        iAngleDifferenceThreshold = 18 --if angle dif is less than this amount, will reduce enemy distance to us by iAngleDistMod
        --iOurFacingAngle = M28UnitInfo.GetUnitFacingAngle(oUnitIfConsideringAngleAndLastShot)

        --Adjust distance threshold if we have fired recently since being in range to fire again is less important
        if bDebugMessages == true then LOG(sFunctionRef..': About to adjust dist threshold based on if we have fired recently, iDistThreshold before adjustment='..iDistThreshold..'; Time='..GetGameTimeSeconds()..'; Last weapon event='..(oUnitIfConsideringAngleAndLastShot[M28UnitInfo.refiLastWeaponEvent] or -100)..'; Time between DF shots='..(oUnitIfConsideringAngleAndLastShot[M28UnitInfo.refiTimeBetweenDFShots] or 'nil')) end
        if GetGameTimeSeconds() - (oUnitIfConsideringAngleAndLastShot[M28UnitInfo.refiLastWeaponEvent] or -100) < (oUnitIfConsideringAngleAndLastShot[M28UnitInfo.refiTimeBetweenDFShots] or oUnitIfConsideringAngleAndLastShot[M28UnitInfo.refiTimeBetweenIFShots] or 100) then
            iDistThreshold = iDistThreshold * 1.06
        else iDistThreshold = iDistThreshold * 0.94
        end
    end
    local iClosestEnemyDist
    if oOptionalFriendlyUnitToRecordClosestEnemy then
        iClosestEnemyDist = 100000
        oOptionalFriendlyUnitToRecordClosestEnemy[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] = nil
    end
    for iUnit, oUnit in tUnitsToCheck do
        if M28UnitInfo.IsUnitValid(oUnit) then
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tStartPosition, oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
            if oOptionalFriendlyUnitToRecordClosestEnemy and iCurDist < iClosestEnemyDist then
                iClosestEnemyDist = iCurDist
                oOptionalFriendlyUnitToRecordClosestEnemy[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] = oUnit
            end
            if bIncludeAngleChecks and EntityCategoryContains(categories.MOBILE, oUnit.UnitId) and M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tStartPosition), M28UnitInfo.GetUnitFacingAngle(oUnit)) <= iAngleDifferenceThreshold then
                if bDebugMessages == true then LOG(sFunctionRef..': Unit facing angle='..M28UnitInfo.GetUnitFacingAngle(oUnit)..'; Angle to start position='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tStartPosition)..'; so will adjust iCurDist '..iCurDist..' by iAngleDistMod='..iAngleDistMod) end
                iCurDist = iCurDist + iAngleDistMod
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bIncludeEnemyDFRange='..tostring(bIncludeEnemyDFRange or false)..'; Unit range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; iCurDist='..iCurDist..'; iDistThreshold='..iDistThreshold..'; iAltThresholdToDFRange='..(iAltThresholdToDFRange or 'nil')) end
            if (bIncludeEnemyDFRange and (iCurDist - (oUnit[M28UnitInfo.refiDFRange] or 0) <= iDistThreshold or iCurDist <= (iAltThresholdToDFRange or 0) or (bIncludeEnemyAntiNavyRange and iCurDist - (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) <= iDistThreshold))) or (not(bIncludeEnemyDFRange) and iCurDist <= iDistThreshold) then
                --Structure specific
                if not(iOptionalDistThresholdForStructure) or iCurDist <= iOptionalDistThresholdForStructure or not(EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Are close to unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                    bAreCloseToUnit = true
                    --Want to keep searching to get the closest enemy unit if dont have one in range and have specified the closest unit be recorded
                    if not(oOptionalFriendlyUnitToRecordClosestEnemy) or iClosestEnemyDist <= -5 + math.max((oOptionalFriendlyUnitToRecordClosestEnemy[M28UnitInfo.refiDFRange] or 0), (oOptionalFriendlyUnitToRecordClosestEnemy[M28UnitInfo.refiIndirectRange] or 0)) then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return true
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Are close to structure but not too close yet, iOptionalDistThresholdForStructure='..iOptionalDistThresholdForStructure) end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bAreCloseToUnit
end

function TeamHasAirControl(iTeam)
--Returns true if any of the air subteams has air control
    local tbSubteams = {}
    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
        tbSubteams[oBrain.M28AirSubteam] = true
    end
    for iAirSubteam, bTrue in tbSubteams do
        if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] then return true end
    end
    return false
end

function WantMoreFactories(iTeam, iPlateau, iLandZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'WantMoreFactories'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --e.g. 1 t1 land factory building tank uses 0.4 mass per tick, so would want 1 factory for every 0.8 mass as a rough baseline; T2 is 0.9 mass per tick, T3 is 1.6; probably want ratio to be 50%-50%-33%

    local tiFactoryToMassByTechRatioWanted = {[1] = 1.2, [2] = 2.2, [3] = 5.5}
    --Adjust factory T1 ratios if we cant path to enemy by land
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
    local iCurIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint])
    local iEnemyIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase])
    if iCurIsland ~= iEnemyIsland and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.35 then
        tiFactoryToMassByTechRatioWanted = {[1]=3.5, [2] = 3.5, [3] = 6.5}
    elseif M28Map.iMapSize <= 256 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 60 then
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 120 then
            tiFactoryToMassByTechRatioWanted[1] = 0.4
        else
            tiFactoryToMassByTechRatioWanted[1] = 0.6
        end
    end
    local iTeamCount = M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]
    if iTeamCount > 1 then
        for iEntry, iFactoryCountWanted in tiFactoryToMassByTechRatioWanted do
            tiFactoryToMassByTechRatioWanted[iEntry] = iFactoryCountWanted / iTeamCount
        end
    end
    local iAverageCurAirAndLandFactories = (M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeLand] or 0) / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] + (M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeAir] or 0) / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]

    local bWantMoreFactories = false
    local bDontWantDueToUnitCap = false
    --Unit cap - want max of 2 factories in the core LZ and no more factories in non-core LZs
    if M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] then
        if not(tLZTeamData[M28Map.subrefLZbCoreBase]) then
            --Dont wnat more factories (no change to default)
            bDontWantDueToUnitCap = true
        else
            local tFactoriesInZone
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
                tFactoriesInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                if M28Utilities.IsTableEmpty(tFactoriesInZone) == false then
                    if table.getn(tFactoriesInZone) >= 2 then
                        --DOnt want more factories (no change to default)
                        bDontWantDueToUnitCap = true
                    end
                end
            end
        end
    end

    --Norush
    if M28Overseer.bNoRushActive and M28Overseer.iNoRushTimer - GetGameTimeSeconds() >= 30 then
        --Only want more factories if we dont have 1 land and 1 air in this LZ
        local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) then return true
        else
            local iFriendlyLand = 0
            local iFriendlyOtherFactory = 0
            local tFriendlyFactory = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
            if M28Utilities.IsTableEmpty(tFriendlyFactory) == false then
                for iUnit, oUnit in tFriendlyFactory do
                    if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) then
                        iFriendlyLand = iFriendlyLand + 1
                    else
                        iFriendlyOtherFactory = iFriendlyOtherFactory + 1
                    end
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            if iFriendlyLand > 0 and iFriendlyOtherFactory > 0 then
                --Dont want more factories
            else
                bWantMoreFactories = true
            end
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if want more factories at gamttime '..GetGameTimeSeconds()..' for iTeam='..iTeam..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; Mass % stored='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] or 'nil')..'; Land fac count='..(M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeLand] or 'nil')..'; Gross mass count='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] or 'nil')..'; Highest factory tech='..(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 'nil')..'; iAverageCurAirAndLandFactories='..(iAverageCurAirAndLandFactories or 'nil')..'; Factories wanted based on gross mass='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] or 0) * (tiFactoryToMassByTechRatioWanted[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] or 0)..'; iCurIsland='..(iCurIsland or 0)..'; iEnemyIsland='..(iEnemyIsland or 0)..'; Time since air fac last failed to have osmething to build='..(GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForAirFactory] or -100))..'; Time since land fac last failed to have something to build='..(GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForLandFactory] or -100))) end
        if not(bWantMoreFactories) and not(bDontWantDueToUnitCap) then
            --Failure to build and have a significant number of factories already (at least 5)
            if (iAverageCurAirAndLandFactories >= 5 or (iAverageCurAirAndLandFactories >= 2.5 and M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 2 and iAverageCurAirAndLandFactories * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 8)) and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForAirFactory] or -100) <= 10 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForLandFactory] or -100) <= 10 and GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeLandFacHadNothingToBuild] or -100) <= 10 then
                --Dont want more factories
                if bDebugMessages == true then LOG(sFunctionRef..': Have high average number of factories so dont want more') end
            else
                --Have we failed to build something at existing land and air factories recently?
                if bDebugMessages == true then LOG(sFunctionRef..': M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; iAverageCurAirAndLandFactories='..iAverageCurAirAndLandFactories..'; Map size='..(M28Map.iMapSize or 'nil')..'; % Stored='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] or 'nil')..'; AiX='..(M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier] or 'nil')..'; Gross mass='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] or 'nil')..'; Time of last stall='..(M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] or 'nil')..'; Highest air fac tech='..(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] or 'nil')..'; Mex count by tech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; Time of last energy stall='..(M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or 'nil')..'; Team has air control='..tostring(TeamHasAirControl(iTeam))) end
                if iAverageCurAirAndLandFactories >= 2 and ((GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForLandFactory] or -100)) <= 10 and (TeamHasLowMass(iTeam) or GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeLandFacHadNothingToBuild] or -100) <= 10)) and ((GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForAirFactory] or -100)) <= 10 or not(DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData))) then
                    --Dont want more factories
                    --Teamgame with high number of factories
                    if bDebugMessages == true then LOG(sFunctionRef..': Failed ot build anythign at land factory recently, and either failed to build at air factory or want land fac instead of air fac') end
                elseif iTeamCount > 1 and iAverageCurAirAndLandFactories >= 3 and iAverageCurAirAndLandFactories * iTeamCount >= 10 and iAverageCurAirAndLandFactories >= (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] or 0) * (tiFactoryToMassByTechRatioWanted[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] or 0) and TeamHasLowMass(iTeam) then
                    --Dont want more factories
                    if bDebugMessages == true then LOG(sFunctionRef..': Have lots of factories in teamgame and have low mass so dont want more') end
                    --More air fac if enemy has large air to ground threat and we dont have air control, and have good gross eco (regardless of current eco)
                elseif iAverageCurAirAndLandFactories <= M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.001 and M28Map.iMapSize > 512 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.1 or iAverageCurAirAndLandFactories * 2.25 * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier] <= M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] - 3) and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] or -100) >= 10 and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 10000 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 and not(TeamHasAirControl(iTeam)) and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 12) and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or -100) >= 10 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy has large air to ground threat so want more factories (on the assumption we will end up getting more air factories) to deal with it') end
                    bWantMoreFactories = true
                elseif (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.6 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] or -120) >= 120 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or -120) >= 120 and (GetGameTimeSeconds() >= 300 or GetGameTimeSeconds() >= 300 / M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier]))
                or ((iCurIsland == iEnemyIsland or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 or iAverageCurAirAndLandFactories <= (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] or 0) * (tiFactoryToMassByTechRatioWanted[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] or 0))
                        and     (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.05 or
                        (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.01 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) == false and table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) >= 3))
                        and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 or (iAverageCurAirAndLandFactories <= math.max(4 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount], M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * tiFactoryToMassByTechRatioWanted[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]])) or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 and GetGameTimeSeconds() <= 600))) then
                    --If enemy has a firebase then dont want more factories if dont have lots of mass
                    if not(WantToEcoDueToEnemyFirebase(iTeam, tLZTeamData, iPlateau)) then
                        --Do we have the energy to support another factory?
                        if bDebugMessages == true then LOG(sFunctionRef..': iAverageCurAirAndLandFactories='..iAverageCurAirAndLandFactories..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]..'; Playable area iMapSize='..M28Map.iMapSize..' Team mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]) end

                        --Small map specific - want loads of land factories
                        if M28Map.iMapSize <= 256 and iAverageCurAirAndLandFactories <= M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * tiFactoryToMassByTechRatioWanted[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 30 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0) then
                            bWantMoreFactories = true

                        elseif iAverageCurAirAndLandFactories >= 2 and iCurIsland == iEnemyIsland and ((M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeAir] or 0) > 0 and HaveLowPower(iTeam)) then
                            --Dont want more factories
                            if bDebugMessages == true then LOG(sFunctionRef..': Have low power so dont want more factories') end

                            --Cap on no. of factories on larger maps
                        elseif iAverageCurAirAndLandFactories >= 4 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] < 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] > 0 and M28Map.iMapSize > 256 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] < 8000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.75 then
                            --Dont want more factories
                            if bDebugMessages == true then LOG(sFunctionRef..': Cap on number of factories for larger maps') end

                            --If we dont have at least 25% mass stored, do we have an enemy in the same plateau as us who is within 300 land travel distance?
                        elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] < 0.25 or (iAverageCurAirAndLandFactories == 1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] < 0.4 and GetGameTimeSeconds() <= 300) then
                            local iStartPlateau, iStartLandZone
                            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
                                iStartPlateau, iStartLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                                if iStartPlateau == iPlateau and iStartLandZone > 0 then
                                    if M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iStartLandZone) <= 350 then
                                        bWantMoreFactories = true
                                        break
                                    end
                                end
                            end
                        else
                            bWantMoreFactories = true
                        end
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': We dont have enough eco to justify more factories') end
                end
            end
        end
    end
    --Exception - get more factories if base level of mass income per brain
    if not(bWantMoreFactories) and not(bDontWantDueToUnitCap) and iAverageCurAirAndLandFactories == 1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2 then
        if bDebugMessages == true then LOG(sFunctionRef..': We have at least 20 mass per sec so want to have more than 1 factory') end
        bWantMoreFactories = true
    end
    --decent eco and air fac count is < 1 on average in teamgame (ie want every player to consider getting air fac)
    if not(bWantMoreFactories) and iTeamCount > 1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 8 * iTeamCount and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 100 and tLZTeamData[M28Map.subrefLZbCoreBase] and not(HaveLowPower(iTeam)) then
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
            local tAirFacs = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
            if M28Utilities.IsTableEmpty(tAirFacs) then
                bWantMoreFactories = true
            end
        end
    end
    if bWantMoreFactories then
        --Double-check - if we would want an air fac, and already have one, and arent at T2 air yet, then dont get more factories
        if iAverageCurAirAndLandFactories >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] <= 1 and DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) then
            local iAirFacsInLZ = 0
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
                local tFriendlyAirFac = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                if M28Utilities.IsTableEmpty(tFriendlyAirFac) == false then
                    iAirFacsInLZ = table.getn(tFriendlyAirFac)
                end
            end
            if iAirFacsInLZ >= 1 then bWantMoreFactories = false end
        end
    end

    --More factories in cases where overflowing and have no T3 engineers or active upgrades (e.g. campaign missions with unit restrictions)
    if not(bWantMoreFactories) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.99 and tLZTeamData[M28Map.subrefLZbCoreBase] and iAverageCurAirAndLandFactories <= 15 and not(HaveLowPower(iTeam)) then
        bWantMoreFactories = true
    end

    --Override - if we dont have a HQ for the factory type then want to rebuild it
    if not(bWantMoreFactories) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] == 0 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] == 0) then
        --Is it likely we have built and then lost the factory?
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] == 0 and (M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeAir] or 0) > 0 then
            bWantMoreFactories = true
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] == 0 and (M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeLand] or 0) > 0 then
            bWantMoreFactories = true
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bWantMoreFactories='..tostring(bWantMoreFactories)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bWantMoreFactories
end

function GetActiveMexUpgrades(tLZTeamData)
    local iActiveMexUpgrades = 0
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then
        for iUpgrade, oUpgrade in tLZTeamData[M28Map.subrefActiveUpgrades] do
            if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUpgrade.UnitId) then iActiveMexUpgrades = iActiveMexUpgrades + 1 end
        end
    end
    return iActiveMexUpgrades
end

function CanUnitUseOvercharge(aiBrain, oUnit)
    --For now checks if enough energy and not underwater and not fired in last 5s; separate function used as may want to expand this with rate of fire check in future
    local sFunctionRef = 'CanUnitUseOvercharge'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local oBP = oUnit:GetBlueprint()
    local iEnergyNeeded
    local bCanUseOC = false
    if GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastOverchargeShot] or -100) >= 5 then
        for iWeapon, oWeapon in oBP.Weapon do
            if oWeapon.OverChargeWeapon then
                if oWeapon.EnergyRequired then
                    iEnergyNeeded = oWeapon.EnergyRequired
                    break
                end
            end
        end

        if aiBrain:GetEconomyStored('ENERGY') >= (iEnergyNeeded or 5000) then bCanUseOC = true end
        if bDebugMessages == true then LOG(sFunctionRef..': iEnergyNeeded='..iEnergyNeeded..'; aiBrain:GetEconomyStored='..aiBrain:GetEconomyStored('ENERGY')..'; bCanUseOC='..tostring(bCanUseOC)) end
        if bCanUseOC == true then
            --Check if underwater
            local oUnitPosition = oUnit:GetPosition()
            local iHeightAtWhichConsideredUnderwater = M28Map.IsUnderwater(oUnitPosition, true) + 0.25 --small margin of error
            local tFiringPositionStart = M28Logic.GetDirectFireWeaponPosition(oUnit)
            if tFiringPositionStart then
                local iFiringHeight = tFiringPositionStart[2]
                if iFiringHeight <= iHeightAtWhichConsideredUnderwater then
                    if bDebugMessages == true then LOG(sFunctionRef..': ACU is underwater; iFiringHeight='..iFiringHeight..'; iHeightAtWhichConsideredUnderwater='..iHeightAtWhichConsideredUnderwater) end
                    bCanUseOC = false
                end
            end
        end
    elseif bDebugMessages == true then LOG(sFunctionRef..': Has been less tahn 5s since last overcharged')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bCanUseOC
end

function WantToEcoDueToEnemyFirebase(iTeam, tLZTeamData, iPlateau)
    local bEnemyHasFirebaseAwayFromCoreLZ = false --true if enemy both has a firebase, and we dont have a firebase in range of this LZ or a core LZ
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau]) == false then
        bEnemyHasFirebaseAwayFromCoreLZ = true
        for iFBLZ, tSubtable in M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau] do
            if tSubtable[M28Team.subrefbInRangeOfCoreLZ] then bEnemyHasFirebaseAwayFromCoreLZ = false end
        end
        if bEnemyHasFirebaseAwayFromCoreLZ then
            --If we have any <T3 mexes in this LZ then eco
            if tLZTeamData[M28Map.subrefMexCountByTech][1] + tLZTeamData[M28Map.subrefMexCountByTech][2] > 0 then
                if TeamHasLowMass(iTeam) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] < 0.4 then
                    return true
                end
            end
        end
    end
    return false
end

function HaveEnoughThreatToAttack(tLZTeamData, iOurCombatThreat, iEnemyCombatThreat, iFirebaseThreatAdjust, bHaveSignificantCombatCloserToFirebase)
    if iOurCombatThreat > iEnemyCombatThreat * 1.4 then
        return true
    elseif  iOurCombatThreat > iEnemyCombatThreat and ((iFirebaseThreatAdjust > 0 and bHaveSignificantCombatCloserToFirebase) or tLZTeamData[M28Map.subrefLZTValue] > iOurCombatThreat * 0.5 or M28Map.iMapSize <= 256 or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false) then
        return true
    elseif tLZTeamData[M28Map.subrefLZbCoreBase] and iOurCombatThreat > iEnemyCombatThreat * 0.8 then
        return true
    end
    return false
end

function DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)
    --Returns true if want an air factory - to be used where we want more production, so we can decide whether to get +1 air fac or +1 land fac

    local sFunctionRef = 'DoWeWantAirFactoryInsteadOfLandFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --First check in case of unit restrictions
    if M28Overseer.bAirFactoriesCantBeBuilt then
        if bDebugMessages == true then LOG(sFunctionRef..': Air factories seem to be disabled so wont try to build') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false
    else
        --Recently failed to build anything at air fac, and either dont have low power or are on the same island as the nearest enemy base, or have dangerous enemies nearby
        if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForAirFactory] or -100) <= 10 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] or 0) > 0
            and ((GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeAirFacHadNothingToBuild] or -100) <= 5 or tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) or (not(HaveLowPower(iTeam) and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForAirFactory] or -100) <= 1.5))) then
            if bDebugMessages == true then LOG(sFunctionRef..': Recently failed to find anything to build for air factory so will get land factory instead') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return false
        else
            --Norush
            if M28Overseer.bNoRushActive and M28Overseer.iNoRushTimer - GetGameTimeSeconds() >= 30 then
                local iLandFactoriesHave = 0
                if (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] or 0) > 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
                    local tLandFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                    if bDebugMessages == true then LOG(sFunctionRef..': Is tLandFactories empty='..tostring(M28Utilities.IsTableEmpty(tLandFactories))) end
                    if M28Utilities.IsTableEmpty(tLandFactories) == false then
                        iLandFactoriesHave = table.getn(tLandFactories)
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': No rush mode is active, iLandFactories='..iLandFactoriesHave) end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                if iLandFactoriesHave >= 1 then return true else return false end
            else
                local iOurIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint])
                if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Is this core base='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase] or false)..'; iOurIsland='..iOurIsland..'; Closest friendly base island='..NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestFriendlyBase])) end
                if tLZTeamData[M28Map.subrefLZbCoreBase] or iOurIsland == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestFriendlyBase]) then
                    --If are low on power and can path to enemy with land that isn't far away and dont have T2 air yet then get land factory; also get land if air facs arent able to build air units and we have lots of mass
                    local iEnemyIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase])
                    local iOurPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tLZData[M28Map.subrefMidpoint])
                    local iEnemyPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tLZTeamData[M28Map.reftClosestEnemyBase])
                    if bDebugMessages == true then LOG(sFunctionRef..': iOurIsland='..iOurIsland..'; iEnemyIsland='..(iEnemyIsland or 'nil')..'; iOurPlateau='..iOurPlateau..'; iEnemyPlateau='..(iEnemyPlateau or 'nil')) end
                    if (iOurIsland == iEnemyIsland and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= 0.8 or (iOurPlateau == iEnemyPlateau and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0) * 1.1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': We want land fac1') end
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return false
                    else
                        --Are in core base or we are in same island as core base
                        local iLandFactoriesWantedBeforeAir = 1
                        local iLandFactoriesHave = 0
                        local iAirFactoriesForEveryLandFactory = 1
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
                            local tLandFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                            if M28Utilities.IsTableEmpty(tLandFactories) == false then
                                iLandFactoriesHave = table.getn(tLandFactories)
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iLandFactoriesHave='..iLandFactoriesHave) end
                        if iLandFactoriesHave < 1 then
                            if bDebugMessages == true then LOG(sFunctionRef..': We want land fac2') end
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return false
                        else
                            --How many land factories do we want
                            if not(iOurIsland == iEnemyIsland) then
                                if not(iOurPlateau == iEnemyPlateau) and iLandFactoriesHave >= 2 then
                                    --cant path to enemy even with amphibious so land facs are only for engis, so want max of 2
                                    if bDebugMessages == true then LOG(sFunctionRef..': We want air fac1') end
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                    return true
                                else
                                    --Cant path to enemy except with amphibious, so dont want lots of land factories
                                    iLandFactoriesWantedBeforeAir = 1
                                    --Exception if low gross power
                                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 22 then
                                        iLandFactoriesWantedBeforeAir = 2
                                    end
                                    iAirFactoriesForEveryLandFactory = 5
                                end
                            else
                                --Can path to enemy with land, base number of factories wanted on distance to enemy base
                                local iEnemyBaseDist = M28Utilities.GetDistanceBetweenPositions(  tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase])
                                --Campaign - enemy base location can be messed up, at higher tech levels treat base as furhter away so we get more air instead of land
                                if M28Map.bIsCampaignMap and iEnemyBaseDist < 500 and M28Map.iMapSize >= 512 and iLandFactoriesHave >= 2 then
                                    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 2 then
                                        iEnemyBaseDist = math.max(iEnemyBaseDist, M28Map.iMapSize * 0.75)
                                    end
                                end
                                if iEnemyBaseDist >= 500 then
                                    iLandFactoriesWantedBeforeAir = 1
                                    iAirFactoriesForEveryLandFactory = 4
                                elseif iEnemyBaseDist >= 350 then
                                    iLandFactoriesWantedBeforeAir = 2
                                    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] <= 1 then
                                        iAirFactoriesForEveryLandFactory = 1
                                    else
                                        iAirFactoriesForEveryLandFactory = 4
                                    end
                                else
                                    iLandFactoriesWantedBeforeAir = 3
                                    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] <= 1 and not(M28Map.bIsCampaignMap) then
                                        iAirFactoriesForEveryLandFactory = 0.25
                                        if M28Map.iMapSize <= 256 and iEnemyBaseDist <= 210 then
                                            iLandFactoriesWantedBeforeAir = 7
                                        end
                                    else
                                        if iEnemyBaseDist <= 250 then
                                            --Somtimes on campaign map thenearest enemy base is messed up
                                            if M28Map.bIsCampaignMap then
                                                if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 2 then
                                                    iAirFactoriesForEveryLandFactory = 1.25
                                                else
                                                    iAirFactoriesForEveryLandFactory = 0.75
                                                end
                                            else
                                                iAirFactoriesForEveryLandFactory = 0.5
                                            end
                                        else
                                            iAirFactoriesForEveryLandFactory = 3
                                        end
                                    end
                                end
                            end
                            if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] == 1 then
                                iLandFactoriesWantedBeforeAir = iLandFactoriesWantedBeforeAir + 1
                                iAirFactoriesForEveryLandFactory = iAirFactoriesForEveryLandFactory * 0.8
                            end
                            if iLandFactoriesHave >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 1 and M28Map.bIsCampaignMap then
                                iAirFactoriesForEveryLandFactory = math.max(iAirFactoriesForEveryLandFactory, 1)
                                iLandFactoriesWantedBeforeAir = math.min(iLandFactoriesWantedBeforeAir, 3)
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iAirFactoriesForEveryLandFactory='..iAirFactoriesForEveryLandFactory..'; iLandFactoriesWantedBeforeAir='..iLandFactoriesWantedBeforeAir..'; iLandFactoriesHave='..iLandFactoriesHave) end
                            if iLandFactoriesHave < iLandFactoriesWantedBeforeAir then
                                if bDebugMessages == true then LOG(sFunctionRef..': We want land fac3') end
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return false
                            else
                                --Have min number of land factories, now check how many air factories we have
                                local iAirFactoriesHave = 0
                                if (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] or 0) > 0 then
                                    local tAirFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                                    if M28Utilities.IsTableEmpty(tAirFactories) == false then
                                        iAirFactoriesHave = table.getn(tAirFactories)
                                    end
                                end
                                local iAirFactoriesWanted = math.ceil(iLandFactoriesHave * iAirFactoriesForEveryLandFactory)
                                if bDebugMessages == true then LOG(sFunctionRef..': iAirFactoriesWanted='..iAirFactoriesWanted..'; iAirFactoriesHave='..iAirFactoriesHave) end
                                if iAirFactoriesWanted > iAirFactoriesHave then
                                    if bDebugMessages == true then LOG(sFunctionRef..': We want air fac2') end
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                    return true
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': We want land fac4') end
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                    return false
                                end
                            end
                        end
                    end
                else
                    --Dif island to nearest start position so presumably want land factories to take contorl of island/plateau
                    if bDebugMessages == true then LOG(sFunctionRef..': Different island to start position so want land factories to take control of the island, we want land fac5') end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return false
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetThreatOfApproachingEnemyACUsAndNearestACU(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    --Will return the combat threat of any approaching enemy ACUs and the position of the nearest ACU (usfficiently in range); also updates the time of hte appraoching threat
    local sFunctionRef = 'GetThreatOfApproachingEnemyACUsAndNearestACU'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end

    local iTotalACUThreat = 0
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Is table of enemy ACUs empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) == false then
        local tMidpoint = tLZData[M28Map.subrefMidpoint]
        local iDistanceThreshold = math.max(math.min(M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tMidpoint) * 0.75, 250), 175)
        local tACUsInRange = {}
        local iNearestACUDist = 100000
        local oNearestACU
        local iCurDist
        for iACU, oACU in M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs] do
            if M28UnitInfo.IsUnitValid(oACU) then
                iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tMidpoint)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy ACU '..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' owned by '..oACU:GetAIBrain().Nickname..'; iCurDist Distance to midpoint='..iCurDist..'; iDistanceThreshold='..iDistanceThreshold) end
                if iCurDist <= iDistanceThreshold then
                    table.insert(tACUsInRange, oACU)
                    if bDebugMessages == true then LOG(sFunctionRef..': Adding ACU as an in range enemy unit') end
                    if iCurDist < iNearestACUDist then
                        iNearestACUDist = iCurDist
                        oNearestACU = oACU
                    end
                end
            end
        end
        iTotalACUThreat = M28UnitInfo.GetCombatThreatRating(tACUsInRange, true)
        if bDebugMessages == true then LOG(sFunctionRef..': iTotalACUThreat='..iTotalACUThreat) end
        if iTotalACUThreat > 0 and tLZTeamData[M28Map.subrefLZbCoreBase] then
            if not(M28Team.tTeamData[iTeam][M28Team.reftCoreLZsTimeOfApproachingACUByPlateauAndZone]) then M28Team.tTeamData[iTeam][M28Team.reftCoreLZsTimeOfApproachingACUByPlateauAndZone] = {} end
            if not(M28Team.tTeamData[iTeam][M28Team.reftCoreLZsTimeOfApproachingACUByPlateauAndZone][iPlateau]) then M28Team.tTeamData[iTeam][M28Team.reftCoreLZsTimeOfApproachingACUByPlateauAndZone][iPlateau] = {} end
            M28Team.tTeamData[iTeam][M28Team.reftCoreLZsTimeOfApproachingACUByPlateauAndZone][iPlateau][iLandZone] = GetGameTimeSeconds()
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            if oNearestACU then return iTotalACUThreat, oNearestACU:GetPosition() end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iTotalACUThreat, nil
end

function NoRushPreventingHydro(tLZOrWZData)
    --If norush is active then returns true if any hydro points in this LZ/WZ are outside the norush radius of the nearest allied base
    local sFunctionRef = 'NoRushPreventingHydro'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end

    if bDebugMessages == true then LOG(sFunctionRef..': Is table of hydro unbuilt locations empty='..tostring(tLZOrWZData[M28Map.subrefHydroUnbuiltLocations])) end
    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroUnbuiltLocations]) == false then
        for iEntry, tResource in tLZOrWZData[M28Map.subrefHydroUnbuiltLocations] do
            if bDebugMessages == true then LOG(sFunctionRef..': tResource='..repru(tResource)..'; Norush range='..M28Overseer.iNoRushRange..'; repru of M28Overseer.reftNoRushM28StartPoints='..repru(M28Overseer.reftNoRushM28StartPoints)) end
            for iStart, tStart in M28Overseer.reftNoRushM28StartPoints do
                if M28Utilities.GetDistanceBetweenPositions(tResource, tStart) > M28Overseer.iNoRushRange then
                    if bDebugMessages == true then LOG(sFunctionRef..': Dist to tStart '..repru(tStart)..' is '..M28Utilities.GetDistanceBetweenPositions(tResource, tStart)..' so are outside norush range') end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function IsLocationInPlayableArea(tLocation)
    if tLocation[1] > M28Map.rMapPlayableArea[1] and  tLocation[1] < M28Map.rMapPlayableArea[3] and tLocation[3] > M28Map.rMapPlayableArea[2] and  tLocation[3] < M28Map.rMapPlayableArea[4] then
        return true
    else
        return false
    end
end

function DoesACUHaveValidOrder(oACU)
    --Checks if either hte ACU has no last order, or the last order is to build something that it cant build
    local sFunctionRef = 'DoesACUHaveValidOrder'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tLastOrders = oACU[M28Orders.reftiLastOrders]
    if bDebugMessages == true then LOG(sFunctionRef..': tLastOrders='..reprs(tLastOrders)) end
    if not(tLastOrders) then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false
    elseif M28Utilities.IsTableEmpty(tLastOrders) then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false
    else
        local tLastOrder = tLastOrders[oACU[M28Orders.refiOrderCount]]
        if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild then
            if bDebugMessages == true then LOG(sFunctionRef..': Last order was to build somethingw ith blueprint '..(tLastOrder[M28Orders.subrefsOrderBlueprint] or 'nil')..'; Can build='..tostring(oACU:CanBuild(tLastOrder[M28Orders.subrefsOrderBlueprint]))) end
            if oACU:CanBuild(tLastOrder[M28Orders.subrefsOrderBlueprint]) then
                --We can build last order, but are we trying to build a mex somewhere that already has a completed mex?
                if EntityCategoryContains(M28UnitInfo.refCategoryMex, tLastOrder[M28Orders.subrefsOrderBlueprint]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Were trying to build a mex, Last position='..repru(tLastOrder[M28Orders.subreftOrderPosition])..'; CanBuildOnMexLocation='..tostring(CanBuildOnMexLocation(tLastOrder[M28Orders.subreftOrderPosition]))..'; playable area='..repru(M28Map.rMapPlayableArea)..'; Dist to ACU='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLastOrder[M28Orders.subreftOrderPosition])) end
                    if M28Map.InPlayableArea(tLastOrder[M28Orders.subreftOrderPosition]) then
                        if CanBuildOnMexLocation(tLastOrder[M28Orders.subreftOrderPosition]) then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        else
                            --Cant build the mex, is it because there is a mex there?
                            local tUnitsNearPosition = GetUnitsInRect(M28Utilities.GetRectAroundLocation(tLastOrder[M28Orders.subreftOrderPosition], 1.8))
                            local bBlockedByCompletedMexOnOurTeam = false
                            if M28Utilities.IsTableEmpty(tUnitsNearPosition) == false then
                                local tMexesNearPosition = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tUnitsNearPosition)
                                if M28Utilities.IsTableEmpty(tMexesNearPosition) == false then
                                    for iMex, oMex in tMexesNearPosition do
                                        if oMex:GetFractionComplete() == 1 and IsAlly(oMex:GetAIBrain():GetArmyIndex(), oACU:GetAIBrain():GetArmyIndex()) then
                                            bBlockedByCompletedMexOnOurTeam = true
                                            break
                                        end
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Trying to build a mex, bBlockedByCompletedMexOnOurTeam='..tostring(bBlockedByCompletedMexOnOurTeam)) end
                            if bBlockedByCompletedMexOnOurTeam then
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return false
                            else
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return true
                            end
                        end
                    else
                        --Not in playable area
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return false
                    end
                else
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                end
            else
                --Cant build last order
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return false
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return true
end

function DoWeWantToSynchroniseMMLShots(iPlateau, iLandZone, tLZData, tLZTeamData, iTeam, iFriendlyBestMobileIndirectRange, iEnemyBestDFRange)
    --Consider synchronising shots with MML if we have enough to warrant it and they are faced with non-Aeon TMD
    local sFunctionRef = 'DoWeWantToSynchroniseMMLShots'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bConsiderSpecialMMLLogic = false
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; iPlateau '..iPlateau..'; iLandZOne '..iLandZone..'; tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMD]='..(tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMD] or 'nil')) end
    if GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMD] or -100) <= 15 then
        if bDebugMessages == true then LOG(sFunctionRef..': tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]..'; tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat]='..(tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 'nil')..'; iFriendlyBestMobileIndirectRange='..iFriendlyBestMobileIndirectRange..'; iEnemyBestDFRange='..iEnemyBestDFRange..'; tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange]='..tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange]) end
        if (tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] or 0) >= 700 and (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) == 0 and (iFriendlyBestMobileIndirectRange or 0) > (iEnemyBestDFRange or 0) and iFriendlyBestMobileIndirectRange > (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0) then
            local bEnemyHasAeonTMD = false --also includes loyalists and naval TMD
            local bEnemyHasNonAeonTMD = false
            function UpdateNearbyTMD(iAdjLZ)
                local tAdjLZTeamData
                if iAdjLZ == iLandZone then tAdjLZTeamData = tLZTeamData else tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam] end
                if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    local tZoneTMD = EntityCategoryFilterDown(M28UnitInfo.refCategoryTMD + categories.ANTIMISSILE * categories.MOBILE, tAdjLZTeamData[M28Map.subrefTEnemyUnits])
                    if M28Utilities.IsTableEmpty(tZoneTMD) == false then
                        bEnemyHasNonAeonTMD = true
                        if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.AEON + categories.ANTIMISSILE * categories.MOBILE, tZoneTMD)) == false then
                            bEnemyHasAeonTMD = true
                        end
                    end
                end
            end
            UpdateNearbyTMD(iLandZone)
            if not(bEnemyHasAeonTMD) then
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        UpdateNearbyTMD(iAdjLZ)
                        if bEnemyHasAeonTMD then break end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bEnemyHasAeonTMD='..tostring(bEnemyHasAeonTMD)..'; bEnemyHasNonAeonTMD='..tostring(bEnemyHasNonAeonTMD)) end
            if not(bEnemyHasAeonTMD) and bEnemyHasNonAeonTMD then
                bConsiderSpecialMMLLogic = true
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bConsiderSpecialMMLLogic='..tostring(bConsiderSpecialMMLLogic)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bConsiderSpecialMMLLogic
end

function IsTargetNearActiveNukeTarget(tTarget, iTeam, iDistThreshold)
    --Returns true if are within iDistThreshold of an active nuke target
    local sFunctionRef = 'IsTargetNearActiveNukeTarget'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bNearTarget = false
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Is table of recently fired nuke launchers empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers]) == false then
        local iLauncherCount = table.getn(M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers])
        for iCurLauncher = iLauncherCount, 1, -1 do
            local oLauncher = M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers][iCurLauncher]
            if bDebugMessages == true then LOG(sFunctionRef..': Considering oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..'; Is launcher still valid='..tostring(M28UnitInfo.IsUnitValid(oLauncher))..'; Active nuke target='..repru(oLauncher[M28Building.reftActiveNukeTarget])) end
            if not(M28UnitInfo.IsUnitValid(oLauncher)) or not(oLauncher[M28Building.reftActiveNukeTarget]) then
                table.remove(M28Team.tTeamData[iTeam][M28Team.reftoRecentlyFiredAlliedNukeLaunchers], iCurLauncher)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Launcher target='..repru(oLauncher[M28Building.reftActiveNukeTarget])..'; tTarget='..repru(tTarget)..'; Dist='..M28Utilities.GetDistanceBetweenPositions(oLauncher[M28Building.reftActiveNukeTarget], tTarget)..'; iDistThreshold='..iDistThreshold) end
                if M28Utilities.GetDistanceBetweenPositions(oLauncher[M28Building.reftActiveNukeTarget], tTarget) <= iDistThreshold then
                    bNearTarget = true
                    break
                end
            end

        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tTarget='..repru(tTarget)..'; bNearTarget='..tostring(bNearTarget)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bNearTarget
end

function IsTableOfUnitsStillValid(tUnits, bInvalidIfFullHealth)
    --bInvalidIfFullHealth - e.g. if have a table of units to repair, set this to true
    local sFunctionRef = 'IsTableOfUnitsStillValid'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(tUnits) == false then
        local iEntryCount = table.getn(tUnits)
        for iCurEntry = iEntryCount, 1, -1 do
            local oUnit = tUnits[iCurEntry]
            --if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Is oUnit.GetHealth nil='..tostring(oUnit.GetHealth == nil)) end
            if not(M28UnitInfo.IsUnitValid(oUnit)) or (bInvalidIfFullHealth and M28UnitInfo.GetUnitHealthPercent(oUnit) == 1) then
                if bDebugMessages == true then LOG(sFunctionRef..': Removing unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' at time '..GetGameTimeSeconds()..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; bInvalidIfFullHealth='..tostring(bInvalidIfFullHealth or false)) end
                table.remove(tUnits, iCurEntry)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Do we still have a table of valid units? is it empty='..tostring(M28Utilities.IsTableEmpty(tUnits))) end
        if M28Utilities.IsTableEmpty(tUnits) == false then
            return true
        end
    end
    return false
end

function IsPositionCloseToZoneEdge(iPlateauOrZero, iLandOrWaterZone, iMaxDistToEdgeOfAdjacentZone, tStartPoint)
    --returns true if are within iMaxDistToEdgeOfAdjacentZone of the edge of iLandOrWaterZone, i.e. if this is positive, then will return true if are anywhere in that zone, or outside it by iMaxDistToEdgeOfAdjacentZone; if is a negative number then must be inside the zone by the negativenumber amount
    --Only an approximation - does a square around the outer edges of the zone to estimate
    local tLZOrWZData

    local tMinPosition, tMaxPosition
    if iPlateauOrZero == 0 then
        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        tMinPosition = M28Map.GetPositionFromPathingSegments(tLZOrWZData[M28Map.subrefWZMinSegX], tLZOrWZData[M28Map.subrefWZMinSegZ])
        tMaxPosition = M28Map.GetPositionFromPathingSegments(tLZOrWZData[M28Map.subrefWZMaxSegX], tLZOrWZData[M28Map.subrefWZMaxSegZ])
    else
        tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        tMinPosition = M28Map.GetPositionFromPathingSegments(tLZOrWZData[M28Map.subrefLZMinSegX], tLZOrWZData[M28Map.subrefLZMinSegZ])
        tMaxPosition = M28Map.GetPositionFromPathingSegments(tLZOrWZData[M28Map.subrefLZMaxSegX], tLZOrWZData[M28Map.subrefLZMaxSegX])
    end
    local iMinX = tMinPosition[1]
    local iMaxX = tMaxPosition[1]
    local iMinZ = tMinPosition[3]
    local iMaxZ = tMaxPosition[3]
    --Really could simplify the below into just one formula, but separating it out makes it slightl yeasier to conceptualise
    if iMaxDistToEdgeOfAdjacentZone > 0 then
        --Want to be outside the box
        if tStartPoint[1] >= iMinX - iMaxDistToEdgeOfAdjacentZone and tStartPoint[1] <= iMaxX + iMaxDistToEdgeOfAdjacentZone then
            if tStartPoint[3] >= iMinZ - iMaxDistToEdgeOfAdjacentZone and tStartPoint[3] <= iMaxZ + iMaxDistToEdgeOfAdjacentZone then
                return true
            end
        end
    else
        --Wnat to be inside the zone box
        if tStartPoint[1] >= iMinX + iMaxDistToEdgeOfAdjacentZone and tStartPoint[1] <= iMaxX - iMaxDistToEdgeOfAdjacentZone then
            if tStartPoint[3] >= iMinZ + iMaxDistToEdgeOfAdjacentZone and tStartPoint[3] <= iMaxZ - iMaxDistToEdgeOfAdjacentZone then
                return true
            end
        end
    end
    return false
end

function WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, bConsideringSubmarinesNotSurface, iOptionalThreatAbsolutePercentIncrease)
    --iOptionalThreatAbsolutePercentIncrease - will increase enemy threat factors by this (absolute increase), e.g. set to 0.1 and instead of wanting 1.3 * enemy threat to attack, will want 1.4 * enemy threat
    local sFunctionRef = 'WantToAttackWithNavyEvenIfOutranged'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bAreInScenario2 = false
    local iModMod = (iOptionalThreatAbsolutePercentIncrease or 0)
    local iEnemyAntiNavyMod = 1.5 + iModMod
    local iEnemyCombatModHigh = 1.3 + iModMod
    local iEnemyCombatModLow = 1.1 + iModMod

    if (bConsideringSubmarinesNotSurface and (iAdjacentAlliedSubmersibleThreat >= 40000 or (iAdjacentAlliedSubmersibleThreat > iAdjacentEnemyAntiNavyThreat * iEnemyAntiNavyMod or (iAdjacentAlliedSubmersibleThreat > iAdjacentEnemyAntiNavyThreat and iAdjacentAlliedCombatThreat > iAdjacentEnemyCombatThreat * iEnemyCombatModHigh)))) or
            --Surface level consideration - want tobe similar to sub so we dont end up attacking with subs and not surface if reason for attacking with subs is our surface threat
            (not(bConsideringSubmarinesNotSurface) and ((iAdjacentAlliedCombatThreat - iAdjacentAlliedSubmersibleThreat) > iAdjacentEnemyCombatThreat * iEnemyCombatModHigh or (tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] - iAdjacentAlliedSubmersibleThreat) > iAdjacentEnemyCombatThreat * iEnemyCombatModLow))  then bAreInScenario2 = true
    elseif tWZTeamData[M28Map.subrefWZbCoreBase] then
        --Consider attacking if naval fac is vulnerable, or we have slightly more threat
        if  iAdjacentAlliedCombatThreat > iAdjacentEnemyCombatThreat then
            if bDebugMessages == true then LOG(sFunctionRef..': We have significantly more threat than enemy so want to attack') end
            bAreInScenario2 = true
        else
            --Are in core zone, and have enemies either in this zone ro an adjacent one; if enemies are in this zone still attack; if they are in adjacent zone then only attack if nearest enemy is almost in range of our naval fac
            if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Enemy has units in oure core water zone so want to attack') end
                bAreInScenario2 = true
            elseif M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]) == false then
                --No enemies in this water zone, so must only be in adjacent zone, check if are close to being in range of our naval factory

                local tFriendlyNavalFac = EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subrefWZTAlliedUnits])
                if M28Utilities.IsTableEmpty(tFriendlyNavalFac) then
                    --Greater search range as dont know how close to midpoint the naval fac build location would be
                    if CloseToEnemyUnit(tWZData[M28Map.subrefMidpoint], tWZTeamData[M28Map.reftoNearestCombatEnemies], 30, iTeam, true) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy has units almost in range of our core zone midpoint so will attack') end
                        bAreInScenario2 = true
                    end
                else
                    --Cycle through each naval fac and see if enemy is close
                    for iNavalFac, oNavalFac in tFriendlyNavalFac do
                        if CloseToEnemyUnit(oNavalFac:GetPosition(), tWZTeamData[M28Map.reftoNearestCombatEnemies], 15, iTeam, true) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy has units almost in range of our naval fac so will attack') end
                            bAreInScenario2 = true
                            break
                        end
                    end
                end
            end
        end

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bAreInScenario2
end


function GetNumberOfUnitsCurrentlyBeingBuiltOfCategoryInZone(tLZTeamData, iCategory)
    local iCount = 0
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
        local tFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory,tLZTeamData[M28Map.subrefLZTAlliedUnits])
        if M28Utilities.IsTableEmpty(tFactories) == false then
            local sBeingBuilt
            for iFactory, oFactory in tFactories do
                sBeingBuilt = oFactory[M28Orders.reftiLastOrders][1][M28Orders.subrefsOrderBlueprint]
                if sBeingBuilt and EntityCategoryContains(iCategory, sBeingBuilt) then
                    iCount = iCount + 1
                end
            end
        end
    end
    return iCount

end