---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 22:33
---
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')

local reftBlueprintPriorityOverride = 'M28FactoryPreferredBlueprintByCategory' --[x] is the blueprint ref, if there's a priority override it returns a numerical value (higher number = higher priority)
local refiTimeSinceLastOrderCheck = 'M28FactoryTimeSinceLastCheck' --against factory, gametime in seconds when the factory was last identified as idle with no order
--NOTE: Also have a blueprint blacklist in the landsubteam data - see M28Team

--Factory types (used by subteams)
refiFactoryTypeLand = 1
refiFactoryTypeAir = 2
refiFactoryTypeNaval = 3
refiFactoryTypeOther = 4

--Build count by BP
refiBuildCountByBlueprint = 'M28FacBC' --against oFactory, returns table with key as the unitID, which returns the number of times the factory has been sent an order to build the unit

function GetMostExpensiveBlueprintOfCategory(iCategoryCondition)
    --Much more simplified version of 'GetBlueprintThatCanBuildOfCategory', for cases where we dont yet have the engineer so want a potential blueprint to work with
    local tBlueprints = EntityCategoryGetUnitList(iCategoryCondition)
    local iHighestMassCost = 0
    local tAllBlueprints = __blueprints
    local sMostExpensiveBlueprint
    local iCurMassCost
    for _, sBlueprint in tBlueprints do
        iCurMassCost = (tAllBlueprints[sBlueprint].Economy.BuildCostMass or 0)
        if iCurMassCost > iHighestMassCost then
            iHighestMassCost = iCurMassCost
            sMostExpensiveBlueprint = sBlueprint
        end
    end
    return sMostExpensiveBlueprint
end

function GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition, oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
    --returns nil if cant find any blueprints that can build
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBlueprintThatCanBuildOfCategory'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tBlueprints = EntityCategoryGetUnitList(iCategoryCondition)
    local tAllBlueprints = __blueprints
    local tValidBlueprints = {}
    local iValidBlueprints = 0
    local tBestBlueprints = {}
    local iBestBlueprints = 0
    local iHighestTech = 1
    local iCurrentTech = 1
    --if bGetSlowest == nil then bGetSlowest = false end
    --if bGetFastest == nil then bGetFastest = false end
    local iCurSpeed, iCurMass
    local tiLowestSpeedByTech = {1000, 1000, 1000}
    local tiLowestMassByTech = {100000000, 100000000, 100000000}
    local tiHighestSpeedByTech = {0,0,0}
    local oCurBlueprint
    local iHighestPriority = 0
    local bCanBuildRequiredCategory
    local iCategoriesThatBlueprintCanBuild
    local tsBlueprintsMeetingDesiredCategoriesToBuild
    if iOptionalCategoryThatMustBeAbleToBuild then
        tsBlueprintsMeetingDesiredCategoriesToBuild = EntityCategoryGetUnitList(iOptionalCategoryThatMustBeAbleToBuild)
        if bDebugMessages == true then LOG(sFunctionRef..': tsBlueprintsMeetingDesiredCategoriesToBuild='..repru(tsBlueprintsMeetingDesiredCategoriesToBuild)) end
    end





    if bDebugMessages == true then LOG(sFunctionRef..': reftBlueprintPriorityOverride='..repru(aiBrain[reftBlueprintPriorityOverride])) end
    if not(oFactory.CanBuild) then
        if oFactory.UnitId then
            M28Utilities.ErrorHandler('Factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..' doesnt have .canbuild')
        else
            M28Utilities.ErrorHandler('Factory has no UnitId and doesnt have .CanBuild')
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return nil
    else
        for _, sBlueprint in tBlueprints do
            if bDebugMessages == true then LOG(sFunctionRef..': About to see if factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; can build blueprint '..sBlueprint..'; CanBuild='..tostring(oFactory:CanBuild(sBlueprint))) end
            if oFactory:CanBuild(sBlueprint) == true then
                --Check we can build the desired category
                if not(iOptionalCategoryThatMustBeAbleToBuild) then bCanBuildRequiredCategory = true
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Have said we need to build a particualr category, will see if sBLueprint='..sBlueprint..' can build this') end
                    bCanBuildRequiredCategory = false
                    iCategoriesThatBlueprintCanBuild = nil
                    if tAllBlueprints[sBlueprint].Economy.BuildableCategory and not(M28Utilities.IsTableEmpty(tsBlueprintsMeetingDesiredCategoriesToBuild)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': sBlueprint has a buildablecategory set, will convert it into a category and see if it matches any of the blueprints we want to be able to build') end
                        for categoryIndex, category in tAllBlueprints[sBlueprint].Economy.BuildableCategory do
                            if categoryIndex == 1 then
                                iCategoriesThatBlueprintCanBuild = ParseEntityCategory(category)
                            else
                                iCategoriesThatBlueprintCanBuild = iCategoriesThatBlueprintCanBuild + ParseEntityCategory(category)
                            end
                        end

                        for iAltBlueprint, sAltBlueprint in tsBlueprintsMeetingDesiredCategoriesToBuild do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if sAltBlueprint='..(sAltBlueprint or 'nil')..' has a category that matches with what sBLueprint can build') end
                            if EntityCategoryContains(iCategoriesThatBlueprintCanBuild, sAltBlueprint) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Can build the desired category') end
                                bCanBuildRequiredCategory = true
                                break
                            end
                        end
                    end
                end

                if bCanBuildRequiredCategory then
                    --if EntityCategoryContains(iCategoryCondition, sBlueprint) then --tBlueprints is already filtered to just those that meet the categories
                    iValidBlueprints = iValidBlueprints + 1
                    tValidBlueprints[iValidBlueprints] = sBlueprint
                    if bIgnoreTechDifferences then iCurrentTech = 1
                    else
                        if EntityCategoryContains(categories.TECH3 + categories.EXPERIMENTAL, sBlueprint) then iCurrentTech = 3
                        elseif EntityCategoryContains(categories.TECH2, sBlueprint) then iCurrentTech = 2
                        else iCurrentTech = 1
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': '..sBlueprint..': iCurrentTech='..iCurrentTech..'; iHighestTech='..iHighestTech) end
                    if iCurrentTech > iHighestTech then
                        iHighestTech = iCurrentTech
                        iHighestPriority = 0
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if sBlueprint has a priority specified if we arent looking for slowest or fastest. sBlueprint='..sBlueprint..'; bGetSlowest='..tostring(bGetSlowest)..'; bGetFastest='..tostring(bGetFastest)..'; bGetCheapest='..tostring((bGetCheapest or false))) end
                    if not(bGetSlowest) and not(bGetFastest) and not(bGetCheapest) and aiBrain[reftBlueprintPriorityOverride][sBlueprint] then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have a priority specified='..aiBrain[reftBlueprintPriorityOverride][sBlueprint]..'; iHighestPriority='..iHighestPriority) end
                        iHighestPriority = math.max(aiBrain[reftBlueprintPriorityOverride][sBlueprint], iHighestPriority)
                    end
                    if bGetSlowest == true or bGetFastest == true then
                        oCurBlueprint = tAllBlueprints[sBlueprint]
                        iCurSpeed = oCurBlueprint.Physics.MaxSpeed
                        if bDebugMessages == true then LOG(sFunctionRef..': '..sBlueprint..': iCurSpeed='..iCurSpeed) end
                        if bGetSlowest == true then
                            if iCurSpeed < tiLowestSpeedByTech[iCurrentTech] then tiLowestSpeedByTech[iCurrentTech] = iCurSpeed end
                        elseif bGetFastest == true then
                            if iCurSpeed > tiHighestSpeedByTech[iCurrentTech] then tiHighestSpeedByTech[iCurrentTech] = iCurSpeed end
                        end
                    elseif bGetCheapest then
                        oCurBlueprint = tAllBlueprints[sBlueprint]
                        iCurMass = oCurBlueprint.Economy.BuildCostMass
                        if iCurMass < tiLowestMassByTech[iCurrentTech] then tiLowestMassByTech[iCurrentTech] = iCurMass end
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to get cheapest; iCurMass='..iCurMass..'; iCurrentTech='..iCurrentTech..'; tiLowestMassByTech[iCurrentTech]='..tiLowestMassByTech[iCurrentTech]) end
                    end
                    --end
                end
            end
        end
        --Now get a list of blueprints that are this tech level and of the highest priority
        --if bDebugMessages == true then LOG(sFunctionRef..': iHighestTech='..iHighestTech..'; tiHighestSpeedByTech='..tiHighestSpeedByTech[iHighestTech]..'; bGetSlowest='..tostring(bGetSlowest)..'; bGetFastest='..tostring(bGetFastest)) end
        local bIsValid, iCurrentPriority
        local iMinTechToUse = iHighestTech
        local iFastestSpeed = tiHighestSpeedByTech[iHighestTech]
        if bGetFastest == true and iHighestTech >= 3 then
            --If cybran, want loyalist instead of bomb; if Aeon want blaze instead of harbinger or shield disrupter; If sera probably want hover tank instead of siege tank; if UEF want titan
            if tiHighestSpeedByTech[3] <= 3.5 and tiHighestSpeedByTech[2] - tiHighestSpeedByTech[3] >= 0.6 then
                iMinTechToUse = 2
                iFastestSpeed = math.max(tiHighestSpeedByTech[3], tiHighestSpeedByTech[2])
            end
        end

        for _, sBlueprint in tValidBlueprints do
            bIsValid = false
            if EntityCategoryContains(categories.TECH3 + categories.EXPERIMENTAL, sBlueprint) then iCurrentTech = 3
            elseif EntityCategoryContains(categories.TECH2, sBlueprint) then iCurrentTech = 2
            else iCurrentTech = 1
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Cycling through each blueprint in valid blueprints, sBlueprint='..sBlueprint..': Considering whether we have high enough tech to consider, iCurrentTech='..iCurrentTech..'; iMinTechToUse='..iMinTechToUse) end
            if iCurrentTech >= iMinTechToUse then
                if not(bGetFastest) and not(bGetSlowest) and not(bGetCheapest) then iCurrentPriority = aiBrain[reftBlueprintPriorityOverride][sBlueprint] end
                if iCurrentPriority == nil then iCurrentPriority = 0 end
                if bDebugMessages == true then LOG(sFunctionRef..': sBlueprint='..sBlueprint..'; iCurrentTech='..iCurrentTech..'; considering priority, iCurrentPriority='..iCurrentPriority..'; iHighestPriority='..iHighestPriority) end
                if iCurrentPriority >= iHighestPriority then
                    bIsValid = true

                    if not(bGetSlowest) and not(bGetFastest) and not(bGetCheapest) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Not interested in if slowest or fastest or cheapest so marking BP as valid') end
                        bIsValid = true
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to get either the slowest, fastest or cheapest') end
                        bIsValid = false
                        if bGetSlowest or bGetFastest then
                            oCurBlueprint = tAllBlueprints[sBlueprint]
                            iCurSpeed = oCurBlueprint.Physics.MaxSpeed
                            if bDebugMessages == true then LOG(sFunctionRef..': sBlueprint='..sBlueprint..'; iCurSpeed='..iCurSpeed) end
                            if bGetSlowest == true then
                                if iCurSpeed <= tiLowestSpeedByTech[iHighestTech] then bIsValid = true end
                            elseif iCurSpeed >= iFastestSpeed then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have the highest speed for tech levels being considered') end
                                bIsValid = true
                            end
                        elseif bGetCheapest then
                            oCurBlueprint = tAllBlueprints[sBlueprint]
                            iCurMass = oCurBlueprint.Economy.BuildCostMass
                            if iCurMass <= tiLowestMassByTech[iCurrentTech] then bIsValid = true end
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to get cheapest; iCurMass='..iCurMass..'; iCurrentTech='..iCurrentTech..'; tiLowestMassByTech[iCurrentTech]='..tiLowestMassByTech[iCurrentTech]..'; bIsValid='..tostring(bIsValid)) end
                        else M28Utilities.ErrorHandler('Missing code')
                        end
                    end
                end
                if bIsValid == true then
                    iBestBlueprints = iBestBlueprints + 1
                    tBestBlueprints[iBestBlueprints] = sBlueprint
                    if bDebugMessages == true then LOG(sFunctionRef..': Have valid blueprint='..sBlueprint) end
                end
            end
        end

        local iBPToBuild = math.random(1, iBestBlueprints)
        if bDebugMessages == true then
            LOG(sFunctionRef..': End of code, iBestBlueprints='..iBestBlueprints..'; Will return random number if this is more than 1, tBestBlueprints[iBPToBuild]='..(tBestBlueprints[iBPToBuild] or 'nil'))
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return tBestBlueprints[iBPToBuild]
    end


end

function AdjustBlueprintForOverrides(aiBrain, sBPIDToBuild, tLZTeamData, iFactoryTechLevel)
    --Blacklisted units (done on land subteam basis - in theory should work ok if use naval units or air units here as well)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AdjustBlueprintForOverrides'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subrefBlueprintBlacklist][sBPIDToBuild] then
        sBPIDToBuild = nil
    else
        --Special case - Cybran and UEF - if building loyalists or titans, then check if want to switch to bricks/percies
        if sBPIDToBuild == 'url0303' then --Loyalist
            if M28Team.tTeamData[aiBrain.M28Team][M28Team.refbEnemyHasPerciesOrBricks] or M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat * categories.TECH3) >= 2 then
                aiBrain[reftBlueprintPriorityOverride]['url0303'] = nil --loyalist
                aiBrain[reftBlueprintPriorityOverride]['xrl0305'] = 1 --brick
                sBPIDToBuild = 'xrl0305'
            end
        elseif sBPIDToBuild == 'uel0303' then --Titan
            if M28Team.tTeamData[aiBrain.M28Team][M28Team.refbEnemyHasPerciesOrBricks] or M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat * categories.TECH3) >= 15 then
                aiBrain[reftBlueprintPriorityOverride]['url0303'] = nil --Titan
                aiBrain[reftBlueprintPriorityOverride]['xel0305'] = 1 --Percival
                sBPIDToBuild = 'xel0305'
            end
        end

        if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, sBPIDToBuild) then
            --Engineers - dont build if we have spare engineers at our current LZ
            local iMaxSpareWanted = 1
            if not(M28Conditions.TeamHasLowMass(aiBrain.M28Team)) then
                iMaxSpareWanted = math.max(2, 1 + math.floor(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamLowestMassPercentStored] * 10)) * M28Engineer.tiBPByTech[iFactoryTechLevel]
            end
            if tLZTeamData[M28Map.subrefSpareBPByTech][iFactoryTechLevel] > iMaxSpareWanted then
                sBPIDToBuild = nil
            end
            --Smaller maps - try and build engis in proportion to tanks at t1 stage
            if iFactoryTechLevel < 2 and sBPIDToBuild and M28Map.iMapSize <= 256 and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] then
                local iCurEngineers = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer)
                local iCurCombat = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandCombat)
                if iCurEngineers > math.max(10, iCurCombat) and aiBrain:GetEconomyStoredRatio('MASS') < 0.6 then
                    sBPIDToBuild = nil
                end
            end
            --Cap total gunships to be active at any one time
        elseif EntityCategoryContains(M28UnitInfo.refCategoryGunship - categories.TECH3 - categories.EXPERIMENTAL, sBPIDToBuild) then
            if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryGunship) >= 80 then sBPIDToBuild = nil end
        end
    end
    if sBPIDToBuild and aiBrain[M28Overseer.refbCloseToUnitCap] then
        if aiBrain[M28Overseer.refiExpectedRemainingCap] <= 20 or EntityCategoryContains(categories.TECH1 + M28UnitInfo.refCategoryMobileLand * categories.TECH2, sBPIDToBuild) or (aiBrain[M28Overseer.refiUnitCapCategoriesDestroyed] and EntityCategoryContains(aiBrain[M28Overseer.refiUnitCapCategoriesDestroyed], sBPIDToBuild)) then
            --Exception - build T2 engineers if we dont have many T3 engineers and have at least 10 leeway and havent been destroying these units
            if aiBrain[M28Overseer.refiExpectedRemainingCap] >= 20 and EntityCategoryContains(M28UnitInfo.refCategoryEngineer * categories.TECH2, sBPIDToBuild) and aiBrain[M28Overseer.refiExpectedRemainingCap] >= 25 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * categories.TECH3) <= 2 and (not(aiBrain[M28Overseer.refiUnitCapCategoriesDestroyed]) or not(EntityCategoryContains(aiBrain[M28Overseer.refiUnitCapCategoriesDestroyed], sBPIDToBuild))) then
                --Are trying to build a T2 engi and havent been destroying any yet, so still build it
                --i.e. do nothing
            elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer * categories.TECH3, sBPIDToBuild) and aiBrain[M28Overseer.refiExpectedRemainingCap] >= 5 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * categories.TECH3) <= 3 then
                --Do nothing - want some t3 engineers so can build t3 and experimental units
            else
                sBPIDToBuild = nil
            end
        end
        if sBPIDToBuild and M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] <= 1 and (aiBrain[M28Overseer.refiExpectedRemainingCap] < 40 or (aiBrain[M28Overseer.refiExpectedRemainingCap] < 70 and M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] == 0)) then
            --Dont build anything if already have lots of it
            if bDebugMessages == true then LOG(sFunctionRef..': Are close to unit cap, sBPIDToBuild after initial close to unit override='..(sBPIDToBuild or 'nil')..'; Current units owned of this already='..aiBrain:GetCurrentUnits(sBPIDToBuild)) end
            if aiBrain:GetCurrentUnits(categories[sBPIDToBuild]) >= 50 then
                sBPIDToBuild = nil
            end
        end
    end

    --NoRush
    if sBPIDToBuild and M28Overseer.bNoRushActive then
        if M28Overseer.iNoRushTimer - GetGameTimeSeconds() > 30 then
            if not(EntityCategoryContains(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryExperimentalLevel, sBPIDToBuild)) then
                sBPIDToBuild = nil
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return sBPIDToBuild
end

function GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iTargetLandZone, bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths, bDontGetCombat)
    local sFunctionRef = 'GetLandZoneSupportCategoryWanted'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iBaseCategoryWanted
    local bInSameIsland = false
    if NavUtils.GetLabel(M28Map.refPathingTypeLand, oFactory:GetPosition()) == NavUtils.GetLabel(M28Map.refPathingTypeLand, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefMidpoint]) then
        bInSameIsland = true
    end
    local tLZTargetTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][iTeam]
    if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateau '..iPlateau..'; iTargetLandZone='..iTargetLandZone..'; bInSameIsland='..tostring(bInSameIsland)..'; bDontConsiderBuildingMAA='..tostring(bDontConsiderBuildingMAA)..'; tLZTargetTeamData[M28Map.subrefbLZWantsIndirectSupport]='..tostring(tLZTargetTeamData[M28Map.subrefbLZWantsIndirectSupport])..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA]='..tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA]..'; subrefLZThreatAllyMAA='..tLZTargetTeamData[M28Map.subrefLZThreatAllyMAA]..'; tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]='..tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]..'; tLZTargetTeamData[M28Map.subrefbLZWantsSupport]='..tostring(tLZTargetTeamData[M28Map.subrefbLZWantsSupport])..'; LZ Air to ground enemy threat='..tLZTargetTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tLZTargetTeamData[M28Map.refbLZWantsMobileShield]='..tostring(tLZTargetTeamData[M28Map.refbLZWantsMobileShield])..'; tLZTargetTeamData[M28Map.refbLZWantsMobileStealth]='..tostring(tLZTargetTeamData[M28Map.refbLZWantsMobileStealth])..'; tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]='..tostring(tLZTargetTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ])..'; bDontConsiderBuildingMAA='..tostring(bDontConsiderBuildingMAA or false)) end


    if (not(bDontGetCombat) and tLZTargetTeamData[M28Map.subrefbLZWantsIndirectSupport] and tLZTargetTeamData[M28Map.subrefbLZWantsSupport]) or GetGameTimeSeconds() - (tLZTargetTeamData[M28Map.subrefiTimeOfMMLFiringNearTMD] or -100) <= 10 then
        --First consider if we need MAA more urgently than indirect
        local bWantMAANotIndirect = false
        if not(bDontConsiderBuildingMAA) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 150 and tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA] < tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted] then
            --We want more MAA for this LZ as well as wanting more indirect fire; prioritise MAA based on threat ratio and if enemy has air to ground force
            local iMAARatioWanted = 8
            if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 25000 then iMAARatioWanted = 4 end
            if tLZTargetTeamData[M28Map.refiEnemyAirToGroundThreat] >= 200 then iMAARatioWanted = iMAARatioWanted * 0.5 end
            if tLZTargetTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] < tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA] * iMAARatioWanted then
                bWantMAANotIndirect = true
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': tLZTargetTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTargetTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]..'; bWantMAANotIndirect='..tostring(bWantMAANotIndirect)) end
        if bWantMAANotIndirect then
            if M28UnitInfo.GetUnitTechLevel(oFactory) == 3 and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA) >= 50 or (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] >= 2000 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.TECH3 * M28UnitInfo.refCategoryBomber, M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround])) == false) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 0 and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA - categories.TECH3) >  oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) * 4 then iBaseCategoryWanted = M28UnitInfo.refCategoryMAA
            else
                iBaseCategoryWanted = M28UnitInfo.refCategoryMAA - categories.TECH3
            end
            if not(bInSameIsland) then iBaseCategoryWanted = iBaseCategoryWanted * categories.AMPHIBIOUS + iBaseCategoryWanted * categories.HOVER end
            if bDebugMessages == true then LOG(sFunctionRef..': Will get MAA1') end
        else
            if bInSameIsland then
                iBaseCategoryWanted = M28UnitInfo.refCategoryIndirect
                if bDebugMessages == true then LOG(sFunctionRef..': Considering oFactory='..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; iTeam='..iTeam..'; iPlateau='..iPlateau..'; iTargetLandZone='..iTargetLandZone..'; We want indirect support for this LZ; Enemy structure threat by DF range='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatEnemyStructureDFByRange])..'; Total indirect threat wanted for LZ='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZIndirectThreatWanted]) end
            else
                --Only consider amphibious indirect (so most factions wont build anything)
                iBaseCategoryWanted = M28UnitInfo.refCategoryIndirect * categories.AMPHIBIOUS + M28UnitInfo.refCategoryIndirect * categories.HOVER
            end
            --If enemy has a firebase in range then cancel request for indirect
            if not(tLZTargetTeamData[M28Map.subrefLZbCoreBase]) and M28Utilities.IsTableEmpty(tLZTargetTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
                iBaseCategoryWanted = nil
                if bDebugMessages == true then LOG(sFunctionRef..': Are in range of a firebase so wont get indirect afterall') end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Will get Indirect') end
            end
        end
    end
    if not(iBaseCategoryWanted) then
        --We dont want indirect fire units, do we want MAA units?
        if bDebugMessages == true then LOG(sFunctionRef..': Dont want indirect fire, do we want MAA? M28Map.subrefLZThreatAllyGroundAA='..tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA]..'; M28Map.subrefLZMAAThreatWanted='..tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]..'; tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA]='..reprs(tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA])..'; tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]='..tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]) end
        if not(bDontConsiderBuildingMAA) and tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA] < tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted] and (M28UnitInfo.GetUnitTechLevel(oFactory) >= 2 or (M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoAllEnemyAir]) == false and (not(bDontConsiderBuildingMAA) or tLZTargetTeamData[M28Map.refiEnemyAirToGroundThreat] > 0))) then
            if M28UnitInfo.GetUnitTechLevel(oFactory) == 3 and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA) >= 50 or (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] >= 2000 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.TECH3 * M28UnitInfo.refCategoryBomber, M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround])) == false) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 0 and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA - categories.TECH3) >  oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) * 4 then iBaseCategoryWanted = M28UnitInfo.refCategoryMAA
            else
                iBaseCategoryWanted = M28UnitInfo.refCategoryMAA - categories.TECH3
            end
            if not(bInSameIsland) then iBaseCategoryWanted = iBaseCategoryWanted * categories.AMPHIBIOUS + iBaseCategoryWanted * categories.HOVER end
            if bDebugMessages == true then LOG(sFunctionRef..': Will build MAA2') end
        end
        if not(iBaseCategoryWanted) then
            --Mobile shields
            if bConsiderMobileShields and tLZTargetTeamData[M28Map.refbLZWantsMobileShield] then
                iBaseCategoryWanted = M28UnitInfo.refCategoryMobileLandShield
                if bInSameIsland then iBaseCategoryWanted = M28UnitInfo.refCategoryMobileLandShield
                else iBaseCategoryWanted = iBaseCategoryWanted * categories.AMPHIBIOUS + iBaseCategoryWanted * categories.HOVER
                end
                if bDebugMessages == true then LOG(sFunctionRef..': LZ wants mobile stealths so will build them; blueprint expect to build from this='..(GetBlueprintThatCanBuildOfCategory(oFactory:GetAIBrain(), iBaseCategoryWanted, oFactory) or 'nil')) end
                --If dont have any blueprints to build then look to support indirect or DF instead
                local sBPIDToBuild = GetBlueprintThatCanBuildOfCategory(oFactory:GetAIBrain(), iBaseCategoryWanted, oFactory)
                if sBPIDToBuild then
                    sBPIDToBuild = AdjustBlueprintForOverrides(oFactory:GetAIBrain(), sBPIDToBuild, tLZTargetTeamData, M28UnitInfo.GetUnitTechLevel(oFactory))
                end
                if not(sBPIDToBuild) then iBaseCategoryWanted = nil end
            end
            if not(iBaseCategoryWanted) then
                --Mobile stealth (unless enemy so close that combat units would be better)
                if bConsiderMobileStealths and tLZTargetTeamData[M28Map.refbLZWantsMobileStealth] and not(tLZTargetTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                    iBaseCategoryWanted = M28UnitInfo.refCategoryMobileLandStealth
                    if bInSameIsland then iBaseCategoryWanted = M28UnitInfo.refCategoryMobileLandStealth
                    else iBaseCategoryWanted = iBaseCategoryWanted * categories.AMPHIBIOUS + iBaseCategoryWanted * categories.HOVER
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': LZ wants mobile shilelds so will build them; blueprint expect to build from this='..(GetBlueprintThatCanBuildOfCategory(oFactory:GetAIBrain(), iBaseCategoryWanted, oFactory) or 'nil')) end
                    --If dont have any blueprints to build then look to support indirect or DF instead
                    local sBPIDToBuild = GetBlueprintThatCanBuildOfCategory(oFactory:GetAIBrain(), iBaseCategoryWanted, oFactory)
                    if sBPIDToBuild then
                        sBPIDToBuild = AdjustBlueprintForOverrides(oFactory:GetAIBrain(), sBPIDToBuild, tLZTargetTeamData, M28UnitInfo.GetUnitTechLevel(oFactory))
                    end
                    if not(sBPIDToBuild) then iBaseCategoryWanted = nil end
                end
            end
        end
        if not(iBaseCategoryWanted) then
            if not(bDontGetCombat) and tLZTargetTeamData[M28Map.subrefbLZWantsSupport] then
                --We want DF units (but not indirect fire units)
                if bInSameIsland then
                    local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
                    local iTechCategory = M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)

                    iBaseCategoryWanted = M28UnitInfo.refCategorySkirmisher * iTechCategory
                    if not(tLZTargetTeamData[M28Map.subrefLZbCoreBase]) and M28Utilities.IsTableEmpty(tLZTargetTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
                        iBaseCategoryWanted = M28UnitInfo.refCategoryDFTank
                        if bDebugMessages == true then LOG(sFunctionRef..': Are in range of a firebase so wont get indirect afterall') end
                    elseif tLZTargetTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategorySkirmisher * iTechCategory) > math.min(2, oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryDFTank * iTechCategory)) then
                        iBaseCategoryWanted = M28UnitInfo.refCategoryDFTank
                        if bDebugMessages == true then LOG(sFunctionRef..': Enemies aren earby so want DF tanks more than skirmishers once we have a couple of skirmishers') end
                    end
                    if not(GetBlueprintThatCanBuildOfCategory(oFactory:GetAIBrain(), iBaseCategoryWanted, oFactory)) then
                        iBaseCategoryWanted = M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategorySkirmisher
                    else
                        --We can build skirmishers, but if we have built fewer than 15 T3 tanks, and enemy is using T2 and lower tech, consider building t3 tanks instead
                        if iFactoryTechLevel >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] <= 2 and M28Conditions.GetLifetimeBuildCount(oFactory:GetAIBrain(), M28UnitInfo.refCategoryDFTank * iTechCategory) <= 15 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy is still at T2 or lower and we havent built many T3 normal tanks so will build normal tanks first before trying to build skrimishers') end
                            iBaseCategoryWanted = M28UnitInfo.refCategoryDFTank
                        end
                    end

                else
                    iBaseCategoryWanted = M28UnitInfo.refCategoryAmphibiousCombat - categories.FIELDENGINEER
                end
            elseif bDebugMessages == true then LOG(sFunctionRef..': Dont want any support category for this LZ')
            end
            if not(iBaseCategoryWanted) and tLZTargetTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] then
                iBaseCategoryWanted = M28UnitInfo.refCategoryAmphibiousCombat - categories.FIELDENGINEER
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': is iBaseCategoryWanted nil='..tostring(iBaseCategoryWanted == nil)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBaseCategoryWanted
end

function GetBlueprintToBuildForLandFactory(aiBrain, oFactory)
    local sFunctionRef = 'GetBlueprintToBuildForLandFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCategoryToBuild
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oFactory:GetPosition(), true, oFactory)
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
    local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
    local iTeam = aiBrain.M28Team
    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
    local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)
    local bCanPathToEnemyWithLand = false
    if tLZData[M28Map.subrefLZIslandRef] == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) then
        bCanPathToEnemyWithLand = true
    end



    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Near start of code, time=' .. GetGameTimeSeconds() .. '; oFactory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; Checking if we have the highest tech land factory in the current land zone, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Highest friendly factory tech=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] .. '; Allied ground MAA threat=' .. (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] or 'nil') .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]=' .. (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] or 'nil') .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat]=' .. (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] or 'nil') .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat]=' .. (M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] or 'nil') .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat]=' .. (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat] or 'nil') .. '; Is factory paused=' .. tostring(oFactory:IsPaused()) .. '; IsPaused value=' .. tostring(oFactory[M28UnitInfo.refbPaused]) .. '; Does LZ factory is in need BP=' .. tostring(tLZTeamData[M28Map.subrefTbWantBP]) .. '; Core LZ=' .. tostring(tLZTeamData[M28Map.subrefLZbCoreBase] or false) .. '; Core expansion=' .. tostring(tLZTeamData[M28Map.subrefLZCoreExpansion] or false))
    end

    local iLandFactoriesInLZ = 0
    local bHaveHighestLZTech = true
    --if iFactoryTechLevel < 3 and iFactoryTechLevel < M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] then
    local tLandFactoriesInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
    for iLZFactory, oLZFactory in tLandFactoriesInLZ do
        if not (oLZFactory == oFactory) and M28UnitInfo.GetUnitTechLevel(oLZFactory) > iFactoryTechLevel then
            bHaveHighestLZTech = false
            break
        end
    end
    iLandFactoriesInLZ = table.getn(tLandFactoriesInLZ)
    --end

    local bDontConsiderBuildingMAA = false
    --Do we already ahve lots of MAA?
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering if we want to ignore getting any MAA, tLZTeamData[M28Map.refiEnemyAirToGroundThreat]=' .. tLZTeamData[M28Map.refiEnemyAirToGroundThreat] .. '; Time since last had no MAA targets for this island=' .. GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoMAATargetsByIsland][tLZData[M28Map.subrefLZIslandRef]] or -10) .. '; tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]=' .. tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]))
    end
    if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] == 0 then
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] <= 1 and (iFactoryTechLevel == 1 or bHaveLowMass)) then
            bDontConsiderBuildingMAA = true
        elseif GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoMAATargetsByIsland][tLZData[M28Map.subrefLZIslandRef]] or -10) < 10 then
            if not (tLZTeamData[M28Map.subrefLZCoreExpansion]) then
                bDontConsiderBuildingMAA = true
            else
                local iMAAInLZ = 0
                local iEnemyAirToGround = 0
                for iEntry, iIslandLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][tLZData[M28Map.subrefLZIslandRef]] do
                    iMAAInLZ = iMAAInLZ + tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZThreatAllyMAA]
                    iEnemyAirToGround = iEnemyAirToGround + tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.refiEnemyAirToGroundThreat]
                end
                if iMAAInLZ >= 300 and iMAAInLZ >= iEnemyAirToGround * 2 then
                    bDontConsiderBuildingMAA = true
                end
            end
            if not (bDontConsiderBuildingMAA) and tLZTeamData[M28Map.subrefLZThreatAllyMAA] - tLZTeamData[M28Map.subrefLZMAAThreatWanted] >= 4000 then
                bDontConsiderBuildingMAA = true
            end
        end
        if not (bDontConsiderBuildingMAA) and ((M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] >= math.min(600 or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 2)) and (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] >= M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] + (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] + M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat]) * 0.2) or (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] > math.max(4000, M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] <= 4000 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) >= 5)) then
            --Do we have more than 1/6 of our DF and indirect force in AA and enemy air to ground threat is <4k? Or alternatively enemy has no air to ground and we have a lot of AA
            local iMAAFactor = 6
            if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] <= 1 then
                iMAAFactor = 12
            elseif M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 10000 then
                iMAAFactor = 4
            end
            if M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] < M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] * iMAAFactor then
                if not (tLZTeamData[M28Map.subrefLZCoreExpansion]) then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': We have lots of MAA; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] .. '; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] .. '; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] .. '; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]=' .. M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat])
                    end
                    bDontConsiderBuildingMAA = true
                else
                    local iMAAInLZ = 0
                    local iEnemyAirToGround = 0
                    for iEntry, iIslandLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][tLZData[M28Map.subrefLZIslandRef]] do
                        iMAAInLZ = iMAAInLZ + tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZThreatAllyMAA]
                        iEnemyAirToGround = iEnemyAirToGround + tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.refiEnemyAirToGroundThreat]
                    end
                    if iMAAInLZ >= 300 and iMAAInLZ >= iEnemyAirToGround * 2 then
                        bDontConsiderBuildingMAA = true
                    end
                end
            end
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': bDontConsiderBuildingMAA after considering global values=' .. tostring(bDontConsiderBuildingMAA) .. '; GroundAA threat=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] .. '; Enemy air to ground threat=' .. M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] .. '; Enemy AirAA threat=' .. M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] .. '; Enemy torp bomber threat=' .. M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] .. '; Air other threat=' .. M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat] .. '; Current T3 MAA=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) .. '; Allied DF threat=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] .. '; Allied indirect=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat])
    end
    if not (bDontConsiderBuildingMAA) then
        --If enemy has low air to ground threat relative to their combat threat then dont get more mAA if we already have half the factories building MAA
        if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] < math.max(200, M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] * 0.4) then
            local bCapMAABuiltAtOnce = true
            if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 0 then
                --Check we dont have air to ground enemy threat in a nearby LZ
                if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                    bCapMAABuiltAtOnce = false
                elseif M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.refiEnemyAirToGroundThreat] > 0 then
                            bCapMAABuiltAtOnce = false
                            break
                        end
                    end
                end
            end
            if bCapMAABuiltAtOnce then
                if M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryMAA) >= math.max(1, math.floor(iLandFactoriesInLZ * 0.5)) then
                    bDontConsiderBuildingMAA = true
                end
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': bCapMAABuiltAtOnce=' .. tostring(bCapMAABuiltAtOnce) .. '; Number of MAA already being built=' .. M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryMAA) .. '; bDontConsiderBuildingMAA=' .. tostring(bDontConsiderBuildingMAA))
            end
        end
    end

    --Mobile shields if we are at T2+ as part of the land zone reinforcement logic
    local bConsiderMobileShields = false
    if iFactoryTechLevel >= 2 and not (bHaveLowPower) and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoShieldTargetsByPlateau][iPlateau] or -100) >= 15 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 15 * iFactoryTechLevel and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 70 then
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 60 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= (1 + M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryMobileLandShield)) * 16 then
            local iCurMobileShields = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMobileLandShield)
            if iCurMobileShields <= 35 and iCurMobileShields * 250 <= math.max(2000, (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat])) then
                bConsiderMobileShields = true
            end
        end
    end

    --Mobile stealth if we are at T2+ as part of the land zone reinforcement logic
    local bConsiderMobileStealths = false
    if iFactoryTechLevel >= 2 and not (bHaveLowPower) and not (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbEnemyHasOmni]) and not (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbEnemyBuiltOmni]) and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoStealthTargetsByPlateau][iPlateau] or -100) >= 15 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 15 * iFactoryTechLevel and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 70 then
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 60 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= (1 + M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryMobileLandStealth)) * 16 then
            local iCurMobileStealths = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMobileLandStealth)
            if iCurMobileStealths <= 16 and iCurMobileStealths * 600 <= math.max(1800, (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat]) * 0.3) then
                bConsiderMobileStealths = true
            end
        end
    end

    local bSaveMassDueToEnemyFirebaseOrOurExperimental
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]) == false and bHaveLowMass then
        bSaveMassDueToEnemyFirebaseOrOurExperimental = true
    else
        bSaveMassDueToEnemyFirebaseOrOurExperimental = M28Conditions.WantToEcoDueToEnemyFirebase(iTeam, tLZTeamData, iPlateau)
    end

    iCategoryToBuild = M28UnitInfo.refCategoryEngineer --Placeholder
    local sBPIDToBuild
    local iCurrentConditionToTry = 0

    --subfunctions to mean we can do away with the 'current condition == 1, == 2.....==999 type approach making it much easier to add to
    function ConsiderBuildingCategory(iCategoryToBuild)
        sBPIDToBuild = GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oFactory, nil, nil, nil, nil, false)
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Time=' .. GetGameTimeSeconds() .. ' Factory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; LZ=' .. iLandZone .. '; iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; sBPIDToBuild before adjusting for override=' .. (sBPIDToBuild or 'nil'))
        end
        if sBPIDToBuild then
            sBPIDToBuild = AdjustBlueprintForOverrides(aiBrain, sBPIDToBuild, tLZTeamData, iFactoryTechLevel)
        end
        if sBPIDToBuild then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd) --Assumes we will end code if we get to this point
            return sBPIDToBuild
        end
    end

    function ConsiderUpgrading()
        sBPIDToBuild = M28UnitInfo.GetUnitUpgradeBlueprint(oFactory, true)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return sBPIDToBuild
    end



    --MAIN BUILDER LOGIC:
    --Enemy early bomber defence (higher priority than tanks since we have our ACU to deal with tanks as a last resort)
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; About to check if we want to build high priority MAA, bDontConsiderBuildingMAA=' .. tostring(bDontConsiderBuildingMAA) .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]=' .. M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat])
    end
    if not (bDontConsiderBuildingMAA) then
        local iNearbyMAAThreat = tLZTeamData[M28Map.subrefLZThreatAllyMAA]
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                iNearbyMAAThreat = iNearbyMAAThreat + tAdjLZTeamData[M28Map.subrefLZThreatAllyMAA]
            end
        end
        if iNearbyMAAThreat < 165 or (tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0) then
            --If enemy has any air units then want at least 110 MAA; if they have any air to ground want at least 165; if air to ground threat for this LZ then want
            if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 0 or (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat] + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] > 0 and iNearbyMAAThreat < 110) then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Want to have a basic level of MAA unless we have lots already; MAA that we alreayd have=' .. oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA))
                end
                if oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA) <= 5 or (tLZTeamData[M28Map.refiEnemyAirToGroundThreat] * 4 > math.min(1000, iNearbyMAAThreat)) then
                    --Only build if we ahve <2 under construction in this LZ
                    if M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryMAA) < 2 then
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Will try and get MAA to combat enemy air to ground threat')
                        end
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryMAA - categories.TECH3) then
                            return sBPIDToBuild
                        end
                    end
                end
            end
        end
    end

    --Core expansions - build 1 tank if havent already (t1 facs only)
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if tLZTeamData[M28Map.subrefLZCoreExpansion] and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedCombatUnits]) and iFactoryTechLevel == 1 then
        if M28Conditions.GetFactoryLifetimeCount(oFactory, M28UnitInfo.refCategoryLandCombat) == 0 then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Core expansion - have no land combat so will try to get some')
            end
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandCombat) then
                return sBPIDToBuild
            end
        elseif M28Conditions.GetFactoryLifetimeCount(oFactory, M28UnitInfo.refCategoryLandScout) == 0 then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Core expansion - have no land scout so will try to get some')
            end
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandScout) then
                return sBPIDToBuild
            end
        end
    end

    --Enemy nearby ACU and PD or T2 arti nearby, with no enemies in this actual LZ - get indirect fire as last resort
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if iFactoryTechLevel >= 2 and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] == 0 then
        local iApproachingACU, tNearestACU = M28Conditions.GetThreatOfApproachingEnemyACUsAndNearestACU(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Emergency indirect builder: iApproachingACU threat=' .. iApproachingACU .. '; Dist to it=' .. M28Utilities.GetDistanceBetweenPositions((tNearestACU or oFactory:GetPosition()), oFactory:GetPosition()) .. '; Cur indirect=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryIndirect) .. '; Lifetime indirect=' .. M28Conditions.GetFactoryLifetimeCount(oFactory, M28UnitInfo.refCategoryIndirect) .. '; Is table of nearby enemy dangerous buildings empty=' .. tostring(M28Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryT2PlusPD + M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryTMD, oFactory:GetPosition(), 175, 'Enemy'))))
        end
        if iApproachingACU <= 400 and tNearestACU and M28Utilities.GetDistanceBetweenPositions(tNearestACU, oFactory:GetPosition()) <= 175 then
            --Does enemy have any T2+ buildings?
            local tNearbyEnemyT2Plus = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryT2PlusPD + M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryTMD, oFactory:GetPosition(), 175, 'Enemy')
            if M28Utilities.IsTableEmpty(tNearbyEnemyT2Plus) == false then
                local iTechCategory = M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)
                local iCurIndirectFire = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryIndirect * iTechCategory)
                if iCurIndirectFire <= 10 and M28Conditions.GetFactoryLifetimeCount(oFactory, M28UnitInfo.refCategoryIndirect * iTechCategory) <= 20 then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': WIll try and get MML or mobile arti')
                    end
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryIndirect) then
                        return sBPIDToBuild
                    end
                end
            end
        end
    end

    --High priority engineer where they are needed for special shielding (e.g. of gameenders)
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if iFactoryTechLevel >= 3 and M28Utilities.IsTableEmpty(oFactory[M28Building.reftoUnitsWantingFactoryEngineers]) == false then
        --Do we already have at least 3 engineers of this factory's faction in the zone that the gameender is in?
        local iFactionRef = M28UnitInfo.GetUnitFaction(oFactory)
        for iUnit, oUnit in oFactory[M28Building.reftoUnitsWantingFactoryEngineers] do
            if M28UnitInfo.IsUnitValid(oUnit) then
                local iGameEnderPlateau, iGameEnderZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                local tLZTeamData = M28Map.tAllPlateaus[iGameEnderPlateau][M28Map.subrefPlateauLandZones][iGameEnderZone][M28Map.subrefLZTeamData][aiBrain.M28Team]
                if tLZTeamData[M28Map.subreftbBPByFactionWanted][iFactionRef] then
                    --How many T3 engineers of this faction do we have traveling to this zone already?
                    local iEngiCatWanted = M28UnitInfo.refCategoryEngineer * categories.TECH3
                    if iFactionRef == M28UnitInfo.refFactionUEF then iEngiCatWanted = iEngiCatWanted * categories.UEF
                    elseif iFactionRef == M28UnitInfo.refFactionAeon then iEngiCatWanted = iEngiCatWanted * categories.AEON
                    elseif iFactionRef == M28UnitInfo.refFactionCybran then iEngiCatWanted = iEngiCatWanted * categories.CYBRAN
                    elseif iFactionRef == M28UnitInfo.refFactionSeraphim then iEngiCatWanted = iEngiCatWanted * categories.SERAPHIM
                    end
                    local iEngisAlreadyTraveling = 0
                    --Want at least 3 enginers traveling of the desired tech level
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
                        for iEngi, oEngi in  tLZTeamData[M28Map.subrefTEngineersTravelingHere] do
                            if M28UnitInfo.IsUnitValid(oEngi) and EntityCategoryContains(iEngiCatWanted, oEngi.UnitId) then
                                iEngisAlreadyTraveling = iEngisAlreadyTraveling + 1
                            end
                        end
                    end
                    if iEngisAlreadyTraveling < 3 then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer * categories.TECH3) then return sBPIDToBuild end
                    end
                end
            end
        end
    end

    --Enemies nearby and have built fewer tanks of this tech level than engineers; or are on a core expansion and have no combat threat in this LZ
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': CHecking if nearby enemy threat and we are T2 plus, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Enemies in this or adjacent LZ=' .. tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) .. '; bSaveMassDueToEnemyFirebaseOrOurExperimental=' .. tostring(bSaveMassDueToEnemyFirebaseOrOurExperimental) .. '; bDontConsiderBuildingMAA=' .. tostring(bDontConsiderBuildingMAA))
    end
    if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
        --Build tanks unless we have a LC of tanks of at least 5 and more than our LC of engineers
        local iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iLandZone, bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths)
        if iCategoryToGet then
            if not (iCategoryToGet) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    if iFactoryTechLevel < 3 or not (bDontConsiderBuildingMAA) then
                        iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iAdjLZ, bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths)
                    elseif M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 1000 then
                        iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iAdjLZ, false, bConsiderMobileShields, bConsiderMobileStealths)
                    else
                        iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iAdjLZ, bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths)
                    end
                    if iCategoryToGet then
                        break
                    end
                end
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Finished checking for support category wanted for this or adjacent LZ. Is iCategoryToGet nil=' .. tostring(iCategoryToGet == nil))
            end
            if iCategoryToGet then
                local iTankLC = M28Conditions.GetLifetimeBuildCount(aiBrain, iCategoryToGet * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Lifetime build count for this tech level=' .. iTankLC .. '; Engi LC for this tech=' .. M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)))
                end
                if iTankLC < 3 or bHaveLowMass or iTankLC < M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then
                    if iFactoryTechLevel < 3 then
                        if ConsiderBuildingCategory(iCategoryToGet) then
                            return sBPIDToBuild
                        end
                    else
                        --If are overflowing mass, no enemies in cur LZ, at T3, and need BP, then get engineers
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Checking for mass overflow exception where will get engis instead; tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]=' .. tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) .. '; Stored%=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] .. '; Want BP=' .. tostring(tLZTeamData[M28Map.subrefTbWantBP]) .. '; iTankLC=' .. iTankLC)
                        end
                        if iTankLC >= 4 and not (bHaveLowMass) and not (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.95 and tLZTeamData[M28Map.subrefTbWantBP] and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) or M28Utilities.GetDistanceBetweenPositions(oFactory:GetPosition(), M28Utilities.GetNearestUnit(tLZTeamData[M28Map.reftoNearestDFEnemies], oFactory:GetPosition()):GetPosition()) >= 70) then
                            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                                return sBPIDToBuild
                            end
                        else
                            --Enemies near to base/land factory, and we have a category to get; however want to still consider unit ratios but based on these LZs before going with the standard support category - i.e. consider indirect fire if have lots of DF and T3 land
                            local iDFTotalThreat = tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
                            local iIndirectTotalThreat = tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]
                            local iEnemyAirToGroundThreat = tLZTeamData[M28Map.refiEnemyAirToGroundThreat]
                            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                    iDFTotalThreat = iDFTotalThreat + M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatAllyMobileDFTotal]
                                    iIndirectTotalThreat = iIndirectTotalThreat + M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatAllyMobileIndirectTotal]
                                    iEnemyAirToGroundThreat = iEnemyAirToGroundThreat + M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.refiEnemyAirToGroundThreat]
                                end
                            end
                            if iDFTotalThreat >= 8000 and iDFTotalThreat > iIndirectTotalThreat * 8 and iEnemyAirToGroundThreat <= tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] and (EntityCategoryContains(categories.AEON, oFactory.UnitId)) or iDFTotalThreat > iIndirectTotalThreat * 10 then
                                if ConsiderBuildingCategory(M28UnitInfo.refCategoryT3MobileArtillery) then
                                    return sBPIDToBuild
                                end
                            elseif ConsiderBuildingCategory(iCategoryToGet) then
                                return sBPIDToBuild
                            end
                        end
                    end
                end
            end
        end
    end

    --Priority tanks if at T2
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering priority T2 units, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Highest friendly factory tech=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] .. '; Lifetime build count for T2 land combat=' .. M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat - categories.TECH1) .. '; Current T2+ engineers=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer - categories.TECH1))
    end
    if iFactoryTechLevel == 2 and iFactoryTechLevel == M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat - categories.TECH1) < math.min(3, aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer - categories.TECH1)) then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Cur skirmishers=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategorySkirmisher * categories.TECH2) .. '; Cur DF tnaks=' .. ConsiderBuildingCategory(M28UnitInfo.refCategoryLandCombat * categories.TECH2)..'; subrefbLZWantsIndirectSupport='..tostring(tLZTeamData[M28Map.subrefbLZWantsIndirectSupport] or false))
        end
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and aiBrain:GetCurrentUnits(M28UnitInfo.refCategorySkirmisher * categories.TECH2) > math.max(2, aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandCombat * categories.TECH2)) then
            --Does enemy have structure threat in this or adjacent LZ? if so then prioritise MML instead unless we already have at least 5
            if tLZTeamData[M28Map.subrefbLZWantsIndirectSupport] and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryIndirect * categories.TECH2) < 5 then
                if bDebugMessages == true then LOG(sFunctionRef..': Want more MML') end
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryIndirect * categories.TECH2) then return sBPIDToBuild end
            end

            if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandCombat * categories.TECH2) then
                return sBPIDToBuild
            else
                if ConsiderBuildingCategory(M28UnitInfo.refCategorySkirmisher * categories.TECH2) then
                    return sBPIDToBuild
                elseif ConsiderBuildingCategory(M28UnitInfo.refCategoryLandCombat * categories.TECH2) then
                    return sBPIDToBuild
                end
            end
        end
    end

    --Initial engineers
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering high priority engineers, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Team highest factory tech level=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] .. '; Lifetime build count=' .. M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) .. '; Current units=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)))
    end
    if iFactoryTechLevel >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] and tLZTeamData[M28Map.subrefLZbCoreBase] then
        local iMinEngisWanted --lifetime count; or half this for active current number
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
            iMinEngisWanted = 2
        else
            iMinEngisWanted = 4
        end
        if M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) < iMinEngisWanted or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) <= (iMinEngisWanted * 0.5) then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                return sBPIDToBuild
            end
        end
    end

    --Engineers if overflowing and at T3 and no ground enemies in this zone
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Engineers when about to overflow, [M28Map.subrefTbWantBP]='..tostring(tLZTeamData[M28Map.subrefTbWantBP])..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]=' .. tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) .. '; bHaveLowMass=' .. tostring(bHaveLowMass) .. '; Want more BP=' .. tostring(tLZTeamData[M28Map.subrefTbWantBP]) .. '; iFactoryTechLevel=' .. iFactoryTechLevel .. '; Mass percent stored=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] .. '; Gross mass=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass])
    end
    if not (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and not (bHaveLowMass) and tLZTeamData[M28Map.subrefTbWantBP] and iFactoryTechLevel >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.7 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 7 then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Will try and get more engieners')
        end
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
            return sBPIDToBuild
        end
    end


    --Early game - more engineers if are on a large map where unlikely to have enemies nearby for a while
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering engineer for maps where enemy far away or not pathable, time=' .. GetGameTimeSeconds() .. '; Factory tehc=' .. iFactoryTechLevel .. '; Core base=' .. tostring(tLZTeamData[M28Map.subrefLZbCoreBase]) .. '; Path to enemy base iwth land=' .. tostring(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) .. '; Dist to closest enemy base from this LZ=' .. M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]))
    end
    if iFactoryTechLevel == 1 and GetGameTimeSeconds() <= 480 and tLZTeamData[M28Map.subrefLZbCoreBase] and (not (aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) or M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) >= 450) then
        --Do we have a low lifetime engineer build count?
        local iLCWanted = 12
        if M28Map.iMapSize <= 512 and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] then
            iLCWanted = 6
        end
        local iLifetimeEngiCount = M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer)
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': iLifetimeEngiCount=' .. iLifetimeEngiCount .. '; iLCWanted=' .. iLCWanted)
        end
        if iLifetimeEngiCount < iLCWanted then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                return sBPIDToBuild
            end
        end
        if iLifetimeEngiCount < 30 and (not (aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) or M28Map.iMapSize > 512 or iLifetimeEngiCount < iLCWanted * 1.25) then
            --Do we have adjacent LZ with unbuilt mexes, no enemies, needing engineers with no engineers currently assigned or traveling?
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                if not (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefMexUnbuiltLocations]) == false and M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEngineersTravelingHere]) == false and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP] then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                            return sBPIDToBuild
                        end
                    end
                end
            end

            --Do we have a nearby island wanting engineers?
            if GetGameTimeSeconds() <= 360 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
                local iDistanceThreshold
                if bHaveLowMass then
                    iDistanceThreshold = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) * 0.5
                    --If have t2 naval fac then greatly reduce distance threshold
                    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] >= 2 then
                        iDistanceThreshold = iDistanceThreshold * 0.4
                    end
                else
                    iDistanceThreshold = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) * 0.75
                end
                iDistanceThreshold = math.min(300, iDistanceThreshold)

                for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Considering island ' .. tPathingData[M28Map.subrefIslandNumber] .. '; travel dist=' .. tPathingData[M28Map.subrefIslandTravelDist] .. '; Closest LZ ref=' .. (tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil') .. '; are enemies in this or adjacent LZ=' .. tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]))
                    end
                    if tPathingData[M28Map.subrefIslandTravelDist] > iDistanceThreshold then
                        break
                    else
                        --Only consider island if available mexes and no enemies
                        if tPathingData[M28Map.subrefIslandClosestLZRef] then
                            local tIslandLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]]
                            local tIslandLZTeamData = tIslandLZData[M28Map.subrefLZTeamData][iTeam]
                            if not (tIslandLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefMexUnbuiltLocations]) == false and tIslandLZData[M28Map.subrefTbWantBP] then
                                if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer - categories.FIELDENGINEER) then
                                    return sBPIDToBuild
                                end
                            end
                        end
                    end
                end
            end
        end
    end


    --Initiail combat
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering initial combat units, lifetime count=' .. M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandCombat))
    end
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bCanPathToEnemyWithLand and iFactoryTechLevel == 1 and bHaveHighestLZTech and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandCombat) < 3 then
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryDFTank) then
            return sBPIDToBuild
        end
    end

    --Scouts if we want any, subject to limit based on number of engineers we have
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering if we want land scouts, does this LZ want scouts=' .. tostring(tLZTeamData[M28Map.refbWantLandScout]))
    end
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if tLZTeamData[M28Map.refbWantLandScout] then
        if not (bHaveHighestLZTech) then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandScout) then
                return sBPIDToBuild
            end
        else
            local iCurLandScouts = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandScout)
            if iCurLandScouts < 8 or iCurLandScouts < aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer) or iCurLandScouts * 2 < aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandCombat) then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandScout) then
                    return sBPIDToBuild
                end
            end
        end
    end


    --Initial T2+ tanks if have at least 5 engis of our current tech level and dont have many tanks, and can path to enemy by land (core base only)
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if iFactoryTechLevel >= 2 and bHaveHighestLZTech and tLZTeamData[M28Map.subrefLZbCoreBase] then
        --Can we path to enemy base from this land zone?
        local iCurIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint])
        local iEnemyIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase])
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; iCurIsland=' .. iCurIsland .. '; iEnemyIsland=' .. iEnemyIsland .. '; iFactoryTechLevel=' .. iFactoryTechLevel .. '; Cur engineers of this tech level=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) .. '; Cur DF units of this tech level=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMobileLand * categories.DIRECTFIRE * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)))
        end
        if iCurIsland == iEnemyIsland and math.min(8 - M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount], aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))) > math.max(1, aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMobileLand * categories.DIRECTFIRE * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))) then
            if bCanPathToEnemyWithLand then
                if ConsiderBuildingCategory(M28UnitInfo.refCategorySkirmisher * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then
                    return sBPIDToBuild
                elseif ConsiderBuildingCategory(M28UnitInfo.refCategoryLandCombat * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then
                    return sBPIDToBuild
                end
            else
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryAmphibiousCombat - categories.FIELDENGINEER) then
                    return sBPIDToBuild
                end
            end
        end
    end

    --Non-core land zones - consider building combat units ahead of engineers if need them for this LZ
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; Do we have a core base=' .. tostring(tLZTeamData[M28Map.subrefLZbCoreBase] or false) .. '; will consider if we want non-core base units for this LZ if not a core base')
    end
    if not (tLZTeamData[M28Map.subrefLZbCoreBase]) then
        local iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iLandZone, bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths, bSaveMassDueToEnemyFirebaseOrOurExperimental)
        if iCategoryToGet then
            if ConsiderBuildingCategory(iCategoryToGet) then
                return sBPIDToBuild
            end
        end
    end

    --Combat units in proportion to engineers at T1 if enemy relatively nearby spawn
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if iFactoryTechLevel == 1 and GetGameTimeSeconds() <= 480 and tLZTeamData[M28Map.subrefLZbCoreBase] and (aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) and M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) < 450 then
        local iLifetimeEngineers = M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer)
        local iLifetimeLandCombat = M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat)
        if iLifetimeLandCombat < math.max(5, iLifetimeEngineers) and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandCombat) < aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer) then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandCombat) then
                return sBPIDToBuild
            end
        end
    end

    --Engineers if we dont have low mass, and want more
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    local bNeedCurTech = true
    for iCurTech = 1, iFactoryTechLevel do
        if tLZTeamData[M28Map.subrefSpareBPByTech][iCurTech] > 0 then
            bNeedCurTech = false
            break
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; about to consider getting engineers, do we have low mass=' .. tostring(bHaveLowMass) .. '; Highest team tech level=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] .. '; bHaveHighestLZTech=' .. tostring(bHaveHighestLZTech) .. '; bNeedCurTech=' .. tostring(bNeedCurTech) .. '; iFactoryTechLevel=' .. iFactoryTechLevel .. '; Lowest % mass stored=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored])
    end
    if bNeedCurTech and not (bHaveLowMass) and (iFactoryTechLevel >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5) then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Will try to build engineer')
        end
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
            return sBPIDToBuild
        end
    end

    --Engineers if we have few engineers in the current land zone and want more, and no adjacent enemies
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; Will consider if we want more engis due to only having a few in the land zone, bNeedCurTech=' .. tostring(bNeedCurTech) .. '; tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal])
    end
    if bNeedCurTech and not (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 10) then
        local tLZEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        local iEngisInLZ = 0
        if M28Utilities.IsTableEmpty(tLZEngineers) == false then
            iEngisInLZ = table.getn(tLZEngineers)
        end
        local iEngisWanted = 3
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
            iEngisWanted = 2
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] > 3 then
            iEngisWanted = math.min(6, math.ceil(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]))
        end
        if not (tLZTeamData[M28Map.subrefLZbCoreBase]) then
            iEngisWanted = iEngisWanted * 0.5
        end
        if iEngisInLZ < iEngisWanted then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                return sBPIDToBuild
            end
        end
    end


    --Other actions - dont do unless we have lots of mass if this is lower than our highest tech level
    if bHaveHighestLZTech and (iFactoryTechLevel >= aiBrain[M28Economy.refiOurHighestLandFactoryTech] or not (bHaveLowMass)) then

        --Combat or MAA if this LZ needs more units
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        --if tLZTeamData[M28Map.subrefbLZWantsSupport] then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Have highest LZ tech, iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; Will see if we want to get support for this LZ, bDontConsiderBuildingMAA=' .. tostring(bDontConsiderBuildingMAA) .. '; bConsiderMobileShields=' .. tostring(bConsiderMobileShields) .. '; bConsiderMobileStealths=' .. tostring(bConsiderMobileStealths))
        end
        local iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iLandZone, bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths, bSaveMassDueToEnemyFirebaseOrOurExperimental)
        if iCategoryToGet then
            if ConsiderBuildingCategory(iCategoryToGet) then
                return sBPIDToBuild
            end
        end


        --Upgrade factory if this LZ is lagging behind tech wise (but not if low mass if this isn't a core LZ
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if iFactoryTechLevel == 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 2 and (iLandFactoriesInLZ >= 4 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] == 3) and (tLZTeamData[M28Map.subrefLZbCoreBase] or (tLZTeamData[M28Map.subrefLZCoreExpansion] and (not (bHaveLowMass) or M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint])] >= 7))) then
            --Dont upgrade to T2 if we have T1 mexes in the LZ, no upgrading mexes, and less than 35 gross mass per tick
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 3.5 or tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] * 3 >= 3 or tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then

                local bUpgradingLandFactory = false
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then
                    for iUnit, oUnit in tLZTeamData[M28Map.subrefActiveUpgrades] do
                        if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) then
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Have an active land factory upgrade=' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit.UnitId) .. '; Is unit valid=' .. tostring(M28UnitInfo.IsUnitValid(oUnit)) .. '; Fraction complete=' .. oUnit:GetFractionComplete() .. '; Work progress=' .. oUnit:GetWorkProgress())
                            end
                            bUpgradingLandFactory = true
                            break
                        end
                    end
                end
                if not (bUpgradingLandFactory) then
                    if ConsiderUpgrading() then
                        return sBPIDToBuild
                    end
                end
            end
        end

        --Maintain basic level of unit threat ratios
        --DF tanks of the cur tech level or higher - get more if we have fewer of these than we have engineers of this tech level and we have less DF threat than the enemy overall
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bCanPathToEnemyWithLand and not (bSaveMassDueToEnemyFirebaseOrOurExperimental) and iFactoryTechLevel >= 2 and math.min(9, aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))) > aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMobileLand * categories.DIRECTFIRE * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Have fewer DF tanks than engineers so want to get more skirmishers or (if cant build any) DF tanks')
            end


            if ConsiderBuildingCategory(M28UnitInfo.refCategorySkirmisher * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then
                return sBPIDToBuild
            else
                --Cant get skirmishers, so get indirect fire if we have none before getting normal tnaks
                if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryIndirect * categories.MOBILE * categories.LAND * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) == 0 and ConsiderBuildingCategory(M28UnitInfo.refCategoryIndirect * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then
                    return sBPIDToBuild
                elseif ConsiderBuildingCategory(M28UnitInfo.refCategoryLandCombat * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then
                    return sBPIDToBuild
                end
            end
        end

        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Checking threat ratios for if we want more indirect, DF threat=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] .. '; Indirect=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat])
        end
        if not (bSaveMassDueToEnemyFirebaseOrOurExperimental) then
            local iIndirectRatioWanted
            if iFactoryTechLevel == 1 then
                iIndirectRatioWanted = 6
            elseif iFactoryTechLevel == 2 then
                iIndirectRatioWanted = 9
            elseif iFactoryTechLevel == 3 then
                if aiBrain:GetCurrentUnits((M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategorySkirmisher) * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) >= 60 then
                    if EntityCategoryContains(categories.AEON, oFactory.UnitId) then
                        iIndirectRatioWanted = 3.5
                    else
                        iIndirectRatioWanted = 4
                    end
                else
                    if EntityCategoryContains(categories.AEON, oFactory.UnitId) then
                        iIndirectRatioWanted = 7
                    else
                        iIndirectRatioWanted = 9
                    end
                end
            end
            if bCanPathToEnemyWithLand and M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] > M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] * iIndirectRatioWanted and (not (bHaveLowMass) or (iFactoryTechLevel >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] > M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] * iIndirectRatioWanted * 2 and aiBrain:GetCurrentUnits((M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategorySkirmisher) * categories.TECH3) >= 50)) then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Will try to build more indirect fire units if arent building any of this tech level or higher in this LZ')
                end
                if iFactoryTechLevel == 1 or M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryIndirect * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) == 0 then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryIndirect) then
                        return sBPIDToBuild
                    end
                end
            end
        end

        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bCanPathToEnemyWithLand and not (bHaveLowMass) and not (bDontConsiderBuildingMAA) then
            --Maintain MAA ratio vs overall combat threat - Only get MAA if we either have T2 land, or 50 gross mass, or enemy has air; max of 2 at a time
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Checking MAA ratio overall, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]=' .. M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] .. '; M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir]=' .. tostring(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir]) .. '; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat])
            end
            if iFactoryTechLevel >= 2 or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoAllEnemyAir]) == false or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 5 then
                local iThreatFactor = 20
                if M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir] and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 4000 then
                    iThreatFactor = 8
                elseif not (M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl]) and (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 2000 or M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir]) then
                    iThreatFactor = 13
                end
                if M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] > M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] * iThreatFactor then
                    local iMAACat
                    if oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA) >= 50 or (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] >= 2000 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.TECH3 * M28UnitInfo.refCategoryBomber, M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround])) == false) and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA - categories.TECH3) > oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) * 4 then
                        iMAACat = M28UnitInfo.refCategoryMAA
                    else
                        iMAACat = M28UnitInfo.refCategoryMAA - categories.TECH3
                    end
                    if M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, iMAACat) <= 1 then
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Will get MAA3')
                        end
                        if ConsiderBuildingCategory(iMAACat) then
                            return sBPIDToBuild
                        end
                    end
                end
            end
        end

        --Be building engineers in 1/4 of land facs if we have a shortfall for this land zone
        if iLandFactoriesInLZ > 1 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.01 or M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) and tLZTeamData[M28Map.subrefTbWantBP] then
            if M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryEngineer) < iLandFactoriesInLZ * 0.25 then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                    return sBPIDToBuild
                end
            end
        end

        --Combat or MAA if we have a LZ within half of dist between us and nearest enemy that wants more units
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        local iEnemyPlateau, iEnemyLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.GetPrimaryEnemyBaseLocation(aiBrain))
        if iEnemyPlateau == iPlateau then
            local iDistToEnemyBaseToConsider
            --Is enemy in same island?
            local iIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint])

            if NavUtils.GetLabel(M28Map.refPathingTypeLand, M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) == iIsland then
                if not (bHaveLowMass) then
                    iDistToEnemyBaseToConsider = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iEnemyLandZone) * 0.75
                else
                    iDistToEnemyBaseToConsider = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iEnemyLandZone) * 0.5
                end
            else
                --enemy base is a dif island to ours, so want to control all of our island (within reason)
                iDistToEnemyBaseToConsider = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.GetPrimaryEnemyBaseLocation(aiBrain))
            end
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                for iEntry, tLZPathing in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': About to check alternative LZ ' .. tLZPathing[M28Map.subrefLZNumber] .. '; iDistToEnemyBaseToConsider=' .. iDistToEnemyBaseToConsider .. '; tLZPathing[M28Map.subrefLZTravelDist]=' .. tLZPathing[M28Map.subrefLZTravelDist])
                    end
                    if tLZPathing[M28Map.subrefLZTravelDist] <= iDistToEnemyBaseToConsider then
                        --if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tLZPathing[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefbLZWantsSupport] then
                        --How far away is it?
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Considering whether to reinforce alternative LZ ' .. (tLZPathing[M28Map.subrefLZNumber] or 'nil') .. '; Travel dist=' .. (tLZPathing[M28Map.subrefLZTravelDist] or 'nil') .. '; iDistToEnemyBaseToConsider=' .. (iDistToEnemyBaseToConsider or 'nil') .. '; Size of this alt LZ in segments=' .. (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tLZPathing[M28Map.subrefLZNumber]][M28Map.subrefLZTotalSegmentCount] or 'nil'))
                        end
                        --if tLZPathing[M28Map.subrefLZTravelDist] <= iDistToEnemyBaseToConsider then
                        local iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, tLZPathing[M28Map.subrefLZNumber], bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths, bSaveMassDueToEnemyFirebaseOrOurExperimental)
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': DO we have no category (i.e. false means we want to build something) for this alternative LZ ' .. tLZPathing[M28Map.subrefLZNumber] .. '=' .. tostring(iCategoryToGet == nil) .. '; bDontConsiderBuildingMAA=' .. tostring(bDontConsiderBuildingMAA))
                        end
                        if iCategoryToGet then
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Will draw the LZ where we want more units in a rnadom colour')
                                M28Map.DrawSpecificLandZone(iPlateau, tLZPathing[M28Map.subrefLZNumber], math.random(1, 8))
                            end
                            if ConsiderBuildingCategory(iCategoryToGet) then
                                return sBPIDToBuild
                            end
                        end
                    else
                        break
                    end
                end
            end
        end

        --Do we have adjacent water with friendly units that wants MAA?
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false and not (bDontConsiderBuildingMAA) then
            local iAdjWZ, iPond
            local iCategoryWanted = (categories.NAVAL + categories.AMPHIBIOUS + categories.HOVER) * M28UnitInfo.refCategoryMAA
            for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                iPond = M28Map.tiPondByWaterZone[iAdjWZ]
                local tWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                if bDebugMessages == true then
                    if not (iPond) then
                        LOG('iPond nil')
                    end
                    if not (iAdjWZ) then
                        LOG('iAdjWZ nil')
                    end
                    if not (tWZTeamData[M28Map.subrefWZMAAThreatWanted]) then
                        LOG('tWZTeamData[M28Map.subrefWZMAAThreatWanted] nil')
                    end
                    if not (tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]) then
                        LOG('tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] nil')
                    end
                    if not (tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]) then
                        LOG('tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] nil')
                    end
                    LOG(sFunctionRef .. ': Considering if want MAA for iPond=' .. iPond .. '; iAdjWZ=' .. iAdjWZ .. '; tWZTeamData[M28Map.subrefWZMAAThreatWanted]=' .. tWZTeamData[M28Map.subrefWZMAAThreatWanted] .. '; tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] .. '; tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]=' .. tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal])
                end
                if tWZTeamData[M28Map.subrefWZMAAThreatWanted] > 0 and (tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < 10 or tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] > 10) then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Will try and build hover flak to support adjacent water zone')
                    end
                    if ConsiderBuildingCategory(iCategoryWanted) then
                        return sBPIDToBuild
                    end
                end
            end
        end

        --Now consider islands
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
            local iDistanceThreshold
            if bHaveLowMass then
                iDistanceThreshold = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) * 0.5
                --If have t2 naval fac then greatly reduce distance threshold
                if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] >= 2 then
                    iDistanceThreshold = iDistanceThreshold * 0.4
                end
            else
                iDistanceThreshold = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) * 0.75
            end

            for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Considering island ' .. tPathingData[M28Map.subrefIslandNumber] .. '; travel dist=' .. tPathingData[M28Map.subrefIslandTravelDist] .. '; Closest LZ ref=' .. (tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil') .. '; are enemies in this or adjacent LZ=' .. tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]))
                end
                if tPathingData[M28Map.subrefIslandTravelDist] > iDistanceThreshold then
                    break
                else
                    --Are there enemies in the target LZ?
                    if tPathingData[M28Map.subrefIslandClosestLZRef] and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryAmphibiousCombat - categories.FIELDENGINEER) then
                            return sBPIDToBuild
                        end
                    end
                end
            end
        end
    elseif (not (bHaveHighestLZTech) or iFactoryTechLevel < aiBrain[M28Economy.refiOurHighestLandFactoryTech]) then
        --Dont have highest tech, and have low mass
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Consideringi f we want to upgrade factory, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Brain highest tech=' .. aiBrain[M28Economy.refiOurHighestLandFactoryTech])
        end
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if iFactoryTechLevel < aiBrain[M28Economy.refiOurHighestLandFactoryTech] then
            --Do we want ot upgrade a support factory? Check first if are upgrading anything here
            local bUpgradingLandFactory = false

            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then
                for iUnit, oUnit in tLZTeamData[M28Map.subrefActiveUpgrades] do
                    if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) then
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Have an active land factory upgrade=' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit.UnitId) .. '; Is unit valid=' .. tostring(M28UnitInfo.IsUnitValid(oUnit)) .. '; Fraction complete=' .. oUnit:GetFractionComplete() .. '; Work progress=' .. oUnit:GetWorkProgress())
                        end
                        bUpgradingLandFactory = true
                        break
                    end
                end
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': bUpgradingLandFactory=' .. tostring(bUpgradingLandFactory) .. '; bHaveLowMass=' .. tostring(bHaveLowMass) .. '; Lowest mass % stored=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored])
            end
            if not (bUpgradingLandFactory) or (not (bHaveLowMass) and aiBrain[M28Economy.refiOurHighestLandFactoryTech] == 3 and (iFactoryTechLevel == 1 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5)) then
                if (tLZTeamData[M28Map.subrefLZbCoreBase] or (tLZTeamData[M28Map.subrefLZCoreExpansion] and (not (bHaveLowMass) or M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint])] >= 7))) then
                    if not (bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.3 and M28Conditions.GetLifetimeBuildCount(aiBrain, categories.LAND * categories.MOBILE * M28UnitInfo.ConvertTechLevelToCategory(aiBrain[M28Economy.refiOurHighestLandFactoryTech])) >= 3 then
                        if ConsiderUpgrading() then
                            return sBPIDToBuild
                        end
                    elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.02 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.15 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0) and M28Conditions.GetLifetimeBuildCount(aiBrain, categories.LAND * categories.MOBILE * M28UnitInfo.ConvertTechLevelToCategory(aiBrain[M28Economy.refiOurHighestLandFactoryTech])) >= 6 then
                        --Still consider upgrading if we have a T2 land factory but no t2 support factory in the LZ and have built some T2 units already
                        local tLandFactoriesInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                        local iHQAndSupportCount = 0
                        for iUnit, oUnit in tLandFactoriesInZone do
                            if M28UnitInfo.GetUnitTechLevel(oUnit) >= aiBrain[M28Economy.refiOurHighestLandFactoryTech] then
                                iHQAndSupportCount = iHQAndSupportCount + 1
                            end
                        end
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': iHQAndSupportCount=' .. iHQAndSupportCount)
                        end
                        if iHQAndSupportCount <= 1 then
                            if ConsiderUpgrading() then
                                return sBPIDToBuild
                            end
                        end
                    end
                end
            end
        end

        --Do we want MAA, mobile shield or mobile stealth (with T2 factory while we have other T3 factories)?
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if iFactoryTechLevel == 2 then
            local iEnemyPlateau, iEnemyLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.GetPrimaryEnemyBaseLocation(aiBrain))
            if iEnemyPlateau == iPlateau then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Time ' .. GetGameTimeSeconds() .. '; aiBrain[M28Overseer.refiDistanceToNearestEnemyBase]=' .. (aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] or 'nil') .. '; iPlateau=' .. (iPlateau or 'nil') .. '; iLandZone=' .. (iLandZone or 'nil') .. '; iEnemyLandZone=' .. (iEnemyLandZone or 'nil') .. '; Factory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. ' at position ' .. repru(oFactory:GetPosition()) .. '; Primary enemy base location=' .. repru(M28Map.GetPrimaryEnemyBaseLocation(aiBrain)))
                end
                local iDistToEnemyBaseToConsider
                if iEnemyLandZone == iLandZone then
                    iDistToEnemyBaseToConsider = (M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iEnemyLandZone) or aiBrain[M28Overseer.refiDistanceToNearestEnemyBase]) * 0.5
                else
                    iDistToEnemyBaseToConsider = aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.4
                end
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                    for iEntry, tLZPathing in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                        if tLZPathing[M28Map.subrefLZTravelDist] <= iDistToEnemyBaseToConsider then
                            --How far away is it?
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': T2 Considering whether to reinforce alternative LZ ' .. tLZPathing[M28Map.subrefLZNumber] .. '; Travel dist=' .. tLZPathing[M28Map.subrefLZTravelDist] .. '; iDistToEnemyBaseToConsider=' .. iDistToEnemyBaseToConsider)
                            end
                            if tLZPathing[M28Map.subrefLZTravelDist] <= iDistToEnemyBaseToConsider then
                                local iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, tLZPathing[M28Map.subrefLZNumber], bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths, true)
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': T2 DO we have no category for this alternative LZ ' .. tLZPathing[M28Map.subrefLZNumber] .. '=' .. tostring(iCategoryToGet == nil) .. '; bDontConsiderBuildingMAA=' .. tostring(bDontConsiderBuildingMAA))
                                end
                                if iCategoryToGet then
                                    if ConsiderBuildingCategory(iCategoryToGet) then
                                        return sBPIDToBuild
                                    end
                                end
                            end
                        else
                            break
                        end
                    end
                end
            end
        end
    end

    --Different island to nearest friendly base - ensure we have some DF and indirect fire threat nearby
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if not(NavUtils.GetLabel(M28Map.refPathingTypeLand, oFactory:GetPosition()) == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.reftClosestFriendlyBase])) then
        if bDebugMessages == true then LOG(sFunctionRef..': Closest base is in a different island, so will get base level of tanks') end
        local iNearbyDFThreat = tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
        local iNearbyIFThreat = tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]
        local iNearbyGroundAAThreat = tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]

        if iNearbyDFThreat < 100 or iNearbyIFThreat < 50 or iNearbyGroundAAThreat < 100 then
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                    iNearbyDFThreat = iNearbyDFThreat + tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
                    iNearbyIFThreat = iNearbyIFThreat + tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]
                    iNearbyGroundAAThreat = iNearbyGroundAAThreat + tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]
                end
            end
            if iNearbyDFThreat < 100 or iNearbyIFThreat < 50 or iNearbyGroundAAThreat < 100 then
                if bDebugMessages == true then LOG(sFunctionRef..': Will get basic level of combat threat as are on an island') end
                if iNearbyDFThreat < 100 then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandCombat * categories.DIRECTFIRE) then return sBPIDToBuild end
                end
                if iNearbyGroundAAThreat < 100 then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryMAA) then return sBPIDToBuild end
                end
                if iNearbyIFThreat < 50 then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryIndirect) then return sBPIDToBuild end
                end
            end
        end


    end

    --Engineers if we have mass and dont have spare engineers
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering if want engineers if have mass: M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] .. '; bHaveHighestLZTech=' .. tostring(bHaveHighestLZTech) .. '; subrefTbWantBP=' .. tostring(tLZTeamData[M28Map.subrefTbWantBP]))
    end
    if tLZTeamData[M28Map.subrefTbWantBP] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.01 and (bHaveHighestLZTech or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.4 and tLZTeamData[M28Map.subrefLZbCoreBase])) then
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
            return sBPIDToBuild
        end
    end

    --T1 mobile arti if we dont ahve low mass and are below highest tech level, or normal tanks otherwise
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if not (bHaveLowMass) and (not (bSaveMassDueToEnemyFirebaseOrOurExperimental) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.45) then
        --Is there a relatively nearby enemy?

        local bEnemiesRelativelyNear = tLZData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]
        if not (bEnemiesRelativelyNear) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                    bEnemiesRelativelyNear = true
                    break
                end
            end
        end
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Dont have low mass so considering if we have enemies adjacent to an adjacent LZ in which case will build T1 arti, bEnemiesRelativelyNear=' .. tostring(bEnemiesRelativelyNear))
        end
        if bEnemiesRelativelyNear then
            if bHaveHighestLZTech then
                if bCanPathToEnemyWithLand then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategorySkirmisher) then
                        return sBPIDToBuild
                    end
                else
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryAmphibiousCombat - categories.FIELDENGINEER) then
                        return sBPIDToBuild
                    end
                end
            else
                if bCanPathToEnemyWithLand and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryIndirect * categories.TECH1) <= 60 then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryIndirect * categories.TECH1) then
                        return sBPIDToBuild
                    end
                end
            end
        end
    end



    --Upgrade T1 to T2 if we have multiple mex upgrades and T1 land facs in this land zone, and already have T2 land, even if have low mass
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if iFactoryTechLevel == 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 20 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] or -5) >= 3 then
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false and table.getn(tLZTeamData[M28Map.subrefActiveUpgrades]) >= 3 then
            if (tLZTeamData[M28Map.subrefLZbCoreBase] or (tLZTeamData[M28Map.subrefLZCoreExpansion] and (not (bHaveLowMass) or M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint])] >= 7))) then
                local iCurMexUpgrades = 0
                local iCurT1FactoryUpgrades = 0
                for iUnit, oUnit in tLZTeamData[M28Map.subrefActiveUpgrades] do
                    if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                        iCurMexUpgrades = iCurMexUpgrades + 1
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryFactory * categories.TECH1, oUnit.UnitId) then
                        iCurT1FactoryUpgrades = iCurT1FactoryUpgrades + 1
                    end
                end
                if iCurT1FactoryUpgrades == 0 and iCurMexUpgrades >= 2 then
                    --Do we have more than 1 T1 land factory in this land zone?
                    local tT1LandFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory * categories.TECH1, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                    if table.getn(tT1LandFactories) >= 2 then
                        if ConsiderUpgrading() then
                            return sBPIDToBuild
                        end
                    end
                end
            end
        end
    end

    --Build more engineers if we have multiple upgrades and need more engineers for the current LZ, even if relatively low mass
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if tLZTeamData[M28Map.subrefTbWantBP] and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 50 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] or -5) >= 5 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) == false then
        if table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 3 then
            --Build engineers as we have lots of upgrades
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                return sBPIDToBuild
            end
        end
    end

    --More land scouts (no cap)
    if tLZTeamData[M28Map.refbWantLandScout] then
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandScout) then
            return sBPIDToBuild
        end
    end

    M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForLandFactory] = GetGameTimeSeconds()
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DetermineWhatToBuild(aiBrain, oFactory)
    local sBPIDToBuild
    if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oFactory.UnitId) then
        sBPIDToBuild = GetBlueprintToBuildForLandFactory(aiBrain, oFactory)
    elseif EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oFactory.UnitId) then
        sBPIDToBuild = GetBlueprintToBuildForAirFactory(aiBrain, oFactory)
    elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oFactory.UnitId) then
        sBPIDToBuild = GetBlueprintToBuildForNavalFactory(aiBrain, oFactory)
    elseif EntityCategoryContains(M28UnitInfo.refCategoryQuantumGateway, oFactory.UnitId) then
        sBPIDToBuild = GetBlueprintToBuildForQuantumGateway(aiBrain, oFactory)
    else
        M28Utilities.ErrorHandler('Need to add code - unexpected factory type')
    end
    return sBPIDToBuild
end
function IsFactoryReadyToBuild(oFactory)
    if oFactory:GetFractionComplete() == 1 and oFactory:GetWorkProgress() == 0 and oFactory:GetFractionComplete() == 1 and not (oFactory:IsUnitState('Building')) and not (oFactory:IsUnitState('Upgrading')) and not (oFactory:IsUnitState('Busy')) and
            (oFactory:IsUnitState('Guarding') or M28Utilities.IsTableEmpty(oFactory:GetCommandQueue())) then
        --Issue in campaign where factories were being given a guard order by another script, meaning their command queue wasnt empty - have updated so this will be ignored
        --Add further check that we havent built something at a nearby factory and have recently stalled
        local aiBrain = oFactory:GetAIBrain()
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oFactory:GetPosition())
        local tLZOrWZTeamData
        local iTeam = aiBrain.M28Team
        if (iLandOrWaterZone or 0) > 0 then
            if iPlateauOrZero == 0 then
                tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
            else
                tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
            end
        end
        if GetGameTimeSeconds() - (tLZOrWZTeamData[M28Map.refiTimeLastBuiltAtFactory] or -100) >= 0.09 then
            --i.e. dont start production in more than 1 factory per zone per tick, so e.g. air facs are less likely to all build asfs at the same time and cause a power stall
            return true
            --backup for scenarios where dont want to wait - if high mass and energy and AiX
        elseif aiBrain.CheatEnabled and tonumber(ScenarioInfo.Options.CheatMult or 1.5) >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 and M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] > (M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] or 0) * 1.25 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or -100) >= 15 then
            return true
        end
    end
    return false
end

function DecideAndBuildUnitForFactory(aiBrain, oFactory, bDontWait, bConsiderDestroyingForMass)
    --If factory is idle then gets it to build something; if its not idle then keeps checking for up to 20 seconds, but will abort if the factory appears to be building something
    local sFunctionRef = 'DecideAndBuildUnitForFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if not (oFactory['M28ActiveBuilderCheck']) then
        oFactory['M28ActiveBuilderCheck'] = true
        local iTicksWaited = 0

        local bProceed = bDontWait
        if not (bProceed) then
            bProceed = IsFactoryReadyToBuild(oFactory)
        end

        local iWorkProgressStart = (oFactory:GetWorkProgress() or 0)
        local iTicksToWait = 1

        while not (bProceed) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(iTicksToWait)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            iTicksWaited = iTicksWaited + iTicksToWait
            if M28UnitInfo.IsUnitValid(oFactory) == false then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return nil
            end
            bProceed = IsFactoryReadyToBuild(oFactory)
            if oFactory:GetWorkProgress() > iWorkProgressStart then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Factory work progress is going up so will abort as it presumably already has an order')
                end
                break
            end
            if iTicksWaited >= 200 then
                if not(oFactory:GetAIBrain()[M28Overseer.refbCloseToUnitCap]) then
                    M28Utilities.ErrorHandler('oFactory has waited more than 200 ticks and still isnt showing as ready to build, oFactory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; brain nickname=' .. oFactory:GetAIBrain().Nickname .. '; Work progress=' .. oFactory:GetWorkProgress() .. '; Factory fraction complete=' .. oFactory:GetFractionComplete() .. '; Factory status=' .. M28UnitInfo.GetUnitState(oFactory) .. '; Is command queue empty=' .. tostring(M28Utilities.IsTableEmpty(oFactory:GetCommandQueue())) .. '; iWorkProgressStart=' .. (iWorkProgressStart or 'nil'), true)
                end
                break
            elseif iTicksWaited >= 40 then
                iTicksToWait = math.min(iTicksToWait + 1, 10)
            end
        end
        if bProceed then
            local sBPToBuild = DetermineWhatToBuild(aiBrain, oFactory)
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': oFactory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; sBPToBuild=' .. (sBPToBuild or 'nil') .. '; Does factory have an empty command queue=' .. tostring(M28Utilities.IsTableEmpty(oFactory:GetCommandQueue())) .. '; Factory work progress=' .. oFactory:GetWorkProgress() .. '; Factory unit state=' .. M28UnitInfo.GetUnitState(oFactory))
            end
            if sBPToBuild then
                --Is this an upgrade or a unit to build?
                if EntityCategoryContains(M28UnitInfo.refCategoryFactory, sBPToBuild) then
                    M28Economy.UpgradeUnit(oFactory, true)
                else
                    M28Orders.IssueTrackedFactoryBuild(oFactory, sBPToBuild, bDontWait)
                end
            else
                --Clear any assisting engineers
                if bDebugMessages == true then LOG(sFunctionRef..': We dont have anything to build, will wait 10 ticks and try again.  In the meantime will clear all assisting engineers. Is table of assisting units empty='..tostring(M28Utilities.IsTableEmpty(oFactory[M28UnitInfo.reftoUnitsAssistingThis]))) end
                if M28Utilities.IsTableEmpty(oFactory[M28UnitInfo.reftoUnitsAssistingThis]) == false then
                    local tUnitsToClear = {}
                    for iUnit, oUnit in oFactory[M28UnitInfo.reftoUnitsAssistingThis] do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            table.insert(tUnitsToClear, oUnit)
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is tUnitsToClear empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToClear))) end
                    if M28Utilities.IsTableEmpty(tUnitsToClear) == false then
                        for iUnit, oUnit in tUnitsToClear do
                            M28Orders.IssueTrackedClearCommands(oUnit)
                        end
                    end
                    oFactory[M28UnitInfo.reftoUnitsAssistingThis] = {}
                end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(10)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if M28UnitInfo.IsUnitValid(oFactory) then
                    local bSelfDestructIfLowMass = false
                    local iExistingT3Factories = 0
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Considering at time ' .. GetGameTimeSeconds() .. ' whether to ctrlk factory tech level ' .. M28UnitInfo.GetUnitTechLevel(oFactory) .. ' when bHaveLowMass=' .. tostring(M28Conditions.HaveLowMass(aiBrain)) .. ' and highest tech=' .. M28Team.tTeamData[oFactory:GetAIBrain().M28Team][M28Team.subrefiHighestFriendlyFactoryTech] .. '; factory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; bConsiderDestroyingForMass=' .. tostring(bConsiderDestroyingForMass or false))
                    end
                    if bConsiderDestroyingForMass and M28UnitInfo.GetUnitTechLevel(oFactory) < 3 and M28Team.tTeamData[oFactory:GetAIBrain().M28Team][M28Team.subrefiHighestFriendlyFactoryTech] == 3 then
                        --Do we have a factory of the same type but of a higher tech level in this LZ?
                        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oFactory:GetPosition())
                        if iPlateauOrZero > 0 then
                            local oBrain = oFactory:GetAIBrain()
                            local iTeam = aiBrain.M28Team
                            local tLZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
                            local iFactoryType = M28UnitInfo.GetFactoryType(oFactory)
                            if iFactoryType == refiFactoryTypeLand then
                                local tExistingT3Factories = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory * categories.TECH3, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': Is table of existing T3 land factories empty=' .. tostring(M28Utilities.IsTableEmpty(tExistingT3Factories)) .. '; Total T3 land owned by this brain=' .. oBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory * categories.TECH3))
                                end
                                iExistingT3Factories = table.getn(tExistingT3Factories)
                                if M28Utilities.IsTableEmpty(tExistingT3Factories) == false and iExistingT3Factories >= 2 and oBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandHQ * categories.TECH3) > 0 then
                                    bSelfDestructIfLowMass = true
                                end

                            elseif iFactoryType == refiFactoryTypeAir then
                                if M28UnitInfo.GetUnitTechLevel(oFactory) == 1 then
                                    local tExistingT3Factories = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory * categories.TECH3, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': Is table of existing T3 air factories empty=' .. tostring(M28Utilities.IsTableEmpty(tExistingT3Factories)) .. ' Brain cur T3 factories=' .. oBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory * categories.TECH3))
                                    end
                                    iExistingT3Factories = table.getn(tExistingT3Factories)
                                    if M28Utilities.IsTableEmpty(tExistingT3Factories) == false and iExistingT3Factories >= 2 and oBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirHQ * categories.TECH3) > 0 then
                                        bSelfDestructIfLowMass = true
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': bSelfDestructIfLowMass=' .. tostring(bSelfDestructIfLowMass))
                    end
                    if not (bSelfDestructIfLowMass) or not (M28Conditions.HaveLowMass(aiBrain)) then
                        ForkThread(DecideAndBuildUnitForFactory, aiBrain, oFactory, false)
                    else
                        sBPToBuild = nil
                        if iExistingT3Factories <= 3 then
                            sBPToBuild = DetermineWhatToBuild(aiBrain, oFactory)
                        end
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Do we have something to build after checking before ctrlK? sBPToBuild=' .. (sBPToBuild or 'nil'))
                        end
                        if sBPToBuild then
                            ForkThread(DecideAndBuildUnitForFactory, aiBrain, oFactory, false)
                        else
                            --CtrlK for mass
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Will ctrlK factory ' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. ' for mass/reclaim')
                            end
                            M28Orders.IssueTrackedKillUnit(oFactory)
                        end
                    end
                end
            end
        end
    end
    oFactory['M28ActiveBuilderCheck'] = false
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SetPreferredUnitsByCategory(aiBrain)
    --If have multiple units that can build for a particular category, this will specify what to build
    --special cases where want to prioritise one unit over another where multiple of same type satisfy the category
    --NOTE: This gets ignored if we have coded in special cases where we want to pick the fastest or slowest unit
    aiBrain[reftBlueprintPriorityOverride] = {}
    --T1
    aiBrain[reftBlueprintPriorityOverride]['ual0201'] = 1 --Aurora (instead of LAB)
    aiBrain[reftBlueprintPriorityOverride]['url0107'] = 1 --Mantis (instead of LAB)
    aiBrain[reftBlueprintPriorityOverride]['uel0201'] = 1 --Striker (instead of mechmarine)
    aiBrain[reftBlueprintPriorityOverride]['xsl0201'] = 1 --Thaam (instead of combat scout)
    --T2
    aiBrain[reftBlueprintPriorityOverride]['uel0202'] = 1 --Pillar (instead of mongoose or riptide)
    aiBrain[reftBlueprintPriorityOverride]['xsl0202'] = 1 --Ilshavoh (instead of hover tank)
    aiBrain[reftBlueprintPriorityOverride]['url0202'] = 1 --Rhino (instead of hover tank)
    aiBrain[reftBlueprintPriorityOverride]['ual0202'] = 1 --Obsidian (instead of blaze)
    --T3
    aiBrain[reftBlueprintPriorityOverride]['uel0303'] = 1 --Titan (instead of Percy)
    aiBrain[reftBlueprintPriorityOverride]['ual0303'] = 1 --Harby (instead of sniper bot)
    --aiBrain[reftBlueprintPriorityOverride]['ual0304'] = 1 --Mobile t3 arti instead of shield disrupter
    aiBrain[reftBlueprintPriorityOverride]['url0303'] = 1 --Loyalist (instead of Brick)
    --aiBrain[reftBlueprintPriorityOverride]['xrl0305'] = 1 --Brick
    aiBrain[reftBlueprintPriorityOverride]['xsl0303'] = 1 --Siege tank (instead of sniper bot)
    aiBrain[reftBlueprintPriorityOverride]['xsl0301'] = 1 --Seraphim basic SACU (instead of preset)

    --Engineers
    aiBrain[reftBlueprintPriorityOverride]['uel0208'] = 1 --T2 Engi (instead of sparky)

end

function IdleFactoryMonitor(aiBrain)
    --Cycles through every factory owned by aiBrain, max of 1 factory per tick, to check if it is idle
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IdleFactoryMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    while not (aiBrain.M28IsDefeated) do
        local tOurFactories = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryQuantumGateway, false, true)
        local tCommandQueue
        local sBPToBuild
        local iTeam
        if M28Utilities.IsTableEmpty(tOurFactories) == false then
            for iFactory, oFactory in tOurFactories do
                if M28UnitInfo.IsUnitValid(oFactory) and oFactory:GetFractionComplete() == 1 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering factory'..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..' at time '..GetGameTimeSeconds()..'; Is factory ready to build='..tostring(IsFactoryReadyToBuild(oFactory))..'; oFactory[M28UnitInfo.refbPaused]='..tostring(oFactory[M28UnitInfo.refbPaused] or false)..'; oFactory:IsPaused()='..tostring(oFactory:IsPaused())) end
                    tCommandQueue = oFactory:GetCommandQueue()
                    if IsFactoryReadyToBuild(oFactory) and GetGameTimeSeconds() - (oFactory[refiTimeSinceLastOrderCheck] or 0) >= 5 then
                        oFactory[refiTimeSinceLastOrderCheck] = GetGameTimeSeconds()
                        ForkThread(DecideAndBuildUnitForFactory, aiBrain, oFactory, nil, true)
                    --Redundancy for paused factories (in theory shouldnt be needed)
                    elseif oFactory[M28UnitInfo.refbPaused] or oFactory:IsPaused() then
                        iTeam = oFactory:GetAIBrain().M28Team
                        if bDebugMessages == true then LOG(sFunctionRef..': M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] or false)..'; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] or false)..'; M28Team.tTeamData[M28Team.subrefiTeamNetMass]='..(M28Team.tTeamData[M28Team.subrefiTeamNetMass] or 'nil')..'; M28Team.tTeamData[M28Team.subrefiTeamNetEnergy]='..(M28Team.tTeamData[M28Team.subrefiTeamNetEnergy] or 'nil')) end
                        if not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > 0 then
                            M28UnitInfo.PauseOrUnpauseMassUsage(oFactory, false)
                            if bDebugMessages == true then LOG(sFunctionRef..': Unpause override for factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)) end
                        end
                    end
                end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(1)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
end

function GetBlueprintToBuildForAirFactory(aiBrain, oFactory)
    local sFunctionRef = 'GetBlueprintToBuildForAirFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCategoryToBuild
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oFactory:GetPosition(), true, oFactory)
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
    local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
    local iTeam = aiBrain.M28Team
    local iAirSubteam = aiBrain.M28AirSubteam
    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
    local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)
    local bSaveMassDueToEnemyFirebaseOrOurExperimental
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]) == false and bHaveLowMass then
        bSaveMassDueToEnemyFirebaseOrOurExperimental = true
    else
        bSaveMassDueToEnemyFirebaseOrOurExperimental = M28Conditions.WantToEcoDueToEnemyFirebase(iTeam, tLZTeamData, iPlateau)
    end

    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Near start of code, time=' .. GetGameTimeSeconds() .. '; oFactory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; Checking if we have the highest tech land factory in the current land zone, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Highest friendly factory tech=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] .. '; Allied ground threat=' .. (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] or 'nil') .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]=' .. (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] or 'nil') .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat]=' .. (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] or 'nil') .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat]=' .. (M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] or 'nil') .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat]=' .. (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat] or 'nil') .. '; Is factory paused=' .. tostring(oFactory:IsPaused()) .. '; IsPaused value=' .. tostring(oFactory[M28UnitInfo.refbPaused]) .. '; Does LZ factory is in need BP=' .. tostring(tLZTeamData[M28Map.subrefTbWantBP]) .. '; Core LZ=' .. tostring(tLZTeamData[M28Map.subrefLZbCoreBase] or false) .. '; Core expansion=' .. tostring(tLZTeamData[M28Map.subrefLZCoreExpansion] or false) .. '; Time since a factory in this LZ last built something=' .. GetGameTimeSeconds() - (tLZTeamData[M28Map.refiTimeLastBuiltAtFactory] or -100) .. '; bHaveLowMass=' .. tostring(bHaveLowMass) .. '; bHaveLowPower=' .. tostring(bHaveLowPower))
    end

    iCategoryToBuild = M28UnitInfo.refCategoryEngineer --Placeholder
    local sBPIDToBuild
    local iCurrentConditionToTry = 0

    --subfunctions to mean we can do away with the 'current condition == 1, == 2.....==999 type approach making it much easier to add to
    function ConsiderBuildingCategory(iCategoryToBuild)
        sBPIDToBuild = GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oFactory, nil, nil, nil, nil, false)

        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Time=' .. GetGameTimeSeconds() .. ' Factory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; LZ=' .. iLandZone .. '; iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; sBPIDToBuild before adjusting for override=' .. (sBPIDToBuild or 'nil'))
        end
        if sBPIDToBuild then
            sBPIDToBuild = AdjustBlueprintForOverrides(aiBrain, sBPIDToBuild, tLZTeamData, iFactoryTechLevel)
        end
        if sBPIDToBuild then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd) --Assumes we will end code if we get to this point
            return sBPIDToBuild
        end
    end

    function ConsiderUpgrading()
        sBPIDToBuild = M28UnitInfo.GetUnitUpgradeBlueprint(oFactory, true)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return sBPIDToBuild
    end


    --MAIN BUILDER LOGIC:
    --Low power - only consider building engineers (if have lots of mass)
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': If low power then will only consider building engineers, bHaveLowPower=' .. tostring(bHaveLowPower))
    end
    if bHaveLowPower then
        M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] = M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]

        --Emergency gunship builder if have no gunships and nearby enemies, even if low power
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] >= 0.7 and iFactoryTechLevel >= 2 and tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
            local iOurGunshipThreat = 0
            local tiSubteamsConsidered = {}
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    if not (tiSubteamsConsidered[oBrain.M28AirSubteam]) then
                        tiSubteamsConsidered[oBrain.M28AirSubteam] = true
                        iOurGunshipThreat = iOurGunshipThreat + (M28Team.tAirSubteamData[oBrain.M28AirSubteam][M28Team.subrefiOurGunshipThreat] or 0)
                    end
                end
            end
            if iOurGunshipThreat == 0 then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryGunship) then
                    return sBPIDToBuild
                end
            end
        end

        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': AIr fac engi builder: bHaveLowMass=' .. tostring(bHaveLowMass) .. '; M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] .. '; subrefTbWantBP=' .. tostring(tLZTeamData[M28Map.subrefTbWantBP] or false))
        end
        if not (bHaveLowMass) and tLZTeamData[M28Map.subrefTbWantBP] then
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.25 and iFactoryTechLevel >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                    return sBPIDToBuild
                end
            end
        end
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Another engi builder - iFactoryTechLevel=' .. iFactoryTechLevel .. '; Highest friendly tech=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] .. '; Mass stored=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored])
        end
        if tLZTeamData[M28Map.subrefTbWantBP] and iFactoryTechLevel >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] then
            --Do we have fewer than 5 engineers of this tech level in this zone and we have some mass stored? if so then build another engineer (also build another engineer if we have fewer than 3 engineers even with low mass)
            local iEngisOfTechInZone = 0
            local tEngisOfTechInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel), tLZTeamData[M28Map.subrefLZTAlliedUnits])
            if M28Utilities.IsTableEmpty(tEngisOfTechInZone) == false then
                iEngisOfTechInZone = table.getn(tEngisOfTechInZone)
            end
            if iEngisOfTechInZone < 3 or (iEngisOfTechInZone < 5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 0) or (iEngisOfTechInZone < 10 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 1000) then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                    return sBPIDToBuild
                end
            end
        end
    else
        --Emergency air defence
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Emergency AA defence, tLZTeamData[M28Map.refiEnemyAirToGroundThreat]=' .. tLZTeamData[M28Map.refiEnemyAirToGroundThreat] .. '; tLZTeamData[M28Map.refiEnemyAirAAThreat]=' .. tLZTeamData[M28Map.refiEnemyAirAAThreat])
        end
        if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 or tLZTeamData[M28Map.refiEnemyAirAAThreat] > 0 then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirAA) then
                return sBPIDToBuild
            end
        end

        --Initial engineers
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Considering high priority engineers, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Team highest factory tech level=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] .. '; Lifetime build count=' .. M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) .. '; Current units=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)))
        end
        if iFactoryTechLevel >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] and tLZTeamData[M28Map.subrefLZbCoreBase] then
            if M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) <= 4 or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) <= 2 then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                    return sBPIDToBuild
                end
            end
        end

        --Overflowing mass (and dont have low power since are here)
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if not (bHaveLowMass) and tLZTeamData[M28Map.subrefTbWantBP] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.7 then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                return sBPIDToBuild
            end
        end

        --Nearby enemy air to ground threat
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                if tAdjLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Have adjacent land zone with air to ground threat=' .. tAdjLZTeamData[M28Map.refiEnemyAirToGroundThreat] .. '; will get airaa')
                    end
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirAA) then
                        return sBPIDToBuild
                    end
                    break
                end
            end
        end

        --Upgrade to T2 if at T1 air and have a certain level of mass and energy, and either cant path to enemy by land or it will take a while
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if iFactoryTechLevel == 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] <= 1 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 32 and aiBrain[M28Economy.refiGrossMassBaseIncome] >= 2 and not (M28Team.DoesBrainHaveActiveHQUpgradesOfCategory(aiBrain, M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryAirFactory)) and ((aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 45 and not (bHaveLowMass)) or not (aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) or M28Utilities.GetTravelDistanceBetweenPositions(oFactory:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase], M28Map.refPathingTypeLand) >= 375) then
            if ConsiderUpgrading() then
                return sBPIDToBuild
            end
        end

        --Nearby enemy ground (gunship)
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Will get gunship if have enemy ground threat in this LZ, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal])
        end
        if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryGunship) then
                return sBPIDToBuild
            end
        end

        --Adjacent LZs - gunship (enemy ground) or AirAA (enemy air)
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Considering adjacent land zone ' .. iAdjLZ .. '; Is table of enemy air untis empty=' .. tostring(M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftLZEnemyAirUnits])) .. '; tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal])
                end
                if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftLZEnemyAirUnits]) == false and not (M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl]) then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirAA) then
                        return sBPIDToBuild
                    end
                    break
                end
                if tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryGunship) then
                        return sBPIDToBuild
                    end
                end
            end
        end

        --early-game Transport (high priority)
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftTransportIslandDropShortlist]) == false and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryTransport) == 0 and ((iFactoryTechLevel <= 2 and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryTransport) <= 1) or (M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] and GetGameTimeSeconds() - (M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refiTimeLastTriedBuildingTransport] or -100) >= 180)) then
            M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refiTimeLastTriedBuildingTransport] = GetGameTimeSeconds()
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryTransport - categories.TECH3 - categories.EXPERIMENTAL) then
                return sBPIDToBuild
            end
        end

        --General production - depends on if we have highest tech level, or if we dont have t3 air yet
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Deciding next decisions based on how high a tech level we are, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Highest air factory tech=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech])
        end
        if iFactoryTechLevel < math.min(3, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 then
            --We dont want to build units in most cases as T3 versions are available

            --Consider upgrading if dont have active upgrade in this LZ
            --Upgrade factory if this LZ is lagging behind tech wise
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': is table of active upgrades for this LZ empty=' .. tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades])))
            end
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then
                local bUpgradingAirFactory = false
                for iUnit, oUnit in tLZTeamData[M28Map.subrefActiveUpgrades] do
                    if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oUnit.UnitId) and M28UnitInfo.GetUnitTechLevel(oUnit) >= iFactoryTechLevel then
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Have an active land factory upgrade=' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit.UnitId) .. '; Is unit valid=' .. tostring(M28UnitInfo.IsUnitValid(oUnit)) .. '; Fraction complete=' .. oUnit:GetFractionComplete() .. '; Work progress=' .. oUnit:GetWorkProgress())
                        end
                        bUpgradingAirFactory = true
                        break
                    end
                end

                if not (bUpgradingAirFactory) then
                    if ConsiderUpgrading() then
                        return sBPIDToBuild
                    end
                end
            end

            --Build engis if are very high mass
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Should we build engis due to high mass? bHaveLowMass=' .. tostring(bHaveLowMass) .. '; Highest % stored=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored])
            end
            if tLZTeamData[M28Map.subrefTbWantBP] and not (bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                    return sBPIDToBuild
                end
            end
        else
            --We have suitably high tech level to consider normal air production (and engineer production)
            --High mass - build more engineers
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': High mass engi builder: bHaveLowMass=' .. tostring(bHaveLowMass) .. '; Lowest mass % stored=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored])
            end
            if tLZTeamData[M28Map.subrefTbWantBP] and not (bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                    return sBPIDToBuild
                end
            end

            --Air scout if dont have any and havent built any at this factory
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirScout) == 0 and M28Conditions.GetFactoryLifetimeCount(oFactory, M28UnitInfo.refCategoryAirScout) == 0 then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirScout) then
                    return sBPIDToBuild
                end
            end

            --AirAA until have a minimum level
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            local iAirAASearchCategory
            if iFactoryTechLevel < 3 then
                iAirAASearchCategory = M28UnitInfo.refCategoryAirAA
            else
                iAirAASearchCategory = M28UnitInfo.refCategoryAirAA * categories.TECH3
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Minimum level of AirAA wanted: Number we have currently=' .. aiBrain:GetCurrentUnits(iAirAASearchCategory))
            end
            if aiBrain:GetCurrentUnits(iAirAASearchCategory) < 3 then
                if bDebugMessages == true then LOG(sFunctionRef..': We have fewer than 3 of AirAA search category, iFactoryTechLevel='..iFactoryTechLevel) end
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirAA) then
                    return sBPIDToBuild
                end
            end

            --Torpedo bombers if nearby navy
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Torp bomber for nearby enemy navy: iFactoryTechLevel=' .. iFactoryTechLevel .. '; Is table of adjacent WZ empty=' .. tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones])))
            end
            if iFactoryTechLevel >= 2 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                local iNearbyEnemyNavalThreat = 0
                local iAdjWZ
                for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                    iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                    local tAdjWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Considering iAdjWZ=' .. iAdjWZ .. '; tAdjWZTeamData[M28Map.subrefbWZOnlyHoverEnemies]=' .. tostring(tAdjWZTeamData[M28Map.subrefbWZOnlyHoverEnemies] or false) .. '; tAdjWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. tAdjWZTeamData[M28Map.subrefTThreatEnemyCombatTotal])
                    end
                    if not (tAdjWZTeamData[M28Map.subrefbWZOnlyHoverEnemies]) then
                        iNearbyEnemyNavalThreat = iNearbyEnemyNavalThreat + tAdjWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]
                    end
                end
                if iNearbyEnemyNavalThreat > 0 then
                    --Do we have enough torp bombers? want basic level ourselves, and then more for large threats
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Our torp bomber threat=' .. M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurTorpBomberThreat] .. '; iNearbyEnemyNavalThreat=' .. iNearbyEnemyNavalThreat)
                    end
                    if M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurTorpBomberThreat] < iNearbyEnemyNavalThreat * 1.5 then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryTorpBomber) then
                            return sBPIDToBuild
                        end
                    end
                end
            end

            --Gunship if dont have at least 3
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            local iCurGunships = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryGunship)
            if iCurGunships < 2 then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryGunship) then
                    return sBPIDToBuild
                end
            end

            --Air scout if dont have any
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirScout) == 0 then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirScout) then
                    return sBPIDToBuild
                end
            end

            --Do we lack enough torpedo bombers to target enemy navy?
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if iFactoryTechLevel >= 2 and (M28Team.tAirSubteamData[iAirSubteam][M28Team.refbNoAvailableTorpsForEnemies] or M28Team.tAirSubteamData[iAirSubteam][M28Team.refbTooMuchGroundNavalAAForTorpBombers]) then
                --Are we far behind on air?
                if M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir] then
                    if M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] > M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurTorpBomberThreat] then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryTorpBomber) then
                            return sBPIDToBuild
                        end
                    end
                else
                    --Not far behind on air so get more torps
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryTorpBomber) then
                        return sBPIDToBuild
                    end
                end
            end

            --AirAA in proportion to gunship threat (based on if far behind on air or not); if have air control then only get if dont have low mass
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            local iAirAAWanted = M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 100
            if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir] then
                iAirAAWanted = math.max(iAirAAWanted * 2, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] * 3 + math.max(0, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] - 4000) * 2)
            elseif not (M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl]) then
                iAirAAWanted = math.max(iAirAAWanted * 1.5, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] * 2 + math.max(0, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] - 4000) * 1.5)
            else
                --We have air control
                iAirAAWanted = math.max(iAirAAWanted, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] * 0.75 + math.max(0, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] - 4000) * 0.3)
            end
            if M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] < iAirAAWanted and (not (bHaveLowMass) or not (M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl])) then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirAA) then
                    return sBPIDToBuild
                end
            end

            --Gunships subject to mass and existing number
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if iCurGunships < 5 or (not (bHaveLowMass) and iCurGunships < 40 and (not(M28Map.bIsCampaignMap) or iCurGunships < 100) and (iCurGunships < 22 or (iFactoryTechLevel >= 3 and aiBrain[M28Economy.refiGrossMassBaseIncome] >= 20))) then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryGunship) then
                    return sBPIDToBuild
                end
            end

            --AirAA if far behind on air (lower priority since we are alreayd building in proportion to gunships above; i.e. dont want to get stuck only building airaa if have lost air control
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir] then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirAA) then
                    return sBPIDToBuild
                end
            end

            --Transport if locations to drop
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftTransportIslandDropShortlist]) == false and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryTransport) == 0 then
                if GetGameTimeSeconds() - (M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refiTimeLastTriedBuildingTransport] or -100) >= 120 then
                    M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refiTimeLastTriedBuildingTransport] = GetGameTimeSeconds()
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryTransport - categories.TECH3 - categories.EXPERIMENTAL) then
                        return sBPIDToBuild
                    end
                end
            end

            --AirAA if dont have low mass and lack air control and are at T3
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if not (bHaveLowMass) and not (M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl]) and iFactoryTechLevel >= 3 then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirAA) then
                    return sBPIDToBuild
                end
            end

            --T3 bomber if have high mass and are at T3 (incase e.g. the T2 gunship cap has bitten)
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if not (bHaveLowMass) and iFactoryTechLevel >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 5000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.75 then
                if tLZTeamData[M28Map.subrefTbWantBP] then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                        return sBPIDToBuild
                    end --redundancy
                end
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryBomber * categories.TECH3) then
                    return sBPIDToBuild
                end
            end
        end
    end
    if iFactoryTechLevel >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] then
        M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForAirFactory] = GetGameTimeSeconds()
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetBlueprintToBuildForNavalFactory(aiBrain, oFactory)
    local sFunctionRef = 'GetBlueprintToBuildForNavalFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCategoryToBuild
    local iWaterZone = M28Map.GetWaterZoneFromPosition(oFactory:GetPosition())
    local iPond = M28Map.tiPondByWaterZone[iWaterZone]
    local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
    local iTeam = aiBrain.M28Team
    local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
    local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
    local tiMAAThresholdByTech = { 50, 500, 1000, 1000 }

    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
    local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)

    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Near start of code, time=' .. GetGameTimeSeconds() .. '; oFactory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; Checking if we have the highest tech land factory in the current land zone, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Highest friendly factory tech=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech])
    end

    local bConsiderBuildingShieldOrStealthBoats = true
    --Shield boat needs 10 energy per tick; same for stealth boat; dont want this to account for more than 20% of gross energy; so want 50 gross energy per tick per shield boat for it to be <20%
    if bHaveLowPower or iFactoryTechLevel == 1 then
        bConsiderBuildingShieldOrStealthBoats = false
    else
        if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoShieldBoatTargetsByPond][iPond] or -100) <= 5 and EntityCategoryContains(categories.UEF, oFactory.UnitId) then
            bConsiderBuildingShieldOrStealthBoats = false
        else
            local iCurShieldAndStealthBoats = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryShieldBoat + M28UnitInfo.refCategoryStealthBoat)
            local iEnergyMod = 1
            if tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
                iEnergyMod = 2.5
            end
            if aiBrain[M28Economy.refiGrossEnergyBaseIncome] < (1 + iCurShieldAndStealthBoats) * 50 * iEnergyMod then
                bConsiderBuildingShieldOrStealthBoats = false
            elseif iCurShieldAndStealthBoats >= 5 then
                --Want to be a T3 factory and have at least 5 T3 naval units before building more shield boats
                bConsiderBuildingShieldOrStealthBoats = false
                if iFactoryTechLevel >= 3 and iCurShieldAndStealthBoats <= 22 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalSurface * categories.TECH3) >= 10 then
                    bConsiderBuildingShieldOrStealthBoats = true
                elseif iCurShieldAndStealthBoats <= 10 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalSurface * categories.TECH3 + M28UnitInfo.refCategoryDestroyer + M28UnitInfo.refCategoryCruiser) * 1.5 > iCurShieldAndStealthBoats then
                    bConsiderBuildingShieldOrStealthBoats = true
                end
            end
        end
    end
    local bUseFrigatesAsScouts = M28Team.tTeamData[iTeam][M28Team.subrefbUseFrigatesAsScoutsByPond][iPond]
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Finished checking if we want to consider building shield/stealth boats, bConsiderBuildingShieldOrStealthBoats=' .. tostring(bConsiderBuildingShieldOrStealthBoats) .. '; Cur shield and stealth boats=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryShieldBoat + M28UnitInfo.refCategoryStealthBoat) .. '; bHaveLowPower=' .. tostring(bHaveLowPower) .. '; Cur T3 navy and destroyer+cruiser=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalSurface * categories.TECH3 + M28UnitInfo.refCategoryDestroyer + M28UnitInfo.refCategoryCruiser))
    end

    iCategoryToBuild = M28UnitInfo.refCategoryEngineer --Placeholder
    local sBPIDToBuild
    local iCurrentConditionToTry = 0

    --subfunctions to mean we can do away with the 'current condition == 1, == 2.....==999 type approach making it much easier to add to
    function ConsiderBuildingCategory(iCategoryToBuild)
        sBPIDToBuild = GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oFactory, nil, nil, nil, nil, false)
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Time=' .. GetGameTimeSeconds() .. ' Factory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; WZ=' .. iWaterZone .. '; iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; sBPIDToBuild before adjusting for override=' .. (sBPIDToBuild or 'nil'))
        end
        if sBPIDToBuild then
            sBPIDToBuild = AdjustBlueprintForOverrides(aiBrain, sBPIDToBuild, tWZTeamData, iFactoryTechLevel)
        end
        if sBPIDToBuild then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd) --Assumes we will end code if we get to this point
            return sBPIDToBuild
        end
    end

    function ConsiderUpgrading()
        sBPIDToBuild = M28UnitInfo.GetUnitUpgradeBlueprint(oFactory, true)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return sBPIDToBuild
    end


    --MAIN BUILDER LOGIC:
    --Cycle through each naval zone and decide what units to get
    local iCombatCategory
    if iFactoryTechLevel <= 1 then
        iCombatCategory = M28UnitInfo.refCategoryFrigate
    elseif iFactoryTechLevel <= 2 then
        if math.random(0, 1) == 1 then
            iCombatCategory = M28UnitInfo.refCategoryFrigate
        else
            iCombatCategory = M28UnitInfo.refCategoryDestroyer
        end
    else
        --T3+
        local iCurDestroyerAndBattlecruiser = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryDestroyer + M28UnitInfo.refCategoryBattlecruiser)
        local iCurFrigates = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFrigate)
        local iCurBattleships = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryBattleship)
        if iCurFrigates == 0 or iCurFrigates <= iCurDestroyerAndBattlecruiser and not (aiBrain[M28Overseer.refbCloseToUnitCap]) then
            iCombatCategory = M28UnitInfo.refCategoryFrigate
        elseif iCurDestroyerAndBattlecruiser == 0 or iCurDestroyerAndBattlecruiser < iCurBattleships then
            iCombatCategory = M28UnitInfo.refCategoryDestroyer + M28UnitInfo.refCategoryBattlecruiser
        else
            iCombatCategory = M28UnitInfo.refCategoryBattleship
        end
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Finished getting combat category, iCurDestroyerAndBattlecruiser=' .. iCurDestroyerAndBattlecruiser .. '; iCurFrigates=' .. iCurFrigates .. '; iCurBattleships=' .. iCurBattleships)
        end
    end

    --High priority engineer if we started in water
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
        if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) < 3 or (iFactoryTechLevel <= 2 and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer) <= 10) then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Water start, will get high priority engineer')
            end
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                return sBPIDToBuild
            end
        end
    end

    --High priority anti-air if we have a battleship and no cruiser, or alternatively if we have 3 destroyers and no cruiser
    local iCurCruiserCarrier = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryCruiserCarrier)
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Checking if we want to get cruisers, iCurCruiserCarrier=' .. iCurCruiserCarrier)
    end
    if iCurCruiserCarrier == 0 and iFactoryTechLevel >= 2 and (
            aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryBattleship) + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryBattlecruiser) > 0
                    or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryDestroyer) >= 3) then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Will try get High priority cruiser')
        end
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryCruiser) then
            return sBPIDToBuild
        end
    end

    --First consider zone we are in
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering immediate needs for cur WZ that are in, tWZTeamData[M28Map.subrefWZThreatEnemySubmersible]=' .. tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] .. '; tWZTeamData[M28Map.subrefWZThreatEnemySurface]=' .. tWZTeamData[M28Map.subrefWZThreatEnemySurface] .. '; tWZTeamData[M28Map.refiEnemyAirToGroundThreat]=' .. tWZTeamData[M28Map.refiEnemyAirToGroundThreat] .. '; tWZTeamData[M28Map.refbWZWantsMobileShield]=' .. tostring(tWZTeamData[M28Map.refbWZWantsMobileShield]) .. '; tWZTeamData[M28Map.refbWZWantsMobileStealth]=' .. tostring(tWZTeamData[M28Map.refbWZWantsMobileStealth]))
    end
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] > 0 then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Immediate threat - want antinavy')
        end
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryAntiNavy - categories.SILO) then
            return sBPIDToBuild
        end
    end

    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if tWZTeamData[M28Map.subrefWZThreatEnemySurface] > 0 then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Immediate threat - want frigate')
        end
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryFrigate) then
            return sBPIDToBuild
        end --Want frigate as enemy is close
    end

    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
        if EntityCategoryContains(categories.AEON, oFactory.UnitId) or tWZTeamData[M28Map.refiEnemyAirToGroundThreat] >= math.max(100, (tWZTeamData[M28Map.subrefWZThreatAlliedAA] or 0) * 0.5) then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Immediate threat - want AA')
            end
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryNavalAA) then
                return sBPIDToBuild
            end
        else
            --Frigates should be a faster way of getting basic AA
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Immediate threat - want AA via frigate')
            end
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryFrigate) then
                return sBPIDToBuild
            end
        end
    end

    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bConsiderBuildingShieldOrStealthBoats and tWZTeamData[M28Map.refbWZWantsMobileShield] then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Want shielding for core WZ')
        end
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryShieldBoat) then
            return sBPIDToBuild
        end
    end

    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bConsiderBuildingShieldOrStealthBoats and tWZTeamData[M28Map.refbWZWantsMobileStealth] then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Want stealth for core WZ')
        end
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryStealthBoat) then
            return sBPIDToBuild
        end
    end

    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if iFactoryTechLevel == 2 then
        --Wnat first t2 unit to be a destroyer, assuming no immediate threats (per above)

        if M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryDestroyer) == 0 then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryDestroyer) then
                return sBPIDToBuild
            end
        end
    end

    --Have at least 1 of the current combat category unit
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Number of combat category units we have=' .. aiBrain:GetCurrentUnits(iCombatCategory))
    end
    if aiBrain:GetCurrentUnits(iCombatCategory) == 0 then
        if ConsiderBuildingCategory(iCombatCategory) then
            return sBPIDToBuild
        end
    end

    --Upgrade naval fac as priority if enemy has better navy tech than us or we ahve lots of naval units; also in high mass scenarios where we already have T3 navy
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; About ot check if want to upgrade factory, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Is table of active upgrades for WZ empty=' .. tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefActiveUpgrades])))
    end
    if iFactoryTechLevel < 3 then
        local iActiveFactoryUpgrades = 0
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefActiveUpgrades]) == false then
            for iUnit, oUnit in tWZTeamData[M28Map.subrefActiveUpgrades] do
                if EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oUnit.UnitId) then
                    iActiveFactoryUpgrades = iActiveFactoryUpgrades + 1
                end
            end
        end
        local bConsiderUpgrading = false
        if iActiveFactoryUpgrades == 0 then
            bConsiderUpgrading = true
        else
            local iFactoriesInWZ = 0
            local tFactoriesInWZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subrefLZTAlliedUnits])
            if M28Utilities.IsTableEmpty(tFactoriesInWZ) == false then
                iFactoriesInWZ = table.getn(tFactoriesInWZ)
            end
            if iActiveFactoryUpgrades < iFactoriesInWZ * 0.5 and not (bHaveLowMass) and not (bHaveLowPower) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.3 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 25) then
                bConsiderUpgrading = true
            end
        end
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': bConsiderUpgrading=' .. tostring(bConsiderUpgrading) .. '; iActiveFactoryUpgrades=' .. iActiveFactoryUpgrades .. '; Is table of activeu pgrades empty=' .. tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefActiveUpgrades])))
        end
        if bConsiderUpgrading then
            local iUpgradeThreatThreshold
            local iGrossMassThreshold
            if iFactoryTechLevel == 1 then
                iUpgradeThreatThreshold = 1000
                iGrossMassThreshold = 4
            else
                iUpgradeThreatThreshold = 6000
                iGrossMassThreshold = 10
            end
            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech] > iFactoryTechLevel then
                iUpgradeThreatThreshold = iUpgradeThreatThreshold * 0.75
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]=' .. tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] or false) .. '; tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]=' .. tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] .. '; iUpgradeThreatThreshold=' .. iUpgradeThreatThreshold)
            end
            if not (tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) or tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= iUpgradeThreatThreshold or aiBrain[M28Economy.refiGrossMassBaseIncome] >= 20 then
                --Do we have enough mass income to justify upgrading?
                if bHaveLowMass then
                    iGrossMassThreshold = iGrossMassThreshold * 1.25
                end
                --Lower threshold if enemy has better tech
                if M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech] then
                    iGrossMassThreshold = iGrossMassThreshold * 0.75
                end
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Gross mass income=' .. aiBrain[M28Economy.refiGrossMassBaseIncome] .. '; iGrossMassThreshold=' .. iGrossMassThreshold)
                end
                if aiBrain[M28Economy.refiGrossMassBaseIncome] >= iGrossMassThreshold then
                    if ConsiderUpgrading() then
                        return sBPIDToBuild
                    end
                else
                    --Lower threshold if we have built lots of T2 units

                    local iLifetimeBuildCount = M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryNavalSurface * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Lifetime build amount of naval units=' .. M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryNavalSurface * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)))
                    end
                    if iLifetimeBuildCount >= 14 then
                        iGrossMassThreshold = iGrossMassThreshold * math.max(0.35, (1 - iGrossMassThreshold * 0.02))
                        if aiBrain[M28Economy.refiGrossMassBaseIncome] >= iGrossMassThreshold then
                            if ConsiderUpgrading() then
                                return sBPIDToBuild
                            end
                        end
                    end
                end
            end
        end
    end

    --Medium priority engineer if no immediate threats in this zone, are in a water start position, and want more engineers due to having mass but not needing power
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Engi fi underwtaer start: tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]=' .. tostring(tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) .. '; tWZTeamData[M28Map.subrefTbWantBP]=' .. tostring(tWZTeamData[M28Map.subrefTbWantBP]) .. '; bHaveLowMass=' .. tostring(bHaveLowMass) .. '; aiBrain[M28Economy.refiGrossMassBaseIncome]=' .. aiBrain[M28Economy.refiGrossMassBaseIncome])
    end
    if tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
        if tWZTeamData[M28Map.subrefTbWantBP] and (not (bHaveLowMass) or (aiBrain[M28Economy.refiGrossMassBaseIncome] >= iFactoryTechLevel * 6)) then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                return sBPIDToBuild
            end
        end
    end

    --Cycle through each adjacent water zone
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': About to cycle through other land and water zones, is table empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefOtherLandAndWaterZonesByDistance])))
    end
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
        local iOtherWZ
        local iOtherPond

        local iOurCumulativeAAThreat = tWZTeamData[M28Map.subrefWZThreatAlliedAA]
        local iOurCumulativeCombatThreat = tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]
        local bHaveWantedAA = false

        for iEntry, tSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
            iOtherWZ = tSubtable[M28Map.subrefWZAWZRef]
            iOtherPond = M28Map.tiPondByWaterZone[iOtherWZ]
            local tOtherWZTeamData = M28Map.tPondDetails[iOtherPond][M28Map.subrefPondWaterZones][iOtherWZ][M28Map.subrefWZTeamData][iTeam]
            iOurCumulativeAAThreat = iOurCumulativeAAThreat + tOtherWZTeamData[M28Map.subrefWZThreatAlliedAA]
            iOurCumulativeCombatThreat = iOurCumulativeCombatThreat + tOtherWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Considering iOtherWZ=' .. (iOtherWZ or 'nil') .. '; tOtherWZTeamData[M28Map.subrefbWZWantsSupport]=' .. tostring(tOtherWZTeamData[M28Map.subrefbWZWantsSupport] or false) .. '; tOtherWZTeamData[M28Map.subrefWZThreatEnemySurface]=' .. (tOtherWZTeamData[M28Map.subrefWZThreatEnemySurface] or 'nil') .. '; tOtherWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]=' .. (tOtherWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 'nil') .. '; tOtherWZTeamData[M28Map.subrefWZMAAThreatWanted]=' .. (tOtherWZTeamData[M28Map.subrefWZMAAThreatWanted] or 'nil') .. '; tOtherWZTeamData[M28Map.refbWZWantsMobileShield]=' .. tostring(tOtherWZTeamData[M28Map.refbWZWantsMobileShield] or false) .. '; tOtherWZTeamData[M28Map.refbWZWantsMobileStealth]=' .. tostring(tOtherWZTeamData[M28Map.refbWZWantsMobileStealth] or false) .. '; tOtherWZTeamData[M28Map.refbWantLandScout]=' .. tostring(tOtherWZTeamData[M28Map.refbWantLandScout] or false) .. '; bUseFrigatesAsScouts=' .. tostring(bUseFrigatesAsScouts or false) .. '; tOtherWZTeamData[M28Map.refiEnemyAirToGroundThreat]=' .. (tOtherWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 'nil') .. '; tOtherWZTeamData[M28Map.subrefWZThreatAlliedAA]=' .. (tOtherWZTeamData[M28Map.subrefWZThreatAlliedAA] or 'nil') .. '; iOurCumulativeAAThreat=' .. iOurCumulativeAAThreat .. '; iOurCumulativeCombatThreat=' .. iOurCumulativeCombatThreat)
            end

            if tOtherWZTeamData[M28Map.subrefbWZWantsSupport] then
                if tOtherWZTeamData[M28Map.subrefWZThreatEnemySubmersible] > tOtherWZTeamData[M28Map.subrefWZThreatAlliedAntiNavy] * 0.75 then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Will try and get antinavy')
                    end
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryAntiNavy - categories.SILO) then
                        return sBPIDToBuild
                    end
                end
                if tOtherWZTeamData[M28Map.subrefWZThreatEnemySurface] > tOtherWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] * 0.75 then
                    --We want more combat, but first consider if we need more MAA
                    if bHaveWantedAA and iOurCumulativeCombatThreat > iOurCumulativeAAThreat * 1.5 then
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Will try and get AA')
                        end
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryNavalAA) then
                            return sBPIDToBuild
                        end
                    end
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Will try and get CombatCategory')
                    end
                    if ConsiderBuildingCategory(iCombatCategory) then
                        return sBPIDToBuild
                    end
                end
            end
            if not (bHaveWantedAA) and (tOtherWZTeamData[M28Map.subrefWZMAAThreatWanted] or 0) > tiMAAThresholdByTech[iFactoryTechLevel] and iOurCumulativeAAThreat < iOurCumulativeCombatThreat then
                bHaveWantedAA = true
            end

            if (tOtherWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) > 0 and (bHaveWantedAA or ((tOtherWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) > (tOtherWZTeamData[M28Map.subrefWZThreatAlliedAA] or 0) * 0.3)) then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Will try get AA')
                end
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryNavalAA) then
                    return sBPIDToBuild
                end
            end
            if bConsiderBuildingShieldOrStealthBoats and tOtherWZTeamData[M28Map.refbWZWantsMobileShield] then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Will try and get shield boat')
                end
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryShieldBoat) then
                    return sBPIDToBuild
                end
            end
            if bConsiderBuildingShieldOrStealthBoats and tOtherWZTeamData[M28Map.refbWZWantsMobileStealth] then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Will try and get stealth boat')
                end
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryStealthBoat) then
                    return sBPIDToBuild
                end
            end
            if bUseFrigatesAsScouts and tOtherWZTeamData[M28Map.refbWantLandScout] then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Will try and get frigate')
                end
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryFrigate) then
                    return sBPIDToBuild
                end
            end
        end
        if bHaveWantedAA and iOurCumulativeAAThreat < iOurCumulativeCombatThreat then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Will try and get AA')
            end
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryNavalAA) then
                return sBPIDToBuild
            end
        end
    end

    --Engis if high mass
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering engis due to having high mass, bHaveLowMass=' .. tostring(bHaveLowMass) .. '; tWZTeamData[M28Map.subrefTbWantBP]=' .. tostring(tWZTeamData[M28Map.subrefTbWantBP]))
    end
    if not (bHaveLowMass) and tWZTeamData[M28Map.subrefTbWantBP] then
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
            return sBPIDToBuild
        end
    end

    --Bombardment units
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    local bAboutToOverflowMass = false
    if not (bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.8 then
        bAboutToOverflowMass = true
    end
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Consdering building bombardment category unit, bHaveLowMass=' .. tostring(bHaveLowMass) .. '; Do we have UEF or seraphim factory=' .. tostring(EntityCategoryContains(categories.UEF + categories.SERAPHIM, oFactory.UnitId)))
    end
    if iFactoryTechLevel >= 3 then
        local iCurBattleships = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryBattleship)
        if bAboutToOverflowMass or (iCurBattleships < 5 or (not (bHaveLowMass) or iCurBattleships <= 1)) then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryBattleship) then
                return sBPIDToBuild
            end
        end
    elseif iFactoryTechLevel == 2 then

        if EntityCategoryContains(categories.UEF + categories.SERAPHIM, oFactory.UnitId) then
            local iCurCruisers = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryCruiser)
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': UEF T2 naval fac, iCurCruisers=' .. iCurCruisers .. '; bAboutToOverflowMass=' .. tostring(bAboutToOverflowMass or false))
            end
            if bAboutToOverflowMass or (iCurCruisers <= 10 and (not (bHaveLowMass) or iCurCruisers <= 4)) then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryCruiser) then
                    return sBPIDToBuild
                end
            end
        else
            local iCurDestroyers = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryDestroyer)
            if bAboutToOverflowMass or (iCurDestroyers <= 8 and (not (bHaveLowMass) or iCurDestroyers < 4)) then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryDestroyer) then
                    return sBPIDToBuild
                end
            end
        end
    else
        local iCurFrigates = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFrigate)
        if bAboutToOverflowMass or (iCurFrigates <= 30 and (not (bHaveLowMass) or iCurFrigates <= 10)) then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryFrigate) then
                return sBPIDToBuild
            end
        end
    end

    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Have no categories to build')
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateLastBuiltTracker(oFactory, sBlueprint)
    if not (oFactory[refiBuildCountByBlueprint]) then
        oFactory[refiBuildCountByBlueprint] = {}
    end
    oFactory[refiBuildCountByBlueprint][sBlueprint] = (oFactory[refiBuildCountByBlueprint][sBlueprint] or 0) + 1
    --facs - track when last built to reduce risk of power stalling by building at multiple all at once (air fac) or mass stalling with land facs

    local aiBrain = oFactory:GetAIBrain()
    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oFactory:GetPosition())
    local tLZOrWZTeamData
    local iTeam = aiBrain.M28Team
    if (iLandOrWaterZone or 0) > 0 then
        if iPlateauOrZero == 0 then
            tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
        else
            tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
        end
        tLZOrWZTeamData[M28Map.refiTimeLastBuiltAtFactory] = GetGameTimeSeconds()
    end

end

function GetBlueprintToBuildForQuantumGateway(aiBrain, oFactory)
    local sFunctionRef = 'GetBlueprintToBuildForQuantumGateway'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCategoryToBuild
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oFactory:GetPosition(), true, oFactory)
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
    local iTeam = aiBrain.M28Team
    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
    local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)
    local bCanPathToEnemyWithLand = false
    if tLZData[M28Map.subrefLZIslandRef] == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) then
        bCanPathToEnemyWithLand = true
    end
    local sBPIDToBuild
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Near start of code, time=' .. GetGameTimeSeconds() .. '; oFactory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; bHvaeLowPower=' .. tostring(bHaveLowPower))
    end
    local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory) --to be safe given we include it in adjustblueprintforoverrides
    local iCurrentConditionToTry = 0

    function ConsiderBuildingCategory(iCategoryToBuild, bOptionalGetCheapest)
        sBPIDToBuild = GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oFactory, nil, nil, bOptionalGetCheapest, nil, false)
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Time=' .. GetGameTimeSeconds() .. ' Factory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; LZ=' .. iLandZone .. '; iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; sBPIDToBuild before adjusting for override=' .. (sBPIDToBuild or 'nil'))
        end
        if sBPIDToBuild then
            sBPIDToBuild = AdjustBlueprintForOverrides(aiBrain, sBPIDToBuild, tLZTeamData, iFactoryTechLevel)
        end
        if sBPIDToBuild then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd) --Assumes we will end code if we get to this point
            return sBPIDToBuild
        end
    end

    --Build RAS SACUs (note - FAF has bug as of May 2023 where SACUs dont benefit from AiX modifier - have added code in M28 to counteract/fix
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if not (bHaveLowPower) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 750 then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Will try to build RAS SACU')
        end
        --[[if aiBrain.CheatEnabled and M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultipler] >= 3.5 then
            if ConsiderBuildingCategory(categories.SUBCOMMANDER, true) then
                return sBPIDToBuild
            end--]]
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryRASSACU) then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Foudn a RAS SACU blueprint to build=' .. (sBPIDToBuild or 'nil'))
            end
            return sBPIDToBuild
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end