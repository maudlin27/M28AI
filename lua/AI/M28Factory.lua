---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 22:33
---
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')

local reftBlueprintPriorityOverride = 'M28FactoryPreferredBlueprintByCategory' --[x] is the blueprint ref, if there's a priority override it returns a numerical value (higher number = higher priority)
local refiTimeSinceLastOrderCheck = 'M28FactoryTimeSinceLastCheck' --against factory, gametime in seconds when the factory was last checked to consider an order
local refiTimeSinceLastFailedToGetOrder = 'M28FactoryTimeFailedToGetOrder' --Against factory, gametimeseconds that factory failed to find anything to do
refbWantNextUnitToBeEngineer = 'M28FacNxtUEng' --true if want next unit to be an engineer
--NOTE: Also have a blueprint blacklist in the landsubteam data - see M28Team

--Factory types (used by subteams)
refiFactoryTypeLand = 1
refiFactoryTypeAir = 2
refiFactoryTypeNaval = 3
refiFactoryTypeOther = 4

--Variables against factory
refiBuildCountByBlueprint = 'M28FacBC' --against oFactory, returns table with key as the unitID, which returns the number of times the factory has been sent an order to build the unit
refiTotalBuildCount = 'M28FacTotBC' --against oFactory, Total number of units the factory has built
reftFactoryRallyPoint = 'M28FacRally' --against oFactory, Location to send units to when theyre built
refiFirstTimeOfLastOrder = 'M28FOrTim' --against oFactory, time that we gave an order for the factory to build a unit (cleared when a unit is built or a different blueprint order is given) - used to spot for factories with units blocking them

--Variables against brain
refiHighestFactoryBuildCount = 'M28FacBrTotBC' --against aiBrain, Highest build count of a factory

function GetMostExpensiveBlueprintOfCategory(iCategoryCondition)
    --Much more simplified version of 'GetBlueprintThatCanBuildOfCategory', for cases where we dont yet have the engineer so want a potential blueprint to work with
    local tBlueprints = EntityCategoryGetUnitList(iCategoryCondition)
    local iHighestMassCost = 0
    local tAllBlueprints = __blueprints
    local sMostExpensiveBlueprint
    local iCurMassCost
    for _, sBlueprint in tBlueprints do
        iCurMassCost = (tAllBlueprints[sBlueprint].Economy.BuildCostMass or 0)
        if iCurMassCost > iHighestMassCost then
            iHighestMassCost = iCurMassCost
            sMostExpensiveBlueprint = sBlueprint
        end
    end
    return sMostExpensiveBlueprint
end

function GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition, oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
    --returns nil if cant find any blueprints that can build
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBlueprintThatCanBuildOfCategory'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tBlueprints = EntityCategoryGetUnitList(iCategoryCondition)
    local tAllBlueprints = __blueprints
    local tValidBlueprints = {}
    local iValidBlueprints = 0
    local tBestBlueprints = {}
    local iBestBlueprints = 0
    local iHighestTech = 1
    local iCurrentTech = 1
    --if bGetSlowest == nil then bGetSlowest = false end
    --if bGetFastest == nil then bGetFastest = false end
    local iCurSpeed, iCurMass
    local tiLowestSpeedByTech = {1000, 1000, 1000}
    local tiLowestMassByTech = {100000000, 100000000, 100000000}
    local tiHighestSpeedByTech = {0,0,0}
    local oCurBlueprint
    local iHighestPriority = 0
    local bCanBuildRequiredCategory
    local iCategoriesThatBlueprintCanBuild
    local tsBlueprintsMeetingDesiredCategoriesToBuild
    if iOptionalCategoryThatMustBeAbleToBuild then
        tsBlueprintsMeetingDesiredCategoriesToBuild = EntityCategoryGetUnitList(iOptionalCategoryThatMustBeAbleToBuild)
        if bDebugMessages == true then LOG(sFunctionRef..': tsBlueprintsMeetingDesiredCategoriesToBuild='..repru(tsBlueprintsMeetingDesiredCategoriesToBuild)) end
    end





    if bDebugMessages == true then LOG(sFunctionRef..': reftBlueprintPriorityOverride='..repru(aiBrain[reftBlueprintPriorityOverride])) end
    if not(oFactory.CanBuild) then
        if oFactory.UnitId then
            M28Utilities.ErrorHandler('Factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..' doesnt have .canbuild')
        else
            M28Utilities.ErrorHandler('Factory has no UnitId and doesnt have .CanBuild')
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return nil
    else
        local Game = import("/lua/game.lua")
        local iArmyIndex = aiBrain:GetArmyIndex()
        for _, sBlueprint in tBlueprints do
            if bDebugMessages == true then LOG(sFunctionRef..': About to see if factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; can build blueprint '..sBlueprint..'; CanBuild='..tostring(oFactory:CanBuild(sBlueprint))) end
            if oFactory:CanBuild(sBlueprint) == true and not(Game.IsRestricted(sBlueprint, iArmyIndex)) then
                --Check we can build the desired category
                if not(iOptionalCategoryThatMustBeAbleToBuild) then bCanBuildRequiredCategory = true
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Have said we need to build a particualr category, will see if sBLueprint='..sBlueprint..' can build this') end
                    bCanBuildRequiredCategory = false
                    iCategoriesThatBlueprintCanBuild = nil
                    if tAllBlueprints[sBlueprint].Economy.BuildableCategory and not(M28Utilities.IsTableEmpty(tsBlueprintsMeetingDesiredCategoriesToBuild)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': sBlueprint has a buildablecategory set, will convert it into a category and see if it matches any of the blueprints we want to be able to build') end
                        for categoryIndex, category in tAllBlueprints[sBlueprint].Economy.BuildableCategory do
                            if categoryIndex == 1 then
                                iCategoriesThatBlueprintCanBuild = ParseEntityCategory(category)
                            else
                                iCategoriesThatBlueprintCanBuild = iCategoriesThatBlueprintCanBuild + ParseEntityCategory(category)
                            end
                        end

                        for iAltBlueprint, sAltBlueprint in tsBlueprintsMeetingDesiredCategoriesToBuild do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if sAltBlueprint='..(sAltBlueprint or 'nil')..' has a category that matches with what sBLueprint can build') end
                            if EntityCategoryContains(iCategoriesThatBlueprintCanBuild, sAltBlueprint) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Can build the desired category') end
                                bCanBuildRequiredCategory = true
                                break
                            end
                        end
                    end
                end

                if bCanBuildRequiredCategory then
                    --if EntityCategoryContains(iCategoryCondition, sBlueprint) then --tBlueprints is already filtered to just those that meet the categories
                    iValidBlueprints = iValidBlueprints + 1
                    tValidBlueprints[iValidBlueprints] = sBlueprint
                    if bIgnoreTechDifferences then iCurrentTech = 1
                    else
                        if EntityCategoryContains(categories.TECH3 + categories.EXPERIMENTAL, sBlueprint) then iCurrentTech = 3
                        elseif EntityCategoryContains(categories.TECH2, sBlueprint) then iCurrentTech = 2
                        else iCurrentTech = 1
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': '..sBlueprint..': iCurrentTech='..iCurrentTech..'; iHighestTech='..iHighestTech) end
                    if iCurrentTech > iHighestTech then
                        iHighestTech = iCurrentTech
                        iHighestPriority = 0
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if sBlueprint has a priority specified if we arent looking for slowest or fastest. sBlueprint='..sBlueprint..'; bGetSlowest='..tostring(bGetSlowest)..'; bGetFastest='..tostring(bGetFastest)..'; bGetCheapest='..tostring((bGetCheapest or false))) end
                    if not(bGetSlowest) and not(bGetFastest) and not(bGetCheapest) and aiBrain[reftBlueprintPriorityOverride][sBlueprint] then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have a priority specified='..aiBrain[reftBlueprintPriorityOverride][sBlueprint]..'; iHighestPriority='..iHighestPriority) end
                        iHighestPriority = math.max(aiBrain[reftBlueprintPriorityOverride][sBlueprint], iHighestPriority)
                    end
                    if bGetSlowest == true or bGetFastest == true then
                        oCurBlueprint = tAllBlueprints[sBlueprint]
                        iCurSpeed = oCurBlueprint.Physics.MaxSpeed
                        if bDebugMessages == true then LOG(sFunctionRef..': '..sBlueprint..': iCurSpeed='..iCurSpeed) end
                        if bGetSlowest == true then
                            if iCurSpeed < tiLowestSpeedByTech[iCurrentTech] then tiLowestSpeedByTech[iCurrentTech] = iCurSpeed end
                        elseif bGetFastest == true then
                            if iCurSpeed > tiHighestSpeedByTech[iCurrentTech] then tiHighestSpeedByTech[iCurrentTech] = iCurSpeed end
                        end
                    elseif bGetCheapest then
                        oCurBlueprint = tAllBlueprints[sBlueprint]
                        iCurMass = oCurBlueprint.Economy.BuildCostMass
                        if iCurMass < tiLowestMassByTech[iCurrentTech] then tiLowestMassByTech[iCurrentTech] = iCurMass end
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to get cheapest; iCurMass='..iCurMass..'; iCurrentTech='..iCurrentTech..'; tiLowestMassByTech[iCurrentTech]='..tiLowestMassByTech[iCurrentTech]) end
                    end
                    --end
                end
            end
        end
        --Now get a list of blueprints that are this tech level and of the highest priority
        --if bDebugMessages == true then LOG(sFunctionRef..': iHighestTech='..iHighestTech..'; tiHighestSpeedByTech='..tiHighestSpeedByTech[iHighestTech]..'; bGetSlowest='..tostring(bGetSlowest)..'; bGetFastest='..tostring(bGetFastest)) end
        local bIsValid, iCurrentPriority
        local iMinTechToUse = iHighestTech
        local iFastestSpeed = tiHighestSpeedByTech[iHighestTech]
        if bGetFastest == true and iHighestTech >= 3 then
            --If cybran, want loyalist instead of bomb; if Aeon want blaze instead of harbinger or shield disrupter; If sera probably want hover tank instead of siege tank; if UEF want titan
            if tiHighestSpeedByTech[3] <= 3.5 and tiHighestSpeedByTech[2] - tiHighestSpeedByTech[3] >= 0.6 then
                iMinTechToUse = 2
                iFastestSpeed = math.max(tiHighestSpeedByTech[3], tiHighestSpeedByTech[2])
            end
        end

        for _, sBlueprint in tValidBlueprints do
            bIsValid = false
            if EntityCategoryContains(categories.TECH3 + categories.EXPERIMENTAL, sBlueprint) then iCurrentTech = 3
            elseif EntityCategoryContains(categories.TECH2, sBlueprint) then iCurrentTech = 2
            else iCurrentTech = 1
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Cycling through each blueprint in valid blueprints, sBlueprint='..sBlueprint..': Considering whether we have high enough tech to consider, iCurrentTech='..iCurrentTech..'; iMinTechToUse='..iMinTechToUse) end
            if iCurrentTech >= iMinTechToUse then
                if not(bGetFastest) and not(bGetSlowest) and not(bGetCheapest) then iCurrentPriority = aiBrain[reftBlueprintPriorityOverride][sBlueprint] end
                if iCurrentPriority == nil then iCurrentPriority = 0 end
                if bDebugMessages == true then LOG(sFunctionRef..': sBlueprint='..sBlueprint..'; iCurrentTech='..iCurrentTech..'; considering priority, iCurrentPriority='..iCurrentPriority..'; iHighestPriority='..iHighestPriority) end
                if iCurrentPriority >= iHighestPriority then
                    bIsValid = true

                    if not(bGetSlowest) and not(bGetFastest) and not(bGetCheapest) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Not interested in if slowest or fastest or cheapest so marking BP as valid') end
                        bIsValid = true
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to get either the slowest, fastest or cheapest') end
                        bIsValid = false
                        if bGetSlowest or bGetFastest then
                            oCurBlueprint = tAllBlueprints[sBlueprint]
                            iCurSpeed = oCurBlueprint.Physics.MaxSpeed
                            if bDebugMessages == true then LOG(sFunctionRef..': sBlueprint='..sBlueprint..'; iCurSpeed='..iCurSpeed) end
                            if bGetSlowest == true then
                                if iCurSpeed <= tiLowestSpeedByTech[iHighestTech] then bIsValid = true end
                            elseif iCurSpeed >= iFastestSpeed then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have the highest speed for tech levels being considered') end
                                bIsValid = true
                            end
                        elseif bGetCheapest then
                            oCurBlueprint = tAllBlueprints[sBlueprint]
                            iCurMass = oCurBlueprint.Economy.BuildCostMass
                            if iCurMass <= tiLowestMassByTech[iCurrentTech] then bIsValid = true end
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to get cheapest; iCurMass='..iCurMass..'; iCurrentTech='..iCurrentTech..'; tiLowestMassByTech[iCurrentTech]='..tiLowestMassByTech[iCurrentTech]..'; bIsValid='..tostring(bIsValid)) end
                        else M28Utilities.ErrorHandler('Missing code')
                        end
                    end
                end
                if bIsValid == true then
                    iBestBlueprints = iBestBlueprints + 1
                    tBestBlueprints[iBestBlueprints] = sBlueprint
                    if bDebugMessages == true then LOG(sFunctionRef..': Have valid blueprint='..sBlueprint) end
                end
            end
        end

        local iBPToBuild = math.random(1, iBestBlueprints)
        if bDebugMessages == true then
            LOG(sFunctionRef..': End of code, iBestBlueprints='..iBestBlueprints..'; Will return random number if this is more than 1, tBestBlueprints[iBPToBuild]='..(tBestBlueprints[iBPToBuild] or 'nil'))
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return tBestBlueprints[iBPToBuild]
    end


end

function AdjustBlueprintForOverrides(aiBrain, oFactory, sBPIDToBuild, tLZTeamData, iFactoryTechLevel)
    --Blacklisted units (done on land subteam basis - in theory should work ok if use naval units or air units here as well)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AdjustBlueprintForOverrides'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subrefBlueprintBlacklist][sBPIDToBuild] then
        if bDebugMessages == true then LOG(sFunctionRef..': Unit is on blacklist so dont want to build') end
        sBPIDToBuild = nil
    else
        --Special case - Cybran and UEF - if building loyalists or titans, then check if want to switch to bricks/percies
        if sBPIDToBuild == 'url0303' then --Loyalist
            if M28Team.tTeamData[aiBrain.M28Team][M28Team.refbEnemyHasPerciesOrBricks] or M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat * categories.TECH3) >= 2 then
                if oFactory:CanBuild('xrl0305') then
                    aiBrain[reftBlueprintPriorityOverride]['url0303'] = nil --loyalist
                    aiBrain[reftBlueprintPriorityOverride]['xrl0305'] = 1 --brick
                    sBPIDToBuild = 'xrl0305'
                    if bDebugMessages == true then LOG(sFunctionRef..': Wnat to build brick instead of loyalist') end
                end
            end
        elseif sBPIDToBuild == 'uel0303' then --Titan
            if M28Team.tTeamData[aiBrain.M28Team][M28Team.refbEnemyHasPerciesOrBricks] or M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat * categories.TECH3) >= 15 then
                if oFactory:CanBuild('xel0305') then
                    aiBrain[reftBlueprintPriorityOverride]['url0303'] = nil --Titan
                    aiBrain[reftBlueprintPriorityOverride]['xel0305'] = 1 --Percival
                    sBPIDToBuild = 'xel0305'
                    if bDebugMessages == true then LOG(sFunctionRef..': want to build percival instead of titan') end
                end
            end
            --Aeon - build blazes instead of obsidians initially if dont have much power
        elseif sBPIDToBuild == 'ual0202' and (aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 95 or aiBrain:GetEconomyStoredRatio('ENERGY') < 0.95 or (oFactory[refiBuildCountByBlueprint]['xal0203'] or 0) < 2 ) then
            if oFactory:CanBuild('xal0203') then
                if bDebugMessages == true then LOG(sFunctionRef..': Switching to build blaze instead of obsidian') end
                sBPIDToBuild = 'xal0203'
            end
        end

        if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, sBPIDToBuild) then
            --Engineers - dont build if we have spare engineers at our current LZ
            local iMaxSpareWanted = 1
            if not(M28Conditions.TeamHasLowMass(aiBrain.M28Team)) then
                iMaxSpareWanted = math.max(2, 1 + math.floor((M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamLowestMassPercentStored] or 0) * 10)) * M28Engineer.tiBPByTech[iFactoryTechLevel]
            end
            if (tLZTeamData[M28Map.subrefSpareBPByTech][iFactoryTechLevel] or 0) > iMaxSpareWanted then
                if bDebugMessages == true then LOG(sFunctionRef..': Have sufficient spare engineers, iMaxSpareWanted='..iMaxSpareWanted) end
                sBPIDToBuild = nil
            end
            --Smaller maps - try and build engis in proportion to tanks at t1 stage
            if iFactoryTechLevel < 2 and sBPIDToBuild and M28Map.iMapSize <= 256 and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] then
                local iCurEngineers = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer)
                local iCurCombat = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandCombat)
                if iCurEngineers > math.max(10, iCurCombat) and aiBrain:GetEconomyStoredRatio('MASS') < 0.6 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Are at t1 stage so want to get more tanks if too bad a proportion, iCurEngineers='..iCurEngineers..'; iCurCombat='..iCurCombat) end
                    sBPIDToBuild = nil
                end
            end

            --Engineers - restrict tech level to the tech level that the LZ is flagged as wanting, unless we are trying to build an engineer of our highest tech level
            if bDebugMessages == true then
                LOG(sFunctionRef..': Were trying to build an engineer, will check if we want BP of this tech level or not, sBPIDToBuild='..(sBPIDToBuild or 'nil')..'; tLZTeamData[M28Map.subrefTbWantBP]='..tostring(tLZTeamData[M28Map.subrefTbWantBP] or false))
            end
            if sBPIDToBuild then --and (tLZTeamData[M28Map.subrefTbWantBP] or M28Map.bIsCampaignMap or M28Overseer.bUnitRestrictionsArePresent) then
                local iCurUnitTechLevel = M28UnitInfo.GetBlueprintTechLevel(sBPIDToBuild)
                if iCurUnitTechLevel < 3 then
                    local iLowestTechWanted
                    if not(tLZTeamData[M28Map.subrefTBuildPowerByTechWanted]) then
                        if not(tLZTeamData[M28Map.subrefTBuildPowerByTechWanted]) then
                            if GetGameTimeSeconds() >= 60 then M28Utilities.ErrorHandler('Dont have BP by tech set for zone containing factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)) end
                        else
                            for iTech, iBPWanted in tLZTeamData[M28Map.subrefTBuildPowerByTechWanted] do
                                if iBPWanted > 0 then
                                    iLowestTechWanted = iTech
                                    break
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iLowestTechWanted='..(iLowestTechWanted or 'nil')..'; iCurUnitTechLevel='..iCurUnitTechLevel) end
                        if (iLowestTechWanted or 1) > math.max(1, iCurUnitTechLevel) then
                            --Do we already have a number of units of this tech level?
                            if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iCurUnitTechLevel)) >= 5 then
                                sBPIDToBuild = nil
                                if bDebugMessages == true then LOG(sFunctionRef..': We already have 5 engineers of this tech level, and dont want more of this tech, iLowestTechWanted='..iLowestTechWanted..', iCurUnitTechLevel='..iCurUnitTechLevel) end
                            end
                        end
                    end
                end
            end

            --Cap total gunships to be active at any one time
        elseif EntityCategoryContains(M28UnitInfo.refCategoryGunship - categories.TECH3 - categories.EXPERIMENTAL, sBPIDToBuild) then
            if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryGunship) >= 80 and not(M28Map.bIsCampaignMap) then
                sBPIDToBuild = nil
                if bDebugMessages == true then LOG(sFunctionRef..': Already have 80 gunships so wont get more') end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': About to consider adjustment for factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..' for if close to unit cap, sBPIDToBuild='..(sBPIDToBuild or 'nil')..'; aiBrain[M28Overseer.refbCloseToUnitCap]='..tostring(aiBrain[M28Overseer.refbCloseToUnitCap] or false)) end
    if sBPIDToBuild and aiBrain[M28Overseer.refbCloseToUnitCap] then
        if aiBrain[M28Overseer.refiExpectedRemainingCap] <= 20 or (aiBrain[M28Overseer.refiExpectedRemainingCap] <= 50 and M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3 and EntityCategoryContains(categories.TECH1 + M28UnitInfo.refCategoryMobileLand * categories.TECH2, sBPIDToBuild)) or (aiBrain[M28Overseer.refiUnitCapCategoriesDestroyed] and EntityCategoryContains(aiBrain[M28Overseer.refiUnitCapCategoriesDestroyed], sBPIDToBuild)) then
            --Exception - build T2 engineers if we dont have many T3 engineers and have at least 10 leeway and havent been destroying these units
            if aiBrain[M28Overseer.refiExpectedRemainingCap] >= 20 and EntityCategoryContains(M28UnitInfo.refCategoryEngineer * categories.TECH2, sBPIDToBuild) and aiBrain[M28Overseer.refiExpectedRemainingCap] >= 25 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * categories.TECH3) <= 2 and (not(aiBrain[M28Overseer.refiUnitCapCategoriesDestroyed]) or not(EntityCategoryContains(aiBrain[M28Overseer.refiUnitCapCategoriesDestroyed], sBPIDToBuild))) then
                --Are trying to build a T2 engi and havent been destroying any yet, so still build it
                --i.e. do nothing
            elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer * categories.TECH3, sBPIDToBuild) and aiBrain[M28Overseer.refiExpectedRemainingCap] >= 5 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * categories.TECH3) <= 3 then
                --Do nothing - want some t3 engineers so can build t3 and experimental units
                --Another exception, more for campaign maps - if factory tech level is our highest tech level, and it isnt a destroyed unit category, then still build
            elseif iFactoryTechLevel >= M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyFactoryTech] and not(EntityCategoryContains(aiBrain[M28Overseer.refiUnitCapCategoriesDestroyed], sBPIDToBuild)) then
                --Do nothing - are at highest tech level for this factory and we havent destroyed any units of this type
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Close to unit cap so wont build more') end
                sBPIDToBuild = nil
            end
        end
        if sBPIDToBuild and M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] <= 1 and (aiBrain[M28Overseer.refiExpectedRemainingCap] < 40 or (aiBrain[M28Overseer.refiExpectedRemainingCap] < 70 and M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] == 0)) then
            --Dont build anything if already have lots of it
            if bDebugMessages == true then LOG(sFunctionRef..': Are close to unit cap, sBPIDToBuild after initial close to unit override='..(sBPIDToBuild or 'nil')..'; Current units owned of this already='..aiBrain:GetCurrentUnits(categories[sBPIDToBuild])) end
            local iCurUnitsOfCategory = aiBrain:GetCurrentUnits(categories[sBPIDToBuild])

            if iCurUnitsOfCategory >= 150 or (iCurUnitsOfCategory >= 50 and (aiBrain[M28Overseer.refiExpectedRemainingCap] or 0) <= 35 and (iCurUnitsOfCategory >= 100 or ((oFactory[refiTotalBuildCount] or 0) + iCurUnitsOfCategory >= 100 and EntityCategoryContains(categories.TECH1 + categories.TECH2, sBPIDToBuild)))) then
                sBPIDToBuild = nil
            end
        elseif sBPIDToBuild then
            if EntityCategoryContains(M28UnitInfo.refCategoryNavalSurface, sBPIDToBuild) then
                if aiBrain:GetCurrentUnits(categories[sBPIDToBuild]) >= 60 then
                    sBPIDToBuild = nil
                end
            elseif (M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] or 5) <= 1 then
                if not(EntityCategoryContains(M28UnitInfo.refCategoryGunship, sBPIDToBuild)) and aiBrain:GetCurrentUnits(categories[sBPIDToBuild]) >= 100 then
                    sBPIDToBuild = nil
                elseif EntityCategoryContains(M28UnitInfo.refCategoryGunship, sBPIDToBuild) and aiBrain:GetCurrentUnits(categories[sBPIDToBuild]) >= 150 then
                    sBPIDToBuild = nil
                end
            end
        end
        --Cap MAA levels
        if sBPIDToBuild and EntityCategoryContains(M28UnitInfo.refCategoryMAA - categories.TECH3, sBPIDToBuild) then
            local iMaxT1AndT2MAA = 200
            if M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl] then
                iMaxT1AndT2MAA = 100
            end
            if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMAA) >= iMaxT1AndT2MAA then
                --Ignore if enemy has air to ground threat in this zone
                if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] == 0 then
                    sBPIDToBuild = nil
                end
            end
        end
    end

    --NoRush
    if sBPIDToBuild and M28Overseer.bNoRushActive then
        if M28Overseer.iNoRushTimer - GetGameTimeSeconds() > 30 then
            if not(EntityCategoryContains(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryExperimentalLevel, sBPIDToBuild)) then
                sBPIDToBuild = nil
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return sBPIDToBuild
end

function GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iLandZone, iTargetLandZone, bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths, bDontGetCombat)
    local sFunctionRef = 'GetLandZoneSupportCategoryWanted'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iBaseCategoryWanted
    local tTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone]
    local tLZTargetTeamData = tTargetLZData[M28Map.subrefLZTeamData][iTeam]
    local bInSameIsland = false
    if NavUtils.GetLabel(M28Map.refPathingTypeLand, oFactory:GetPosition()) == NavUtils.GetLabel(M28Map.refPathingTypeLand, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefMidpoint]) then
        bInSameIsland = true
        --If this is a campaign map do further checks if this zone wants support (as dont want to be running such checks a huge amount)
        if M28Map.bIsCampaignMap and tLZTargetTeamData[M28Map.subrefbLZWantsSupport] and not(iLandZone == iTargetLandZone) then
            --Are we not at full playable area?
            if M28Map.rMapPlayableArea[1] > M28Map.rMapPotentialPlayableArea[2] or M28Map.rMapPlayableArea[2] > M28Map.rMapPotentialPlayableArea[2] or M28Map.rMapPlayableArea[3] < M28Map.rMapPotentialPlayableArea[3] or M28Map.rMapPlayableArea[4] < M28Map.rMapPotentialPlayableArea[4] then
                bInSameIsland = false
                local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                local iEntryNumber = tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]
                if iEntryNumber then
                    local tTravelPath = tLZData[M28Map.subrefLZPathingToOtherLandZones][iEntryNumber][M28Map.subrefLZPath]
                    if bDebugMessages == true then LOG(sFunctionRef..': tTravelPath='..repru(tTravelPath)) end
                    if M28Utilities.IsTableEmpty(tTravelPath) == false then
                        bInSameIsland = true
                        for iPath, iPathLZ in tTravelPath do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iPathLZ='..iPathLZ..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefMidpoint]))) end
                            if not(M28Conditions.IsLocationInPlayableArea(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefMidpoint])) then
                                if bDebugMessages == true then LOG(sFunctionRef..': iPathLZ is not in the playable area so want to treat same island as being false') end
                                bInSameIsland = false
                                break
                            end
                        end
                    end
                end
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateau '..iPlateau..'; iTargetLandZone='..iTargetLandZone..'; bInSameIsland='..tostring(bInSameIsland)..'; bDontConsiderBuildingMAA='..tostring(bDontConsiderBuildingMAA)..'; tLZTargetTeamData[M28Map.subrefbLZWantsIndirectSupport]='..tostring(tLZTargetTeamData[M28Map.subrefbLZWantsIndirectSupport])..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA]='..tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA]..'; subrefLZThreatAllyMAA='..tLZTargetTeamData[M28Map.subrefLZThreatAllyMAA]..'; tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]='..tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]..'; tLZTargetTeamData[M28Map.subrefbLZWantsSupport]='..tostring(tLZTargetTeamData[M28Map.subrefbLZWantsSupport])..'; LZ Air to ground enemy threat='..tLZTargetTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tLZTargetTeamData[M28Map.refbLZWantsMobileShield]='..tostring(tLZTargetTeamData[M28Map.refbLZWantsMobileShield])..'; tLZTargetTeamData[M28Map.refbLZWantsMobileStealth]='..tostring(tLZTargetTeamData[M28Map.refbLZWantsMobileStealth])..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]='..tostring(tLZTargetTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ])..'; bDontConsiderBuildingMAA='..tostring(bDontConsiderBuildingMAA or false)) end


    if (not(bDontGetCombat) and tLZTargetTeamData[M28Map.subrefbLZWantsIndirectSupport] and tLZTargetTeamData[M28Map.subrefbLZWantsSupport]) or GetGameTimeSeconds() - (tLZTargetTeamData[M28Map.subrefiTimeOfMMLFiringNearTMD] or -100) <= 10 then
        --First consider if we need MAA more urgently than indirect
        local bWantMAANotIndirect = false
        if not(bDontConsiderBuildingMAA) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 150 and tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA] < tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted] then
            --We want more MAA for this LZ as well as wanting more indirect fire; prioritise MAA based on threat ratio and if enemy has air to ground force
            local iMAARatioWanted = 8
            if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 25000 then iMAARatioWanted = 4 end
            if tLZTargetTeamData[M28Map.refiEnemyAirToGroundThreat] >= 200 then iMAARatioWanted = iMAARatioWanted * 0.5 end
            if tLZTargetTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] < tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA] * iMAARatioWanted then
                bWantMAANotIndirect = true
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': tLZTargetTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTargetTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]..'; bWantMAANotIndirect='..tostring(bWantMAANotIndirect)) end
        if bWantMAANotIndirect then
            if M28UnitInfo.GetUnitTechLevel(oFactory) == 3 and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA) >= 50 or (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] >= 2000 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.TECH3 * M28UnitInfo.refCategoryBomber, M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround])) == false) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 0 and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA - categories.TECH3) >  oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) * 4 then iBaseCategoryWanted = M28UnitInfo.refCategoryMAA
            else
                iBaseCategoryWanted = M28UnitInfo.refCategoryMAA - categories.TECH3
            end
            if not(bInSameIsland) then iBaseCategoryWanted = iBaseCategoryWanted * categories.AMPHIBIOUS + iBaseCategoryWanted * categories.HOVER end
            if bDebugMessages == true then LOG(sFunctionRef..': Will get MAA1') end
        else
            if bInSameIsland then
                iBaseCategoryWanted = M28UnitInfo.refCategoryIndirect
                if bDebugMessages == true then LOG(sFunctionRef..': Considering oFactory='..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; iTeam='..iTeam..'; iPlateau='..iPlateau..'; iTargetLandZone='..iTargetLandZone..'; We want indirect support for this LZ; Enemy structure threat by DF range='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatEnemyStructureDFByRange])..'; Total indirect threat wanted for LZ='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZIndirectThreatWanted]) end
            else
                --Only consider amphibious indirect (so most factions wont build anything)
                iBaseCategoryWanted = M28UnitInfo.refCategoryIndirect * categories.AMPHIBIOUS + M28UnitInfo.refCategoryIndirect * categories.HOVER
            end
            --If enemy has a firebase in range then cancel request for indirect
            if not(tLZTargetTeamData[M28Map.subrefLZbCoreBase]) and M28Utilities.IsTableEmpty(tLZTargetTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
                iBaseCategoryWanted = nil
                if bDebugMessages == true then LOG(sFunctionRef..': Are in range of a firebase so wont get indirect afterall') end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Will get Indirect') end
            end
        end
    end
    if not(iBaseCategoryWanted) then
        --We dont want indirect fire units, do we want MAA units?
        if bDebugMessages == true then LOG(sFunctionRef..': Dont want indirect fire, do we want MAA? M28Map.subrefLZThreatAllyGroundAA='..tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA]..'; M28Map.subrefLZMAAThreatWanted='..tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]..'; tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA]='..reprs(tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA])..'; tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]='..tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]) end
        if not(bDontConsiderBuildingMAA) and tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA] < tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted] and (M28UnitInfo.GetUnitTechLevel(oFactory) >= 2 or (M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoAllEnemyAir]) == false and (not(bDontConsiderBuildingMAA) or tLZTargetTeamData[M28Map.refiEnemyAirToGroundThreat] > 0))) then
            --Dont get MAA if no enemy air units in this zone or adjacent zone, and the existing MAA threat is more than 50% of any mobile DF +IF threat
            local bStillWantMAA = true
            if (tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted] or 0) < 30 and tLZTargetTeamData[M28Map.refiEnemyAirToGroundThreat] == 0 and (tLZTargetTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0) * 0.25 < (tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0) then
                bStillWantMAA = false
            elseif M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoAllEnemyAir]) then
                local bNoAdjAirThreat = true
                local iAdjDFAndIFThreat = (tTargetLZData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0) + (tTargetLZData[M28Map.subrefLZThreatAllyMobileIndirectTotal] or 0)
                local iAdjMAAThreat = (tTargetLZData[M28Map.subrefLZThreatAllyMAA] or 0)
                if M28Utilities.IsTableEmpty(tTargetLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tTargetLZData[M28Map.subrefLZAdjacentLandZones] do
                        local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                        if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZAdjacentLandZones]) == false then
                            bNoAdjAirThreat = false
                            break
                        else
                            iAdjDFAndIFThreat = iAdjDFAndIFThreat + (tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0) + (tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] or 0)
                            iAdjMAAThreat = iAdjMAAThreat + (tAdjLZTeamData[M28Map.subrefLZThreatAllyMAA] or 0)
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': bNoAdjAirThreat='..bNoAdjAirThreat..'; iAdjMAAThreat='..iAdjMAAThreat) end
                if bNoAdjAirThreat then
                    if iAdjMAAThreat >= 100 or EntityCategoryContains(categories.TECH1, oFactory.UnitId) then
                        local iMaxMAARatioWanted = 0.3
                        local iAirAAThreatWanted = M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 1.3
                        local iAirAAThreatHave = M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat]
                        if iAirAAThreatHave < iAirAAThreatWanted then
                            iMaxMAARatioWanted = math.min(1, iMaxMAARatioWanted * 3 * iAirAAThreatWanted / iAirAAThreatHave)
                        end
                        if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 1000 then iMaxMAARatioWanted = iMaxMAARatioWanted * 1.5 end
                        if iAdjMAAThreat * iMaxMAARatioWanted > iAdjDFAndIFThreat then
                            bStillWantMAA = false
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': bStillWantMAA='..tostring(bStillWantMAA)..'; iAirAAThreatHave='..iAirAAThreatHave..'; iAirAAThreatWanted='..iAirAAThreatWanted..'; iMaxMAARatioWanted='..iMaxMAARatioWanted..'; iAdjMAAThreat='..iAdjMAAThreat..'; iAdjDFAndIFThreat='..iAdjDFAndIFThreat) end
                    end
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': bStillWantMAA='..tostring(bStillWantMAA)..'; IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoAllEnemyAir])='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoAllEnemyAir]))) end

            if bStillWantMAA then
                if M28UnitInfo.GetUnitTechLevel(oFactory) == 3 and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA) >= 50 or (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] >= 2000 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.TECH3 * M28UnitInfo.refCategoryBomber, M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround])) == false) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 0 and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA - categories.TECH3) >  oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) * 4 then iBaseCategoryWanted = M28UnitInfo.refCategoryMAA
                else
                    iBaseCategoryWanted = M28UnitInfo.refCategoryMAA - categories.TECH3
                end
                if not(bInSameIsland) then iBaseCategoryWanted = iBaseCategoryWanted * categories.AMPHIBIOUS + iBaseCategoryWanted * categories.HOVER end
                if bDebugMessages == true then LOG(sFunctionRef..': Will build MAA2') end
            end
        end
        if not(iBaseCategoryWanted) then
            --Mobile shields
            if bConsiderMobileShields and tLZTargetTeamData[M28Map.refbLZWantsMobileShield] then
                iBaseCategoryWanted = M28UnitInfo.refCategoryMobileLandShield
                if bInSameIsland then iBaseCategoryWanted = M28UnitInfo.refCategoryMobileLandShield
                else iBaseCategoryWanted = iBaseCategoryWanted * categories.AMPHIBIOUS + iBaseCategoryWanted * categories.HOVER
                end
                if bDebugMessages == true then LOG(sFunctionRef..': LZ wants mobile stealths so will build them; blueprint expect to build from this='..(GetBlueprintThatCanBuildOfCategory(oFactory:GetAIBrain(), iBaseCategoryWanted, oFactory) or 'nil')) end
                --If dont have any blueprints to build then look to support indirect or DF instead
                local sBPIDToBuild = GetBlueprintThatCanBuildOfCategory(oFactory:GetAIBrain(), iBaseCategoryWanted, oFactory)
                if sBPIDToBuild then
                    sBPIDToBuild = AdjustBlueprintForOverrides(oFactory:GetAIBrain(), oFactory, sBPIDToBuild, tLZTargetTeamData, M28UnitInfo.GetUnitTechLevel(oFactory))
                end
                if not(sBPIDToBuild) then iBaseCategoryWanted = nil end
            end
            if not(iBaseCategoryWanted) then
                --Mobile stealth (unless enemy so close that combat units would be better)
                if bConsiderMobileStealths and tLZTargetTeamData[M28Map.refbLZWantsMobileStealth] and not(tLZTargetTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                    iBaseCategoryWanted = M28UnitInfo.refCategoryMobileLandStealth
                    if bInSameIsland then iBaseCategoryWanted = M28UnitInfo.refCategoryMobileLandStealth
                    else iBaseCategoryWanted = iBaseCategoryWanted * categories.AMPHIBIOUS + iBaseCategoryWanted * categories.HOVER
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': LZ wants mobile shilelds so will build them; blueprint expect to build from this='..(GetBlueprintThatCanBuildOfCategory(oFactory:GetAIBrain(), iBaseCategoryWanted, oFactory) or 'nil')) end
                    --If dont have any blueprints to build then look to support indirect or DF instead
                    local sBPIDToBuild = GetBlueprintThatCanBuildOfCategory(oFactory:GetAIBrain(), iBaseCategoryWanted, oFactory)
                    if sBPIDToBuild then
                        sBPIDToBuild = AdjustBlueprintForOverrides(oFactory:GetAIBrain(), oFactory, sBPIDToBuild, tLZTargetTeamData, M28UnitInfo.GetUnitTechLevel(oFactory))
                    end
                    if not(sBPIDToBuild) then iBaseCategoryWanted = nil end
                end
            end
        end
        if not(iBaseCategoryWanted) then
            if not(bDontGetCombat) and tLZTargetTeamData[M28Map.subrefbLZWantsSupport] then
                --We want DF units (but not indirect fire units)
                if bInSameIsland then
                    local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
                    local iTechCategory = M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)

                    iBaseCategoryWanted = M28UnitInfo.refCategorySkirmisher * iTechCategory
                    if not(tLZTargetTeamData[M28Map.subrefLZbCoreBase]) and M28Utilities.IsTableEmpty(tLZTargetTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
                        iBaseCategoryWanted = M28UnitInfo.refCategoryDFTank
                        if bDebugMessages == true then LOG(sFunctionRef..': Are in range of a firebase so wont get indirect afterall') end
                    elseif tLZTargetTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategorySkirmisher * iTechCategory) > math.min(2, oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryDFTank * iTechCategory)) then
                        iBaseCategoryWanted = M28UnitInfo.refCategoryDFTank
                        if bDebugMessages == true then LOG(sFunctionRef..': Enemies aren earby so want DF tanks more than skirmishers once we have a couple of skirmishers') end
                    end
                    if not(GetBlueprintThatCanBuildOfCategory(oFactory:GetAIBrain(), iBaseCategoryWanted, oFactory)) then
                        iBaseCategoryWanted = M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategorySkirmisher
                    else
                        --We can build skirmishers, but if we have built fewer than 15 T3 tanks, and enemy is using T2 and lower tech, consider building t3 tanks instead
                        if iFactoryTechLevel >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] <= 2 and M28Conditions.GetLifetimeBuildCount(oFactory:GetAIBrain(), M28UnitInfo.refCategoryDFTank * iTechCategory) <= 15 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy is still at T2 or lower and we havent built many T3 normal tanks so will build normal tanks first before trying to build skrimishers') end
                            iBaseCategoryWanted = M28UnitInfo.refCategoryDFTank
                        end
                    end

                else
                    iBaseCategoryWanted = M28UnitInfo.refCategoryAmphibiousCombat - categories.FIELDENGINEER
                end
            elseif bDebugMessages == true then LOG(sFunctionRef..': Dont want any support category for this LZ')
            end
            if not(iBaseCategoryWanted) and tLZTargetTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] then
                iBaseCategoryWanted = M28UnitInfo.refCategoryAmphibiousCombat - categories.FIELDENGINEER
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': is iBaseCategoryWanted nil='..tostring(iBaseCategoryWanted == nil)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBaseCategoryWanted
end

function GetBlueprintToBuildForLandFactory(aiBrain, oFactory)
    local sFunctionRef = 'GetBlueprintToBuildForLandFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iCategoryToBuild
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oFactory:GetPosition(), true, oFactory)
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
    local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
    local iTeam = aiBrain.M28Team
    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
    local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)
    local bCanPathToEnemyWithLand = false
    if tLZData[M28Map.subrefLZIslandRef] == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) then
        bCanPathToEnemyWithLand = true
    end



    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Near start of code, time=' .. GetGameTimeSeconds() .. '; oFactory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. ' at plateau '..(iPlateau or 'nil')..' and zone '..(iLandZone or 'nil')..'; Checking if we have the highest tech land factory in the current land zone, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Highest friendly factory tech=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] .. '; Allied ground MAA threat=' .. (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] or 'nil') .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]=' .. (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] or 'nil') .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat]=' .. (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] or 'nil') .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat]=' .. (M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] or 'nil') .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat]=' .. (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat] or 'nil') .. '; Is factory paused=' .. tostring(oFactory:IsPaused()) .. '; IsPaused value=' .. tostring(oFactory[M28UnitInfo.refbPaused]) .. '; Does LZ factory is in need BP=' .. tostring(tLZTeamData[M28Map.subrefTbWantBP]) .. '; Core LZ=' .. tostring(tLZTeamData[M28Map.subrefLZbCoreBase] or false) .. '; Core expansion=' .. tostring(tLZTeamData[M28Map.subrefLZCoreExpansion] or false))
    end

    local iLandFactoriesInLZ = 0
    local bHaveHighestLZTech = true
    --if iFactoryTechLevel < 3 and iFactoryTechLevel < M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] then
    local tLandFactoriesInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
    for iLZFactory, oLZFactory in tLandFactoriesInLZ do
        if not (oLZFactory == oFactory) and oLZFactory:GetFractionComplete() == 1 and M28UnitInfo.GetUnitTechLevel(oLZFactory) > iFactoryTechLevel then
            bHaveHighestLZTech = false
            break
        end
    end
    iLandFactoriesInLZ = table.getn(tLandFactoriesInLZ)
    --end

    local bDontConsiderBuildingMAA = false
    --Do we already ahve lots of MAA?
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering if we want to ignore getting any MAA, tLZTeamData[M28Map.refiEnemyAirToGroundThreat]=' .. tLZTeamData[M28Map.refiEnemyAirToGroundThreat] .. '; Time since last had no MAA targets for this island=' .. GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoMAATargetsByIsland][tLZData[M28Map.subrefLZIslandRef]] or -10) .. '; tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]=' .. tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]))
    end
    local iMinMAARatioFactor = 10
    if iFactoryTechLevel == 1 then iMinMAARatioFactor = 20 end

    if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] * iMinMAARatioFactor > M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] then
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] <= 1 and (iFactoryTechLevel == 1 or (bHaveLowMass and M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] > M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat])) and ((GetGameTimeSeconds() <= 600 and M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] * 5 > M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]) or M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] * 2 > M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat])) then
            if bDebugMessages == true then LOG(sFunctionRef..': Have enemies here or adjacent LZ or have enough MAA for enemy air ot ground threat') end
            bDontConsiderBuildingMAA = true
        elseif GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoMAATargetsByIsland][tLZData[M28Map.subrefLZIslandRef]] or -100) < 10 then
            if not (tLZTeamData[M28Map.subrefLZCoreExpansion]) then
                if bDebugMessages == true then LOG(sFunctionRef..': Not a core expansion so dont want more MAA as we havent had MAA targets recently') end
                bDontConsiderBuildingMAA = true
            else
                local iMAAInLZ = 0
                local iEnemyAirToGround = 0
                for iEntry, iIslandLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][tLZData[M28Map.subrefLZIslandRef]] do
                    iMAAInLZ = iMAAInLZ + tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZThreatAllyMAA]
                    iEnemyAirToGround = iEnemyAirToGround + tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.refiEnemyAirToGroundThreat]
                end
                if iMAAInLZ >= 300 and iMAAInLZ >= iEnemyAirToGround * 2 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have more air to ground threat than needed so wont get more') end
                    bDontConsiderBuildingMAA = true
                end
            end
            if not (bDontConsiderBuildingMAA) and tLZTeamData[M28Map.subrefLZThreatAllyMAA] - tLZTeamData[M28Map.subrefLZMAAThreatWanted] >= 4000 then
                if bDebugMessages == true then LOG(sFunctionRef..': already have large mAA threat so dont want more') end
                bDontConsiderBuildingMAA = true
            end
        end
        if not (bDontConsiderBuildingMAA) and ((M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] >= math.min(600 or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 2)) and (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] >= M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] + (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] + M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat]) * 0.2) or (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] > math.max(4000, M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] <= 4000 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) >= 5)) then
            --Do we have more than 1/6 of our DF and indirect force in AA and enemy air to ground threat is <4k? Or alternatively enemy has no air to ground and we have a lot of AA
            local iMAAFactor = 6
            if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] <= 1 then
                iMAAFactor = 12
            elseif M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 10000 then
                iMAAFactor = 4
            end
            if M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] < M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] * iMAAFactor then
                if not (tLZTeamData[M28Map.subrefLZCoreExpansion]) then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': We have lots of MAA; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] .. '; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] .. '; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] .. '; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]=' .. M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat])
                    end
                    bDontConsiderBuildingMAA = true
                else
                    local iMAAInLZ = 0
                    local iEnemyAirToGround = 0
                    for iEntry, iIslandLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][tLZData[M28Map.subrefLZIslandRef]] do
                        iMAAInLZ = iMAAInLZ + tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZThreatAllyMAA]
                        iEnemyAirToGround = iEnemyAirToGround + tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.refiEnemyAirToGroundThreat]
                    end
                    if iMAAInLZ >= 300 and iMAAInLZ >= iEnemyAirToGround * 2 then
                        bDontConsiderBuildingMAA = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Have some MAA in LZ and more than twice neemy air to ground so dont want more MAA') end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': bDontConsiderBuildingMAA after considering global values=' .. tostring(bDontConsiderBuildingMAA) .. '; GroundAA threat=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] .. '; Enemy air to ground threat=' .. M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] .. '; Enemy AirAA threat=' .. M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] .. '; Enemy torp bomber threat=' .. M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] .. '; Air other threat=' .. M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat] .. '; Current T3 MAA=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) .. '; Allied DF threat=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] .. '; Allied indirect=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat])
    end
    if not (bDontConsiderBuildingMAA) then
        --If factory is at T1 and we have lots of T1 MAA then dont get more MAA assuming no enemy air threat in this zone
        if iFactoryTechLevel == 1 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) then
            local iCurT1MAA =  aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMAA)
            if iCurT1MAA >= 80 or (aiBrain[M28Economy.refiOurHighestLandFactoryTech] > 1 and iCurT1MAA >= 20 and (tLZTeamData[M28Map.subrefLZbCoreBase] or iCurT1MAA >= 50 or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory - categories.TECH1, tLZTeamData[M28Map.subrefLZTAlliedUnits])) == false)) then
                bDontConsiderBuildingMAA = true
                if bDebugMessages == true then LOG(sFunctionRef..': T1 factory and have enough MAA threat so dont want more') end
            end
        end

        --If enemy has low air to ground threat relative to their combat threat then dont get more mAA if we already have half the factories building MAA
        if not(bDontConsiderBuildingMAA) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] < math.max(200, M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] * 0.4) then
            local bCapMAABuiltAtOnce = true
            if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 0 then
                --Check we dont have air to ground enemy threat in a nearby LZ
                if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                    bCapMAABuiltAtOnce = false
                elseif M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.refiEnemyAirToGroundThreat] > 0 then
                            bCapMAABuiltAtOnce = false
                            break
                        end
                    end
                end
            end
            if bCapMAABuiltAtOnce then
                if M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryMAA) >= math.max(1, math.floor(iLandFactoriesInLZ * 0.5)) then
                    bDontConsiderBuildingMAA = true
                end
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': bCapMAABuiltAtOnce=' .. tostring(bCapMAABuiltAtOnce) .. '; Number of MAA already being built=' .. M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryMAA) .. '; bDontConsiderBuildingMAA=' .. tostring(bDontConsiderBuildingMAA))
            end
        end
    end

    --Mobile shields if we are at T2+ as part of the land zone reinforcement logic
    local bConsiderMobileShields = false
    if iFactoryTechLevel >= 2 and not (bHaveLowPower) and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoShieldTargetsByPlateau][iPlateau] or -100) >= 15 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 15 * iFactoryTechLevel and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 70 then
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 60 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= (1 + M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryMobileLandShield)) * 16 then
            local iCurMobileShields = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMobileLandShield)
            if iCurMobileShields <= 35 and (iCurMobileShields * 250 <= math.max(2000, (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat]))) then
                bConsiderMobileShields = true
            end
        end
    end

    --Mobile stealth if we are at T2+ as part of the land zone reinforcement logic
    local bConsiderMobileStealths = false
    if iFactoryTechLevel >= 2 and not (bHaveLowPower) and not (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbEnemyHasOmni]) and not (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbEnemyBuiltOmni]) and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoStealthTargetsByPlateau][iPlateau] or -100) >= 15 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 15 * iFactoryTechLevel and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 70 then
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 60 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= (1 + M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryMobileLandStealth)) * 16 then
            local iCurMobileStealths = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMobileLandStealth)
            if iCurMobileStealths <= 16 and iCurMobileStealths * 600 <= math.max(1800, (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat]) * 0.3) then
                bConsiderMobileStealths = true
            end
        end
    end

    local bSaveMassDueToEnemyFirebaseOrOurExperimental
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]) == false and bHaveLowMass then
        bSaveMassDueToEnemyFirebaseOrOurExperimental = true
    else
        bSaveMassDueToEnemyFirebaseOrOurExperimental = M28Conditions.WantToEcoDueToEnemyFirebase(iTeam, tLZTeamData, iPlateau)
    end

    iCategoryToBuild = M28UnitInfo.refCategoryEngineer --Placeholder
    local sBPIDToBuild
    local iCurrentConditionToTry = 0

    --subfunctions to mean we can do away with the 'current condition == 1, == 2.....==999 type approach making it much easier to add to
    function ConsiderBuildingCategory(iCategoryToBuild)
        sBPIDToBuild = GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oFactory, nil, nil, nil, nil, false)
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Time=' .. GetGameTimeSeconds() .. ' Factory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; LZ=' .. iLandZone .. '; iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; sBPIDToBuild before adjusting for override=' .. (sBPIDToBuild or 'nil'))
        end
        if sBPIDToBuild then
            sBPIDToBuild = AdjustBlueprintForOverrides(aiBrain, oFactory, sBPIDToBuild, tLZTeamData, iFactoryTechLevel)
        end
        if sBPIDToBuild then
            if bDebugMessages == true then LOG(sFunctionRef..': After adjusting for overrides still have blueprint to build='..sBPIDToBuild) end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd) --Assumes we will end code if we get to this point
            return sBPIDToBuild
        elseif bDebugMessages == true then LOG(sFunctionRef..': Dont have a blueprint to build')
        end
    end

    function ConsiderUpgrading()
        --If this is a support factory or T1 factory then only consider upgrading if we have spare idle factories in this LZ, subject to how many factories we have
        local bConsiderUpgrading = true
        if iFactoryTechLevel == 1 or not(EntityCategoryContains(M28UnitInfo.refCategoryLandHQ, oFactory.UnitId)) then

            local iUpgradingLandFactories = 0
            local iAvailableLandFactories = 0
            local tLandFactoriesInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
            if M28Utilities.IsTableEmpty(tLandFactoriesInLZ) == false then
                for iFactory, oFactory in tLandFactoriesInLZ do
                    if oFactory:GetFractionComplete() == 1 then
                        if oFactory:IsUnitState('Upgrading') then
                            iUpgradingLandFactories = iUpgradingLandFactories + 1
                        else
                            iAvailableLandFactories = iAvailableLandFactories + 1
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iUpgradingLandFactories='..iUpgradingLandFactories..'; iAvailableLandFactories='..iAvailableLandFactories..'; iFactoryTechLevel='..iFactoryTechLevel..'; iOurHighestLandFactoryTech='..aiBrain[M28Economy.refiOurHighestLandFactoryTech]) end
                if iUpgradingLandFactories > 0 then
                    if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and iFactoryTechLevel < aiBrain[M28Economy.refiOurHighestLandFactoryTech] then
                        bConsiderUpgrading = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Dont want to upgrade as there are nearby enemies') end
                    elseif iAvailableLandFactories <= 3 and iUpgradingLandFactories + 1 >= iAvailableLandFactories then
                        bConsiderUpgrading = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Dont want to upgrade as dont have many available land factories remaining') end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bConsiderUpgrading='..tostring(bConsiderUpgrading)) end
        if bConsiderUpgrading then
            sBPIDToBuild = M28UnitInfo.GetUnitUpgradeBlueprint(oFactory, true)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return sBPIDToBuild
        end
    end



    --MAIN BUILDER LOGIC:
    --Enemy early bomber defence (higher priority than tanks since we have our ACU to deal with tanks as a last resort)
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; About to check if we want to build high priority MAA, bDontConsiderBuildingMAA=' .. tostring(bDontConsiderBuildingMAA) .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]=' .. M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat])
    end
    if not (bDontConsiderBuildingMAA) then
        local iNearbyMAAThreat = tLZTeamData[M28Map.subrefLZThreatAllyMAA]
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                iNearbyMAAThreat = iNearbyMAAThreat + tAdjLZTeamData[M28Map.subrefLZThreatAllyMAA]
            end
        end
        if iNearbyMAAThreat < 165 or (tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0) then
            --If enemy has any air units then want at least 110 MAA; if they have any air to ground want at least 165; if air to ground threat for this LZ then want
            if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 0 or (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat] + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] > 0 and iNearbyMAAThreat < 110) then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Want to have a basic level of MAA unless we have lots already; MAA that we alreayd have=' .. oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA))
                end
                if oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA) <= 5 or (tLZTeamData[M28Map.refiEnemyAirToGroundThreat] * 4 > math.min(1000, iNearbyMAAThreat)) then
                    --Only build if we ahve <2 under construction in this LZ
                    if M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryMAA) < 2 then
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Will try and get MAA to combat enemy air to ground threat')
                        end
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryMAA - categories.TECH3) then
                            return sBPIDToBuild
                        end
                    end
                end
            end
        end
    end

    --Engineers for transport - build engineers as high priority if no enemies in this zone
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers]) == false and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) then
        if bDebugMessages == true then LOG(sFunctionRef..': Want engineers as have transport waiting for them') end
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end
    end

    --Core expansions - build 1 tank if havent already (t1 facs only)
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if tLZTeamData[M28Map.subrefLZCoreExpansion] and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedCombatUnits]) and iFactoryTechLevel == 1 then
        if M28Conditions.GetFactoryLifetimeCount(oFactory, M28UnitInfo.refCategoryLandCombat) == 0 then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Core expansion - have no land combat so will try to get some')
            end
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandCombat) then
                return sBPIDToBuild
            end
        elseif M28Conditions.GetFactoryLifetimeCount(oFactory, M28UnitInfo.refCategoryLandScout) == 0 then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Core expansion - have no land scout so will try to get some')
            end
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandScout) then
                return sBPIDToBuild
            end
        end
    end

    --First engineer of cur tech level
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if iFactoryTechLevel >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] and tLZTeamData[M28Map.subrefLZbCoreBase] then
        local iMinEngisWanted --lifetime count; or half this for active current number
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
            iMinEngisWanted = 1
        else
            iMinEngisWanted = 2
        end
        if M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) < iMinEngisWanted then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                return sBPIDToBuild
            end
        end
    end

    --T1 factory that has built loads of units or is in a location for fortifying (with access to T2 tech already) - consider upgrading
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if want to upgrade T1 factory to T2 due to having built lots of units, enemies in this zone empty='..tostring( M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))..'; Tech level='..iFactoryTechLevel..'; M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]))..'; Lifetime count='..M28Conditions.GetFactoryLifetimeCount(oFactory, nil, true)) end
    if iFactoryTechLevel == 1 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) and not(M28Conditions.HaveLowPower(iTeam)) then
        local iLifetimeCountWanted = 35
        if not(bHaveLowMass) then
            iLifetimeCountWanted = iLifetimeCountWanted - 8
            if aiBrain[M28Economy.refiGrossMassBaseIncome] >= 7 then iLifetimeCountWanted = iLifetimeCountWanted - 7 end
        end
        if M28Map.bIsCampaignMap then iLifetimeCountWanted = iLifetimeCountWanted - 16
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 2 and aiBrain[M28Economy.refiGrossMassBaseIncome] >= 3 then iLifetimeCountWanted = iLifetimeCountWanted - 9
        end
        if iLifetimeCountWanted <= 5 then iLifetimeCountWanted = 5 end
        --Increase lifetime count if our highest factory tech level is 1 and we dont have many other land or air factories
        if iLifetimeCountWanted < 15 and aiBrain[M28Economy.refiOurHighestLandFactoryTech] == 1 and tLZTeamData[M28Map.subrefTbWantBP] and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory) < 4 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer) < 8 then
            iLifetimeCountWanted = math.min(15, iLifetimeCountWanted + 5)
        end
        if tLZTeamData[M28Map.subrefLZFortify] and aiBrain[M28Economy.refiOurHighestLandFactoryTech] >= 2 then iLifetimeCountWanted = 2 end
        if bDebugMessages == true then LOG(sFunctionRef..': iLifetimeCountWanted='..iLifetimeCountWanted..'; actual count='..M28Conditions.GetFactoryLifetimeCount(oFactory, nil, true)) end
        if M28Conditions.GetFactoryLifetimeCount(oFactory, nil, true) >= iLifetimeCountWanted then

            if ConsiderUpgrading() then  return sBPIDToBuild end
        end
    end

    --Enemy nearby ACU and PD or T2 arti nearby, with no enemies in this actual LZ - get indirect fire as last resort, or mobile shields if we have 10+ indirect fire units and have t2 arti here that wants shielding
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if iFactoryTechLevel >= 2 and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] == 0 then
        local iApproachingACU, tNearestACU = M28Conditions.GetThreatOfApproachingEnemyACUsAndNearestACU(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Emergency indirect builder: iApproachingACU threat=' .. iApproachingACU .. '; Dist to it=' .. M28Utilities.GetDistanceBetweenPositions((tNearestACU or oFactory:GetPosition()), oFactory:GetPosition()) .. '; Cur indirect=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryIndirect) .. '; Lifetime indirect=' .. M28Conditions.GetFactoryLifetimeCount(oFactory, M28UnitInfo.refCategoryIndirect) .. '; Is table of nearby enemy dangerous buildings empty=' .. tostring(M28Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryT2PlusPD + M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryTMD, oFactory:GetPosition(), 175, 'Enemy'))))
        end
        local bWantIndirectSubjectToNumbers = false
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then bWantIndirectSubjectToNumbers = true
        elseif iApproachingACU <= 400 and tNearestACU and M28Utilities.GetDistanceBetweenPositions(tNearestACU, oFactory:GetPosition()) <= 175 then
            --Does enemy have any T2+ buildings?
            local tNearbyEnemyT2Plus = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryT2PlusPD + M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryTMD, oFactory:GetPosition(), 175, 'Enemy')
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby enemy T2Plus units empty='..tostring(M28Utilities.IsTableEmpty(tNearbyEnemyT2Plus))) end
            if M28Utilities.IsTableEmpty(tNearbyEnemyT2Plus) == false then
                bWantIndirectSubjectToNumbers = true
            end
        end



        --search adjacent zones to see if they need more mml
        if bDebugMessages == true then LOG(sFunctionRef..': Time since MML fired near TMD in this zone='..GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMD] or -100)..'; Factory total build count='..oFactory[refiTotalBuildCount]) end
        if not(bWantIndirectSubjectToNumbers) then
            if GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMD] or -100) <= 20 then bWantIndirectSubjectToNumbers = true
            elseif oFactory[refiTotalBuildCount] < 30 then --at higher build count numbers greater risk we are just sending mml to die and will never win
                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                    local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Time since MML fired near TMD in adj zone '..iAdjLZ..'='..GetGameTimeSeconds() - (tAdjLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMD] or -100)) end
                    if GetGameTimeSeconds() - (tAdjLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMD] or -100) <= 10 then
                        bWantIndirectSubjectToNumbers = true
                        break
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bWantIndirectSubjectToNumbers='..tostring(bWantIndirectSubjectToNumbers)) end
        if bWantIndirectSubjectToNumbers then
            bDebugMessages = true
            local iTechCategory = M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)
            local iCurIndirectFire = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryIndirect * iTechCategory)
            local bConsiderShieldsInstead = false
            if bConsiderMobileShields and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield]) == false and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield])) == false then
                local iCurMobileShields = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMobileLandShield)
                if iCurMobileShields <= 3 * iCurIndirectFire then
                    bConsiderShieldsInstead = true
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': iCurIndirectFire='..iCurIndirectFire..'; Lifetime factory indirect fire count='..M28Conditions.GetFactoryLifetimeCount(oFactory, M28UnitInfo.refCategoryIndirect * iTechCategory)..'; bConsiderShieldsInstead='..tostring(bConsiderShieldsInstead)) end
            if bConsiderShieldsInstead and ConsiderBuildingCategory(M28UnitInfo.refCategoryMobileLandShield) then return sBPIDToBuild end

            if iCurIndirectFire <= 9 + 1.5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Conditions.GetFactoryLifetimeCount(oFactory, M28UnitInfo.refCategoryIndirect * iTechCategory) <= 18 + 2 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': WIll try and get MML or mobile arti, or mobile shield if we have t2 arti in this zone wanting shielding')
                end
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryIndirect) then
                    return sBPIDToBuild
                end
            end
            bDebugMessages = false
        end

    end

    --High priority engineer where they are needed for special shielding (e.g. of gameenders)
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if iFactoryTechLevel >= 3 and M28Utilities.IsTableEmpty(oFactory[M28Building.reftoUnitsWantingFactoryEngineers]) == false then
        --Do we already have at least 3 engineers of this factory's faction in the zone that the gameender is in?
        local iFactionRef = M28UnitInfo.GetUnitFaction(oFactory)
        for iUnit, oUnit in oFactory[M28Building.reftoUnitsWantingFactoryEngineers] do
            if M28UnitInfo.IsUnitValid(oUnit) then
                local iGameEnderPlateau, iGameEnderZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                local tLZTeamData = M28Map.tAllPlateaus[iGameEnderPlateau][M28Map.subrefPlateauLandZones][iGameEnderZone][M28Map.subrefLZTeamData][aiBrain.M28Team]
                if tLZTeamData[M28Map.subreftbBPByFactionWanted][iFactionRef] then
                    --How many T3 engineers of this faction do we have traveling to this zone already?
                    local iEngiCatWanted = M28UnitInfo.refCategoryEngineer * categories.TECH3
                    if iFactionRef == M28UnitInfo.refFactionUEF then iEngiCatWanted = iEngiCatWanted * categories.UEF
                    elseif iFactionRef == M28UnitInfo.refFactionAeon then iEngiCatWanted = iEngiCatWanted * categories.AEON
                    elseif iFactionRef == M28UnitInfo.refFactionCybran then iEngiCatWanted = iEngiCatWanted * categories.CYBRAN
                    elseif iFactionRef == M28UnitInfo.refFactionSeraphim then iEngiCatWanted = iEngiCatWanted * categories.SERAPHIM
                    end
                    local iEngisAlreadyTraveling = 0
                    --Want at least 3 enginers traveling of the desired tech level
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
                        for iEngi, oEngi in  tLZTeamData[M28Map.subrefTEngineersTravelingHere] do
                            if M28UnitInfo.IsUnitValid(oEngi) and EntityCategoryContains(iEngiCatWanted, oEngi.UnitId) then
                                iEngisAlreadyTraveling = iEngisAlreadyTraveling + 1
                            end
                        end
                    end
                    if iEngisAlreadyTraveling < 3 then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer * categories.TECH3) then return sBPIDToBuild end
                    end
                end
            end
        end
    end

    --ALso high priority engineers more generally if arent building any and want more
    if tLZTeamData[M28Map.subrefTbWantBP] and iFactoryTechLevel >= 3 and (M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 250) then
        local iCurBPWanted = tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][1] + tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][2] + tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][3]
        if iCurBPWanted > 20 then
            local iCurEngineersBeingBuilt = M28Conditions.GetNumberOfUnitsCurrentlyBeingBuiltOfCategoryInZone(tLZTeamData, M28UnitInfo.refCategoryEngineer * categories.TECH3)
            if (iCurEngineersBeingBuilt <= 2 or not(bHaveLowMass)) and iCurEngineersBeingBuilt * M28Engineer.tiBPByTech[3] < iCurBPWanted then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end
            end
        end
    end

    --Priority upgrade to T3 if have lots of T3 mexes, and no enemies in this zone (even if have enemies nearby), provided we have other factores in the zone that can build units
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if iFactoryTechLevel == 2 and aiBrain[M28Economy.refiOurHighestLandFactoryTech] == 2 and tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) and (aiBrain[M28Economy.refiGrossMassBaseIncome] >= 10 or tLZTeamData[M28Map.subrefMexCountByTech][3] >= 4) and (not(M28Conditions.HaveLowPower(iTeam)) or (not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 100)) then
        local bAlreadyUpgradingT2HQ = false
        --Check we arent already upgrading a T2 factory of any kind
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then
            for iUpgrade, oUpgrade in tLZTeamData[M28Map.subrefActiveUpgrades] do
                if EntityCategoryContains(categories.TECH2 * M28UnitInfo.refCategoryAllHQFactories, oUpgrade.UnitId) then
                    bAlreadyUpgradingT2HQ = true
                    break
                end
            end
        end
        if not(bAlreadyUpgradingT2HQ) then
            --Do we have other land factories in this zone? treat t1 factories as being worth 1/3 a t2 factory, need to -1 due to this factory
            local iT2FactoryEquivalent = -1 + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory * categories.TECH2) + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory) / 3
            if iT2FactoryEquivalent >= 1 then
                if ConsiderUpgrading() then  return sBPIDToBuild end
            end
        end
    end

    --Near unit cap - dont build anything at land fac if low mass and not highest tech level
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if aiBrain[M28Overseer.refbCloseToUnitCap] and (iFactoryTechLevel < math.min(3, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]) or (bHaveLowMass and not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]))) then
        --Try and get an upgrade if dont have low mass
        if not(bHaveLowMass) and (iFactoryTechLevel < aiBrain[M28Economy.refiOurHighestLandFactoryTech] or (iFactoryTechLevel < 3 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]))) then
            if ConsiderUpgrading() then return sBPIDToBuild end
        end
    else
        --Enemies nearby and have built fewer tanks of this tech level than engineers; or are on a core expansion and have no combat threat in this LZ
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': CHecking if nearby enemy threat and we are T2 plus, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Enemies in this or adjacent LZ=' .. tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) .. '; bSaveMassDueToEnemyFirebaseOrOurExperimental=' .. tostring(bSaveMassDueToEnemyFirebaseOrOurExperimental) .. '; bDontConsiderBuildingMAA=' .. tostring(bDontConsiderBuildingMAA))
        end
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
            --Build tanks unless we have a LC of tanks of at least 5 and more than our LC of engineers
            local iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iLandZone, iLandZone, bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths)
            if iCategoryToGet then
                if not (iCategoryToGet) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        if iFactoryTechLevel < 3 or not (bDontConsiderBuildingMAA) then
                            iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iLandZone, iAdjLZ, bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths)
                        elseif M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 1000 then
                            iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iLandZone, iAdjLZ, false, bConsiderMobileShields, bConsiderMobileStealths)
                        else
                            iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iLandZone, iAdjLZ, bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths)
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished considering category to build for iAdjLZ='..iAdjLZ..'; is iCategoryToGet nil='..tostring(iCategoryToGet == nil)) end
                        if iCategoryToGet then
                            break
                        end
                    end
                end
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Finished checking for support category wanted for this or adjacent LZ. Is iCategoryToGet nil=' .. tostring(iCategoryToGet == nil))
                end
                if iCategoryToGet then
                    local iTankLC = M28Conditions.GetLifetimeBuildCount(aiBrain, iCategoryToGet * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Lifetime build count for this tech level=' .. iTankLC .. '; Engi LC for this tech=' .. M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)))
                    end
                    if iTankLC < 3 or bHaveLowMass or iTankLC < M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then
                        if iFactoryTechLevel < 3 then
                            if ConsiderBuildingCategory(iCategoryToGet) then
                                return sBPIDToBuild
                            end
                        else
                            --If are overflowing mass, no enemies in cur LZ, at T3, and need BP, then get engineers
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Checking for mass overflow exception where will get engis instead; tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]=' .. tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) .. '; Stored%=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] .. '; Want BP=' .. tostring(tLZTeamData[M28Map.subrefTbWantBP]) .. '; iTankLC=' .. iTankLC)
                            end
                            if iTankLC >= 4 and not (bHaveLowMass) and not (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.95 and tLZTeamData[M28Map.subrefTbWantBP] and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) or M28Utilities.GetDistanceBetweenPositions(oFactory:GetPosition(), M28Utilities.GetNearestUnit(tLZTeamData[M28Map.reftoNearestDFEnemies], oFactory:GetPosition()):GetPosition()) >= 70) then
                                if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                                    return sBPIDToBuild
                                end
                            else
                                --Enemies near to base/land factory, and we have a category to get; however want to still consider unit ratios but based on these LZs before going with the standard support category - i.e. consider indirect fire if have lots of DF and T3 land
                                local iDFTotalThreat = tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
                                local iIndirectTotalThreat = tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]
                                local iEnemyAirToGroundThreat = tLZTeamData[M28Map.refiEnemyAirToGroundThreat]
                                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                    for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                        iDFTotalThreat = iDFTotalThreat + M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatAllyMobileDFTotal]
                                        iIndirectTotalThreat = iIndirectTotalThreat + M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatAllyMobileIndirectTotal]
                                        iEnemyAirToGroundThreat = iEnemyAirToGroundThreat + M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.refiEnemyAirToGroundThreat]
                                    end
                                end
                                if iDFTotalThreat >= 8000 and iDFTotalThreat > iIndirectTotalThreat * 8 and iEnemyAirToGroundThreat <= tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] and (EntityCategoryContains(categories.AEON, oFactory.UnitId)) or iDFTotalThreat > iIndirectTotalThreat * 10 then
                                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryT3MobileArtillery) then
                                        return sBPIDToBuild
                                    end
                                elseif ConsiderBuildingCategory(iCategoryToGet) then
                                    return sBPIDToBuild
                                end
                            end
                        end
                    end
                end
            end
        end

        --Priority tanks if at T2
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Considering priority T2 units, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Highest friendly factory tech=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] .. '; Lifetime build count for T2 land combat=' .. M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat - categories.TECH1) .. '; Current T2+ engineers=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer - categories.TECH1))
        end
        if iFactoryTechLevel == 2 and iFactoryTechLevel == M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat - categories.TECH1) < math.min(3, aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer - categories.TECH1)) then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Cur skirmishers=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategorySkirmisher * categories.TECH2) .. '; Cur DF tnaks=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandCombat * categories.TECH2)..'; subrefbLZWantsIndirectSupport='..tostring(tLZTeamData[M28Map.subrefbLZWantsIndirectSupport] or false))
            end
            if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and aiBrain:GetCurrentUnits(M28UnitInfo.refCategorySkirmisher * categories.TECH2) > math.max(2, aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandCombat * categories.TECH2)) then
                --Does enemy have structure threat in this or adjacent LZ? if so then prioritise MML instead unless we already have at least 5
                if tLZTeamData[M28Map.subrefbLZWantsIndirectSupport] and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryIndirect * categories.TECH2) < 5 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want more MML') end
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryIndirect * categories.TECH2) then return sBPIDToBuild end
                end

                if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandCombat * categories.TECH2) then
                    return sBPIDToBuild
                else
                    if ConsiderBuildingCategory(M28UnitInfo.refCategorySkirmisher * categories.TECH2) then
                        return sBPIDToBuild
                    elseif ConsiderBuildingCategory(M28UnitInfo.refCategoryLandCombat * categories.TECH2) then
                        return sBPIDToBuild
                    end
                end
            end
        end

        --Initial engineers
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Considering high priority engineers, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Team highest factory tech level=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] .. '; Lifetime build count=' .. M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) .. '; Current units=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)))
        end
        if iFactoryTechLevel >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] and tLZTeamData[M28Map.subrefLZbCoreBase] then
            local iMinEngisWanted --lifetime count; or half this for active current number
            if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                iMinEngisWanted = 2
            else
                iMinEngisWanted = 4
            end
            if M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) < iMinEngisWanted or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) <= (iMinEngisWanted * 0.5) then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                    return sBPIDToBuild
                end
            end
        end

        --Engineers if overflowing and at T3 and no ground enemies in this zone
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Engineers when about to overflow, [M28Map.subrefTbWantBP]='..tostring(tLZTeamData[M28Map.subrefTbWantBP])..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]=' .. tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) .. '; bHaveLowMass=' .. tostring(bHaveLowMass) .. '; Want more BP=' .. tostring(tLZTeamData[M28Map.subrefTbWantBP]) .. '; iFactoryTechLevel=' .. iFactoryTechLevel .. '; Mass percent stored=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] .. '; Gross mass=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass])
        end
        if not (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and not (bHaveLowMass) and tLZTeamData[M28Map.subrefTbWantBP] and iFactoryTechLevel >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.7 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 7 then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Will try and get more engieners')
            end
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                return sBPIDToBuild
            end
        end


        --Early game - more engineers if are on a large map where unlikely to have enemies nearby for a while
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Considering engineer for maps where enemy far away or not pathable, time=' .. GetGameTimeSeconds() .. '; Factory tehc=' .. iFactoryTechLevel .. '; Core base=' .. tostring(tLZTeamData[M28Map.subrefLZbCoreBase]) .. '; Path to enemy base iwth land=' .. tostring(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) .. '; Dist to closest enemy base from this LZ=' .. M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]))
        end
        if iFactoryTechLevel == 1 and GetGameTimeSeconds() <= 480 and tLZTeamData[M28Map.subrefLZbCoreBase] and (not (aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) or M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) >= 450) then
            --Do we have a low lifetime engineer build count?
            local iLCWanted = 12
            if M28Map.iMapSize <= 512 and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] then
                iLCWanted = 6
            end
            local iLifetimeEngiCount = M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer)
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': iLifetimeEngiCount=' .. iLifetimeEngiCount .. '; iLCWanted=' .. iLCWanted)
            end
            if iLifetimeEngiCount < iLCWanted then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end
            end
            if iLifetimeEngiCount < iLifetimeEngiCount * 2 and (not (aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) or M28Map.iMapSize > 512 or iLifetimeEngiCount < iLCWanted * 1.25) then
                --Do we have adjacent LZ with unbuilt mexes, no enemies, needing engineers with no engineers currently assigned or traveling?
                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    if not (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefMexUnbuiltLocations]) == false and M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEngineersTravelingHere]) == false and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP] then
                            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                                return sBPIDToBuild
                            end
                        end
                    end
                end

                --Do we have a nearby island wanting engineers?
                if GetGameTimeSeconds() <= 360 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
                    local iDistanceThreshold
                    if bHaveLowMass then
                        iDistanceThreshold = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) * 0.5
                        --If have t2 naval fac then greatly reduce distance threshold
                        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] >= 2 then
                            iDistanceThreshold = iDistanceThreshold * 0.4
                        end
                    else
                        iDistanceThreshold = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) * 0.75
                    end
                    iDistanceThreshold = math.min(300, iDistanceThreshold)

                    for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Considering island ' .. tPathingData[M28Map.subrefIslandNumber] .. '; travel dist=' .. tPathingData[M28Map.subrefIslandTravelDist] .. '; Closest LZ ref=' .. (tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil') .. '; are enemies in this or adjacent LZ=' .. tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]))
                        end
                        if tPathingData[M28Map.subrefIslandTravelDist] > iDistanceThreshold then
                            break
                        else
                            --Only consider island if available mexes and no enemies
                            if tPathingData[M28Map.subrefIslandClosestLZRef] then
                                local tIslandLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]]
                                local tIslandLZTeamData = tIslandLZData[M28Map.subrefLZTeamData][iTeam]
                                if not (tIslandLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefMexUnbuiltLocations]) == false and tIslandLZData[M28Map.subrefTbWantBP] then
                                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer - categories.FIELDENGINEER) then
                                        return sBPIDToBuild
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end


        --Initiail combat
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Considering initial combat units, lifetime count=' .. M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandCombat))
        end
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bCanPathToEnemyWithLand and iFactoryTechLevel == 1 and bHaveHighestLZTech and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandCombat) < 3 then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryDFTank) then
                return sBPIDToBuild
            end
        end

        --Scouts if we want any, subject to limit based on number of engineers we have
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Considering if we want land scouts, does this LZ want scouts=' .. tostring(tLZTeamData[M28Map.refbWantLandScout]))
        end
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if tLZTeamData[M28Map.refbWantLandScout] then
            if not (bHaveHighestLZTech) then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandScout) then
                    return sBPIDToBuild
                end
            else
                local iCurLandScouts = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandScout)
                if iCurLandScouts < 8 or iCurLandScouts < aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer) or iCurLandScouts * 2 < aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandCombat) then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandScout) then
                        return sBPIDToBuild
                    end
                end
            end
        end


        --Initial T2+ tanks if have at least 5 engis of our current tech level and dont have many tanks, and can path to enemy by land (core base only)
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if iFactoryTechLevel >= 2 and bHaveHighestLZTech and tLZTeamData[M28Map.subrefLZbCoreBase] then
            --Can we path to enemy base from this land zone?
            local iCurIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint])
            local iEnemyIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase])
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; iCurIsland=' .. iCurIsland .. '; iEnemyIsland=' .. iEnemyIsland .. '; iFactoryTechLevel=' .. iFactoryTechLevel .. '; Cur engineers of this tech level=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) .. '; Cur DF units of this tech level=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMobileLand * categories.DIRECTFIRE * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)))
            end
            if iCurIsland == iEnemyIsland and math.min(8 - M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount], aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))) > math.max(1, aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMobileLand * categories.DIRECTFIRE * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))) then
                if bCanPathToEnemyWithLand then
                    if iFactoryTechLevel == 2 and ConsiderBuildingCategory(M28UnitInfo.refCategorySkirmisher * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then
                        return sBPIDToBuild
                        --Initial T3 tanks - want tanks instead of sniperbots if enemy has lower health units/isnt at T3
                    elseif iFactoryTechLevel == 3 and oFactory[refiTotalBuildCount] >= 5 and (oFactory[refiTotalBuildCount] >= 15 or (M28Team.tTeamData[iTeam][M28Team.refiEnemyHighestMobileLandHealth] >= 2400 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3)) and ConsiderBuildingCategory(M28UnitInfo.refCategorySkirmisher * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then
                        return sBPIDToBuild
                    elseif ConsiderBuildingCategory(M28UnitInfo.refCategoryLandCombat * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then
                        return sBPIDToBuild
                    end
                else
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryAmphibiousCombat - categories.FIELDENGINEER) then
                        return sBPIDToBuild
                    end
                end
            end
        end

        --Non-core land zones - consider building combat units ahead of engineers if need them for this LZ
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; Do we have a core base=' .. tostring(tLZTeamData[M28Map.subrefLZbCoreBase] or false) .. '; will consider if we want non-core base units for this LZ if not a core base')
        end
        if not (tLZTeamData[M28Map.subrefLZbCoreBase]) then
            local iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iLandZone, iLandZone, bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths, bSaveMassDueToEnemyFirebaseOrOurExperimental)
            if iCategoryToGet then
                if bDebugMessages == true then LOG(sFunctionRef..': Have support category wanted for iPlateau='..iPlateau..'; iLandZone='..iLandZone) end
                if ConsiderBuildingCategory(iCategoryToGet) then
                    return sBPIDToBuild
                end
            end
        end



        --Consider upgrading factory to t2 (or T3) if we have lots of mass, or have built lots of units from this factory
        local iUnitCountToUpgrade = 25
        if iFactoryTechLevel < 3 then
            if iFactoryTechLevel < aiBrain[M28Economy.refiOurHighestLandFactoryTech] then
                iUnitCountToUpgrade = iUnitCountToUpgrade - 10
                local iUpgradingCount = 0
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]) == false then
                    for iUpgrade, oUpgrade in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs] do
                        if M28UnitInfo.IsUnitValid(oUpgrade) and EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUpgrade.UnitId) then
                            iUpgradingCount = iUpgradingCount + 1
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iUpgradingCount='..iUpgradingCount..'; iUnitCountToUpgrade pre this='..iUnitCountToUpgrade) end
                iUnitCountToUpgrade = iUnitCountToUpgrade + (iUpgradingCount + (iUpgradingCount - 1)) * 6


            else
                if iFactoryTechLevel < M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] then
                    iUnitCountToUpgrade = iUnitCountToUpgrade - 5
                end
                --If have active HQ upgrades for this brain then make it much less likely we will upgrade
                local bHaveActiveHQUpgrade = true
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryAllHQFactories, tLZTeamData[M28Map.subrefActiveUpgrades])) then
                    --Check all active upgrades of this tech level and below for this brain
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]) then
                        bHaveActiveHQUpgrade = false
                    else
                        bHaveActiveHQUpgrade = false
                        for iUpgrade, oUpgrade in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs] do
                            if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUpgrade.UnitId) or M28UnitInfo.GetUnitTechLevel(oUpgrade) >= iFactoryTechLevel then
                                bHaveActiveHQUpgrade = true
                                break
                            end
                        end
                    end
                end
                if bHaveActiveHQUpgrade then
                    iUnitCountToUpgrade = iUnitCountToUpgrade + 15
                    if bHaveLowMass or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.6 then
                        iUnitCountToUpgrade = iUnitCountToUpgrade + 15
                    end
                end
            end

            --(iFactoryTechLevel < M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) then iUnitCountToUpgrade = iUnitCountToUpgrade - 10 end
            if bHaveLowMass then iUnitCountToUpgrade = iUnitCountToUpgrade + 15 end
            if tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] then iUnitCountToUpgrade = iUnitCountToUpgrade + 15 end
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) then
                if bDebugMessages == true then LOG(sFunctionRef..': No enemy units in this zone and at least 40% mass stored so reducing unit count to upgrade by 25% from '..iUnitCountToUpgrade) end
                iUnitCountToUpgrade = iUnitCountToUpgrade * 0.75
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.8 or (M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]) and GetGameTimeSeconds() - (oFactory[refiTimeSinceLastFailedToGetOrder] or -100) <= 5 and tLZTeamData[M28Map.subrefLZbCoreBase]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Either have at least 80% mass stored or it has been a while since we had nothing to build so reducing unit count to upgrade by 50% from '..iUnitCountToUpgrade) end
                    iUnitCountToUpgrade = iUnitCountToUpgrade * 0.5
                end
            end
            if (GetGameTimeSeconds() - (oFactory[refiTimeSinceLastFailedToGetOrder] or -100)) <= 5 and (iFactoryTechLevel >= aiBrain[M28Economy.refiOurHighestLandFactoryTech] or not(tLZTeamData[M28Map.subrefLZbCoreBase])) then
                if bDebugMessages == true then LOG(sFunctionRef..': Not had anythign to build recently and we either have our highest tech or are not at a core base, so doubling unit count required') end
                iUnitCountToUpgrade = iUnitCountToUpgrade * 2
            end
            if M28Utilities.IsTableEmpty(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades])) then
                if bDebugMessages == true then LOG(sFunctionRef..': No active upgrades in this zone so reducing the unit count to upgrade by 25% from '..iUnitCountToUpgrade) end
                iUnitCountToUpgrade = iUnitCountToUpgrade * 0.75
            end

            --If we dont have many factories for this brain then increase the unit count for early game
            if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryAirFactory) < 3 and GetGameTimeSeconds() <= 480 then
                if bDebugMessages == true then LOG(sFunctionRef..'; We only have '..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryAirFactory)..' factories in total and early game so increasing the units to upgrade') end
                iUnitCountToUpgrade = math.max(iUnitCountToUpgrade * 1.5, 16)
            end


            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to upgrade factory, iFactoryTechLevel='..(iFactoryTechLevel or 'nil')..'; Highest friendly tech='..(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] or 'nil')..'; Time since last had no order='..(GetGameTimeSeconds() - (oFactory[refiTimeSinceLastFailedToGetOrder] or -100))..'; Is table of active upgrades empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]))..'; iUnitCountToUpgrade='..iUnitCountToUpgrade..'; Factory lifetime build count='..M28Conditions.GetFactoryLifetimeCount(oFactory, nil, true)) end
            if M28Conditions.GetFactoryLifetimeCount(oFactory, nil, true) >= iUnitCountToUpgrade then
                if bDebugMessages == true then LOG(sFunctionRef..': Will try and upgrade factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)) end
                if ConsiderUpgrading() then return sBPIDToBuild end
            end
        end

        --Combat units in proportion to engineers at T1 if enemy relatively nearby spawn
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if iFactoryTechLevel == 1 and GetGameTimeSeconds() <= 480 and tLZTeamData[M28Map.subrefLZbCoreBase] and (aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) and M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) < 450 then
            local iLifetimeEngineers = M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer)
            local iLifetimeLandCombat = M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat)
            if iLifetimeLandCombat < math.max(5, iLifetimeEngineers) and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandCombat) < aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer) then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandCombat) then return sBPIDToBuild end
            end
        end

        --Engineers if we dont have low mass, and want more
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        local bNeedCurTech = true
        for iCurTech = 1, iFactoryTechLevel do
            if tLZTeamData[M28Map.subrefSpareBPByTech][iCurTech] > 0 then
                bNeedCurTech = false
                break
            end
        end
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; about to consider getting engineers, do we have low mass=' .. tostring(bHaveLowMass) .. '; Highest team tech level=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] .. '; bHaveHighestLZTech=' .. tostring(bHaveHighestLZTech) .. '; bNeedCurTech=' .. tostring(bNeedCurTech) .. '; iFactoryTechLevel=' .. iFactoryTechLevel .. '; Lowest % mass stored=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored])
        end
        if bNeedCurTech and not (bHaveLowMass) and (iFactoryTechLevel >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5) then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Will try to build engineer')
            end
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                return sBPIDToBuild
            end
        end

        --Engineers if we have few engineers in the current land zone and want more, and no adjacent enemies
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; Will consider if we want more engis due to only having a few in the land zone, bNeedCurTech=' .. tostring(bNeedCurTech) .. '; tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal])
        end
        if bNeedCurTech and not (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 10) then
            local tLZEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subrefLZTAlliedUnits])
            local iEngisInLZ = 0
            if M28Utilities.IsTableEmpty(tLZEngineers) == false then
                iEngisInLZ = table.getn(tLZEngineers)
            end
            local iEngisWanted = 3
            if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                iEngisWanted = 2
            elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] > 3 then
                iEngisWanted = math.min(6, math.ceil(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]))
            end
            if not (tLZTeamData[M28Map.subrefLZbCoreBase]) then
                iEngisWanted = iEngisWanted * 0.5
            end
            if iEngisInLZ < iEngisWanted then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                    return sBPIDToBuild
                end
            end
        end


        --Other actions - dont do unless we have lots of mass if this is lower than our highest tech level
        if bHaveHighestLZTech and (iFactoryTechLevel >= aiBrain[M28Economy.refiOurHighestLandFactoryTech] or not (bHaveLowMass)) then
            --Combat or MAA if this LZ needs more units
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            --if tLZTeamData[M28Map.subrefbLZWantsSupport] then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Have highest LZ tech, iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; Will see if we want to get support for this LZ, bDontConsiderBuildingMAA=' .. tostring(bDontConsiderBuildingMAA) .. '; bConsiderMobileShields=' .. tostring(bConsiderMobileShields) .. '; bConsiderMobileStealths=' .. tostring(bConsiderMobileStealths))
            end
            local iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iLandZone, iLandZone, bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths, bSaveMassDueToEnemyFirebaseOrOurExperimental)
            if iCategoryToGet then
                if ConsiderBuildingCategory(iCategoryToGet) then
                    return sBPIDToBuild
                end
            end


            --Upgrade factory if this LZ is lagging behind tech wise (but not if low mass if this isn't a core LZ
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if iFactoryTechLevel == 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 2 and (iLandFactoriesInLZ >= 4 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] == 3) and (tLZTeamData[M28Map.subrefLZbCoreBase] or (tLZTeamData[M28Map.subrefLZCoreExpansion] and (not (bHaveLowMass) or M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint])] >= 7))) then
                --Dont upgrade to T2 if we have T1 mexes in the LZ, no upgrading mexes, and less than 35 gross mass per tick
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 3.5 or tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] * 3 >= 3 or tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then

                    local bUpgradingLandFactory = false
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then
                        for iUnit, oUnit in tLZTeamData[M28Map.subrefActiveUpgrades] do
                            if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) then
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': Have an active land factory upgrade=' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit.UnitId) .. '; Is unit valid=' .. tostring(M28UnitInfo.IsUnitValid(oUnit)) .. '; Fraction complete=' .. oUnit:GetFractionComplete() .. '; Work progress=' .. oUnit:GetWorkProgress())
                                end
                                bUpgradingLandFactory = true
                                break
                            end
                        end
                    end
                    if not (bUpgradingLandFactory) then
                        if ConsiderUpgrading() then return sBPIDToBuild end
                    end
                end
            end

            --Maintain basic level of unit threat ratios
            --DF tanks of the cur tech level or higher - get more if we have fewer of these than we have engineers of this tech level and we have less DF threat than the enemy overall
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if bDebugMessages == true then LOG(sFunctionRef..': Maintaining basic threat ratios - bCanPathToEnemyWithLand='..tostring(bCanPathToEnemyWithLand)..'; bSaveMassDueToEnemyFirebaseOrOurExperimental='..tostring(bSaveMassDueToEnemyFirebaseOrOurExperimental)..'; iFactoryTechLevel='..iFactoryTechLevel..'; If have fewer than 9 DF units and fewer than no. of engineers then will build more, cur DF units of this tech level='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMobileLand * categories.DIRECTFIRE * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))) end
            if bCanPathToEnemyWithLand and not (bSaveMassDueToEnemyFirebaseOrOurExperimental) and iFactoryTechLevel >= 2 and math.min(9, aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))) > aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMobileLand * categories.DIRECTFIRE * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Have fewer DF tanks than engineers so want to get more skirmishers or (if cant build any) DF tanks')
                end


                if ConsiderBuildingCategory(M28UnitInfo.refCategorySkirmisher * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then
                    return sBPIDToBuild
                else
                    --Cant get skirmishers, so get indirect fire if we have none before getting normal tnaks
                    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryIndirect * categories.MOBILE * categories.LAND * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) == 0 and ConsiderBuildingCategory(M28UnitInfo.refCategoryIndirect * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then
                        return sBPIDToBuild
                    elseif ConsiderBuildingCategory(M28UnitInfo.refCategoryLandCombat * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then
                        return sBPIDToBuild
                    end
                end
            end

            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Checking threat ratios for if we want more indirect, DF threat=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] .. '; Indirect=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat])
            end
            if not (bSaveMassDueToEnemyFirebaseOrOurExperimental) then
                local iIndirectRatioWanted
                if iFactoryTechLevel == 1 then
                    iIndirectRatioWanted = 6
                elseif iFactoryTechLevel == 2 then
                    iIndirectRatioWanted = 9
                elseif iFactoryTechLevel == 3 then
                    if aiBrain:GetCurrentUnits((M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategorySkirmisher) * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) >= 60 then
                        if EntityCategoryContains(categories.AEON, oFactory.UnitId) then
                            iIndirectRatioWanted = 3.5
                        else
                            iIndirectRatioWanted = 4
                        end
                    else
                        if EntityCategoryContains(categories.AEON, oFactory.UnitId) then
                            iIndirectRatioWanted = 7
                        else
                            iIndirectRatioWanted = 9
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Indirect threat ratio, bCanPathToEnemyWithLand='..tostring(bCanPathToEnemyWithLand)..', M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat]='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat]..'; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat]='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat]..'; iIndirectRatioWanted='..iIndirectRatioWanted..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Cur T3 DF and skrimisher count='..aiBrain:GetCurrentUnits((M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategorySkirmisher) * categories.TECH3)) end
                if bCanPathToEnemyWithLand and M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] > M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] * iIndirectRatioWanted and (not (bHaveLowMass) or (iFactoryTechLevel >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] > M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] * iIndirectRatioWanted * 2 and aiBrain:GetCurrentUnits((M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategorySkirmisher) * categories.TECH3) >= 50)) then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Will try to build more indirect fire units if arent building any of this tech level or higher in this LZ')
                    end
                    if iFactoryTechLevel == 1 or M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryIndirect * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) == 0 then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryIndirect) then
                            return sBPIDToBuild
                        end
                    end
                end
            end

            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if bCanPathToEnemyWithLand and not (bHaveLowMass) and not (bDontConsiderBuildingMAA) then
                --Maintain MAA ratio vs overall combat threat - Only get MAA if we either have T2 land, or 50 gross mass, or enemy has air; max of 2 at a time
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Checking MAA ratio overall, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]=' .. M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] .. '; M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir]=' .. tostring(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir]) .. '; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat])
                end
                if iFactoryTechLevel >= 2 or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoAllEnemyAir]) == false or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 5 then
                    local iThreatFactor = 20
                    if M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir] and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 4000 then
                        iThreatFactor = 8
                    elseif not (M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl]) and (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 2000 or M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir]) then
                        iThreatFactor = 13
                    end
                    if M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] > M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] * iThreatFactor then
                        local iMAACat
                        if oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA) >= 50 or (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] >= 2000 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.TECH3 * M28UnitInfo.refCategoryBomber, M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround])) == false) and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA - categories.TECH3) > oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) * 4 then
                            iMAACat = M28UnitInfo.refCategoryMAA
                        else
                            iMAACat = M28UnitInfo.refCategoryMAA - categories.TECH3
                        end
                        if M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, iMAACat) <= 1 then
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Will get MAA3')
                            end
                            if ConsiderBuildingCategory(iMAACat) then
                                return sBPIDToBuild
                            end
                        end
                    end
                end
            end

            --Be building engineers in 1/4 of land facs if we have a shortfall for this land zone
            if iLandFactoriesInLZ > 1 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.01 or M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) and tLZTeamData[M28Map.subrefTbWantBP] then
                if M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryEngineer) < iLandFactoriesInLZ * 0.25 then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                        return sBPIDToBuild
                    end
                end
            end

            --Combat or MAA if we have a LZ within half of dist between us and nearest enemy that wants more units
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            local iEnemyPlateau, iEnemyLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.GetPrimaryEnemyBaseLocation(aiBrain))
            if iEnemyPlateau == iPlateau then
                local iDistToEnemyBaseToConsider
                --Is enemy in same island?
                local iIsland = NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, oFactory:GetPosition())
                if bDebugMessages == true then
                    local iEnemyBaseSegmentX, iEnemyBaseSegmentZ = M28Map.GetPathingSegmentFromPosition(M28Map.GetPrimaryEnemyBaseLocation(aiBrain))
                    LOG(sFunctionRef..': Primary enemy base location='..repru(M28Map.GetPrimaryEnemyBaseLocation(aiBrain))..'; Land label='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) or 'nil')..'; iEnemyLandZone='..(iEnemyLandZone or 'nil')..'; tPathingPlateauAndLZOverride[iX][iZ]='..repru(M28Map.tPathingPlateauAndLZOverride[(M28Map.GetPrimaryEnemyBaseLocation(aiBrain)[1] or 0)][(M28Map.GetPrimaryEnemyBaseLocation(aiBrain)[3] or 0)])..'; iEnemyBaseSegmentX'..iEnemyBaseSegmentX..'; , iEnemyBaseSegmentZ='..iEnemyBaseSegmentZ..'; tLandZoneBySegment='..(M28Map.tLandZoneBySegment[iEnemyBaseSegmentX][iEnemyBaseSegmentZ] or 'nil'))
                end
                if NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) == iIsland and (iEnemyLandZone or 0) > 0 then
                    if not (bHaveLowMass) then
                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 then
                            iDistToEnemyBaseToConsider = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iEnemyLandZone)
                            --Campaign specific - if no active upgrades then increase the dist further (as we may be tech capped/unable to build experimentals)
                            if (M28Map.bIsCampaignMap or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.8) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) and not(M28Conditions.HaveLowPower(iTeam)) then
                                iDistToEnemyBaseToConsider = math.max(500, iDistToEnemyBaseToConsider)
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': About to get travel distance to use based on dist to enemy base, iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iEnemyLandZone='..(iEnemyLandZone or 'nil')..'; iEnemyPlateau='..(iEnemyPlateau or 'nil')) end
                            iDistToEnemyBaseToConsider = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iEnemyLandZone) * 0.75
                        end
                        iDistToEnemyBaseToConsider = math.max(iDistToEnemyBaseToConsider, 250)

                    else
                        iDistToEnemyBaseToConsider = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iEnemyLandZone) * 0.5
                    end
                else
                    --enemy base is a dif island to ours or for some reason doesnt have a land zone, so want to control all of our island (within reason)
                    iDistToEnemyBaseToConsider = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.GetPrimaryEnemyBaseLocation(aiBrain))
                end

                --Reduce distance to consider if we are building an experimental
                if iDistToEnemyBaseToConsider >= 200 then
                    if iFactoryTechLevel == 3 and bHaveLowMass and oFactory[refiTotalBuildCount] >= 5 and aiBrain:GetEconomyStored('MASS') < 600 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]) == false and not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                        if (iEnemyLandZone or 0) > 0 then
                            iDistToEnemyBaseToConsider = math.max(200,     (M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iEnemyLandZone) or 0) * 0.3)
                        else
                            iDistToEnemyBaseToConsider = 200
                        end
                    end
                end

                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                    local bDontConsiderPlayableArea = not(M28Map.bIsCampaignMap)
                    for iEntry, tLZPathing in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': About to check alternative LZ ' .. tLZPathing[M28Map.subrefLZNumber] .. '; iDistToEnemyBaseToConsider=' .. iDistToEnemyBaseToConsider .. '; tLZPathing[M28Map.subrefLZTravelDist]=' .. tLZPathing[M28Map.subrefLZTravelDist])
                        end
                        if tLZPathing[M28Map.subrefLZTravelDist] <= iDistToEnemyBaseToConsider and (bDontConsiderPlayableArea or M28Conditions.IsLocationInPlayableArea(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tLZPathing[M28Map.subrefLZNumber]][M28Map.subrefMidpoint])) then
                            --if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tLZPathing[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefbLZWantsSupport] then
                            --How far away is it?
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Considering whether to reinforce alternative LZ ' .. (tLZPathing[M28Map.subrefLZNumber] or 'nil') .. '; Travel dist=' .. (tLZPathing[M28Map.subrefLZTravelDist] or 'nil') .. '; iDistToEnemyBaseToConsider=' .. (iDistToEnemyBaseToConsider or 'nil') .. '; Size of this alt LZ in segments=' .. (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tLZPathing[M28Map.subrefLZNumber]][M28Map.subrefLZTotalSegmentCount] or 'nil'))
                            end
                            --if tLZPathing[M28Map.subrefLZTravelDist] <= iDistToEnemyBaseToConsider then
                            local iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iLandZone, tLZPathing[M28Map.subrefLZNumber], bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths, bSaveMassDueToEnemyFirebaseOrOurExperimental)
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': DO we have no category (i.e. false means we want to build something) for this alternative LZ ' .. tLZPathing[M28Map.subrefLZNumber] .. '=' .. tostring(iCategoryToGet == nil) .. '; bDontConsiderBuildingMAA=' .. tostring(bDontConsiderBuildingMAA))
                            end
                            if iCategoryToGet then
                                if bDebugMessages == true then
                                    LOG(sFunctionRef..': Have got a category to build based on the land zone '..tLZPathing[M28Map.subrefLZNumber])
                                    --LOG(sFunctionRef .. ': Will draw the LZ where we want more units in a rnadom colour')
                                    --M28Map.DrawSpecificLandZone(iPlateau, tLZPathing[M28Map.subrefLZNumber], math.random(1, 8))
                                end
                                if ConsiderBuildingCategory(iCategoryToGet) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have got valid blueprint '..sBPIDToBuild..' to build') end
                                    return sBPIDToBuild
                                end
                            end
                        else
                            break
                        end
                    end
                end
            end

            --Do we have adjacent water with friendly units that wants MAA?
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false and not (bDontConsiderBuildingMAA) then
                local iAdjWZ, iPond
                local iCategoryWanted = (categories.NAVAL + categories.AMPHIBIOUS + categories.HOVER) * M28UnitInfo.refCategoryMAA
                for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                    iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                    iPond = M28Map.tiPondByWaterZone[iAdjWZ]
                    local tWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then
                        if not (iPond) then
                            LOG('iPond nil')
                        end
                        if not (iAdjWZ) then
                            LOG('iAdjWZ nil')
                        end
                        if not (tWZTeamData[M28Map.subrefWZMAAThreatWanted]) then
                            LOG('tWZTeamData[M28Map.subrefWZMAAThreatWanted] nil')
                        end
                        if not (tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]) then
                            LOG('tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] nil')
                        end
                        if not (tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]) then
                            LOG('tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] nil')
                        end
                        LOG(sFunctionRef .. ': Considering if want MAA for iPond=' .. iPond .. '; iAdjWZ=' .. iAdjWZ .. '; tWZTeamData[M28Map.subrefWZMAAThreatWanted]=' .. tWZTeamData[M28Map.subrefWZMAAThreatWanted] .. '; tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] .. '; tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]=' .. tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal])
                    end
                    if tWZTeamData[M28Map.subrefWZMAAThreatWanted] > 0 and (tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < 10 or tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] > 10) then
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Will try and build hover flak to support adjacent water zone')
                        end
                        if ConsiderBuildingCategory(iCategoryWanted) then
                            return sBPIDToBuild
                        end
                    end
                end
            end

            --Now consider islands
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
                local iDistanceThreshold
                if bHaveLowMass then
                    iDistanceThreshold = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) * 0.5
                    --If have t2 naval fac then greatly reduce distance threshold
                    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] >= 2 then
                        iDistanceThreshold = iDistanceThreshold * 0.4
                    end
                else
                    iDistanceThreshold = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) * 0.75
                end

                for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Considering island ' .. tPathingData[M28Map.subrefIslandNumber] .. '; travel dist=' .. tPathingData[M28Map.subrefIslandTravelDist] .. '; Closest LZ ref=' .. (tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil') .. '; are enemies in this or adjacent LZ=' .. tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]))
                    end
                    if tPathingData[M28Map.subrefIslandTravelDist] > iDistanceThreshold then
                        break
                    else
                        --Are there enemies in the target LZ?
                        if tPathingData[M28Map.subrefIslandClosestLZRef] and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                            if ConsiderBuildingCategory(M28UnitInfo.refCategoryAmphibiousCombat - categories.FIELDENGINEER) then
                                return sBPIDToBuild
                            end
                        end
                    end
                end
            end
        elseif (not (bHaveHighestLZTech) or iFactoryTechLevel < aiBrain[M28Economy.refiOurHighestLandFactoryTech]) then
            --Dont have highest tech, and have low mass
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Consideringi f we want to upgrade factory, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Brain highest tech=' .. aiBrain[M28Economy.refiOurHighestLandFactoryTech])
            end
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if iFactoryTechLevel < aiBrain[M28Economy.refiOurHighestLandFactoryTech] then
                --Do we want ot upgrade a support factory? Check first if are upgrading anything here
                local bUpgradingLandFactory = false

                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then
                    for iUnit, oUnit in tLZTeamData[M28Map.subrefActiveUpgrades] do
                        if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) then
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Have an active land factory upgrade=' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit.UnitId) .. '; Is unit valid=' .. tostring(M28UnitInfo.IsUnitValid(oUnit)) .. '; Fraction complete=' .. oUnit:GetFractionComplete() .. '; Work progress=' .. oUnit:GetWorkProgress())
                            end
                            bUpgradingLandFactory = true
                            break
                        end
                    end
                end
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': bUpgradingLandFactory=' .. tostring(bUpgradingLandFactory) .. '; bHaveLowMass=' .. tostring(bHaveLowMass) .. '; Lowest mass % stored=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored])
                end
                if not (bUpgradingLandFactory) or (not (bHaveLowMass) and (aiBrain[M28Economy.refiOurHighestLandFactoryTech] == 3 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 4000 or M28Conditions.GetFactoryLifetimeCount(oFactory, nil, true) >= 25) and (iFactoryTechLevel == 1 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5)) then
                    if (tLZTeamData[M28Map.subrefLZbCoreBase] or (tLZTeamData[M28Map.subrefLZCoreExpansion] and (not (bHaveLowMass) or M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint])] >= 7))) then
                        if not (bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.3 and M28Conditions.GetLifetimeBuildCount(aiBrain, categories.LAND * categories.MOBILE * M28UnitInfo.ConvertTechLevelToCategory(aiBrain[M28Economy.refiOurHighestLandFactoryTech])) >= 3 then
                            if ConsiderUpgrading() then
                                return sBPIDToBuild
                            end
                        elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.02 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.15 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0) and M28Conditions.GetLifetimeBuildCount(aiBrain, categories.LAND * categories.MOBILE * M28UnitInfo.ConvertTechLevelToCategory(aiBrain[M28Economy.refiOurHighestLandFactoryTech])) >= 6 then
                            --Still consider upgrading if we have a T2 land factory but no t2 support factory in the LZ and have built some T2 units already
                            local tLandFactoriesInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                            local iHQAndSupportCount = 0
                            for iUnit, oUnit in tLandFactoriesInZone do
                                if M28UnitInfo.GetUnitTechLevel(oUnit) >= aiBrain[M28Economy.refiOurHighestLandFactoryTech] then
                                    iHQAndSupportCount = iHQAndSupportCount + 1
                                end
                            end
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': iHQAndSupportCount=' .. iHQAndSupportCount)
                            end
                            if iHQAndSupportCount <= 1 then
                                if ConsiderUpgrading() then
                                    return sBPIDToBuild
                                end
                            end
                        end
                    end
                end
            end

            --Do we want MAA, mobile shield or mobile stealth (with T2 factory while we have other T3 factories)?
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if iFactoryTechLevel == 2 then
                local iEnemyPlateau, iEnemyLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.GetPrimaryEnemyBaseLocation(aiBrain))
                if iEnemyPlateau == iPlateau then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Time ' .. GetGameTimeSeconds() .. '; aiBrain[M28Overseer.refiDistanceToNearestEnemyBase]=' .. (aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] or 'nil') .. '; iPlateau=' .. (iPlateau or 'nil') .. '; iLandZone=' .. (iLandZone or 'nil') .. '; iEnemyLandZone=' .. (iEnemyLandZone or 'nil') .. '; Factory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. ' at position ' .. repru(oFactory:GetPosition()) .. '; Primary enemy base location=' .. repru(M28Map.GetPrimaryEnemyBaseLocation(aiBrain)))
                    end
                    local iDistToEnemyBaseToConsider
                    if iEnemyLandZone == iLandZone then
                        iDistToEnemyBaseToConsider = (M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iEnemyLandZone) or aiBrain[M28Overseer.refiDistanceToNearestEnemyBase]) * 0.5
                    else
                        iDistToEnemyBaseToConsider = aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.4
                    end
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                        for iEntry, tLZPathing in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                            if tLZPathing[M28Map.subrefLZTravelDist] <= iDistToEnemyBaseToConsider then
                                --How far away is it?
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': T2 Considering whether to reinforce alternative LZ ' .. tLZPathing[M28Map.subrefLZNumber] .. '; Travel dist=' .. tLZPathing[M28Map.subrefLZTravelDist] .. '; iDistToEnemyBaseToConsider=' .. iDistToEnemyBaseToConsider)
                                end
                                if tLZPathing[M28Map.subrefLZTravelDist] <= iDistToEnemyBaseToConsider then
                                    local iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iLandZone, tLZPathing[M28Map.subrefLZNumber], bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths, true)
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': T2 DO we have no category for this alternative LZ ' .. tLZPathing[M28Map.subrefLZNumber] .. '=' .. tostring(iCategoryToGet == nil) .. '; bDontConsiderBuildingMAA=' .. tostring(bDontConsiderBuildingMAA))
                                    end
                                    if iCategoryToGet then
                                        if ConsiderBuildingCategory(iCategoryToGet) then
                                            return sBPIDToBuild
                                        end
                                    end
                                end
                            else
                                break
                            end
                        end
                    end
                end
            end
        end

        --Different island to nearest friendly base or expansion base - ensure we have some DF and indirect fire threat nearby
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if on a different island or are an expansion base, Factory land label='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, oFactory:GetPosition()) or 'nil')..'; Closest friendly base='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestFriendlyBase]) or 'nil')..'; Is this a core expansion zone='..tostring(tLZTeamData[M28Map.subrefLZCoreExpansion] or false)..'; Is this a core zone='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase] or false)) end
        if not(NavUtils.GetLabel(M28Map.refPathingTypeLand, oFactory:GetPosition()) == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestFriendlyBase])) or tLZTeamData[M28Map.subrefLZCoreExpansion] then
            if bDebugMessages == true then LOG(sFunctionRef..': Closest base is in a different island, so will get base level of tanks') end
            local iNearbyDFThreat = tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
            local iNearbyIFThreat = tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]
            local iNearbyGroundAAThreat = tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]
            local iFriendlyDFThreatWanted = 100
            local iFriendlyIFThreatWanted = 50
            local iFriendlyAAThreatWanted = 100
            local iThreatFactor = 1
            if M28Map.bIsCampaignMap then iThreatFactor = 3 end
            if M28Map.subrefLZSValue >= 1000 then iThreatFactor = iThreatFactor * 1.5 end
            if tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 then iThreatFactor = iThreatFactor * 2 end
            if tLZData[M28Map.subrefLZMexCount] >= 4 then iThreatFactor = iThreatFactor * 2 end


            if not(iThreatFactor == 1) then
                iFriendlyDFThreatWanted = iFriendlyDFThreatWanted * iThreatFactor
                iFriendlyIFThreatWanted = iFriendlyIFThreatWanted * iThreatFactor
                iFriendlyAAThreatWanted = iFriendlyAAThreatWanted * iThreatFactor
            end
            --If no enemies in an adjacent land zone and this factory ahs built at least 25 units, then disable this test, as otherwise we run the risk of units traveling far away meaning we keep buliding inappropriate units
            if M28Conditions.GetFactoryLifetimeCount(oFactory, nil, true) >= 25 and not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
                if bHaveLowMass or GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForLandFactory] or -100) <= 10 then
                    if M28Conditions.GetFactoryLifetimeCount(oFactory, nil, true) <= 50 then
                        --Consider lifetime counts for each unit type specifically
                        if M28Conditions.GetFactoryLifetimeCount(oFactory, M28UnitInfo.refCategoryLandCombat * categories.DIRECTFIRE, true) >= 15 then iFriendlyDFThreatWanted = 0 end
                        if M28Conditions.GetFactoryLifetimeCount(oFactory, M28UnitInfo.refCategoryMAA, true) >= 12 then iFriendlyAAThreatWanted = 0 end
                        if M28Conditions.GetFactoryLifetimeCount(oFactory, M28UnitInfo.refCategoryIndirect, true) >= 12 then iFriendlyIFThreatWanted = 0 end
                    else
                        iFriendlyDFThreatWanted = 0
                        iFriendlyIFThreatWanted = 0
                        iFriendlyAAThreatWanted = 0
                    end
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have a base level of threat around this land factory, iThreatFactor='..iThreatFactor..'; iNearbyDFThreat='..iNearbyDFThreat..'; iFriendlyDFThreatWanted='..iFriendlyDFThreatWanted) end

            if iNearbyDFThreat < iFriendlyDFThreatWanted or iNearbyIFThreat < iFriendlyIFThreatWanted or iNearbyGroundAAThreat < iFriendlyAAThreatWanted then
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                        iNearbyDFThreat = iNearbyDFThreat + tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
                        iNearbyIFThreat = iNearbyIFThreat + tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]
                        iNearbyGroundAAThreat = iNearbyGroundAAThreat + tAdjLZTeamData[M28Map.subrefLZThreatAllyGroundAA]
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Threat after factoring in adjacent land zones: iNearbyDFThreat='..iNearbyDFThreat..'; iNearbyIFThreat='..iNearbyIFThreat..'; iNearbyGroundAAThreat='..iNearbyGroundAAThreat) end
                if iNearbyDFThreat < iFriendlyDFThreatWanted or iNearbyIFThreat < iFriendlyIFThreatWanted or iNearbyGroundAAThreat < iFriendlyAAThreatWanted then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will get basic level of combat threat as are on an island') end
                    --Get a couple of each type first:
                    if iNearbyDFThreat < 100 then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandCombat * categories.DIRECTFIRE) then return sBPIDToBuild end
                    end
                    if iNearbyGroundAAThreat < 100 then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryMAA) then return sBPIDToBuild end
                    end
                    if iNearbyIFThreat < 50 then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryIndirect) then return sBPIDToBuild end
                    end

                    --Now get the one that we ahve the lowest ratio for
                    local iLowestCategoryType
                    local iLowestRatio = 10000
                    local iCurRatio
                    if iNearbyDFThreat < iFriendlyDFThreatWanted then
                        iLowestRatio = iNearbyDFThreat / iFriendlyDFThreatWanted
                        iLowestCategoryType = M28UnitInfo.refCategoryLandCombat * categories.DIRECTFIRE
                    end

                    if iNearbyGroundAAThreat < iFriendlyAAThreatWanted then
                        iCurRatio = iNearbyGroundAAThreat / iFriendlyAAThreatWanted
                        if iCurRatio < iLowestRatio then
                            iLowestRatio = iCurRatio
                            iLowestCategoryType = M28UnitInfo.refCategoryMAA
                        end
                    end

                    if iNearbyIFThreat < iFriendlyIFThreatWanted then
                        iCurRatio = iNearbyIFThreat / iFriendlyIFThreatWanted
                        if iCurRatio < iLowestRatio then
                            iLowestRatio = iCurRatio
                            iLowestCategoryType = M28UnitInfo.refCategoryIndirect
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iLowestRatio='..iLowestRatio) end
                    if iLowestCategoryType then
                        if ConsiderBuildingCategory(iLowestCategoryType) then return sBPIDToBuild end
                    end
                end
            end


        end

        --Engineers if we have mass and dont have spare engineers
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Considering if want engineers if have mass: M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] .. '; bHaveHighestLZTech=' .. tostring(bHaveHighestLZTech) .. '; subrefTbWantBP=' .. tostring(tLZTeamData[M28Map.subrefTbWantBP]))
        end
        if tLZTeamData[M28Map.subrefTbWantBP] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.01 and (bHaveHighestLZTech or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.4 and tLZTeamData[M28Map.subrefLZbCoreBase])) then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                return sBPIDToBuild
            end
        end

        --T1 mobile arti if we dont ahve low mass and are below highest tech level, or normal tanks otherwise
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if not (bHaveLowMass) and (not (bSaveMassDueToEnemyFirebaseOrOurExperimental) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.45) then
            --Is there a relatively nearby enemy?

            local bEnemiesRelativelyNear = tLZData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]
            if not (bEnemiesRelativelyNear) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                        bEnemiesRelativelyNear = true
                        break
                    end
                end
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Dont have low mass so considering if we have enemies adjacent to an adjacent LZ in which case will build T1 arti, bEnemiesRelativelyNear=' .. tostring(bEnemiesRelativelyNear))
            end
            if bEnemiesRelativelyNear then
                if bHaveHighestLZTech then
                    if bCanPathToEnemyWithLand then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategorySkirmisher) then
                            return sBPIDToBuild
                        end
                    else
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryAmphibiousCombat - categories.FIELDENGINEER) then
                            return sBPIDToBuild
                        end
                    end
                else
                    if bCanPathToEnemyWithLand and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryIndirect * categories.TECH1) <= 60 then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryIndirect * categories.TECH1) then
                            return sBPIDToBuild
                        end
                    end
                end
            end
        end



        --Upgrade T1 to T2 if we have multiple mex upgrades and T1 land facs in this land zone, and already have T2 land, even if have low mass
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if iFactoryTechLevel == 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 20 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] or -5) >= 3 then
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false and table.getn(tLZTeamData[M28Map.subrefActiveUpgrades]) >= 3 then
                if (tLZTeamData[M28Map.subrefLZbCoreBase] or (tLZTeamData[M28Map.subrefLZCoreExpansion] and (not (bHaveLowMass) or M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint])] >= 7))) then
                    local iCurMexUpgrades = 0
                    local iCurT1FactoryUpgrades = 0
                    for iUnit, oUnit in tLZTeamData[M28Map.subrefActiveUpgrades] do
                        if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                            iCurMexUpgrades = iCurMexUpgrades + 1
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFactory * categories.TECH1, oUnit.UnitId) then
                            iCurT1FactoryUpgrades = iCurT1FactoryUpgrades + 1
                        end
                    end
                    if iCurT1FactoryUpgrades == 0 and iCurMexUpgrades >= 2 then
                        --Do we have more than 1 T1 land factory in this land zone?
                        local tT1LandFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory * categories.TECH1, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                        if table.getn(tT1LandFactories) >= 2 then
                            if ConsiderUpgrading() then
                                return sBPIDToBuild
                            end
                        end
                    end
                end
            end
        end

        --Build more engineers if we have multiple upgrades and need more engineers for the current LZ, even if relatively low mass
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if tLZTeamData[M28Map.subrefTbWantBP] and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 50 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] or -5) >= 5 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) == false then
            if table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 3 then
                --Build engineers as we have lots of upgrades
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                    return sBPIDToBuild
                end
            end
        end

        --More land scouts (no cap)
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then LOG(sFunctionRef..': Uncapped land scout builder, tLZTeamData[M28Map.refbWantLandScout]='..tostring(tLZTeamData[M28Map.refbWantLandScout])) end
        if tLZTeamData[M28Map.refbWantLandScout] then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandScout) then
                return sBPIDToBuild
            end
        end

        --Want factories to have a lifetime build count of indirect fire units
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if not(bHaveLowMass) and M28Conditions.GetFactoryLifetimeCount(oFactory, M28UnitInfo.refCategoryIndirect, false) < 5 then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryIndirect) then return sBPIDToBuild end
        end

        --Build more units if we are overflowing mass and dont have many units in cur land zone
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.95 then
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedCombatUnits]) or table.getn(tLZTeamData[M28Map.subrefLZTAlliedCombatUnits]) < 25 then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryIndirect) then return sBPIDToBuild end
            end
        end

        --Build land scouts if need more if in LZ expansion with poor radar coverage
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if tLZTeamData[M28Map.refiRadarCoverage] < 50 and tLZTeamData[M28Map.refbWantLandScout] then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandScout) then return sBPIDToBuild end
        end
    end



    M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForLandFactory] = GetGameTimeSeconds()
    oFactory[refiTimeSinceLastFailedToGetOrder] = GetGameTimeSeconds() --Redundancy, will also include in parent logic
    tLZTeamData[M28Map.subrefiTimeLandFacHadNothingToBuild] = GetGameTimeSeconds()
    if bDebugMessages == true then LOG(sFunctionRef..': Updated time that last had nothing to build for land factory to '..M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForLandFactory]) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DetermineWhatToBuild(aiBrain, oFactory)
    local sBPIDToBuild
    if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oFactory.UnitId) then
        sBPIDToBuild = GetBlueprintToBuildForLandFactory(aiBrain, oFactory)
    elseif EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oFactory.UnitId) then
        sBPIDToBuild = GetBlueprintToBuildForAirFactory(aiBrain, oFactory)
    elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oFactory.UnitId) then
        sBPIDToBuild = GetBlueprintToBuildForNavalFactory(aiBrain, oFactory)
    elseif EntityCategoryContains(M28UnitInfo.refCategoryQuantumGateway, oFactory.UnitId) then
        sBPIDToBuild = GetBlueprintToBuildForQuantumGateway(aiBrain, oFactory)
    else
        M28Utilities.ErrorHandler('Need to add code - unexpected factory type')
    end
    return sBPIDToBuild
end
function IsFactoryReadyToBuild(oFactory)
    if oFactory:GetFractionComplete() == 1 and oFactory:GetWorkProgress() == 0 and oFactory:GetFractionComplete() == 1 and not (oFactory:IsUnitState('Building')) and not (oFactory:IsUnitState('Upgrading')) and not (oFactory:IsUnitState('Busy')) and
            (oFactory:IsUnitState('Guarding') or M28Utilities.IsTableEmpty(oFactory:GetCommandQueue())) then
        --Issue in campaign where factories were being given a guard order by another script, meaning their command queue wasnt empty - have updated so this will be ignored
        --Add further check that we havent built something at a nearby factory and have recently stalled
        local aiBrain = oFactory:GetAIBrain()
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oFactory:GetPosition())
        local tLZOrWZTeamData
        local iTeam = aiBrain.M28Team
        if (iLandOrWaterZone or 0) > 0 then
            if iPlateauOrZero == 0 then
                tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
            else
                tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
            end
        end
        if GetGameTimeSeconds() - (tLZOrWZTeamData[M28Map.refiTimeLastBuiltAtFactory] or -100) >= 0.09 then
            --i.e. dont start production in more than 1 factory per zone per tick, so e.g. air facs are less likely to all build asfs at the same time and cause a power stall
            return true
            --backup for scenarios where dont want to wait - if high mass and energy and AiX
        elseif aiBrain.CheatEnabled and tonumber(ScenarioInfo.Options.CheatMult or 1.5) >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 and M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] > (M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] or 0) * 1.25 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or -100) >= 15 then
            return true
        end
    end
    return false
end

function SetFactoryRallyPoint(oFactory)
    --Search to the left of the factory as the first choice; if not in buildable area search to the right; then up; then down
    local sFunctionRef = 'SetFactoryRallyPoint'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tiAngles = {270, 0, 90, 180}
    local oFactoryBP = oFactory:GetBlueprint()
    local tiFactorySize = {oFactoryBP.Physics.SkirtSizeX, oFactoryBP.Physics.SkirtSizeZ, oFactoryBP.Physics.SkirtSizeX, oFactoryBP.Physics.SkirtSizeZ}
    local tPotentialRally
    local tPreferredRally
    local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
    local iBestRallyValue = -100
    local iCurRallyValue
    if bDebugMessages == true then LOG(sFunctionRef..': Near start for factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..' at time '..GetGameTimeSeconds()..'; tiFactoryRadius='..repru(tiFactorySize)..'; Factory position='..repru(oFactory:GetPosition())) end
    for iEntry, iCurAngle in tiAngles do
        for iDistAdjust = 4,2, -2 do
            tPotentialRally = M28Utilities.MoveInDirection(oFactory:GetPosition(), iCurAngle, tiFactorySize[iEntry] * 0.6 + iDistAdjust, true, false, false)
            if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tPotentialRally) then
                iCurRallyValue = 4 - iEntry --Prefer them in the angle indicated
                local tNearbyUnits = GetUnitsInRect(tPotentialRally[1] - 1, tPotentialRally[3] - 1, tPotentialRally[1] + 1, tPotentialRally[3] + 1)
                if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                    iCurRallyValue = iCurRallyValue - 0.25
                    local tNearbyStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tNearbyUnits)
                    if M28Utilities.IsTableEmpty(tNearbyStructures) == false then
                        iCurRallyValue = iCurRallyValue - 4
                    end
                end
                if iDistAdjust > 3 and iDistAdjust <= 7 then iCurRallyValue = iCurRallyValue + 2 end
                if bDebugMessages == true then LOG(sFunctionRef..': tPotentialRally='..repru(tPotentialRally)..'; iDistAdjust='..iDistAdjust..'; iCurAngle='..iCurAngle..'; iCurRallyValue='..iCurRallyValue..'; iBestRallyValue='..iBestRallyValue) end
                if iCurRallyValue > iBestRallyValue then
                    iBestRallyValue = iCurRallyValue
                    tPreferredRally = tPotentialRally
                end
            end
        end
    end
    if not(tPreferredRally) then tPreferredRally = oFactory:GetPosition() end
    oFactory[reftFactoryRallyPoint] = {tPreferredRally[1], tPreferredRally[2], tPreferredRally[3]}
    if not(oFactory:IsUnitState('Building')) then IssueClearFactoryCommands({oFactory}) end
    IssueFactoryRallyPoint({oFactory}, oFactory[reftFactoryRallyPoint])
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MovePotentialBlockingUnitsFromFactory(oFactory)
    local sFunctionRef = 'MovePotentialBlockingUnitsFromFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain = oFactory:GetAIBrain()

    local rRect = M28Utilities.GetRectAroundLocation(oFactory:GetPosition(), M28UnitInfo.GetBuildingSize(oFactory.UnitId) * 0.5 - 0.2)
    local tUnitsInRect = GetUnitsInRect(rRect)
    if bDebugMessages == true then LOG(sFunctionRef..': Factory doesnt seem to have been trying to build something for a long time so will check for units nearby that arent attached, are complete, and are blocking it. Is tUnitsInRect empty='..tostring(M28Utilities.IsTableEmpty(tUnitsInRect))) end
    if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
        local tMobileLandInRect = EntityCategoryFilterDown(M28UnitInfo.refCategoryMobileLand, tUnitsInRect)
        if M28Utilities.IsTableEmpty(tMobileLandInRect) == false then
            for iUnit, oUnit in tMobileLandInRect do
                if oUnit:GetFractionComplete() == 1 and oUnit:GetAIBrain().M28AI and oUnit:GetAIBrain().M28Team == aiBrain.M28Team and not(oUnit:IsUnitState('Upgrading')) then
                    --Move the unit
                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and move potential blocking unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                    M28Orders.IssueTrackedMove(oUnit, oFactory[reftFactoryRallyPoint], 0, false, 'FacBlock', true)
                    M28Micro.TrackTemporaryUnitMicro(oUnit, 2)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedCheckIfFactoryBuildingAndRetry(oFactory)
    local sFunctionRef = 'DelayedCheckIfFactoryBuildingAndRetry'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iStartTime = GetGameTimeSeconds()
    local iBuildCount = (oFactory[refiTotalBuildCount] or 0)
    local iWaitCount = 0
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitSeconds(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    iWaitCount = iWaitCount + 1
    --Check if factory has been stuck
    while M28UnitInfo.IsUnitValid(oFactory) and oFactory[refiTotalBuildCount] == iBuildCount and oFactory:GetWorkProgress() == 0 and not(oFactory:IsUnitState('Upgrading')) and not(oFactory:IsUnitState('Building')) do
        if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; oFactory='..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; iWaitCount='..iWaitCount..'; oFactory[refiFirstTimeOfLastOrder]='..(oFactory[refiFirstTimeOfLastOrder] or 'nil')) end
        if iWaitCount >= 5 then
            if oFactory[refiFirstTimeOfLastOrder] and GetGameTimeSeconds() - (oFactory[refiFirstTimeOfLastOrder] or 0) >= 5 then
                if bDebugMessages == true then LOG(sFunctionRef..': Will try and get a new order for the factory and clear blocking units') end
                MovePotentialBlockingUnitsFromFactory(oFactory)
                DecideAndBuildUnitForFactory(oFactory:GetAIBrain(), oFactory, true, false)
            end
            break
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        iWaitCount = iWaitCount + 1
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DecideAndBuildUnitForFactory(aiBrain, oFactory, bDontWait, bConsiderDestroyingForMass)
    --If factory is idle then gets it to build something; if its not idle then keeps checking for up to 20 seconds, but will abort if the factory appears to be building something
    local sFunctionRef = 'DecideAndBuildUnitForFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if not (oFactory['M28ActiveBuilderCheck']) then
        oFactory['M28ActiveBuilderCheck'] = true
        local iTicksWaited = 0

        local bProceed = bDontWait
        if not (bProceed) then
            bProceed = IsFactoryReadyToBuild(oFactory)
        end

        local iWorkProgressStart = (oFactory:GetWorkProgress() or 0)
        local iTicksToWait = 1

        while not (bProceed) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(iTicksToWait)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            iTicksWaited = iTicksWaited + iTicksToWait
            if M28UnitInfo.IsUnitValid(oFactory) == false then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return nil
            end
            bProceed = IsFactoryReadyToBuild(oFactory)
            if oFactory:GetWorkProgress() > iWorkProgressStart then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Factory work progress is going up so will abort as it presumably already has an order')
                end
                break
            end

            if iTicksWaited >= 200 then
                if not(oFactory:GetAIBrain()[M28Overseer.refbCloseToUnitCap]) then
                    M28Utilities.ErrorHandler('oFactory has waited more than 200 ticks and still isnt showing as ready to build, oFactory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; brain nickname=' .. oFactory:GetAIBrain().Nickname .. '; Work progress=' .. oFactory:GetWorkProgress() .. '; Factory fraction complete=' .. oFactory:GetFractionComplete() .. '; Factory status=' .. M28UnitInfo.GetUnitState(oFactory) .. '; Is command queue empty=' .. tostring(M28Utilities.IsTableEmpty(oFactory:GetCommandQueue())) .. '; iWorkProgressStart=' .. (iWorkProgressStart or 'nil'), true)
                end
                break
            elseif iTicksWaited >= 40 then
                iTicksToWait = math.min(iTicksToWait + 1, 10)
                if iTicksWaited >= 50 and oFactory:GetWorkProgress() == 0 and not(oFactory:IsUnitState('Upgrading')) and not(oFactory[M28UnitInfo.refbPaused]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a facotry stuck at 0 work progress, factory order blueprint='..(oFactory[M28Orders.reftiLastOrders][oFactory[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] or 'nil')..'; oFactory[refiFirstTimeOfLastOrder]='..(oFactory[refiFirstTimeOfLastOrder] or 'nil')) end
                    if oFactory[M28Orders.reftiLastOrders][oFactory[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] and ((oFactory[refiFirstTimeOfLastOrder] and GetGameTimeSeconds() - oFactory[refiFirstTimeOfLastOrder] >= 5) or (M28Utilities.IsTableEmpty(oFactory:GetCommandQueue()) == false)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..' has been waiting a while and isnt ready, will see if issue is a blocking unit') end
                        MovePotentialBlockingUnitsFromFactory(oFactory)
                    end
                end
            end
        end
        if bProceed then
            --Set factory rally point if havent already
            if M28Utilities.IsTableEmpty(oFactory[reftFactoryRallyPoint]) then
                SetFactoryRallyPoint(oFactory)
            end
            local sBPToBuild = DetermineWhatToBuild(aiBrain, oFactory)
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': oFactory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; sBPToBuild=' .. (sBPToBuild or 'nil') .. '; Does factory have an empty command queue=' .. tostring(M28Utilities.IsTableEmpty(oFactory:GetCommandQueue())) .. '; Factory work progress=' .. oFactory:GetWorkProgress() .. '; Factory unit state=' .. M28UnitInfo.GetUnitState(oFactory))
            end
            if sBPToBuild then
                --Is this an upgrade or a unit to build?
                if EntityCategoryContains(M28UnitInfo.refCategoryFactory, sBPToBuild) then
                    M28Economy.UpgradeUnit(oFactory, true)
                else
                    --Do we already have this order? If so then want to start tracking how long we have had this order for, and consider redundancies after a while in case a unit is blocking us
                    if bDebugMessages == true then LOG(sFunctionRef..': oFactory[refiFirstTimeOfLastOrder]='..(oFactory[refiFirstTimeOfLastOrder] or 'nil')..'; Time from now='..(GetGameTimeSeconds() - (oFactory[refiFirstTimeOfLastOrder] or GetGameTimeSeconds()))..'; Is factory paused='..tostring(oFactory[M28UnitInfo.refbPaused])) end
                    if oFactory[refiFirstTimeOfLastOrder] and not(oFactory[M28UnitInfo.refbPaused]) and oFactory[M28Orders.reftiLastOrders][oFactory[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] == sBPToBuild then
                        if GetGameTimeSeconds() - (oFactory[refiFirstTimeOfLastOrder] or -100) >= 5 then --If changing the time from 5s need to also change it in the delayedcheck function
                            --Redundancy with code here - would expect this to be called via DelayedCheckifFactoryBuildingAndRetry
                            MovePotentialBlockingUnitsFromFactory(oFactory)

                        end
                    else
                        oFactory[refiFirstTimeOfLastOrder] = GetGameTimeSeconds()
                        if bDebugMessages == true then LOG(sFunctionRef..': Setting refiFirstTimeOfLastOrder='..oFactory[refiFirstTimeOfLastOrder]) end
                        ForkThread(DelayedCheckIfFactoryBuildingAndRetry, oFactory)
                    end
                    M28Orders.IssueTrackedFactoryBuild(oFactory, sBPToBuild, bDontWait)
                end
            else
                oFactory[refiTimeSinceLastFailedToGetOrder] = GetGameTimeSeconds()
                --Clear any assisting engineers
                if bDebugMessages == true then LOG(sFunctionRef..': We dont have anything to build, will wait 10 ticks and try again.  In the meantime will clear all assisting engineers. Is table of assisting units empty='..tostring(M28Utilities.IsTableEmpty(oFactory[M28UnitInfo.reftoUnitsAssistingThis]))) end
                if M28Utilities.IsTableEmpty(oFactory[M28UnitInfo.reftoUnitsAssistingThis]) == false then
                    local tUnitsToClear = {}
                    for iUnit, oUnit in oFactory[M28UnitInfo.reftoUnitsAssistingThis] do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            table.insert(tUnitsToClear, oUnit)
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is tUnitsToClear empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToClear))) end
                    if M28Utilities.IsTableEmpty(tUnitsToClear) == false then
                        for iUnit, oUnit in tUnitsToClear do
                            M28Orders.IssueTrackedClearCommands(oUnit)
                        end
                    end
                    oFactory[M28UnitInfo.reftoUnitsAssistingThis] = {}
                end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(10)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if M28UnitInfo.IsUnitValid(oFactory) then
                    local bSelfDestructIfLowMass = false
                    local iExistingT3Factories = 0
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Considering at time ' .. GetGameTimeSeconds() .. ' whether to ctrlk factory tech level ' .. M28UnitInfo.GetUnitTechLevel(oFactory) .. ' when bHaveLowMass=' .. tostring(M28Conditions.HaveLowMass(aiBrain)) .. ' and highest tech=' .. M28Team.tTeamData[oFactory:GetAIBrain().M28Team][M28Team.subrefiHighestFriendlyFactoryTech] .. '; factory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; bConsiderDestroyingForMass=' .. tostring(bConsiderDestroyingForMass or false))
                    end
                    if bConsiderDestroyingForMass and M28UnitInfo.GetUnitTechLevel(oFactory) < 3 and M28Team.tTeamData[oFactory:GetAIBrain().M28Team][M28Team.subrefiHighestFriendlyFactoryTech] == 3 then
                        --Do we have a factory of the same type but of a higher tech level in this LZ?
                        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oFactory:GetPosition())
                        if iPlateauOrZero > 0 then
                            local oBrain = oFactory:GetAIBrain()
                            local iTeam = aiBrain.M28Team
                            local tLZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
                            local iFactoryType = M28UnitInfo.GetFactoryType(oFactory)
                            if iFactoryType == refiFactoryTypeLand then
                                local tExistingT3Factories = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory * categories.TECH3, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': Is table of existing T3 land factories empty=' .. tostring(M28Utilities.IsTableEmpty(tExistingT3Factories)) .. '; Total T3 land owned by this brain=' .. oBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory * categories.TECH3))
                                end
                                iExistingT3Factories = table.getn(tExistingT3Factories)
                                if M28Utilities.IsTableEmpty(tExistingT3Factories) == false and iExistingT3Factories >= 2 and oBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandHQ * categories.TECH3) > 0 then
                                    bSelfDestructIfLowMass = true
                                end

                            elseif iFactoryType == refiFactoryTypeAir then
                                if M28UnitInfo.GetUnitTechLevel(oFactory) == 1 then
                                    local tExistingT3Factories = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory * categories.TECH3, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': Is table of existing T3 air factories empty=' .. tostring(M28Utilities.IsTableEmpty(tExistingT3Factories)) .. ' Brain cur T3 factories=' .. oBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory * categories.TECH3))
                                    end
                                    iExistingT3Factories = table.getn(tExistingT3Factories)
                                    if M28Utilities.IsTableEmpty(tExistingT3Factories) == false and iExistingT3Factories >= 2 and oBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirHQ * categories.TECH3) > 0 then
                                        bSelfDestructIfLowMass = true
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': bSelfDestructIfLowMass=' .. tostring(bSelfDestructIfLowMass))
                    end
                    if not (bSelfDestructIfLowMass) or not (M28Conditions.HaveLowMass(aiBrain)) then
                        ForkThread(DecideAndBuildUnitForFactory, aiBrain, oFactory, false)
                    else
                        sBPToBuild = nil
                        if iExistingT3Factories <= 3 then
                            sBPToBuild = DetermineWhatToBuild(aiBrain, oFactory)
                        end
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Do we have something to build after checking before ctrlK? sBPToBuild=' .. (sBPToBuild or 'nil'))
                        end
                        if sBPToBuild then
                            ForkThread(DecideAndBuildUnitForFactory, aiBrain, oFactory, false)
                        else
                            --CtrlK for mass
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Will ctrlK factory ' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. ' for mass/reclaim')
                            end
                            M28Orders.IssueTrackedKillUnit(oFactory)
                        end
                    end
                end
            end
        end
    end
    oFactory['M28ActiveBuilderCheck'] = false
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SetPreferredUnitsByCategory(aiBrain)
    --If have multiple units that can build for a particular category, this will specify what to build
    --special cases where want to prioritise one unit over another where multiple of same type satisfy the category
    --NOTE: This gets ignored if we have coded in special cases where we want to pick the fastest or slowest unit
    aiBrain[reftBlueprintPriorityOverride] = {}
    --T1
    aiBrain[reftBlueprintPriorityOverride]['ual0201'] = 1 --Aurora (instead of LAB)
    aiBrain[reftBlueprintPriorityOverride]['url0107'] = 1 --Mantis (instead of LAB)
    aiBrain[reftBlueprintPriorityOverride]['uel0201'] = 1 --Striker (instead of mechmarine)
    aiBrain[reftBlueprintPriorityOverride]['xsl0201'] = 1 --Thaam (instead of combat scout)
    --T2
    aiBrain[reftBlueprintPriorityOverride]['uel0202'] = 1 --Pillar (instead of mongoose or riptide)
    aiBrain[reftBlueprintPriorityOverride]['xsl0202'] = 1 --Ilshavoh (instead of hover tank)
    aiBrain[reftBlueprintPriorityOverride]['url0202'] = 1 --Rhino (instead of hover tank)
    aiBrain[reftBlueprintPriorityOverride]['ual0202'] = 1 --Obsidian (instead of blaze)
    --T3
    aiBrain[reftBlueprintPriorityOverride]['uel0303'] = 1 --Titan (instead of Percy)
    aiBrain[reftBlueprintPriorityOverride]['ual0303'] = 1 --Harby (instead of sniper bot)
    --aiBrain[reftBlueprintPriorityOverride]['ual0304'] = 1 --Mobile t3 arti instead of shield disrupter
    aiBrain[reftBlueprintPriorityOverride]['url0303'] = 1 --Loyalist (instead of Brick)
    --aiBrain[reftBlueprintPriorityOverride]['xrl0305'] = 1 --Brick
    aiBrain[reftBlueprintPriorityOverride]['xsl0303'] = 1 --Siege tank (instead of sniper bot)
    aiBrain[reftBlueprintPriorityOverride]['xsl0301'] = 1 --Seraphim basic SACU (instead of preset)

    --Engineers
    aiBrain[reftBlueprintPriorityOverride]['uel0208'] = 1 --T2 Engi (instead of sparky)

end

function IdleFactoryMonitor(aiBrain)
    --Cycles through every factory owned by aiBrain, max of 1 factory per tick, to check if it is idle
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IdleFactoryMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    while not (aiBrain.M28IsDefeated) do
        local tOurFactories = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryQuantumGateway, false, true)
        local tCommandQueue
        local sBPToBuild
        local iTeam
        if M28Utilities.IsTableEmpty(tOurFactories) == false then
            for iFactory, oFactory in tOurFactories do
                if M28UnitInfo.IsUnitValid(oFactory) and oFactory:GetFractionComplete() == 1 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering factory'..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..' at time '..GetGameTimeSeconds()..'; Is factory ready to build='..tostring(IsFactoryReadyToBuild(oFactory))..'; oFactory[M28UnitInfo.refbPaused]='..tostring(oFactory[M28UnitInfo.refbPaused] or false)..'; oFactory:IsPaused()='..tostring(oFactory:IsPaused())) end
                    tCommandQueue = oFactory:GetCommandQueue()
                    if IsFactoryReadyToBuild(oFactory) and GetGameTimeSeconds() - (oFactory[refiTimeSinceLastOrderCheck] or 0) >= 5 then
                        oFactory[refiTimeSinceLastOrderCheck] = GetGameTimeSeconds()
                        ForkThread(DecideAndBuildUnitForFactory, aiBrain, oFactory, nil, true)
                    --Redundancy for paused factories (in theory shouldnt be needed)
                    elseif oFactory[M28UnitInfo.refbPaused] or oFactory:IsPaused() then
                        iTeam = oFactory:GetAIBrain().M28Team
                        if bDebugMessages == true then LOG(sFunctionRef..': M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] or false)..'; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] or false)..'; M28Team.tTeamData[M28Team.subrefiTeamNetMass]='..(M28Team.tTeamData[M28Team.subrefiTeamNetMass] or 'nil')..'; M28Team.tTeamData[M28Team.subrefiTeamNetEnergy]='..(M28Team.tTeamData[M28Team.subrefiTeamNetEnergy] or 'nil')) end
                        if not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > 0 then
                            M28UnitInfo.PauseOrUnpauseMassUsage(oFactory, false)
                            if bDebugMessages == true then LOG(sFunctionRef..': Unpause override for factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)) end
                        end
                    end
                end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(1)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
end

function GetBlueprintToBuildForAirFactory(aiBrain, oFactory)
    local sFunctionRef = 'GetBlueprintToBuildForAirFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCategoryToBuild
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oFactory:GetPosition(), true, oFactory)
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
    local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
    local iTeam = aiBrain.M28Team
    local iAirSubteam = aiBrain.M28AirSubteam
    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
    local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)
    local bSaveMassDueToEnemyFirebaseOrOurExperimental
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]) == false and bHaveLowMass then
        bSaveMassDueToEnemyFirebaseOrOurExperimental = true
    else
        bSaveMassDueToEnemyFirebaseOrOurExperimental = M28Conditions.WantToEcoDueToEnemyFirebase(iTeam, tLZTeamData, iPlateau)
    end



    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Near start of code, time=' .. GetGameTimeSeconds() .. '; oFactory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; Checking if we have the highest tech land factory in the current land zone, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Highest friendly factory tech=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] .. '; Allied ground threat=' .. (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] or 'nil') .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]=' .. (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] or 'nil') .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat]=' .. (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] or 'nil') .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat]=' .. (M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] or 'nil') .. '; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat]=' .. (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat] or 'nil') .. '; Is factory paused=' .. tostring(oFactory:IsPaused()) .. '; IsPaused value=' .. tostring(oFactory[M28UnitInfo.refbPaused]) .. '; Does LZ factory is in need BP=' .. tostring(tLZTeamData[M28Map.subrefTbWantBP]) .. '; Core LZ=' .. tostring(tLZTeamData[M28Map.subrefLZbCoreBase] or false) .. '; Core expansion=' .. tostring(tLZTeamData[M28Map.subrefLZCoreExpansion] or false) .. '; Time since a factory in this LZ last built something=' .. GetGameTimeSeconds() - (tLZTeamData[M28Map.refiTimeLastBuiltAtFactory] or -100) .. '; bHaveLowMass=' .. tostring(bHaveLowMass) .. '; bHaveLowPower=' .. tostring(bHaveLowPower))
    end

    iCategoryToBuild = M28UnitInfo.refCategoryEngineer --Placeholder
    local sBPIDToBuild
    local iCurrentConditionToTry = 0

    --subfunctions to mean we can do away with the 'current condition == 1, == 2.....==999 type approach making it much easier to add to
    function ConsiderBuildingCategory(iCategoryToBuild)
        sBPIDToBuild = GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oFactory, nil, nil, nil, nil, false)

        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Time=' .. GetGameTimeSeconds() .. ' Factory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; LZ=' .. iLandZone .. '; iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; sBPIDToBuild before adjusting for override=' .. (sBPIDToBuild or 'nil'))
        end
        if sBPIDToBuild then
            sBPIDToBuild = AdjustBlueprintForOverrides(aiBrain, oFactory, sBPIDToBuild, tLZTeamData, iFactoryTechLevel)
        end
        if sBPIDToBuild then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd) --Assumes we will end code if we get to this point
            return sBPIDToBuild
        end
    end

    function ConsiderUpgrading()
        sBPIDToBuild = M28UnitInfo.GetUnitUpgradeBlueprint(oFactory, true)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return sBPIDToBuild
    end


    --MAIN BUILDER LOGIC:
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    --Special priority flag to build engineer
    if oFactory[refbWantNextUnitToBeEngineer] then
        oFactory[refbWantNextUnitToBeEngineer] = false
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end
    end
    --Low power - only consider building engineers (if have lots of mass)
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': If low power then will only consider building engineers or emergency AirAA, bHaveLowPower=' .. tostring(bHaveLowPower))
    end
    if bHaveLowPower then
        M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] = M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]

        --Emergency gunship builder if have no gunships and nearby enemies, even if low power
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] >= 0.7 and iFactoryTechLevel >= 2 and tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
            local iOurGunshipThreat = 0
            local tiSubteamsConsidered = {}
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    if not (tiSubteamsConsidered[oBrain.M28AirSubteam]) then
                        tiSubteamsConsidered[oBrain.M28AirSubteam] = true
                        iOurGunshipThreat = iOurGunshipThreat + (M28Team.tAirSubteamData[oBrain.M28AirSubteam][M28Team.subrefiOurGunshipThreat] or 0)
                    end
                end
            end
            if iOurGunshipThreat == 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Have no gunship threat so will try and build some') end
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryGunship) then
                    return sBPIDToBuild
                end
            end
        end

        --Emergency AirAA if enemy air to ground threat overall and we haven't built many inties, or is air to gorund threat in this zone, subject to if we are power stalling
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] >= 0.95 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > 0 and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) then
            if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 or (M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround] > 0 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirAA) <= 2) then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirAA) then return sBPIDToBuild end
            end
        end

        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': AIr fac engi builder: bHaveLowMass=' .. tostring(bHaveLowMass) .. '; M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] .. '; subrefTbWantBP=' .. tostring(tLZTeamData[M28Map.subrefTbWantBP] or false))
        end
        if not (bHaveLowMass) and tLZTeamData[M28Map.subrefTbWantBP] then
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.25 and iFactoryTechLevel >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                    return sBPIDToBuild
                end
            end
        end
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Another engi builder - iFactoryTechLevel=' .. iFactoryTechLevel .. '; Highest friendly tech=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] .. '; Mass stored=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored])
        end
        if tLZTeamData[M28Map.subrefTbWantBP] and iFactoryTechLevel >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] then
            --Do we have fewer than 5 engineers of this tech level in this zone and we have some mass stored? if so then build another engineer (also build another engineer if we have fewer than 3 engineers even with low mass)
            local iEngisOfTechInZone = 0
            local iBPWanted = tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][1] + tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][2] + tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][3]
            local tEngisOfTechInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel), tLZTeamData[M28Map.subrefLZTAlliedUnits])
            if M28Utilities.IsTableEmpty(tEngisOfTechInZone) == false then
                iEngisOfTechInZone = table.getn(tEngisOfTechInZone)
            end
            if iEngisOfTechInZone < 3 or (iEngisOfTechInZone < 5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 0) or (iEngisOfTechInZone < 10 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 1000 or iBPWanted >= 100))
                    or (iEngisOfTechInZone < 50 and iBPWanted / 10 > iEngisOfTechInZone and iFactoryTechLevel >= 3 and (M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or M28Conditions.GetNumberOfUnitsCurrentlyBeingBuiltOfCategoryInZone(tLZTeamData, M28UnitInfo.refCategoryEngineer * categories.TECH3) <= math.min(2, iBPWanted / M28Engineer.tiBPByTech[3]))) then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                    return sBPIDToBuild
                end
            end
        end

    else
        --Emergency air defence
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Emergency AA defence, tLZTeamData[M28Map.refiEnemyAirToGroundThreat]=' .. tLZTeamData[M28Map.refiEnemyAirToGroundThreat] .. '; tLZTeamData[M28Map.refiEnemyAirAAThreat]=' .. tLZTeamData[M28Map.refiEnemyAirAAThreat])
        end
        if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 or tLZTeamData[M28Map.refiEnemyAirAAThreat] > 0 then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirAA) then
                return sBPIDToBuild
            end
        end

        --Initial engineers
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Considering high priority engineers, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Team highest factory tech level=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] .. '; Lifetime build count=' .. M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) .. '; Current units=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)))
        end
        if iFactoryTechLevel >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] and tLZTeamData[M28Map.subrefLZbCoreBase] then
            if M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) <= 4 or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) <= 2 then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                    return sBPIDToBuild
                end
            end
        end

        --Spy plane/air scout if not power stalling and havent built any, and are at T2+, and dont have omni
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then LOG(sFunctionRef..': Low power air scout builder, stored energy ratio='..aiBrain:GetEconomyStoredRatio('ENERGY')..'; Cur air scouts='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirScout)..'; this factory lifetime count='..M28Conditions.GetFactoryLifetimeCount(oFactory, M28UnitInfo.refCategoryAirScout)..'; Radar coverage='..(tLZTeamData[M28Map.refiRadarCoverage] or 'nil')..'; factory total build count='..(oFactory[refiTotalBuildCount] or 0)) end
        if iFactoryTechLevel >= 2 and (tLZTeamData[M28Map.refiRadarCoverage] or 0) <= 300 and aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.99 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirScout) == 0 and M28Conditions.GetFactoryLifetimeCount(oFactory, M28UnitInfo.refCategoryAirScout) <= math.floor((oFactory[refiTotalBuildCount] or 0) * 0.1) then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirScout) then return sBPIDToBuild end
        end

        --Overflowing mass (and dont have low power since are here)
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if not (bHaveLowMass) and tLZTeamData[M28Map.subrefTbWantBP] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.7 then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                return sBPIDToBuild
            end
        end

        --Nearby enemy air to ground threat
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                if tAdjLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Have adjacent land zone with air to ground threat=' .. tAdjLZTeamData[M28Map.refiEnemyAirToGroundThreat] .. '; will get airaa')
                    end
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirAA) then
                        return sBPIDToBuild
                    end
                    break
                end
            end
        end

        --Upgrade to T2 if at T1 air and have a certain level of mass and energy, and either cant path to enemy by land or it will take a while or we have good gross mass and energy income
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to upgrade T1 air fac to T2, iFactoryTechLevel='..iFactoryTechLevel..'; aiBrain[M28Economy.refiGrossEnergyBaseIncome]='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; aiBrain[M28Economy.refiGrossMassBaseIncome]='..aiBrain[M28Economy.refiGrossMassBaseIncome]) end
        if iFactoryTechLevel == 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] <= 1 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 32 and aiBrain[M28Economy.refiGrossMassBaseIncome] >= 2 and (not (M28Team.DoesBrainHaveActiveHQUpgradesOfCategory(aiBrain, M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryAirFactory)) or (aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 100 and aiBrain[M28Economy.refiGrossMassBaseIncome] >= 7 and not(M28Team.DoesBrainHaveActiveHQUpgradesOfCategory(aiBrain, M28UnitInfo.refCategoryAirFactory)))) and ((aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 10 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 7 and aiBrain[M28Economy.refiOurHighestLandFactoryTech] >= 2) or (aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 45 and not (bHaveLowMass)) or not (aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) or M28Utilities.GetTravelDistanceBetweenPositions(oFactory:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase], M28Map.refPathingTypeLand) >= 375) then
            if ConsiderUpgrading() then
                return sBPIDToBuild
            end
        end

        --Nearby enemy ground (gunship)
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Will get gunship if have enemy ground threat in this LZ, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal])
        end
        if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': Nearby enemy threat so will try and build gunship') end
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryGunship) then
                return sBPIDToBuild
            end
        end

        --Near unit cap - dont build anything at air fac if low mass and not highest tech level
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if aiBrain[M28Overseer.refbCloseToUnitCap] and iFactoryTechLevel < math.min(3, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]) then
            --Try and get an upgrade if dont have low mass
            if not(bHaveLowMass) and (iFactoryTechLevel < aiBrain[M28Economy.refiOurHighestAirFactoryTech] or (iFactoryTechLevel < 3 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]))) then
                if ConsiderUpgrading() then return sBPIDToBuild end
            end
        else
            --Adjacent LZs - gunship (enemy ground) or AirAA (enemy air)
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Considering adjacent land zone ' .. iAdjLZ .. '; Is table of enemy air untis empty=' .. tostring(M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftLZEnemyAirUnits])) .. '; tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal])
                    end
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftLZEnemyAirUnits]) == false and not (M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl]) then
                        if iFactoryTechLevel >= 3 or not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbOnlyGetASFs]) then
                            if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirAA) then return sBPIDToBuild end
                            break
                        end
                    end
                    if tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Adjacent zone has enemy threat so will try and build gunship') end
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryGunship) then
                            return sBPIDToBuild
                        end
                    end
                end
            end

            --early-game Transport (high priority)
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if (M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftTransportIslandDropShortlist]) == false or M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftTransportFarAwaySameIslandPlateauLandZoneDropShortlist]) == false) and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryTransport) == 0 and ((iFactoryTechLevel <= 2 and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryTransport) <= 1) or (M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] and GetGameTimeSeconds() - (M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refiTimeLastTriedBuildingTransport] or -100) >= 180)) then
                M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refiTimeLastTriedBuildingTransport] = GetGameTimeSeconds()
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryTransport - categories.TECH3 - categories.EXPERIMENTAL) then
                    return sBPIDToBuild
                end
            end

            --Determine the AirAA category to produce
            local iAirAASearchCategory
            if iFactoryTechLevel < 3 and not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbOnlyGetASFs]) then
                iAirAASearchCategory = M28UnitInfo.refCategoryAirAA
            else
                iAirAASearchCategory = M28UnitInfo.refCategoryAirAA * categories.TECH3
            end
            local iAirAACountOfSearchCategory = aiBrain:GetCurrentUnits(iAirAASearchCategory)

            --Priority asf for campaign missions
            iCurrentConditionToTry = iCurrentConditionToTry + 1
            if bDebugMessages == true then LOG(sFunctionRef..': Priority asf for campaign maps, iFactoryTechLevel='..iFactoryTechLevel..'; iAirAACountOfSearchCategory='..iAirAACountOfSearchCategory..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiOurAirAAThreat]='..M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiOurAirAAThreat]) end
            if M28Map.bIsCampaignMap and iFactoryTechLevel >= 3 and iAirAACountOfSearchCategory <= 100 and (M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives]) == false or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 10000) and M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiOurAirAAThreat] < math.min(20000, M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.5) then
                if bDebugMessages == true then LOG(sFunctionRef..': Campaign specific logic - will get base level of air threat hten get asfs as a high priority') end
                local iAirSubteam = aiBrain.M28AirSubteam
                --Base level of gunship and torp bomber threat before considering to get asf, assuming we have a base level of asf
                if M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] <= 1000 then
                    if ConsiderBuildingCategory(iAirAASearchCategory) then return sBPIDToBuild end
                end

                --Gunships
                if M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] <= 600 then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryGunship) then return sBPIDToBuild end
                end

                --Torp bomber if need them
                if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbNoAvailableTorpsForEnemies] and M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurTorpBomberThreat] <= 2500 then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryTorpBomber) then return sBPIDToBuild end
                end

                if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirAA * categories.TECH3) then return sBPIDToBuild end
            end


            --General production - depends on if we have highest tech level, or if we dont have t3 air yet
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Deciding next decisions based on how high a tech level we are, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Highest air factory tech=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech])
            end
            if iFactoryTechLevel < math.min(3, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 or ((not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 2500) and (M28Conditions.GetFactoryLifetimeCount(oFactory, nil, true) >= 25) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4)) then
                --We dont want to build units in most cases as T3 versions are available

                --Consider upgrading if dont have active upgrade in this LZ
                --Upgrade factory if this LZ is lagging behind tech wise
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': is table of active upgrades for this LZ empty=' .. tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades])))
                end
                local bUpgradingAirFactory = false
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then
                    for iUnit, oUnit in tLZTeamData[M28Map.subrefActiveUpgrades] do
                        if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oUnit.UnitId) and M28UnitInfo.GetUnitTechLevel(oUnit) >= iFactoryTechLevel then
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Have an active land factory upgrade=' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit.UnitId) .. '; Is unit valid=' .. tostring(M28UnitInfo.IsUnitValid(oUnit)) .. '; Fraction complete=' .. oUnit:GetFractionComplete() .. '; Work progress=' .. oUnit:GetWorkProgress())
                            end
                            bUpgradingAirFactory = true
                            break
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': bUpgradingAirFactory already='..tostring(bUpgradingAirFactory)) end
                if not (bUpgradingAirFactory) then
                    if ConsiderUpgrading() then
                        return sBPIDToBuild
                    end
                end

                --Build engis if are very high mass
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Should we build engis due to high mass? bHaveLowMass=' .. tostring(bHaveLowMass) .. '; Highest % stored=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored])
                end
                if tLZTeamData[M28Map.subrefTbWantBP] and not (bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5 then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                        return sBPIDToBuild
                    end
                end

                --Bomber if high mass and fewer than 100
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to get bombers alt, bHaveLowMass='..tostring(bHaveLowMass)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; Current bombers='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryBomber)) end
                if not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.7 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryBomber) <= 100 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to get more bombers') end
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryBomber) then return sBPIDToBuild end
                end
            else
                --We have suitably high tech level to consider normal air production (and engineer production)
                --High mass - build more engineers
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': High mass engi builder: bHaveLowMass=' .. tostring(bHaveLowMass) .. '; Lowest mass % stored=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored])
                end
                if tLZTeamData[M28Map.subrefTbWantBP] and not (bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                        return sBPIDToBuild
                    end
                end

                --Adjacent water zone with enemy surface combat threats
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbNoAvailableTorpsForEnemies] and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
                    local iAdjWZ
                    for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                        iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                        local tAdjWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Considering high priority air builder, iAdjWZ=' .. iAdjWZ .. '; tAdjWZTeamData[M28Map.subrefbWZOnlyHoverEnemies]=' .. tostring(tAdjWZTeamData[M28Map.subrefbWZOnlyHoverEnemies] or false) .. '; tAdjWZTeamData[M28Map.subrefWZThreatEnemySurface]=' .. tAdjWZTeamData[M28Map.subrefWZThreatEnemySurface])
                        end
                        if tAdjWZTeamData[M28Map.subrefWZThreatEnemySurface] > 0 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build torp bombers (if non hover), or gunships, or failing that bombers') end
                            if not(tAdjWZTeamData[M28Map.subrefbWZOnlyHoverEnemies]) then
                                if ConsiderBuildingCategory(M28UnitInfo.refCategoryTorpBomber) then return sBPIDToBuild end
                            end
                            if ConsiderBuildingCategory(M28UnitInfo.refCategoryGunship) then return sBPIDToBuild end
                            if ConsiderBuildingCategory(M28UnitInfo.refCategoryBomber) then return sBPIDToBuild end
                        end
                    end
                end

                --Air scout if dont have any and havent built many at this factory
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                local iCurAirScouts = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirScout)
                if bDebugMessages == true then LOG(sFunctionRef..': Air scout checker, cur air scouts='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirScout)..'; Lifetime air scout count for htis factory='..M28Conditions.GetFactoryLifetimeCount(oFactory, M28UnitInfo.refCategoryAirScout)..'; Total factory count of all units='..oFactory[refiTotalBuildCount]) end
                if iCurAirScouts == 0 and M28Conditions.GetFactoryLifetimeCount(oFactory, M28UnitInfo.refCategoryAirScout) <= math.floor(oFactory[refiTotalBuildCount] * 0.1) then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirScout) then return sBPIDToBuild end
                end

                --AirAA until have a minimum level
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if bDebugMessages == true then LOG(sFunctionRef .. ': Minimum level of AirAA wanted: Number we have currently=' .. aiBrain:GetCurrentUnits(iAirAASearchCategory)) end
                if iAirAACountOfSearchCategory < 3 then
                    if bDebugMessages == true then LOG(sFunctionRef..': We have fewer than 3 of AirAA search category, iFactoryTechLevel='..iFactoryTechLevel) end
                    if ConsiderBuildingCategory(iAirAASearchCategory) then
                        return sBPIDToBuild
                    end
                end

                --Torpedo bombers if nearby navy
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if bDebugMessages == true then LOG(sFunctionRef .. ': Torp bomber for nearby enemy navy: iFactoryTechLevel=' .. iFactoryTechLevel .. '; Is table of adjacent WZ empty=' .. tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
                if iFactoryTechLevel >= 2 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                    local iNearbyEnemyNavalThreat = 0
                    local iAdjWZ
                    for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                        iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                        local tAdjWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Considering iAdjWZ=' .. iAdjWZ .. '; tAdjWZTeamData[M28Map.subrefbWZOnlyHoverEnemies]=' .. tostring(tAdjWZTeamData[M28Map.subrefbWZOnlyHoverEnemies] or false) .. '; tAdjWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. tAdjWZTeamData[M28Map.subrefTThreatEnemyCombatTotal])
                        end
                        if not (tAdjWZTeamData[M28Map.subrefbWZOnlyHoverEnemies]) then
                            iNearbyEnemyNavalThreat = iNearbyEnemyNavalThreat + tAdjWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]
                        end
                    end
                    if iNearbyEnemyNavalThreat > 0 then
                        --Do we have enough torp bombers? want basic level ourselves, and then more for large threats
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Our torp bomber threat=' .. M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurTorpBomberThreat] .. '; iNearbyEnemyNavalThreat=' .. iNearbyEnemyNavalThreat)
                        end
                        if M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurTorpBomberThreat] < iNearbyEnemyNavalThreat * 1.5 then
                            if ConsiderBuildingCategory(M28UnitInfo.refCategoryTorpBomber) then
                                return sBPIDToBuild
                            end
                        end
                    end
                end

                --Gunship if dont have at least 3
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                local iCurGunships = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryGunship)
                if iCurGunships < 2 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Fewer than 2 gunships so will try and get a gusnhip') end
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryGunship) then return sBPIDToBuild end
                end

                --Air scout if dont have any
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if bDebugMessages == true then LOG(sFunctionRef..': Will get air scouts if dont have any; iCurrentConditionToTry='..iCurrentConditionToTry) end
                if iCurAirScouts == 0 then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirScout) then return sBPIDToBuild end
                end

                --Engineers if we need them for our core zone and are at T3 and are defending against arti, and are building <= 2 engineers in this zone
                if tLZTeamData[M28Map.subrefTbWantBP] and iFactoryTechLevel >= 3 and (M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 500) then
                    local iCurBPWanted = tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][1] + tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][2] + tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][3]
                    if iCurBPWanted > 30 then
                        local iCurEngineersBeingBuilt = M28Conditions.GetNumberOfUnitsCurrentlyBeingBuiltOfCategoryInZone(tLZTeamData, M28UnitInfo.refCategoryEngineer * categories.TECH3)
                        if (iCurEngineersBeingBuilt <= 2 or not(bHaveLowMass)) and iCurEngineersBeingBuilt * M28Engineer.tiBPByTech[3] < iCurBPWanted then
                            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end
                        end
                    end
                end

                --Do we lack enough torpedo bombers to target enemy navy?
                if bDebugMessages == true then LOG(sFunctionRef..': About to consider getting torp bombers, iFactoryTechLevel='..iFactoryTechLevel..'; time='..GetGameTimeSeconds()..'; M28Team.tAirSubteamData[iAirSubteam][M28Team.refbNoAvailableTorpsForEnemies]='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbNoAvailableTorpsForEnemies] or false)..'; M28Team.tAirSubteamData[iAirSubteam][M28Team.refbTooMuchGroundNavalAAForTorpBombers]='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbTooMuchGroundNavalAAForTorpBombers])..'; M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir]='..tostring(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir])..'; M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurTorpBomberThreat]='..M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurTorpBomberThreat]..'; M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat]='..M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat]) end
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if iFactoryTechLevel >= 2 and (M28Team.tAirSubteamData[iAirSubteam][M28Team.refbNoAvailableTorpsForEnemies] or M28Team.tAirSubteamData[iAirSubteam][M28Team.refbTooMuchGroundNavalAAForTorpBombers]) then
                    --Are we far behind on air?
                    if M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir] then
                        if M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] > M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurTorpBomberThreat] then
                            if ConsiderBuildingCategory(M28UnitInfo.refCategoryTorpBomber) then return sBPIDToBuild end
                        end
                    else
                        --Not far behind on air so get more torps
                        if bDebugMessages == true then LOG(sFunctionRef..': Not far behind on air so will try and get more torp bombers') end
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryTorpBomber) then return sBPIDToBuild end
                    end
                end

                --Bombers if have nearby enemy navy (and no torp bombers)
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbNoAvailableTorpsForEnemies] and M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurTorpBomberThreat] == 0 and M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurBomberThreat] + M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurTorpBomberThreat] + M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] <= 1000 then
                    --Do we have an adjacent water zone that has enemies
                    local bNearbyNavalThreat = false
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                            local iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                            local tAdjWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                            if tAdjWZTeamData[M28Map.subrefWZThreatEnemySurface] > 0 then
                                bNearbyNavalThreat = true
                            end
                        end
                    end
                    if bNearbyNavalThreat then
                        --Get bomber or gunship of any kind (torp bombers in preference to normal bombers)
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryTorpBomber) then return sBPIDToBuild end
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryGunship) then return sBPIDToBuild end
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryBomber) then return sBPIDToBuild end
                    end
                end


                --AirAA in proportion to gunship+bomber threat (based on if far behind on air or not); if have air control then only get if dont have low mass
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                local iAirAAWanted = M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 100
                if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir] then
                    iAirAAWanted = math.max(iAirAAWanted * 2, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] * 3 + math.max(0, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] - 4000) * 2 + M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurBomberThreat] * 2)
                elseif not (M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl]) then
                    iAirAAWanted = math.max(iAirAAWanted * 1.5, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] * 2 + math.max(0, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] - 4000) * 1.5 + M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurBomberThreat])
                else
                    --We have air control
                    iAirAAWanted = math.max(iAirAAWanted, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] * 0.75 + math.max(0, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] - 4000) * 0.3 + M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurBomberThreat] * 0.75)
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Will consider getting AirAA in proportion to gunship threat now, Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..';  M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurBomberThreat]='.. M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurBomberThreat]..'; M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat]='..M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat]..'; M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat]='..M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat]..'; iAirAAWanted='..iAirAAWanted) end
                if iAirAACountOfSearchCategory < 400 and M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] < iAirAAWanted and (not (bHaveLowMass) or not (M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl])) then
                    --Cap total number of AirAA built bsaed on enemy threat
                    if iAirAASearchCategory and ConsiderBuildingCategory(iAirAASearchCategory) then return sBPIDToBuild end
                end

                --Gunships subject to mass and existing number
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if iCurGunships < 5 or (not (bHaveLowMass) and iCurGunships < 40 and (not(M28Map.bIsCampaignMap) or iCurGunships < 100) and
                        (iCurGunships < 22 or (iFactoryTechLevel >= 3 and aiBrain[M28Economy.refiGrossMassBaseIncome] >= 20) or ((M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.3 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.2 and M28Map.bIsCampaignMap)) and M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] <= 2 or M28Map.bIsCampaignMap)))) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have a large number of gunships so will get more') end
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryGunship) then return sBPIDToBuild end
                end

                --AirAA if far behind on air (lower priority since we are alreayd building in proportion to gunships above; i.e. dont want to get stuck only building airaa if have lost air control
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if bDebugMessages == true then LOG(sFunctionRef..': AirAA if far behind on air, iCurrentConditionToTry='..iCurrentConditionToTry..'; are we far behind='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir])) end
                if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir] and (iAirAACountOfSearchCategory < 20 or (iCurGunships >= iAirAACountOfSearchCategory * 0.25 and (not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbNoAvailableTorpsForEnemies]) or M28Team.tAirSubteam[iAirSubteam][M28Team.subrefiOurTorpBomberThreat] >= 2500))) then
                    if iFactoryTechLevel >= 3 or not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbOnlyGetASFs]) then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirAA) then return sBPIDToBuild end
                    end
                end

                --Transport if locations to drop
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if (M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftTransportIslandDropShortlist]) == false or M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftTransportFarAwaySameIslandPlateauLandZoneDropShortlist]) == false) and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryTransport) == 0 then
                    if GetGameTimeSeconds() - (M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refiTimeLastTriedBuildingTransport] or -100) >= 120 then
                        M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refiTimeLastTriedBuildingTransport] = GetGameTimeSeconds()
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryTransport - categories.TECH3 - categories.EXPERIMENTAL) then return sBPIDToBuild end
                    end
                end

                --AirAA if dont have low mass and lack air control and are at T3
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if iAirAACountOfSearchCategory < 400 and not (bHaveLowMass) and not (M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl]) and iFactoryTechLevel >= 3 then
                    if iFactoryTechLevel >= 3 or not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbOnlyGetASFs]) then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirAA) then return sBPIDToBuild end
                    end
                end

                --T3 bomber if have high mass and are at T3 (incase e.g. the T2 gunship cap has bitten)
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if not (bHaveLowMass) and iFactoryTechLevel >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 5000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.75 then
                    if tLZTeamData[M28Map.subrefTbWantBP] then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end --redundancy
                    end
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryBomber * categories.TECH3) then return sBPIDToBuild end
                end

                --Bombers if have enemies in adjacent water zone and no enemy air units in cur zone, or AirAA if enemy air units are there, up to a distance of 250
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) then
                    M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, oFactory:GetPosition())
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                        for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                            if tSubtable[M28Map.subrefiDistance] >= math.min(M28Map.iMapSize * 0.5, 250) then break end
                            local tLZOrWZData
                            local tLZOrWZTeamData
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering zone '..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..'; Is water zone='..tostring(tSubtable[M28Map.subrefbIsWaterZone])..'; Plateau or pond='..tSubtable[M28Map.subrefiPlateauOrPond]) end
                            if tSubtable[M28Map.subrefbIsWaterZone] then
                                tLZOrWZData = M28Map.tPondDetails[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                            else
                                --Plateau
                                tLZOrWZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                            end
                            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                                if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbNoAvailableTorpsForEnemies] then
                                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryTorpBomber) then return sBPIDToBuild end
                                end
                                if ConsiderBuildingCategory(M28UnitInfo.refCategoryGunship) then return sBPIDToBuild end
                                if ConsiderBuildingCategory(M28UnitInfo.refCategoryBomber) then return sBPIDToBuild end
                            elseif tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] + tLZOrWZTeamData[M28Map.refiEnemyAirAAThreat] + tLZOrWZTeamData[M28Map.refiEnemyAirOtherThreat] > 0 then
                                if iAirAACountOfSearchCategory < 400 and (iAirAACountOfSearchCategory < 150 or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] >= iAirAACountOfSearchCategory * 200) then
                                    if ConsiderBuildingCategory(iAirAASearchCategory) then return sBPIDToBuild end
                                end
                            end
                        end
                    end
                end

                --AirAA if high mass and lack air control
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if bDebugMessages == true then LOG(sFunctionRef..'; AirAA if high mass and lack air control, iCurrentConditionToTry='..iCurrentConditionToTry..'; iAirAACountOfSearchCategory='..iAirAACountOfSearchCategory..'; Have low mass='..tostring(bHaveLowMass)..'; Mass%='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; Have air control='..tostring(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl])..'; AirAA threat='..M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiOurAirAAThreat]) end
                if iAirAACountOfSearchCategory < 400 and not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 and (not(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl]) or M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiOurAirAAThreat] <= 750 * iFactoryTechLevel) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Low priority AirAA builder') end
                    if iFactoryTechLevel >= 3 or not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbOnlyGetASFs]) then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryAirAA) then return sBPIDToBuild end
                    end
                end

                --Gunship if we dont have low mass (or are in a campaign with at least 500 mass stored and no active upgrades) and have air control
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if bDebugMessages == true then LOG(sFunctionRef..': Low priority gunship builder, iFactoryTechLevel='..iFactoryTechLevel..'; Lowest air fac tech='..M28Team.tTeamData[iTeam][M28Team.subrefiLowestFriendlyAirFactoryTech]..'; have air control='..tostring(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl])..'; Have low mass='..tostring(bHaveLowMass)..'; CampaignMap='..tostring(M28Map.bIsCampaignMap)..'; team mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Is table of upgrading HQs empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]))..'; Is table of upgrading mexes empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]))) end
                if iCurGunships <= 200 and iFactoryTechLevel >= M28Team.tTeamData[iTeam][M28Team.subrefiLowestFriendlyAirFactoryTech] and M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl] and (not(bHaveLowMass) or (M28Map.bIsCampaignMap and iFactoryTechLevel >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 500 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]))) then
                    --Either build gunships or AirAA dpeending on which we have less of
                    if bDebugMessages == true then LOG(sFunctionRef..': Will try to build a gunship as have air control') end
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryGunship) then return sBPIDToBuild end
                end

                --Campaign specific - bombers if we lack gunship and bomber threat
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if iCurGunships == 0 and iFactoryTechLevel < 3 and M28Team.tTeamData[iTeam][M28Team.subrefiLowestFriendlyAirFactoryTech] < 3 and (M28Map.bIsCampaignMap or M28Overseer.bUnitRestrictionsArePresent) and M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] == 0 and M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiOurBomberThreat] < 1500 then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryGunship) then return sBPIDToBuild end --redundancy but unlikely we can build them
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryBomber) then return sBPIDToBuild end
                end

                --Bomber if high mass and fewer than 100
                iCurrentConditionToTry = iCurrentConditionToTry + 1
                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to get bombers, bHaveLowMass='..tostring(bHaveLowMass)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; Current bombers='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryBomber)) end
                if not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.7 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryBomber) <= 100 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to get more bombers') end
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryBomber) then return sBPIDToBuild end
                end
            end
        end

    end
    --Engineers if thisi s an Air HQ and we need BP of this tech level or lower, and have at least 1k mass stored on our team with positive mass income
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 1000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0 and EntityCategoryContains(M28UnitInfo.refCategoryAirHQ, oFactory.UnitId) and tLZTeamData[M28Map.subrefTbWantBP] and aiBrain[M28Economy.refiGrossMassBaseIncome] >= 3 then
        local bWantBPOfThisTech = false
        for iCurTech = iFactoryTechLevel, 1, -1 do
            if tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iCurTech] > 0 then
                bWantBPOfThisTech = true
                break
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Air fac last builder for engineers at an air HQ, bWantBPOfThisTech='..tostring(bWantBPOfThisTech)..'; iFactoryTechLevel='..iFactoryTechLevel) end
        if bWantBPOfThisTech then if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end end
    end


    if iFactoryTechLevel >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] then
        M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadNothingToBuildForAirFactory] = GetGameTimeSeconds()
        tLZTeamData[M28Map.subrefiTimeAirFacHadNothingToBuild] = GetGameTimeSeconds()
    end
    oFactory[refiTimeSinceLastFailedToGetOrder] = GetGameTimeSeconds() --Redundancy, will also include in parent logic
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetBlueprintToBuildForNavalFactory(aiBrain, oFactory)
    local sFunctionRef = 'GetBlueprintToBuildForNavalFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCategoryToBuild
    local iWaterZone = M28Map.GetWaterZoneFromPosition(oFactory:GetPosition())
    local iPond = M28Map.tiPondByWaterZone[iWaterZone]
    local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
    local iTeam = aiBrain.M28Team
    local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
    local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
    local tiMAAThresholdByTech = { 50, 500, 1000, 1000 }

    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
    local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)



    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Near start of code, time=' .. GetGameTimeSeconds() .. '; oFactory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; Checking if we have the highest tech land factory in the current land zone, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Highest friendly factory tech=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech])
    end

    local bConsiderBuildingShieldOrStealthBoats = true
    --Shield boat needs 10 energy per tick; same for stealth boat; dont want this to account for more than 20% of gross energy; so want 50 gross energy per tick per shield boat for it to be <20%
    if bHaveLowPower or iFactoryTechLevel == 1 then
        bConsiderBuildingShieldOrStealthBoats = false
    else
        if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoShieldBoatTargetsByPond][iPond] or -100) <= 5 and EntityCategoryContains(categories.UEF, oFactory.UnitId) then
            bConsiderBuildingShieldOrStealthBoats = false
        else
            local iCurShieldAndStealthBoats = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryShieldBoat + M28UnitInfo.refCategoryStealthBoat)
            local iEnergyMod = 1
            if tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
                iEnergyMod = 2.5
            end
            if aiBrain[M28Economy.refiGrossEnergyBaseIncome] < (1 + iCurShieldAndStealthBoats) * 50 * iEnergyMod then
                bConsiderBuildingShieldOrStealthBoats = false
            elseif iCurShieldAndStealthBoats >= 5 then
                --Want to be a T3 factory and have at least 5 T3 naval units before building more shield boats
                bConsiderBuildingShieldOrStealthBoats = false
                if iFactoryTechLevel >= 3 and iCurShieldAndStealthBoats <= 22 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalSurface * categories.TECH3) >= 10 then
                    bConsiderBuildingShieldOrStealthBoats = true
                elseif iCurShieldAndStealthBoats <= 10 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalSurface * categories.TECH3 + M28UnitInfo.refCategoryDestroyer + M28UnitInfo.refCategoryCruiser) * 1.5 > iCurShieldAndStealthBoats then
                    bConsiderBuildingShieldOrStealthBoats = true
                end
            end
        end
    end
    local bUseFrigatesAsScouts = M28Team.tTeamData[iTeam][M28Team.subrefbUseFrigatesAsScoutsByPond][iPond]
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Finished checking if we want to consider building shield/stealth boats, bConsiderBuildingShieldOrStealthBoats=' .. tostring(bConsiderBuildingShieldOrStealthBoats) .. '; Cur shield and stealth boats=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryShieldBoat + M28UnitInfo.refCategoryStealthBoat) .. '; bHaveLowPower=' .. tostring(bHaveLowPower) .. '; Cur T3 navy and destroyer+cruiser=' .. aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalSurface * categories.TECH3 + M28UnitInfo.refCategoryDestroyer + M28UnitInfo.refCategoryCruiser))
    end

    iCategoryToBuild = M28UnitInfo.refCategoryEngineer --Placeholder
    local sBPIDToBuild
    local iCurrentConditionToTry = 0

    --subfunctions to mean we can do away with the 'current condition == 1, == 2.....==999 type approach making it much easier to add to
    function ConsiderBuildingCategory(iCategoryToBuild)
        sBPIDToBuild = GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oFactory, nil, nil, nil, nil, false)
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Time=' .. GetGameTimeSeconds() .. ' Factory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; WZ=' .. iWaterZone .. '; iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; sBPIDToBuild before adjusting for override=' .. (sBPIDToBuild or 'nil'))
        end
        if sBPIDToBuild then
            sBPIDToBuild = AdjustBlueprintForOverrides(aiBrain, oFactory, sBPIDToBuild, tWZTeamData, iFactoryTechLevel)
        end
        if sBPIDToBuild then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd) --Assumes we will end code if we get to this point
            return sBPIDToBuild
        end
    end

    function ConsiderUpgrading()
        sBPIDToBuild = M28UnitInfo.GetUnitUpgradeBlueprint(oFactory, true)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return sBPIDToBuild
    end


    --MAIN BUILDER LOGIC:
    --Cycle through each naval zone and decide what units to get
    local iCurFrigates = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFrigate)
    local bConsiderBuildingMoreCombat = true

    local iCombatCategory
    if iFactoryTechLevel <= 1 then
        iCombatCategory = M28UnitInfo.refCategoryFrigate
        if iCurFrigates >= 75 then bConsiderBuildingMoreCombat = false end
        if bDebugMessages == true then LOG(sFunctionRef..' Combat category is to just build frigates') end
    elseif iFactoryTechLevel <= 2 then
        if iCurFrigates < 75 and math.random(0, 1) == 1 then
            iCombatCategory = M28UnitInfo.refCategoryFrigate
            if bDebugMessages == true then LOG(sFunctionRef..' Combat category is to build frigates instead of destroyers') end
        else
            iCombatCategory = M28UnitInfo.refCategoryDestroyer
            if bDebugMessages == true then LOG(sFunctionRef..' Combat category is to build destroyer') end
        end
    else
        --T3+
        local iCurDestroyerAndBattlecruiser = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryDestroyer + M28UnitInfo.refCategoryBattlecruiser)

        local iCurBattleships = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryBattleship)
        if iCurFrigates == 0 or iCurFrigates <= iCurDestroyerAndBattlecruiser and not (aiBrain[M28Overseer.refbCloseToUnitCap]) and iCurFrigates <= 75 then
            iCombatCategory = M28UnitInfo.refCategoryFrigate
        elseif iCurDestroyerAndBattlecruiser == 0 or iCurDestroyerAndBattlecruiser < iCurBattleships then
            iCombatCategory = M28UnitInfo.refCategoryDestroyer + M28UnitInfo.refCategoryBattlecruiser
        else
            iCombatCategory = M28UnitInfo.refCategoryBattleship
        end
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Finished getting combat category, iCurDestroyerAndBattlecruiser=' .. iCurDestroyerAndBattlecruiser .. '; iCurFrigates=' .. iCurFrigates .. '; iCurBattleships=' .. iCurBattleships)
        end
    end

    --High priority engineer if we started in water
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
        if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) < 3 or (iFactoryTechLevel <= 2 and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer) <= 10) then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Water start, will get high priority engineer')
            end
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                return sBPIDToBuild
            end
        end
    end

    --High priority anti-air if we have a battleship and no cruiser, or alternatively if we have 3 destroyers and no cruiser
    local iCurCruiserCarrier = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryCruiserCarrier)
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Checking if we want to get cruisers, iCurCruiserCarrier=' .. iCurCruiserCarrier)
    end
    if iCurCruiserCarrier == 0 and iFactoryTechLevel >= 2 and (
            aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryBattleship) + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryBattlecruiser) > 0
                    or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryDestroyer) >= 3) then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Will try get High priority cruiser')
        end
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryCruiser) then
            return sBPIDToBuild
        end
    end

    --First consider zone we are in
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering immediate needs for cur WZ that are in, tWZTeamData[M28Map.subrefWZThreatEnemySubmersible]=' .. tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] .. '; tWZTeamData[M28Map.subrefWZThreatEnemySurface]=' .. tWZTeamData[M28Map.subrefWZThreatEnemySurface] .. '; tWZTeamData[M28Map.refiEnemyAirToGroundThreat]=' .. tWZTeamData[M28Map.refiEnemyAirToGroundThreat] .. '; tWZTeamData[M28Map.refbWZWantsMobileShield]=' .. tostring(tWZTeamData[M28Map.refbWZWantsMobileShield]) .. '; tWZTeamData[M28Map.refbWZWantsMobileStealth]=' .. tostring(tWZTeamData[M28Map.refbWZWantsMobileStealth]))
    end
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] > 0 then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Immediate threat - want antinavy')
        end
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryAntiNavy - categories.SILO) then
            return sBPIDToBuild
        end
    end

    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if tWZTeamData[M28Map.subrefWZThreatEnemySurface] > 0 then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Immediate threat - want frigate')
        end
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryFrigate) then
            return sBPIDToBuild
        end --Want frigate as enemy is close
    end

    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
        if EntityCategoryContains(categories.AEON, oFactory.UnitId) or tWZTeamData[M28Map.refiEnemyAirToGroundThreat] >= math.max(100, (tWZTeamData[M28Map.subrefWZThreatAlliedAA] or 0) * 0.5) then
            if bDebugMessages == true then LOG(sFunctionRef .. ': Immediate threat - want AA') end
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryNavalAA) then return sBPIDToBuild end
        else
            --Frigates should be a faster way of getting basic AA
            if bDebugMessages == true then LOG(sFunctionRef .. ': Immediate threat - want AA via frigate') end
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryNavalAA + M28UnitInfo.refCategoryFrigate) then return sBPIDToBuild end
        end
    end

    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bConsiderBuildingShieldOrStealthBoats and tWZTeamData[M28Map.refbWZWantsMobileShield] then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Want shielding for core WZ')
        end
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryShieldBoat) then return sBPIDToBuild end
    end

    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bConsiderBuildingShieldOrStealthBoats and tWZTeamData[M28Map.refbWZWantsMobileStealth] then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Want stealth for core WZ')
        end
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryStealthBoat) then return sBPIDToBuild end
    end

    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if iFactoryTechLevel == 2 then
        --Wnat first t2 unit to be a destroyer, assuming no immediate threats (per above)

        if M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryDestroyer) == 0 then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryDestroyer) then
                return sBPIDToBuild
            end
        end
    end

    --Have at least 1 of the current combat category unit
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Number of combat category units we have=' .. aiBrain:GetCurrentUnits(iCombatCategory)..'; bConsiderBuildingMoreCombat='..tostring(bConsiderBuildingMoreCombat))
    end
    if bConsiderBuildingMoreCombat and aiBrain:GetCurrentUnits(iCombatCategory) == 0 then
        if bDebugMessages == true then LOG(sFunctionRef..': will try and build more of combat category') end
        if ConsiderBuildingCategory(iCombatCategory) then
            return sBPIDToBuild
        end
    end

    --Upgrade naval fac as priority if enemy has better navy tech than us or we ahve lots of naval units; also in high mass scenarios where we already have T3 navy
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; About ot check if want to upgrade factory, iFactoryTechLevel=' .. iFactoryTechLevel .. '; Is table of active upgrades for WZ empty=' .. tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefActiveUpgrades])))
    end
    if iFactoryTechLevel < 3 and (oFactory[refiTotalBuildCount] >= 5 or iFactoryTechLevel < aiBrain[M28Economy.refiOurHighestNavalFactoryTech]) then
        local iActiveFactoryUpgrades = 0
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefActiveUpgrades]) == false then
            for iUnit, oUnit in tWZTeamData[M28Map.subrefActiveUpgrades] do
                if EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oUnit.UnitId) then
                    iActiveFactoryUpgrades = iActiveFactoryUpgrades + 1
                end
            end
        end
        local bConsiderUpgrading = false
        if iActiveFactoryUpgrades == 0 then
            bConsiderUpgrading = true
        else
            local iFactoriesInWZ = 0
            local tFactoriesInWZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subrefLZTAlliedUnits])
            if M28Utilities.IsTableEmpty(tFactoriesInWZ) == false then
                iFactoriesInWZ = table.getn(tFactoriesInWZ)
            end
            if iActiveFactoryUpgrades < iFactoriesInWZ * 0.5 and not (bHaveLowMass) and not (bHaveLowPower) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.3 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 25) then
                bConsiderUpgrading = true
            end
        end
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': bConsiderUpgrading=' .. tostring(bConsiderUpgrading) .. '; iActiveFactoryUpgrades=' .. iActiveFactoryUpgrades .. '; Is table of activeu pgrades empty=' .. tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefActiveUpgrades])))
        end
        if bConsiderUpgrading then
            local iUpgradeThreatThreshold
            local iGrossMassThreshold
            if iFactoryTechLevel == 1 then
                iUpgradeThreatThreshold = 1000
                iGrossMassThreshold = 4
            else
                iUpgradeThreatThreshold = 6000
                iGrossMassThreshold = 10
            end
            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech] > iFactoryTechLevel then
                iUpgradeThreatThreshold = iUpgradeThreatThreshold * 0.75
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Considering whether to upgrade, tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]=' .. tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] or false) .. '; tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]=' .. tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] .. '; iUpgradeThreatThreshold=' .. iUpgradeThreatThreshold)
            end
            if not (tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) or tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= iUpgradeThreatThreshold or aiBrain[M28Economy.refiGrossMassBaseIncome] >= 20 then
                --Do we have enough mass income to justify upgrading?
                if bHaveLowMass then
                    iGrossMassThreshold = iGrossMassThreshold * 1.25
                end
                --Lower threshold if enemy has better tech
                if M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech] then
                    iGrossMassThreshold = iGrossMassThreshold * 0.75
                end
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Considering whether to upgrade, Gross mass income=' .. aiBrain[M28Economy.refiGrossMassBaseIncome] .. '; iGrossMassThreshold=' .. iGrossMassThreshold)
                end
                if aiBrain[M28Economy.refiGrossMassBaseIncome] >= iGrossMassThreshold then
                    if bDebugMessages == true then LOG(sFunctionRef..': Mass income high enough so will try and upgrade naval fac') end
                    if ConsiderUpgrading() then
                        return sBPIDToBuild
                    end
                else
                    --Lower threshold if we have built lots of T2 units

                    local iLifetimeBuildCount = M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryNavalSurface * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Lifetime build amount of naval units=' .. M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryNavalSurface * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)))
                    end
                    if iLifetimeBuildCount >= 14 then
                        iGrossMassThreshold = iGrossMassThreshold * math.max(0.35, (1 - iGrossMassThreshold * 0.02))
                        if aiBrain[M28Economy.refiGrossMassBaseIncome] >= iGrossMassThreshold then
                            if bDebugMessages == true then LOG(sFunctionRef..': LC high enough so Will try and upgrade naval fac') end
                            if ConsiderUpgrading() then
                                return sBPIDToBuild
                            end
                        end
                    end
                end
            end
        end
    end

    --Medium priority engineer if no immediate threats in this zone, are in a water start position or high mass, and want more engineers due to having mass but not needing power
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Engi fi underwtaer start: tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]=' .. tostring(tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) .. '; tWZTeamData[M28Map.subrefTbWantBP]=' .. tostring(tWZTeamData[M28Map.subrefTbWantBP]) .. '; bHaveLowMass=' .. tostring(bHaveLowMass) .. '; aiBrain[M28Economy.refiGrossMassBaseIncome]=' .. aiBrain[M28Economy.refiGrossMassBaseIncome])
    end
    if tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] or (not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.2)  then
        if tWZTeamData[M28Map.subrefTbWantBP] and (not (bHaveLowMass) or (aiBrain[M28Economy.refiGrossMassBaseIncome] >= iFactoryTechLevel * 6)) then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
                return sBPIDToBuild
            end
        end
    end

    --Cycle through each adjacent water zone
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': About to cycle through other land and water zones, is table empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefOtherLandAndWaterZonesByDistance])))
    end
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
        local iOtherWZ
        local iOtherPond

        local iOurCumulativeAAThreat = tWZTeamData[M28Map.subrefWZThreatAlliedAA]
        local iOurCumulativeCombatThreat = tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]
        local bHaveWantedAA = false
        local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)

        for iEntry, tSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
            if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tWZData[M28Map.subrefMidpoint]) then
                iOtherWZ = tSubtable[M28Map.subrefWZAWZRef]
                iOtherPond = M28Map.tiPondByWaterZone[iOtherWZ]
                local tOtherWZTeamData = M28Map.tPondDetails[iOtherPond][M28Map.subrefPondWaterZones][iOtherWZ][M28Map.subrefWZTeamData][iTeam]
                iOurCumulativeAAThreat = iOurCumulativeAAThreat + tOtherWZTeamData[M28Map.subrefWZThreatAlliedAA]
                iOurCumulativeCombatThreat = iOurCumulativeCombatThreat + tOtherWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Considering iOtherWZ=' .. (iOtherWZ or 'nil') .. '; tOtherWZTeamData[M28Map.subrefbWZWantsSupport]=' .. tostring(tOtherWZTeamData[M28Map.subrefbWZWantsSupport] or false) .. '; tOtherWZTeamData[M28Map.subrefWZThreatEnemySurface]=' .. (tOtherWZTeamData[M28Map.subrefWZThreatEnemySurface] or 'nil') .. '; tOtherWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]=' .. (tOtherWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 'nil') .. '; tOtherWZTeamData[M28Map.subrefWZMAAThreatWanted]=' .. (tOtherWZTeamData[M28Map.subrefWZMAAThreatWanted] or 'nil') .. '; tOtherWZTeamData[M28Map.refbWZWantsMobileShield]=' .. tostring(tOtherWZTeamData[M28Map.refbWZWantsMobileShield] or false) .. '; tOtherWZTeamData[M28Map.refbWZWantsMobileStealth]=' .. tostring(tOtherWZTeamData[M28Map.refbWZWantsMobileStealth] or false) .. '; tOtherWZTeamData[M28Map.refbWantLandScout]=' .. tostring(tOtherWZTeamData[M28Map.refbWantLandScout] or false) .. '; bUseFrigatesAsScouts=' .. tostring(bUseFrigatesAsScouts or false) .. '; tOtherWZTeamData[M28Map.refiEnemyAirToGroundThreat]=' .. (tOtherWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 'nil') .. '; tOtherWZTeamData[M28Map.subrefWZThreatAlliedAA]=' .. (tOtherWZTeamData[M28Map.subrefWZThreatAlliedAA] or 'nil') .. '; iOurCumulativeAAThreat=' .. iOurCumulativeAAThreat .. '; iOurCumulativeCombatThreat=' .. iOurCumulativeCombatThreat..'; tOtherWZTeamData[M28Map.subrefWZThreatEnemySubmersible]='..tOtherWZTeamData[M28Map.subrefWZThreatEnemySubmersible]..'; tOtherWZTeamData[M28Map.subrefWZThreatAlliedAntiNavy]='..tOtherWZTeamData[M28Map.subrefWZThreatAlliedAntiNavy])
                end

                if tOtherWZTeamData[M28Map.subrefbWZWantsSupport] then
                    if tOtherWZTeamData[M28Map.subrefWZThreatEnemySubmersible] > tOtherWZTeamData[M28Map.subrefWZThreatAlliedAntiNavy] * 0.75 then
                        if bDebugMessages == true then LOG(sFunctionRef .. ': Will try and get antinavy') end
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryAntiNavy - categories.SILO) then
                            return sBPIDToBuild
                        end
                    end
                    if tOtherWZTeamData[M28Map.subrefWZThreatEnemySurface] > tOtherWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] * 0.75 then
                        --We want more combat, but first consider if we need more MAA
                        if bHaveWantedAA and iOurCumulativeCombatThreat > iOurCumulativeAAThreat * 1.5 then
                            if bDebugMessages == true then LOG(sFunctionRef .. ': Will try and get AA unless we already have lots and are at T1, Cur unit count='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalAA)) end
                            if iFactoryTechLevel > 1 or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalAA) < 100 then
                                if ConsiderBuildingCategory(M28UnitInfo.refCategoryNavalAA) then return sBPIDToBuild end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef .. ': Will try and get CombatCategory or (if that fails) a sub') end
                        if bConsiderBuildingMoreCombat then
                            if ConsiderBuildingCategory(iCombatCategory) then return sBPIDToBuild end
                            --Backup - build sub
                            if ConsiderBuildingCategory(M28UnitInfo.refCategorySubmarine) then return sBPIDToBuild end
                        end

                    end
                end
                if not (bHaveWantedAA) and (tOtherWZTeamData[M28Map.subrefWZMAAThreatWanted] or 0) > tiMAAThresholdByTech[iFactoryTechLevel] and iOurCumulativeAAThreat < iOurCumulativeCombatThreat then
                    bHaveWantedAA = true
                end

                if (tOtherWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) > 0 and (bHaveWantedAA or ((tOtherWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) > (tOtherWZTeamData[M28Map.subrefWZThreatAlliedAA] or 0) * 0.3)) then
                    if bDebugMessages == true then LOG(sFunctionRef .. ': Will try get AA unless t1 with lots') end
                    if iFactoryTechLevel > 1 or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalAA) < 100 then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryNavalAA) then return sBPIDToBuild end
                    end
                end
                if bConsiderBuildingShieldOrStealthBoats and tOtherWZTeamData[M28Map.refbWZWantsMobileShield] then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Will try and get shield boat')
                    end
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryShieldBoat) then
                        return sBPIDToBuild
                    end
                end
                if bConsiderBuildingShieldOrStealthBoats and tOtherWZTeamData[M28Map.refbWZWantsMobileStealth] then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Will try and get stealth boat')
                    end
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryStealthBoat) then
                        return sBPIDToBuild
                    end
                end
                if bUseFrigatesAsScouts and tOtherWZTeamData[M28Map.refbWantLandScout] and iCurFrigates <= 80 then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Will try and get frigate')
                    end
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryFrigate) then
                        return sBPIDToBuild
                    end
                end
            end
        end
        if bHaveWantedAA and iOurCumulativeAAThreat < iOurCumulativeCombatThreat and (iOurCumulativeAAThreat <= math.min(iOurCumulativeCombatThreat, 100) or oFactory[refiTotalBuildCount] <= 10 or (iFactoryTechLevel == 1 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalAA) <= 40 or iOurCumulativeAAThreat * 4 < iOurCumulativeCombatThreat) or (iFactoryTechLevel >= 2 and (aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalAA) <= 100 or iOurCumulativeAAThreat * 3 < iOurCumulativeCombatThreat))) then
            if bDebugMessages == true then LOG(sFunctionRef .. ': Will try and get AA as we have less than our combat threat, iOurCumulativeAAThreat='..iOurCumulativeAAThreat..'; iOurCumulativeCombatThreat='..iOurCumulativeCombatThreat..'; Factory build count='..oFactory[refiTotalBuildCount]) end
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryNavalAA) then return sBPIDToBuild end
        end
    end

    --Engis if high mass
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering engis due to having high mass, bHaveLowMass=' .. tostring(bHaveLowMass) .. '; tWZTeamData[M28Map.subrefTbWantBP]=' .. tostring(tWZTeamData[M28Map.subrefTbWantBP]))
    end
    if not (bHaveLowMass) and tWZTeamData[M28Map.subrefTbWantBP] then
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then
            return sBPIDToBuild
        end
    end

    --Bombardment units
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    local bAboutToOverflowMass = false
    if not (bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.8 then
        bAboutToOverflowMass = true
    end
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Consdering building bombardment category unit, bHaveLowMass=' .. tostring(bHaveLowMass) .. '; Do we have UEF or seraphim factory=' .. tostring(EntityCategoryContains(categories.UEF + categories.SERAPHIM, oFactory.UnitId)))
    end
    if iFactoryTechLevel >= 3 then
        local iCurBattleships = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryBattleship)
        if bAboutToOverflowMass or (iCurBattleships < 5 or (not (bHaveLowMass) or iCurBattleships <= 1)) then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryBattleship) then
                return sBPIDToBuild
            end
        end
    elseif iFactoryTechLevel == 2 then

        if EntityCategoryContains(categories.UEF + categories.SERAPHIM, oFactory.UnitId) then
            local iCurCruisers = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryCruiser)
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': UEF T2 naval fac, iCurCruisers=' .. iCurCruisers .. '; bAboutToOverflowMass=' .. tostring(bAboutToOverflowMass or false))
            end
            if bAboutToOverflowMass or (iCurCruisers <= 10 and (not (bHaveLowMass) or iCurCruisers <= 4)) then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryCruiser) then
                    return sBPIDToBuild
                end
            end
        else
            local iCurDestroyers = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryDestroyer)
            if bAboutToOverflowMass or (iCurDestroyers <= 8 and (not (bHaveLowMass) or iCurDestroyers < 4)) then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryDestroyer) then
                    return sBPIDToBuild
                end
            end
        end
    else
        if bConsiderBuildingMoreCombat and (bAboutToOverflowMass or (iCurFrigates <= 30 and (not (bHaveLowMass) or iCurFrigates <= 10))) then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryFrigate) then
                return sBPIDToBuild
            end
        end
    end

    --Overflowing - build something (e.g. to cover campaign scenarios)
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bAboutToOverflowMass and not(bHaveLowPower) then
        local iSurfaceCombatCount = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE)
        local iAACombatCount = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalAA)
        local iSubCount = aiBrain:GetCurrentUnits(M28UnitInfo.refCategorySubmarine)
        local iMaxCount = 30
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= 0.5 then iMaxCount = 10 end
        if iSurfaceCombatCount < iMaxCount or iAACombatCount < iMaxCount or iSubCount < iMaxCount then
            --First try and get based on whicih we have least of
            if iSurfaceCombatCount < iMaxCount and iSurfaceCombatCount <= iAACombatCount and iSurfaceCombatCount <= iSubCount then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE) then return sBPIDToBuild end
            end
            if iSubCount < iMaxCount and iSubCount <= iAACombatCount then
                if ConsiderBuildingCategory(M28UnitInfo.refCategorySubmarine) then return sBPIDToBuild end
            end
            if iAACombatCount < iMaxCount then
                if ConsiderBuildingCategory(M28UnitInfo.refCategorySubmarine) then return sBPIDToBuild end
            end

            --Now just try and get them if we dont have lots already
            if iSurfaceCombatCount < iMaxCount then
                ConsiderBuildingCategory(M28UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE)
            end
            if iSubCount < iMaxCount then
                if ConsiderBuildingCategory(M28UnitInfo.refCategorySubmarine) then return sBPIDToBuild end
            end
            if iAACombatCount < iMaxCount then
                if ConsiderBuildingCategory(M28UnitInfo.refCategorySubmarine) then return sBPIDToBuild end
            end
        end
    end

    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Have no categories to build')
    end
    oFactory[refiTimeSinceLastFailedToGetOrder] = GetGameTimeSeconds() --Redundancy, will also include in parent logic
    tWZTeamData[M28Map.subrefiTimeNavalFacHadNothingToBuild] = GetGameTimeSeconds()
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateLastBuiltTracker(oFactory, sBlueprint)
    if not (oFactory[refiBuildCountByBlueprint]) then
        oFactory[refiBuildCountByBlueprint] = {}
    end
    oFactory[refiBuildCountByBlueprint][sBlueprint] = (oFactory[refiBuildCountByBlueprint][sBlueprint] or 0) + 1

    --facs - track when last built to reduce risk of power stalling by building at multiple all at once (air fac) or mass stalling with land facs
    local aiBrain = oFactory:GetAIBrain()


    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oFactory:GetPosition())
    local tLZOrWZTeamData
    local iTeam = aiBrain.M28Team
    if (iLandOrWaterZone or 0) > 0 then
        if iPlateauOrZero == 0 then
            tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
        else
            tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
        end
        tLZOrWZTeamData[M28Map.refiTimeLastBuiltAtFactory] = GetGameTimeSeconds()
    end

end

function GetBlueprintToBuildForQuantumGateway(aiBrain, oFactory)
    local sFunctionRef = 'GetBlueprintToBuildForQuantumGateway'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCategoryToBuild
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oFactory:GetPosition(), true, oFactory)
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
    local iTeam = aiBrain.M28Team
    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
    local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)
    local bCanPathToEnemyWithLand = false
    if tLZData[M28Map.subrefLZIslandRef] == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) then
        bCanPathToEnemyWithLand = true
    end
    local sBPIDToBuild
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Near start of code, time=' .. GetGameTimeSeconds() .. '; oFactory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; bHvaeLowPower=' .. tostring(bHaveLowPower))
    end
    local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory) --to be safe given we include it in adjustblueprintforoverrides
    local iCurrentConditionToTry = 0

    function ConsiderBuildingCategory(iCategoryToBuild, bOptionalGetCheapest)
        sBPIDToBuild = GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oFactory, nil, nil, bOptionalGetCheapest, nil, false)
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Time=' .. GetGameTimeSeconds() .. ' Factory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; LZ=' .. iLandZone .. '; iCurrentConditionToTry=' .. iCurrentConditionToTry .. '; sBPIDToBuild before adjusting for override=' .. (sBPIDToBuild or 'nil'))
        end
        if sBPIDToBuild then
            sBPIDToBuild = AdjustBlueprintForOverrides(aiBrain, oFactory, sBPIDToBuild, tLZTeamData, iFactoryTechLevel)
        end
        if sBPIDToBuild then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd) --Assumes we will end code if we get to this point
            return sBPIDToBuild
        end
    end

    --Build RAS SACUs (note - FAF has bug as of May 2023 where SACUs dont benefit from AiX modifier - have added code in M28 to counteract/fix
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if not (bHaveLowPower) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 750 then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Will try to build RAS SACU')
        end
        --[[if aiBrain.CheatEnabled and M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultipler] >= 3.5 then
            if ConsiderBuildingCategory(categories.SUBCOMMANDER, true) then
                return sBPIDToBuild
            end--]]
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryRASSACU) then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Foudn a RAS SACU blueprint to build=' .. (sBPIDToBuild or 'nil'))
            end
            return sBPIDToBuild
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end