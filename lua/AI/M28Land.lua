---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 09/12/2022 07:49
---
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local NavUtils = M28Utilities.NavUtils
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
--local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
--local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')

--Global
tLZRefreshCountByTeam = {}
iTicksPerLandCycle = 11 --Set by ConsiderSlowdownForHighUnitCount; WaitTicks(11) is equivalent to WaitSeconds(1) i.e. will try and run logic for every unit over this amount of time; with high unit numbers will consider adjusting
--Land zone subteam data - see M28Map for main variables; threat specific values are included here

--Varaibles against specific units
reftiPlateauAndLZToMoveTo = 'M28LandPlatAndLZToMoveTo' --If tell a unit to mvoe to a LZ then will update this with the plateau and land zone wanted
refiCurrentAssignmentValue = 'M28LandAssignedValue' --when a combat unit is given an order for a land zone, the value of that land zone should be recorded
refiCurrentAssignmentPlateauAndLZ = 'M28LandAssignedPlatLZ' --returns {iPlateau, iLandZone} that the units orders have been coordinated by
refiTimeOfLastAssignment = 'M28LandLastAssignmenttime' --returns gametimeseconds that the unit was last assigned to the available units of a land zone
refiLastNegLZAssignment = 'M28LLstNgLZ' --If moving some butn ot all units to a zone wanting support due to it not having that big a threat, this gets recorded with the zone, to reduce instances where units get stuck
reftiRadarPlateauAndLandZonesCoveredByTeam = 'M28LandRadarLZs' --Returns talbes of {iPlateau, iLandZone} that the radar is providing the best radar coverage of
reftiRadarPlateauAndLandZonesCoveredByOmni = 'M28LandOmniLZs' --Returns talbes of {iPlateau, iLandZone} that the radar is providing some omni coverage of
refoSREnemyTarget = 'M28LndSRTrg' --If we have a SR unit told to target an enemy, this tracks it so we dont switch to retreat logic when we move into a new zone in pursuit
refiTimeOfSREnemyTarget = 'M28LndSRTTim' --Gametimeseconds
reftoUnitsToKillOnCompletion = 'M28RadCtrlK' --Table of units to ctrlk when this unit finishes construction
reftoAssignedMAAGuards = 'M28LAMAAGrd' --Table of MAA assigned to cover a unit (e.g. a fatboy)
refoAssignedUnitToGuard = 'M28LAMAAToG' --Unit that is being guarded/assisted (e.g. MAA assisting a fatboy)
iFatboyBaseMAACount = 6 --Number of MAA wanted as guards normally
iFatboySafeMAACount = 12 --Number of MAA wanted as guards if worried about restorer deathball/equivalent
refbFlaggedForPriorityScout = 'M28LndPrScFg' --true if we have flagged this unit wants a priority land scout
refiTimeLastBuiltLandScoutForUnit = 'M28LndTmLstBultLS' --Gametimeseconds that we last built a high priority land scout because of this unit
iIntelThresholdForPriorityScout = 50 --I.e. if have less than this radar coverage in a zone, then a skirmisher will consider flagging to ask for a priority scout
refiRaidingBasePlateau = 'M28LRdBP' --Plateau that built the unit raiding
refiRaidingBaseZone = 'M28LRdBZ' --LZ that built the unit raiding
refiRaidingTargetZone = 'M28LRdTr' --Target LZ for raiding

--See M28navy for sonar equivalent
refoAssignedMobileShield = 'M28LandAssignedMobileShield' --Gives the mobile shield assigned ot this unit
refoAssignedLandScout = 'M28ACULSc' --assigned land scout for the ACU or skirmisher/other unit requesting priority land scout
reftoAdditionalAssignedMobileShields = 'M28LandExtraMobS' --for units assigned multiple mobile shields (e.g. ACUs)
refoMobileShieldTarget = 'M28LandMobileShieldTarget' --Aginst mobile shield, returns the unit that the mobile shield is trying to protect
refoAssignedMobileStealth = 'M28LandAssignedMobileStealth' --If a mobile stealth is assigned to this unit, then returns the mobile stealth unit assigned
refoMobileStealthTarget = 'M28LandMobileStealthTarget' --Against mobile stleaht units, returns the unit the mobile stealth is trying to cover
refoLandScoutTarget = 'M28LndSTrg' --Against land scouts if assigned to follow a unit such as an ACU

function UpdateIfLandZoneWantsSupport(tLZTeamData, iPlateau, iLandZone, iTeam, bWantDFSupport, bWantIndirectSupport)
    tLZTeamData[M28Map.subrefbLZWantsSupport] = (bWantDFSupport or bWantIndirectSupport)
    tLZTeamData[M28Map.subrefbLZWantsDFSupport] = bWantDFSupport
    tLZTeamData[M28Map.subrefbLZWantsIndirectSupport] = bWantIndirectSupport
    if not(M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau]) then
        M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau] = {}
    end
    M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau][iLandZone] = tLZTeamData[M28Map.subrefbLZWantsSupport]
end


function GetUnitPlateauAndLandZoneOverride(oUnit)
    --Return true if have changed something
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnitPlateauAndLandZoneOverride'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iPossiblePlateau
    local iPossibleLZ
    local iBestPlateau
    local iBestLZ
    local bFoundAlternative

    if bDebugMessages == true then LOG(sFunctionRef..': Unit position='..repru(oUnit:GetPosition())..'; Reprs of unit assigned plateau and land zone by team='..reprs(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam])..'; Unit owner='..oUnit:GetAIBrain().Nickname..'; Unit owner team='..oUnit:GetAIBrain().M28Team..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; TIme='..GetGameTimeSeconds()) end

    --Dont override if we are an amphibious/hover unit that is showing as on water
    local iNavPlateau
    local iNavIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition())
    if not(iNavIsland) then
        iNavPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, oUnit:GetPosition())
        if iNavPlateau then
            if M28UnitInfo.GetUnitPathingType(oUnit) == M28Map.refPathingTypeHover then
                if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is on water and is amphibious or hover pathing, so makes sense that it doesnt have a valid land zone') end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return false
            end
        end
    end

    if M28Utilities.IsTableEmpty(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) == false then
        for iTeam, tTeamPlateauAndLZ in oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] do
            if tTeamPlateauAndLZ[2] > 0 then
                if iTeam == oUnit:GetAIBrain().M28Team and M28Utilities.IsTableEmpty(tTeamPlateauAndLZ) == false then
                    iBestPlateau = tTeamPlateauAndLZ[1]
                    iBestLZ = tTeamPlateauAndLZ[2]
                    break
                else
                    iPossiblePlateau = tTeamPlateauAndLZ[1]
                    iPossibleLZ = tTeamPlateauAndLZ[2]
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Just considered iTeam='..iTeam..'; tTeamPlateauAndLZ='..repru(tTeamPlateauAndLZ)..'; iBestPlateau='..(iBestPlateau or 'nil')..'; iBestLZ='..(iBestLZ or 'nil')..'; iPossiblePlateau='..(iPossiblePlateau or 'nil')..'; iPossibleLZ='..(iPossibleLZ or 'nil')) end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iBestPlateau='..(iBestPlateau or 'nil')..'; iBestLZ='..(iBestLZ or 'nil')..'; iPossiblePlateau='..(iPossiblePlateau or 'nil')..'; iPossibleLZ='..(iPossibleLZ or 'nil')) end
        if iBestPlateau and iBestLZ then
            M28Map.AddLocationToPlateauExceptions(oUnit:GetPosition(), iBestPlateau, iBestLZ)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        elseif iPossiblePlateau and iPossibleLZ then

            M28Map.AddLocationToPlateauExceptions(oUnit:GetPosition(), iPossiblePlateau, iPossibleLZ)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end
    else
        --If we look in a 2x2 box around the unit can we find a valid plateau?
        local iDistAdjust
        local tBasePosition = oUnit:GetPosition()

        for iBaseAdjust = 1, 3 do
            iDistAdjust = math.max(2, M28Map.iLandZoneSegmentSize) * iBaseAdjust
            local tLocationAdjust = {{-iDistAdjust,0}, {-iDistAdjust, -iDistAdjust}, {-iDistAdjust, iDistAdjust}, {0, -iDistAdjust}, {0, iDistAdjust}, {iDistAdjust, -iDistAdjust}, {iDistAdjust, 0}, {iDistAdjust,iDistAdjust}}
            if bDebugMessages == true then LOG(sFunctionRef..': Will look in a box around the unit to see if can find a valid plateau, iDistAdjust='..iDistAdjust) end
            for iEntry, tAdjustXZ in tLocationAdjust do
                iPossiblePlateau, iPossibleLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition({ tBasePosition[1] + tAdjustXZ[1], tBasePosition[2], tBasePosition[3] + tAdjustXZ[2] })
                if bDebugMessages == true then LOG(sFunctionRef..': Considering tBasePosition='..repru(tBasePosition)..'; tAdjustXZ='..repru(tAdjustXZ)..'; iPossiblePlateau='..(iPossiblePlateau or 'nil')..'; iPossibleLZ='..(iPossibleLZ or 'nil')..'; NavUtils plateau for this position='..(NavUtils.GetLabel(M28Map.refPathingTypeHover, { tBasePosition[1] + tAdjustXZ[1], tBasePosition[2], tBasePosition[3] + tAdjustXZ[2] }) or 'nil')) end
                if (iPossiblePlateau or 0) > 0 and (iPossibleLZ or 0) > 0 and M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones][iPossibleLZ] then
                    if bDebugMessages == true then LOG('Found a plateau override for oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at position '..repru(oUnit:GetPosition())..' and tAdjustXZ='..repru(tAdjustXZ)) end
                    bFoundAlternative = true
                    M28Map.AddLocationToPlateauExceptions(oUnit:GetPosition(), iPossiblePlateau, iPossibleLZ)
                    break
                end
            end
            if not(bFoundAlternative) then
                --Try in a 1x1 box around the unit to see if we can find a plateau that is land pathable, and if so, see if we can path to a land zone, and if so then update to record this as the closest land zone
                iDistAdjust = 1
                tLocationAdjust = {{0,0}, {-iDistAdjust,0}, {-iDistAdjust, -iDistAdjust}, {-iDistAdjust, iDistAdjust}, {0, -iDistAdjust}, {0, iDistAdjust}, {iDistAdjust, -iDistAdjust}, {iDistAdjust, 0}, {iDistAdjust,iDistAdjust}}
                if bDebugMessages == true then LOG(sFunctionRef..': Will look in a smaller radius box around the unit to see if can find a valid plateau, iDistAdjust='..iDistAdjust) end
                for iEntry, tAdjustXZ in tLocationAdjust do
                    local tAltLocation = { tBasePosition[1] + tAdjustXZ[1], tBasePosition[2], tBasePosition[3] + tAdjustXZ[2] }
                    iPossiblePlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tAltLocation)
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering tAltLocation='..repru(tAltLocation)..'; iPossiblePlateau='..(iPossiblePlateau or 'nil')..'; iPossibleLZ='..(iPossibleLZ or 'nil')..'; NavUtils land pathing label='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tAltLocation) or 'nil')..'; Is table of land zones for this plateau empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones]))) end
                    if (iPossiblePlateau or 0) > 0 and (NavUtils.GetLabel(M28Map.refPathingTypeLand, tAltLocation) or 0) > 0 then
                        --We have a plateau, but dont have a land zone for this position even though it is pathable by land - is there a land zone for this plateau nearby that can path here?
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering nearby LZs that might be able to path here, is table of LZs empty for plateau '..iPossiblePlateau..' = '..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones]))) end
                        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones]) == false then
                            local iClosestLZDist = 100000
                            local iClosestUnpathableLZDist = 100000
                            local iClosestUnpathableLZRef
                            local iCurLZDist
                            for iLandZone, tAltLZData in M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones] do
                                iCurLZDist = M28Utilities.GetDistanceBetweenPositions(tAltLocation, M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMidpoint])

                                if iCurLZDist < iClosestLZDist then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Can we path from alt location to midpoint of land zone '..iLandZone..' with iCurLZDist='..iCurLZDist..'='..tostring(NavUtils.CanPathTo(M28Map.refPathingTypeLand, tAltLocation, M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones][M28Map.subrefMidpoint]))) end
                                    if NavUtils.CanPathTo(M28Map.refPathingTypeLand, tAltLocation, M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones][M28Map.subrefMidpoint]) then
                                        if iCurLZDist < iClosestLZDist then
                                            iClosestLZDist = iCurLZDist
                                            iPossibleLZ = iLandZone
                                        end
                                    elseif not(iPossibleLZ) and iCurLZDist < iClosestUnpathableLZDist then
                                        iClosestUnpathableLZDist = iCurLZDist
                                        iClosestUnpathableLZRef = iLandZone
                                    end
                                end
                            end
                            if not(iPossibleLZ) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Couldnt find any LZs that are actually pathable, closest unpaathable dist='..iClosestUnpathableLZDist..'; if this is within 50 then will use this') end
                                if iClosestUnpathableLZDist < 50 then
                                    iPossibleLZ = iClosestUnpathableLZRef
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Finsihed considering alternative entries in 1x1 box, iPossiblePlateau='..(iPossiblePlateau or 'nil')..'; iPossibleLZ='..(iPossibleLZ or 'nil')..'; If couldnt find anywhere will draw this units position in red; plateau if use hover pathing='..(NavUtils.GetLabel('Hover', oUnit:GetPosition()) or 'nil'))
                        if not(iPossibleLZ) then M28Utilities.DrawLocation(oUnit:GetPosition(), 2) end
                    end
                    if (iPossiblePlateau or 0) > 0 and (iPossibleLZ or 0) > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Identified a backup land zone override for oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at position '..repru(oUnit:GetPosition())..' and tAdjustXZ='..repru(tAdjustXZ)..'; will add to list of exceptions, iPossibleLZ='..(iPossibleLZ or 'nil')) end
                        bFoundAlternative = true
                        M28Map.AddLocationToPlateauExceptions(oUnit:GetPosition(), iPossiblePlateau, iPossibleLZ)
                        break
                    end
                end
            end
            if bFoundAlternative then break end
        end

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bFoundAlternative
end

function ConsiderAddingPlateauOverrideForUnit(oUnit)
    --If unit doesnt show as having a plateau, it isnt attached, and it is on land then have its current position assigned  to the most recent plateau
    --Note - other places will also call override, this isnt the only function
    --returns true if has added an override
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderAddingPlateauOverrideForUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bMadeChange = false
    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; Unit position='..repru(oUnit:GetPosition())..'; Map height='..M28Map.iMapWaterHeight) end
    if oUnit.IsUnitState and not(oUnit:IsUnitState('Attached')) and oUnit:GetPosition()[2] > M28Map.iMapWaterHeight then
        local iCurPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, oUnit:GetPosition())
        if bDebugMessages == true then LOG(sFunctionRef..': Unit plateau from NavUtils='..(iCurPlateau or 'nil')) end
        if (iCurPlateau or 0) <= 0 then
            bMadeChange = GetUnitPlateauAndLandZoneOverride(oUnit)
        else
            --Have a valid plateau but for some reason dont have a land zone?
            local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnit:GetPosition())
            if bDebugMessages == true then LOG(sFunctionRef..': iSegmentX-Z='..iSegmentX..'-'..iSegmentZ..'; tLandZoneBySegment[iSegmentX][iSegmentZ]='..(M28Map.tLandZoneBySegment[iSegmentX][iSegmentZ] or 'nil')) end
            if not(M28Map.tLandZoneBySegment[iSegmentX][iSegmentZ]) then
                --If units are dropped from a transport onto water then this can happen, so check that this isnt the case
                if GetTerrainHeight(oUnit:GetPosition()[1], oUnit:GetPosition()[3]) > M28Map.iMapWaterHeight then
                    bMadeChange = GetUnitPlateauAndLandZoneOverride(oUnit)
                    if bDebugMessages == true then LOG(sFunctionRef..': bMadeChange after checking unit plateau and LZ override='..tostring(bMadeChange)) end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Wont consider override for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' because it appears to be in a water zone') end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bMadeChange
end

function RemoveUnitFromListOfUnitsTravelingToLandZone(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RemoveUnitFromListOfUnitsTravelingToLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[reftiPlateauAndLZToMoveTo]='..repru(oUnit[reftiPlateauAndLZToMoveTo])) end
    if oUnit[reftiPlateauAndLZToMoveTo] then
        local sUnitTableRef
        if EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit.UnitId) then
            sUnitTableRef = M28Map.subrefTScoutsTravelingHere
        else
            M28Utilities.ErrorHandler('Need to add code for this unit category')
        end
        if sUnitTableRef then
            local iTargetPlateau = oUnit[reftiPlateauAndLZToMoveTo][1]
            local iTargetLandZone = oUnit[reftiPlateauAndLZToMoveTo][2]
            local tTravelingUnits = M28Map.tAllPlateaus[iTargetPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][sUnitTableRef]
            if M28Utilities.IsTableEmpty(tTravelingUnits) == false then
                for iTravelUnit, oTravelUnit in tTravelingUnits do
                    if oTravelUnit == oUnit then
                        table.remove(tTravelingUnits, iTravelUnit)
                        break
                    end
                end
            end
        end
        oUnit[reftiPlateauAndLZToMoveTo] = nil
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetUnitToTravelToLandZone(oUnit, iTargetPlateau, iTargetLandZone, subrefTScoutsTravelingHere)
    --Intended for non-engineer units (engineers are handled separately)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnitToTravelToLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    M28Navy.RemoveUnitFromAnyExistingLandOrWaterZoneItWasPreviouslyTravelingTo(oUnit, subrefTScoutsTravelingHere)

    oUnit[M28Navy.refiWZToMoveTo] = nil
    oUnit[reftiPlateauAndLZToMoveTo] = {iTargetPlateau, iTargetLandZone}
    local tLZData = M28Map.tAllPlateaus[iTargetPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
    --if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; iTargetPlateau='..iTargetPlateau..'; iTargetLandZone='..iTargetLandZone..'; Is tLZData empty='..tostring(M28Utilities.IsTableEmpty(tLZData))..'; Is tLZTeamData empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData))..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
    if not(tLZTeamData[subrefTScoutsTravelingHere]) then tLZTeamData[subrefTScoutsTravelingHere] = {} end
    table.insert(tLZTeamData[subrefTScoutsTravelingHere], oUnit)
    if bDebugMessages == true then LOG(sFunctionRef..': About to tell unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to go to iTargetPlateau='..iTargetPlateau..'; iTargetLandZone='..iTargetLandZone..'; midpoint of LZ='..repru(tLZData[M28Map.subrefMidpoint])) end
    M28Orders.IssueTrackedMove(oUnit, tLZData[M28Map.subrefMidpoint], 6, false, 'TLZ'..iTargetLandZone)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateUnitPositionsAndLandZone(aiBrain, tUnits, iTeam, iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
    --Similar to UpdateUnitPositionsAndWaterZone; Based on RemoveEntriesFromArrayAndAddToNewTableBasedOnCondition, but more complex as dont always want to add unit to a table
    --bUpdateTimeOfLastEnemyPositionCheck - if bUseLastKnownPosition is false and this is true, then updates subrefiTimeOfLastEnemyUnitPosUpdate
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateUnitPositionsAndLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iRevisedIndex = 1
    local iTableSize = table.getn(tUnits)
    local iActualPlateau, iActualLandZone
    local UpdateUnitLastKnownPosition = M28Team.UpdateUnitLastKnownPosition
    local bUseActualPositionIfEnemy = false
    local bUnitIsAttached
    if bUpdateTimeOfLastEnemyPositionCheck and not(bUseLastKnownPosition) then tLZTeamData[M28Map.subrefiTimeOfLastEnemyUnitPosUpdate] = GetGameTimeSeconds() end
    if not(bUseLastKnownPosition) or (bUseLastKnownPosition and (tLZTeamData[M28Map.refiRadarCoverage] or 0) >= 70) then bUseActualPositionIfEnemy = true end


    for iOrigIndex=1, iTableSize do
        if not(tUnits[iOrigIndex]) or tUnits[iOrigIndex].Dead then
            --Remove the entry
            tUnits[iOrigIndex] = nil
        else
            --Air units - first check inside the map area (to avoid too big a load on CPU trying to locate nearby valid zones and false error messages)
            if not(bAreAirUnits) or M28Conditions.IsLocationInMap(tUnits[iOrigIndex]:GetPosition()) then
                --Unit still valid, does it have the right plateau and land zone?
                bUnitIsAttached = tUnits[iOrigIndex]:IsUnitState('Attached')
                if bAreEnemyUnits or bUseLastKnownPosition then
                    UpdateUnitLastKnownPosition(aiBrain, tUnits[iOrigIndex], bUseActualPositionIfEnemy)
                end
                if bUseLastKnownPosition then
                    if bAreAirUnits or bUnitIsAttached then
                        iActualPlateau, iActualLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition( tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                    else
                        iActualPlateau, iActualLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], true, tUnits[iOrigIndex])
                    end
                else
                    --Cases where can use actual position (i.e. Allied unit or special use cases where a human will likely infer an enemy unit has moved):
                    if bUnitIsAttached or bAreAirUnits then
                        iActualPlateau, iActualLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition( tUnits[iOrigIndex]:GetPosition())
                    else
                        iActualPlateau, iActualLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tUnits[iOrigIndex]:GetPosition(), true, tUnits[iOrigIndex])
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iOrigIndex='..iOrigIndex..'; iActualPlateau='..(iActualPlateau or 'nil')..'; iActualLandZone='..(iActualLandZone or 'nil')..'; Unit='..tUnits[iOrigIndex].UnitId..M28UnitInfo.GetUnitLifetimeCount(tUnits[iOrigIndex])..'; bUnitIsAttached='..tostring(bUnitIsAttached)..'; bAreAirUnits='..tostring(bAreAirUnits or false)..'; Unit brain owner='..tUnits[iOrigIndex]:GetAIBrain().Nickname..'; Unit position='..repru(tUnits[iOrigIndex]:GetPosition())) end
                end

                if not(iActualPlateau > 0) then
                    if not(bAreAirUnits) and not(bUnitIsAttached) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Dont have a valid actual plateau so will use the recorded plateau and land zone') end
                        iActualPlateau = iRecordedPlateau
                        iActualLandZone = iRecordedLandZone
                        --Add location to table of pathing exceptions
                        if bUseLastKnownPosition then
                            M28Map.AddLocationToPlateauExceptions(tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iRecordedPlateau, iRecordedLandZone)
                        else
                            M28Map.AddLocationToPlateauExceptions(tUnits[iOrigIndex]:GetPosition(), iRecordedPlateau, iRecordedLandZone)
                        end
                    end
                end



                --Is the plateau and zone correct?
                if bDebugMessages == true then
                    LOG('Updating unit position for unit '..tUnits[iOrigIndex].UnitId..M28UnitInfo.GetUnitLifetimeCount(tUnits[iOrigIndex])..'; iRecordedPlateau='..iRecordedPlateau..'; iActualPlateau='..(iActualPlateau or 'nil')..';  iRecordedLandZone='..(iRecordedLandZone or 'nil')..'; iActualLandZone='..(iActualLandZone or 'nil')..'; Unit actual position='..repru(tUnits[iOrigIndex]:GetPosition())..'; Plateau ref using navutils of actual position='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tUnits[iOrigIndex]:GetPosition()) or 'nil')..'; Last known position='..repru(tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Hover nav utils of unit position='..(NavUtils.GetLabel(M28Map.refPathingTypeHover, tUnits[iOrigIndex]:GetPosition()) or 'nil'))
                    M28Utilities.DrawLocation(tUnits[iOrigIndex]:GetPosition())
                end
                --If the plateau has changed, and the new one has no valid location, then update the position to the actual position (due to issue with e.g. air units where if they fly over a cliff at the point intel is lost then it causes an error when trying to add them to another zone)
                if not(iRecordedPlateau == iActualPlateau) and bUseLastKnownPosition and (iActualLandZone or 0) > 0 then
                    local tRevisedPosition = tUnits[iOrigIndex]:GetPosition()
                    tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][iTeam] = {tRevisedPosition[1], tRevisedPosition[2], tRevisedPosition[3]}
                    iActualPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tRevisedPosition)
                end
            else
                --Air unit is outside the map bounds - treat the actual plateau as the recorded plateau - i.e. just keep the air unit against this zone until it comes back inside the map
                iActualPlateau = iRecordedPlateau
                iActualLandZone = iRecordedLandZone
            end
            if iRecordedPlateau == iActualPlateau and iRecordedLandZone == iActualLandZone then
                --No change needed for unit
                if (iOrigIndex ~= iRevisedIndex) then
                    tUnits[iRevisedIndex] = tUnits[iOrigIndex]
                    tUnits[iOrigIndex] = nil
                end
                iRevisedIndex = iRevisedIndex + 1
            else
                local oUnitToAdd = tUnits[iOrigIndex]
                --Want to remove the entry from this table, but then add it to the correct table
                oUnitToAdd[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam] = nil --Done here so we dont try and go through this table again when removing later on
                if iActualPlateau > 0 and iActualLandZone > 0 then
                    --AddUnitToLandZoneForBrain(aiBrain,        oUnit,      iPlateau,       iLandZone,      bIsEnemyAirUnit)
                    M28Team.AddUnitToLandZoneForBrain(aiBrain, oUnitToAdd, iActualPlateau, iActualLandZone, bAreAirUnits)
                    if bDebugMessages == true then LOG('Adding unit to land zone') end
                else
                    local iWaterZone
                    if iActualPlateau > 0 then
                        local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnitToAdd:GetPosition())
                        iWaterZone = M28Map.tWaterZoneBySegment[iSegmentX][iSegmentZ]
                    end
                    if bDebugMessages == true then LOG('Unit water zone='..(iWaterZone or 'nil')) end
                    if iWaterZone then
                        M28Team.AddUnitToWaterZoneForBrain(aiBrain, oUnitToAdd, iWaterZone, bAreAirUnits)
                    else
                        if bAreAirUnits then
                            --Get revised plateau/LZ
                            iActualPlateau, iActualLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnitToAdd:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': Air unit will record in either water or land zone, iActualPlateau='..(iActualPlateau or 'nil')..'; iActualLandZone='..(iActualLandZone or 'nil')) end
                            if iActualPlateau == 0 then
                                --Water zone
                                iWaterZone = iActualLandZone
                                M28Team.AddUnitToWaterZoneForBrain(aiBrain, oUnitToAdd, iWaterZone, bAreAirUnits)
                            else
                                M28Team.AddUnitToLandZoneForBrain(aiBrain, oUnitToAdd, iActualPlateau, iActualLandZone, bAreAirUnits)
                            end
                        else
                            --Not sure where to record unit so call main logic
                            M28Team.AssignUnitToLandZoneOrPond(aiBrain, oUnitToAdd, true)
                        end
                    end
                end

                tUnits[iOrigIndex] = nil
            end
        end
    end
    if iRevisedIndex < iTableSize then
        --table.setn(tUnits, iRevisedIndex - 1)
        for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
            --if bDebugMessages == true then LOG(sFunctionRef..': removing entry '..iRemovalEntry..' from iRecordedLandZone='..iRecordedLandZone..'; Entry being removed UnitId='..(tUnits[iRemovalEntry].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tUnits[iRemovalEntry]) or 'nil')..'; iTableSize='..iTableSize..'; iRevisedIndex='..iRevisedIndex) end
            table.remove(tUnits, iRemovalEntry)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iRevisedIndex='..iRevisedIndex..'; Is tUnits empty='..tostring(M28Utilities.IsTableEmpty(tUnits))..'; iiRecordedPlateau='..iRecordedPlateau..'; iRecordedLandZone='..iRecordedLandZone..'; GameTime='..GetGameTimeSeconds()..'; bUseLastKnownPosition='..tostring(bUseLastKnownPosition or false)..'; bUseActualPositionIfEnemy='..tostring(bUseActualPositionIfEnemy)..'; bUpdateTimeOfLastEnemyPositionCheck='..tostring(bUpdateTimeOfLastEnemyPositionCheck)) end
end

function RecordAirThreatForLandZone(tLZTeamData, iTeam, iPlateau, iLandZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAirThreatForLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                                                                --GetAirThreatLevel(tUnits,                                   bEnemyUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
    tLZTeamData[M28Map.refiEnemyAirToGroundThreat] = M28UnitInfo.GetAirThreatLevel(tLZTeamData[M28Map.reftLZEnemyAirUnits],     true,       false,              false,              true,               false,                  false)
    tLZTeamData[M28Map.refiEnemyAirAAThreat] = M28UnitInfo.GetAirThreatLevel(tLZTeamData[M28Map.reftLZEnemyAirUnits],           true,       true,               false,              false,              false,                   false)
    tLZTeamData[M28Map.refiEnemyAirOtherThreat] = M28UnitInfo.GetAirThreatLevel(tLZTeamData[M28Map.reftLZEnemyAirUnits],        true,       false,               false,              false,              true,                   true)

    if bDebugMessages == true then LOG(sFunctionRef..': Finished updating enemy air threat values for iTeam '..iTeam..' iPlateau '..iPlateau..'; iLandZOne '..iLandZone..'; AirToGround threat='.. tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Other air threat='..tLZTeamData[M28Map.refiEnemyAirOtherThreat]..'; Is table of enemy air units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]))) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordGroundThreatForLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone)
    --Records the different types of threat for the land zone

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordGroundThreatForLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Track team total threat - first remove the previous entry, then add in the new entry
    M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] - tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
    M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] - tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]
    M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] - tLZTeamData[M28Map.subrefLZThreatAllyMAA]
    M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] - tLZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA]



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at game time '..GetGameTimeSeconds()..' for iTeam='..iTeam..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))) end
    tLZTeamData[M28Map.subrefThreatEnemyShield] = 0 --will change later
    --local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) then
        tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] = nil
        tLZTeamData[M28Map.subrefThreatEnemyDFStructures] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] = 0
        tLZTeamData[M28Map.subrefiThreatEnemyGroundAA] = 0
        tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] = false
        tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] = 0
    else
        local tMobileUnits = EntityCategoryFilterDown(categories.MOBILE - M28UnitInfo.refCategoryScathis, tLZTeamData[M28Map.subrefTEnemyUnits])
        local tStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryScathis, tLZTeamData[M28Map.subrefTEnemyUnits])
        local tEnemiesExclShieldsAndFixedArti = EntityCategoryFilterDown(categories.MOBILE - M28UnitInfo.refCategoryMobileLandShield + categories.DIRECTFIRE, tLZTeamData[M28Map.subrefTEnemyUnits]) --(shield value gets added later based on the threat excl shields)
        local bHaveDangerousEnemies = false
        tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] = M28UnitInfo.GetCombatThreatRating(tEnemiesExclShieldsAndFixedArti, true)

        if bDebugMessages == true then
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                LOG(sFunctionRef..': Will list out every enemy unit in the zone and its threat, position, and the plateau and land zone of that position')
                for iUnit, oUnit in tLZTeamData[M28Map.subrefTEnemyUnits] do
                    local iUnitPlateau, iUnitZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                    LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with % completion '..oUnit:GetFractionComplete()..' has threat '..M28UnitInfo.GetCombatThreatRating({ oUnit }, true)..'; AA threat='..M28UnitInfo.GetAirThreatLevel({ oUnit }, true, false, true, false, false, false)..'; Position='..repru(oUnit:GetPosition())..'; Dist to midpoint='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])..'; iUnitPlateau='..(iUnitPlateau or 'nil')..'; iUnitZone='..(iUnitZone or 'nil'))
                end
            end
        end

        tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] = M28UnitInfo.GetCombatThreatRating(tStructures, true, false, true)
        tLZTeamData[M28Map.subrefiThreatEnemyGroundAA] = M28UnitInfo.GetAirThreatLevel(tLZTeamData[M28Map.subrefTEnemyUnits], true, false, true, false, false, false)
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] = 0
        tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] = M28UnitInfo.GetMassCostOfUnits(tStructures, true)
        tLZTeamData[M28Map.subrefThreatEnemyDFStructures] = 0

        --Increase structure value for under construction experimentals
        local tExperimentals = EntityCategoryFilterDown(categories.EXPERIMENTAL * categories.MOBILE, tLZTeamData[M28Map.subrefTEnemyUnits])
        if M28Utilities.IsTableEmpty(tExperimentals) == false then
            for iUnit, oUnit in tExperimentals do
                if oUnit:GetFractionComplete() < 1 then
                    tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] = tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * oUnit:GetFractionComplete()
                    if bDebugMessages == true then LOG(sFunctionRef..': Have under construction experimental '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' in Plateau '..iPlateau..' Zone '..iZone..'; will increase threat for this, fraction complete='..oUnit:GetFractionComplete()..'; structure threat after increase='..tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]) end
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Plateau '..iPlateau..' LZ '..iLandZone..' has enemy units, Enemy combat total='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Is table of enemy structures empty='..tostring(M28Utilities.IsTableEmpty(tStructures))..'; Is tMobileUnits empty='..tostring(M28Utilities.IsTableEmpty(tMobileUnits))) end
        local iCurThreat
        if M28Utilities.IsTableEmpty(tMobileUnits) == false then
            for iUnit, oUnit in tMobileUnits do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Indirect range='..(oUnit[M28UnitInfo.refiIndirectRange] or 'nil')..'; Combat threat rating='..M28UnitInfo.GetCombatThreatRating({ oUnit }, true)) end
                if (oUnit[M28UnitInfo.refiDFRange] > 0 or oUnit[M28UnitInfo.refiIndirectRange]) and oUnit:GetFractionComplete() >= 0.9 then
                    iCurThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }, true)
                    if iCurThreat > 0 then
                        if oUnit[M28UnitInfo.refiDFRange] > 0 then
                            if not(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) then tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] = {} end
                            tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange][oUnit[M28UnitInfo.refiDFRange]] = (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange][oUnit[M28UnitInfo.refiDFRange]] or 0) + iCurThreat
                            if not(bHaveDangerousEnemies) and iCurThreat > 10 then bHaveDangerousEnemies = true end
                            tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] = tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] + iCurThreat
                        end
                        if oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                            if not(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange]) then tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] = {} end
                            --Units that have both DF and indirect fire range, and significant threat, unless the IF range is significantly higiher than DF, reduce the threat given (one example being ACU with mod that gives it indirectfire attack)
                            if iCurThreat > 100 and (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then
                                if oUnit[M28UnitInfo.refiDFRange] + 5 > oUnit[M28UnitInfo.refiIndirectRange] then
                                    if iCurThreat > 1000 and oUnit[M28UnitInfo.refiDFRange] < 50 then
                                        iCurThreat = iCurThreat * 0.2
                                    else
                                        iCurThreat = iCurThreat * 0.3
                                    end
                                elseif oUnit[M28UnitInfo.refiIndirectRange] < 50 then
                                    iCurThreat = iCurThreat * 0.4
                                else
                                    iCurThreat = iCurThreat * 0.6
                                end
                            end
                            tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange][oUnit[M28UnitInfo.refiIndirectRange]] = (tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange][oUnit[M28UnitInfo.refiIndirectRange]] or 0) + iCurThreat
                            tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] = tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] + iCurThreat
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Enemy mobile indirect range after updating all units='..repru(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange])..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]='..repru(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange])..'; subrefLZThreatEnemyMobileDFTotal='..(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 'nil')) end
        end
        if M28Utilities.IsTableEmpty(tStructures) == false then
            for iUnit, oUnit in tStructures do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; with DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')) end
                if oUnit[M28UnitInfo.refiDFRange] > 0 and oUnit:GetFractionComplete() >= 0.9 then
                    iCurThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Structure iCurThreat='..iCurThreat) end
                    if iCurThreat > 0 then
                        if not(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) then tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] = {} end
                        tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange][oUnit[M28UnitInfo.refiDFRange]] = (tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange][oUnit[M28UnitInfo.refiDFRange]] or 0) + iCurThreat
                        if not(bHaveDangerousEnemies) and iCurThreat > 10 then bHaveDangerousEnemies = true end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                    tLZTeamData[M28Map.subrefThreatEnemyDFStructures] = tLZTeamData[M28Map.subrefThreatEnemyDFStructures] + iThreat
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': LZ threats by range after updating for all structures='..repru(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange])) end
        end
        tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] = bHaveDangerousEnemies

        --Increase enemy threats for shield values
        local tShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryMobileLandShield, tLZTeamData[M28Map.subrefTEnemyUnits])
        if M28Utilities.IsTableEmpty(tShields) == false then
            local iCurShield, iMaxShield
            local iThreatFactor
            for iUnit, oUnit in tShields do
                if oUnit:GetFractionComplete() >= 0.9 then
                    iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, true)
                    iThreatFactor = math.max(0.1, iCurShield /  iMaxShield)
                    tLZTeamData[M28Map.subrefThreatEnemyShield] = tLZTeamData[M28Map.subrefThreatEnemyShield] + iThreatFactor * (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
                end
            end
        end
        if (tLZTeamData[M28Map.subrefThreatEnemyShield] or 0) >= 50 then
            local iMaxShieldRating
            if tLZTeamData[M28Map.subrefThreatEnemyShield] >= 4000 then
                if M28Utilities.bLoudModActive then --QUIET now has logic for overlapping shields to take damage and has increased recharge times
                    iMaxShieldRating = tLZTeamData[M28Map.subrefThreatEnemyShield]
                else
                    iMaxShieldRating = math.min(3200 + (tLZTeamData[M28Map.subrefThreatEnemyShield] - 4000) * 0.4, 7000) --shields wont be able to cover everywhere, and more than one shield has lower value due to FAF anti-shield stacking
                end
            else
                iMaxShieldRating = tLZTeamData[M28Map.subrefThreatEnemyShield]
            end
            if M28Utilities.bLoudModActive then
                iMaxShieldRating = iMaxShieldRating + 0.5 * math.min(5000, tLZTeamData[M28Map.subrefThreatEnemyShield]) --shields are really good in LOUD
            end
            local iShieldMaxFactor = 1
            if M28Utilities.bQuietModActive then iShieldMaxFactor = 1.25 --Az: Static shields nerfed to FAF values in QUIET; mobile shields not; since shield threat includes both will do 1.25 as a rough approximation/allowance for there potentially being mobile shields that are good for their mass cost
            elseif M28Utilities.bLoudModActive then iShieldMaxFactor = 4
            end
            if not(iMaxShieldRating) then
                M28Utilities.ErrorHandler('Dont have a max shield rating for P'..iPlateau..'LZ'..iLandZone..'; tLZTeamData[M28Map.subrefThreatEnemyShield]='..(tLZTeamData[M28Map.subrefThreatEnemyShield] or 'nil')..'; will use gross LZ value')
                iMaxShieldRating = (tLZTeamData[M28Map.subrefThreatEnemyShield] or 0)
            end
            tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] = tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] + math.max(iMaxShieldRating * 0.1, math.min(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * iShieldMaxFactor, iMaxShieldRating))
            tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] = tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] + math.min(tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] * iShieldMaxFactor, iMaxShieldRating)
            tLZTeamData[M28Map.subrefiThreatEnemyGroundAA] = tLZTeamData[M28Map.subrefiThreatEnemyGroundAA] + math.min(tLZTeamData[M28Map.subrefiThreatEnemyGroundAA] * iShieldMaxFactor, iMaxShieldRating)
            tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] = tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] + math.min(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] * iShieldMaxFactor, iMaxShieldRating * 0.6)
            tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] = tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] + math.min(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] * iShieldMaxFactor, iMaxShieldRating * 0.6)

        end

    end

    --Include long range threats
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of long range threats empty for iLandZone='..iLandZone..'='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats]) == false then
        local tNearbyLongRangeThreats = {}
        local iZoneDiameter = math.max(tLZData[M28Map.subrefLZMaxSegX] - tLZData[M28Map.subrefLZMinSegX], tLZData[M28Map.subrefLZMaxSegZ] - tLZData[M28Map.subrefLZMinSegZ]) * M28Map.iLandZoneSegmentSize
        local iRangeThreshold = math.max(iZoneDiameter * 0.8, 60)
        for iUnit, oUnit in tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats] do
            --Only include megalith if we lack similar DF or IF range
            if M28UnitInfo.IsUnitValid(oUnit) and (oUnit[M28UnitInfo.refiCombatRange] > 70 or tLZTeamData[M28Map.subrefLZAllyBestCombatRange] < oUnit[M28UnitInfo.refiCombatRange] or (oUnit[M28UnitInfo.refiCombatRange] == 70 and tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] >= 100 and M28Conditions.GetBestMobileDFRangeInZone(tLZTeamData) > oUnit[M28UnitInfo.refiCombatRange])) then
                if bDebugMessages == true then LOG(sFunctionRef..': Long range threat unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Dist to midpoint='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])..'; Unit range='..(oUnit[M28UnitInfo.refiCombatRange] or 0)..'; iRangeThreshold='..iRangeThreshold..'; iZoneDiameter='..iZoneDiameter) end
                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= (oUnit[M28UnitInfo.refiCombatRange] or 0) + iRangeThreshold then --tried 55 but proved too small
                    table.insert(tNearbyLongRangeThreats, oUnit)
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby long range threats empty='..tostring(M28Utilities.IsTableEmpty(tNearbyLongRangeThreats))) end
        if M28Utilities.IsTableEmpty(tNearbyLongRangeThreats) then tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] = 0
        else
            tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] = M28UnitInfo.GetCombatThreatRating(tNearbyLongRangeThreats, true)
        end
    else
        tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] = 0
    end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeIFThreats]) then tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeIFThreat] = 0
    else
        tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeIFThreat] = M28UnitInfo.GetCombatThreatRating(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeIFThreats], true)
    end


    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) then
        tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyStructureIndirect] = 0
        tLZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyMAA] = 0
        tLZTeamData[M28Map.subrefLZAllyBestCombatRange] = 0
    else
        local tMobileUnits = EntityCategoryFilterDown(categories.MOBILE, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local tStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] = M28UnitInfo.GetCombatThreatRating(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits], false)
        tLZTeamData[M28Map.subrefLZThreatAllyStructureIndirect] = M28UnitInfo.GetCombatThreatRating(tStructures, false, false, true)
        tLZTeamData[M28Map.subrefLZThreatAllyMAA] = M28UnitInfo.GetAirThreatLevel(tMobileUnits, false, false, true, false, false, false)
        tLZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] = M28UnitInfo.GetAirThreatLevel(tStructures, false, false, true, false, false, false) + tLZTeamData[M28Map.subrefLZThreatAllyMAA]

        tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] = nil
        local iCurThreat
        if bDebugMessages == true then LOG(sFunctionRef..': Calculating threat by range for allied units, is tMobileUnits empty='..tostring(M28Utilities.IsTableEmpty(tMobileUnits))..'; is tStructures empty='..tostring(M28Utilities.IsTableEmpty(tStructures))) end
        if M28Utilities.IsTableEmpty(tMobileUnits) == false then
            for iUnit, oUnit in tMobileUnits do
                if oUnit:GetFractionComplete() >= 1 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; refiDFRange='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; IndirectRange='..(oUnit[M28UnitInfo.refiIndirectRange] or 'nil')..'; Unit combat rating='..M28UnitInfo.GetCombatThreatRating({ oUnit }, false)) end
                    if oUnit[M28UnitInfo.refiDFRange] > 0 or oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                        iCurThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }, false, nil, (oUnit[M28UnitInfo.refiDFRange] or 0) == 0)
                        if iCurThreat > 0 then
                            if oUnit[M28UnitInfo.refiDFRange] > 0 then
                                if not(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) then tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] = {} end
                                tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange][oUnit[M28UnitInfo.refiDFRange]] = (tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange][oUnit[M28UnitInfo.refiDFRange]] or 0) + iCurThreat
                            end
                            if oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                                if not(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange]) then tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] = {} end
                                tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange][oUnit[M28UnitInfo.refiIndirectRange]] = (tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange][oUnit[M28UnitInfo.refiIndirectRange]] or 0) + iCurThreat
                            end
                        end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tStructures) == false then
            for iUnit, oUnit in tStructures do
                if oUnit[M28UnitInfo.refiDFRange] > 0 and oUnit:GetFractionComplete() >= 1 then
                    iCurThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }, true)
                    if iCurThreat > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording PD threat of oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurThreat='..iCurThreat..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; iUnit='..iUnit) end
                        if not(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) then tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] = {} end
                        tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange][oUnit[M28UnitInfo.refiDFRange]] = (tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange][oUnit[M28UnitInfo.refiDFRange]] or 0) + iCurThreat
                    end
                end
            end
        end
        --Update total DF and indirect threat
        tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] = 0
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] = tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] + iThreat
            end
        end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] do
                tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] = tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] + iThreat
            end
        end

        --Update combat range
        local iBestRange = 0
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                iBestRange = math.max(iBestRange, iRange)
            end
        end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                iBestRange = math.max(iBestRange, iRange)
            end
        end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] do
                iBestRange = math.max(iBestRange, iRange)
            end
        end
        tLZTeamData[M28Map.subrefLZAllyBestCombatRange] = iBestRange

        M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] + tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
        M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] + tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]
        M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] + tLZTeamData[M28Map.subrefLZThreatAllyMAA]
        M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] + tLZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA]
    end

    --Add non-M28 teammate defences
    if M28Conditions.IsTableOfUnitsStillValid(tLZTeamData[M28Map.subreftoTeammateFixedDF]) then
        local iAlliedFixedDF = 0
        for iUnit, oUnit in tLZTeamData[M28Map.subreftoTeammateFixedDF] do
            iAlliedFixedDF = iAlliedFixedDF + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
        end
        tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] = tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] + iAlliedFixedDF
        if bDebugMessages == true then LOG(sFunctionRef..': Increasing combat threat for zone '..iLandZone..' for DF by '..iAlliedFixedDF) end
    end
    if M28Conditions.IsTableOfUnitsStillValid(tLZTeamData[M28Map.subreftoTeammateFixedAA]) then
        local iAlliedFixedAA = 0
        for iUnit, oUnit in tLZTeamData[M28Map.subreftoTeammateFixedAA] do
            iAlliedFixedAA = iAlliedFixedAA + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
        end
        tLZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] = tLZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] + iAlliedFixedAA
        if bDebugMessages == true then LOG(sFunctionRef..': Increasing AA allied threat for zone '..iLandZone..' by '..iAlliedFixedAA) end
    end
    local bNearbyEnemies = false

    if bDebugMessages == true then LOG(sFunctionRef..': Considering if enemy units in this or adjacent LZ, is table of enemy units for this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))..'; Adjacent LZs='..repru(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
        bNearbyEnemies = true
    else
        --, iPlateau, iLandZone
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones] do
                --NEED to flag as nearby enemies if any enemy units in the LZ, or else can cause problems where we try to attack a unit in an adjacent land zone, and then think there is no such unit due to this flag if it is only based on combat threat
                if bDebugMessages == true then LOG(sFunctionRef..': Enemy combat threat for adjacent LZ iAdjLZ='..iAdjLZ..'; threat='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal]) end
                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                    bNearbyEnemies = true
                    break
                end
            end
        end
    end

    --Calculate core DF and indirect wanted just for this LZ:
    if bNearbyEnemies then
        local iEnemyStructureThreat = 0
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                iEnemyStructureThreat = iEnemyStructureThreat + iThreat
            end
        end
        tLZTeamData[M28Map.subrefLZIndirectThreatWanted] = iEnemyStructureThreat * 2 + tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] * 2
        tLZTeamData[M28Map.subrefLZDFThreatWanted] = math.max(200, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 2)
    else
        tLZTeamData[M28Map.subrefLZDFThreatWanted] = 0
        tLZTeamData[M28Map.subrefLZIndirectThreatWanted] = 0
    end

    --If we have no friendly combat units and enemy has combat threat, then request less MAA, or none if we have no non-MAA/scout units
    if bDebugMessages == true then LOG(sFunctionRef..': Setting the MAA level wanted for iLandZone='..iLandZone..'; tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]='..tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tLZTeamData[M28Map.refiEnemyAirOtherThreat]='..tLZTeamData[M28Map.refiEnemyAirOtherThreat]..'; Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))..'; subrefLZSValue='..tLZTeamData[M28Map.subrefLZSValue]..'; subrefLZTThreatAllyCombatTotal='..tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]) end
    if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < 11 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= math.min(1500, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 0.9) or tLZTeamData[M28Map.subrefLZbCoreBase] then
        tLZTeamData[M28Map.subrefLZMAAThreatWanted] = math.max(tLZTeamData[M28Map.refiEnemyAirToGroundThreat] * 0.65 + tLZTeamData[M28Map.refiEnemyAirAAThreat] * 0.15 + tLZTeamData[M28Map.refiEnemyAirOtherThreat] * 0.15, tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] * 0.1)
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] <= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 and tLZTeamData[M28Map.subrefLZMAAThreatWanted] < 600 then
            if tLZTeamData[M28Map.subrefLZSValue] >= 600 or tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= 1200 then
                tLZTeamData[M28Map.subrefLZMAAThreatWanted] = 600
            end
        end
    elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        local bHaveAlliedNonMAAOrScout = false
        local bHaveAlliedMAA = false
        for iUnit, oUnit in tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do
            if EntityCategoryContains(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryMAA - M28UnitInfo.refCategoryLandScout, oUnit.UnitId) then
                bHaveAlliedNonMAAOrScout = true
                break
            elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId) then
                bHaveAlliedMAA = true
            end
        end -- M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryMAA - M28UnitInfo.refCategoryLandScout, subreftoLZOrWZAlliedUnits
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveAlliedMAA='..tostring(bHaveAlliedMAA)..'; bHaveAlliedNonMAAOrScout='..tostring(bHaveAlliedNonMAAOrScout)) end
        if bHaveAlliedNonMAAOrScout or (bHaveAlliedMAA and tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0) then
            --SIgnificantly less MAA for dealing with non-air to ground threats
            if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                tLZTeamData[M28Map.subrefLZMAAThreatWanted] = math.max(tLZTeamData[M28Map.refiEnemyAirToGroundThreat], (tLZTeamData[M28Map.refiEnemyAirOtherThreat] + tLZTeamData[M28Map.refiEnemyAirAAThreat]) * 0.075, tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] * 0.2)
            else
                tLZTeamData[M28Map.subrefLZMAAThreatWanted] = math.max((tLZTeamData[M28Map.refiEnemyAirOtherThreat] + tLZTeamData[M28Map.refiEnemyAirAAThreat]) * 0.075, tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] * 0.1)
            end
        else
            tLZTeamData[M28Map.subrefLZMAAThreatWanted] = 0
        end
    else
        tLZTeamData[M28Map.subrefLZMAAThreatWanted] = 0
    end

    --Increase MAA wanted if we have ACU in the LZ
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false then
        local tiMAAByTechForACU = {100, 400, 1000}
        if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
            tLZTeamData[M28Map.subrefLZMAAThreatWanted] = tLZTeamData[M28Map.subrefLZMAAThreatWanted] + math.min(1600, tiMAAByTechForACU[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2)
        else
            tLZTeamData[M28Map.subrefLZMAAThreatWanted] = tLZTeamData[M28Map.subrefLZMAAThreatWanted] + tiMAAByTechForACU[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed recording MAA Wanted='..(tLZTeamData[M28Map.subrefLZMAAThreatWanted] or 'nil')..'; will treat as 0 if less than 10') end
    if (tLZTeamData[M28Map.subrefLZMAAThreatWanted] or 0) < 10 then tLZTeamData[M28Map.subrefLZMAAThreatWanted] = 0 end



    --Update if have enemies in adjacent WZ
    tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] = false
    tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = false
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
        local iAdjWZ, iPond
        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
            iAdjWZ = tSubtable[M28Map.subrefAWZRef]
            iPond = M28Map.tiPondByWaterZone[iAdjWZ]
            local tWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
            if (tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 20 and tWZTeamData[M28Map.subrefWZBestEnemyDFRange] > 0 then
                tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] = true
                tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = true
                break
            elseif M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = true
            end
        end
    end

    tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] = bNearbyEnemies
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]='..repru(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange])..'; bNearbyEnemies='..tostring(bNearbyEnemies)..'; Allied combat='..(tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 'nil')..'; tLZTeamData[M28Map.subrefLZMAAThreatWanted]='..tLZTeamData[M28Map.subrefLZMAAThreatWanted]..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tLZTeamData[M28Map.refiEnemyAirOtherThreat]='..tLZTeamData[M28Map.refiEnemyAirOtherThreat]) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RunFromEnemy(oUnitToRun, oEnemy, iTeam, iPlateau, iDistanceToRun)
    --NOTE: Used by waterzone logic as well for scouts to run

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RunFromEnemy'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    oUnitToRun[M28UnitInfo.refiTimeLastTriedRetreating] = GetGameTimeSeconds()

    local iAngleFromEnemy = M28Utilities.GetAngleFromAToB(oEnemy:GetPosition(), oUnitToRun:GetPosition())
    --MoveInDirection(tStart, iAngle,           iDistance, bKeepInMapBounds, bTravelUnderwater, bKeepInCampaignPlayableArea)
    local tPotentialRunPosition = M28Utilities.MoveInDirection(oUnitToRun:GetPosition(), iAngleFromEnemy, iDistanceToRun, false,             false,              false)
    local tNextRunPosition = M28Utilities.MoveInDirection(oUnitToRun:GetPosition(), iAngleFromEnemy, iDistanceToRun + math.max(8, math.min(20, iDistanceToRun)), false,             false,              false)
    local bAmphibious = EntityCategoryContains(M28UnitInfo.refCategoryAmphibious + categories.HOVER, oUnitToRun.UnitId)
    local iCurIsland
    function IsPositionValid(tPosition)
        if M28Conditions.IsLocationInPlayableArea(tPosition) then
            if bAmphibious and NavUtils.GetLabel(M28Map.refPathingTypeHover, tPosition) == iPlateau then
                return true
            elseif not(bAmphibious) then
                if not(iCurIsland) then iCurIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnitToRun:GetPosition()) end
                if iCurIsland == NavUtils.GetLabel(M28Map.refPathingTypeLand, tPosition) then
                    return true
                end

            end
        end
    end
    local bCurPositionValid = IsPositionValid(tPotentialRunPosition)
    local bNextPositionValid = IsPositionValid(tNextRunPosition)
    if bDebugMessages == true then LOG(sFunctionRef..': bCurPositionValid='..tostring(bCurPositionValid)..'; bNextPositionValid='..tostring(bNextPositionValid)) end
    if not(bCurPositionValid) or not(bNextPositionValid) then
        --Consider running slightly towards the nearest rally point
        if bDebugMessages == true then LOG(sFunctionRef..': Dont have a valid run position so will try and run to the rally point instead') end
        local iUnitPlateau, iUnitZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnitToRun:GetPosition())
        local tRallyPoint
        if (iUnitZone or 0) > 0 then
            local tLZOrWZData

            if iUnitPlateau == 0 then
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iUnitZone]][M28Map.subrefPondWaterZones][iUnitZone]
                tRallyPoint = M28Navy.GetNearestWaterRallyPoint(tLZOrWZData, iTeam, M28Map.tiPondByWaterZone[iUnitZone], iUnitZone)
            else
                tLZOrWZData = M28Map.tAllPlateaus[iUnitPlateau][M28Map.subrefPlateauLandZones][iUnitZone]
                tRallyPoint = GetNearestLandRallyPoint(tLZOrWZData, iTeam, iUnitPlateau, iUnitZone, 2, EntityCategoryContains(categories.HOVER + M28UnitInfo.refCategoryAmphibious, oUnitToRun.UnitId))
            end

        else
            --Run to the unit's brain's start position
            tRallyPoint = M28Map.PlayerStartPoints[oUnitToRun:GetAIBrain():GetArmyIndex()]
        end

        local iAngleToRally = M28Utilities.GetAngleFromAToB(tPotentialRunPosition, tRallyPoint)
        local iTurnSize = 30
        local iTurnAngleAdjust
        if M28Utilities.GetAngleDifference(iAngleFromEnemy + iTurnSize, iAngleToRally) <= M28Utilities.GetAngleDifference(iAngleFromEnemy - iTurnSize, iAngleToRally) then
            iTurnAngleAdjust = iTurnSize
        else
            iTurnAngleAdjust = -iTurnSize
        end
        tPotentialRunPosition = M28Utilities.MoveInDirection(oUnitToRun:GetPosition(), iAngleFromEnemy + iTurnAngleAdjust, iDistanceToRun, false,             false,              false)
        if bDebugMessages == true then LOG(sFunctionRef..': If try turning towards rally slightly is it valid? iTurnAngleAdjust='..iTurnAngleAdjust..'; Is position valid='..tostring(IsPositionValid(tPotentialRunPosition) or false)) end
        if not(IsPositionValid(tPotentialRunPosition)) then
            if bNextPositionValid then
                if bDebugMessages == true then LOG(sFunctionRef..': Next position is valid so will just try traveling there and hope its only a small detour') end
                tPotentialRunPosition = tNextRunPosition
            elseif iDistanceToRun < 7 then
                if bDebugMessages == true then LOG(sFunctionRef..': Will go to rally instead') end
                tPotentialRunPosition = {tRallyPoint[1], tRallyPoint[2], tRallyPoint[3]}
            else
                --Try shorter distance
                tPotentialRunPosition = M28Utilities.MoveInDirection(oUnitToRun:GetPosition(), iAngleFromEnemy + iTurnAngleAdjust * 1.6, iDistanceToRun * 0.5, false,             false,              false)
                if bDebugMessages == true then LOG(sFunctionRef..': Trying shorter dist and bigger angle, is revised tPotentialRunPosition valid='..tostring(IsPositionValid(tPotentialRunPosition) or false)) end
                if not(IsPositionValid(tPotentialRunPosition)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Still not valid so going to rally instead') end
                    tPotentialRunPosition = {tRallyPoint[1], tRallyPoint[2], tRallyPoint[3]}
                end
            end
        end
    end



    M28Orders.IssueTrackedMove(oUnitToRun, tPotentialRunPosition, math.min(8, iDistanceToRun * 0.25), false, 'RunE'..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy))
    if bDebugMessages == true then LOG(sFunctionRef..': Just tried to give move order for oUnitToRun='..oUnitToRun.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToRun)..' from cur position '..repru(oUnitToRun:GetPosition())..' to position '..repru(tPotentialRunPosition)..' due to enemy '..(oEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEnemy) or 'nil')..' which is at last known position '..repru(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; iDistanceToRun='..(iDistanceToRun or 'nil')..'; Angle to run location='..M28Utilities.GetAngleFromAToB(oUnitToRun:GetPosition(), tPotentialRunPosition)..'; Angle from unit ot enemy='..M28Utilities.GetAngleFromAToB(oUnitToRun:GetPosition(), oEnemy:GetPosition())..'; Actual last order position='..repru(oUnitToRun[M28Orders.reftiLastOrders][oUnitToRun[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition])..'; Unit order count='..(oUnitToRun[M28Orders.refiOrderCount] or 'nil')..'; GameTime='..GetGameTimeSeconds()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageLandZoneScouts(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tScouts, bLandZoneContainsNonScouts)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageLandZoneScouts'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    tLZTeamData[M28Map.refbWantLandScout] = false
    if bDebugMessages == true then
        LOG(sFunctionRef..': Considering if we want a land scout for iPlateau '..iPlateau..'; iLandZone='..iLandZone..'; bLandZoneContainsNonScouts='..tostring(bLandZoneContainsNonScouts or false)..'; Enemy combat threat='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Is table of land scouts traveling here empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTScoutsTravelingHere]))..'; Is table of scouts currently in this LZ empty='..tostring(M28Utilities.IsTableEmpty(tScouts))..'; Time='..GetGameTimeSeconds())
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTScoutsTravelingHere]) == false then
            for iScout, oScout in tLZTeamData[M28Map.subrefTScoutsTravelingHere] do
                LOG(sFunctionRef..': Scout travling here oScout='..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..'; dist='..M28Utilities.GetDistanceBetweenPositions(oScout:GetPosition(), tLZData[M28Map.subrefMidpoint])..'; owned by ='..oScout:GetAIBrain().Nickname)
            end
        end
    end

    --Refresh list of scouts traveling here
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTScoutsTravelingHere]) == false then
        local iTableSize = table.getn(tLZTeamData[M28Map.subrefTScoutsTravelingHere])
        for iCurEntry = iTableSize, 1, -1 do
            if not(M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.subrefTScoutsTravelingHere][iCurEntry])) then
                table.remove(tLZTeamData[M28Map.subrefTScoutsTravelingHere], iCurEntry)
            end
        end
    end

    if (bLandZoneContainsNonScouts or tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 2 or (GetGameTimeSeconds() <= 420 and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 3000 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] < 3)) and (tLZData[M28Map.subrefLZOrWZMexCount] > 0 or tLZData[M28Map.subrefLZTotalSegmentCount] > 30) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTScoutsTravelingHere]) then
        --Want a land scout for htis land zone, unless we already have one traveling here; if we have available land scouts then will change this flag back to false
        if bDebugMessages == true then LOG(sFunctionRef..': Probably want scout for this zone, doing further checks, subrefbPacifistArea='..tostring(tLZData[M28Map.subrefbPacifistArea] or false)..'; subrefbTeamHasOmniVision='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmniVision] or false)..'; Is midpoint in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]))..'; subrefLZbCoreBase='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])..'; subrefTEnemyUnits empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))) end
        if not(tLZData[M28Map.subrefbPacifistArea]) and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmniVision]) then
            if not(M28Map.bIsCampaignMap) or M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then
                if not(tLZTeamData[M28Map.subrefLZbCoreBase]) or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    tLZTeamData[M28Map.refbWantLandScout] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; We want to get a scout for this LZ '..(iLandZone or 'nil')..' on plateau '..(iPlateau or 'nil')..' with island '..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..'; setting refbWantLandScout to true') end
                elseif (GetGameTimeSeconds() >= 240 or M28Team.tTeamData[iTeam][M28Team.subrefiLowestFriendlyLandFactoryTech] > 1) and tLZTeamData[M28Map.refiRadarCoverage] < M28UnitInfo.iT3RadarSize - 20 then
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts]) == false and (tLZTeamData[M28Map.subrefMexCountByTech][2] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.refiRadarCoverage] < M28UnitInfo.iT2RadarSize - 10) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want scout as have priority units wanting scouts') end
                        tLZTeamData[M28Map.refbWantLandScout] = true
                    elseif not(tLZTeamData[M28Map.refbBaseInSafePosition]) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                            local tAdjLZTeamData =  M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                            if tAdjLZTeamData[M28Map.refbWantLandScout] and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftoUnitsWantingPriorityScouts]) == false and tAdjLZTeamData [M28Map.refiRadarCoverage] < M28UnitInfo.iT2RadarSize - 20 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Adjacent zone has priority units wanting land scout so will build one here') end
                                tLZTeamData[M28Map.refbWantLandScout] = true
                                break
                            end
                        end
                    end
                end
            end
        end
    end

    --Do we have any land scouts that are available? if so then assign to an adjacent land zone if the adjacent zone wants scouts (exception if we have LC1 scout which we want to assign to enemy base zone if its available)
    if M28Utilities.IsTableEmpty(tScouts) == false then
        tLZTeamData[M28Map.refiTimeLastHadVisual] = GetGameTimeSeconds()
        local tAvailableScouts = {}
        local bCheckForEnemies = false
        local tEnemyUnitTablesToConsider = {}
        local bFriendlyCombatInAdjZone = false
        if M28Utilities.bCPUPerformanceMode then
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                table.insert(tEnemyUnitTablesToConsider, tLZTeamData[M28Map.reftoNearestDFEnemies])
                bCheckForEnemies = true
            end
        else
            --Check for neemies if there are any in this or adjacent land zone
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                --if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 then
                table.insert(tEnemyUnitTablesToConsider, tLZTeamData[M28Map.subrefTEnemyUnits])
            end

            if tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= 50 then bFriendlyCombatInAdjZone = true end

            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if enemies in iAdjLZ='..iAdjLZ..'; enemy combat total='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal]) end
                    if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] > 0 then
                        table.insert(tEnemyUnitTablesToConsider, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits])
                    end
                    if not(bFriendlyCombatInAdjZone) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTThreatAllyCombatTotal] > 50 then
                        bFriendlyCombatInAdjZone = true
                    end
                end
            end
            if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
                for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                    local tAdjLZTeamData = M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam]
                    if (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) > 0 then
                        table.insert(tEnemyUnitTablesToConsider, tAdjLZTeamData[M28Map.subrefTEnemyUnits])
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tEnemyUnitTablesToConsider) == false then bCheckForEnemies = true end
        end

        local oEnemyToRunFrom
        local oPrevEnemyToRunFrom
        local iRunThreshold --If get this close to being in range of an enemy should try to run

        if tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= math.max(5000, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 4) then iRunThreshold = 15
        elseif tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= 200 then iRunThreshold = 17
        elseif bFriendlyCombatInAdjZone then iRunThreshold = 20
        else iRunThreshold = 27
        end

        local iAttackThreshold = 35
        if bDebugMessages == true then LOG(sFunctionRef..': About to consider orders for scouts in this LZ, size of tScouts='..table.getn(tScouts)..'; bCheckForEnemies='..tostring(bCheckForEnemies)..'; Enemy combat total='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]) end
        local oEnemyToConsiderAttacking
        local iEnemyToConsiderAttackingDist
        local bConsiderAttacking = false
        local iCurDist
        local bStandAlmostStill = false
        local iActualCurDist
        local iClosestDangerousEnemy
        local oClosestDangerousEnemy
        local toEscortScouts = {}
        local bEnemyIsImmobile
        local iClosestEnemy = 1000
        local oClosestEnemy
        local iImmobileDistAdjust = math.min(iRunThreshold, 5)
        local bClosestDangerousEnemyIsImmobile
        local toNearbyEnemyGunships, bWantScoutToCloak
        for iScout, oScout in tScouts do
            if bWantScoutToCloak then bWantScoutToCloak = false end
            oEnemyToConsiderAttacking = nil
            bConsiderAttacking = false
            if not(oScout.Dead) and oScout:GetFractionComplete() == 1 then

                if bDebugMessages == true then LOG(sFunctionRef..': Considering scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..'; bCheckForEnemies='..tostring(bCheckForEnemies)) end
                if bCheckForEnemies then
                    --Selen - if nearby enemy gunship then cloak
                    if oScout.UnitId == 'xsl0101' then
                        --Record any gunships in this and adjacent zones if not already
                        if toNearbyEnemyGunships == nil then
                            toNearbyEnemyGunships = {}
                            function CheckForEnemyGunships(tZoneTeamData)
                                if bDebugMessages == true then LOG(sFunctionRef..': Do we want to hide from air for cur zone being considered, refiEnemyAirToGroundThreat='..tZoneTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Is table of enemy air units empty='..tostring(M28Utilities.IsTableEmpty(tZoneTeamData[M28Map.reftLZEnemyAirUnits]))) end
                                if tZoneTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 and M28Utilities.IsTableEmpty(tZoneTeamData[M28Map.reftLZEnemyAirUnits]) == false then
                                    for iAir, oAir in tZoneTeamData[M28Map.reftLZEnemyAirUnits] do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to cloak due to nearby gunship, oAir='..oAir.UnitId..M28UnitInfo.GetUnitLifetimeCount(oAir)..'; Dist between scout and this='..M28Utilities.GetDistanceBetweenPositions(oAir:GetPosition(), oScout:GetPosition())) end
                                        if EntityCategoryContains(M28UnitInfo.refCategoryGunship, oAir.UnitId) then
                                            table.insert(toNearbyEnemyGunships, oAir)
                                        end
                                    end
                                end
                            end
                            CheckForEnemyGunships(tLZTeamData)
                            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                    local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                                    local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                                    CheckForEnemyGunships(tAdjLZTeamData, oScout)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAjdLZ='..iAdjLZ..' for if want to run from gunships') end
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(toNearbyEnemyGunships) == false then
                            for iGunship, oGunship in toNearbyEnemyGunships do
                                if M28Utilities.GetDistanceBetweenPositions(oScout:GetPosition(), oGunship:GetPosition()) <= 30 + (oGunship[M28UnitInfo.refiCombatRange] or 20) then
                                    bWantScoutToCloak = true
                                    break
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': bWantScoutToCloak='..tostring(bWantScoutToCloak)..'; oScout[M28UnitInfo.refbUnitGivenCloakOrder]='..tostring(oScout[M28UnitInfo.refbUnitGivenCloakOrder] or false)) end
                        if bWantScoutToCloak then
                            if not(oScout[M28UnitInfo.refbUnitGivenCloakOrder]) then
                                M28UnitInfo.CloakUnit(oScout, false, true)
                            end
                        end
                    end
                    if not(bWantScoutToCloak) then
                        iClosestDangerousEnemy = 10000
                        oEnemyToRunFrom = nil
                        if (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 40 or (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0) < 30) and EntityCategoryContains(M28UnitInfo.refCategoryCombatScout, oScout.UnitId) and (oScout[M28UnitInfo.refiDFRange] or 0) >= 12 then
                            bConsiderAttacking = true
                            iEnemyToConsiderAttackingDist = 100000
                        end
                        if bDebugMessages == true and oPrevEnemyToRunFrom then LOG(sFunctionRef..': oPrevEnemyToRunFrom='..oPrevEnemyToRunFrom.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPrevEnemyToRunFrom)..'; Dist to prev enemy='..M28Utilities.GetDistanceBetweenPositions(oPrevEnemyToRunFrom:GetPosition(), oScout:GetPosition())..'; Enemy range='..(oPrevEnemyToRunFrom[M28UnitInfo.refiDFRange] or 0)..'; Run threshold='..iRunThreshold..'; iLandZone='..iLandZone) end
                        if not(bConsiderAttacking) and oPrevEnemyToRunFrom and not(oPrevEnemyToRunFrom.Dead) and M28Utilities.GetDistanceBetweenPositions(oPrevEnemyToRunFrom:GetPosition(), oScout:GetPosition()) - (oPrevEnemyToRunFrom[M28UnitInfo.refiDFRange] or 0) <= iRunThreshold and oPrevEnemyToRunFrom[M28UnitInfo.refiDFRange] <= 29 and not(EntityCategoryContains(categories.MOBILE, oPrevEnemyToRunFrom.UnitId) and not(oPrevEnemyToRunFrom:IsUnitState('Moving')) and not(oPrevEnemyToRunFrom:IsUnitState('Attacking'))) then
                            --Run from same enemy
                            oEnemyToRunFrom = oPrevEnemyToRunFrom
                        else
                            bStandAlmostStill = false
                            bClosestDangerousEnemyIsImmobile = false
                            for iUnitTable, tUnitTable in tEnemyUnitTablesToConsider do
                                for iUnit, oUnit in tUnitTable do
                                    if M28UnitInfo.IsUnitValid(oUnit) then

                                        if bDebugMessages == true then LOG(sFunctionRef..': Looking for enemy to run from for scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..', considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Unit position='..repru(oUnit:GetPosition())..'; Unit last known position='..repru(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Dist between last known position and scout='..M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition())..'; Actual dist using actual position='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oScout:GetPosition())..'; Is unit visible='..tostring(M28UnitInfo.CanSeeUnit(oScout:GetAIBrain(), oUnit))..'; Unit range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; iRunThreshold='..iRunThreshold..'; Is distance within run threshold='..tostring(M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0) <= iRunThreshold)..'; bConsiderAttacking='..tostring(bConsiderAttacking)..'; Unit df range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Unit build range='..(oUnit:GetBlueprint().Economy.MaxBuildDistance or 'nil')..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; iClosestEnemy='..iClosestEnemy) end
                                        if bConsiderAttacking or (((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId))) then
                                            bEnemyIsImmobile = false
                                            if oUnit:IsUnitState('Upgrading') or oUnit:IsUnitState('BeingUpgraded') or EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) then
                                                bEnemyIsImmobile = true
                                            end
                                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition())
                                            if iCurDist < iClosestEnemy then
                                                iClosestEnemy = iCurDist
                                                oClosestEnemy = oUnit
                                            end
                                            --if iCurDist < iClosestFixedEnemy and
                                            if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                                                iCurDist = iCurDist - (oUnit:GetBlueprint().Economy.MaxBuildDistance or 0)
                                            elseif (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then
                                                if EntityCategoryContains(M28UnitInfo.refCategoryLandScout - M28UnitInfo.refCategoryCombatScout, oUnit.UnitId) and iCurDist < oUnit[M28UnitInfo.refiDFRange] + 2 and (not(bFriendlyCombatInAdjZone) or M28UnitInfo.GetUnitHealthPercent(oScout) < 0.5) then
                                                    --This means we should be far less likely to run from UEF and Aeon land scouts if we arent yet in range of them (and sometimes even if we are slightly in range)
                                                    iCurDist = iCurDist - (oUnit[M28UnitInfo.refiDFRange] or 0)
                                                else
                                                    iCurDist = iCurDist - (oUnit[M28UnitInfo.refiDFRange] or 0)
                                                end
                                                --If unit is immobile then reduce its range effective distance slightly as we will be much more aggressive in such a scenario
                                                if bEnemyIsImmobile then iCurDist = iCurDist - iImmobileDistAdjust end
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': iCurDist after adjusting for range='..iCurDist) end
                                            if iCurDist < iClosestDangerousEnemy and (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout * categories.TECH3 - categories.SERAPHIM, oUnit.UnitId))  then
                                                oClosestDangerousEnemy = oUnit
                                                iClosestDangerousEnemy = iCurDist
                                                bClosestDangerousEnemyIsImmobile = bEnemyIsImmobile
                                            end
                                            if iCurDist <= iRunThreshold then
                                                oEnemyToRunFrom = oUnit
                                                if bConsiderAttacking and iCurDist >= 4 and EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) and iClosestDangerousEnemy > iRunThreshold then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Decent dist until we are in range of engineer so will look to stand almost still instead of retreating') end
                                                    bStandAlmostStill = true
                                                else
                                                    bStandAlmostStill = false
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': Want to run from unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so will stop searching unless considering attacking, iClosestDangerousEnemy='..iClosestDangerousEnemy..'; iRunThreshold='..iRunThreshold..'; bConsiderAttacking='..tostring(bConsiderAttacking)) end
                                                if not(bConsiderAttacking) or (iClosestDangerousEnemy < iRunThreshold and not(bClosestDangerousEnemyIsImmobile)) then break end
                                            else
                                                --Adjust run threshold if enemy unit is moving, and facing towards us
                                                if iCurDist - 2 <= iRunThreshold and oUnit:IsUnitState('Moving') and M28Utilities.GetAngleDifference(M28UnitInfo.GetUnitFacingAngle(oUnit), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oScout:GetPosition())) <= 15 then
                                                    oEnemyToRunFrom = oUnit
                                                    bStandAlmostStill = false
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to run as unit is facing us and still relatively close, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so will stop searching') end
                                                    if not(bConsiderAttacking) or iClosestDangerousEnemy < iRunThreshold then break end
                                                elseif bConsiderAttacking and ((oUnit[M28UnitInfo.refiDFRange] or 0) == 0 or EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) and iCurDist < math.min(iAttackThreshold, iEnemyToConsiderAttackingDist, iClosestDangerousEnemy) and (not(oUnit[refoLandScoutTarget]) or iCurDist < 30) then
                                                    oEnemyToConsiderAttacking = oUnit
                                                    iEnemyToConsiderAttackingDist = iCurDist
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to consider attacking the unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' but will first check no units to run from') end
                                                else
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is too far away for us to run from it, will keep looking subject to considering if its close enough we should stand still instead, iCurDist='..iCurDist) end
                                                    if not(oEnemyToRunFrom) then
                                                        --Try to approximate case where enemy has a unit that is approaching our scout, and we are moving away, only to move back again - a human player would know to only move the scout a small bit to allow intel to catchup on the enemy unit; so will approximate that by having hte scout 'retreat' but not by much, if the enemy near
                                                        iActualCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oScout:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0)
                                                        if iActualCurDist - 5 <= iRunThreshold and (iActualCurDist - 3.5 <= iRunThreshold or oUnit:IsUnitState('Moving')) then
                                                            oEnemyToRunFrom = oUnit
                                                            bStandAlmostStill = true
                                                        end
                                                    end
                                                end
                                            end

                                            --Check if about to get in range of engineer that can reclaim us - have done +8 as lower values resulted in some cases in the engineer being able to reclaim the scout
                                        elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) <= 8 + (oUnit:GetBlueprint().Economy.MaxBuildDistance or 3) then
                                            oEnemyToRunFrom = oUnit
                                            break
                                        end
                                    end
                                end
                            end
                        end
                        if bConsiderAttacking then
                            local bAttackBuildingEvenIfCloseToEnemy = false
                            if bDebugMessages == true then LOG(sFunctionRef..': bClosestDangerousEnemyIsImmobile='..tostring(bClosestDangerousEnemyIsImmobile)..'; oClosestEnemy='..(oClosestEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestEnemy) or 'nil')..'; oEnemyToRunFrom='..(oEnemyToRunFrom.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEnemyToRunFrom) or 'nil')..'; iClosestDangerousEnemy='..iClosestDangerousEnemy) end
                            if bClosestDangerousEnemyIsImmobile and oClosestEnemy and oEnemyToRunFrom and not(oClosestEnemy == oEnemyToRunFrom) and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oClosestEnemy.UnitId) then
                                local iActualDistToClosestDangerousEnemy = M28Utilities.GetDistanceBetweenPositions(oEnemyToRunFrom:GetPosition(), oScout:GetPosition())
                                --If we move to be in range of the closest enemy building, will we be in range of the closest enemy to run from?
                                if bDebugMessages == true then LOG(sFunctionRef..': iActualDistToClosestDangerousEnemy='..iActualDistToClosestDangerousEnemy..'; iClosestEnemy='..iClosestEnemy..'; Closest enemy combat range='..(oEnemyToRunFrom[M28UnitInfo.refiCombatRange] or 0)..'; oEnemyToConsiderAttacking before considering if nearest unit is building='..(oEnemyToConsiderAttacking.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEnemyToConsiderAttacking) or 'nil')) end
                                if iActualDistToClosestDangerousEnemy > (oEnemyToRunFrom[M28UnitInfo.refiCombatRange] or 0) + 1 and iActualDistToClosestDangerousEnemy > iClosestEnemy then
                                    if not(oEnemyToConsiderAttacking == oClosestEnemy) and EntityCategoryContains(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryEngineer, oClosestEnemy.UnitId) and (iClosestDangerousEnemy <= iRunThreshold or not(oEnemyToConsiderAttacking)) then
                                        oEnemyToConsiderAttacking = oEnemyToConsiderAttacking
                                        if bDebugMessages == true then LOG(sFunctionRef..': Changing oEnemyToConsiderAttacking to be the nearest building to the combat scout') end
                                    end
                                    local tPotentialAttackPosition = M28Utilities.MoveInDirection(oClosestEnemy:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestEnemy:GetPosition(), oScout:GetPosition()), oScout[M28UnitInfo.refiDFRange], true)
                                    if tPotentialAttackPosition and M28Utilities.GetDistanceBetweenPositions(tPotentialAttackPosition, oEnemyToRunFrom:GetPosition()) >= 1 + (oEnemyToRunFrom[M28UnitInfo.refiCombatRange] or 0) then
                                        bAttackBuildingEvenIfCloseToEnemy = true
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': oClosestEnemy='..oClosestEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemy)..'; oEnemyToRunFrom='..oEnemyToRunFrom.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToRunFrom)..'; Dist to potential attack location from closest enemy='..M28Utilities.GetDistanceBetweenPositions(tPotentialAttackPosition, oEnemyToRunFrom:GetPosition())..'; bAttackBuildingEvenIfCloseToEnemy='..tostring(bAttackBuildingEvenIfCloseToEnemy)) end
                                end
                            end
                            if not(bAttackBuildingEvenIfCloseToEnemy) then
                                if iClosestDangerousEnemy - 8 <= iRunThreshold then oEnemyToConsiderAttacking = nil
                                elseif oEnemyToRunFrom and M28UnitInfo.GetCombatThreatRating({ oEnemyToRunFrom }, true) <= 11 and not(EntityCategoryContains(M28UnitInfo.refCategoryLandCombat, oEnemyToRunFrom.UnitId)) then
                                    oEnemyToConsiderAttacking = oEnemyToRunFrom
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will consider attacking unit as closest dangerous enemy is still a bit from being in our range, iClosestDangerousEnemy='..iClosestDangerousEnemy) end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Do we have a valid enemy unit to run from='..tostring(M28UnitInfo.IsUnitValid(oEnemyToRunFrom))..'; ENemy ID if any='..(oEnemyToRunFrom.UnitId or 'nil')..'; oEnemyToConsiderAttacking='..(oEnemyToConsiderAttacking.UnitId or 'nil')..'; iClosestDangerousEnemy='..iClosestDangerousEnemy) end
                end
                if oClosestDangerousEnemy then
                    oScout[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] = oClosestDangerousEnemy
                    if bDebugMessages == true then LOG(sFunctionRef..': setting refoClosestEnemyFromLastCloseToEnemyUnitCheck to be oClosestDangerousEnemy='..oClosestDangerousEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestDangerousEnemy)) end
                end
                if oScout.UnitId == 'xsl0101' and oEnemyToRunFrom and not(oEnemyToConsiderAttacking) and oScout[M28UnitInfo.refbUnitGivenCloakOrder] and not(tLZTeamData[M28Map.refiEnemyOmniCoverage] or 0) > 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Selen is cloaked so will stay cloaked instead of running') end
                    bWantScoutToCloak = true
                end
                if bWantScoutToCloak then
                    --Do nothing - already dealt with above
                elseif oEnemyToConsiderAttacking and M28UnitInfo.IsUnitValid(oEnemyToConsiderAttacking) then
                    tLZTeamData[M28Map.refbWantLandScout] = false
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oEnemyToConsiderAttacking:GetPosition(), oScout:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': Have an enemy to attack with combat scout, oEnemyToConsiderAttacking='..oEnemyToConsiderAttacking.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToConsiderAttacking)..'; iCurDist='..iCurDist..'; oScout[M28UnitInfo.refbLastShotBlocked]='..tostring(oScout[M28UnitInfo.refbLastShotBlocked])..'; Health% of enemy to consider attacking='..M28UnitInfo.GetUnitHealthPercent(oEnemyToConsiderAttacking)..'; Time of last weapon event='..GetGameTimeSeconds() - (oScout[M28UnitInfo.refiLastWeaponEvent] or 0)..'; setting refbWantLandScout to false') end
                    if iCurDist >= 9 then
                        --Move closer if our shot is blocked and enemy isnt an engineer; also some redundancy incase our shot is blocked but isnt registering as blocked
                        if (oScout[M28UnitInfo.refbLastShotBlocked] or (iCurDist >= 8 and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oEnemyToConsiderAttacking.UnitId) and (M28UnitInfo.GetUnitHealthPercent(oEnemyToConsiderAttacking) >= 1 or oEnemyToConsiderAttacking:GetHealth() <= 10))) and (not(EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oEnemyToConsiderAttacking.UnitId)) or (iCurDist >= 5 and iCurDist > oEnemyToConsiderAttacking:GetBlueprint().Economy.MaxBuildDistance)) then
                            M28Orders.IssueTrackedMove(oScout, oEnemyToConsiderAttacking:GetPosition(), 4, false, 'SelSM', false)
                        else
                            M28Orders.IssueTrackedAttackMove(oScout, oEnemyToConsiderAttacking:GetPosition(), 4, false, 'SelSA', false)
                        end
                    else
                        --Are too close so run away temporarily
                        RunFromEnemy(oScout, oEnemyToConsiderAttacking, iTeam, iPlateau, 16)
                    end
                    oPrevEnemyToRunFrom = nil --DOnt want to bypass checking enemy units incase there is a threatening one nearby
                elseif oEnemyToRunFrom then
                    tLZTeamData[M28Map.refbWantLandScout] = false
                    if bDebugMessages == true then LOG(sFunctionRef..': Want scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..' to run from oEnemyToRunFrom '..oEnemyToRunFrom.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToRunFrom)..' unless iti s a combat scout vs an engineer/mex in a low threat LZ in which case want it to attack the unit; LZ combat total='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Scout DF range='..(oScout[M28UnitInfo.refiDFRange] or 'nil')..'; Do we have a combat scout='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryCombatScout, oScout.UnitId))..'; Distance to nearest enemy='..M28Utilities.GetDistanceBetweenPositions(oEnemyToRunFrom:GetPosition(), oScout:GetPosition())..'; bStandAlmostStill='..tostring(bStandAlmostStill)..'; setting refbWantLandScout to false') end
                    oPrevEnemyToRunFrom = oEnemyToRunFrom
                    if bStandAlmostStill then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and run from enemy but only a short way as want to almost stand still') end
                        RunFromEnemy(oScout, oEnemyToRunFrom, iTeam, iPlateau, 3)
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and run from the nearest enemy') end
                        RunFromEnemy(oScout, oEnemyToRunFrom, iTeam, iPlateau, 16)
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': No nearby enemy to run from, Considering if scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..' is available; reftiPlateauAndLZToMoveTo='..repru(oScout[reftiPlateauAndLZToMoveTo])) end
                    if oScout[reftiPlateauAndLZToMoveTo] then
                        --Make scout available if its target LZ is this LZ
                        if oScout[reftiPlateauAndLZToMoveTo][2] == iLandZone and oScout[reftiPlateauAndLZToMoveTo][1] == iPlateau then
                            --Clear this unit from list of traveling units, but dont make it available as want a slight delay, so want it to be available on the next cycle
                            if bDebugMessages == true then LOG(sFunctionRef..': Scout is traveling to this land zone and is here so will clear the trackers so next cycle it is shown as available, setting refbWantLandScout to false') end
                            RemoveUnitFromListOfUnitsTravelingToLandZone(oScout)
                            tLZTeamData[M28Map.refbWantLandScout] = false
                        else
                            --Scout should be traveling to another land zone - if it has no orders then refresh them
                            if bDebugMessages == true then LOG(sFunctionRef..': Scout should travel to another land zone so order it to travel there') end
                            M28Orders.IssueTrackedMove(oScout, M28Map.tAllPlateaus[oScout[reftiPlateauAndLZToMoveTo][1]][M28Map.subrefPlateauLandZones][oScout[reftiPlateauAndLZToMoveTo][2]][M28Map.subrefMidpoint], 6, false, 'TLZ'..oScout[reftiPlateauAndLZToMoveTo][2])
                        end
                    elseif oScout[M28Navy.refiWZToMoveTo] then
                        --Scout should be traveling to another water zone - if it has no orders then refresh them
                        M28Orders.IssueTrackedMove(oScout, M28Map.tPondDetails[M28Map.tiPondByWaterZone[oScout[M28Navy.refiWZToMoveTo]]][M28Map.subrefPondWaterZones][oScout[M28Navy.refiWZToMoveTo]][M28Map.subrefMidpoint], 6, false, 'TWZ'..oScout[M28Navy.refiWZToMoveTo])
                        if bDebugMessages == true then LOG(sFunctionRef..': Scout should travel to a water zone '..oScout[M28Navy.refiWZToMoveTo]..' so will resend the order to ensure it is still moving there') end
                    else
                        --Scout has no nearby enemies to run from, and isnt traveling to a plateau, so it should be available for use
                        if bDebugMessages == true then LOG(sFunctionRef..': Dont want to run or attack with scout and it isnt already assigned to another LZ so will aadd to table of available scouts, oScout='..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..'; oScout[refoLandScoutTarget]='..(oScout[refoLandScoutTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oScout[refoLandScoutTarget]) or 'nil')) end
                        if M28UnitInfo.GetUnitLifetimeCount(oScout) == 1 then
                            --Assign to enemy base if it is in the same island
                            local iEnemyBasePlateauOrZero, iEnemyBaseLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tLZTeamData[M28Map.reftClosestEnemyBase])
                            local bGoingToEnemyBase = false
                            if iEnemyBasePlateauOrZero == iPlateau and iEnemyBaseLZOrWZ then
                                local tEnemyBaseLZData = M28Map.tAllPlateaus[iEnemyBasePlateauOrZero][M28Map.subrefPlateauLandZones][iEnemyBaseLZOrWZ]
                                local tEnemyBaseLZTeamData = tEnemyBaseLZData[M28Map.subrefLZTeamData][iTeam]
                                if M28Utilities.IsTableEmpty(tEnemyBaseLZTeamData[M28Map.subrefTScoutsTravelingHere]) and NavUtils.GetLabel(M28Map.refPathingTypeLand,tLZTeamData[M28Map.reftClosestEnemyBase]) == tLZData[M28Map.subrefLZIslandRef] and (tEnemyBaseLZTeamData[M28Map.refbWantLandScout] or M28Utilities.IsTableEmpty(tEnemyBaseLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Dealing with first ever land scout so will have it prioritise enemy base for intel, iEnemyBasePlateauOrZero='..iEnemyBasePlateauOrZero..'; iEnemyBaseLZOrWZ='..iEnemyBaseLZOrWZ) end
                                    bGoingToEnemyBase = true
                                end
                            end
                            if bGoingToEnemyBase then
                                GetUnitToTravelToLandZone(oScout, iEnemyBasePlateauOrZero, iEnemyBaseLZOrWZ, M28Map.subrefTScoutsTravelingHere)
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Adding scout to table of available scouts; did enemy base zone want land csout='..tostring(M28Map.tAllPlateaus[iEnemyBasePlateauOrZero][M28Map.subrefPlateauLandZones][iEnemyBaseLZOrWZ][M28Map.subrefLZTeamData][iTeam][M28Map.refbWantLandScout] or false)..'; Was table of land scouts traveling there empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iEnemyBasePlateauOrZero][M28Map.subrefPlateauLandZones][iEnemyBaseLZOrWZ][M28Map.subrefLZTeamData][M28Map.subrefTScoutsTravelingHere]))) end
                                table.insert(tAvailableScouts, oScout)
                            end
                        else
                            if oScout[refoLandScoutTarget] and M28UnitInfo.IsUnitValid(oScout[refoLandScoutTarget]) then
                                table.insert(toEscortScouts, oScout)
                                if bDebugMessages == true then LOG(sFunctionRef..': Scout is escorting unit '..oScout[refoLandScoutTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout[refoLandScoutTarget])) end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Will add scout to table of available scouts') end
                                table.insert(tAvailableScouts, oScout)
                            end
                        end
                    end
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Is available scout table empty='..tostring(M28Utilities.IsTableEmpty(tAvailableScouts))) end

        if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
            function AssignLandScoutToUnit(oUnitToReceiveScout)
                oUnitToReceiveScout[refoAssignedLandScout] = tAvailableScouts[1]
                tAvailableScouts[1][refoLandScoutTarget] = oUnitToReceiveScout
                table.insert(toEscortScouts, tAvailableScouts[1])
                table.remove(tAvailableScouts, 1)
                if bDebugMessages == true then LOG(sFunctionRef..': Have assigned scout to unit '..oUnitToReceiveScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToReceiveScout)) end
                if oUnitToReceiveScout[refbFlaggedForPriorityScout] then
                    oUnitToReceiveScout[refbFlaggedForPriorityScout] = false
                    oUnitToReceiveScout[refiTimeLastBuiltLandScoutForUnit] = nil
                    local iCurLandSubteam = oUnitToReceiveScout:GetAIBrain().M28LandSubteam
                    if M28Utilities.IsTableEmpty(M28Team.tLandSubteamData[iCurLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout]) == false then
                        for iEntry, oEntry in M28Team.tLandSubteamData[iCurLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout] do
                            if oEntry == oUnitToReceiveScout then
                                table.remove(M28Team.tLandSubteamData[iCurLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout], iEntry)
                                break
                            end
                        end
                    end
                    --Remove from LZTeamData
                    local tUnitLZData, tUnitLZTeamData = M28Map.GetLandOrWaterZoneData(oUnitToReceiveScout:GetPosition(), true, iTeam)
                    if M28Utilities.IsTableEmpty(tUnitLZTeamData[M28Map.reftoUnitsWantingPriorityScouts]) == false then
                        for iEntry, oEntry in tUnitLZTeamData[M28Map.reftoUnitsWantingPriorityScouts] do
                            if oEntry == oUnitToReceiveScout then
                                table.remove(tUnitLZTeamData[M28Map.reftoUnitsWantingPriorityScouts], iEntry)
                                break
                            end
                        end
                    end
                end
            end
            --If not a core zone and have ACU in this zone that lacks a decided scout, no nearby omni, and has an upgrade with decent df range (so guncom) then assign scout to it
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false and not(tLZTeamData[M28Map.subrefLZbCoreBase]) and tLZTeamData[M28Map.refiRadarCoverage] < math.min(300, math.max(200, M28UnitInfo.iT3RadarSize - 90)) then
                for iACU, oACU in tLZTeamData[M28Map.subrefAlliedACU] do
                    if not(M28UnitInfo.IsUnitValid(oACU[refoAssignedLandScout])) and (oACU[M28ACU.refiUpgradeCount] or 0) > 0 and oACU[M28UnitInfo.refiDFRange] >= 28 then
                        AssignLandScoutToUnit(oACU)
                        if M28Utilities.IsTableEmpty(tAvailableScouts) then break end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished assigning to any ACU if relevant, is reftoUnitsWantingPriorityScouts empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts]))..'; is tAvailableScouts empty='..tostring(M28Utilities.IsTableEmpty(tAvailableScouts))) end
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts]) == false and M28Utilities.IsTableEmpty(tAvailableScouts) == false then
                --Do same thing with units wanting priority land scout
                for iRecorded, oRecorded in tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts] do
                    AssignLandScoutToUnit(oRecorded)
                    if M28Utilities.IsTableEmpty(tAvailableScouts) then break end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished assigning scouts to priority units if any, is reftoUnitsWantingPriorityScouts empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts]))..'; is tAvailableScouts empty='..tostring(M28Utilities.IsTableEmpty(tAvailableScouts))) end
            if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
                --First assign any available scouts to adjacent land zones wanting scouts
                --Early game - prioritise zones with combat threat if we only have one scout available
                local bPrioritiseLandZonesWithFriendlyCombat = false
                local tFirstPlateauOrLZIfWantCombat
                if table.getn(tAvailableScouts) == 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 and (GetGameTimeSeconds() <= 360 or tLZTeamData[M28Map.refiRadarCoverage] <= 100) then bPrioritiseLandZonesWithFriendlyCombat = true end

                if bDebugMessages == true then LOG(sFunctionRef..': Will first allocate scouts to any adjacent land zones that want a scout. Is table of adj zones empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]))) end
                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
                    local bDontCheckInPlayableArea = not(M28Map.bIsCampaignMap)
                    for _, iAdjLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Consideri niAdjLZ='..iAdjLZ..'; Does this LZ want land scout='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.refbWantLandScout] or false)..'; Is table of traveling scouts here empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTScoutsTravelingHere]))) end
                        local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                        if tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refbWantLandScout] and (bDontCheckInPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint])) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will send land scout '..tAvailableScouts[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tAvailableScouts[1])..' to go to adjacent land zone '..iAdjLZ..' in plateau '..iPlateau) end
                            if not(tAdjLZData[M28Map.subrefbPacifistArea]) then
                                if not(bPrioritiseLandZonesWithFriendlyCombat) or M28Utilities.IsTableEmpty(tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTAlliedCombatUnits]) == false then

                                    GetUnitToTravelToLandZone(tAvailableScouts[1], iPlateau, iAdjLZ, M28Map.subrefTScoutsTravelingHere)
                                    tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refbWantLandScout] = false
                                    if bDebugMessages == true then LOG(sFunctionRef..': Scout allocated to adjacent iAdjLZ='..iAdjLZ..' so flagging that zone no longer wants scouts, setting refbWantLandScout to false') end
                                    table.remove(tAvailableScouts, 1)
                                    if M28Utilities.IsTableEmpty(tAvailableScouts) then break end
                                else
                                    --We want to prioritise an adjacent zone wanting scouts
                                    if not(tFirstPlateauOrLZIfWantCombat) then
                                        tFirstPlateauOrLZIfWantCombat = {iPlateau, iAdjLZ}
                                    end
                                end
                            end
                        end
                    end
                    if bPrioritiseLandZonesWithFriendlyCombat and M28Utilities.IsTableEmpty(tAvailableScouts) == false and tFirstPlateauOrLZIfWantCombat then
                        GetUnitToTravelToLandZone(tAvailableScouts[1], tFirstPlateauOrLZIfWantCombat[1], tFirstPlateauOrLZIfWantCombat[2], M28Map.subrefTScoutsTravelingHere)
                        M28Map.tAllPlateaus[tFirstPlateauOrLZIfWantCombat[1]][M28Map.subrefPlateauLandZones][tFirstPlateauOrLZIfWantCombat[2]][M28Map.subrefLZTeamData][iTeam][M28Map.refbWantLandScout] = false

                        if bDebugMessages == true then LOG(sFunctionRef..': Sending scout to the land zone='..tFirstPlateauOrLZIfWantCombat[2]..' so will flag it no longer wants scouts, so setting refbWantLandScout to false') end
                        table.remove(tAvailableScouts, 1)
                    end
                end
                --Now assign any remaining available scouts to adjacent water zones wanting scouts (if any)
                if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                        local tAmphibiousOrHoverScouts = EntityCategoryFilterDown(M28UnitInfo.refCategoryAmphibious + categories.HOVER, tAvailableScouts)
                        if M28Utilities.IsTableEmpty(tAmphibiousOrHoverScouts) == false then
                            local iPond, iAdjWZ
                            for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                                iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                                iPond = M28Map.tiPondByWaterZone[iAdjWZ]
                                local tAdjWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
                                if tAdjWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refbWantLandScout] then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering tAmphibiousOrHoverScouts, size of table='..table.getn(tAmphibiousOrHoverScouts)) end
                                    M28Navy.GetUnitToTravelToWaterZone(tAmphibiousOrHoverScouts[1], iPond, iAdjWZ, M28Map.subrefTScoutsTravelingHere)
                                    M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.refbWantLandScout] = false
                                    local iAvailableScoutRef
                                    for iUnit, oUnit in tAvailableScouts do
                                        if oUnit == tAmphibiousOrHoverScouts[1] then
                                            iAvailableScoutRef = iUnit
                                            break
                                        end
                                    end
                                    table.remove(tAmphibiousOrHoverScouts, 1)
                                    if iAvailableScoutRef then
                                        table.remove(tAvailableScouts, iAvailableScoutRef)
                                    end
                                    if M28Utilities.IsTableEmpty(tAmphibiousOrHoverScouts) then
                                        break
                                    end
                                end
                            end
                        end
                    end

                    if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': We still have available scouts so setting refbWantLandScout to false, value before this='..tostring(tLZTeamData[M28Map.refbWantLandScout])) end
                        tLZTeamData[M28Map.refbWantLandScout] = false
                        --Want to apply if core base, as we dont treat core bases as wanting land scouts normally, meaning if only adjacent zones are also core bases we get stuck where we think we never have any targets for land scouts on the island
                        if tLZTeamData[M28Map.subrefLZbCoreBase] or table.getn(tAvailableScouts) > 1 then
                            --Look for further away zones in this island wanting land scouts
                            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                                for iEntry, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                                    local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                                    if tTeamTargetLZData[M28Map.refbWantLandScout] then
                                        --Consider assigning to priority units wanting land scouts as a backup to normal logic
                                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts]) == false then
                                            for iCurRecorded = table.getn(tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts]), 1, -1 do
                                                local oCurRecorded = tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts][iCurRecorded]
                                                if M28UnitInfo.IsUnitValid(oCurRecorded) then
                                                    if M28UnitInfo.IsUnitValid(oCurRecorded[refoAssignedLandScout]) then --redundancy
                                                        oCurRecorded[refbFlaggedForPriorityScout] = false
                                                        oCurRecorded[refiTimeLastBuiltLandScoutForUnit] = nil
                                                        table.remove(tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts], iCurRecorded)
                                                    else
                                                        AssignLandScoutToUnit(oCurRecorded)
                                                    end
                                                end
                                            end
                                        end

                                        if bDebugMessages == true then LOG(sFunctionRef..': Getting scout '..tAvailableScouts[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tAvailableScouts[1])..' to go from iLandZone '..iLandZone..'; to furhter away LZ='..tPathingDetails[M28Map.subrefLZNumber]..'; setting refbWantLandScout to false') end
                                        GetUnitToTravelToLandZone(tAvailableScouts[1], iPlateau, tPathingDetails[M28Map.subrefLZNumber], M28Map.subrefTScoutsTravelingHere)
                                        tTeamTargetLZData[M28Map.refbWantLandScout] = false
                                        table.remove(tAvailableScouts, 1)
                                        if M28Utilities.IsTableEmpty(tAvailableScouts) then break end
                                    end
                                    --subrefLZNumber = 1 --Land zone reference number
                                    --subrefLZPath = 2 --against subrefLZPathingToOtherLandZones subtable, returns a table [x]=1,2,3...; which returns the land zone reference for each land zone that will go through on a path from these
                                    --subrefLZTravelDist = 3 --against subrefLZPathingToOtherLandZones subtable
                                end
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': We only have 1 available scout, so dont want to flag that we couldnt find any land scouts') end
                        end
                        if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
                            if table.getn(tAvailableScouts) > 1 then
                                if not(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandTimeLastFailedLandScoutByTeam][iTeam][tLZData[M28Map.subrefLZIslandRef]]) then
                                    if not(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandTimeLastFailedLandScoutByTeam][iTeam]) then
                                        if not(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandTimeLastFailedLandScoutByTeam]) then M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandTimeLastFailedLandScoutByTeam] = {} end
                                        M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandTimeLastFailedLandScoutByTeam][iTeam] = {}
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Have multiple available land scouts still for P'..iPlateau..'Z'..iLandZone..' at time='..GetGameTimeSeconds()..' so will record this for the island '..tLZData[M28Map.subrefLZIslandRef]..'; is reftoPriorityUnitsWantingLandScout empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tLandSubteamData[tAvailableScouts[1]:GetAIBrain().M28LandSubteam][M28Team.reftoPriorityUnitsWantingLandScout]))) end
                                M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandTimeLastFailedLandScoutByTeam][iTeam][tLZData[M28Map.subrefLZIslandRef]] = GetGameTimeSeconds()
                                tLZTeamData[M28Map.refiSpareLandScouts] = table.getn(tAvailableScouts)
                            end
                            --If we are here then we still have available land scouts; if we have ap atrol path then patrol; if we have a mex then go here, if we have an adjcent zone go here, otherwise move randomly if we have no orders
                            for iScout, oScout in tAvailableScouts do
                                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subreftPatrolPath]) == false then
                                    --Patrol the land zone
                                    M28Orders.PatrolPath(oScout, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subreftPatrolPath], false, 'SP')
                                else
                                    --Do nothing if scout is moving as maybe it landed on a segment just out of the zone it shoudl have been in
                                    if not(oScout:IsUnitState('Moving')) then
                                        M28Orders.UpdateRecordedOrders(oScout)
                                        if (oScout[M28Orders.refiOrderCount] or 0) == 0 then
                                            --Want ot get somewhere to move to as a backup
                                            if tLZData[M28Map.subrefLZOrWZMexCount] > 0 then
                                                M28Orders.IssueTrackedMove(oScout, tLZData[M28Map.subrefMidpoint], 5, false, 'BackupMid')
                                            else
                                                --Do we have an adjacent LZ? If so move here
                                                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
                                                    GetUnitToTravelToLandZone(tAvailableScouts[1], iPlateau, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones][1], M28Map.subrefTScoutsTravelingHere)
                                                else
                                                    --No adjacent LZs, and no mexes in this LZ, so just move randomly
                                                    M28Orders.IssueTrackedMove(oScout, M28Utilities.MoveInDirection(oScout:GetPosition(), math.random(1, 360), math.random(10, 30), true, false, true), 5, false, 'BackupRnd')
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(toEscortScouts) == false then
            local bRemoveAssignment = false
            for iScout, oScout in toEscortScouts do
                --If target is underwater and we are not amphibious/hover, then no longer assign
                if M28UnitInfo.IsUnitUnderwater(oScout[refoLandScoutTarget]) and not(EntityCategoryContains(M28UnitInfo.refCategoryAmphibious + categories.HOVER, oScout.UnitId)) then
                    oScout[refoLandScoutTarget][refoAssignedLandScout] = nil
                    oScout[refoLandScoutTarget] = nil
                else
                    M28Orders.IssueTrackedMove(oScout, M28Utilities.MoveInDirection(oScout[refoLandScoutTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(oScout[refoLandScoutTarget]:GetPosition(), oScout:GetPosition()), 8, true, false, true), 1.5, false, 'ScACU'..oScout[refoLandScoutTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout[refoLandScoutTarget]))
                end
            end
        end

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateBestEnemyRangesForThisLandZone(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateBestEnemyRangesForThisLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Update best range values for enemies and allies
    local iEnemyBestMobileDFRange = 0
    local iEnemyBestStructureDFRange = 0
    local iEnemyBestMobileIndirectRange = 0

    --First get range for this land zone
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) == false then
        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] do
            if iThreat > 20 then iEnemyBestMobileDFRange = math.max(iRange, iEnemyBestMobileDFRange) end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]='..repru(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange])..'; iEnemyBestMobileDFRange='..iEnemyBestMobileDFRange..'; Is table of enemy structure DF by range empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
            if iThreat > 20 then iEnemyBestStructureDFRange = math.max(iRange, iEnemyBestStructureDFRange) end
            if bDebugMessages == true then LOG(sFunctionRef..': iRange='..iRange..'; iThreat='..iThreat..'; iEnemyBestStructureDFRange after update='..iEnemyBestStructureDFRange) end
        end
    end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange]) == false then
        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] do
            if iThreat > 20 then iEnemyBestMobileIndirectRange = math.max(iRange, iEnemyBestMobileIndirectRange) end
        end
    end
    tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] = iEnemyBestMobileDFRange
    tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] = iEnemyBestStructureDFRange
    tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] = iEnemyBestMobileIndirectRange
    if bDebugMessages == true then LOG(sFunctionRef..': End of code for iLandZone '..iLandZone..'; tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]='..tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordClosestAdjacentEnemiesAndGetBestEnemyRange(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordClosestAdjacentEnemiesAndGetBestEnemyRange'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    tLZTeamData[M28Map.reftoNearestDFEnemies] = {}
    tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere] = nil
    local iEnemyBestMobileDFRange = 0
    local iEnemyBestStructureDFRange = 0
    local iEnemyBestMobileIndirectRange = 0
    tLZTeamData[M28Map.reftoAdjacentStructuresWithHighRange] = {}

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iTeam='..iTeam..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Enemies in this or adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
    if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] or tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
        iEnemyBestMobileDFRange = (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0)
        iEnemyBestStructureDFRange = (tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0)
        iEnemyBestMobileIndirectRange = (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0)

        --Adjust the ranges to factor in adjacent land zones
        local iLowestDistUntilInRange = 10000
        local oLowestDFDistUntilInRange
        local tMidpoint = tLZData[M28Map.subrefMidpoint]
        local iCurDistUntilInRange
        local iEnemyPDThreshold
        --If we have friendly units in this zone, then always include units within a threshold
        local iThresholdToAlwaysIncludeInDFRange
        local iMaxDistAwayToIncludeAdjUnitInDFRange
        local aiBrain = ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]]
        --local bIncludedNearestDFDueToMinRange
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            iThresholdToAlwaysIncludeInDFRange  = 0.5 * math.max(tLZData[M28Map.subrefLZMaxSegX] - tLZData[M28Map.subrefLZMinSegX], tLZData[M28Map.subrefLZMaxSegZ] - tLZData[M28Map.subrefLZMinSegZ]) * M28Map.iLandZoneSegmentSize
            iMaxDistAwayToIncludeAdjUnitInDFRange = iThresholdToAlwaysIncludeInDFRange + 20 --Want to include bit of an allowance as we might be managing units in the adjacent zone as well
        else
            iMaxDistAwayToIncludeAdjUnitInDFRange = 20 + 0.5 * math.max(tLZData[M28Map.subrefLZMaxSegX] - tLZData[M28Map.subrefLZMinSegX], tLZData[M28Map.subrefLZMaxSegZ] - tLZData[M28Map.subrefLZMinSegZ]) * M28Map.iLandZoneSegmentSize --Want to include bit of an allowance as we might be managing units in the adjacent zone as well
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Best mobile DF range for this zone only='..tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]..'; Mobile structure range='..tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange]..'; Mobile indirect='..tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange]..'; Is table of adjacent LZs empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]))..'; iMaxDistAwayToIncludeAdjUnitInDFRange='..iMaxDistAwayToIncludeAdjUnitInDFRange..'; Zone X size (diameter)='..(tLZData[M28Map.subrefLZMaxSegX] - tLZData[M28Map.subrefLZMinSegX])*M28Map.iLandZoneSegmentSize..'; Zone Z size (diameter)='..(tLZData[M28Map.subrefLZMaxSegZ] - tLZData[M28Map.subrefLZMinSegZ]) * M28Map.iLandZoneSegmentSize) end
        function UpdateForAdjacentLandZone(tAltLZTeamData)
            --iEnemyBestMobileDFRange = math.max(iEnemyBestMobileDFRange, tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange])
            --iEnemyBestStructureDFRange = math.max(iEnemyBestStructureDFRange, tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange])
            --Record adjacent structures that have high (highest recorded or >=50) DF range
            if M28Utilities.bCPUPerformanceMode then
                iEnemyPDThreshold = 60
            else
                iEnemyPDThreshold = math.min(50, math.max(     iEnemyBestMobileDFRange,iEnemyBestStructureDFRange))
            end
            if (tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0) >= iEnemyPDThreshold and M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                local tEnemyStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD, tAltLZTeamData[M28Map.subrefTEnemyUnits])
                if M28Utilities.IsTableEmpty(tEnemyStructures) == false then
                    for iUnit, oUnit in tEnemyStructures do
                        if (oUnit[M28UnitInfo.refiDFRange] or 0) >= iEnemyPDThreshold then
                            table.insert(tLZTeamData[M28Map.reftoAdjacentStructuresWithHighRange], oUnit)
                        end
                    end
                end
            end
            iEnemyBestMobileIndirectRange = math.max(iEnemyBestMobileIndirectRange, tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange])
            local toNearbyExperimentalsAndDistUntilInRange = {}
            if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent LZ, Enemy mobile DF for this LZ='..tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]..'; Mobile structure range='..tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange]..'; Mobile indirect='..tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange]..'; iThresholdToAlwaysIncludeInDFRange='..(iThresholdToAlwaysIncludeInDFRange or 'nil')) end
            if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subrefTEnemyUnits]) == false and tAltLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 10 then
                for iUnit, oUnit in tAltLZTeamData[M28Map.subrefTEnemyUnits] do
                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit[M28UnitInfo.refiDFRange] > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout * categories.TECH1 - categories.SERAPHIM, oUnit.UnitId)) then
                        --Ignore selens that are cloaked
                        if oUnit.UnitId == 'xsl0101' and M28UnitInfo.GetUnitSpeed(oUnit) < 0.2 and not(M28UnitInfo.CanSeeUnit(aiBrain, oUnit, false)) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will ignore cloaked enemy selen') end
                        else
                            iCurDistUntilInRange = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tMidpoint) - oUnit[M28UnitInfo.refiDFRange]
                            if EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then table.insert(toNearbyExperimentalsAndDistUntilInRange, {oUnit, iCurDistUntilInRange}) end
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' in adjacent zone and if it is close to being in range, iCurDistUntilInRange='..iCurDistUntilInRange..'; iLowestDistUntilInRange='..iLowestDistUntilInRange..'; DFRange='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; iMaxDistAwayToIncludeAdjUnitInDFRange='..iMaxDistAwayToIncludeAdjUnitInDFRange..'; Unit actual dist to this zone midpoint='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMidpoint)) end
                            if iCurDistUntilInRange < iLowestDistUntilInRange then
                                oLowestDFDistUntilInRange = oUnit
                                iLowestDistUntilInRange = iCurDistUntilInRange
                                --if iThresholdToAlwaysIncludeInDFRange then bIncludedNearestDFDueToMinRange = iCurDistUntilInRange <= iThresholdToAlwaysIncludeInDFRange end
                            end
                            if iCurDistUntilInRange <= iMaxDistAwayToIncludeAdjUnitInDFRange then
                                if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then
                                    if oUnit[M28UnitInfo.refiDFRange] > iEnemyBestMobileDFRange then iEnemyBestMobileDFRange = oUnit[M28UnitInfo.refiDFRange] end
                                else
                                    if oUnit[M28UnitInfo.refiDFRange] > iEnemyBestStructureDFRange then iEnemyBestStructureDFRange = oUnit[M28UnitInfo.refiDFRange] end
                                end
                                if iThresholdToAlwaysIncludeInDFRange and iCurDistUntilInRange <= iThresholdToAlwaysIncludeInDFRange then
                                    table.insert(tLZTeamData[M28Map.reftoNearestDFEnemies], oLowestDFDistUntilInRange)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Unit is close enough to being in range that we will include in nearest enemies') end
                                end
                            end
                        end
                    end
                end
            end
            if oLowestDFDistUntilInRange  then
                table.insert(tLZTeamData[M28Map.reftoNearestDFEnemies], oLowestDFDistUntilInRange)
            end
            --Include experimentals that are almost the closest unit (so our 'choose manual attack' logic works better)
            if M28Utilities.IsTableEmpty(toNearbyExperimentalsAndDistUntilInRange) == false then
                for iEntry, tExpSubtable in toNearbyExperimentalsAndDistUntilInRange do
                    if not(tExpSubtable[1] == oLowestDFDistUntilInRange) and tExpSubtable[2] - 20 <= math.max(5, iLowestDistUntilInRange) and (not(iThresholdToAlwaysIncludeInDFRange) or tExpSubtable[2] >= iThresholdToAlwaysIncludeInDFRange) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding further away experimental from adjacnet zone into table of nearest enemy DF units, Expeirmental unit='..tExpSubtable[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tExpSubtable[1])) end
                        table.insert(tLZTeamData[M28Map.reftoNearestDFEnemies], tExpSubtable[1])
                    end
                end
            end
        end
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for iEntry, iAdjLandZone in tLZData[M28Map.subrefLZAdjacentLandZones] do
                iLowestDistUntilInRange = 10000
                oLowestDFDistUntilInRange = nil
                UpdateForAdjacentLandZone(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLandZone][M28Map.subrefLZTeamData][iTeam])
            end
        end

        --Factor in non-adjacent zones that still have segments close enough to threaten this zone
        if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
            for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                UpdateForAdjacentLandZone(M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam])
            end
        end

        --Factor in adjacent water zones
        if bDebugMessages == true then LOG(sFunctionRef..': Is tLZData[M28Map.subrefAdjacentWaterZones] empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
        if tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
            local iAdjWZ, iPond
            for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                iPond = M28Map.tiPondByWaterZone[iAdjWZ]
                local tWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjWZ='..iAdjWZ..' for iPond='..iPond..'; Enemy Combat total='..(tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)..'; Is Nearest combat enemies empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]))) end
                if (tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 20 and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]) == false then
                    iEnemyBestMobileDFRange = math.max(iEnemyBestMobileDFRange, (tWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0))
                    iLowestDistUntilInRange = 10000
                    oLowestDFDistUntilInRange = nil

                    for iUnit, oUnit in tWZTeamData[M28Map.reftoNearestCombatEnemies] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0)) end
                        if M28UnitInfo.IsUnitValid(oUnit) and (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit.UnitId)) then
                            iCurDistUntilInRange = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tMidpoint) - oUnit[M28UnitInfo.refiDFRange]
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurDistUntilInRange='..iCurDistUntilInRange) end
                            if iCurDistUntilInRange < iLowestDistUntilInRange then
                                oLowestDFDistUntilInRange = oUnit
                                iLowestDistUntilInRange = iCurDistUntilInRange
                            end
                        end
                    end
                    if oLowestDFDistUntilInRange  then
                        table.insert(tLZTeamData[M28Map.reftoNearestDFEnemies], oLowestDFDistUntilInRange)
                    end
                end
            end
        end

        --Add all units from this zone into reftoNearestDFEnemies
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] then
            for iUnit, oUnit in tLZTeamData[M28Map.subrefTEnemyUnits] do
                if oUnit[M28UnitInfo.refiDFRange] > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) then
                    table.insert(tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit)
                end
            end
        end
    end

    --Record nearest enemy structure if this land zone is large enough and has no enemies (for performance reasons - dont want to risk doing this calculation on tiny zones/mini plateaus near an enemy base), and currently planned use is only for indirect fire units as a backup target
    tLZTeamData[M28Map.refbEnemiesInNearbyPlateau] = false
    if bDebugMessages == true then LOG(sFunctionRef..': Will check for nearby enemy structures if no enemies in this LZ, iPlateau='..iPlateau..'; iLandZOne='..iLandZone..'; Enemies in this or adj LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Total segment count='..tLZData[M28Map.subrefLZTotalSegmentCount]..'; Segment size='..M28Map.iLandZoneSegmentSize..'; is table of other land and water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]))) end
    if not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and tLZData[M28Map.subrefLZTotalSegmentCount] >= 150 / M28Map.iLandZoneSegmentSize then
        M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData)
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
            local iClosestEnemyDist = 10000
            local oClosestEnemy
            local iCurDist
            for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateauOrPond='..tSubtable[M28Map.subrefiPlateauOrPond]..'; Is water zone='..tostring(tSubtable[M28Map.subrefbIsWaterZone])..'; Distance='..tSubtable[M28Map.subrefiDistance]..'; iEntry='..iEntry) end
                if tSubtable[M28Map.subrefiDistance] >= 170 and (iEntry >= 7 or tSubtable[M28Map.subrefiDistance] >= 320) then break end
                if not(iPlateau == tSubtable[M28Map.subrefiPlateauOrPond]) and not(tSubtable[M28Map.subrefbIsWaterZone]) then
                    --Have a nearby land zone in a different plateau, check if there are enemy units in this LZ and (if so) if any of them are structures
                    local tAdjLZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                    if not(tAdjLZData[M28Map.subrefbPacifistArea]) then
                        local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]))) end
                        if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                            tLZTeamData[M28Map.refbEnemiesInNearbyPlateau] = true
                            local tEnemyStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tAdjLZTeamData[M28Map.subrefTEnemyUnits])
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy structures empty='..tostring(M28Utilities.IsTableEmpty(tEnemyStructures))) end
                            if M28Utilities.IsTableEmpty(tEnemyStructures) == false then
                                for iUnit, oUnit in tEnemyStructures do
                                    if M28UnitInfo.IsUnitValid(oUnit) then
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit:GetPosition())
                                        if iCurDist <= iClosestEnemyDist then
                                            oClosestEnemy = oUnit
                                            iClosestEnemyDist = iCurDist
                                            if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..iCurDist..'; this is the closest unit for now, will cycle through any remaining') end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for enemy structure in nearby different plateau, oClosestEnemy='..(oClosestEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestEnemy) or 'nli')) end
            tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere] = oClosestEnemy
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iEnemyBestMobileDFRange='..iEnemyBestMobileDFRange..'; iEnemyBestStructureDFRange='..iEnemyBestStructureDFRange..'; iEnemyBestMobileIndirectRange='..iEnemyBestMobileIndirectRange) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iEnemyBestMobileDFRange, iEnemyBestStructureDFRange, iEnemyBestMobileIndirectRange
end

function ReviseTargetLZIfFarAway(tLZData, iTeam, iPlateau, iStartLandZone, iTargetLandZone, iMaxLZTowardsRally)
    --If we want to move to a rally point but it is more than iMaxLZTowardsRally land zones away, then go to the iMaxLZTowardsRally'th entry
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReviseTargetLZIfFarAway'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iNewTargetLZ = iTargetLandZone
    if not(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]) then
        M28Map.ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iPlateau, iStartLandZone, iTargetLandZone, tLZData[M28Map.subrefMidpoint])
    end
    if iMaxLZTowardsRally and tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone] then
        if bDebugMessages == true then
            LOG(sFunctionRef..': WIll consider revising the '..iMaxLZTowardsRally..' entry along the path; repru of the path='..repru(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath])..'; Position in the path='..tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone])
            local tPath = {}
            table.insert(tPath, tLZData[M28Map.subrefMidpoint])
            for iEntry, iZone in tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath] do
                table.insert(tPath, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iZone][M28Map.subrefMidpoint])
            end
            M28Utilities.DrawPath(tPath)
        end
        --Change closest LZ to run to to be 2 along the path from cur LZ to the target LZ
        for iEntry, iLZPointInPath in tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath] do
            if iEntry >= iMaxLZTowardsRally then
                if bDebugMessages == true then LOG(sFunctionRef..': Were going to move to iTargetLandZone='..iTargetLandZone..' from LZ'..iStartLandZone..' but it is at least iMaxLZTowardsRally='..iMaxLZTowardsRally..' LZ away so will move to iEntry LZ which is '..iLZPointInPath..'; Total paht size='..table.getn(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath])) end
                iNewTargetLZ = iLZPointInPath
                break
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iNewTargetLZ
end

function GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, iMaxLZTowardsRally, bAmphibiousPathing)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNearestLandRallyPoint'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Gets the location of the nearest rally point; if bAmphibiousPathing is true then will consider other islands, otherwise will only consider current island
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau]) == false then
        local iCurDist
        local iClosestDist = 100000
        local iClosestLZRef
        local iBaseIsland = tLZData[M28Map.subrefLZIslandRef]
        local iClosestAmphibDist = 100000
        local iClosestAmphibLZRef
        local iSecondClosestDist = 100000
        local iSecondClosestLZRef

        if bDebugMessages == true then LOG(sFunctionRef..': have potential land zones to consider for plateau '..iPlateau..'; bAmphibiousPathing='..tostring(bAmphibiousPathing or false)) end
        for iEntry, iAltLZ in M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau] do
            if bDebugMessages == true then LOG(sFunctionRef..': Looking for rally point for iPlateau '..iPlateau..'; iLandZone '..iLandZone..'; Considering iAltLZ='..iAltLZ..'; Travel distance to here='..(M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iAltLZ) or 'nil')) end
            if iAltLZ == iLandZone then
                if not(iClosestLZRef) then
                    iClosestLZRef = iAltLZ
                    --break
                end
            else
                if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAltLZ][M28Map.subrefLZIslandRef] == iBaseIsland then
                    iCurDist = (M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iAltLZ) or iClosestDist + 1)  --M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAltLZ][M28Map.subrefMidpoint], tLZData[M28Map.subrefMidpoint])
                    if iCurDist < iClosestDist then
                        iSecondClosestLZRef = iClosestLZRef
                        iSecondClosestDist = iClosestDist
                        iClosestDist = iCurDist
                        iClosestLZRef = iAltLZ
                        if bDebugMessages == true then LOG(sFunctionRef..': Have a new closestLZRef that is on same island, iBaseIsland='..iBaseIsland..'; iClosestLZRef='..iClosestLZRef..'; iClosestDist='..iClosestDist) end
                    elseif iCurDist < iSecondClosestDist then
                        iSecondClosestDist = iCurDist
                        iSecondClosestLZRef = iAltLZ
                    end
                elseif bAmphibiousPathing and not(iClosestLZRef) then
                    iCurDist = M28Utilities.GetDistanceBetweenPositions( M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAltLZ][M28Map.subrefMidpoint], tLZData[M28Map.subrefMidpoint])
                    if iCurDist < iClosestAmphibDist then
                        iClosestAmphibDist = iCurDist
                        iClosestAmphibLZRef = iAltLZ
                        if bDebugMessages == true then LOG(sFunctionRef..': Have a new closetsAmphibLZRef, iClosestAmphibDist='..iClosestAmphibDist..'; iClosestAmphibLZRef='..iClosestAmphibLZRef) end
                    end
                end
            end
        end
        if not(iClosestLZRef) then
            if bAmphibiousPathing and iClosestAmphibLZRef then iClosestLZRef = iClosestAmphibLZRef
            else
                iClosestLZRef = iLandZone
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Dont have iClosestLZRef, bAmphibiousPathing='..tostring(bAmphibiousPathing or false)..'; iClosestAmphibLZRef='..(iClosestAmphibLZRef or 'nil')..'; iClosestLZRef after updating for amphibious or setting to cur land zone='..iClosestLZRef) end
        else
            iClosestAmphibLZRef = nil
        end
        if iClosestLZRef == iLandZone then
            --Do nothing - wont find a closer one
        else
            --Do we have a path to this rally point from the current land zone? If so move 2 along the path
            if iClosestAmphibLZRef then
                --Do nothign - will just want to go straight to the amphibious LZ
            else
                local tZonesToConsider = {iClosestLZRef}
                if iSecondClosestLZRef then table.insert(tZonesToConsider, iSecondClosestLZRef) end
                for _, iTargetLZRef in tZonesToConsider do
                    if not(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLZRef]) then
                        M28Map.ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iPlateau, iLandZone, iTargetLZRef, tLZData[M28Map.subrefMidpoint])
                        if not(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLZRef]) then
                            M28Utilities.ErrorHandler('Dont have pathing recorded for iTargetLZRef='..iTargetLZRef..'; iPlateau='..iPlateau..'; iBaesLZ='..iLandZone..'; iClosestLZRef='..iClosestLZRef..' even after checking to update pathing, if logs are enabled will draw midpoint of LZ')
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint])..'; subrefLZTotalSegmentCount for closest LZref='..(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLZRef][M28Map.subrefLZTotalSegmentCount] or 'nil')..'; Will draw midpoint in red, and hten draw the base LZ in gold and the closest LZ in cyan')
                                M28Utilities.DrawLocation(tLZData[M28Map.subrefMidpoint], 2, 200)
                                M28Map.DrawSpecificLandZone(iPlateau, iLandZone, 4)
                                M28Map.DrawSpecificLandZone(iPlateau, iTargetLZRef, 6)
                            end
                        end
                    end
                end
                --Consider switching from closest to second closest if closest is dangerous and secondclosest is closer to our base;  this is to avoid scenario (covered in v113 changes) where we try moving to a LZ 2 away, and the first LZ to get there takes us closer to the enemy
                if iSecondClosestLZRef and tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef] and tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iSecondClosestLZRef] then
                    local iClosestFirstZone = tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef]][M28Map.subrefLZPath][1]
                    local tClosestFirstZoneLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestFirstZone]
                    local tClosestFirstZoneLZTeamData = tClosestFirstZoneLZData[M28Map.subrefLZTeamData][iTeam]
                    local iSecondClosestFirstZone = tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iSecondClosestLZRef]][M28Map.subrefLZPath][1]
                    local tSecondClosestFirstZoneLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iSecondClosestFirstZone]
                    local tSecondClosestFirstZoneLZTeamData = tSecondClosestFirstZoneLZData[M28Map.subrefLZTeamData][iTeam]
                    local iClosestGrossThreat = (tClosestFirstZoneLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                    local iClosestNetThreat = (tClosestFirstZoneLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) - (tClosestFirstZoneLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)
                    local iSecondClosestGrossThreat = (tSecondClosestFirstZoneLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                    local iSecondClosestNetThreat = (tSecondClosestFirstZoneLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) - (tSecondClosestFirstZoneLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)
                    --Include mobile DF threat in adjacent zones
                    local iAdjZoneFactor = 0.7
                    if M28Utilities.IsTableEmpty(tClosestFirstZoneLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for _, iAdjLZ in tClosestFirstZoneLZData[M28Map.subrefLZAdjacentLandZones] do
                            local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                            if (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) > 0 then
                                iClosestGrossThreat = iClosestGrossThreat + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) * iAdjZoneFactor
                            end
                            iClosestNetThreat = iClosestNetThreat + ((tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) - (tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0)) * 0.7
                        end
                    end
                    if M28Utilities.IsTableEmpty(tSecondClosestFirstZoneLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for _, iAdjLZ in tSecondClosestFirstZoneLZData[M28Map.subrefLZAdjacentLandZones] do
                            local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                            if (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) > 0 then
                                iSecondClosestGrossThreat = iSecondClosestGrossThreat + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) * iAdjZoneFactor
                            end
                            iSecondClosestNetThreat = iSecondClosestNetThreat + ((tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) - (tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0)) * iAdjZoneFactor
                        end
                    end

                    --Does the closest first zone closer to the enemy and has significantly more enemy combat threat than the second closest first zone?
                    if bDebugMessages == true then LOG(sFunctionRef..': iLandZone='..iLandZone..'; iPlateua='..iPlateau..'; First closest LZ='..iClosestFirstZone..'; Second closest first zone='..(iSecondClosestFirstZone or 'nil')..'; ClosestFirstZoneModDist%='..(tClosestFirstZoneLZTeamData[M28Map.refiModDistancePercent] or 'nil')..'; Second closest='..(tSecondClosestFirstZoneLZTeamData[M28Map.refiModDistancePercent] or 'nil')..'; Closest net combat='..iClosestGrossThreat..'; Second closest net combat='.. (iSecondClosestGrossThreat or 'nil')..'; iSecondClosestLZRef='..(iSecondClosestLZRef or 'nil')..'; iSecondClosestDist='..(iSecondClosestDist or 'nil')..'; iClosestGrossThreat='..iClosestGrossThreat..'; iSecondClosestGrossThreat='..(iSecondClosestGrossThreat or 'nil')) end
                    if iSecondClosestLZRef and tSecondClosestFirstZoneLZTeamData[M28Map.refiModDistancePercent] and tClosestFirstZoneLZTeamData[M28Map.refiModDistancePercent] > tSecondClosestFirstZoneLZTeamData[M28Map.refiModDistancePercent] and tClosestFirstZoneLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > (tClosestFirstZoneLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0) * 0.8 and tClosestFirstZoneLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] - (tClosestFirstZoneLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0) > 1.2 * ((tSecondClosestFirstZoneLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) - (tSecondClosestFirstZoneLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Switching rally point so will treat second closest as the actual closest') end
                        iClosestLZRef = iSecondClosestLZRef
                        iClosestDist = iSecondClosestDist
                        --If second closest is lower mod dist, significantly lower gross threat, and either net threat isnt negative, or net threat negative but not massively more than gross threat, then switch
                    elseif (iClosestNetThreat > 0 and iSecondClosestNetThreat <= 0 and (iClosestNetThreat > math.min(iSecondClosestGrossThreat * 0.5, iClosestGrossThreat * 0.5))) or
                            (iSecondClosestGrossThreat * 1.25 < iClosestGrossThreat and tSecondClosestFirstZoneLZTeamData[M28Map.refiModDistancePercent] < tClosestFirstZoneLZTeamData[M28Map.refiModDistancePercent] and ((iClosestNetThreat > 0 and iClosestGrossThreat < iClosestNetThreat) or (iSecondClosestNetThreat < 0 and iClosestNetThreat < 0 and -iSecondClosestNetThreat < 3 * iSecondClosestGrossThreat and -iClosestNetThreat < 3 * iClosestGrossThreat))) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Second closest seems safer than closest so will switch') end
                        iClosestLZRef = iSecondClosestLZRef
                        iClosestDist = iSecondClosestDist
                    end
                end



                if iMaxLZTowardsRally and tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef] then
                    if (iClosestDist <= 250 or iClosestAmphibDist <= 250) then iMaxLZTowardsRally = iMaxLZTowardsRally + 1 end
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': WIll consider changing to the '..iMaxLZTowardsRally..' entry along the path to get to zone '..iClosestLZRef..'; repru of the path='..repru(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef]][M28Map.subrefLZPath])..'; Position in the path='..tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef]..'; tLZData[M28Map.subrefLZPathingToOtherLZEntryRef]='..repru(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef])..'; iClosestLZRef='..iClosestLZRef..'; Full listing of repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones]='..repru(repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZPathingToOtherLandZones]))..'; Dist to end destination (straight line)='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef][M28Map.subrefMidpoint]))
                        local tPath = {}
                        table.insert(tPath, tLZData[M28Map.subrefMidpoint])
                        for iEntry, iZone in tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef]][M28Map.subrefLZPath] do
                            table.insert(tPath, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iZone][M28Map.subrefMidpoint])
                            if bDebugMessages == true then LOG(sFunctionRef..': Dist from path entry iZone '..iZone..' to the target='..M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iZone][M28Map.subrefMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef][M28Map.subrefMidpoint])) end
                        end
                        M28Utilities.DrawPath(tPath)
                        if bDebugMessages == true then LOG(sFunctionRef..': repru of tPath if going the full path='..repru(tPath)) end
                    end
                    local tTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef]
                    local iAngleToTargetLZ = M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tTargetLZData[M28Map.subrefMidpoint])
                    local bKeepLooking
                    local iStraightLineDistToTarget = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tTargetLZData[M28Map.subrefMidpoint])
                    --Change closest LZ to run to to be 2 along the path from cur LZ to the target LZ
                    for iEntry, iLZPointInPath in tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef]][M28Map.subrefLZPath] do
                        if iEntry >= iMaxLZTowardsRally then
                            if iLZPointInPath == iClosestLZRef then break else
                                --Consider moving to iMaxLZTowardsRally + 1 entry if not much further away; consider just going to the end point if this would be in a very different angle to the original location as well
                                local tPathLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZPointInPath]
                                if bDebugMessages == true then LOG(sFunctionRef..': iEntry='..iEntry..'; iMaxLZTowardsRally='..iMaxLZTowardsRally..'; iLZPointInPath='..iLZPointInPath..'; iClosestDist before='..iClosestDist..'; iClosestAmphibDist before='..(iClosestAmphibDist or 'nil')..'; Angle to along path LZ='..M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tPathLZData[M28Map.subrefMidpoint])..'; Angle to end LZ wanted='..iAngleToTargetLZ..'; angle dif='..M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tPathLZData[M28Map.subrefMidpoint]), iAngleToTargetLZ)) end
                                if iEntry >= iMaxLZTowardsRally + 3 then
                                    iClosestLZRef = iLZPointInPath
                                    break
                                else
                                    bKeepLooking = false
                                    if M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tPathLZData[M28Map.subrefMidpoint]), iAngleToTargetLZ) >= 45 then
                                        bKeepLooking = true
                                    elseif iStraightLineDistToTarget - M28Utilities.GetDistanceBetweenPositions(tPathLZData[M28Map.subrefMidpoint], tTargetLZData[M28Map.subrefMidpoint]) < math.min(150, iEntry * 40) then
                                        --Quite a big angle dif, so consider moving up to 2 further along path
                                        bKeepLooking = true
                                    end
                                    if not(bKeepLooking) then
                                        iClosestLZRef = iLZPointInPath
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iMaxLZTowardsRally='..(iMaxLZTowardsRally or 'nil')..'; iClosestLZRef='..iClosestLZRef..'; Returning midpoint for closestLZRef='..repru({M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef][M28Map.subrefMidpoint][1], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef][M28Map.subrefMidpoint][2], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef][M28Map.subrefMidpoint][3]})) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return {M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef][M28Map.subrefMidpoint][1], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef][M28Map.subrefMidpoint][2], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef][M28Map.subrefMidpoint][3]}
    else
        if not(M28Map.bIsCampaignMap) or M28Conditions.IsLocationInPlayableArea(M28Map.PlayerStartPoints[M28Team.GetFirstActiveM28Brain(iTeam):GetArmyIndex()]) then
            --If dealing with plateau with 3+ zones then might not have set any to have a rally point
            M28Utilities.ErrorHandler('No rally point for P'..(iPlateau or 'nil')..' LZ'..(iLandZone or 'nil')..' for team '..iTeam..'; will return current midpoint', true)
            if bDebugMessages == true then
                LOG(sFunctionRef..': Will draw specific land zone in gold, midpoint='..repru(tLZData[M28Map.subrefMidpoint])..'; Closest friendly base='..repru(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.reftClosestFriendlyBase])..'; iTeam='..iTeam)
                M28Map.DrawSpecificLandZone(iPlateau, iLandZone, 4)
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return {tLZData[M28Map.subrefMidpoint][1], tLZData[M28Map.subrefMidpoint][2], tLZData[M28Map.subrefMidpoint][3]}
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshLandRallyPoints(iTeam, iPlateau)
    --For now just has core bases and core expansion points as rally points, may adjust htis in the future
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshLandRallyPoints'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    

    if not(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau]) then M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau] = {} end
    M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau] = {}
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones]) == false then
        local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
        local iHighestSValue = 0
        local iLZWithHighestSValue
        local tiDangerousCoreBaseRefs = {}
        local iNetCombatValue
        local iMaxZoneCount = (M28Map.tAllPlateaus[iPlateau][M28Map.subrefLandZoneCount] or 0)

        for iLandZone, tLZData in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones] do
            if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then
                if bDebugMessages == true then LOG(sFunctionRef..': considering if we want zone '..iLandZone..' in iPlateau='..iPlateau..' to be a rally point, is core base='..tostring(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] or false)..'; is core expansion='..tostring(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZCoreExpansion] or false)..'; iMaxZoneCount='..iMaxZoneCount) end
                local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                if tLZTeamData[M28Map.subrefLZbCoreBase] or (tLZTeamData[M28Map.subrefLZSValue] >= 200 and (tLZTeamData[M28Map.subrefLZCoreExpansion] or (not(iLZWithHighestSValue) and tLZTeamData[M28Map.subrefLZSValue] >= 1000)) or (iMaxZoneCount <= 2 and (tLZTeamData[M28Map.subrefLZCoreExpansion] or (tLZData[M28Map.subrefLZOrWZMexCount] or 0) > 0))) then
                    if tLZTeamData[M28Map.subrefLZSValue] >= iHighestSValue then
                        iHighestSValue = tLZTeamData[M28Map.subrefLZSValue]
                        iLZWithHighestSValue = iLandZone
                    end
                    --Dont have as rally if enemy has T2 arti nearby
                    if iMaxZoneCount > 1 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) and (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0) == 0 then
                        iNetCombatValue = (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) - (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)
                        if iNetCombatValue < 0 or (tLZTeamData[M28Map.subrefLZbCoreBase] and (iNetCombatValue <= 200 or  (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) < (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0) * 1.25)) then
                            table.insert(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau], iLandZone)
                        elseif tLZTeamData[M28Map.subrefLZbCoreBase] then
                            table.insert(tiDangerousCoreBaseRefs, iLandZone)
                        end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau]) then
            if iLZWithHighestSValue then table.insert(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau], iLZWithHighestSValue)
            elseif M28Utilities.IsTableEmpty(tiDangerousCoreBaseRefs) == false then
                for iEntry, iLandZone in tiDangerousCoreBaseRefs do
                    table.insert(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau], iLandZone)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, iLZOrWZToSupport, iMAAFactorAdjust, bWaterZone, tHoverMAAToAdvance)
    --Assigns MAA to the land zone up to the level at which the LZ doesnt want more MAA support, but increases the MAA wanted by the land zone by iMAAFactorAdjust (or 1 if not specified)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SendMAAToSupportLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tAltLZOrWZData
    local tAltTeamLZOrWZData
    local tTargetPosition
    local iPond
    local iMAAThreatWanted, iAllyGroundAA
    if bWaterZone then
        iPond = M28Map.tiPondByWaterZone[iLZOrWZToSupport]
        tAltLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iLZOrWZToSupport]
        tAltTeamLZOrWZData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
        tTargetPosition = tAltLZOrWZData[M28Map.subrefMidpoint]
        iAllyGroundAA = tAltTeamLZOrWZData[M28Map.subrefLZOrWZThreatAllyGroundAA]
        iMAAThreatWanted = (tAltTeamLZOrWZData[M28Map.subrefWZMAAThreatWanted] or 0) * (iMAAFactorAdjust or 1) - (iAllyGroundAA or 0)
    else
        tAltLZOrWZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZOrWZToSupport]
        tAltTeamLZOrWZData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
        tTargetPosition = tAltLZOrWZData[M28Map.subrefMidpoint]
        iAllyGroundAA = tAltTeamLZOrWZData[M28Map.subrefLZOrWZThreatAllyGroundAA]
        iMAAThreatWanted = M28Conditions.GetNetMAAWantedForZone(tAltTeamLZOrWZData, iMAAFactorAdjust)
    end

    local tDistToTargetByRef = {}
    if not(iMAAThreatWanted) or not(iAllyGroundAA) then
        M28Utilities.ErrorHandler('Have nil MAA or AllyGroundAA threat for iLZOrWZToSupport='..(iLZOrWZToSupport or 'nil')..'; see log for more info')
        LOG(sFunctionRef..': MAA iTeam='..(iTeam or 'nil')..'; iPlateau='..(iPlateau or 'nil')..'; iLZOrWZToSupport='..(iLZOrWZToSupport or 'nil')..'; tAltTeamLZOrWZData[M28Map.subrefLZMAAThreatWanted]='..(tAltTeamLZOrWZData[M28Map.subrefLZMAAThreatWanted] or 'nil')..'; tAltTeamLZOrWZData[M28Map.subrefLZOrWZThreatAllyGroundAA]='..(tAltTeamLZOrWZData[M28Map.subrefLZOrWZThreatAllyGroundAA] or 'nil'))
    else
        for iUnit, oUnit in (tHoverMAAToAdvance or tMAAToAdvance) do
            tDistToTargetByRef[iUnit] = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetPosition)
        end
        local tbRemovedMAAReferencesByRef = {}
        for iUnitRef, iDistance in M28Utilities.SortTableByValue(tDistToTargetByRef, false) do
            if bDebugMessages == true then LOG(sFunctionRef..': About to issue order to move for iUnitRef='..iUnitRef..'; tMAAToAdvance[iUnitRef]='..(tMAAToAdvance[iUnitRef].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tMAAToAdvance[iUnitRef]) or 'nil')..' to go to tTargetPosition='..repru(tTargetPosition)) end
            M28Orders.IssueTrackedMove(tMAAToAdvance[iUnitRef], tTargetPosition, 10, false, 'MVELZ'..iLZOrWZToSupport)
            iMAAThreatWanted = iMAAThreatWanted - M28UnitInfo.GetAirThreatLevel({ tMAAToAdvance[iUnitRef] }, false, false, true, false, false, false)
            tbRemovedMAAReferencesByRef[iUnitRef] = true
            if iMAAThreatWanted < 0 then break end
        end
        if M28Utilities.IsTableEmpty(tbRemovedMAAReferencesByRef) == false then
            --Remove any MAA that have given orders from tMAAToAdvance:
            if M28Utilities.IsTableEmpty(tHoverMAAToAdvance) then
                local iRevisedIndex = 1
                local iTableSize = table.getn(tMAAToAdvance)

                for iOrigIndex=1, iTableSize do
                    if tMAAToAdvance[iOrigIndex] then
                        if not(tbRemovedMAAReferencesByRef[iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                            --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                            if (iOrigIndex ~= iRevisedIndex) then
                                tMAAToAdvance[iRevisedIndex] = tMAAToAdvance[iOrigIndex];
                                tMAAToAdvance[iOrigIndex] = nil;
                            end
                            iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                        else
                            tMAAToAdvance[iOrigIndex] = nil;
                        end
                    end
                end
                if iRevisedIndex < iTableSize then
                    --table.setn(tMAAToAdvance, iRevisedIndex - 1)
                    for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
                        table.remove(tMAAToAdvance, iRemovalEntry)
                    end
                end
            else
                --Need to remove from both the hover MAA table, and the main MAA table
                local iRevisedIndex = 1
                local iTableSize = table.getn(tHoverMAAToAdvance)


                for iOrigIndex=1, iTableSize do
                    if tHoverMAAToAdvance[iOrigIndex] then
                        if not(tbRemovedMAAReferencesByRef[iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                            --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                            if (iOrigIndex ~= iRevisedIndex) then
                                tHoverMAAToAdvance[iRevisedIndex] = tHoverMAAToAdvance[iOrigIndex];
                                tHoverMAAToAdvance[iOrigIndex] = nil;
                            end
                            iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                        else
                            --Want to remove the unit - also remove from the original MAA table
                            for iUnit, oUnit in tMAAToAdvance do
                                if oUnit == tHoverMAAToAdvance[iOrigIndex] then
                                    table.remove(tMAAToAdvance, iUnit)
                                    break
                                end
                            end
                            tHoverMAAToAdvance[iOrigIndex] = nil;
                        end
                    end
                end
                if iRevisedIndex < iTableSize then
                    --table.setn(tHoverMAAToAdvance, iRevisedIndex - 1)
                    for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
                        table.remove(tHoverMAAToAdvance, iRemovalEntry)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function StealthUnitsInLandZone(tTeamTargetLZData, tStealthsToAssign, bAssignAllStealths, toOptionalUnitsToStealth)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'StealthUnitsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --local tTargetLandZone = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][iTeam]
    local bNoUnitsWantingStealthing = true
    if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileStealth]) and M28Utilities.IsTableEmpty(toOptionalUnitsToStealth) then
        M28Utilities.ErrorHandler('Are trying to send mobile Stealths to support a land zone that has no allied combat units in it and no units wanting Stealthing')
    else
        local toUnitsWantingStealth
        if toOptionalUnitsToStealth then toUnitsWantingStealth = toOptionalUnitsToStealth
        else toUnitsWantingStealth = tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileStealth]
        end
        if M28Utilities.IsTableEmpty(toUnitsWantingStealth) == false then
            for iTarget, oTarget in toUnitsWantingStealth do
                if not(oTarget[refoAssignedMobileStealth]) then
                    if M28Utilities.IsTableEmpty(tStealthsToAssign) then
                        bNoUnitsWantingStealthing = false
                        break
                    else
                        --Assign the closest mobile Stealth
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iStealth, oStealth in tStealthsToAssign do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iStealth='..iStealth..'; Stealth unit='..oStealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth)) end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oStealth:GetPosition(), oTarget:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iStealth
                            end
                            break
                        end
                        tStealthsToAssign[iClosestRef][refoMobileStealthTarget] = oTarget
                        oTarget[refoAssignedMobileStealth] = tStealthsToAssign[iClosestRef]
                        MoveToStealthTarget(tStealthsToAssign[iClosestRef], tTeamTargetLZData[M28Map.reftClosestEnemyBase])
                        table.remove(tStealthsToAssign, iClosestRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have just removed Stealth with iClosestRef='..iClosestRef..' from the table of tStealthsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; size of table='..table.getn(tStealthsToAssign)) end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tStealthsToAssign) == false and bAssignAllStealths then
            bNoUnitsWantingStealthing = true
            --No units that want Stealthing - e.g. we might be telling mobile Stealths to defend here temporarily; dont assign the Stealths, instead just give them orders so they are still of some use
            if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) == false then
                for iTarget, oTarget in tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits] do
                    if not(oTarget[refoAssignedMobileStealth]) then --redundancy
                        --Assign the closest mobile Stealth
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iStealth, oStealth in tStealthsToAssign do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iStealth='..iStealth..'; Stealth unit='..oStealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth)) end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oStealth:GetPosition(), oTarget:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iStealth
                            end
                            break
                        end
                        --Dont record the Stealth as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoStealthtarget works
                        tStealthsToAssign[iClosestRef][refoMobileStealthTarget] = oTarget
                        MoveToStealthTarget(tStealthsToAssign[iClosestRef], tTeamTargetLZData[M28Map.reftClosestEnemyBase])
                        tStealthsToAssign[iClosestRef][refoMobileStealthTarget] = nil
                        table.remove(tStealthsToAssign, iClosestRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Backup Stealth assignment - Have removed Stealth with iClosestRef='..iClosestRef..' from the table of tStealthsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; size of table='..table.getn(tStealthsToAssign)) end
                        if M28Utilities.IsTableEmpty(tStealthsToAssign) then break end
                    end
                end

                --Do we still have spare mobile Stealths?
                if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                    --Get closest unit to enemy base and assign all remaining Stealths temporarily here
                    local iCurDist
                    local iClosestDist = 100000
                    local oClosestToEnemyBase

                    for iTarget, oTarget in tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits] do
                        if M28UnitInfo.IsUnitValid(oTarget) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), tTeamTargetLZData[M28Map.reftClosestEnemyBase])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oClosestToEnemyBase = oTarget
                            end
                        end
                    end
                    if oClosestToEnemyBase then
                        local tEnemyBase = tTeamTargetLZData[M28Map.reftClosestEnemyBase]
                        for iStealth, oStealth in tStealthsToAssign do
                            --Dont record the Stealth as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoStealthtarget works
                            if bDebugMessages == true then LOG(sFunctionRef..': About to tell Stealth '..(oStealth.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oStealth) or 'nil')..' to move towards oClosestToEnemyBase='..(oClosestToEnemyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase) or 'nil')) end
                            oStealth[refoMobileStealthTarget] = oClosestToEnemyBase
                            MoveToStealthTarget(oStealth, tEnemyBase)
                            oStealth[refoMobileStealthTarget] = nil
                            if bDebugMessages == true then LOG(sFunctionRef..': Backup Stealth assignment - have told Stealth '..oStealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth)..' to go to the closest enemy in this LZ to enemy base='..oClosestToEnemyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase)) end
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': No friendly units close to enemy base - assuming this is termpoary due to unit being destroyed')
                    end
                end
            end
        end
    end
    if bNoUnitsWantingStealthing then
        --Flag that this LZ no longer wants mobile Stealths
        tTeamTargetLZData[M28Map.refbLZWantsMobileStealth] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordMobileShieldAgainstTarget(oShield, oTarget)
    oShield[refoMobileShieldTarget] = oTarget
    if EntityCategoryContains(categories.COMMAND + M28UnitInfo.refCategoryFatboy, oTarget.UnitId) then
        local iEnemyNovaxCount = M28Team.tTeamData[oTarget:GetAIBrain().M28Team][M28Team.refiEnemyNovaxCount]
        local bAssignAsExtraShield = false
        if iEnemyNovaxCount > 0 then
            local iExistingExtraShields = 0
            if M28Conditions.IsTableOfUnitsStillValid(oTarget[reftoAdditionalAssignedMobileShields]) then
                iExistingExtraShields = table.getn(oTarget[reftoAdditionalAssignedMobileShields])
            end
            if iExistingExtraShields <= math.min(iEnemyNovaxCount, 4) and (iExistingExtraShields <= 2 or M28UnitInfo.GetUnitHealthPercent(oTarget) < 1) then
                bAssignAsExtraShield = true
            end
        end
        if bAssignAsExtraShield then
            if not(oTarget[reftoAdditionalAssignedMobileShields]) then oTarget[reftoAdditionalAssignedMobileShields] = {} end
            table.insert(oTarget[reftoAdditionalAssignedMobileShields], oShield)
        else
            oTarget[refoAssignedMobileShield] = oShield
        end
    else
        oTarget[refoAssignedMobileShield] = oShield
    end
end

function ClearCurrentShieldTarget(oShield)
    if oShield[refoMobileShieldTarget] then
        if M28Utilities.IsTableEmpty(oShield[refoMobileShieldTarget][reftoAdditionalAssignedMobileShields]) == false then
            for iCurShield = table.getn(oShield[refoMobileShieldTarget][reftoAdditionalAssignedMobileShields]), 1, -1 do
                local oCurShield = oShield[refoMobileShieldTarget][reftoAdditionalAssignedMobileShields][iCurShield]
                if oCurShield == oShield then
                    table.remove(oShield[refoMobileShieldTarget][reftoAdditionalAssignedMobileShields], iCurShield)
                end
            end
        end
        if oShield[refoMobileShieldTarget][refoAssignedMobileShield] == oShield then
            oShield[refoMobileShieldTarget][refoAssignedMobileShield] = nil
        end
        oShield[refoMobileShieldTarget] = nil
    end
end

function ShieldUnitsInLandZone(tTeamTargetLZData, tShieldsToAssign, bAssignAllShields)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ShieldUnitsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --local tTargetLandZone = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][iTeam]
    local bNoUnitsWantingShielding = true
    if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]) and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefAlliedACU]) then
        M28Utilities.ErrorHandler('Are trying to send mobile shields to support a land zone that has no allied combat units in it and no units wanting shielding')
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of units wanting mobile shield empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]))) end
        if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]) == false then
            --Prioritise t2 arti if have enemy t2 arti in zone
            function AssignClosestMobileShieldToTarget(oTarget)
                --Returns false if should abort
                if not(oTarget[refoAssignedMobileShield]) then
                    if M28Utilities.IsTableEmpty(tShieldsToAssign) then
                        bNoUnitsWantingShielding = false
                        return false
                    else
                        --Assign the closest mobile shield
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iShield, oShield in tShieldsToAssign do
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oTarget:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iShield='..iShield..'; Shield unit='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; iCurDist='..iCurDist..'; iClosestDist='..iClosestDist..'; oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)) end
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iShield
                            end
                        end
                        RecordMobileShieldAgainstTarget(tShieldsToAssign[iClosestRef], oTarget)

                        MoveToShieldTarget(tShieldsToAssign[iClosestRef], tTeamTargetLZData[M28Map.reftClosestEnemyBase])
                        table.remove(tShieldsToAssign, iClosestRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have just removed shield with iClosestRef='..iClosestRef..' from the table of tShieldsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; size of table='..table.getn(tShieldsToAssign)) end
                        return not(M28Utilities.IsTableEmpty(tShieldsToAssign))
                    end
                end
            end
            local tUnitsToPrioritiseForShielding = {}
            if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
                tUnitsToPrioritiseForShielding = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield])
            end
            if M28Conditions.IsTableOfUnitsStillValid(tTeamTargetLZData[M28Map.subrefAlliedACU]) then
                local iCurHealthPercent
                if not(tUnitsToPrioritiseForShielding) then tUnitsToPrioritiseForShielding = {} end
                for iACU, oACU in tTeamTargetLZData[M28Map.subrefAlliedACU] do
                    iCurHealthPercent = M28UnitInfo.GetUnitHealthPercent(oACU)
                    if iCurHealthPercent <= 0.6 or (iCurHealthPercent <= 0.98 and GetGameTimeSeconds() - (oACU[M28ACU.refiTimeLastWantedToRun] or -100) <= 5) or M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refiEnemyNovaxCount] > 0 then
                        table.insert(tUnitsToPrioritiseForShielding, oACU)
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tUnitsToPrioritiseForShielding) == false then
                for iTarget, oTarget in tUnitsToPrioritiseForShielding do
                    if not(oTarget.Dead) then
                        if AssignClosestMobileShieldToTarget(oTarget) == false then break end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]) == false and M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                for iTarget, oTarget in tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield] do
                    if not(oTarget.Dead) then
                        if AssignClosestMobileShieldToTarget(oTarget) == false then break end
                    end
                end
            end
        end
        if (M28Utilities.IsTableEmpty(tShieldsToAssign) == false or M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefAlliedACU]) == false) and bAssignAllShields then
            bNoUnitsWantingShielding = true
            --No units that want shielding - e.g. we might be telling mobile shields to defend here temporarily; dont assign the shields, instead just give them orders so they are still of some use
            local tPotentialShieldTargets = {}
            if tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits] then tPotentialShieldTargets = tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits] end
            if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefAlliedACU]) == false then
                for iACU, oACU in tTeamTargetLZData[M28Map.subrefAlliedACU] do
                    table.insert(tPotentialShieldTargets, oACU)
                end
            end

            if M28Utilities.IsTableEmpty(tPotentialShieldTargets) == false then
                for iTarget, oTarget in tPotentialShieldTargets do
                    if not(oTarget[refoAssignedMobileShield]) then --redundancy
                        --Assign the closest mobile shield
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iShield, oShield in tShieldsToAssign do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iShield='..iShield..'; Shield unit='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)) end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oTarget:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iShield
                            end
                            break
                        end
                        if iClosestRef then
                            --Dont record the shield as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoshieldtarget works
                            tShieldsToAssign[iClosestRef][refoMobileShieldTarget] = oTarget
                            MoveToShieldTarget(tShieldsToAssign[iClosestRef], tTeamTargetLZData[M28Map.reftClosestEnemyBase])
                            tShieldsToAssign[iClosestRef][refoMobileShieldTarget] = nil
                            table.remove(tShieldsToAssign, iClosestRef)
                            if bDebugMessages == true then LOG(sFunctionRef..': Backup shield assignment - Have removed shield with iClosestRef='..iClosestRef..' from the table of tShieldsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; size of table='..table.getn(tShieldsToAssign)) end
                            if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                        else
                            tShieldsToAssign = {}
                        end
                    end
                end

                --Do we still have spare mobile shields?
                if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                    --Get closest unit to enemy base and assign all remaining shields temporarily here
                    local iCurDist
                    local iClosestDist = 100000
                    local oClosestToEnemyBase

                    for iTarget, oTarget in tPotentialShieldTargets do
                        if M28UnitInfo.IsUnitValid(oTarget) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), tTeamTargetLZData[M28Map.reftClosestEnemyBase])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oClosestToEnemyBase = oTarget
                            end
                        end
                    end
                    if oClosestToEnemyBase then
                        local tEnemyBase = tTeamTargetLZData[M28Map.reftClosestEnemyBase]
                        for iShield, oShield in tShieldsToAssign do
                            --Dont record the shield as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoshieldtarget works
                            if bDebugMessages == true then LOG(sFunctionRef..': About to tell shield '..(oShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oShield) or 'nil')..' to move towards oClosestToEnemyBase='..(oClosestToEnemyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase) or 'nil')) end
                            oShield[refoMobileShieldTarget] = oClosestToEnemyBase
                            MoveToShieldTarget(oShield, tEnemyBase)
                            oShield[refoMobileShieldTarget] = nil
                            if bDebugMessages == true then LOG(sFunctionRef..': Backup shield assignment - have told shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' to go to the closest enemy in this LZ to enemy base='..oClosestToEnemyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase)) end
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': No friendly units close to enemy base - assuming this is termpoary due to unit being destroyed')
                    end
                end
            end
        end
    end
    if bNoUnitsWantingShielding then
        --Flag that this LZ no longer wants mobile shields
        tTeamTargetLZData[M28Map.refbLZWantsMobileShield] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MoveToShieldTarget(oShield, tEnemyBase, tOptionalShieldLZTeamData, tOptionalEnemyDFUnits, tOptionalRallyPoint)
    --If tOptionalShieldLZTeamData is specified, then will check if safe to try and shield the unit

    if EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oShield.UnitId) then M28Utilities.ErrorHandler('Fatboy is being given orders as though it is a shielded unit') end
    local bMoveToUnit = true
    if tOptionalShieldLZTeamData and tOptionalEnemyDFUnits and tOptionalRallyPoint and (tOptionalShieldLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) >= 180 then
        local iDistToShieldTarget = M28Utilities.GetDistanceBetweenPositions(oShield[refoMobileShieldTarget]:GetPosition(), oShield:GetPosition())
        if iDistToShieldTarget >= 50 then
            local tShieldTargetLZData, tShieldTargetLZTeamData = M28Map.GetLandOrWaterZoneData(oShield[refoMobileShieldTarget]:GetPosition(), true, oShield:GetAIBrain().M28Team)
            if not(tShieldTargetLZTeamData ==  tOptionalShieldLZTeamData) then
                if M28Utilities.GetDistanceBetweenPositions(oShield[refoMobileShieldTarget]:GetPosition(), tOptionalRallyPoint) >= M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), tOptionalRallyPoint) then
                    --Are we almost in range of an enemy unit in this zone?
                    if M28Utilities.IsTableEmpty(tOptionalEnemyDFUnits) == false then
                        if M28Conditions.CloseToEnemyUnit(oShield:GetPosition(), tOptionalEnemyDFUnits, 5, oShield:GetAIBrain().M28Team, true) then
                            --LOG('MoveToShieldTarget: Shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' is in a dangerous zone and target '..oShield[refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield[refoMobileShieldTarget])..' is far away so will retreat; Does shield have active micro='..tostring(oShield[M28UnitInfo.refbSpecialMicroActive] or false)..'; Closest friendly base='..repru(tOptionalShieldLZTeamData[M28Map.reftClosestFriendlyBase]))
                            --M28Utilities.DrawLocation(oShield:GetPosition())
                            bMoveToUnit = false
                            --IssueTrackedMove(oUnit, tOrderPosition,                       iDistanceToReissueOrder, bAddToExistingQueue, sOptionalOrderDesc,                                                                                       bOverrideMicroOrder)
                            M28Orders.IssueTrackedMove(oShield, tOptionalRallyPoint, 5, false,                'ShBl'..oShield[refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield[refoMobileShieldTarget]), false)
                        end
                    end

                end
            end
        end

    end
    if bMoveToUnit then

        local oBP = oShield:GetBlueprint()
        --Decide whether to move towards the unit's target if the unit is moving (so e.g. if we are retreating we are less likely to block the retreating unit)
        local bGivenOrderForRetreating = false
        local tTargetFirstOrder = oShield[refoMobileShieldTarget][M28Orders.reftiLastOrders][1]
        if tTargetFirstOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueMove then
            local iDistToEnemyBaseFromUnit = M28Utilities.GetDistanceBetweenPositions(oShield[refoMobileShieldTarget]:GetPosition(), tEnemyBase)
            local iDistToEnemyBaseFromMoveTarget = M28Utilities.GetDistanceBetweenPositions(tTargetFirstOrder[M28Orders.subreftOrderPosition], tEnemyBase)
            if iDistToEnemyBaseFromMoveTarget > iDistToEnemyBaseFromUnit then
                --We are likely retreating
                bGivenOrderForRetreating = true
                local iShieldRadius = oBP.Defense.Shield.ShieldSize * 0.5
                local iShieldDistanceWanted = math.max(5, oBP.Defense.Shield.ShieldSize * 0.5)
                local iTargetSpeed = (oShield[refoMobileShieldTarget]:GetBlueprint().Physics.MaxSpeed or 0)
                local iDistWithinShieldAlready = iShieldRadius - M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oShield[refoMobileShieldTarget]:GetPosition())
                if iDistWithinShieldAlready >= 1 or iTargetSpeed + 1 + iDistWithinShieldAlready >= iShieldRadius then --More than 1 inside shield range or are likely to run into shield
                    iShieldDistanceWanted = iShieldDistanceWanted + math.max(iDistWithinShieldAlready, iTargetSpeed)
                end

                M28Orders.IssueTrackedMove(oShield, M28Utilities.MoveInDirection(oShield[refoMobileShieldTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(oShield[refoMobileShieldTarget]:GetPosition(), tTargetFirstOrder[M28Orders.subreftOrderPosition]), iShieldDistanceWanted, true, false, true), math.min(3, iShieldDistanceWanted - 1, iShieldRadius - 1), false, 'ShRU'..oShield[refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield[refoMobileShieldTarget]))
            end
        end
        if not(bGivenOrderForRetreating) then
            local iShieldDistanceWanted = math.max(3, oBP.Defense.Shield.ShieldSize * 0.5 - 1 - oBP.Physics.MaxSpeed - (oShield[refoMobileShieldTarget]:GetBlueprint().Physics.MaxSpeed or 0))
            M28Orders.IssueTrackedMove(oShield, M28Utilities.MoveInDirection(oShield[refoMobileShieldTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(tEnemyBase,oShield[refoMobileShieldTarget]:GetPosition()), iShieldDistanceWanted, true, false, true), math.min(5, iShieldDistanceWanted - 1), false, 'ShU'..oShield[refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield[refoMobileShieldTarget]))
        end
    end
end

function MoveToStealthTarget(oStealth, tEnemyBase, tOptionalStealthLZTeamData, tOptionalEnemyDFUnits, tOptionalRallyPoint)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MoveToStealthTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bMoveToUnit = true
    if tOptionalStealthLZTeamData and M28Utilities.IsTableEmpty(tOptionalEnemyDFUnits) == false and tOptionalRallyPoint then
        --Retreat if close to enemies
        if M28Conditions.CloseToEnemyUnit(oStealth:GetPosition(), tOptionalEnemyDFUnits, 5, oStealth:GetAIBrain().M28Team, true,    nil,        nil,                                oStealth) then
            if M28UnitInfo.IsUnitValid(oStealth[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                local iAngleToEnemy = M28Utilities.GetAngleFromAToB(oStealth:GetPosition(), oStealth[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())
                local iAngleToRally = M28Utilities.GetAngleFromAToB(oStealth:GetPosition(), tOptionalRallyPoint)
                local tTemporaryRetreatLocation
                if M28Utilities.GetAngleDifference(iAngleToEnemy, iAngleToRally) <= 50 then
                    tTemporaryRetreatLocation = M28Utilities.MoveInDirection(oStealth:GetPosition(), iAngleToEnemy - 180, 10, true, false, M28Map.bIsCampaignMap)
                    if not(M28Utilities.IsTableEmpty(tTemporaryRetreatLocation) == false and NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tTemporaryRetreatLocation) == NavUtils.GetLabel(M28Map.refPathingTypeLand, tOptionalRallyPoint)) then
                        --We cant reach this location so will revert to rally point
                        tTemporaryRetreatLocation = tOptionalRallyPoint
                    end
                else
                    tTemporaryRetreatLocation = tOptionalRallyPoint
                end

                if M28Utilities.IsTableEmpty(tTemporaryRetreatLocation) == false then
                    oStealth[M28UnitInfo.refiTimeLastTriedRetreating] = math.floor(GetGameTimeSeconds())
                    M28Orders.IssueTrackedMove(oStealth, tTemporaryRetreatLocation, 4, false, 'StealthRn')
                    bMoveToUnit = false
                end
            end
        end
    end

    if bMoveToUnit then
        if bDebugMessages == true then LOG(sFunctionRef..': oStealth[refoMobileStealthTarget]='..(oStealth[refoMobileStealthTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oStealth[refoMobileStealthTarget]) or 'nil')..'; SizeX='..(oStealth[refoMobileStealthTarget]:GetBlueprint().SizeX or 'nil')..'; SizeZ='..(oStealth[refoMobileStealthTarget]:GetBlueprint().SizeZ or 'nil')..'; SizeX if do __blueprints='..(__blueprints[oStealth[refoMobileStealthTarget].UnitId].SizeX or 'nil')) end
        local oBP = oStealth:GetBlueprint()
        local oTargetBP = oStealth[refoMobileStealthTarget]:GetBlueprint()
        --Strange bug where t3 mobile arti :GetBlueprint() had no sizex; this worked as a workaround:
        if not(oTargetBP.SizeX) then oTargetBP = __blueprints[oStealth[refoMobileStealthTarget].UnitId] end
        local iStealthDistanceWanted = math.max(8, oBP.Intel.RadarStealthFieldRadius - 1 - oBP.Physics.MaxSpeed - (oTargetBP.Physics.MaxSpeed or 0))
        local iSize = math.max(oTargetBP.SizeX, oTargetBP.SizeZ)
        if iSize >= 1 then
            iStealthDistanceWanted = iStealthDistanceWanted - math.min(1.5, iSize * 0.5)
        end

        M28Orders.IssueTrackedMove(oStealth, M28Utilities.MoveInDirection(oStealth[refoMobileStealthTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(tEnemyBase,oStealth[refoMobileStealthTarget]:GetPosition()), iStealthDistanceWanted, true, false, true), math.min(5, iStealthDistanceWanted - 1), false, 'StU'..oStealth[refoMobileStealthTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth[refoMobileStealthTarget]))
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageMobileShieldsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tMobileShields)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMobileShieldsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Size of tMobileShields='..table.getn(tMobileShields)) end

    local iCurShield, iMaxShield
    local tShieldsToRetreat = {}
    local tShieldsToAssign = {}
    local tEnemyBase = tLZTeamData[M28Map.reftClosestEnemyBase]
    if M28Utilities.IsTableEmpty(tEnemyBase) then
        M28Utilities.ErrorHandler('Couldnt find enemy base, will try backup approach')
        local iCurDist
        local iClosestDist = 100000
        local oClosestBrain
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestBrain = oBrain
            end
        end
        tEnemyBase = M28Map.PlayerStartPoints[oClosestBrain:GetArmyIndex()]
    end
    local tEnemyDFUnits
    local tRallyPoint
    if (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 200 then
        tEnemyDFUnits = EntityCategoryFilterDown(categories.DIRECTFIRE, tLZTeamData[M28Map.subrefTEnemyUnits])
        tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 1, false)
    end
    local tOriginallyAssignedMobileShields = {}
    local bRetreatShield, iDistToShieldTarget
    local bCheckForEnemiesInsideShield = false
    if tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] < math.max(200, (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 0.8) then bCheckForEnemiesInsideShield = true end
    for iUnit, oUnit in tMobileShields do
        iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, false)
        if bDebugMessages == true then
            LOG(sFunctionRef..': Considering what to do with unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurShield='..iCurShield..'; iMaxShield='..iMaxShield..'; SHield%='..iCurShield/iMaxShield..'; oUnit[M28UnitInfo.refbWaitForShieldToBeRestored]='..tostring(oUnit[M28UnitInfo.refbWaitForShieldToBeRestored] or false))
            if M28UnitInfo.IsUnitValid(oUnit[refoMobileShieldTarget]) then
                LOG(sFunctionRef..': Cur shield target='..oUnit[refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[refoMobileShieldTarget])..'; Dist to this='..M28Utilities.GetDistanceBetweenPositions(oUnit[refoMobileShieldTarget]:GetPosition(), oUnit:GetPosition())..'; Is shield close to enemy units in this LZ='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 10, iTeam, true, nil, nil, nil, nil, false)))
            end
        end
        if oUnit[refoMobileShieldTarget][M28Building.reftArtiTemplateRefs] and not(oUnit[M28UnitInfo.refbEasyBrain]) then
            --Even if shield is down/low we want to remain with the shield we are covering; we also want to be disabled if enemy has teleport
            if not(oUnit[M28UnitInfo.refbSpecialMicroActive]) then
                if not(oUnit[M28UnitInfo.refbShieldIsDisabled]) and M28Team.tTeamData[iTeam][M28Team.refbEnemyHasTeleport] then
                    M28UnitInfo.DisableUnitShield(oUnit)
                end
                table.insert(tOriginallyAssignedMobileShields, oUnit)
            end
        elseif not(oUnit[M28UnitInfo.refbEasyBrain]) and (iCurShield < iMaxShield * 0.5 or (oUnit[M28UnitInfo.refbWaitForShieldToBeRestored] and iCurShield < iMaxShield * 0.9)) then
            --Retreat
            table.insert(tShieldsToRetreat, oUnit)
        elseif oUnit[refoMobileShieldTarget] and M28UnitInfo.IsUnitValid(oUnit[refoMobileShieldTarget]) then
            bRetreatShield = false
            if not(oUnit[M28UnitInfo.refbEasyBrain]) and iCurShield < iMaxShield * 0.95 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false and not(EntityCategoryContains(categories.COMMAND,oUnit[refoMobileShieldTarget].UnitId)) then
                --Are we almost in range of enemy units?
                iDistToShieldTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[refoMobileShieldTarget]:GetPosition())
                if iDistToShieldTarget >= 30 or bCheckForEnemiesInsideShield then
                    --CloseToEnemyUnit(tStartPosition, tUnitsToCheck,                   iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                    if M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 10, iTeam, true,                      nil,                    nil,                                oUnit,                                        nil,                            false) then
                        if iDistToShieldTarget >= 30 then
                            bRetreatShield = true
                        elseif bCheckForEnemiesInsideShield and oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()) <= (oUnit:GetBlueprint().Defense.Shield.ShieldSize or 0) * 0.6 + 3 then
                            --If enemy is almost inside our shield then want to retreat to try and save the mobile shield
                            bRetreatShield = true
                        end
                    end
                end
            end
            if bRetreatShield then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to retreat shield due to risk enemy has units inbetween us and the target, or enemy is about to get underneath our shield') end
                table.insert(tShieldsToRetreat, oUnit)
                oUnit[M28UnitInfo.refbWaitForShieldToBeRestored] = true
            else
                table.insert(tOriginallyAssignedMobileShields, oUnit)
            end
        else
            table.insert(tShieldsToAssign, oUnit)
            if oUnit[M28UnitInfo.refbWaitForShieldToBeRestored] then oUnit[M28UnitInfo.refbWaitForShieldToBeRestored] = nil end
        end
    end
    if M28Utilities.IsTableEmpty(tShieldsToRetreat) == false then
        local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2)
        local tAmphibiousRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2, true)
        if bDebugMessages == true then LOG(sFunctionRef..': Will give orders to retreat, size of tShieldsToRetreat='..table.getn(tShieldsToRetreat)) end
        for iUnit, oUnit in tShieldsToRetreat do
            if bDebugMessages == true then
                local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, false)
                LOG(sFunctionRef..': About to tell unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to run due to a low shield. iCurShield='..(iCurShield or 'nil')..'; iMaxShield='..(iMaxShield or 'nil')..'; Unit paused='..tostring(oUnit[M28UnitInfo.refbPaused])..'; Are power stalling='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; Team Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; % stored E='..oUnit:GetAIBrain():GetEconomyStoredRatio('ENERGY')..'; Gross energy='..oUnit:GetAIBrain()[import('/mods/M28AI/lua/AI/M28Economy.lua').refiGrossEnergyBaseIncome]..'; oUnit.MyShield.IsOn==nil='..tostring(oUnit.MyShield.IsOn == nil))
            end
            ClearCurrentShieldTarget(oUnit)

            if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ASRun'..iLandZone)
            else
                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'SRun'..iLandZone)
            end
        end
    end
    if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
        --Assign available shields to units in this zone wanting shielding
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield]) == false then
            ShieldUnitsInLandZone(tLZTeamData, tShieldsToAssign)
        end
        if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then


            --Cycle through every land zone and record priority ones to shield
            if bDebugMessages == true then LOG(sFunctionRef..': Will give orders to tShieldsToAssign, size of table='..table.getn(tShieldsToAssign)) end
            local tiClosestLZWithNearbyThreat = {}
            local iClosestLZWithNoThreat
            local iClosestLZNotWantingShieldButWithUnits
            local iClosestLZWithAnyCombatUnits
            local tiAllOtherLZWantingShields = {}
            if tLZTeamData[M28Map.subrefbLZWantsSupport] and not(tLZTeamData[M28Map.refbLZWantsMobileShield]) and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedCombatUnits]) == false or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false) then iClosestLZNotWantingShieldButWithUnits = iLandZone end
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                local bEnemyHasTeleport = M28Team.tTeamData[iTeam][M28Team.refbEnemyHasTeleport]
                for iEntry, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                    local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': iLandZone='..iLandZone..'; Considering other land zone '..tPathingDetails[M28Map.subrefLZNumber]..'; Other land zone DF threat='..(tTeamTargetLZData[M28Map.subrefLZThreatAllyMobileDFTotal] or 'nil')..'; Does this zone want mobile shields='..tostring(tTeamTargetLZData[M28Map.refbLZWantsMobileShield] or false)..'; Does target have active GE template='..tostring(M28Conditions.HaveActiveGameEnderTemplateLogic(tTeamTargetLZData))) end
                    if tTeamTargetLZData[M28Map.refbLZWantsMobileShield] then
                        if tTeamTargetLZData[M28Map.refiEnemyAirToGroundThreat] > 0 or tTeamTargetLZData[M28Map.subrefTThreatEnemyCombatTotal] >= 40 or (bEnemyHasTeleport and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.refbLZWantsMobileShield]) == false and M28Conditions.HaveActiveGameEnderTemplateLogic(tTeamTargetLZData)) then
                            ShieldUnitsInLandZone(tTeamTargetLZData, tShieldsToAssign)
                            if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                        else
                            if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefTEnemyUnits]) == false or tTeamTargetLZData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                                table.insert(tiClosestLZWithNearbyThreat, tPathingDetails[M28Map.subrefLZNumber])
                            else
                                table.insert(tiAllOtherLZWantingShields, tPathingDetails[M28Map.subrefLZNumber])
                                if not(iClosestLZWithNoThreat) then iClosestLZWithNoThreat = tPathingDetails[M28Map.subrefLZNumber] end
                            end
                        end
                    elseif not(iClosestLZNotWantingShieldButWithUnits) then
                        if tTeamTargetLZData[M28Map.subrefbLZWantsSupport] and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) == false then
                            iClosestLZNotWantingShieldButWithUnits = tPathingDetails[M28Map.subrefLZNumber]
                        end
                        if not(iClosestLZWithAnyCombatUnits) and (M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) == false or M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefAlliedACU]) == false) then
                            iClosestLZWithAnyCombatUnits = tPathingDetails[M28Map.subrefLZNumber]
                        end
                    end

                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking other zones we can path to for units wanting shielding, is tShieldsToAssign empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; Is M28Utilities.IsTableEmpty(tiClosestLZWithNearbyThreat) empty='..tostring(M28Utilities.IsTableEmpty(tiClosestLZWithNearbyThreat))) end
            if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                if M28Utilities.IsTableEmpty(tiClosestLZWithNearbyThreat) == false then
                    for _, iTargetLZ in  tiClosestLZWithNearbyThreat do
                        local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLZ][M28Map.subrefLZTeamData][iTeam]
                        ShieldUnitsInLandZone(tTeamTargetLZData, tShieldsToAssign)
                        if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                    end
                end
                if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                    if iClosestLZWithNoThreat then
                        local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZWithNoThreat][M28Map.subrefLZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Have mobile shields to assign, closest LZ='..iClosestLZWithNoThreat..'; DOes this LZ want mobile shields='..tostring(tTeamTargetLZData[M28Map.refbLZWantsMobileShield] or false)..'; is table of units wanting shielding empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]))) end
                        ShieldUnitsInLandZone(tTeamTargetLZData, tShieldsToAssign)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is tShieldsToAssign empty after checking for closest LZ with no threat='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; iClosestLZNotWantingShieldButWithUnits='..(iClosestLZNotWantingShieldButWithUnits or 'nil')) end
                    if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                        if M28Utilities.IsTableEmpty(tiAllOtherLZWantingShields) == false then
                            for iEntry, iZone in tiAllOtherLZWantingShields do
                                if not(iZone ==iClosestLZWithNoThreat) then
                                    local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZWithNoThreat][M28Map.subrefLZTeamData][iTeam]
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have mobile shields to assign, considering zone that wants shielding, iZone='..iZone..'; DOes this LZ want mobile shields='..tostring(tTeamTargetLZData[M28Map.refbLZWantsMobileShield] or false)..'; is table of units wanting shielding empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]))) end
                                    ShieldUnitsInLandZone(tTeamTargetLZData, tShieldsToAssign)
                                    if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': Still have shields to assign after considering all zones with adjacent enemy threats, so will flag that we failed to have shield targets for plateau '..iPlateau..'; For reference, the current land zone considering this is '..iLandZone..'; Time='..GetGameTimeSeconds()) end
                            if tLZData[M28Map.subrefLZIslandRef] then M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoShieldTargetsByIsland][tLZData[M28Map.subrefLZIslandRef]] = GetGameTimeSeconds() end
                            --Dont have any land zones that want a mobile shield, but we have mobile shields - find the closest LZ  that wants DF or IF support and has DF or IF units, and send them here; if that's this LZ, then have them go to the unit closest to the enemy in this LZ, but without assigning them
                            if iClosestLZNotWantingShieldButWithUnits or iClosestLZWithAnyCombatUnits then
                                local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][(iClosestLZNotWantingShieldButWithUnits or iClosestLZWithAnyCombatUnits)][M28Map.subrefLZTeamData][iTeam]
                                if bDebugMessages == true then LOG(sFunctionRef..': Have mobile shields to assign, closest LZ with friendly combat units that wants more units='..(iClosestLZNotWantingShieldButWithUnits or 'nil')..'; iClosestLZWithAnyCombatUnits='..(iClosestLZWithAnyCombatUnits or 'nil')..'; DOes this LZ want mobile shields='..tostring(tTeamTargetLZData[M28Map.refbLZWantsMobileShield] or false)..'; is table of units wanting shielding empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]))) end
                                ShieldUnitsInLandZone(tTeamTargetLZData, tShieldsToAssign, true)
                            end
                            if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                                --cant find any land zones with friendly combat units so have nowhere to assign mobile shields; will send them all to the nearest rally point instead
                                local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2)
                                local tAmphibiousRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2, true)
                                for iUnit, oUnit in tShieldsToAssign do
                                    if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                        M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ASBckup'..iLandZone)
                                    else
                                        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'ShBckup'..iLandZone)
                                    end
                                end

                            end
                        end

                    end
                end
            end
        end
    end

    --Do we have any units in the zone without a shield, who are closer to the nearest enemy base than our current units? If so then assign a mobile shield already assigned to one of these units
    if M28Utilities.IsTableEmpty(tOriginallyAssignedMobileShields) == false then
        --First consider reassigning 1 shield if there are nearby enemy DF units and we have a unit closer to them than a current defended shield target
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield]) == false then
            local bHaveACUInZoneWithNoDFEnemies = false
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.COMMAND, tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield])) == false then bHaveACUInZoneWithNoDFEnemies = true end
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false or bHaveACUInZoneWithNoDFEnemies then
                local iClosestDistToEnemy = 10000
                local oClosestUnitWantingShieldToEnemy, iCurDist
                local bIncludeIndirect = true --v89 - changed to always include
                --if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false or (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] and GetGameTimeSeconds() - tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] <= 15) or (tLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0) > 0 then bIncludeIndirect = true end
                --Get closest enemy DF unit to our midpoint
                local oClosestEnemyToMidpoint
                local iClosestEnemyDist = 10000
                if not(bHaveACUInZoneWithNoDFEnemies) then
                    for iUnit, oUnit in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit:GetPosition())
                        if iCurDist < iClosestEnemyDist then
                            iClosestEnemyDist = iCurDist
                            oClosestEnemyToMidpoint = oUnit
                        end
                    end
                end

                if oClosestEnemyToMidpoint or bHaveACUInZoneWithNoDFEnemies then
                    local tComparisonPosition
                    if bHaveACUInZoneWithNoDFEnemies then tComparisonPosition = tLZTeamData[M28Map.reftClosestEnemyBase] else tComparisonPosition =  oClosestEnemyToMidpoint:GetPosition() end
                    local bWantToShieldACU = false

                    for iUnit, oUnit in tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield] do
                        if not(M28UnitInfo.IsUnitValid(oClosestUnitWantingShieldToEnemy[refoAssignedMobileShield])) and ((oUnit[M28UnitInfo.refiDFRange] or 0) > 12 or (bIncludeIndirect and (oUnit[M28UnitInfo.refiIndirectRange] or 0) > 12)) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tComparisonPosition)
                            if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then iCurDist = iCurDist / 1000 end
                            if iCurDist < iClosestDistToEnemy then
                                iClosestDistToEnemy = iCurDist
                                oClosestUnitWantingShieldToEnemy = oUnit
                            end
                        end
                    end
                    if oClosestUnitWantingShieldToEnemy then
                        if EntityCategoryContains(categories.COMMAND, oClosestUnitWantingShieldToEnemy.UnitId) then
                            bWantToShieldACU = true
                        end
                        local iFurthestShieldedDistToEnemy = 0
                        local oFurthestShieldToEnemy

                        if not(bWantToShieldACU) then
                            --Get the closest unit being shielded already (ignoring ACUs being shielded)
                            for iShield, oShield in tOriginallyAssignedMobileShields do

                                if not(EntityCategoryContains(categories.COMMAND, oShield[refoMobileShieldTarget].UnitId)) and not(oShield[refoMobileShieldTarget][M28Building.reftArtiTemplateRefs]) then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield[refoMobileShieldTarget]:GetPosition(), tComparisonPosition)
                                    if iCurDist > iFurthestShieldedDistToEnemy then
                                        iFurthestShieldedDistToEnemy = iCurDist
                                        oFurthestShieldToEnemy = oShield
                                    end
                                end
                            end
                        else
                            --Want the closest shield to the ACU
                            iFurthestShieldedDistToEnemy = 10000
                            for iShield, oShield in tOriginallyAssignedMobileShields do
                                if not(EntityCategoryContains(categories.COMMAND, oShield[refoMobileShieldTarget].UnitId)) and not(oShield[refoMobileShieldTarget][M28Building.reftArtiTemplateRefs]) then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oClosestUnitWantingShieldToEnemy:GetPosition())
                                    if iCurDist <     iFurthestShieldedDistToEnemy then
                                        iFurthestShieldedDistToEnemy = iCurDist
                                        oFurthestShieldToEnemy = oShield
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to reassign furthest away shield to closest shield for P'..iPlateau..'Z'..iLandZone..', iFurthestShieldedDistToEnemy='..iFurthestShieldedDistToEnemy..'; iClosestDistToEnemy='..iClosestDistToEnemy..'; oFurthestShieldToEnemy='..(oFurthestShieldToEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oFurthestShieldToEnemy) or 'nil')..'; oClosestUnitWantingShieldToEnemy='..(oClosestUnitWantingShieldToEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestUnitWantingShieldToEnemy) or 'nil')..'; Does closest unit have a valid assigned shield='..tostring(M28UnitInfo.IsUnitValid(oClosestUnitWantingShieldToEnemy[refoAssignedMobileShield]))) end
                        if oFurthestShieldToEnemy and (bWantToShieldACU or iFurthestShieldedDistToEnemy - iClosestDistToEnemy >= 3) then
                            --Switch shields
                            if bDebugMessages == true then LOG(sFunctionRef..': Will switch shields, old target='..(oFurthestShieldToEnemy[refoMobileShieldTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oFurthestShieldToEnemy[refoMobileShieldTarget]) or 'nil')..'; bWantToShieldACU='..tostring(bWantToShieldACU)) end
                            ClearCurrentShieldTarget(oFurthestShieldToEnemy)
                            RecordMobileShieldAgainstTarget(oFurthestShieldToEnemy, oClosestUnitWantingShieldToEnemy)
                        end
                    end
                end
            end
        end
        --Now move all shields to their designated unit to guard
        for iShield, oShield in tOriginallyAssignedMobileShields do
            --make sure we are behind the target
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and get shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' to move behind the shield target '..oShield[refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield[refoMobileShieldTarget])..'; Shield position='..repru(oShield:GetPosition())..'; Target last order position='..repru(oShield[refoMobileShieldTarget][M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition])) end
            MoveToShieldTarget(oShield, tEnemyBase, tLZTeamData, tEnemyDFUnits, tRallyPoint)
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageMobileStealthsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tMobileStealths, iEnemyOmniCoverage)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMobileStealthsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then
        local iEnemyOmniCoverage = M28Conditions.GetEnemyOmniCoverageOfZone(iPlateau, iLandZone, iTeam)
        LOG(sFunctionRef..': Start of code, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Size of tMobileStealths='..table.getn(tMobileStealths)..'; iEnemyOmniCoverage='..iEnemyOmniCoverage)
    end

    local tStealthsToAssign = {}
    local tEnemyBase = tLZTeamData[M28Map.reftClosestEnemyBase]
    if M28Utilities.IsTableEmpty(tEnemyBase) then
        M28Utilities.ErrorHandler('Couldnt find enemy base, will try backup approach')
        local iCurDist
        local iClosestDist = 100000
        local oClosestBrain
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestBrain = oBrain
            end
        end
        tEnemyBase = M28Map.PlayerStartPoints[oClosestBrain:GetArmyIndex()]
    end
    local tEnemyDFUnits = tLZTeamData[M28Map.reftoNearestDFEnemies]
    local tRallyPoint
    if M28Utilities.IsTableEmpty(tEnemyDFUnits) == false then
        tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 1, false)
    end

    local tOriginallyAssignedMobileStealths = {}

    --If enemy has omni coverage and we dont have units wanting mobile stealth in this zone, then clear any mobile stealths
    if iEnemyOmniCoverage >= 40 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth]) then
        for iUnit, oUnit in tMobileStealths do
            if oUnit[refoMobileStealthTarget] and ((oUnit[refoMobileStealthTarget][M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone and oUnit[refoMobileStealthTarget][M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] == iPlateau) or not(EntityCategoryContains(categories.COMMAND + M28UnitInfo.refCategoryLandExperimental, oUnit[refoMobileStealthTarget].UnitId))) then
                if oUnit[refoMobileStealthTarget][refoAssignedMobileStealth] then oUnit[refoMobileStealthTarget][refoAssignedMobileStealth] = nil end
                oUnit[refoMobileStealthTarget] = nil
            end
            table.insert(tStealthsToAssign, oUnit) --We decide whether ot run from enemies in MoveToStealthTarget
        end
    else
        for iUnit, oUnit in tMobileStealths do
            if oUnit[refoMobileStealthTarget] and M28UnitInfo.IsUnitValid(oUnit[refoMobileStealthTarget]) then
                table.insert(tOriginallyAssignedMobileStealths, oUnit)

            else
                table.insert(tStealthsToAssign, oUnit) --We decide whether ot run from enemies in MoveToStealthTarget
            end
        end
    end


    if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
        --First check none of our mobile stealth units are almost in range of an enemy that can see them
        --Stealth units in this zone first
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth]) == false then
            StealthUnitsInLandZone(tLZTeamData, tStealthsToAssign)
        end
        if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
            --Check priority table of units wanting stealth
            local aiBrain = tStealthsToAssign[1]:GetAIBrain()
            if M28Utilities.IsTableEmpty(M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.reftoPriorityUnitsWantingMobileStealth]) == false then
                local oClosestPriorityUnitWantingStealth
                local iClosestPriorityUnitWantingStealthDist = 250
                local iCurPriorityUnitWantingStealthDist

                for iUnit, oUnit in M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.reftoPriorityUnitsWantingMobileStealth] do
                    if not(oUnit.Dead) and not(M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileStealth])) and NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition()) == tLZData[M28Map.subrefLZIslandRef] then
                        iCurPriorityUnitWantingStealthDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                        if iCurPriorityUnitWantingStealthDist < iClosestPriorityUnitWantingStealthDist then
                            local tUnitLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]][M28Map.subrefLZTeamData][iTeam]
                            if bDebugMessages == true then LOG(sFunctionRef..': Have a priority unit wanting mobile stealth, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' tUnitLZTeamData[refiEnemyOmniCoverage]='..(tUnitLZTeamData[M28Map.refiEnemyOmniCoverage] or 'nil')..'; Unit assigned to P'..oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1]..'Z'..oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]..'; iPlateau='..iPlateau) end
                            if (tUnitLZTeamData[M28Map.refiEnemyOmniCoverage] or 0) < 40 then
                                --Want to assign a mobile stealth to the closest such unit
                                iClosestPriorityUnitWantingStealthDist = iCurPriorityUnitWantingStealthDist
                                oClosestPriorityUnitWantingStealth = oUnit
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for priority units wanting stealth, oClosestPriorityUnitWantingStealth='..(oClosestPriorityUnitWantingStealth.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestPriorityUnitWantingStealth) or 'nil')) end
                if M28UnitInfo.IsUnitValid(oClosestPriorityUnitWantingStealth) then
                    local tTargetUnitLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][oClosestPriorityUnitWantingStealth[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]][M28Map.subrefLZTeamData][iTeam]
                    if tTargetUnitLZTeamData then
                        --StealthUnitsInLandZone(tTeamTargetLZData, tStealthsToAssign, bAssignAllStealths, toOptionalUnitsToStealth)
                        StealthUnitsInLandZone(tTargetUnitLZTeamData, tStealthsToAssign, false, {oClosestPriorityUnitWantingStealth})
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished calling StealthUnitsInLandZone for the target unit zone='..(oClosestPriorityUnitWantingStealth[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] or 'nil')) end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then

                --Cycle through every land zone and record priority ones to Stealth
                if bDebugMessages == true then LOG(sFunctionRef..': Will give orders to tStealthsToAssign, size of table='..table.getn(tStealthsToAssign)) end
                local tiClosestLZWithNearbyThreat = {}
                local iClosestLZWithNoThreat
                local iClosestLZNotWantingStealthButWithUnits
                local iClosestLZWithAnyCombatUnits
                if tLZTeamData[M28Map.subrefbLZWantsSupport] and not(tLZTeamData[M28Map.refbLZWantsMobileStealth]) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedCombatUnits]) == false then iClosestLZNotWantingStealthButWithUnits = iLandZone end
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                    for iEntry, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                        local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                        if tTeamTargetLZData[M28Map.refbLZWantsMobileStealth] then
                            if tTeamTargetLZData[M28Map.refiEnemyAirToGroundThreat] > 0 or tTeamTargetLZData[M28Map.subrefTThreatEnemyCombatTotal] >= 40 then
                                StealthUnitsInLandZone(tTeamTargetLZData, tStealthsToAssign)
                                if M28Utilities.IsTableEmpty(tStealthsToAssign) then break end
                            elseif M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefTEnemyUnits]) == false or tTeamTargetLZData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                                table.insert(tiClosestLZWithNearbyThreat, tPathingDetails[M28Map.subrefLZNumber])
                            elseif not(iClosestLZWithNoThreat) then iClosestLZWithNoThreat = tPathingDetails[M28Map.subrefLZNumber]
                            end
                        elseif not(iClosestLZNotWantingStealthButWithUnits) then
                            if tTeamTargetLZData[M28Map.subrefbLZWantsSupport] and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) == false then iClosestLZNotWantingStealthButWithUnits = tPathingDetails[M28Map.subrefLZNumber] end
                            if not(iClosestLZWithAnyCombatUnits) and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) == false then iClosestLZWithAnyCombatUnits = tPathingDetails[M28Map.subrefLZNumber] end
                        end

                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished checking other zones we can path to for units wanting Stealthing, is tStealthsToAssign empty='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; Is M28Utilities.IsTableEmpty(tiClosestLZWithNearbyThreat) empty='..tostring(M28Utilities.IsTableEmpty(tiClosestLZWithNearbyThreat))) end
                if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                    if M28Utilities.IsTableEmpty(tiClosestLZWithNearbyThreat) == false then
                        for _, iTargetLZ in  tiClosestLZWithNearbyThreat do
                            local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLZ][M28Map.subrefLZTeamData][iTeam]
                            StealthUnitsInLandZone(tTeamTargetLZData, tStealthsToAssign)
                            if M28Utilities.IsTableEmpty(tStealthsToAssign) then break end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                        if iClosestLZWithNoThreat then
                            local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZWithNoThreat][M28Map.subrefLZTeamData][iTeam]
                            if bDebugMessages == true then LOG(sFunctionRef..': Have mobile Stealths to assign, closest LZ='..iClosestLZWithNoThreat..'; DOes this LZ want mobile Stealths='..tostring(tTeamTargetLZData[M28Map.refbLZWantsMobileStealth] or false)..'; is table of units wanting Stealthing empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileStealth]))) end
                            StealthUnitsInLandZone(tTeamTargetLZData, tStealthsToAssign)
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Is tStealthsToAssign empty after checking for closest LZ with no threat='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; iClosestLZNotWantingStealthButWithUnits='..(iClosestLZNotWantingStealthButWithUnits or 'nil')) end
                        if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                            M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoStealthTargetsByPlateau][iPlateau] = GetGameTimeSeconds()
                            --Dont have any land zones that want a mobile Stealth, but we have mobile Stealths - find the closest LZ  that wants DF or IF support and has DF or IF units, and send them here; if that's this LZ, then have them go to the unit closest to the enemy in this LZ, but without assigning them
                            if iClosestLZNotWantingStealthButWithUnits or iClosestLZWithAnyCombatUnits then
                                local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][(iClosestLZNotWantingStealthButWithUnits or iClosestLZWithAnyCombatUnits)][M28Map.subrefLZTeamData][iTeam]
                                if bDebugMessages == true then LOG(sFunctionRef..': Have mobile Stealths to assign, closest LZ with friendly combat units that wants more units='..(iClosestLZNotWantingStealthButWithUnits or 'nil')..'; iClosestLZWithAnyCombatUnits='..(iClosestLZWithAnyCombatUnits or 'nil')..'; DOes this LZ want mobile Stealths='..tostring(tTeamTargetLZData[M28Map.refbLZWantsMobileStealth] or false)..'; is table of units wanting Stealthing empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileStealth]))) end
                                StealthUnitsInLandZone(tTeamTargetLZData, tStealthsToAssign, true)
                            end
                            if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                                --No targets for mobile stealth
                                if bDebugMessages == true then LOG(sFunctionRef..': couldnt find any land zones with friendly combat units so have nowhere to assign mobile Stealths; will send them all to the nearest rally point instead') end
                                local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2)
                                for iUnit, oUnit in tStealthsToAssign do
                                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'StBckup'..iLandZone)
                                end

                            end

                        end
                    end
                end
            end
        end
    end

    if M28Utilities.IsTableEmpty(tOriginallyAssignedMobileStealths) == false then
        --First consider reassigning 1 Stealth if there are nearby enemy DF units and we have a unit closer to them than a current defended Stealth target
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth]) == false and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
            local iClosestDistToEnemy = 10000
            local oClosestUnitWantingStealthToEnemy, iCurDist
            local bIncludeIndirect = true --v89 - changed to always include
            --if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false or (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrStealth] and GetGameTimeSeconds() - tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrStealth] <= 15) or (tLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0) > 0 then bIncludeIndirect = true end
            --Get closest enemy DF unit to our midpoint
            local oClosestEnemyToMidpoint
            local iClosestEnemyDist = 10000
            for iUnit, oUnit in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit:GetPosition())
                if iCurDist < iClosestEnemyDist then
                    iClosestEnemyDist = iCurDist
                    oClosestEnemyToMidpoint = oUnit
                end
            end

            if oClosestEnemyToMidpoint then
                for iUnit, oUnit in tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth] do
                    if not(M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileStealth])) and ((oUnit[M28UnitInfo.refiDFRange] or 0) > 12 or (bIncludeIndirect and (oUnit[M28UnitInfo.refiIndirectRange] or 0) > 12)) then
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestEnemyToMidpoint:GetPosition())
                        if iCurDist < iClosestDistToEnemy then
                            iClosestDistToEnemy = iCurDist
                            oClosestUnitWantingStealthToEnemy = oUnit
                        end
                    end
                end
                if oClosestUnitWantingStealthToEnemy then
                    --Get the closest unit being Stealthed already (ignoring ACUs being Stealthed)
                    local iFurthestStealthedDistToEnemy = 0
                    local oFurthestStealthToEnemy


                    for iStealth, oStealth in tOriginallyAssignedMobileStealths do

                        if not(EntityCategoryContains(categories.COMMAND + categories.EXPERIMENTAL, oStealth[refoMobileStealthTarget].UnitId)) then --never reassign an ACU or experimental mobile stealth
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oStealth[refoMobileStealthTarget]:GetPosition(), oClosestEnemyToMidpoint:GetPosition())
                            if iCurDist > iFurthestStealthedDistToEnemy then
                                iFurthestStealthedDistToEnemy = iCurDist
                                oFurthestStealthToEnemy = oStealth
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to reassign furthest away Stealth to closest Stealth for P'..iPlateau..'Z'..iLandZone..', iFurthestStealthedDistToEnemy='..iFurthestStealthedDistToEnemy..'; iClosestDistToEnemy='..iClosestDistToEnemy..'; oFurthestStealthToEnemy='..(oFurthestStealthToEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oFurthestStealthToEnemy) or 'nil')..'; oClosestUnitWantingStealthToEnemy='..(oClosestUnitWantingStealthToEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestUnitWantingStealthToEnemy) or 'nil')) end
                    if oFurthestStealthToEnemy and iFurthestStealthedDistToEnemy - iClosestDistToEnemy >= 3 then
                        --Switch Stealths
                        if bDebugMessages == true then LOG(sFunctionRef..': Will switch Stealths, old target='..oFurthestStealthToEnemy[refoMobileStealthTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oFurthestStealthToEnemy[refoMobileStealthTarget])) end
                        oFurthestStealthToEnemy[refoMobileStealthTarget][refoAssignedMobileStealth] = nil
                        oFurthestStealthToEnemy[refoMobileStealthTarget] = oClosestUnitWantingStealthToEnemy
                        oClosestUnitWantingStealthToEnemy[refoAssignedMobileStealth] = oFurthestStealthToEnemy
                    end
                end
            end
        end
        --Now move all Stealths to their designated unit to guard
        for iStealth, oStealth in tOriginallyAssignedMobileStealths do
            --make sure we are behind the target
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and get Stealth '..oStealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth)..' to move behind the Stealth target '..oStealth[refoMobileStealthTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth[refoMobileStealthTarget])..'; Stealth position='..repru(oStealth:GetPosition())..'; Target last order position='..repru(oStealth[refoMobileStealthTarget][M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition])) end
            MoveToStealthTarget(oStealth, tEnemyBase, tLZTeamData, tEnemyDFUnits, tRallyPoint)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageMAAInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableMAA)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMAAInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2) --Get a LZ up to 3 land zones away to retreat to (i.e. will pick rally point and then move 2 towards it)
    local tAmphibiousRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2, true)
    local bRetreatWithAllMAA = false
    local bAttackMoveWithMAA = false

    --Consider retreating if insufficient MAA to deal with enemy air to ground threat and lack significant fixed AA in this zone
    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to retreat or attack move vs enemy air, M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; tLZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA]='..tLZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA]..'; Team has air control='..tostring(M28Conditions.TeamHasAirControl(iTeam))) end
    if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 2000 and tLZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] <= math.min(8000, M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.25) and not(M28Conditions.TeamHasAirControl(iTeam)) then
        local bBombersOrTransportNearby = false
        local iAdjLZEnemyGunshipThreat = 0
        local iAdjLZOurMAAThreat = (tLZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] or 0) - (tLZTeamData[M28Map.subrefLZThreatAllyMAA] or 0) --Include fixedAA from this zone

        function ConsiderZoneAirAndMAAValues(tCurZoneTeamData)
            if M28Utilities.IsTableEmpty(tCurZoneTeamData[M28Map.reftLZEnemyAirUnits]) == false then
                if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryBomber + M28UnitInfo.refCategoryTransport, tCurZoneTeamData[M28Map.reftLZEnemyAirUnits])) == false then
                    bBombersOrTransportNearby = true
                else
                    iAdjLZEnemyGunshipThreat = iAdjLZEnemyGunshipThreat + (tCurZoneTeamData[M28Map.refiEnemyAirToGroundThreat] or 0)
                end
            end
            iAdjLZOurMAAThreat = iAdjLZOurMAAThreat + tLZTeamData[M28Map.subrefLZThreatAllyMAA]
        end
        ConsiderZoneAirAndMAAValues(tLZTeamData)

        if not(bBombersOrTransportNearby) then
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                ConsiderZoneAirAndMAAValues(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam])
                if bBombersOrTransportNearby then break end
            end
        end
        if not(bBombersOrTransportNearby) then
            if iAdjLZEnemyGunshipThreat > iAdjLZOurMAAThreat * 4 then
                tLZTeamData[M28Map.subrefLZTimeMAARetreatedFromGunships] = GetGameTimeSeconds()
                bRetreatWithAllMAA = true
            elseif iAdjLZEnemyGunshipThreat > math.min(iAdjLZOurMAAThreat, 8000) then
                bAttackMoveWithMAA = true
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bBombersOrTransportNearby='..tostring(bBombersOrTransportNearby)..'; iAdjLZEnemyGunshipThreat='..iAdjLZEnemyGunshipThreat..'; iAdjLZOurMAAThreat='..iAdjLZOurMAAThreat..'; bAttackMoveWithMAA='..tostring(bAttackMoveWithMAA)..'; bRetreatWithAllMAA='..tostring(bRetreatWithAllMAA)) end
    end

    --First split the MAA into those that need to run (due to being in range of DF units) and those that can advance
    local tMAAToAdvance = {}
    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, is table of nearest DF enemies empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]))..'; P='..iPlateau..'; Zone='..iLandZone) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) and not(bRetreatWithAllMAA) then
        --No DF enemies so treat all MAA as being available
        tMAAToAdvance = tAvailableMAA
        if bDebugMessages == true then LOG(sFunctionRef..': No DF enemies so will consider advancing with all MAA') end
    else
        local iRunThreshold = 20
        if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
            iRunThreshold = 14
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false then
                iRunThreshold = 10
            end
        end
        --Increase run threshold if we dont have a significant combat force in this zone
        if tLZTeamData[M28Map.subrefbLZWantsDFSupport] and tLZTeamData[M28Map.subrefLZThreatAllyMAA] > (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] + tLZTeamData[M28Map.subrefLZSValue]) * 2 and tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] < tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] then
            iRunThreshold = iRunThreshold * 2
        end

        local bMovingTowardsEnemy, iAngleToRally, iAngleToNearestUnit, bAmphibiousUnit
        local bCampaignMap = M28Map.bIsCampaignMap
        if bDebugMessages == true then
            LOG(sFunctionRef..': Will list out every unit in reftoNearestDFEnemies')
            for iUnit, oUnit in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                LOG(sFunctionRef..': Enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
            end
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                    LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; Is table of DF enemies empty='..tostring(M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftoNearestDFEnemies])))
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                        for iUnit, oUnit in tAdjLZTeamData[M28Map.reftoNearestDFEnemies] do
                            LOG(sFunctionRef..': Adj LZ enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
                        end
                    end
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': iRunThreshold='..iRunThreshold..'; Enemy air to ground threat='..(tLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 'nil')) end
        for iUnit, oUnit in tAvailableMAA do
            --Run if within 14 of being in range of enemy direct fire
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if friendly unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is in range of an enemy unit, is close to enemy='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], iRunThreshold, iTeam, true                    , nil,                  nil,                                oUnit))) end
            --CloseToEnemyUnit(tStartPosition, tUnitsToCheck,                           iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
            if M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], iRunThreshold, iTeam, true                    , nil,                  nil,                                oUnit) then
                if bDebugMessages == true then
                    LOG(sFunctionRef..': MAA '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is too close to DF enemy, iRunThreshold='..iRunThreshold..'; will run back; will list out enemy units and distance to us in a moment')
                    for iEnemy, oEnemy in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                        LOG('oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; DF r ange='..(oEnemy[M28UnitInfo.refiDFRange] or 'nil')..'; Dist to this MAA unit='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Actual distance using actual position='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemy:GetPosition()))
                    end
                end
                --Does moving towards the rally point take us closer to the enemy?
                bMovingTowardsEnemy = false
                bAmphibiousUnit = EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId)
                local tTempRetreatLocation
                if oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] then
                    local tCurRallyPoint
                    if bAmphibiousUnit then
                        tCurRallyPoint = tAmphibiousRallyPoint
                    else
                        tCurRallyPoint = tRallyPoint
                    end
                    iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)
                    iAngleToNearestUnit = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': iAngleToRally='..iAngleToRally..'; iAngleToNearestUnit='..iAngleToNearestUnit..'; Angle dif='..M28Utilities.GetAngleDifference(iAngleToRally, iAngleToNearestUnit)) end
                    if M28Utilities.GetAngleDifference(iAngleToRally, iAngleToNearestUnit) <= 60 then --tried with lower value of 45 and led to MAA moving closer to enemy
                        bMovingTowardsEnemy = true
                        --Can we move in the opposite direction to the enemy?
                        tTempRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToNearestUnit + 180, 20, true, false, bCampaignMap)
                        if M28Utilities.IsTableEmpty(tTempRetreatLocation) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': Island ref for tempretreatlocation='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tTempRetreatLocation) or 'nil')..'; LZData island ref='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')) end
                            if not(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tTempRetreatLocation) == tLZData[M28Map.subrefLZIslandRef]) then
                                tTempRetreatLocation = nil
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': MAA will retreat, tTempRetreatLocation='..repru(tTempRetreatLocation)..'; Angle from mAA to this='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), (tTempRetreatLocation or {0,0,0}))) end
                if M28Utilities.IsTableEmpty(tTempRetreatLocation) == false then
                    M28Orders.IssueTrackedMove(oUnit, tTempRetreatLocation, 6, false, 'ORun'..iLandZone)
                elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                    --IssueTrackedMove(oUnit, tOrderPosition, iDistanceToReissueOrder, bAddToExistingQueue, sOptionalOrderDesc, bOverrideMicroOrder)
                    M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'MAAConsA'..iLandZone)
                else
                    if bDebugMessages == true then LOG(sFunctionRef..'; Will retreat to rally point, angle to rally='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)..'; Dist to rally='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint)) end
                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'MAAConsL'..iLandZone)
                end
                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = GetGameTimeSeconds()
            elseif bRetreatWithAllMAA then
                if bAmphibiousUnit then
                    M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ARun'..iLandZone)
                else
                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'Run'..iLandZone)
                end
                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = GetGameTimeSeconds()
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Will treat MAA as not in danger and consider advancing with it') end
                table.insert(tMAAToAdvance, oUnit)
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of tMAAToAdvance empty='..tostring(M28Utilities.IsTableEmpty(tMAAToAdvance))) end


    --If enemy has air units in this zone then send the MAA to advance units towards it, but avoid enemy land units
    if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Number of MAA units to advance='..table.getn(tMAAToAdvance)..'; Is table of enemy air units for this LZ '..iLandZone..' empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]))..'; bRetreatWithAllMAA='..tostring(bRetreatWithAllMAA)) end
        if bRetreatWithAllMAA then
            for iUnit, oUnit in tMAAToAdvance do
                if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                    M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'MAACons2A'..iLandZone)
                else
                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'MAACons2L'..iLandZone)
                end
            end
        elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) == false then
            --Move towards the nearest enemy air unit to the LZ midpoint
            local oNearestEnemyToMidpoint
            local iClosestDist = 100000
            local iCurDist
            --Get closest enemy air unit
            for iUnit, oUnit in tLZTeamData[M28Map.reftLZEnemyAirUnits] do
                iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                if iCurDist < iClosestDist then
                    iClosestDist = iCurDist
                    oNearestEnemyToMidpoint = oUnit
                end
            end

            --Move towards the air unit
            local tOrderPosition = oNearestEnemyToMidpoint:GetPosition()
            if bDebugMessages == true then
                LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..' Will order every MAA to move to oNearestEnemyToMidpoint='..oNearestEnemyToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint)..' at position '..repru(oNearestEnemyToMidpoint:GetPosition()))
                --M28Utilities.DrawLocation(tOrderPosition) --this will desync the replay so only manually enable
            end
            --local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2, false)

            for iUnit, oUnit in tMAAToAdvance do
                --Below is redundant so commented out, as already doing close to enemy check above
                --CloseToEnemyUnit(tStartPosition,       tUnitsToCheck,              iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                --[[if M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 6, iTeam, true,               nil,                        nil,                                nil,                                    nil,                                    false) then
                    M28Orders.IssueTrackedAggressiveMove(oUnit, tRallyPoint, 7, false, 'MmaAR' )
                else--]]
                if bAttackMoveWithMAA then
                    M28Orders.IssueTrackedAggressiveMove(oUnit, tOrderPosition, 7, false, 'MNAm')
                else
                    M28Orders.IssueTrackedMove(oUnit, tOrderPosition, 7, false, 'MNA')
                end
                --end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will do reprs of orders of the first unit in tMAAToAdvance, '..tMAAToAdvance[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tMAAToAdvance[1])..': '..reprs(tMAAToAdvance[1][M28Orders.reftiLastOrders])) end

        else
            --Enemy doesnt have any air units, so consider if there are other land zones we want to support with MAA
            local tLZToReinforceModDistance = {}
            local iCurModDist
            local bSignificantAdjacentDanger = false
            local iMinCombatIfSignifDanger = 0
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                --If there are enemies in an adjacent LZ, then be more cautious with where to send MAA
                if tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] > 0 or tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeIFThreat] > 0 then
                    bSignificantAdjacentDanger = true
                    iMinCombatIfSignifDanger = math.max(2000, (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] + tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeIFThreat]) * 0.5)
                elseif tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                    local iEnemyThreat = math.max(0, (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) - (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0))
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                            local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                            iEnemyThreat = iEnemyThreat + math.max(0, (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) - (tAdjLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0))
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iEnemyThreat (i.e. net adjacent combat threat)='..iEnemyThreat..'; This zone ally MAA='..tLZTeamData[M28Map.subrefLZThreatAllyMAA]) end
                    if iEnemyThreat > math.min(800, (tLZTeamData[M28Map.subrefLZThreatAllyMAA] or 0) * 0.04) then
                        bSignificantAdjacentDanger = true
                        iMinCombatIfSignifDanger = math.min(iEnemyThreat * 0.2, (tLZTeamData[M28Map.subrefLZThreatAllyMAA] or 0) * 0.1, 800)
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': About to consider all other adjacent land zones to iLandZone '..iLandZone..', reprs of tLZData[M28Map.subrefLZPathingToOtherLandZones]='..reprs(tLZData[M28Map.subrefLZPathingToOtherLandZones])..'; Size of tMAAToAdvance='..table.getn(tMAAToAdvance)..'; bSignificantAdjacentDanger='..tostring(bSignificantAdjacentDanger)..'; iMinCombatIfSignifDanger='..iMinCombatIfSignifDanger) end

                for iEntry, tPathDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                    local tAltTeamLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to send MAA to assist alt LZ '..tPathDetails[M28Map.subrefLZNumber]..'; tAltTeamLZData[M28Map.subrefLZMAAThreatWanted]='..tAltTeamLZData[M28Map.subrefLZMAAThreatWanted]..'; tAltTeamLZData[M28Map.subrefLZOrWZThreatAllyGroundAA]='..tAltTeamLZData[M28Map.subrefLZOrWZThreatAllyGroundAA]..'; subrefLZThreatAllyMAA='..tAltTeamLZData[M28Map.subrefLZThreatAllyMAA]..'; Air to ground threat in this alt LZ='..tAltTeamLZData[M28Map.refiEnemyAirToGroundThreat]..'; GetNetMAAWantedForZone='..M28Conditions.GetNetMAAWantedForZone(tAltTeamLZData)) end
                    if tAltTeamLZData[M28Map.subrefLZMAAThreatWanted] > tAltTeamLZData[M28Map.subrefLZOrWZThreatAllyGroundAA] or (tAltTeamLZData[M28Map.subrefLZMAAThreatWanted] > tAltTeamLZData[M28Map.subrefLZThreatAllyMAA] and M28Conditions.GetNetMAAWantedForZone(tAltTeamLZData) > 0) then
                        if not(bSignificantAdjacentDanger) or (tLZTeamData[M28Map.subrefLZSValue] > 30 or tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > math.min(iMinCombatIfSignifDanger, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal])) then
                            iCurModDist = tPathDetails[M28Map.subrefLZTravelDist]
                            if tAltTeamLZData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                                iCurModDist = iCurModDist - 200
                                if tAltTeamLZData[M28Map.subrefLZTThreatAllyCombatTotal] > 0 then iCurModDist = iCurModDist - 35 end
                            elseif (tAltTeamLZData[M28Map.refiEnemyAirOtherThreat] + tLZTeamData[M28Map.refiEnemyAirAAThreat]) > 45 then iCurModDist = iCurModDist - 100
                            end
                            if M28Utilities.IsTableEmpty(tAltTeamLZData[M28Map.subreftoLZOrWZAlliedUnits]) then iCurModDist = iCurModDist + 100 end
                            if tAltTeamLZData[M28Map.subrefTThreatEnemyCombatTotal] > 6 then
                                iCurModDist = iCurModDist + 50
                                if tAltTeamLZData[M28Map.subrefLZTThreatAllyCombatTotal] == 0 then
                                    iCurModDist = iCurModDist + 150
                                elseif tAltTeamLZData[M28Map.subrefTThreatEnemyCombatTotal] > tAltTeamLZData[M28Map.subrefLZTThreatAllyCombatTotal] then
                                    iCurModDist = iCurModDist + 75
                                end
                                --tAltTeamLZData[M28Map.subrefTThreatEnemyCombatTotal] > subrefLZTThreatAllyCombatTotal
                            end
                            tLZToReinforceModDistance[tPathDetails[M28Map.subrefLZNumber]] = iCurModDist
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tLZToReinforceModDistance) == false then
                    for iLZ, iModDist in M28Utilities.SortTableByValue(tLZToReinforceModDistance, false) do
                        if bDebugMessages == true then LOG(sFunctionRef..': About to send MAA to support zone '..iLZ..'; iModDist='..iModDist..'; size of tMAAToAdvance='..table.getn(tMAAToAdvance)) end
                        SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, iLZ)
                        if M28Utilities.IsTableEmpty(tMAAToAdvance) then
                            break
                        end
                    end
                end

                if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': Still ahve MAA left over, will consider ot her zones to advance to') end
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                        for iEntry, tPathDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                            local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                            if not(tAltLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tAltLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false and tAltLZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] < tAltLZTeamData[M28Map.subrefLZTValue] * 0.1 then
                                if bDebugMessages == true then LOG(sFunctionRef..': sending MAA to support other LZ='..tPathDetails[M28Map.subrefLZNumber]..'; Size of MAA to advance before sending='..table.getn(tMAAToAdvance)) end
                                SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, tPathDetails[M28Map.subrefLZNumber])
                                if M28Utilities.IsTableEmpty(tMAAToAdvance) then break end
                            end
                        end
                    end
                end
            end



            --Do we have any MAA remaining after sending MAA to any LZ wanting support?
            if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                --Is there an adjacent water zone that wants MAA support?
                if bDebugMessages == true then LOG(sFunctionRef..': Checking if have adjacent water zones, in which case will see if any of them want MAA; is table of adj water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                    local tHoverMAA = EntityCategoryFilterDown(categories.HOVER, tMAAToAdvance)
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of hover MAA empty='..tostring(M28Utilities.IsTableEmpty(tHoverMAA))) end
                    if M28Utilities.IsTableEmpty(tHoverMAA) == false then
                        local iPond, iAdjWZ
                        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                            iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                            iPond = M28Map.tiPondByWaterZone[iAdjWZ]
                            local tAltWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjWZ='..iAdjWZ..'; iPond='..iPond..'; MAA threat wanted='..tAltWZTeamData[M28Map.subrefWZMAAThreatWanted]) end
                            if tAltWZTeamData[M28Map.subrefWZMAAThreatWanted] > math.max(50, tAltWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA]) then
                                --Only consider if either no enemy threat, or we have an allied combat threat
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy combat total='..tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Ally combat total='..tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]) end
                                if tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < 10 or tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] > 10 then
                                    SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, iAdjWZ, nil, true, tHoverMAA)
                                    if M28Utilities.IsTableEmpty(tHoverMAA) then break end
                                end
                            end
                        end


                        --Do we still have hover MAA available and have high priority water zoens wanting MAA?
                        if M28Utilities.IsTableEmpty(tHoverMAA) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': Checking list of centrally flagged WZ to see if they want MAA, is table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau]))..'; repru of M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau]='..repru(M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau])) end
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau]) == false then
                                local iDistThreshold = math.max(250, M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase])) * 0.8
                                local iThresholdAdjust
                                for iAdjWZ, bWantsSupport in M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau] do
                                    --If waterzone isn't too far from us then support it (based on simple straight line)
                                    iPond = M28Map.tiPondByWaterZone[iAdjWZ]
                                    local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
                                    iThresholdAdjust = 0
                                    if tAltWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZMAAThreatWanted] >= 2000 and tAltWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefLZTThreatAllyCombatTotal] >= 12000 then iThresholdAdjust = 100 end
                                    if bDebugMessages == true then
                                        --[[if not(iAdjWZ) then LOG('iAdjWZ is nil') end
                                        if not(iDistThreshold) then LOG('iDistThreshold is nil') end
                                        LOG('tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint]))
                                        LOG('tAltWZData[M28Map.subrefMidpoint]='..repru(tAltWZData[M28Map.subrefMidpoint])..'; iAdjWZ='..iAdjWZ..'; iPond='..(iPond or 'nil'))--]]
                                        LOG(sFunctionRef..': Considering WZ further away flagged as wanting MAA, iAdjWZ='..iAdjWZ..'; iDistThreshold='..iDistThreshold..'; Dist to WZ='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tAltWZData[M28Map.subrefMidpoint])..'; iThresholdAdjust='..iThresholdAdjust)
                                    end
                                    if M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tAltWZData[M28Map.subrefMidpoint]) <= iDistThreshold + iThresholdAdjust then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and send MAA to this water zone') end
                                        SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, iAdjWZ, nil, true, tHoverMAA)
                                        if M28Utilities.IsTableEmpty(tHoverMAA) then break end
                                    end
                                end
                            end
                            --Consider sending MAA to all zones (i.e. land and water, and other islands)
                            M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData)
                            if M28Utilities.IsTableEmpty(tHoverMAA) == false and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                                local iZoneMAAWanted
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering sending MAA to further away islands') end
                                for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                                    local tAltLZOrWZData, tAltLZOrWZTeamData
                                    if tSubtable[M28Map.subrefbIsWaterZone] then
                                        tAltLZOrWZData = M28Map.tPondDetails[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                        tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                                        iZoneMAAWanted = tAltLZOrWZTeamData[M28Map.subrefWZMAAThreatWanted]
                                    else
                                        if tSubtable[M28Map.subrefiPlateauOrPond] == iPlateau then
                                            tAltLZOrWZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                            tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                                            iZoneMAAWanted = tAltLZOrWZTeamData[M28Map.subrefLZMAAThreatWanted]
                                        else
                                            iZoneMAAWanted = 0
                                        end
                                    end
                                    if iZoneMAAWanted >= 5 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': About to send MAA to support LZ or WZ ref='..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..'; Is water zone='..tostring(tSubtable[M28Map.subrefbIsWaterZone])..'; iZoneMAAWanted='..iZoneMAAWanted..'; iPlateau='..iPlateau..'; Is table of tHoverMAA empty='..tostring(M28Utilities.IsTableEmpty(tHoverMAA))) end
                                        SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, tSubtable[M28Map.subrefiLandOrWaterZoneRef], 1.5, tSubtable[M28Map.subrefbIsWaterZone], tHoverMAA)
                                        if M28Utilities.IsTableEmpty(tHoverMAA) then break end
                                    end
                                end
                            end
                        end
                    end
                end


                --If sitll have MAA available, then send to existing land zones with a greater factor
                if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                    local iMAALZToSupport
                    local iHighestAirValue = 0
                    local iHighestAirLZ
                    local iCurAirValue
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                        for iEntry, tPathDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering which adjacent LZ has the biggest air threat for leftover MAA, cur entry=LZ'..tPathDetails[M28Map.subrefLZNumber]..'; MAA threat wanted='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZMAAThreatWanted]..'; GroundAA have already='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZOrWZThreatAllyGroundAA]..'; Enemy air to ground threat='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.refiEnemyAirToGroundThreat]..'; Air othre threat='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.refiEnemyAirOtherThreat]..'; Is table of enemy air empty for this alt LZ='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.reftLZEnemyAirUnits]))..' iHighestAirValue so far='..iHighestAirValue) end
                            if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZMAAThreatWanted] > M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZOrWZThreatAllyGroundAA] then
                                local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                                iCurAirValue = tAltLZTeamData[M28Map.subrefLZMAAThreatWanted] * 0.01 + tAltLZTeamData[M28Map.refiEnemyAirToGroundThreat] + (tAltLZTeamData[M28Map.refiEnemyAirOtherThreat] + tAltLZTeamData[M28Map.refiEnemyAirAAThreat]) * 0.1
                                if iCurAirValue > iHighestAirValue then
                                    iHighestAirValue = iCurAirValue
                                    iHighestAirLZ = tPathDetails[M28Map.subrefLZNumber]
                                end
                            end
                        end
                    end
                    iMAALZToSupport = iHighestAirLZ


                    if bDebugMessages == true then LOG(sFunctionRef..': Do any adjacent zones want support? iMAALZToSupport='..(iMAALZToSupport or 'nil')) end
                    if iMAALZToSupport then
                        local tTargetPosition = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iMAALZToSupport][M28Map.subrefMidpoint]
                        for iUnit, oUnit in tMAAToAdvance do
                            M28Orders.IssueTrackedMove(oUnit, tTargetPosition, 10, false, 'MVBLZ'..iMAALZToSupport)
                        end
                    end
                    if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then --Go back through each LZ assigning 3 times what it would normally want in MAA
                        local iFactorAdjust
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                            if iMinCombatIfSignifDanger == 0 then iMinCombatIfSignifDanger = 10 end
                            for iEntry, tPathDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                                local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                                if (not(tAltLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) or tAltLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > iMinCombatIfSignifDanger or tAltLZTeamData[M28Map.subrefLZSValue] > 10) then
                                    iFactorAdjust = 2
                                    if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then iFactorAdjust = 3 end
                                    SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, tPathDetails[M28Map.subrefLZNumber], iFactorAdjust)
                                end
                            end
                        end
                    end
                end
            end

            if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Still have spare MAA, tLZData[M28Map.subrefLZIslandRef]='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iPlateau='..(iPlateau or 'nil')) end
                --Only flag that we have no MAA targets for a core base if we have 10+ MAA, including T2+ MAA, with no target
                local bEnoughMAAInZone = false
                if tLZTeamData[M28Map.subrefLZbCoreBase] then
                    local tT2PlusMAAToAdvance = EntityCategoryFilterDown(categories.TECH2 + categories.TECH3, tMAAToAdvance)
                    if table.getn(tT2PlusMAAToAdvance) >= 8 then
                        bEnoughMAAInZone = true
                    end
                elseif tLZTeamData[M28Map.subrefLZCoreExpansion] then
                    if table.getn(tMAAToAdvance) >= 2 then
                        bEnoughMAAInZone = true
                    end
                else
                    bEnoughMAAInZone = true
                end
                if bEnoughMAAInZone then
                    if not(tLZData[M28Map.subrefLZIslandRef]) then tLZData[M28Map.subrefLZIslandRef] = NavUtils.GetLabel(M28Map.refPathingTypeHover, tLZData[M28Map.subrefMidpoint]) end
                    if tLZData[M28Map.subrefLZIslandRef] then
                        if not(M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoMAATargetsByIsland]) then M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoMAATargetsByIsland] = {} end
                        M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoMAATargetsByIsland][tLZData[M28Map.subrefLZIslandRef]] = GetGameTimeSeconds()
                    end
                end
                --Go to rally point instead
                for iUnit, oUnit in tMAAToAdvance do
                    if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                        M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 10, false, 'ABRtr'..iLandZone)
                    else
                        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 10, false, 'BRtr'..iLandZone)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageRASSACUsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tSACUs)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageRASSACUsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Manages SACUs to be assigned engineer type duties (wont always be RAS SACUs - e.g. might be LOUD where we want SACUs to build experimentals
    --Gameender duty - have RAS SACUs assist with building a gameender/t3 arti/novax in the zone and associated shielding, if we have an active template
    local bProceed = true
    if bDebugMessages == true then LOG(sFunctionRef..': Start of RAS code, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Time='..GetGameTimeSeconds()..'; Time since last wanted SACU for exp='..(GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeLastWantSACUForExp] or 0))) end
    function BuildCategoryWithSACUs(iCategoryWanted, iOptionalFactionWanted, toSACUByFaction, iOptionalEngineerActionForTracking)
        --toSACUByFaction - only needed if iOptionalFactionWanted is specified
        --iOptionalEngineerActionForTracking - if specified, then will call trackengineer function
        local oPrimaryEngineer
        if iOptionalFactionWanted then
            oPrimaryEngineer = toSACUByFaction[iOptionalFactionWanted][1]
        else
            oPrimaryEngineer = tSACUs[1]
        end

        if oPrimaryEngineer then
            local aiBrain = oPrimaryEngineer:GetAIBrain()
            local sBlueprint, tBuildLocation = M28Engineer.GetBlueprintAndLocationToBuild(aiBrain, oPrimaryEngineer, iOptionalEngineerActionForTracking or M28Engineer.refActionBuildExperimental, iCategoryWanted, 100, nil, nil,                                false,                          nil,                nil,                                false, tLZData, tLZTeamData)

            --Update SACU table to remove any of the desired faction who can be given other orders
            if bDebugMessages == true then LOG(sFunctionRef..': sBlueprint='..(sBlueprint or 'nil')..'; tBuildLocation='..repru(tBuildLocation or {})..'; oPrimaryEngineer='..(oPrimaryEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oPrimaryEngineer) or 'nil')) end
            if sBlueprint and tBuildLocation then
                local toBuilders
                if iOptionalFactionWanted then
                    for iCurEntry = table.getn(tSACUs), 1, -1 do
                        if M28UnitInfo.GetUnitFaction(tSACUs[iCurEntry]) == iOptionalFactionWanted then
                            table.remove(tSACUs, iCurEntry)
                        end
                    end
                    toBuilders = toSACUByFaction[iOptionalFactionWanted]
                else
                    toBuilders = tSACUs
                end

                --Build with all the SACUs wanted
                if M28Utilities.IsTableEmpty(toBuilders) == false then
                    bProceed = false
                    if iOptionalFactionWanted and M28Utilities.IsTableEmpty(tSACUs) == false then bProceed = true end
                    for iSACU, oSACU in toBuilders do
                        local tMoveLocation = M28Engineer.GetLocationToMoveForConstruction(oSACU, tBuildLocation, sBlueprint, 0, false)
                        if tMoveLocation then
                            if bDebugMessages == true then LOG(sFunctionRef..': Telling oSACU '..oSACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSACU)..' to move to '..repru(tMoveLocation)..' and then build '..sBlueprint..' at location '..repru(tBuildLocation)) end
                            M28Orders.IssueTrackedMoveAndBuild(oSACU, tBuildLocation, sBlueprint, tMoveLocation, 1, false, 'SACUExpMBld')
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Telling engineer '..oSACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSACU)..' to build '..sBlueprint..' at build location '..repru(tBuildLocation)) end
                            M28Orders.IssueTrackedBuild(oSACU, tBuildLocation, sBlueprint, false, 'SACUExpBld')
                        end
                        if iOptionalEngineerActionForTracking and not(oSACU[M28Engineer.refiAssignedAction] == iOptionalEngineerActionForTracking) then M28Engineer.TrackEngineerAction(oSACU, iOptionalEngineerActionForTracking, iSACU == 1, 1, nil, nil, false) end
                        --M28Engineer.TrackEngineerAction(oSACU, M28Engineer.refActionBuildExperimental, true, 1, nil, nil, false)
                    end
                end
            end
        end
    end

    if tLZTeamData[M28Map.subrefbGEShieldSACU] then
        --Check if we need more shield SACUs
        local iShieldSACUsWantedPerTemplate = M28Conditions.GetShieldSACUsWantedForGETemplate(iTeam)
        local iAdditionalShieldSACUsWanted = 0
        for iTemplate, tSubtable in tLZTeamData[M28Map.reftActiveGameEnderTemplates] do
            if M28Utilities.IsTableEmpty(tSubtable[M28Map.subreftoGEShieldSACUs]) then
                iAdditionalShieldSACUsWanted = iAdditionalShieldSACUsWanted + iShieldSACUsWantedPerTemplate
            else
                iAdditionalShieldSACUsWanted = iAdditionalShieldSACUsWanted + math.max(0, table.getn(tSubtable[M28Map.subreftoGEShieldSACUs]) - iShieldSACUsWantedPerTemplate)
            end
        end
        for iSACU = table.getn(tSACUs), 1, -1 do
            if EntityCategoryContains(categories.UEF, tSACUs[iSACU].UnitId) then
                M28Engineer.AssignEngineerToGameEnderTemplate(tSACUs[iSACU], tLZData, tLZTeamData, iPlateau, iLandZone)
                table.remove(tSACUs, iSACU)
                iAdditionalShieldSACUsWanted = iAdditionalShieldSACUsWanted - 1
                if iAdditionalShieldSACUsWanted <= 0 then break end
            end
        end
    end

    --If have any SACUs without RAS upgrade that could get it, then get RAS upgrade, provided no enemies in the zone (LOUD - only doe this if close to unit cap or defending against t3 arti since that will stop us building mass fabs, due to how bad ras is)
    if M28Utilities.IsTableEmpty(tSACUs) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Considering getting RAS if no enemies in LZ and not LOUD, tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])..'; Enemy air to ground='..(tLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0)..'; Unit cap level='..(M28Team.tTeamData[iTeam][M28Team.refiLowestUnitCapAdjustmentLevel] or 'nil')..'; Defending against arti='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti])..'; Team mass%='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Team is stalling E='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])) end
        if not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and (tLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) == 0 and (not(M28Utilities.bLoudModActive) or (M28Team.tTeamData[iTeam][M28Team.refiLowestUnitCapAdjustmentLevel] or 5) <= 2 or M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.9 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 30 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]))) then
            local tSACUsToUpgrade = {}
            local tSACUsUpgrading = {}
            local bWantBuildPower = false
            if (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.6 or (M28Team.tTeamData[iTeam][M28Team.refiLowestUnitCapAdjustmentLevel] <= -2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.2)) and (GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] or 0)) <= 5 or not(M28Conditions.HaveLowPower(iTeam)) then
                bWantBuildPower = true
            end
            local sUpgradeWanted
            for iSACU = table.getn(tSACUs), 1, -1 do
                local oSACU = tSACUs[iSACU]
                if bDebugMessages == true then LOG(sFunctionRef..'; Considering iSACU='..iSACU..' in the table, oSACU='..oSACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSACU)..'; Unit state='..M28UnitInfo.GetUnitState(oSACU)..'; Special micro active='..tostring(oSACU[M28UnitInfo.refbSpecialMicroActive])..'; oSACU[M28ACU.reftPreferredUpgrades]='..repru(oSACU[M28ACU.reftPreferredUpgrades])..'; bWantBuildPower='..tostring(bWantBuildPower or false)) end
                if oSACU:IsUnitState('Upgrading') then
                    table.insert(tSACUsUpgrading, oSACU)
                    table.remove(tSACUs, iSACU)
                elseif oSACU[M28UnitInfo.refbSpecialMicroActive] and oSACU:IsUnitState('Moving') then
                    --Do nothing - e.g. SACU might be rolling off of factory, or dodging a shot
                else
                    if oSACU[M28ACU.reftPreferredUpgrades] == nil or (bWantBuildPower and not(oSACU[M28ACU.refbTriedAndFailedToGetBuildRateUpgrade])) then
                        sUpgradeWanted = M28ACU.GetUpgradeForSACU(oSACU, bWantBuildPower, bWantBuildPower)
                        if bDebugMessages == true then LOG(sFunctionRef..': sUpgradeWanted='..(sUpgradeWanted or 'nil')) end
                        if sUpgradeWanted then
                            --Get upgrade wanted
                            table.insert(tSACUsToUpgrade, oSACU)
                            table.remove(tSACUs, iSACU)
                            if bWantBuildPower and (oSACU[M28ACU.refiUpgradeCount] or 0) == 0  then bWantBuildPower = false end --i.e. better to just get bild power on 1 and assist with others, than try to get on all at the same time
                            if bDebugMessages == true then LOG(sFunctionRef..': Have added SACU to table of SACUs to upgrade, sUpgradeWanted='..sUpgradeWanted) end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of SACUs upgrading empty='..tostring(M28Utilities.IsTableEmpty(tSACUsUpgrading))) end
            if M28Utilities.IsTableEmpty(tSACUsUpgrading) == false then
                local bLeaveOneSACU = false
                local iMaxDistanceToAssist
                if ((tLZTeamData[M28Map.subrefiTimeLastWantSACUForExp] or tLZTeamData[M28Map.subrefiTimeLastWantSACUForSMD]) and GetGameTimeSeconds() - math.max((tLZTeamData[M28Map.subrefiTimeLastWantSACUForExp] or 0), tLZTeamData[M28Map.subrefiTimeLastWantSACUForSMD] or 0) <= 3) then
                    bLeaveOneSACU = true
                elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]) == false and M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] then
                    bLeaveOneSACU = true
                    iMaxDistanceToAssist = 20
                end

                --First add any SACUsToUpgrade back to main table
                if M28Utilities.IsTableEmpty(tSACUsToUpgrade) == false then
                    for iSACU, oSACU in tSACUsToUpgrade do
                        table.insert(tSACUs, oSACU)
                    end
                end
                --Assist with all SACUs (or all but one)
                local oSACUToAssist = tSACUsUpgrading[1]
                bProceed = bLeaveOneSACU
                for iSACU = table.getn(tSACUs), 1, -1 do
                    local oSACU = tSACUs[iSACU]
                    if bLeaveOneSACU then
                        bLeaveOneSACU = false
                    else
                        if not(iMaxDistanceToAssist) or M28Utilities.GetDistanceBetweenPositions(oSACU:GetPosition(), oSACUToAssist:GetPosition()) <= iMaxDistanceToAssist then
                            if bDebugMessages == true then LOG(sFunctionRef..': Telling oSACU='..oSACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSACU)..' to assist oSACUToAssist='..oSACUToAssist.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSACUToAssist)) end
                            M28Orders.IssueTrackedGuard(oSACU, oSACUToAssist, false, 'SACUUpgrAs', false)
                            table.remove(tSACUs, iSACU)
                        elseif bDebugMessages == true then LOG(sFunctionRef..': iMaxDistanceToAssist='..iMaxDistanceToAssist..'; are too far from oSACU='..oSACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSACU)..'; Dist between SACUs='..M28Utilities.GetDistanceBetweenPositions(oSACU:GetPosition(), oSACUToAssist:GetPosition()))
                        end
                    end
                end
            elseif M28Utilities.IsTableEmpty(tSACUsToUpgrade) == false then
                for iSACU, oSACU in tSACUsToUpgrade do
                    if bDebugMessages == true then LOG(sFunctionRef..': Will ugprade oSACU='..oSACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSACU)..' with upgrade '..(oSACU[M28ACU.reftPreferredUpgrades][1] or 'nil')..' unless special micro active, special micro='..tostring(oSACU[M28UnitInfo.refbSpecialMicroActive] or false)) end
                    if not(oSACU[M28UnitInfo.refbSpecialMicroActive]) then
                        M28Orders.IssueTrackedEnhancement(oSACU, oSACU[M28ACU.reftPreferredUpgrades][1], false, 'SACURasUpgr')
                        break
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tSACUs) then bProceed = false end
        end
        --M28Orders.IssueTrackedEnhancement(oACU, sUpgradeToGet, false, 'ACUUpg')
        local bWantExperimentalAnyway = false
        if (M28Team.tTeamData[iTeam][M28Team.refiLowestUnitCapAdjustmentLevel] or 5) <= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.5 and not(M28Conditions.HaveLowPower(iTeam)) then
            bWantExperimentalAnyway = true
        end
        if bDebugMessages == true then LOG(sFunctionRef..': About to consider if we want to get SMD or experimental due to restrictions on what can be built by engineers, bProceed='..tostring(bProceed)..'; Time since last wanted SACU for exp or engi='..(GetGameTimeSeconds() - math.max((tLZTeamData[M28Map.subrefiTimeLastWantSACUForExp] or 0), tLZTeamData[M28Map.subrefiTimeLastWantSACUForSMD] or 0))..'; bWantExperimentalAnyway='..tostring(bWantExperimentalAnyway)) end
        if bProceed and (bWantExperimentalAnyway or  ((tLZTeamData[M28Map.subrefiTimeLastWantSACUForExp] or tLZTeamData[M28Map.subrefiTimeLastWantSACUForSMD]) and GetGameTimeSeconds() - math.max((tLZTeamData[M28Map.subrefiTimeLastWantSACUForExp] or 0), tLZTeamData[M28Map.subrefiTimeLastWantSACUForSMD] or 0) <= math.max(5, (iTicksPerLandCycle-1)*0.1))) then
            local bBuildingSMD = false
            if tLZTeamData[M28Map.subrefiTimeLastWantSACUForSMD] and GetGameTimeSeconds() - tLZTeamData[M28Map.subrefiTimeLastWantSACUForSMD] <= math.max(5, (iTicksPerLandCycle-1)*0.1) and (M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] == 0 or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false) then
                local iSMDBPWanted, bAssistSMD, oSMDToShield, oShieldToAssist = M28Engineer.GetBPToAssignToSMD(iPlateau, iLandZone, iTeam, tLZTeamData, tLZTeamData[M28Map.subrefLZbCoreBase], M28Conditions.TeamHasLowMass(iTeam), M28Conditions.HaveLowPower(iTeam))
                if bDebugMessages == true then LOG(sFunctionRef..': Deciding if want to use RAS SACUs to build SMD, iSMDBPWanted='..iSMDBPWanted..'; bAssistSMD='..tostring(bAssistSMD)..'; oSMDToShield='..(oSMDToShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oSMDToShield) or 'nil')..'; oShieldToAssist='..(oShieldToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oShieldToAssist) or 'nil')) end
                if iSMDBPWanted > 0 and M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandOrWaterZone(tLZTeamData, M28UnitInfo.refCategorySMD, true) == 0 and not(bAssistSMD) and not(oSMDToShield) and not(oShieldToAssist) then
                    bBuildingSMD = true
                    BuildCategoryWithSACUs(M28UnitInfo.refCategorySMD, nil, nil, M28Engineer.refActionBuildSMD)
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bBuildingSMD='..tostring(bBuildingSMD)..'; Time since last wanted SMD='..GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeLastWantSACUForSMD] or 0)) end
            if not(bBuildingSMD) and (bWantExperimentalAnyway or tLZTeamData[M28Map.subrefiTimeLastWantSACUForExp] and GetGameTimeSeconds() - tLZTeamData[M28Map.subrefiTimeLastWantSACUForExp] <= math.max(5, (iTicksPerLandCycle-1)*0.1)) then
                --First check we have no experimental level units under construction in this zone
                if bDebugMessages == true then LOG(sFunctionRef..': Number of exp under construction in LZ='..M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandOrWaterZone(tLZTeamData, M28UnitInfo.refCategoryExperimentalLevel, true)) end
                if M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandOrWaterZone(tLZTeamData, M28UnitInfo.refCategoryExperimentalLevel, true) == 0 then
                    local tbEngineersOfFactionOrNilIfAlreadyAssigned = {}
                    local aiBrain
                    local toSACUByFaction = {}
                    local iCurFaction
                    for iSACU, oSACU in tSACUs do
                        iCurFaction = M28UnitInfo.GetUnitFaction(oSACU)
                        tbEngineersOfFactionOrNilIfAlreadyAssigned[iCurFaction] = true
                        if not(aiBrain) then aiBrain = oSACU:GetAIBrain() end
                        if not(toSACUByFaction[iCurFaction]) then toSACUByFaction[iCurFaction] = {} end
                        table.insert(toSACUByFaction[iCurFaction], oSACU)
                    end
                    local iCategoryWanted, iFactionWanted = M28Engineer.DecideOnExperimentalToBuild(M28Engineer.refActionBuildExperimental, aiBrain, tbEngineersOfFactionOrNilIfAlreadyAssigned, tLZData, tLZTeamData, iPlateau, iLandZone)
                    if bDebugMessages == true then LOG(sFunctionRef..': is iCategoryWanted nil='..tostring(iCategoryWanted == nil)..'; is iFactionWanted nil='..tostring(iFactionWanted == nil)) end
                    if iCategoryWanted then
                        if iCategoryWanted == M28Engineer.refActionManageGameEnderTemplate then
                            --Need to assign unit to GETemplate
                            bProceed = false
                            for iSACU, oSACU in tSACUs do
                                M28Engineer.AssignEngineerToGameEnderTemplate(oSACU, tLZData, tLZTeamData, iPlateau, iLandZone)
                            end
                        else
                            BuildCategoryWithSACUs(iCategoryWanted, iFactionWanted, toSACUByFaction, M28Engineer.refActionBuildExperimental)
                        end
                    end
                end
            end
        end
        --Consider sending 1 SACU to water zone if havent already sent one and this is a core base and we have multiple SACUs
        if bProceed and M28Utilities.IsTableEmpty(tSACUs) == false then
            local iCurSACUsAssignedToWaterZones = 0
            local iCurSACUsInLandZone = table.getn(tSACUs)
            local aiBrain = ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]]
            local iLandToWaterRatio = 10
            if aiBrain[M28Overseer.refbPrioritiseNavy] then iLandToWaterRatio = 0.5
            elseif not(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) then iLandToWaterRatio = 2
            end
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoSACUsTravelingToWaterZoneFromHere]) == false then iCurSACUsAssignedToWaterZones = table.getn(tLZTeamData[M28Map.subreftoSACUsTravelingToWaterZoneFromHere]) end
            if iCurSACUsInLandZone > iCurSACUsAssignedToWaterZones * iLandToWaterRatio then
                if aiBrain[M28Map.refbCanPathToEnemyBaseWithAmphibious] and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] >= 3 then
                    --Send SACUs if we are priorising navy, or if we need SACUs to build experimentals (i.e. QUIET or LOUD)
                    if aiBrain[M28Overseer.refbPrioritiseNavy] or ((M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) and not(tLZTeamData[M28Map.refbBaseInSafePosition]) and (not(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) or (M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= math.max(3, M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false))) then
                        --Do we have more than 1 SACU here?
                        if tLZTeamData[M28Map.subrefLZbCoreBase] and iCurSACUsInLandZone > 1 then
                            --Are weither a naval AI, or this is our 3rd+ SACU?
                            local bNavalOr3rdSACU = (aiBrain[M28Overseer.refbPrioritiseNavy] or iCurSACUsInLandZone >= 3)
                            if not(bNavalOr3rdSACU) then
                                for iSACU, oSACU in tSACUs do
                                    if M28UnitInfo.GetUnitLifetimeCount(oSACU) >= 3 then
                                        bNavalOr3rdSACU = true
                                        break
                                    end
                                end
                            end
                            if bNavalOr3rdSACU then
                                --Can we find a nearby high value water zone?
                                M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData)
                                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                                    local iMaxSearchRange = 150
                                    local iCurWaterZone
                                    if not(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) or aiBrain[M28Overseer.refbPrioritiseNavy] then iMaxSearchRange = 300 end
                                    local bAssignedSACU = false
                                    for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                                        if tSubtable[M28Map.subrefiDistance] > iMaxSearchRange then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Are outside the max range so wil stop searching') end
                                            break
                                        elseif tSubtable[M28Map.subrefbIsWaterZone] then
                                            iCurWaterZone = tSubtable[M28Map.subrefiLandOrWaterZoneRef]
                                            --Is this a high value pond, or a WZ that has recently tried getting exp
                                            local tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurWaterZone]][M28Map.subrefPondWaterZones][iCurWaterZone]
                                            local tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                                            if (M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iCurWaterZone]] or 0) >= 14 or (tAltLZOrWZTeamData[M28Map.subrefiTimeLastWantSACUForExp] and GetGameTimeSeconds() - tAltLZOrWZTeamData[M28Map.subrefiTimeLastWantSACUForExp] <= 11) then
                                                if M28Utilities.IsTableEmpty(tAltLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                                    --Have a high value water zone with friendly units in it, if we have a navla factory here that has built something, then send an SACU
                                                    for iUnit, oUnit in tAltLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do
                                                        if (oUnit[M28Factory.refiTotalBuildCount] or 0) >= 1 then
                                                            --Send 1 SACU here
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Will send SACU '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to go to WZ='..iCurWaterZone) end
                                                            tSACUs[1][M28UnitInfo.refiSACUWaterZoneTarget] = iCurWaterZone
                                                            table.remove(tSACUs, 1)
                                                            if M28Utilities.IsTableEmpty(tSACUs) then bProceed = false end
                                                            bAssignedSACU = true
                                                            break
                                                        end
                                                    end
                                                    if bAssignedSACU then break end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            elseif iCurSACUsAssignedToWaterZones > 0then
                for iCurEntry = table.getn(tLZTeamData[M28Map.subreftoSACUsTravelingToWaterZoneFromHere]), 1, -1 do
                    local oTravelingSACU = tLZTeamData[M28Map.subreftoSACUsTravelingToWaterZoneFromHere][iCurEntry]
                    if not(oTravelingSACU[M28UnitInfo.refiSACUWaterZoneTarget]) then
                        table.remove(tLZTeamData[M28Map.subreftoSACUsTravelingToWaterZoneFromHere], iCurEntry)
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we should proceed with considering assigning SACUs to GE template, bProceed='..tostring(bProceed)..'; Is table of active GE templates for this zone empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates]))) end
        if bProceed and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates]) == false then
            for iTemplate, tSubtable in tLZTeamData[M28Map.reftActiveGameEnderTemplates] do
                if not(tSubtable[M28Map.subrefGEbDontNeedEngineers]) then
                    for iSACU, oSACU in tSACUs do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering SACU assignment to GE template, oSACU='..oSACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSACU)..'; oSACU[M28Building.reftArtiTemplateRefs]='..repru(oSACU[M28Building.reftArtiTemplateRefs])..'; oSACU[M28UnitInfo.refbSpecialMicroActive]='..tostring(oSACU[M28UnitInfo.refbSpecialMicroActive] or false)) end
                        if M28Utilities.IsTableEmpty(oSACU[M28Building.reftArtiTemplateRefs]) then
                            if not(oSACU[M28UnitInfo.refbSpecialMicroActive]) then
                                M28Engineer.AssignEngineerToGameEnderTemplate(oSACU, tLZData, tLZTeamData, iPlateau, iLandZone)
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': RAS SACUs are assigned to gameender duty for iTemplate ref='..iTemplate) end
                    bProceed = false
                    break
                end
            end
        end
    else
        bProceed = false
        --All SACUs are assigned to GE template/we have none
    end
    if bDebugMessages == true then LOG(sFunctionRef..': FInished going through if want to help active GE template, bProceed='..tostring(bProceed)) end
    if bProceed then
        --Defending against arti - if have a gameender then first consider if have part-complete shield that want to construct
        local oShieldToAssist
        local oPartCompleteGameEnderToAssist
        if bDebugMessages == true then LOG(sFunctionRef..': Is reftoUnitsForSpecialShieldProtection empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]))..'; refbDefendAgainstArti='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or false)) end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) == false and M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] then
            local tGameEndersForShielding = EntityCategoryFilterDown(M28UnitInfo.refCategoryGameEnder, tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection])
            if bDebugMessages == true then LOG(sFunctionRef..': Is tGameEndersForShielding empty='..tostring(M28Utilities.IsTableEmpty(tGameEndersForShielding))) end
            if M28Utilities.IsTableEmpty(tGameEndersForShielding) == false then
                local oGameEnderToCover
                local iHighestCompletionGameEnder = 0.3
                for iGameEnder, oGameEnder in tGameEndersForShielding do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oGameEnder='..oGameEnder.UnitId..M28UnitInfo.GetUnitLifetimeCount(oGameEnder)..'; is reftoSpecialAssignedShields empty='..tostring(M28Utilities.IsTableEmpty(oGameEnder[M28Building.reftoSpecialAssignedShields]))) end
                    if not(oGameEnderToCover) and M28Utilities.IsTableEmpty(oGameEnder[M28Building.reftoSpecialAssignedShields]) == false then
                        oGameEnderToCover = oGameEnder
                    end
                    if not(oGameEnder.Dead) and oGameEnder:GetFractionComplete() < 1 and oGameEnder:GetFractionComplete() > iHighestCompletionGameEnder then
                        iHighestCompletionGameEnder = oGameEnder:GetFractionComplete()
                        oPartCompleteGameEnderToAssist = oGameEnder
                    end
                end

                if oGameEnderToCover then
                    --How much shielding do we have
                    local iNearestCompleteShield = 0
                    local oNearestCompleteShield
                    local iActiveShields = 0
                    local iCurShield, iMaxShield
                    for iShield, oShield in oGameEnderToCover[M28Building.reftoSpecialAssignedShields] do
                        if oShield:GetFractionComplete() < 1 and oShield:GetFractionComplete() > iNearestCompleteShield then
                            iNearestCompleteShield = oShield:GetFractionComplete()
                            oNearestCompleteShield = oShield
                        else
                            iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                            if iCurShield > 0 then iActiveShields = iActiveShields + 1 end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iActiveShields='..iActiveShields..'; iNearestCompleteShield='..iNearestCompleteShield) end
                    if iActiveShields > 1 or (iActiveShields == 1 and iNearestCompleteShield >= 0.75) then
                        --Do nothing
                    else
                        oShieldToAssist = oNearestCompleteShield
                    end
                end
            end

        end

        --Defending against arti - if have T3 arti or gameender then want to assist the shield with RAS SACUs (in addition to any engineers that are assisting it)
        local oPriorityUnitToRepairInsteadOfAssistingShield
        if not(oShieldToAssist) then
            local tPriorityUnitsToShield
            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with zone '..iLandZone..'; at time '..GetGameTimeSeconds()..'; DefendAgainstArti='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti])) end
            if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] and (M28Team.tTeamData[iTeam][M28Team.refiEnemyT3ArtiCount] > 0 or M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] >= 2) then
                local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                if aiBrain.GetUnitsAroundPoint then
                    tPriorityUnitsToShield = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryGameEnder, tLZData[M28Map.subrefMidpoint], 250, 'Ally')
                    if bDebugMessages == true then LOG(sFunctionRef..': Is tPriorityUnitsToShield empty='..tostring(M28Utilities.IsTableEmpty(tPriorityUnitsToShield))) end
                    if M28Utilities.IsTableEmpty(tPriorityUnitsToShield) then
                        tPriorityUnitsToShield = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedT3Arti, tLZData[M28Map.subrefMidpoint], 150, 'Ally')
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of priority units to shield empty='..tostring(M28Utilities.IsTableEmpty(tPriorityUnitsToShield))) end
            if M28Utilities.IsTableEmpty(tPriorityUnitsToShield) == false then
                --Get closest of these that has a shield that is damaged
                local iCurDist
                local iClosestDist = 100000
                local iCurShield, iMaxShield
                local bAssistEvenIfNotDamaged = true
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.4 then bAssistEvenIfNotDamaged = false end
                for iUnit, oUnit in tPriorityUnitsToShield do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering priority unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction compelte='..oUnit:GetFractionComplete()..'; Does it have a shield providing coverage='..tostring(M28UnitInfo.IsUnitValid(oUnit[M28Building.refoPriorityShieldProvidingCoverage]))) end
                    if not(oUnit.Dead) and oUnit:GetFractionComplete() >= 0.35 then
                        if M28UnitInfo.IsUnitValid(oUnit[M28Building.refoPriorityShieldProvidingCoverage]) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit[M28Building.refoPriorityShieldProvidingCoverage]:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': Shield='..oUnit[M28Building.refoPriorityShieldProvidingCoverage].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28Building.refoPriorityShieldProvidingCoverage])..'; iCurDist='..iCurDist..'; iCloestDist='..iClosestDist) end
                            if iCurDist < iClosestDist then
                                --Is the shield still active?
                                iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit[M28Building.refoPriorityShieldProvidingCoverage], true)
                                if bDebugMessages == true then LOG(sFunctionRef..': iCurShield='..iCurShield) end
                                if (iCurShield > 0 and (bAssistEvenIfNotDamaged or iCurShield < iMaxShield or GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeLastDamaged] or - 100) <= 25)) or (oUnit[M28Building.refoPriorityShieldProvidingCoverage]:GetFractionComplete() < 1 and (not(oUnit[M28Engineer.refbDontIncludeAsPartCompleteBuildingForConstruction]) or oUnit[M28Building.refoPriorityShieldProvidingCoverage]:GetFractionComplete() <= 0.75)) then
                                    iClosestDist = iCurDist
                                    oShieldToAssist = oUnit[M28Building.refoPriorityShieldProvidingCoverage]
                                    if iCurShield == iMaxShield and oUnit:GetFractionComplete() < 1 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeLastDamaged] or - 100) >= 20 then
                                        oPriorityUnitToRepairInsteadOfAssistingShield = oUnit
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': oShieldToAssist='..(oShieldToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oShieldToAssist) or 'nil')) end
        if oPriorityUnitToRepairInsteadOfAssistingShield then
            for iUnit, oUnit in tSACUs do
                M28Orders.IssueTrackedRepair(oUnit, oPriorityUnitToRepairInsteadOfAssistingShield, false, 'RASRRep', false)
            end
        elseif oShieldToAssist then
            if bDebugMessages == true then LOG(sFunctionRef..': Have priority shield to assist') end
            if oShieldToAssist:GetFractionComplete() == 1 then
                for iUnit, oUnit in tSACUs do
                    M28Orders.IssueTrackedGuard(oUnit, oShieldToAssist, false, 'RASAGS', false)
                end
            else
                for iUnit, oUnit in tSACUs do
                    M28Orders.IssueTrackedRepair(oUnit, oShieldToAssist, false, 'RASRS', false)
                end
            end
        else
            local tUnitsToAssist = {}
            --If overflowing mass then search for under construction experimentals in the zone
            local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)
            if not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.65 then
                --If have under construction experimental in this zone then assist it
                local tExpInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryExperimentalLevel, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if M28Utilities.IsTableEmpty(tExpInZone) == false then
                    for iExp, oExp in tExpInZone do
                        if oExp:GetFractionComplete() < 1 then
                            table.insert(tUnitsToAssist, oExp)
                        end
                    end
                end
            end
            if oPartCompleteGameEnderToAssist and not(bHaveLowPower) and M28Utilities.IsTableEmpty(tUnitsToAssist) then
                table.insert(tUnitsToAssist, oPartCompleteGameEnderToAssist)
            end

            --If we have a bunch of SACUs and have a game-ender to assist then focus on this instead of more SACUs
            local oGateway
            local bNotAssistingGateway = true
            local bHaveRASGateway = false
            if oPartCompleteGameEnderToAssist and M28Utilities.IsTableEmpty(tUnitsToAssist) == false and (oPartCompleteGameEnderToAssist:GetFractionComplete() >= 0.45 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 200 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 80 and table.getn(tSACUs) >= 4 + M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] * 2)) then
                --Dont consider assisting gateway
                if bDebugMessages == true then LOG(sFunctionRef..': Will prioririse assisting gameender instead of getting more SACUs') end
            else

                --If have mass stored then find the nearest quantum gatway and assist it for now, otherwise do nothing (if enemies in this LZ then will have been sent to the combat unit management already)
                --(dont do this in LOUD unless near unit cap since wont be getting RAS SACUs)
                if not(M28Utilities.bLoudModActive) or M28Team.tTeamData[iTeam][M28Team.refiLowestUnitCapAdjustmentLevel] <= 1 then
                    local tQuantumGateways = EntityCategoryFilterDown(M28UnitInfo.refCategoryQuantumGateway, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of quantum gateways empty='..tostring(M28Utilities.IsTableEmpty( tQuantumGateways))) end
                    if M28Utilities.IsTableEmpty( tQuantumGateways) == false then
                        for iUnit, oUnit in tQuantumGateways do
                            oGateway = oUnit
                            if not(EntityCategoryContains(categories.SERAPHIM, oUnit.UnitId)) then
                                bHaveRASGateway = true
                                break
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': oGateway='..(oGateway.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oGateway))..'; bHaveRASGateway='..tostring(bHaveRASGateway)) end
            if oGateway then
                if not(bHaveRASGateway) then
                    --Do we have a T3+ 'other' factory type on the team, for a non-sera faction?
                    local iLandSubteam = oGateway:GetAIBrain().M28LandSubteam
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of other faction types empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeOther]))..'; Reprs of this='..reprs(M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeOther])) end
                    if M28Utilities.IsTableEmpty(M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeOther]) == false then
                        local bHaveNonSeraFactory = false
                        for iFaction, tSubtable in M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeOther] do
                            if not(iFaction == M28UnitInfo.refFactionSeraphim) and (tSubtable[3] or 0) > 0 then
                                bHaveNonSeraFactory = true
                                break
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished searching other factory types, bHaveNonSeraFactory='..tostring(bHaveNonSeraFactory or false)) end
                        if bHaveNonSeraFactory then
                            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                            if aiBrain.GetUnitsAroundPoint then
                                local tNearbyFriendlyGateway = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryQuantumGateway - categories.SERAPHIM, tLZData[M28Map.subrefMidpoint], 250, 'Ally')
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby non sera quantum gateways empty='..tostring(M28Utilities.IsTableEmpty(tNearbyFriendlyGateway))) end
                                if M28Utilities.IsTableEmpty(tNearbyFriendlyGateway) == false then
                                    for iUnit, oUnit in tNearbyFriendlyGateway do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering quantum gateway oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Terrain label='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oUnit:GetPosition()) or 'nil')..'; iPlateau='..(iPlateau or 'nil')) end
                                        if oUnit:GetAIBrain().M28AI and NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oUnit:GetPosition()) == iPlateau then
                                            --Check factory is building something
                                            if oUnit:GetWorkProgress() > 0 or not(oUnit[M28Factory.refiTimeSinceLastFailedToGetOrder]) or GetGameTimeSeconds() - oUnit[M28Factory.refiTimeSinceLastFailedToGetOrder] >= 20 then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have a non sera gateway to assist instead, oGateway='..oGateway.UnitId..M28UnitInfo.GetUnitLifetimeCount(oGateway)) end
                                                oGateway = oUnit
                                                break
                                            elseif bDebugMessages == true then LOG(sFunctionRef..': Gateway appears idle so will keep searching')
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                if (M28Map.bIsCampaignMap or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.05) and not(M28Conditions.HaveLowPower(iTeam)) and ((M28Map.bIsCampaignMap and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 80 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) or (not(M28Map.bIsCampaignMap) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < math.min(100, 40 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]))) then
                    if (M28Map.bIsCampaignMap or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 100) and oGateway:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryRASSACU) < 50 then
                        bNotAssistingGateway = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Will get every SACU to assist the gateway') end
                        table.insert(tUnitsToAssist, oGateway)
                        --[[for iUnit, oUnit in tSACUs do
                            M28Orders.IssueTrackedGuard(oUnit, oGateway, false, 'RASQG', false)
                        end--]]
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': oGateway='..(oGateway.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oGateway) or 'nil')..'; bNotAssistingGateway='..tostring(bNotAssistingGateway)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Have low power='..tostring(M28Conditions.HaveLowPower(iTeam))) end
            if bNotAssistingGateway then
                --If low power and have under construction pgen then assist this
                if bDebugMessages == true then LOG(sFunctionRef..': Does team have low mass='..tostring(M28Conditions.TeamHasLowMass(iTeam))..'; Is table of engineers building experimentals empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]))..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Time since close to unit cap='..(GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] or 0))) end
                if bHaveLowPower then
                    local tPowerInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryPower * categories.TECH3, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tPowerInZone) == false then
                        for iPgen, oPgen in tPowerInZone do
                            if oPgen:GetFractionComplete() < 1 then
                                table.insert(tUnitsToAssist, oPgen)
                            end
                        end
                    end
                end
                --If building an experimental and dont have low mass then assist it
                if M28Utilities.IsTableEmpty(tUnitsToAssist) and (not(M28Conditions.TeamHasLowMass(iTeam)) or (GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] or 0) <= 60)) and not(bHaveLowPower) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]) == false then

                    local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                    if aiBrain.GetUnitsAroundPoint then
                        local tExperimentalLevelUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryExperimentalLevel, tLZData[M28Map.subrefMidpoint], 100, 'Ally')
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of experimental level units empty='..tostring(M28Utilities.IsTableEmpty( tExperimentalLevelUnits))) end
                        if M28Utilities.IsTableEmpty( tExperimentalLevelUnits) == false then
                            for iUnit, oUnit in tExperimentalLevelUnits do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering nearby experimental '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()) end
                                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() < 1 then
                                    table.insert(tUnitsToAssist, oUnit)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Adding unit to table of units to assist') end
                                end
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Do we have any units to assist? is table empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToAssist))) end
                if M28Utilities.IsTableEmpty(tUnitsToAssist) then
                    --If have upgrading unit then assist this
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of active upgrades empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoActiveUpgrades]))) end
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoActiveUpgrades]) == false then tUnitsToAssist = tLZTeamData[M28Map.subreftoActiveUpgrades]
                    else
                        --Assist shield if need to defend from arti
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of priority shields to assist empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]))..'; Defending against arti='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti])) end
                        if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]) == false and (M28Team.tTeamData[iTeam][M28Team.refiEnemyT3ArtiCount] > 0 or M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] >= 2) then
                            tUnitsToAssist = tLZTeamData[M28Map.reftPriorityShieldsToAssist]
                        else
                            --otherwise assist an air factory if we have one
                            tUnitsToAssist = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                            if bDebugMessages == true then LOG(sFunctionRef..': Setting unit to assist to be an air factory, is tUnitsToAssist empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToAssist))) end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished saerching for potential units to assist, is table empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToAssist))) end
            if M28Utilities.IsTableEmpty(tUnitsToAssist) == false then
                local tStartPoint
                if oGateway then tStartPoint = oGateway:GetPosition()
                elseif M28UnitInfo.IsUnitValid(tSACUs[1]) then tStartPoint = tSACUs[1]:GetPosition()
                else tStartPoint = tLZData[M28Map.subrefMidpoint] --redundancy
                end
                local oClosestUnitToAssist = M28Utilities.GetNearestUnit(tUnitsToAssist, tStartPoint)
                if bDebugMessages == true then LOG(sFunctionRef..': oClosestUnitToAssist='..(oClosestUnitToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestUnitToAssist) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oClosestUnitToAssist))) end
                if not(M28UnitInfo.IsUnitValid(oClosestUnitToAssist)) then M28Utilities.ErrorHandler('No unit to assist for RAS', true)
                else
                    for iUnit, oUnit in tSACUs do
                        M28Orders.IssueTrackedGuard(oUnit, oClosestUnitToAssist, false, 'RASAs', false)
                        if bDebugMessages == true then LOG(sFunctionRef..': Telling RAS '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to assist unit') end
                    end
                end

            else
                --Othewrise clear orders if nothing to assist
                for iUnit, oUnit in tSACUs do
                    if not(oUnit[M28UnitInfo.refbSpecialMicroActive]) and not(oUnit:IsUnitState('Moving')) and (oUnit:IsUnitState('Repairing') or oUnit:IsUnitState('Building') or oUnit:IsUnitState('Guarding')) then
                        M28Orders.IssueTrackedClearCommands(oUnit)
                    end
                end
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetNearestEnemyInOtherPlateau(iPlateau, tLZData, iTeam, bGetIndirectThreatInstead)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNearestEnemyInOtherPlateau'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData) --redundancy
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
        local iClosestEnemyDist = 10000
        local oClosestEnemy
        local iCurDist
        local iEnemyIFThreat = 0
        local iEnemyBestRange = 0
        for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateauOrPond='..tSubtable[M28Map.subrefiPlateauOrPond]..'; Is water zone='..tostring(tSubtable[M28Map.subrefbIsWaterZone])..'; Distance='..tSubtable[M28Map.subrefiDistance]..'; iEntry='..iEntry) end
            if tSubtable[M28Map.subrefiDistance] >= 170 and (iEntry >= 7 or tSubtable[M28Map.subrefiDistance] >= 320 or (bGetIndirectThreatInstead and tSubtable[M28Map.subrefiDistance] >= 200)) then break end
            if not(iPlateau == tSubtable[M28Map.subrefiPlateauOrPond]) and not(tSubtable[M28Map.subrefbIsWaterZone]) then --water zones dont track indirect fire threat, and in any event battleships and cruisers outrange t2 arti and mobile t3 arti (which is what this might be used for)
                --Have a nearby land zone in a different plateau, check if there are enemy units in this LZ and (if so) if any of them are structures
                local tAdjLZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                if not(tAdjLZData[M28Map.subrefbPacifistArea]) then
                    local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]))) end
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                        if bGetIndirectThreatInstead then
                            iEnemyIFThreat = iEnemyIFThreat + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] or 0) + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)
                            iEnemyBestRange = math.max(iEnemyBestRange, (tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0))
                        else
                            for iUnit, oUnit in tAdjLZTeamData[M28Map.subrefTEnemyUnits] do
                                if M28UnitInfo.IsUnitValid(oUnit) then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit:GetPosition())
                                    if iCurDist <= iClosestEnemyDist then
                                        oClosestEnemy = oUnit
                                        iClosestEnemyDist = iCurDist
                                        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..iCurDist..'; this is the closest unit for now, will cycle through any remaining') end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for enemy units in nearby different plateau, oClosestEnemy='..(oClosestEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestEnemy) or 'nli')..'; iEnemyIFThreat='..iEnemyIFThreat..'; bGetIndirectThreatInstead='..tostring(bGetIndirectThreatInstead or false)) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        if bGetIndirectThreatInstead then return iEnemyIFThreat, iEnemyBestRange
        else
            return oClosestEnemy
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function BackupUnitTowardsRallyIfAvailable(oUnit, tRallyPoint, iIslandPlateauOrPondRef, sOrderDesc, bAmphibiousAndUsingPlateauRef, iDefaultDistOverride, iMaxAngleDifForMovingBackwardsOverride, bUsingPondRef)
    --iDefaultDistOverride - if specified, then doesnt require a backup dist to move back, and will use this if no backup dist is available
    --iMaxAngleDifForMovingBackwardsOverride - Overrides the maximum angle difference allowed to move backwards in a straight line for the unit instead of moving to tRallyPoint; if this is exceeded, then will try and move to the rally point instead

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'BackupUnitTowardsRallyIfAvailable'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28UnitInfo.IsUnitValid(oUnit) then
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit position='..repru(oUnit:GetPosition())..'; tRallyPoint='..repru(tRallyPoint)..'; iIslandPlateauOrPondRef='..iIslandPlateauOrPondRef..'; sOrderDesc='..sOrderDesc..'; bAmphibiousAndUsingPlateauRef='..tostring(bAmphibiousAndUsingPlateauRef)..'; iDefaultDistOverride='..(iDefaultDistOverride or 'nil')..'; iMaxAngleDifForMovingBackwardsOverride='..(iMaxAngleDifForMovingBackwardsOverride or 'nil')..'; Dist to the rally point/position to move='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint)..'; Time='..GetGameTimeSeconds()) end
        local iBackupDist = 0
        local iMaxAngleDifference = iMaxAngleDifForMovingBackwardsOverride or 35
        local bValidTowardsLocation = false
        if oUnit[M28UnitInfo.refbCanKite] then
            iBackupDist = (oUnit:GetBlueprint().Physics.BackUpDistance or 0)
        end

        if iBackupDist >= 6 or iDefaultDistOverride then


            local iDistToMove
            if iDefaultDistOverride and iBackupDist >= 3 then iDistToMove = math.min(iBackupDist - 1, iDefaultDistOverride)
            elseif not(iDefaultDistOverride) then
                iDistToMove = math.min(iBackupDist - 1, 20)
                if iBackupDist >= 12 and iBackupDist < 20 then iDistToMove = iDistToMove - 1.5 end
            else iDistToMove = iDefaultDistOverride
            end
            local iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)
            local iCurUnitFacingDirection = M28UnitInfo.GetUnitFacingAngle(oUnit)
            local iMoveBackwardsAngle = iCurUnitFacingDirection - 180
            if iMoveBackwardsAngle < 0 then iMoveBackwardsAngle = iMoveBackwardsAngle + 360 end
            local tPotentialMoveLocation
            local iAngleDif = M28Utilities.GetAngleDifference(iAngleToRally, iMoveBackwardsAngle)
            local iAngleActuallyMoving

            if bDebugMessages == true then LOG(sFunctionRef..': Checking whether to move directly backwards, iAngleToRally='..iAngleToRally..'; iMoveBackwardsAngle='..iMoveBackwardsAngle..'; iAngleDif='..iAngleDif..'; iMaxAngleDifference='..iMaxAngleDifference..' Approx Speed (X and Z velocity times 10) = '..M28UnitInfo.GetUnitSpeed(oUnit)) end
            function CheckIfValidLocation()
                if bAmphibiousAndUsingPlateauRef then
                    if NavUtils.GetLabel(M28Map.refPathingTypeHover, tPotentialMoveLocation) == iIslandPlateauOrPondRef then
                        bValidTowardsLocation = true
                    end
                elseif not(bUsingPondRef) then
                    if NavUtils.GetLabel(M28Map.refPathingTypeLand, tPotentialMoveLocation) == iIslandPlateauOrPondRef then
                        bValidTowardsLocation = true
                    end
                else
                    if NavUtils.GetLabel(M28Map.refPathingTypeNavy, tPotentialMoveLocation) == iIslandPlateauOrPondRef then
                        bValidTowardsLocation = true
                    end
                end
            end
            if iAngleDif >= 3 and iAngleDif <= iMaxAngleDifference then
                local iMaxAngleAdjust = math.min(iAngleDif, 5)
                if iMoveBackwardsAngle > iAngleToRally then iMaxAngleAdjust = -iMaxAngleAdjust end
                iAngleActuallyMoving = iMoveBackwardsAngle + iMaxAngleAdjust
                tPotentialMoveLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(),iAngleActuallyMoving, iDistToMove, true, false)
                CheckIfValidLocation()

            end
            --else
            if not(bValidTowardsLocation) then
                tPotentialMoveLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToRally, iDistToMove, true, false)
                CheckIfValidLocation()
                iAngleActuallyMoving = iAngleToRally
            end
            if tPotentialMoveLocation and bValidTowardsLocation then
                --If arent already moving in this direction then stop for 1 tick, as backing up doesnt work properly otherwise
                local tLastOrder = oUnit[M28Orders.reftiLastOrders][1]
                if bDebugMessages == true then LOG(sFunctionRef..': iAngleToRally='..iAngleToRally..'; iDistToMove='..iDistToMove..'; bValidTowardsLocation='..tostring(bValidTowardsLocation or false)..'; Unit state='..M28UnitInfo.GetUnitState(oUnit))
                    if tLastOrder and tLastOrder[M28Orders.subreftOrderPosition] then LOG(sFunctionRef..': Angle dif between destination and last move order='..M28Utilities.GetAngleDifference(iAngleActuallyMoving, M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLastOrder[M28Orders.subreftOrderPosition]))) end
                end
                local bStopFirst = false
                if (tLastOrder and not(tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueMove)) then
                    bStopFirst = true

                elseif tLastOrder[M28Orders.subreftOrderPosition] then
                    local iAngleDif = M28Utilities.GetAngleDifference(iAngleActuallyMoving, M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLastOrder[M28Orders.subreftOrderPosition]))
                    if iAngleDif > 15 then
                        bStopFirst = true
                    end
                end
                local iUnitSpeed = M28UnitInfo.GetUnitSpeed(oUnit)
                if bStopFirst then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will clear unit orders and wait a bit until unit is going slow enough, unit approx speed='..M28UnitInfo.GetUnitSpeed(oUnit)) end
                    local iTotalTimeWaited = 0
                    M28Orders.IssueTrackedClearCommands(oUnit)
                    while M28UnitInfo.IsUnitValid(oUnit) and iUnitSpeed >= 0.75 and iTotalTimeWaited <= 9 do
                        if iTotalTimeWaited == 0 then
                            M28Orders.UpdateUnitNameForOrder(oUnit, 'Slow4Rev')
                        end
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        iTotalTimeWaited = iTotalTimeWaited + 1
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        if bDebugMessages == true then LOG(sFunctionRef..': Speed after waiting 1 tick='..M28UnitInfo.GetUnitSpeed(oUnit)..'; iTotalTimeWaited in ticks='..iTotalTimeWaited) end
                    end
                    if not(M28UnitInfo.IsUnitValid(oUnit)) then M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd) return nil end


                    --Ticks to wait:
                    --With no 'move 5 degrees towards rally' logic: 3 tick delay meant this only worked sometimes, and failed in one case with a fatboy; 4-7 tick delay failed initially when fatboy was moving forwards but didn't have issues after that, 8 ticks worked more reliably; velocity when 8 ticks worked: X-0.10995483398438 Y0 Z0.13614654541016; with 5 degree logic also still neededed to wait 8 ticks instead of 4 to move backwards
                    --With 5 degree logic, when velocity slowed to iTotalVelocity=0.073184967041016 was no need to wait any ticks to move ackwards
                    --Therefore will try waiting 1 tick until speed is sub-1 (speed being total velocity * 10); when did this, with a speed threshold of 1, it failed with fatboy; speed of 0.73837280273438 was ok

                end
                if bDebugMessages == true then LOG(sFunctionRef..': tPotentialMoveLocation='..repru(tPotentialMoveLocation)..'; Unit position='..repru(oUnit:GetPosition())..'; iDistToMove='..(iDistToMove or 'nil')..'; Dist to potential move location='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tPotentialMoveLocation)..'; bStopFirst='..tostring(bStopFirst)..'; iUnitSpeed='..iUnitSpeed) end
                M28Orders.IssueTrackedMove(oUnit, tPotentialMoveLocation, math.min(iDistToMove * 0.2, 5), false, sOrderDesc..'T', false)
                --Check if we are being blocked - decided to leave out in the end as not convinced it was actually helping significantly (ignore for water)
                if iDistToMove > 2 and iTicksPerLandCycle <= 15 and M28Map.GetLandZoneFromPosition(oUnit:GetPosition()) then
                    local tViaPoint = M28Utilities.MoveInDirection(oUnit:GetPosition(),iAngleActuallyMoving, 0.5)
                    if tViaPoint then
                        local rRectToSearch = M28Utilities.GetRectAroundLocation(tViaPoint, 0.5)
                        local tBlockingUnits = M28Utilities.GetUnitsInRect(rRectToSearch)
                        if M28Utilities.IsTableEmpty(tBlockingUnits) == false then
                            local iTeam = oUnit:GetAIBrain().M28Team
                            local iMassThreshold = oUnit[M28UnitInfo.refiUnitMassCost] * 3
                            local tBlockingViaPoint
                            for iBlockingUnit, oBlockingUnit in tBlockingUnits do
                                if not(oBlockingUnit == oUnit) and M28UnitInfo.IsUnitValid(oBlockingUnit) and (oBlockingUnit[M28UnitInfo.refiUnitMassCost] or iMassThreshold) < iMassThreshold and not(oBlockingUnit[M28UnitInfo.refbSpecialMicroActive]) then
                                    local oBrain = oBlockingUnit:GetAIBrain()
                                    if oBrain.M28AI and oBrain.M28Team == iTeam then
                                        --Move this unit the same direction
                                        if not(tBlockingViaPoint) then
                                            tBlockingViaPoint = M28Utilities.MoveInDirection(oBlockingUnit:GetPosition(),iAngleActuallyMoving, iDistToMove + 1)
                                        end
                                        M28Orders.IssueTrackedMove(oBlockingUnit, tBlockingViaPoint, 1, false, sOrderDesc..'Bl', false)
                                        M28Micro.TrackTemporaryUnitMicro(oBlockingUnit, 0.5, nil, true)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will also retreat blocking unit '..oBlockingUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBlockingUnit)) end
                                    end
                                end
                            end
                        end
                    end
                end
                if iUnitSpeed * iTicksPerLandCycle * 0.1 > iDistToMove * 0.75 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to issue an interim move order after the first, will first wait '..math.ceil(iTicksPerLandCycle * 0.5)..' ticks') end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(math.ceil(iTicksPerLandCycle * 0.5))
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting, will issue interim order now for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        BackupUnitTowardsRallyIfAvailable(oUnit, tRallyPoint, iIslandPlateauOrPondRef, sOrderDesc, bAmphibiousAndUsingPlateauRef, iDefaultDistOverride, iMaxAngleDifForMovingBackwardsOverride, bUsingPondRef)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    end
                end
            end
        end
        if not(bValidTowardsLocation) then
            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 5, false, sOrderDesc..'R', false)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageCombatUnitsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableCombatUnits, iFriendlyBestMobileDFRange, iFriendlyBestMobileIndirectRange, bWantIndirectReinforcements, tUnavailableUnitsInThisLZ, bDelayOrdersForHover, bHaveCombatUnitsFromAdjZone)
    --Handles logic for main combat units (direct and indirect fire mobile units) that are noted as available to the land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageCombatUnitsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then
        LOG(sFunctionRef..': start of code, iTeam='..iTeam..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Is table of available combat units empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))..'; iFriendlyBestMobileDFRange='..iFriendlyBestMobileDFRange..'; iFriendlyBestMobileIndirectRange='..iFriendlyBestMobileIndirectRange..'; Are there enemy units in this or adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; bWantIndirectReinforcements='..tostring(bWantIndirectReinforcements or false)..'; tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]='..tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]..'; subrefLZThreatAllyMobileIndirectByRange='..repru(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange])..'; subrefLZThreatAllyMobileDFByRange='..repru(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange])..'; Enemy mobile DF='..repru(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange])..'; Threat of tAvailableCombatUnits='..M28UnitInfo.GetCombatThreatRating(tAvailableCombatUnits, false, false, false)..'; subrefiAvailableMobileShieldThreat='..(tLZTeamData[M28Map.subrefiAvailableMobileShieldThreat] or 0)..'; LZ value='..tLZTeamData[M28Map.subrefLZTValue]..'; refiModDistancePercent='..tLZTeamData[M28Map.refiModDistancePercent]..'; Time='..GetGameTimeSeconds())
        for iUnit, oUnit in tAvailableCombatUnits do
            LOG(sFunctionRef..': Threat of unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'='..M28UnitInfo.GetCombatThreatRating({ oUnit }, false, false, false))
        end
    end

    function ProceedWithUnitOrder(oUnit, bWeOutrangeEnemy)
        if bDelayOrdersForHover and EntityCategoryContains(categories.HOVER, oUnit.UnitId) then
            if bWeOutrangeEnemy then
                if GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastHoverLandCombatOrder] or -10) <= 6 then
                    return false
                end
            else
                if GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastHoverLandCombatOrder] or -10) <= 8 then
                    return false
                end
            end
            oUnit[M28UnitInfo.refiTimeOfLastHoverLandCombatOrder] = GetGameTimeSeconds()
        end
        return true
    end
    local iCurTime = math.floor(GetGameTimeSeconds())
    function IgnoreOrderDueToStuckUnit(oUnit)
        if oUnit[M28UnitInfo.refbUnitStuckAlternating] then
            if (not(oUnit[M28UnitInfo.refbEasyBrain]) or EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnit.UnitId)) and oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition] and M28Utilities.GetDistanceBetweenPositions(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition], oUnit:GetPosition()) >= 15 then
                if oUnit[M28Orders.reftiLastOrders][1][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueGroundAttack then
                    --We wont reach destination with a ground attack so need new orders
                    return false
                else
                    --Do nothing - want unit to reach its destination before it gets new orders
                    if bDebugMessages == true then LOG(sFunctionRef..': Unit is stuck so will ignore orders') end
                    return true
                end
            end
        end
    end

    local bWantReinforcements = false
    local bIgnoreEnemiesInThisZone = false
    local tbAdjacentZoneEnemiesToIgnoreByZone = {}
    local bConsiderEnemiesInAtLeastOneAdjacentZone = true
    local tUnitsNearFatboyInFurtherAwayZones

    --First record the range of enemy units, and which units in adjacent zones are nearest to us:
    UpdateBestEnemyRangesForThisLandZone(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    local iEnemyBestMobileDFRange, iEnemyBestStructureDFRange, iEnemyBestMobileIndirectRange = RecordClosestAdjacentEnemiesAndGetBestEnemyRange(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2) --Get a LZ up to 3 land zones away to retreat to (i.e. will pick rally point and then move 2 towards it)
    local tAmphibiousRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2, true)
    local iAngleTowardsBase = M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase])
    local iDistTowardsBase = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase])
    local tMoveTowardsBaseRetreatPoint = M28Utilities.MoveInDirection(tLZData[M28Map.subrefMidpoint], iAngleTowardsBase, math.min(50, iDistTowardsBase), true, false, M28Map.bIsCampaignMap)
    if bDebugMessages == true then LOG(sFunctionRef..': tMoveTowardsBaseRetreatPoint='..repru(tMoveTowardsBaseRetreatPoint)..'; iAngleTowardsBase='..iAngleTowardsBase..'; iDistTowardsBase from LZ midpoint='..iDistTowardsBase..'; Midpoint='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tMoveTowardsBaseRetreatPoint) or 'nil')..'; tLZData[M28Map.subrefLZIslandRef]='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')) end
    if tMoveTowardsBaseRetreatPoint then
        if not(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tMoveTowardsBaseRetreatPoint) == tLZData[M28Map.subrefLZIslandRef]) then
            tMoveTowardsBaseRetreatPoint = nil
        else
            local iAngleToRallyPoint = M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tRallyPoint)
            if bDebugMessages == true then LOG(sFunctionRef..': iAngleToRallyPoint='..iAngleToRallyPoint..'; Angle dif='..M28Utilities.GetAngleDifference(iAngleToRallyPoint, iAngleTowardsBase)..'; Dist between rally point and bsae='..M28Utilities.GetDistanceBetweenPositions(tRallyPoint, tLZTeamData[M28Map.reftClosestFriendlyBase])) end
            if M28Utilities.GetAngleDifference(iAngleToRallyPoint, iAngleTowardsBase) <= 20 then
                tMoveTowardsBaseRetreatPoint = nil
            elseif M28Utilities.GetDistanceBetweenPositions(tRallyPoint, tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 20 then
                tMoveTowardsBaseRetreatPoint = nil
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': tAmphibiousRallyPoint='..repru(tAmphibiousRallyPoint)..'; tRallyPoint='..repru(tRallyPoint)) end
    local iIndirectRunFigureNormal = 10
    local iIndirectRunFigureDeployedAdjust = 15
    local iIndirectRunFigureSynchronisation = 11
    local iIndirectDistanceInsideRangeThreshold

    local oClosestFriendlyUnitToAnEnemyFirebase --For simplicity will be the closest unit to the last firebase checked (where multiple firebases)
    local iClosestFriendlyUnitToAnEnemyFirebase = 100000

    local iFirebaseThreatAdjust = 0
    local iFirebaseCloseCombatThreat = 0
    local iAdjacentFirebaseThreat = 0

    local iAvailableCombatUnitThreat = M28UnitInfo.GetMassCostOfUnits(tAvailableCombatUnits)
    iAvailableCombatUnitThreat = iAvailableCombatUnitThreat + math.min(iAvailableCombatUnitThreat, tLZTeamData[M28Map.subrefiAvailableMobileShieldThreat])



    local bHaveSignificantCombatCloserToFirebase = false
    local iClosestFirebaseDist = 100000
    local oClosestUnitFromAllFirebases
    local oNearestFirebaseUnit
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
        --Is the firebase not in range of a core LZ?
        local bFirebaseInCoreLZRange = false
        local oOurNearestUnitToFirebase
        local tEnemyT2ArtiAndShields
        local iCurDist
        local iClosestDist
        local iCurFirebaseThreat
        local bIsAdjacent
        local iDistToFirebase
        local iClosestDistFromAllFirebases = 100000

        for iEntry, tPlateauAndLZ in tLZTeamData[M28Map.subreftEnemyFirebasesInRange] do
            if M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][tPlateauAndLZ[2]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] then
                bFirebaseInCoreLZRange = true
                iFirebaseThreatAdjust = 0
                break
            else
                --Ignore firebase in the LZ we are already in
                if not(iLandZone == tPlateauAndLZ[2]) then
                    local tFirebaseLZData = M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][tPlateauAndLZ[2]]
                    local tFirebaseLZTeamData = tFirebaseLZData[M28Map.subrefLZTeamData][iTeam]
                    tEnemyT2ArtiAndShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryFixedShield, tFirebaseLZTeamData[M28Map.subrefTEnemyUnits])
                    if M28Utilities.IsTableEmpty(tEnemyT2ArtiAndShields) == false then
                        iClosestDist = 100000
                        for iUnit, oUnit in tEnemyT2ArtiAndShields do
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oNearestFirebaseUnit = oUnit
                                if iCurDist < iClosestDistFromAllFirebases then
                                    oClosestUnitFromAllFirebases = oUnit
                                end
                            end
                        end
                        iClosestDist = 100000
                        local tFirebaseMidpoint = tFirebaseLZData[M28Map.subrefMidpoint]
                        for iUnit, oUnit in tAvailableCombatUnits do
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tFirebaseMidpoint)
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oOurNearestUnitToFirebase = oUnit
                                if iClosestDist < iClosestFriendlyUnitToAnEnemyFirebase then
                                    oClosestFriendlyUnitToAnEnemyFirebase = oUnit
                                    iClosestFriendlyUnitToAnEnemyFirebase = iClosestDist
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': oOurNearestUnitToFirebase='..oOurNearestUnitToFirebase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOurNearestUnitToFirebase)..'; oNearestFirebaseUnit='..oNearestFirebaseUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestFirebaseUnit)..'; Dist between them='..M28Utilities.GetDistanceBetweenPositions(oOurNearestUnitToFirebase:GetPosition(), oNearestFirebaseUnit:GetPosition())) end

                        if oOurNearestUnitToFirebase and oNearestFirebaseUnit then
                            iCurFirebaseThreat = 0
                            iDistToFirebase = M28Utilities.GetDistanceBetweenPositions(oOurNearestUnitToFirebase:GetPosition(), oNearestFirebaseUnit:GetPosition())
                            iClosestFirebaseDist = math.min(iClosestFirebaseDist, iDistToFirebase)
                            if iDistToFirebase <= 140 then
                                iCurFirebaseThreat = M28UnitInfo.GetMassCostOfUnits(tEnemyT2ArtiAndShields, true)
                                if iCurFirebaseThreat > 0 then
                                    iFirebaseCloseCombatThreat = tFirebaseLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] + math.min(tFirebaseLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 1.5, (tFirebaseLZTeamData[M28Map.subrefThreatEnemyShield] or 0)) --combat total excludes shields and t2 arti
                                    bIsAdjacent = false
                                    if M28Utilities.IsTableEmpty(tFirebaseLZData[M28Map.subrefLZPath]) == false then

                                        --Include friendly units in LZs between here and the firebase
                                        if bDebugMessages == true then
                                            --LOG(sFunctionRef..': iLandZone='..reprs(iLandZone))
                                            --LOG(sFunctionRef..': tPlateauAndLZ[2]='..reprs(tPlateauAndLZ[2]))
                                            --LOG(sFunctionRef..': tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][tPlateauAndLZ[2]]='..reprs(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][tPlateauAndLZ[2]]))
                                            --LOG(sFunctionRef..': pathing='..reprs(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][tPlateauAndLZ[2]]][M28Map.subrefLZPath]))
                                            --LOG(sFunctionRef..': tLZData[M28Map.subrefLZPathingToOtherLandZones]='..reprs(tLZData[M28Map.subrefLZPathingToOtherLandZones]))
                                            LOG(sFunctionRef..': Will cycle through all LZs between LZ'..reprs(iLandZone or 'nil')..' and LZ'..reprs(tPlateauAndLZ[2] or 'nil')..' and factor in friendly threat; Entry in pathing table='..reprs(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][tPlateauAndLZ[2]] or 'nil')..'; reprs of pathing='..reprs(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][tPlateauAndLZ[2]]][M28Map.subrefLZPath])..'; tLZData[M28Map.subrefLZPathingToOtherLandZones]='..reprs(tLZData[M28Map.subrefLZPathingToOtherLandZones]))
                                        end

                                        for iEntry, iAdjacentLandZone in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                            if iAdjacentLandZone == tPlateauAndLZ[2] then
                                                bIsAdjacent = true
                                            end
                                        end
                                        for iEntry, iPathLZ in tFirebaseLZData[M28Map.subrefLZPath] do
                                            if not(iPathLZ == iLandZone) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Friendly LZ that will pass through to get to firebase='..iPathLZ..'; Friendly combat threat of this='..(M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTThreatAllyCombatTotal] or 'nil')) end
                                                local tOtherFirebaseZoneTeamData = M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefLZTeamData][iTeam]
                                                iCurFirebaseThreat = iCurFirebaseThreat - (tOtherFirebaseZoneTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)
                                                iFirebaseCloseCombatThreat = iFirebaseCloseCombatThreat + (tOtherFirebaseZoneTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) - (tOtherFirebaseZoneTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)
                                                if not(bHaveSignificantCombatCloserToFirebase) and M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTThreatAllyCombatTotal] >= 4000 then
                                                    bHaveSignificantCombatCloserToFirebase = true
                                                end
                                            end
                                        end
                                    end
                                    if bIsAdjacent then
                                        --Track adjacent firebase threat so if we want to take this into account later we can; dont think we are double-counting this though so currently only using to affect decision on whether to automatically retreat
                                        iAdjacentFirebaseThreat = iAdjacentFirebaseThreat + math.max(iCurFirebaseThreat, 0)
                                    end
                                end
                            end
                            iFirebaseThreatAdjust = iFirebaseThreatAdjust + math.max(iCurFirebaseThreat, 0)
                        end
                    end
                else
                    iClosestFirebaseDist = 0
                end
            end
        end
    end

    --If enemy has a firebase, then retreat if we dont have enough threat to beat it and we dont have significant indirect force
    local bRunFromFirebase = false
    if bDebugMessages == true then LOG(sFunctionRef..': If enemy has nearby firebase will check if we have enough units to try and attack it, iFirebaseThreatAdjust='..iFirebaseThreatAdjust..'; bHaveSignificantCombatCloserToFirebase='..tostring(bHaveSignificantCombatCloserToFirebase or false)..'; iFirebaseCloseCombatThreat='..iFirebaseCloseCombatThreat) end
    if iFirebaseThreatAdjust > 0 and not(bHaveSignificantCombatCloserToFirebase) then
        if iAvailableCombatUnitThreat < math.min(20000, iFirebaseThreatAdjust) or (iAvailableCombatUnitThreat < iFirebaseThreatAdjust * 2) then
            --Retreat by default then check if have enough threat to attack
            bRunFromFirebase = true
            --Exception if we have fatboys or megaliths in which case compare to enemy long range threat as well
            if iAvailableCombatUnitThreat >= 8000 then
                local tFriendlyExperimental = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental, tAvailableCombatUnits)
                if bDebugMessages == true then LOG(sFunctionRef..': Will consider running from firebase, is table of firendly experimentals empty='..tostring(M28Utilities.IsTableEmpty(tFriendlyExperimental))) end
                if M28Utilities.IsTableEmpty(tFriendlyExperimental) == false then
                    local iLRExpThreat = 0
                    local bHaveDamagedFatboys = false
                    local bHaveFatboys = false
                    local iSRExpThreat = 0
                    local bHaveSRExpNearFirebaseUnit = false
                    for iUnit, oUnit in tFriendlyExperimental do
                        if (oUnit[M28UnitInfo.refiCombatRange] or 0) >= 60 then
                            local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, false)
                            if iMaxShield > 0 then
                                bHaveFatboys = true
                                if iCurShield > 0 then
                                    iLRExpThreat = iLRExpThreat + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * iCurShield / iMaxShield
                                    if iCurShield < iMaxShield * 0.7 then bHaveDamagedFatboys = true end
                                else bHaveDamagedFatboys = true
                                end
                            else
                                iLRExpThreat = iLRExpThreat + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * M28UnitInfo.GetUnitHealthPercent(oUnit)
                            end
                        end
                        --Include megalith in both LR and SR threats
                        if (oUnit[M28UnitInfo.refiDFRange] or 0) <= 80 and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) then
                            iSRExpThreat = iSRExpThreat + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * M28UnitInfo.GetUnitHealthPercent(oUnit)
                            if not(bHaveSRExpNearFirebaseUnit) and oClosestUnitFromAllFirebases and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestUnitFromAllFirebases:GetPosition()) <= oUnit[M28UnitInfo.refiCombatRange] + 10 then
                                bHaveSRExpNearFirebaseUnit = true
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iLRExpThreat='..iLRExpThreat..'; iSRExpThreat='..iSRExpThreat..'; bHaveSRExpNearFirebaseUnit='..tostring(bHaveSRExpNearFirebaseUnit or false)) end
                    if bHaveSRExpNearFirebaseUnit and (iAvailableCombatUnitThreat >= iFirebaseCloseCombatThreat * 0.8 or iSRExpThreat >= 8000) then
                        bRunFromFirebase = false
                    elseif iLRExpThreat > 0 then
                        local iEnemyT2ArtiThreat = 0
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
                            --Treat T2 arti as being worth twice their mass cost since we may be dealing with a fatboy
                            iEnemyT2ArtiThreat = M28UnitInfo.GetMassCostOfUnits(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits], true)
                            if bHaveFatboys then iEnemyT2ArtiThreat = iEnemyT2ArtiThreat * 1.25 end
                            if bHaveDamagedFatboys then iEnemyT2ArtiThreat = iEnemyT2ArtiThreat * 1.25 end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iLRExpThreat='..iLRExpThreat..'; tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat]='..tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat]..'; iEnemyT2ArtiThreat='..iEnemyT2ArtiThreat..'; bHaveFatboys='..tostring(bHaveFatboys or false)..'; iFirebaseCloseCombatThreat='..iFirebaseCloseCombatThreat) end
                        if iLRExpThreat > tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] + iEnemyT2ArtiThreat or (not(bHaveDamagedFatboys) and math.max(iAvailableCombatUnitThreat, iLRExpThreat) >= iFirebaseCloseCombatThreat * 2) then
                            bRunFromFirebase = false
                        end
                    end
                    if bRunFromFirebase and iSRExpThreat > 0 then
                        if iSRExpThreat > math.max(8000, iFirebaseCloseCombatThreat * 3) or ((iClosestFirebaseDist <= 80 or bHaveSignificantCombatCloserToFirebase) and iSRExpThreat >= math.max(7000, iFirebaseCloseCombatThreat * 2)) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have enough short range experimental threat to press the attack') end
                            bRunFromFirebase = false
                        end
                    end
                end
            end
            if bRunFromFirebase and iClosestFirebaseDist <= 100 then
                local tFriendlyIndirect = EntityCategoryFilterDown(M28UnitInfo.refCategoryIndirect, tAvailableCombatUnits)
                if M28Utilities.IsTableEmpty( tFriendlyIndirect) == false then
                    local iFriendlyIndirect = table.getn(tFriendlyIndirect)
                    if bDebugMessages == true then LOG(sFunctionRef..': Friendly indirect of all tech level='..iFriendlyIndirect) end
                    if iFriendlyIndirect >= 20 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Exception to decision to run from firebase') end
                        bRunFromFirebase = false
                        --if the firebase is close to a core base or we have MMLs in this zone or other zones that have recently damaged it then consider attacking anyway
                    else
                        local tFriendlyT2PlusIndirect = EntityCategoryFilterDown(categories.ALLUNITS - categories.TECH1, tFriendlyIndirect)
                        if M28Utilities.IsTableEmpty(tFriendlyT2PlusIndirect) == false then
                            iFriendlyIndirect = table.getn(tFriendlyT2PlusIndirect)
                            if iFriendlyIndirect >= 2 and M28UnitInfo.IsUnitValid(oClosestUnitFromAllFirebases) then
                                local iFirebasePlateau, iFirebaseZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oClosestUnitFromAllFirebases:GetPosition())
                                if (iFirebaseZone or 0) > 0 and (iFirebasePlateau or 0) > 0 then
                                    --If firebase direct fire range
                                    local tFirebaseLZTeamData = M28Map.tAllPlateaus[iFirebasePlateau][M28Map.subrefPlateauLandZones][iFirebaseZone][M28Map.subrefLZTeamData][iTeam]
                                    --Check enemy doesnt have ravager/equivalent that makes MML bad, or (if they do) that we have lots of T3+ MML
                                    if math.max((tFirebaseLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0), tFirebaseLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0) < 60 or iFriendlyIndirect >= 15 then

                                        if bDebugMessages == true then LOG(sFunctionRef..': Time since last had MML in this zone firing near TMD or shield='..(GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -30))..'; Dist from nearest firebase unit to base='..M28Utilities.GetDistanceBetweenPositions(oClosestUnitFromAllFirebases:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])..'; Time since firebase zone had a shield or TMD face a missile='..(GetGameTimeSeconds() - (tFirebaseLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -30))) end
                                        --If have MMLs that have recently damaged the firebase shields or been intercepted by TMD, consider if we have enough MMLs to overwhelm the firebase
                                        if GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -30) <= 30 or GetGameTimeSeconds() - (tFirebaseLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -10) <= 30 or (oClosestUnitFromAllFirebases and M28Utilities.GetDistanceBetweenPositions(oClosestUnitFromAllFirebases:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 200) then
                                            local iEnemyTMDCount = 0
                                            local iEnemyT2ArtiCount = 0
                                            local iOurMMLCount = 0
                                            local iOurNonMMLCount = 0
                                            local tOurMML = EntityCategoryFilterDown(M28UnitInfo.refCategoryMML, tFriendlyT2PlusIndirect)
                                            if M28Utilities.IsTableEmpty(tOurMML) == false then
                                                iOurMMLCount = table.getn(tOurMML)
                                            end
                                            iOurNonMMLCount = iFriendlyIndirect - iOurMMLCount
                                            if M28Utilities.IsTableEmpty(tFirebaseLZTeamData[M28Map.subreftoEnemyTMD]) == false then
                                                iEnemyTMDCount = table.getn(tFirebaseLZTeamData[M28Map.subreftoEnemyTMD])
                                            end
                                            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
                                                iEnemyT2ArtiCount = table.getn(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits])
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': iEnemyTMDCount='..iEnemyTMDCount..'; iOurMMLCount='..iOurMMLCount..'; iOurNonMMLCount='..iOurNonMMLCount..'; iEnemyT2ArtiCount='..iEnemyT2ArtiCount..'; Enemy shield threat='..(tFirebaseLZTeamData[M28Map.subrefThreatEnemyShield] or 0)) end
                                            if iEnemyT2ArtiCount == 0 or (iEnemyT2ArtiCount * 1.5 + (tFirebaseLZTeamData[M28Map.subrefThreatEnemyShield] or 0) / 1000 < (iOurNonMMLCount + math.max(0,(iOurMMLCount - iEnemyTMDCount)))) then
                                                bRunFromFirebase = false
                                                if bDebugMessages == true then LOG(sFunctionRef..': WIll try and attack firebase') end
                                            end
                                            if bRunFromFirebase and iOurMMLCount > 0 and M28Utilities.IsTableEmpty( tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                                --Revise MML count to factor in all adjacent zones
                                                local tThisZoneMML = EntityCategoryFilterDown(M28UnitInfo.refCategoryMML, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                                local iAltMMLCount = 0
                                                if M28Utilities.IsTableEmpty(tThisZoneMML) == false then
                                                    iAltMMLCount = table.getn(tThisZoneMML)
                                                end
                                                for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                                        tThisZoneMML = EntityCategoryFilterDown(M28UnitInfo.refCategoryMML, tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                                        if M28Utilities.IsTableEmpty(tThisZoneMML) == false then
                                                            iAltMMLCount = iAltMMLCount + table.getn(tThisZoneMML)
                                                        end
                                                    end
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': iAltMMLCount='..iAltMMLCount..'; iOurMMLCount='..iOurMMLCount..'; iEnemyT2ArtiCount='..iEnemyT2ArtiCount..'; Enemy shield threat='..(tFirebaseLZTeamData[M28Map.subrefThreatEnemyShield] or 0)..'; iEnemyTMDCount='..iEnemyTMDCount) end
                                                if iAltMMLCount > iOurMMLCount then
                                                    if (iEnemyT2ArtiCount * 1.5 + (tFirebaseLZTeamData[M28Map.subrefThreatEnemyShield] or 0) / 1000 < (iOurNonMMLCount + math.max(0,(iAltMMLCount - iEnemyTMDCount)))) then
                                                        bRunFromFirebase = false
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Hvae enough MML to attack') end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                if bRunFromFirebase then
                    if iAvailableCombatUnitThreat >= math.max(12000, iFirebaseCloseCombatThreat * 3) or (bHaveSignificantCombatCloserToFirebase and  iAvailableCombatUnitThreat >= math.max(7000, iFirebaseCloseCombatThreat * 2)) then
                        bRunFromFirebase = false

                    end
                end
            end
        end
    end

    --Flag that we are attacking this firebase so other zones can also attack it instead of running if they are in scenario 1
    if oClosestUnitFromAllFirebases and (iFriendlyBestMobileIndirectRange or 0) > math.max(tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0, tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0) then
        local tClosestFirebaseTeamData = M28Map.GetLandOrWaterZoneData(oClosestUnitFromAllFirebases:GetPosition(), true, iTeam)
        if tClosestFirebaseTeamData then
            if bDebugMessages == true then LOG(sFunctionRef..': Time since we last had a zone wanting to attack this firebase zone='..(tClosestFirebaseTeamData[M28Map.refiTimeOfLastIndirectFirebaseAttack] or 'nil')) end
            if bRunFromFirebase == false then
                tClosestFirebaseTeamData[M28Map.refiTimeOfLastIndirectFirebaseAttack] = GetGameTimeSeconds()
            elseif GetGameTimeSeconds() - (tClosestFirebaseTeamData[M28Map.refiTimeOfLastIndirectFirebaseAttack] or -100) <= 3 then
                bRunFromFirebase = false
            end
        end
    end

    local bSuicideIntoFatboyOrACU = false
    local oClosestFatboyOrACUInIslandToSuicideInto
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets]) == false then
        local iCurACUDist
        local iClosestACUDist = 150 --Wont try and suicide if are further away than this
        local bSuicideIntoCurACU, bIgnoreDistanceToMidpointCheck
        for iACU, oACU in M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets] do
            if M28UnitInfo.IsUnitValid(oACU) and not(M28UnitInfo.IsUnitUnderwater(oACU)) and not(oACU:IsUnitState('Attached')) then
                --Require enemy health to be < 5*our available combat threat (prev did 2x, but since 20 tanks is about 1k threat, that means we are running when enemy is at 3k health and we have 20 tanks), or sub-1k
                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to charge into enemy ACU, ACU health='..oACU:GetHealth()..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; Dist to LZ midpoint='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZData[M28Map.subrefMidpoint])) end
                bSuicideIntoCurACU = false
                if oACU:GetHealth() < math.max(1000, iAvailableCombatUnitThreat * 2) then
                    bSuicideIntoCurACU = true
                elseif iAvailableCombatUnitThreat >= 400 and oACU:GetHealth() < math.max(1000, iAvailableCombatUnitThreat * 5) then
                    --Check threat around enemy ACU vs our threat based on our closest available unit to the enemy ACU (so if we have a bunch of tanks nearby we will consider pushing, but if we just have 1-2 tanks we wont)
                    local toUnitsAlmostInRangeOfACU = {}
                    local toUnitsModeratelyFarAway = {}
                    local toUnitsFarAway = {}
                    local iModeratelyFarThreshold = 40
                    local oClosestAvailableCombatToACU
                    local iClosestAvailableCombatToACU = 10000
                    local iCurDistLessRange
                    for iUnit, oUnit in tAvailableCombatUnits do
                        iCurDistLessRange = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition()) - oUnit[M28UnitInfo.refiCombatRange]
                        if iCurDistLessRange < iClosestAvailableCombatToACU then
                            iClosestAvailableCombatToACU = iCurDistLessRange
                            oClosestAvailableCombatToACU = oUnit
                        end
                        if iCurDistLessRange <= 6 then
                            table.insert(toUnitsAlmostInRangeOfACU, oUnit)
                        elseif iCurDistLessRange <= iModeratelyFarThreshold then
                            table.insert(toUnitsModeratelyFarAway, oUnit)
                        else
                            table.insert(toUnitsFarAway, oUnit)
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iClosestAvailableCombatToACU='..iClosestAvailableCombatToACU..'; iModeratelyFarThreshold='..iModeratelyFarThreshold) end
                    if iClosestAvailableCombatToACU <= iModeratelyFarThreshold then
                        local iNearbyThreat = M28UnitInfo.GetCombatThreatRating(toUnitsAlmostInRangeOfACU, false, false)
                        local iEnemyACUThreat = M28UnitInfo.GetCombatThreatRating({ oACU }, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': iClosestAvailableCombatToACU='..iClosestAvailableCombatToACU..'; iNearbyThreat='..iNearbyThreat..'; iEnemyACUThreat='..iEnemyACUThreat) end
                        if iNearbyThreat >= iEnemyACUThreat then
                            bSuicideIntoCurACU = true
                            bIgnoreDistanceToMidpointCheck = true
                        else
                            local iMediumThreat = M28UnitInfo.GetCombatThreatRating(toUnitsModeratelyFarAway, false, false)
                            if bDebugMessages == true then LOG(sFunctionRef..': iMediumThreat='..iMediumThreat) end
                            if iNearbyThreat + iMediumThreat > iEnemyACUThreat then
                                --Do detailed calculation
                                local toFriendlyNearbyCombat = {}
                                for iUnit, oUnit in toUnitsModeratelyFarAway do
                                    if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestAvailableCombatToACU:GetPosition()) <= 20 then
                                        table.insert(  toFriendlyNearbyCombat, oUnit)
                                    end
                                end
                                local iNearbyFriendlyCombatThreat = M28UnitInfo.GetCombatThreatRating(toFriendlyNearbyCombat, false, false)
                                if iNearbyThreat + iNearbyFriendlyCombatThreat > iEnemyACUThreat then
                                    local toNearbyEnemyThreat = {}
                                    local iDistanceThreshold = math.max(10, iClosestAvailableCombatToACU + 15)
                                    function IncludeDFEnemiesNearby(tCurLZTeamData, bCheckIfAlreadyRecorded)
                                        if M28Utilities.IsTableEmpty(tCurLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                                            for iUnit, oUnit in tCurLZTeamData[M28Map.reftoNearestDFEnemies] do
                                                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0) <= iDistanceThreshold
                                                        or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestAvailableCombatToACU:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0) <= iDistanceThreshold then
                                                    if not(bCheckIfAlreadyRecorded) then
                                                        table.insert(toNearbyEnemyThreat, oUnit)
                                                    else
                                                        local bAlreadyRecorded = false
                                                        for iRecorded, oRecorded in toNearbyEnemyThreat do
                                                            if oRecorded == oUnit then
                                                                bAlreadyRecorded = true
                                                                break
                                                            end
                                                        end
                                                        if not(bAlreadyRecorded) then
                                                            table.insert(toNearbyEnemyThreat, oUnit)
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    IncludeDFEnemiesNearby(tLZTeamData)
                                    if not(oACU[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) and oACU[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] == iPlateau then
                                        local tACUTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][oACU[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]][M28Map.subrefLZTeamData][iTeam]
                                        IncludeDFEnemiesNearby(tACUTeamData, not(M28Utilities.IsTableEmpty(toNearbyEnemyThreat)))
                                    end
                                    local iNearbyEnemyThreat = M28UnitInfo.GetCombatThreatRating(toNearbyEnemyThreat, true)
                                    if bDebugMessages == true then LOG(sFunctionRef..': iNearbyEnemyThreat='..iNearbyEnemyThreat..'; iNearbyFriendlyCombatThreat='..iNearbyFriendlyCombatThreat..'; iNearbyThreat='..iNearbyThreat) end
                                    if iNearbyFriendlyCombatThreat + iNearbyThreat > iNearbyEnemyThreat then
                                        bSuicideIntoCurACU = true
                                        bIgnoreDistanceToMidpointCheck = true
                                    end
                                end
                            end
                        end
                    end
                end
                if bSuicideIntoCurACU then
                    iCurACUDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZData[M28Map.subrefMidpoint])
                    if iCurACUDist <= iClosestACUDist then bIgnoreDistanceToMidpointCheck = true
                    elseif not(bIgnoreDistanceToMidpointCheck) then
                        --If we have enough combat units almost in range of the ACU then still suicide into it
                        local aiBrain = ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]]
                        local toFriendlyUnitsNearACU = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat, oACU:GetPosition(), 35, 'Ally')
                        if bDebugMessages == true then LOG(sFunctionRef..': ACU is quite far from this zone midpoint, do we have significant combat threat near the ACU? is toFriendlyUnitsNearACU empty='..tostring(M28Utilities.IsTableEmpty(toFriendlyUnitsNearACU))) end
                        if M28Utilities.IsTableEmpty(toFriendlyUnitsNearACU) == false and M28UnitInfo.GetCombatThreatRating({ oACU }, true) < M28UnitInfo.GetCombatThreatRating(toFriendlyUnitsNearACU, false) then
                            bIgnoreDistanceToMidpointCheck = true
                        end
                    end
                    if bIgnoreDistanceToMidpointCheck then
                        oClosestFatboyOrACUInIslandToSuicideInto = oACU
                        bSuicideIntoFatboyOrACU = true
                        iClosestACUDist = iCurACUDist
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to suicide into enemy ACU') end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished considering if there is an ACU we should try and snipe, bSuicideIntoFatboyOrACU='..tostring(bSuicideIntoFatboyOrACU)..'; oClosestFatboyOrACUInIslandToSuicideInto='..(oClosestFatboyOrACUInIslandToSuicideInto.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestFatboyOrACUInIslandToSuicideInto) or 'nil')..'; Time='..GetGameTimeSeconds()) end
    end
    if not(oClosestFatboyOrACUInIslandToSuicideInto) and iAvailableCombatUnitThreat >= 5000 and iFriendlyBestMobileDFRange > 15 and tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] >= 1000 and M28Conditions.IsTableOfUnitsStillValid(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats]) then
        local tEnemyFatboy = EntityCategoryFilterDown(M28UnitInfo.refCategoryFatboy, tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats])
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy fatboy empty='..tostring(M28Utilities.IsTableEmpty(tEnemyFatboy))) end
        if M28Utilities.IsTableEmpty(tEnemyFatboy) == false then
            local iClosestDistToMidpoint = 100000
            local iCurDist
            for iUnit, oUnit in tEnemyFatboy do
                if M28UnitInfo.IsUnitValid(oUnit) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Fatboy='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; land label='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition()) or 'nil')..'; LZ island ref='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..'; Dist to midpoint='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])) end
                    --Add to skirmisher enemies
                    if NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition()) == tLZData[M28Map.subrefLZIslandRef] then
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                        if iCurDist < iClosestDistToMidpoint then
                            iClosestDistToMidpoint = iCurDist
                            oClosestFatboyOrACUInIslandToSuicideInto = oUnit
                        end
                    end
                end
            end
            if oClosestFatboyOrACUInIslandToSuicideInto then
                --Cycle through available DF units (if we have any)
                local tT3PlusDF = EntityCategoryFilterDown(categories.DIRECTFIRE - categories.TECH1 - categories.TECH2, tAvailableCombatUnits)
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of T3PlusDF units empty='..tostring(M28Utilities.IsTableEmpty(tT3PlusDF))) end
                if M28Utilities.IsTableEmpty(tT3PlusDF) == false then
                    local oClosestFriendlyDFUnitToFatboy = M28Utilities.GetNearestUnit(tT3PlusDF, oClosestFatboyOrACUInIslandToSuicideInto:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': oClosestFriendlyDFUnitToFatboy='..(oClosestFriendlyDFUnitToFatboy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestFriendlyDFUnitToFatboy) or 'nil')..'; oClosestFatboyOrACUInIslandToSuicideInto='..oClosestFatboyOrACUInIslandToSuicideInto.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestFatboyOrACUInIslandToSuicideInto)..'; Dist between them='..M28Utilities.GetDistanceBetweenPositions(oClosestFriendlyDFUnitToFatboy:GetPosition(), oClosestFatboyOrACUInIslandToSuicideInto:GetPosition())..'; oClosestFriendlyDFUnitToFatboy='..(oClosestFriendlyDFUnitToFatboy[M28UnitInfo.refiDFRange] or 'nil')) end
                    if oClosestFriendlyDFUnitToFatboy then
                        local iDistUntilDFReachesFatboy = M28Utilities.GetDistanceBetweenPositions(oClosestFriendlyDFUnitToFatboy:GetPosition(), oClosestFatboyOrACUInIslandToSuicideInto:GetPosition())
                        if iDistUntilDFReachesFatboy <= math.max(25 + iFriendlyBestMobileDFRange, 35 + (oClosestFriendlyDFUnitToFatboy[M28UnitInfo.refiDFRange] or 0)) then
                            --Much lower threshold if enemy has multiple fatboys or we dont have a big combat threat
                            if iDistUntilDFReachesFatboy <= 5 +  (oClosestFriendlyDFUnitToFatboy[M28UnitInfo.refiDFRange] or 0) or (iDistUntilDFReachesFatboy <= 60 and (oClosestFriendlyDFUnitToFatboy[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oClosestFriendlyDFUnitToFatboy)) >= 10000) then
                                bSuicideIntoFatboyOrACU = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Have a friendly T3 DF unit in range or almost in range of enemy fatboy so will suicide into it') end
                            elseif iAvailableCombatUnitThreat < 10000 or tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] >= 30000 then
                                --More refined check as either enemy has multiple fatboys or we have only a small level of threat so might struggle to chase down the fatboy
                                if bDebugMessages == true then LOG(sFunctionRef..': tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat]='..tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat]..'; oClosestFriendlyDFUnitToFatboy[M28UnitInfo.refiUnitMassCost]='..(oClosestFriendlyDFUnitToFatboy[M28UnitInfo.refiUnitMassCost] or 'nil')) end
                                if tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] >= 30000 then
                                    --If enemy has multiple fatboys then require T2 arti to be in range to consider suiciding into it
                                    if tLZTeamData[M28Map.refiTimeOurT2ArtiLastFired] and GetGameTimeSeconds() - tLZTeamData[M28Map.refiTimeOurT2ArtiLastFired] <= 20 then
                                        --We have fired T2 arti recently, so is the fatboy in range of friendly T2 arti to the point of being able to shoot them? if so, then attack
                                        local tFixedT2Arti = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                        if M28Utilities.IsTableEmpty(tFixedT2Arti) == false then
                                            for iArti, oArti in tFixedT2Arti do
                                                if oArti:GetFractionComplete() == 1 and M28Utilities.GetDistanceBetweenPositions(oArti:GetPosition(), oClosestFatboyOrACUInIslandToSuicideInto:GetPosition()) <= oClosestFatboyOrACUInIslandToSuicideInto[M28UnitInfo.refiCombatRange] then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Fatboy is in combat range of friendly t2 arti so will attack') end
                                                    bSuicideIntoFatboyOrACU = true
                                                    break
                                                end
                                            end
                                        end
                                    end
                                elseif (oClosestFriendlyDFUnitToFatboy[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oClosestFriendlyDFUnitToFatboy)) >= 5000 and iDistUntilDFReachesFatboy - (oClosestFriendlyDFUnitToFatboy[M28UnitInfo.refiDFRange] or 0) <= 35 then
                                    bSuicideIntoFatboyOrACU = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Nearest unit close to being in range and is high value so will continue with suicide approach') end
                                else
                                    --Likely only 1 fatboy but our threat is low - only consider suiciding in if we have at least 5k in mass of units close to being in range of the fatboy
                                    local toUnitsCloseToBeingAbleToShootFatboy = {}
                                    for iUnit, oUnit in tT3PlusDF do
                                        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFatboyOrACUInIslandToSuicideInto:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0) <= 35 then
                                            table.insert(toUnitsCloseToBeingAbleToShootFatboy, oUnit)
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Mass cost of DF units almost able to shoot fatboy='.. M28UnitInfo.GetMassCostOfUnits(toUnitsCloseToBeingAbleToShootFatboy, false)) end
                                    if M28UnitInfo.GetMassCostOfUnits(toUnitsCloseToBeingAbleToShootFatboy, false) then
                                        bSuicideIntoFatboyOrACU = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': We have enough combat units in range to be able to target the fatboy') end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    local bRunFromEnemyAir = false
    if bDebugMessages == true then LOG(sFunctionRef..': Wondering if we want to run from enemy air, iFirebaseThreatAdjust='..iFirebaseThreatAdjust..'; tLZTeamData[M28Map.refiModDistancePercent]='..tLZTeamData[M28Map.refiModDistancePercent]..'; tLZTeamData[M28Map.subrefLZMAAThreatWanted]='..tLZTeamData[M28Map.subrefLZMAAThreatWanted]..'; Have air control='..tostring(M28Team.tAirSubteamData[ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].M28AirSubteam][M28Team.refbHaveAirControl])..'; Enemy air to ground='..(M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] or 'nil')) end
    if iFirebaseThreatAdjust == 0 and not(bSuicideIntoFatboyOrACU) and tLZTeamData[M28Map.refiModDistancePercent] <= 0.75 and tLZTeamData[M28Map.subrefLZMAAThreatWanted] >= 50 and not(M28Team.tAirSubteamData[ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].M28AirSubteam][M28Team.refbHaveAirControl]) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 400 then
        local iNetEnemyAirToGroundThreat = tLZTeamData[M28Map.refiEnemyAirToGroundThreat] - tLZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] * 2 - tLZTeamData[M28Map.subrefLZThreatAllyMAA] * 4
        local iNearbyMAA = (tLZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] or 0)
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                iNetEnemyAirToGroundThreat = iNetEnemyAirToGroundThreat + math.max(0, tAdjLZTeamData[M28Map.refiEnemyAirToGroundThreat] - tAdjLZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] * 2) - tAdjLZTeamData[M28Map.subrefLZThreatAllyMAA] * 4
                iNearbyMAA = iNearbyMAA + (tAdjLZTeamData[M28Map.subrefLZThreatAllyMAA] or 0)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iNetEnemyAirToGroundThreat in adjacent zones='..iNetEnemyAirToGroundThreat) end
        if iNetEnemyAirToGroundThreat >= math.max(200, iAvailableCombatUnitThreat * 0.1) then
            bRunFromEnemyAir = true
            --If in enemy base/threatening enemy buildings then dont run
            local iNearbyEnemyBuildingValue = 0
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                local tNearbyEnemyBuildings = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryPD, tLZTeamData[M28Map.subrefTEnemyUnits])
                iNearbyEnemyBuildingValue = M28UnitInfo.GetMassCostOfUnits(tNearbyEnemyBuildings, true)
            end
            if iNearbyEnemyBuildingValue >= math.min(2000, iAvailableCombatUnitThreat * 0.2) then
                bRunFromEnemyAir = false
            end
        end
        --Be more cautious with experimental level land forces
        if bDebugMessages == true then LOG(sFunctionRef..': Run from a global enemy air to ground threat if relevant, tLZTeamData[M28Map.refiModDistancePercent]='..tLZTeamData[M28Map.refiModDistancePercent]..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; iNearbyMAA='..iNearbyMAA..'; Far behind on air='..tostring(M28Team.tAirSubteamData[ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].M28AirSubteam][M28Team.refbFarBehindOnAir] or false)..'; Enemy air to ground='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; LZSvalue='..tLZTeamData[M28Map.subrefLZSValue]..'; Enemy structure mass='..tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]..'; Dist to closest friendly base='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase])..'; iFriendlyBestMobileDFRange='..iFriendlyBestMobileDFRange) end
        if not(bRunFromEnemyAir) and tLZTeamData[M28Map.refiModDistancePercent] >= 0.25 and iAvailableCombatUnitThreat >= 8000 and iNearbyMAA < 3000 and iAvailableCombatUnitThreat > iNearbyMAA * 5 and M28Team.tAirSubteamData[ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].M28AirSubteam][M28Team.refbFarBehindOnAir] and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > iAvailableCombatUnitThreat * 0.35 then
            --Check dont have enemies in our range, or enemies we are in range of, or high value friendly units, and we dont ahve a long range unit (that is likely a fatboy that can build its own MAA)
            if tLZTeamData[M28Map.subrefLZSValue] <= 3000 and tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] <= 3000 and M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase]) >= 150 and iFriendlyBestMobileDFRange <= 90 then
                --Check for experimentals in this zone, and if we have any, if they are in range of any enemies (or about to be)
                local tLandExp = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental, tAvailableCombatUnits)
                if bDebugMessages == true then LOG(sFunctionRef..': Is friendly tLandExp empty='..tostring(M28Utilities.IsTableEmpty(tLandExp))) end
                if M28Utilities.IsTableEmpty(tLandExp) == false then
                    local bInRangeOfEnemyDFUnit = false
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                        local iEnemyDFRange = math.max(tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0, tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0)
                        for iExp, oExp in tLandExp do
                            if bDebugMessages == true then LOG(sFunctionRef..': Does the enemy have df units in range of our exp, based on enemy unit range='..tostring(M28Conditions.CloseToEnemyUnit(oExp:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 5, iTeam, true, nil, nil, nil, nil, nil))..'; Exp DF range='..(oExp[M28UnitInfo.refiDFRange] or 'nil')) end
                            if (oExp[M28UnitInfo.refiDFRange] or 0) > iEnemyDFRange then
                                if M28Conditions.CloseToEnemyUnit(oExp:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], (oExp[M28UnitInfo.refiDFRange] or 0) + 5, iTeam, false, nil, nil, nil, nil, nil) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Exp is in range of enemy DF unit') end
                                    bInRangeOfEnemyDFUnit = true
                                    break
                                end
                            else
                                if M28Conditions.CloseToEnemyUnit(oExp:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 5, iTeam, true, nil, nil, nil, nil, nil) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy DF unit is in range of our experimental') end
                                    bInRangeOfEnemyDFUnit = true
                                    break
                                end
                            end
                        end
                    end
                    if not(bInRangeOfEnemyDFUnit) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Are too far from base without sufficient groundAA support so will retreat from enemy potential air threat') end
                        bRunFromEnemyAir = true
                    end
                end
            end
        end
    end
    local oNearestEnemyToFriendlyBase
    local bConsiderAttackingACU = false
    local toEnemyACUsNearZone --will set this later on
    function GetManualAttackTargetIfWantManualAttack(oUnit, oOptionalPrimaryTarget)
        if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack - start of code') end
        --Returns the unit, and returns true if should move towards it instead of a manual attack order (will want to move towards it if we are in range of a dangerous unit but we cant attack it yet)
        local oManualAttackTarget
        local bMoveTowardsTarget = false
        if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack - Considering if want oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to pick a target for a manual attack, unit DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Is table of nearby enemy units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]))..'; Can we see nearest enemy to midpoint='..tostring(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oNearestEnemyToFriendlyBase))..'; Dist to nearest enemy='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition())..'; Is unit shot blocked='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked] or false)..'; refiTimeOfLastUnblockedShot='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or 0)..'; Unit DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Mass cost='..(oUnit[M28UnitInfo.refiUnitMassCost] or 'nil')..'; bConsiderAttackingACU='..tostring(bConsiderAttackingACU)) end

        --Monkeylord, GC and Ythotha - prioritise enemy ACUs that we are clsoe to being in range of, unless the ACU is very powerful
        if (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) >= 15000 and oUnit[M28UnitInfo.refiCombatRange] <= 64 and (oUnit[M28UnitInfo.refiDFRange] <= 50 or oUnit.UnitId == 'url0402') and oUnit:GetMaxHealth() >= 40000 then --IF CHANGING HERE THEN CHANGE BELOW AS WELL
            if not(oClosestFatboyOrACUInIslandToSuicideInto) and (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then
                --Consider suiciding into enemy ACU with experimentals only
                local iClosestACU
                if bConsiderAttackingACU and M28Utilities.IsTableEmpty(toEnemyACUsNearZone) == false then iClosestACU = oUnit[M28UnitInfo.refiDFRange] + math.min(30, math.max(20, oUnit[M28UnitInfo.refiDFRange]))
                else iClosestACU = oUnit[M28UnitInfo.refiDFRange] + 14
                end
                local iCurDist
                local oClosestACUNearUnit
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) == false then
                    for iACU, oACU in M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs] do
                        if M28UnitInfo.IsUnitValid(oACU) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZData[M28Map.subrefMidpoint])
                            if bDebugMessages == true then LOG(sFunctionRef..': Dist to ACU owned by '..oACU:GetAIBrain().Nickname..'='..iCurDist) end
                            if iCurDist < iClosestACU and not(M28UnitInfo.IsUnitUnderwater(oACU)) and not(oACU:IsUnitState('Attached')) then
                                --Check this isnt a deadly ACU (i.e. 10k+ of mass upgrades)
                                if (oACU[M28UnitInfo.refiDFMassThreatOverride] or 0) < 10000 and not(oACU[M28UnitInfo.refbUnitIsCloaked]) then
                                    --Check on same plateau as us
                                    local iACUPlateau, iACUZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oACU:GetPosition())
                                    if iACUPlateau == iPlateau then
                                        iClosestACU = iCurDist
                                        oClosestACUNearUnit = oACU
                                    end
                                end
                            end
                        end
                    end
                end
                if oClosestACUNearUnit then
                    if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack Will launch micro logic to suicide into enemy ACU') end
                    --Suicide into this ACU as special micro logic (so dont get given new orders)
                    ForkThread(M28Micro.SuicideExperimentalIntoEnemyACU, oUnit, oClosestACUNearUnit)
                    return oClosestACUNearUnit, true
                end
            end
        end

        --ACU snipe target that are in range of
        if bSuicideIntoFatboyOrACU and oClosestFatboyOrACUInIslandToSuicideInto and ((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or ((oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0 and EntityCategoryContains(M28UnitInfo.refCategoryLandCombat, oUnit.UnitId))) then
            --Are we almost 5 within range of the ACU/fatboy target, and it is an ACU (as for a fatboy t might be good to get close so we are under the shield)? if so then have as manual attack target
            if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack Dist to oClosestFatboyOrACUInIslandToSuicideInto='..M28Utilities.GetDistanceBetweenPositions(oClosestFatboyOrACUInIslandToSuicideInto:GetPosition(), oUnit:GetPosition())..'; Combat range='..oUnit[M28UnitInfo.refiCombatRange]) end
            if M28Utilities.GetDistanceBetweenPositions(oClosestFatboyOrACUInIslandToSuicideInto:GetPosition(), oUnit:GetPosition()) < (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) - 5 then
                return oClosestFatboyOrACUInIslandToSuicideInto, false
            end
        end

        --Note - in some cases the nearest enemy unit to the midpoint may be much further away than our units, if our units are from an adjacent zone or have just entered the cur zone, therefore if dealing with an experimental friendly unit want to do more detailed check of all nearby enemy units
        if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), (oOptionalPrimaryTarget or oNearestEnemyToFriendlyBase)) then --and (EntityCategoryContains(categories.EXPERIMENTAL + categories.TECH3, oUnit.UnitId) or M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition()) < (oUnit[M28UnitInfo.refiDFRange] or 0)) then
            --Nearest enemy is inside our range, is there another high value target that we should target?
            if EntityCategoryContains(categories.TECH3 + categories.EXPERIMENTAL, oUnit.UnitId) then

                local iCategoryToSearch = M28UnitInfo.refCategoryLandExperimental + categories.COMMAND + M28UnitInfo.refCategoryDestroyer --I.e. salems on land should be attacked if we are in range of them
                --Ythotha - also consider enemy T3 land combat to try and avoid it constantly changing targets

                --Below is if wanted to generalise, however concerned about riks of overkill
                --[[
                local iCategoryToSearch = M28UnitInfo.refCategoryMobileDFLand + M28UnitInfo.refCategoryPD
                local iUnitTechLevel = M28UnitInfo.GetUnitTechLevel(oUnit)
                if iUnitTechLevel == 2 then
                    iCategoryToSearch = iCategoryToSearch - categories.TECH1
                elseif iUnitTechLevel == 3 then
                    iCategoryToSearch = iCategoryToSearch - categories.TECH1 - categories.TECH2
                elseif iUnitTechLevel == 4 then
                    iCategoryToSearch = iCategoryToSearch * categories.EXPERIMENTAL
                end--]]
                local tNearbyEnemiesOfCategory = EntityCategoryFilterDown(iCategoryToSearch, tLZTeamData[M28Map.reftoNearestDFEnemies])
                local iClosestEnemyOfCategory = 10000
                local iCurDistOfCategory
                local iCurHealth
                local iLowestHealth = 10000000
                local oEnemyWeAreInRangeOf
                local iClosestEnemyWeAreInRangeOf = 100000
                if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack - Is tNearbyEnemiesOfCategory empty='..tostring(M28Utilities.IsTableEmpty(tNearbyEnemiesOfCategory))) end
                if M28Utilities.IsTableEmpty(tNearbyEnemiesOfCategory) == false then
                    for iEnemy, oEnemy in tNearbyEnemiesOfCategory do
                        if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack - Considering oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; Is this the same as nearest enemy to midpoint='..tostring(oEnemy == oNearestEnemyToFriendlyBase)..'; Fraction complete='..oEnemy:GetFractionComplete()) end
                        if oEnemy:GetFractionComplete() == 1 then
                            iCurHealth = oEnemy:GetHealth()
                            if oUnit.MyShield.GetHealth then
                                iCurHealth = iCurHealth + oUnit.MyShield:GetHealth()
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack -  Considering if we want to manually attack enemy unit '..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; iCurHelath='..iCurHealth..'; iLowestHealth='..iLowestHealth..'; Can see unit='..tostring(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemy))..'; Distance ot unit='..M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())..'; iCurHealth < iLowestHealth ='..tostring(iCurHealth < iLowestHealth )..'; Both conditions='..tostring(iCurHealth < iLowestHealth and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemy, true))) end
                            --if iCurHealth < iLowestHealth and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemy) then
                            iCurDistOfCategory = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())
                            iClosestEnemyOfCategory = math.min(iClosestEnemyOfCategory, iCurDistOfCategory)
                            if iCurDistOfCategory <= oUnit[M28UnitInfo.refiDFRange] + 2 and iCurHealth < iLowestHealth and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemy) then
                                iLowestHealth = iCurHealth
                                oManualAttackTarget = oEnemy
                                if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack - Setting manual attack target to this enemy') end
                            elseif iCurDistOfCategory <= (oEnemy[M28UnitInfo.refiDFRange] or 0) and iCurDistOfCategory < iClosestEnemyWeAreInRangeOf and (oEnemy[M28UnitInfo.refiUnitMassCost] or GetUnitMassCost(oEnemy)) > 2000 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy unit can attack us and has a notable mass cost so will move towards it, time since last weapon event='..(GetGameTimeSeconds() - (oEnemy[M28UnitInfo.refiLastWeaponEvent] or 0))) end
                                oEnemyWeAreInRangeOf = oEnemy
                                iClosestEnemyWeAreInRangeOf = iCurDistOfCategory
                            end
                            --elseif bDebugMessages == true then LOG(sFunctionRef..': Enemy is too high health or we cant see it')
                            --end
                        end
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack -  Finished searhcing for oManualAttackTarget='..(oManualAttackTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oManualAttackTarget) or 'nil')) end
                if not(oManualAttackTarget) and oEnemyWeAreInRangeOf then oManualAttackTarget = oEnemyWeAreInRangeOf bMoveTowardsTarget = true end
                --non-kiting experimental specific (i.e. GC, Ythotha, Megalith) - if are in a dif zone to the assigned zone then do getunitsaroundpoint to check no enemy experimentals or ACUs almost within range
                if not(oManualAttackTarget) then
                    if not(oUnit[M28UnitInfo.refbCanKite]) and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oUnit.UnitId) and not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                        local tNearbyEnemyExperimentals = oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryLandExperimental + categories.COMMAND, oUnit:GetPosition(), oUnit[M28UnitInfo.refiDFRange] + 2, 'Enemy')
                        if M28Utilities.IsTableEmpty(tNearbyEnemyExperimentals) == false then
                            for iEnemy, oEnemy in tNearbyEnemyExperimentals do
                                if oEnemy:GetFractionComplete() == 1 then
                                    iCurHealth = oEnemy:GetHealth()
                                    if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack exp backup search -  Considering if we want to manually attack enemy unit '..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; iCurHelath='..iCurHealth..'; iLowestHealth='..iLowestHealth..'; Can see unit='..tostring(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemy))..'; Distance ot unit='..M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())..'; iCurHealth < iLowestHealth ='..tostring(iCurHealth < iLowestHealth )..'; Both conditions='..tostring(iCurHealth < iLowestHealth and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemy, true))) end
                                    if iCurHealth < iLowestHealth and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemy) then
                                        iCurDistOfCategory = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())
                                        iClosestEnemyOfCategory = math.min(iClosestEnemyOfCategory, iCurDistOfCategory)
                                        if iCurDistOfCategory <= oUnit[M28UnitInfo.refiDFRange] + 2 then
                                            iLowestHealth = iCurHealth
                                            oManualAttackTarget = oEnemy
                                            bMoveTowardsTarget = false
                                            if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack exp backup search - Setting manual attack target to this enemy') end
                                        elseif bDebugMessages == true then LOG(sFunctionRef..': exp backup Enemy is too far away')
                                        end
                                    elseif bDebugMessages == true then LOG(sFunctionRef..': exp backup Enemy is too high health or we cant see it')
                                    end
                                end
                            end
                        end
                    end

                    --Consider targeting T3 land for ythotha - will do by doing attack move
                    if not(oManualAttackTarget) and iClosestEnemyOfCategory >= math.max(oUnit[M28UnitInfo.refiDFRange] + 10, 70) and EntityCategoryContains(M28UnitInfo.refCategoryYthotha, oUnit.UnitId) then
                        --If we alreayd have a target that is in range then stick with this if we are near it
                        local iCurAngleDif
                        local iClosestAngleDif = 1000
                        local iYthothaAngle = M28UnitInfo.GetUnitFacingAngle(oUnit)

                        local oExistingAttackTarget = oUnit[M28Orders.reftiLastOrders][M28Orders.refiOrderCount][M28Orders.subrefoOrderUnitTarget]
                        if M28UnitInfo.IsUnitValid(oExistingAttackTarget) and M28Utilities.GetDistanceBetweenPositions(oExistingAttackTarget:GetPosition(), oUnit:GetPosition()) <= oUnit[M28UnitInfo.refiDFRange] + 1 then
                            --Record closest angle dif and reduce by 15 so we wont switch targets to another unit if it wouldnt be that much of an improvement
                            iClosestAngleDif = math.max(0, M28Utilities.GetAngleDifference(iYthothaAngle, M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oExistingAttackTarget:GetPosition())) - 15)
                        end
                        if iClosestAngleDif > 30 then --i.e. 45+ angle dif since we reduce it by 15 in the above step
                            local tOtherPriorityTargets = EntityCategoryFilterDown(M28UnitInfo.refCategoryMobileDFLand * categories.TECH3 - M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryT3PD, tLZTeamData[M28Map.reftoNearestDFEnemies])
                            if bDebugMessages == true then LOG(sFunctionRef..': Is tOtherPriorityTargets empty='..tostring(M28Utilities.IsTableEmpty(  tOtherPriorityTargets))) end
                            if M28Utilities.IsTableEmpty(  tOtherPriorityTargets) == false then
                                for iEnemy, oEnemy in tOtherPriorityTargets do
                                    if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack - Considering ythotha t3 oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; Is this the same as nearest enemy to midpoint='..tostring(oEnemy == oNearestEnemyToFriendlyBase)..'; Fraction complete='..oEnemy:GetFractionComplete()..'; Unit max health='..oEnemy:GetMaxHealth()..'; Can see unit='..tostring(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemy))..'; Dist to us='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemy:GetPosition())..'; Angle dif='..M28Utilities.GetAngleDifference(iYthothaAngle, M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oEnemy:GetPosition()))..'; Closest dif='..iClosestAngleDif) end
                                    if oEnemy:GetFractionComplete() == 1 then
                                        if oEnemy:GetMaxHealth() >= 2000 and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemy) then
                                            iCurDistOfCategory = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())
                                            iClosestEnemyOfCategory = math.min(iClosestEnemyOfCategory, iCurDistOfCategory)
                                            if iCurDistOfCategory <= oUnit[M28UnitInfo.refiDFRange] then
                                                iCurAngleDif = M28Utilities.GetAngleDifference(iYthothaAngle, M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oEnemy:GetPosition()))
                                                if iCurAngleDif < iClosestAngleDif then
                                                    iClosestAngleDif = iCurAngleDif
                                                    oManualAttackTarget = oEnemy
                                                    bMoveTowardsTarget = false
                                                    if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack - Setting ythotha manual attack target to this enemy') end
                                                end

                                            elseif bDebugMessages == true then LOG(sFunctionRef..': Enemy is too far away for ythotha to target')
                                            end
                                        end
                                    end
                                end
                            end
                        elseif bDebugMessages == true then LOG(sFunctionRef..': Will stick with existing manual attack target')
                        end
                    end
                end
                if oManualAttackTarget then
                    --Is nearest enemy to midpoitn a better target?
                    local aiBrain = oUnit:GetAIBrain()
                    if not(oManualAttackTarget == oNearestEnemyToFriendlyBase) and EntityCategoryContains(iCategoryToSearch, oNearestEnemyToFriendlyBase.UnitId) and oNearestEnemyToFriendlyBase:GetFractionComplete() == 1 then
                        if oNearestEnemyToFriendlyBase:GetHealth() < iLowestHealth and M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition()) <= oUnit[M28UnitInfo.refiDFRange] + 2 then
                            if M28UnitInfo.CanSeeUnit(aiBrain, oNearestEnemyToFriendlyBase) then
                                oManualAttackTarget = oNearestEnemyToFriendlyBase
                                bMoveTowardsTarget = false
                            else
                                oManualAttackTarget = nil
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..':GetManualAttackTargetIfWantManualAttack - Finished checking if nearest enemy to midpoint is better target, oManualAttackTarget='..(oManualAttackTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oManualAttackTarget) or 'nil')..'; Nearest enemy to midpoint health='.. oNearestEnemyToFriendlyBase:GetHealth()) end
                    end
                    if oManualAttackTarget then
                        --Look for shields that are covering this
                        local tShieldsCoveringTarget = M28Logic.IsTargetUnderShield(aiBrain, oManualAttackTarget, 0, false, false, false, false, true)
                        if M28Utilities.IsTableEmpty(tShieldsCoveringTarget) == false then
                            local iLowestHealthShield = 1000000
                            local oLowestHealthShield, iCurShieldHealth, iMaxShieldHealth

                            for iShield, oShield in tShieldsCoveringTarget do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering oShield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; Is valid='..tostring(M28UnitInfo.IsUnitValid(oShield))..'; Can see unit='..tostring( M28UnitInfo.CanSeeUnit(aiBrain, oShield))) end
                                if M28UnitInfo.IsUnitValid(oShield) and M28UnitInfo.CanSeeUnit(aiBrain, oShield) then
                                    iCurShieldHealth, iMaxShieldHealth = M28UnitInfo.GetCurrentAndMaximumShield(oShield, false)
                                    if bDebugMessages == true then LOG(sFunctionRef..': iCurShieldHealth='..iCurShieldHealth..'; iMaxShieldHealth='..iMaxShieldHealth) end
                                    if iMaxShieldHealth >= 5000 and iCurShieldHealth < iLowestHealthShield and not(M28UnitInfo.IsUnitUnderwater(oShield)) then
                                        oLowestHealthShield = oShield
                                        iLowestHealthShield = iCurShieldHealth
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': oLowestHealthShield='..(oLowestHealthShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oLowestHealthShield) or 'nil')) end
                            if oLowestHealthShield then
                                --Switch target to the shield
                                oManualAttackTarget = oLowestHealthShield
                                if M28Utilities.GetDistanceBetweenPositions(oLowestHealthShield:GetPosition(), oUnit:GetPosition()) > oUnit[M28UnitInfo.refiDFRange] + 4 then
                                    bMoveTowardsTarget = true
                                end
                            end
                        end
                    end
                end
            end
        end
        if not(oManualAttackTarget) and iAvailableCombatUnitThreat <= 120 and oUnit[M28UnitInfo.refiUnitMassCost] <= 60 and oNearestEnemyToFriendlyBase:GetHealth() >= 300 and ((oNearestEnemyToFriendlyBase[M28UnitInfo.refiCombatRange] or 0) == 0 or oNearestEnemyToFriendlyBase:GetFractionComplete() < 0.8) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false and not(EntityCategoryContains(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryRadar + categories.VOLATILE, oNearestEnemyToFriendlyBase.UnitId)) then
            --if nearest enemy has lots of health consider vulnerable nearby targets such as engineers and radar (e.g. one scenario to avoid is a LAB attack-moving at a land factory, when there is an engineer building the factory behind it)
            local tPotentiallyVulnerableEnemyUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryRadar + M28UnitInfo.refCategoryEngineer + categories.VOLATILE, tLZTeamData[M28Map.subrefTEnemyUnits])
            if bDebugMessages == true then LOG(sFunctionRef..': Considering vulnerable units as have low threat, is tPotentiallyVulnerableEnemyUnits empty='..tostring(M28Utilities.IsTableEmpty(tPotentiallyVulnerableEnemyUnits))) end
            local iClosestDist = 40
            if M28Utilities.IsTableEmpty(tPotentiallyVulnerableEnemyUnits) == false then
                local iCurDist
                for iEnemyUnit, oEnemyUnit in tPotentiallyVulnerableEnemyUnits do
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oEnemyUnit:GetPosition(), oUnit:GetPosition())
                    if iCurDist < iClosestDist then
                        oManualAttackTarget = oEnemyUnit
                        iClosestDist = iCurDist
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have engineer or radar or volatile unit to target with weak DF unit such as a lab, oManualAttackTarget='..(oManualAttackTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oManualAttackTarget) or 'nil')) end
                --If closest unit is a unit under construction then a player would recognise there will be a nearby engineer even if we havent had intel of it yet
            end
            if not(oManualAttackTarget) and oNearestEnemyToFriendlyBase:GetFractionComplete() < 1 and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oNearestEnemyToFriendlyBase.UnitId) then
                local tNearbyEngineers = oNearestEnemyToFriendlyBase:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryEngineer, oNearestEnemyToFriendlyBase:GetPosition(), 15, 'Ally')
                if bDebugMessages == true then LOG(sFunctionRef..': Is tNearbyEngineers empty='..tostring(M28Utilities.IsTableEmpty(tNearbyEngineers))) end
                if M28Utilities.IsTableEmpty(tNearbyEngineers) == false then
                    oManualAttackTarget = M28Utilities.GetNearestUnit(tNearbyEngineers, oUnit:GetPosition())
                end
            end

            if oManualAttackTarget then
                if iClosestDist > oUnit[M28UnitInfo.refiDFRange] or not(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit, false)) then
                    bMoveTowardsTarget = true
                end
            end
        end
        --Blocked longer ranged non-exp but still valuable DF units (since exp already run more detailed logic above I think) - consider manual target on dangerous enemy in range of us; example that prompted this was salems ignoring enemy SACUs (nearst non-combat unit had cliff blockign shots, salems wanted to advance to enemy nearby exp that wasnt yet in range, allowing sacus to get free kill)
        if not(oManualAttackTarget) and (oUnit[M28UnitInfo.refiDFRange] or 0) > 35 and (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) < 15000 and oUnit[M28UnitInfo.refiUnitMassCost] >= 400 then
            if bDebugMessages == true then LOG(sFunctionRef..': Longer ranged non-Exp DF unit - considering if it is in range of an enemy unit, in which case consider manually attacking that enemy unit') end
            local iDistToEnemy
            if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                iDistToEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition())
                if bDebugMessages == true then LOG(sFunctionRef..': Considering refoClosestEnemyFromLastCloseToEnemyUnitCheck, iDistToEnemy='..iDistToEnemy) end
                if ((iDistToEnemy < oUnit[M28UnitInfo.refiCombatRange] - 10) or (iDistToEnemy < oUnit[M28UnitInfo.refiCombatRange] and iDistToEnemy <= 2 + (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiCombatRange] or 0))) and oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiCombatRange] > 0 and not(M28Logic.IsShotBlocked(oUnit, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], false, nil)) then
                    oManualAttackTarget = oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]
                end
            end
            if not(oManualAttackTarget) and oNearestEnemyToFriendlyBase and not(oNearestEnemyToFriendlyBase == oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                iDistToEnemy = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition())
                if bDebugMessages == true then LOG(sFunctionRef..': Considering oNearestEnemyToFriendlyBase, iDistToEnemy='..iDistToEnemy) end
                if ((iDistToEnemy < oUnit[M28UnitInfo.refiCombatRange] - 10) or (iDistToEnemy < oUnit[M28UnitInfo.refiCombatRange] and iDistToEnemy <= 2 + (oNearestEnemyToFriendlyBase[M28UnitInfo.refiCombatRange] or 0))) and oNearestEnemyToFriendlyBase[M28UnitInfo.refiCombatRange] > 0 and not(M28Logic.IsShotBlocked(oUnit, oNearestEnemyToFriendlyBase, false, nil)) then
                    oManualAttackTarget = oNearestEnemyToFriendlyBase
                end
                if bDebugMessages == true then LOG(sFunctionRef..': oManualAttackTarget after check='..(oManualAttackTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oManualAttackTarget) or 'nil')) end
            end
        end
        return oManualAttackTarget, bMoveTowardsTarget
    end

    function RecordDFLandZoneTarget(iLandZoneTarget, iAttackType)
        --Send nil value to clear previously recorded values
        if not(iLandZoneTarget) then
            if tLZTeamData[M28Map.subreftiLandZoneTargetedByOurDF] then
                local tTargetingLandZoneTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tLZTeamData[M28Map.subreftiLandZoneTargetedByOurDF]][M28Map.subrefLZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': About to update for iPlateau='..iPlateau..'subreftiLandZoneTargetedByOurDF='..(tLZTeamData[M28Map.subreftiLandZoneTargetedByOurDF] or 'nil')..'; is tTargetingLandZoneTeamData nil='..tostring(tTargetingLandZoneTeamData == nil)) end
                if not(tTargetingLandZoneTeamData[M28Map.subreftiLandZonesTargetingThisWithOurDF]) then tTargetingLandZoneTeamData[M28Map.subreftiLandZonesTargetingThisWithOurDF] = {} end
                tTargetingLandZoneTeamData[M28Map.subreftiLandZonesTargetingThisWithOurDF][iLandZone] = nil
                tLZTeamData[M28Map.subreftiLandZoneTargetedByOurDF] = nil
            end
        else
            tLZTeamData[M28Map.subreftiLandZoneTargetedByOurDF] = iLandZoneTarget
            local tTargetingLandZoneTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZoneTarget][M28Map.subrefLZTeamData][iTeam]
            if tTargetingLandZoneTeamData[M28Map.subreftiLandZonesTargetingThisWithOurDF] then
                tTargetingLandZoneTeamData[M28Map.subreftiLandZonesTargetingThisWithOurDF][iLandZone] = iAttackType
            end
        end
    end
    if tLZTeamData[M28Map.subreftiLandZoneTargetedByOurDF] then RecordDFLandZoneTarget(nil) end

    local bGivenCombatUnitsOrders = false

    if bDebugMessages == true then LOG(sFunctionRef..': iFirebaseThreatAdjust='..iFirebaseThreatAdjust..'; bRunFromFirebase='..tostring(bRunFromFirebase)..'; tLZTeamData[M28Map.subreftEnemyFirebasesInRange]='..reprs(tLZTeamData[M28Map.subreftEnemyFirebasesInRange])..'; subrefiNearbyEnemyLongRangeDFThreat='..tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat]..'; Enemies in adj wZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])..'; iFirebaseCloseCombatThreat='..iFirebaseCloseCombatThreat..'; bRunFromEnemyAir='..tostring(bRunFromEnemyAir)..'; bSuicideIntoFatboyOrACU='..tostring(bSuicideIntoFatboyOrACU)) end


    --Consider retreating if dangerous enemy gunship force that our MAA are retreating from, and no enemy buildings to threaten, or friendly buildings to defend
    if not(oClosestFatboyOrACUInIslandToSuicideInto) and tLZTeamData[M28Map.refiModDistancePercent] <= 0.5 and tLZTeamData[M28Map.subrefLZTimeMAARetreatedFromGunships] and GetGameTimeSeconds() - tLZTeamData[M28Map.subrefLZTimeMAARetreatedFromGunships] <= math.max(20, iTicksPerLandCycle * 0.3) and tLZTeamData[M28Map.subrefLZSValue] <= 1000 and not(tLZTeamData[M28Map.subrefLZbCoreBase]) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]) and (tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) == 0 then
        --Retreat all units in this zone
        bGivenCombatUnitsOrders = true
        bConsiderEnemiesInAtLeastOneAdjacentZone = false
        if bDebugMessages == true then LOG(sFunctionRef..': Will retreat due to recent gunship threat and nothing significant to defend or attack') end
        for iUnit, oUnit in tAvailableCombatUnits do
            if oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone and ProceedWithUnitOrder(oUnit) then
                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tRallyPoint, tLZData[M28Map.subrefLZIslandRef],'GunShR'..iLandZone)
            end
        end
    end


    if not(bGivenCombatUnitsOrders) then

        --If we have a fatboy in our available combat units, then do getunitsaroundpoint to check for signficant threats that might not be in an adjacent zone, and then add them as direct fire units against this zone so they get incorporated into checks for nearby enemies
        local iVisibleLandCombatMassInFatboyRange = 0
        if iFriendlyBestMobileDFRange >= 90 then
            --Get fatboy closest to enemy base
            local tFriendlyFatboys = EntityCategoryFilterDown(M28UnitInfo.refCategoryFatboy, tAvailableCombatUnits)
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of friendly fatboys empty='..tostring(M28Utilities.IsTableEmpty(tFriendlyFatboys))) end
            if M28Utilities.IsTableEmpty(tFriendlyFatboys) == false then
                local oClosestFatboyToEnemy
                if not(tFriendlyFatboys[2]) then
                    oClosestFatboyToEnemy = tFriendlyFatboys[1]
                else
                    oClosestFatboyToEnemy = M28Utilities.GetNearestUnit(tFriendlyFatboys, tLZTeamData[M28Map.reftClosestEnemyBase])
                end
                if bDebugMessages == true then LOG(sFunctionRef..': oClosestFatboyToEnemy='..oClosestFatboyToEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestFatboyToEnemy)) end
                if oClosestFatboyToEnemy then
                    local tAllDangerousCombatNearFatboy = oClosestFatboyToEnemy:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryIndirectT3 + M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryDestroyer + M28UnitInfo.refCategoryBattleship + M28UnitInfo.refCategoryBattlecruiser -M28UnitInfo.refCategoryLandScout, oClosestFatboyToEnemy:GetPosition(), (oClosestFatboyToEnemy[M28UnitInfo.refiCombatRange] or 0), 'Enemy')
                    if bDebugMessages == true then LOG(sFunctionRef..': is tAllDangerousCombatNearFatboy empty='..tostring(M28Utilities.IsTableEmpty(tAllDangerousCombatNearFatboy))..'; Fatboy range='..(oClosestFatboyToEnemy[M28UnitInfo.refiDFRange] or 0)) end
                    if M28Utilities.IsTableEmpty(tAllDangerousCombatNearFatboy) == false then
                        iVisibleLandCombatMassInFatboyRange = M28UnitInfo.GetMassCostOfUnits(tAllDangerousCombatNearFatboy, true)
                        local tbAdjacentLZ = {}
                        tUnitsNearFatboyInFurtherAwayZones = {}
                        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                            tbAdjacentLZ[iAdjLZ] = true
                        end
                        tbAdjacentLZ[iLandZone] = true
                        for iEnemy, oEnemy in tAllDangerousCombatNearFatboy do
                            if bDebugMessages == true and M28UnitInfo.IsUnitValid(oEnemy) then LOG(sFunctionRef..': Have dangerous enemy '..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..' owned by '..oEnemy:GetAIBrain().Nickname..'; Assigned plateau and LZ='..repru(oEnemy[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam])..'; Adjacent LZs='..repru(tbAdjacentLZ)..'; Assigned WZ='..(oEnemy[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] or 'nil')..'; Dist from this enemy to closest fatboy='..M28Utilities.GetDistanceBetweenPositions(oClosestFatboyToEnemy:GetPosition(), oEnemy:GetPosition())..'; Fatboy range='..(oClosestFatboyToEnemy[M28UnitInfo.refiDFRange] or 'nil')) end
                            if not(tbAdjacentLZ[oEnemy[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]]) or not(oEnemy[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] == iPlateau) then
                                if M28UnitInfo.IsUnitValid(oEnemy) then
                                    if oEnemy[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] then tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] = true
                                    elseif oEnemy[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] then tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = true
                                    end
                                    table.insert(tLZTeamData[M28Map.reftoNearestDFEnemies], oEnemy)
                                    table.insert(tUnitsNearFatboyInFurtherAwayZones, oEnemy)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Adding enemy to table of nearest DF units and to units near fatboy in further away zones') end
                                end
                                --Sometimes the nearest enemy to our midpoint might be a dif unit, but this unit might still be closer to the fatboy, so want to include if its in range of the fatboy to be safe
                            elseif not(oEnemy[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) and oEnemy[M28UnitInfo.refiUnitMassCost] >= 500 then
                                if M28UnitInfo.IsUnitValid(oEnemy) then
                                    table.insert(tLZTeamData[M28Map.reftoNearestDFEnemies], oEnemy)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Unit in adj zone, will add to table of nearest DF enemies to be safe in case it isnt already recorded (will lead to some doublecounting') end
                                end
                            end
                        end
                    end
                end
            end
        end

        --Only consider if we have a fairly large force for our tech level; in which case will only send a small part of our army to deal with the enemy
        if iAvailableCombatUnitThreat >= 300 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] then
            --Consider this zone first (no point ignoring enemies in adj zone if wont be ignoring in this zone); no cap as we will just send a smaller (but still large enough) force to deal with enemy threats if ignoring
            if iAvailableCombatUnitThreat >= tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 10 and iAvailableCombatUnitThreat >= (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] + tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]) * 6 then
                bIgnoreEnemiesInThisZone = true
                --Record which units in adjacent zones we should ignore
                bConsiderEnemiesInAtLeastOneAdjacentZone = false
                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                    if (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) <= 15000 and iAvailableCombatUnitThreat >= (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 10 and iAvailableCombatUnitThreat >= (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] + (tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0)) * 6 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Ignoring iAdjLZ='..iAdjLZ..' due to it having too low a threat, enemy combat total for adj LZ='..(tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)..'; iAvailableCombatUnitThreat='..(iAvailableCombatUnitThreat or 'nil')) end
                        tbAdjacentZoneEnemiesToIgnoreByZone[iAdjLZ] = true
                    else
                        bConsiderEnemiesInAtLeastOneAdjacentZone = true
                    end
                end
            end
        end

        --If enemy has units in this or adjacent LZ, then decide what to do
        if (tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) and (bSuicideIntoFatboyOrACU or not(bRunFromFirebase) and not(bRunFromEnemyAir)) then
            local tFriendlyNearbyExperimentals --used lateron if we want to assess if there is negligible neemy threat
            local iDFRangeOverrideForScenario1
            --Cloaked units - flag we want spy plane if we have any land experimentals
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if have nearby cloaked enemy units if we have a large threat, iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; Is table of cloaked enemy units empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits]))..'; iVisibleLandCombatMassInFatboyRange='..iVisibleLandCombatMassInFatboyRange) end
            if iAvailableCombatUnitThreat >= 10000 and M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits]) then
                local tFriendlyLandExperimentals = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental, tAvailableCombatUnits)
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of friendly land experimentals empty='..tostring(M28Utilities.IsTableEmpty(tFriendlyLandExperimentals))) end
                if M28Utilities.IsTableEmpty(tFriendlyLandExperimentals) == false then
                    local toExperimentalsNearCloakedUnit = {}
                    for iCloaked, oCloaked in M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits] do
                        for iExperimental, oExperimental in tFriendlyLandExperimentals do
                            if bDebugMessages == true then LOG(sFunctionRef..': oExperimental='..oExperimental.UnitId..M28UnitInfo.GetUnitLifetimeCount(oExperimental)..'; oCloaked='..oCloaked.UnitId..M28UnitInfo.GetUnitLifetimeCount(oCloaked)..'; Dist from experimental to cloaked='..M28Utilities.GetDistanceBetweenPositions(oExperimental:GetPosition(), oCloaked:GetPosition())) end
                            if M28Utilities.GetDistanceBetweenPositions(oExperimental:GetPosition(), oCloaked:GetPosition()) <= 80 then
                                table.insert(toExperimentalsNearCloakedUnit, oExperimental)
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is toExperimentalsNearCloakedUnit empty='..tostring(M28Utilities.IsTableEmpty(toExperimentalsNearCloakedUnit))) end
                    if M28Utilities.IsTableEmpty(toExperimentalsNearCloakedUnit) == false then
                        for iUnit, oUnit in toExperimentalsNearCloakedUnit do
                            M28Air.AddUnitWantingPriorityScout(oUnit)
                        end
                    end
                end
            end

            local bEnemyHasNoDFUnits
            if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] then bEnemyHasNoDFUnits = false
            else
                bEnemyHasNoDFUnits = M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies])
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Checking for nearest enemy to midpoint, bEnemyHasNoDFUnits='..tostring(bEnemyHasNoDFUnits)..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))) end

            toEnemyACUsNearZone = EntityCategoryFilterDown(categories.COMMAND, tLZTeamData[M28Map.reftoNearestDFEnemies])
            local oNearestEnemyStructureToMidpoint
            local iClosestDist = 100000
            local iClosestStructureDist = 100000
            local iCurDist
            local iEnemyBestDFRange = math.max(iEnemyBestMobileDFRange, iEnemyBestStructureDFRange)
            local bNotCloseToAdjacentPD = false
            --If enemy DF structures are in an adjacent zone then only include their range for this decision if they are near enough
            if (tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0) < iEnemyBestStructureDFRange and iEnemyBestStructureDFRange > iEnemyBestMobileDFRange and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoAdjacentStructuresWithHighRange]) == false then
                --Adjacent structures are providing the best enemy DF range; would we outrange the enemy if it wasnt for these?
                if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false and math.max((iFriendlyBestMobileDFRange or 0), (iFriendlyBestMobileIndirectRange or 0)) > math.max(iEnemyBestMobileDFRange, (tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0)) then
                    --Get enemy longer range PD in adjacent zone closest to this zone midpoint, so can see if it is almost in range of any allied units
                    local oClosestPD
                    for iUnit, oUnit in tLZTeamData[M28Map.reftoAdjacentStructuresWithHighRange] do
                        if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then --redundancy
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) - oUnit[M28UnitInfo.refiDFRange]
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oClosestPD = oUnit
                            end
                        end
                    end
                    bNotCloseToAdjacentPD = true
                    if oClosestPD and iClosestDist <= 200 then
                        local iThreshold = 10 --If within 10 of being in range then recognise the range on the unit
                        for iUnit, oUnit in tAvailableCombatUnits do
                            if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestPD:GetPosition()) - oClosestPD[M28UnitInfo.refiDFRange] - iThreshold <= 0 then
                                bNotCloseToAdjacentPD = false
                                break
                            end
                        end
                    end
                    if bNotCloseToAdjacentPD then
                        iEnemyBestStructureDFRange =     (tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0)
                        iEnemyBestDFRange = math.max(iEnemyBestMobileDFRange, iEnemyBestStructureDFRange)
                        if bDebugMessages == true then LOG(sFunctionRef..': Closest PD is far enough away from our units that we can ignore its range when deciding what scenario we are in, oClosestPD='..(oClosestPD.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestPD) or 'nil')..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iEnemyBestDFRange after update='..iEnemyBestDFRange..'; Time='..GetGameTimeSeconds()) end
                    end
                    iClosestDist = 100000
                end

            end


            local bNearestEnemyNeedsManualAttack = false --If nearest enemy is below water with its base but still visible on the top then units wont fire at it unless given a specific attack order
            local bAreInScenario1 = false --true if are in scenario 1
            local tEnemyEngineers = {} --So can avoid getting in reclaim range, and consider targeting as a priority
            local tSkirmisherDFEnemies = {}
            local tHiddenIFEnemies --If have any IF units that we lack visibility of, will add here so we can avoid with skirmishers
            local tSkirmisherEnemyT3MobileArti = {} --for e.g. sniperbots to avoid unless they have shield coverage
            local aiBrain = ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]]

            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Going through all enemy units in this zone to determine skirmisher enemies, nearest enemy to friendly base, and nearest structure') end
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefMidpoint]) then
                    --Got an error in coop so put in below as a redundancy in case had no midpoint (but couldve been another reason)
                    M28Utilities.ErrorHandler('Dont have midpoint for P'..iPlateau..'Z'..iLandZone..'; will try and rerecord')
                    M28Map.RecordMidpointAndOtherDataForZone(iPlateau, iLandZone, tLZData)
                end
                tEnemyEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subrefTEnemyUnits])
                if not(tEnemyEngineers) then tEnemyEngineers = {} end
                for iUnit, oUnit in tLZTeamData[M28Map.subrefTEnemyUnits] do
                    if not(bIgnoreEnemiesInThisZone) then
                        if oUnit.UnitId == 'xsl0101' and M28UnitInfo.GetUnitSpeed(oUnit) < 0.2 and not(M28UnitInfo.CanSeeUnit(aiBrain, oUnit, false)) then
                            --Ignore selen
                        else
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], (oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or oUnit:GetPosition()))
                            if iCurDist < iClosestDist and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) then
                                iClosestDist = iCurDist
                                oNearestEnemyToFriendlyBase = oUnit
                            end
                            if iCurDist < iClosestStructureDist and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) and oUnit:GetFractionComplete() >= 0.5 then
                                iClosestStructureDist = iCurDist
                                oNearestEnemyStructureToMidpoint = oUnit
                            end
                            if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then
                                table.insert(tSkirmisherDFEnemies, oUnit)
                                if bDebugMessages == true then LOG(sFunctionRef..': Recording enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with name '..(__blueprints[oUnit.UnitId].General.UnitName or 'nil')..' with DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..' against tSkirmisherDFEnemies') end
                            elseif (oUnit[M28UnitInfo.refiIndirectRange] or 0) > 10 then
                                if oUnit[M28UnitInfo.refiIndirectRange] > 60 and oUnit[M28UnitInfo.refiIndirectRange] < 130 and EntityCategoryContains(M28UnitInfo.refCategoryT3MobileArtillery, oUnit.UnitId) then
                                    table.insert(tSkirmisherEnemyT3MobileArti, oUnit)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Recording enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with name '..(__blueprints[oUnit.UnitId].General.UnitName or 'nil')..' with DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..' against tSkirmisherEnemyT3MobileArti') end
                                end
                                --Also check for hidden IF enemies
                                if not(M28UnitInfo.CanSeeUnit(aiBrain, oUnit, false)) then
                                    if not(tHiddenIFEnemies) then tHiddenIFEnemies = {} end
                                    table.insert(tHiddenIFEnemies, oUnit)
                                end
                            end
                        end
                    end
                end
                if not(oNearestEnemyToFriendlyBase) and M28Utilities.IsTableEmpty(toEnemyACUsNearZone) == false then
                    for iACU, oACU in toEnemyACUsNearZone do
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], oACU[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                        if iCurDist < iClosestDist then
                            iClosestDist = iCurDist
                            oNearestEnemyToFriendlyBase = oACU
                        end
                    end
                end
            end
            --More detailed check of nearby ACUs if we have an experimental, as sometimes an ACU can be in an adjacent zone near to our unit
            if M28Utilities.IsTableEmpty(toEnemyACUsNearZone) and iAvailableCombatUnitThreat >= 5000 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) == false then
                for iACU, oACU in M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs] do
                    if bDebugMessages == true then LOG(sFunctionRef..': ACU doublecheck, ACU brain='..oACU:GetAIBrain().Nickname..'; dist to this zone midpoint='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZData[M28Map.subrefMidpoint])) end
                    if not(oACU.Dead) and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= 150 then
                        table.insert(toEnemyACUsNearZone, oACU)
                    end
                end
            end
            if M28Utilities.IsTableEmpty(toEnemyACUsNearZone) == false and (iAvailableCombatUnitThreat >= 500 or (tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] >= 3000)) then
                --if iEnemyBestDFRange >= 30 then
                local iMobileDFWanted = math.min(M28UnitInfo.GetCombatThreatRating(toEnemyACUsNearZone, true), 8000)
                if bDebugMessages == true then LOG(sFunctionRef..': Threat of enemy ACUs in zone (or nearest ACU to the zone that is in adj zone)='..M28UnitInfo.GetCombatThreatRating(toEnemyACUsNearZone, true)..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]) end
                if iMobileDFWanted <= 500 or iAvailableCombatUnitThreat > iMobileDFWanted then
                    --Check that the threat of our forces near the enemy ACU is high enough to handle it as well
                    local oClosestACUToMidpoint
                    local iClosestACUDist = 10000
                    for iACU, oACU in toEnemyACUsNearZone do
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], oACU[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                        if iCurDist < iClosestACUDist then
                            iClosestACUDist = iCurDist
                            oClosestACUToMidpoint = oACU
                        end
                    end
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': oClosestACUToMidpoint='..(oClosestACUToMidpoint.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestACUToMidpoint) or 'nil'))
                        if oClosestACUToMidpoint then LOG(sFunctionRef..': ACU dist to midpoint='..M28Utilities.GetDistanceBetweenPositions(oClosestACUToMidpoint:GetPosition(), tLZData[M28Map.subrefMidpoint])) end
                    end
                    if oClosestACUToMidpoint and M28Utilities.GetDistanceBetweenPositions(oClosestACUToMidpoint:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= 200 then
                        --Include T1 arti in the threat calculation
                        --Get the closest friendly combat unit to this
                        iClosestACUDist = 10000
                        local oClosestCombatUnitToEnemyACU
                        for iUnit, oUnit in tAvailableCombatUnits do
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestACUToMidpoint:GetPosition())
                            if iCurDist < iClosestACUDist then
                                iClosestACUDist = iCurDist
                                oClosestCombatUnitToEnemyACU = oUnit
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': oClosestCombatUnitToEnemyACU='..(oClosestCombatUnitToEnemyACU.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestCombatUnitToEnemyACU) or 'nil')) end
                        if oClosestCombatUnitToEnemyACU then
                            local tFriendlyCombatNearACU = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat, oClosestCombatUnitToEnemyACU:GetPosition(), 40, 'Ally')
                            local iFriendlyFrontlineCombatThreat = M28UnitInfo.GetCombatThreatRating(tFriendlyCombatNearACU, true)
                            if iFriendlyFrontlineCombatThreat >= iMobileDFWanted then
                                --Check if enemy has significant force
                                if iFriendlyFrontlineCombatThreat >= 15000 then bConsiderAttackingACU = true
                                else
                                    local tEnemiesNearACU = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat, oClosestACUToMidpoint:GetPosition(), 35, 'Enemy')
                                    local iThreatOfEnemies = M28UnitInfo.GetCombatThreatRating(tEnemiesNearACU)
                                    if bDebugMessages == true then LOG(sFunctionRef..': iThreatOfEnemies using getunitsaroundpoint='..iThreatOfEnemies) end
                                    if iFriendlyFrontlineCombatThreat >= iThreatOfEnemies then
                                        if tLZTeamData[M28Map.refiRadarCoverage] >= 100 then
                                            bConsiderAttackingACU = true --no need for more detailed memory based check as we have good intel coverage
                                        else
                                            local tEnemyACULZData, tEnemyACULZTeamData = M28Map.GetLandOrWaterZoneData(oClosestACUToMidpoint:GetPosition(), true, iTeam)
                                            if M28Utilities.IsTableEmpty(tEnemyACULZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                                                --We might not have intel of enemy threat - do more detailed calculation based on enemy DF units
                                                local toNearbyOtherDFEnemies = {}
                                                --Include enemies almost in range of the enemy ACU's position
                                                for iUnit, oUnit in tEnemyACULZTeamData[M28Map.reftoNearestDFEnemies] do
                                                    if not(oUnit.Dead) and not(oUnit == oClosestACUToMidpoint) and oUnit[M28UnitInfo.refiDFRange] and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestACUToMidpoint:GetPosition()) - oUnit[M28UnitInfo.refiDFRange] <= 10 then
                                                        table.insert(toNearbyOtherDFEnemies, oUnit)
                                                    end
                                                end
                                                iThreatOfEnemies = M28UnitInfo.GetCombatThreatRating(toNearbyOtherDFEnemies) + iMobileDFWanted
                                                if bDebugMessages == true then LOG(sFunctionRef..': iThreatOfEnemies based on mroe detailed memory based check='..iThreatOfEnemies) end
                                                if iFriendlyFrontlineCombatThreat >= iThreatOfEnemies * 0.95 then
                                                    bConsiderAttackingACU = true
                                                end
                                            else
                                                bConsiderAttackingACU = true
                                            end
                                        end
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iFriendlyFrontlineCombatThreat='..iFriendlyFrontlineCombatThreat..'; iClosestACUDist='..iClosestACUDist..'; oClosestCombatUnitToEnemyACU='..oClosestCombatUnitToEnemyACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestCombatUnitToEnemyACU)..'; Closest enemy ACU is owned by '..oClosestACUToMidpoint:GetAIBrain().Nickname) end
                        end
                    end
                end
                --[[else
                    bConsiderAttackingACU = true
                    if bDebugMessages == true then LOG(sFunctionRef..': iEnemyBestDFRange isnt at least 30 so will consider attacking ACU, iEnemyBestDFRange='..iEnemyBestDFRange) end
                end--]]
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished deciding if we want to try and attack enemy ACU, bConsiderAttackingACU='..tostring(bConsiderAttackingACU or false)..'; Is table of enemy ACUs near zone empty='..tostring(M28Utilities.IsTableEmpty(toEnemyACUsNearZone))) end

            local bOnlyCheckForStructureOrDF = true
            if not(oNearestEnemyToFriendlyBase) then bOnlyCheckForStructureOrDF = false end



            function GetUnitToAttackNearestACUOrOverrideUnit(oUnit, oACUOverride)
                local oClosestACUToAttack
                local iClosestACU = 100000
                local iCurACUDist
                local iDistToBeInRange = 5
                if oClosestFatboyOrACUInIslandToSuicideInto and EntityCategoryContains(categories.COMMAND, oClosestFatboyOrACUInIslandToSuicideInto.UnitId) then iDistToBeInRange = 12 end
                if oACUOverride then
                    oClosestACUToAttack = oACUOverride
                    iClosestACU = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACUOverride:GetPosition())
                else
                    for iACU, oACU in toEnemyACUsNearZone do
                        iCurACUDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())
                        if iCurACUDist < iClosestACU then
                            iClosestACU = iCurACUDist
                            oClosestACUToAttack = oACU
                        end
                    end
                end
                if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oUnit.UnitId) then RecordAttackingExperimental(tLZTeamData, oUnit) end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' should do attack order on ACU or move to it, iClosestACU='..iClosestACU..'; oUnit[M28UnitInfo.refiDFRange]='..oUnit[M28UnitInfo.refiDFRange]..'; oUnit[M28UnitInfo.refbLastShotBlocked]='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked] or false)..'; Do we expect shot to be blocked='..tostring(M28Logic.IsShotBlocked(oUnit, oClosestACUToAttack))..'; iDistToBeInRange='..iDistToBeInRange) end

                if (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) >= 15000 and oUnit[M28UnitInfo.refiCombatRange] <= 64 and (oUnit[M28UnitInfo.refiDFRange] <= 50 or oUnit.UnitId == 'url0402') and oUnit:GetMaxHealth() >= 40000 then --IF CHANGING HERE THEN CHANGE ABOVE AS WELL
                    if bDebugMessages == true then LOG(sFunctionRef..': Will suicide experimental into ACU') end
                    ForkThread(M28Micro.SuicideExperimentalIntoEnemyACU, oUnit, oClosestACUToAttack)
                end
                if not(oUnit[M28UnitInfo.refbSpecialMicroActive]) then
                    if (oUnit[M28UnitInfo.refiCombatRange] or 0) - iClosestACU >= iDistToBeInRange and (not(oUnit[M28UnitInfo.refbLastShotBlocked]) and (not(EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oUnit.UnitId)) or (oUnit[M28UnitInfo.refiDFRange] or 0) == 0 or not(M28Logic.IsShotBlocked(oUnit, oClosestACUToAttack)))) then --ACU more than 5 inside our range - attack it unless our shot is blocked
                        M28Orders.IssueTrackedAttack(oUnit, oClosestACUToAttack, false, 'ACUEAt', false)
                    else
                        M28Orders.IssueTrackedMove(oUnit, oClosestACUToAttack:GetPosition(), (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.4, false, 'ACUEMv'..iLandZone, false)
                    end
                end
            end

            function SuicideUnitIntoEnemyStructure(oUnit)
                --Consider running from nearby enemy engineers
                local bRunningFromEngi = false
                if M28Utilities.IsTableEmpty(tEnemyEngineers) == false and oUnit[M28UnitInfo.refiLastWeaponEvent] then
                    if bDebugMessages == true then LOG(sFunctionRef..': Time since unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' fired its weapon last='..GetGameTimeSeconds() -oUnit[M28UnitInfo.refiLastWeaponEvent]..'; Time between IF shots='..oUnit[M28UnitInfo.refiTimeBetweenIFShots]) end
                    if GetGameTimeSeconds() - oUnit[M28UnitInfo.refiLastWeaponEvent] < oUnit[M28UnitInfo.refiTimeBetweenIFShots] - 2.1 then
                        local oNearestEngineerToUnit = M28Utilities.GetNearestUnit(tEnemyEngineers, oUnit:GetPosition())
                        local iEngiBuildRange = math.max(4, (oNearestEngineerToUnit:GetBlueprint().Economy.MaxBuildDistance or 5)) + 1 --+1 to allow for unit sizes
                        local iDistToNearestEngi = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEngineerToUnit:GetPosition())
                        if bDebugMessages == true then LOG(sFunctionRef..': oNearestEngineerToUnit='..oNearestEngineerToUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEngineerToUnit)..'; iEngiBuildRange='..iEngiBuildRange..'; iDistToNearestEngi='..iDistToNearestEngi) end
                        if iDistToNearestEngi <= 3 + iEngiBuildRange then --to allow for engi to move inbetween firing
                            local iAngleFromEngiToUnit = M28Utilities.GetAngleFromAToB(oNearestEngineerToUnit:GetPosition(), oUnit:GetPosition())
                            local tPotentialMoveLocation = M28Utilities.MoveInDirection(oNearestEngineerToUnit:GetPosition(), iAngleFromEngiToUnit, iEngiBuildRange + 6, true, true, M28Map.bIsCampaignMap)
                            if bDebugMessages == true then LOG(sFunctionRef..': Plateau label of tPotentialMoveLocation='..(NavUtils.GetLabel(M28Map.refPathingTypeHover, tPotentialMoveLocation) or 'nil')..'; iPlateau='..iPlateau) end
                            if tPotentialMoveLocation and NavUtils.GetLabel(M28Map.refPathingTypeHover, tPotentialMoveLocation) == iPlateau then
                                bRunningFromEngi = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Will try and run from the engineer') end
                                M28Orders.IssueTrackedMove(oUnit, tPotentialMoveLocation, 1, false, 'ArtRnFrE', false)
                            end
                        end
                    end
                end
                if not(bRunningFromEngi) then
                    --Get closest unit of preferred category
                    local tBuildingsOfInterestInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tLZTeamData[M28Map.subrefTEnemyUnits])
                    local oUnitToAttack
                    if M28Utilities.IsTableEmpty(tBuildingsOfInterestInZone) == false then
                        --Get units iwthin range, and then pick the preferred one
                        local iCurValue, iValueFactor
                        local iBestValue = 0
                        for iEnemy, oEnemy in tBuildingsOfInterestInZone do
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())
                            if iCurDist <= oUnit[M28UnitInfo.refiCombatRange] + 16 then
                                --Adjust value based on category
                                if EntityCategoryContains(categories.VOLATILE - M28UnitInfo.refCategoryT1Power, oEnemy.UnitId) then
                                    iValueFactor = 4
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryPD, oEnemy.UnitId) then
                                    iValueFactor = 1.5
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryPower - M28UnitInfo.refCategoryT1Power, oEnemy.UnitId) then
                                    iValueFactor = 2.1 --so a T1 mex should have more value than a T1 pgen
                                    if oEnemy:GetWorkProgress() >= 0.05 then --Reason for htis is that a human palyer will usually be able ot use intuition to target upgraidng mexes, since players typically upgrade mexes in order, and are likely to have engineers near an upgrading mex, as well as some being at T2 some at T1, but want to avoid the significant cpu load from trying to mathematically approximate such intuition
                                        if EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oEnemy.UnitId) then
                                            iValueFactor = 2 + 40 * oEnemy:GetWorkProgress() --T2 mex costs roughly 25 times a t1 mex, but we are treating eco damage as worth twice as much
                                            if bDebugMessages == true then LOG(sFunctionRef..': T1 mex upgrading to t2 so greater priority, oEnemy:GetWorkProgress()='..oEnemy:GetWorkProgress()) end
                                        elseif EntityCategoryContains(M28UnitInfo.refCategoryT2Mex, oEnemy.UnitId) then
                                            iValueFactor = 2 + 7 * oEnemy:GetWorkProgress() --T3 mex costs 5 times t2 mex, but we are valuing eco damage at double rate
                                        else
                                            iValueFactor = 2 + 3 * oEnemy:GetWorkProgress() --e.g. support for mods with upgradable pgens
                                        end
                                    end
                                else
                                    iValueFactor = 1
                                end
                                --Reduce value if not actually in range
                                if iCurDist > oUnit[M28UnitInfo.refiCombatRange] then
                                    iValueFactor = iValueFactor * 0.25
                                end
                                --Reduce value if covered by shields
                                if M28Utilities.IsTableEmpty(oEnemy[M28Building.reftoShieldsProvidingCoverage]) == false then
                                    iValueFactor = iValueFactor * 0.05
                                end
                                --Reduce value if owned by civilian
                                if M28Conditions.IsCivilianBrain(oEnemy:GetAIBrain()) then iValueFactor = iValueFactor * 0.05 end
                                --Reduce value if we'd have to move a bit to get in range
                                if iCurDist > oUnit[M28UnitInfo.refiCombatRange] + 6 then
                                    iValueFactor = iValueFactor * 0.2
                                end

                                iCurValue = iValueFactor * oEnemy:GetFractionComplete() * (oEnemy[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oEnemy))
                                --Now figure out how quickly we can kill the unit, and adjust the value by that
                                local iShotsToKill = math.floor(oEnemy:GetHealth() / (oUnit[M28UnitInfo.refiStrikeDamage] or 200)) + 1
                                iCurValue = iCurValue / math.max(2, iShotsToKill) --2 shots to kill min since likely we have multiple t1 arti in the zone, so want to avoid e.g. all of them trying to focus down an enemy t1 radar
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; iCurValue='..iCurValue..'; iValueFactor='..iValueFactor..'; Mass cost='..oEnemy[M28UnitInfo.refiUnitMassCost]..'; iShotsToKill='..iShotsToKill..'; ICurDist='..iCurDist..'; Unit combat range='..oUnit[M28UnitInfo.refiCombatRange]..'; Work progress='..(oEnemy:GetWorkProgress() or 'nil')..'; Fraction complete='..oEnemy:GetFractionComplete()..'; Is table of shields providing coverage empty='..tostring(M28Utilities.IsTableEmpty(oEnemy[M28Building.reftoShieldsProvidingCoverage]))) end
                                if iCurValue > iBestValue then
                                    iBestValue = iCurValue
                                    oUnitToAttack = oEnemy
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Finsihed considering all buildings in zone, iBestValue='..iBestValue) end
                    end
                    if not(oUnitToAttack) then oUnitToAttack = oNearestEnemyStructureToMidpoint end
                    if M28Utilities.GetDistanceBetweenPositions(oUnitToAttack:GetPosition(), oUnit:GetPosition()) <= oUnit[M28UnitInfo.refiCombatRange] + 2 then
                        M28Orders.IssueTrackedAttack(oUnit, oUnitToAttack, false, 'ISDrAtc'..iLandZone, false)
                    else
                        M28Orders.IssueTrackedAggressiveMove(oUnit, oUnitToAttack[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 15, false, 'IKADrMve'..iLandZone)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': T1 arti drop or similar, oUnitToAttack='..(oUnitToAttack.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitToAttack) or 'nil')) end
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to search adjacent land zones for enemies closer to the midpoint; bOnlyCheckForStructureOrDF='..tostring(bOnlyCheckForStructureOrDF)..'; oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase) or 'nil')..'; oNearestEnemyStructureToMidpoint='..(oNearestEnemyStructureToMidpoint.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyStructureToMidpoint) or 'nil')) end
            local bEnemyHasFixedShieldsInThisOrAdjacentZone = false
            if (tLZTeamData[M28Map.subrefThreatEnemyShield] or 0) > 0 then bEnemyHasFixedShieldsInThisOrAdjacentZone = true end

            local iModifiedHighestEnemyValue
            if iAvailableCombatUnitThreat >= 300 then
                iModifiedHighestEnemyValue = (tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) + (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) + (tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)
                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                    iModifiedHighestEnemyValue = math.max(1, iModifiedHighestEnemyValue, (tAdjLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) + (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0))
                end
            end
            if iModifiedHighestEnemyValue then iModifiedHighestEnemyValue = iModifiedHighestEnemyValue * 0.75 end --dont worry about adjusting distances if have locations similar in value
            if bDebugMessages == true then LOG(sFunctionRef..': iModifiedHighestEnemyValue='..(iModifiedHighestEnemyValue or 'nil')) end
            local iDistMod
            function UpdateForUnitsInAdjacentZone(tAdjLZTeamData)
                if bDebugMessages == true then LOG(sFunctionRef..': Will update enemy engineers, skirmisher enemies, and in some casese nearest enemy unit, for units in adjacent zone') end
                if iModifiedHighestEnemyValue and iAvailableCombatUnitThreat >= 3000 and iModifiedHighestEnemyValue >= 1500 and (iModifiedHighestEnemyValue >= 5000 or (tAdjLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) < 1800) then --primarily want the logic for things like experimentals
                    iDistMod = math.max(1,3 - 2 * ((tAdjLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) + (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)) / iModifiedHighestEnemyValue) --i.e. no adjust for highest value zone, down to x3 (i.e. +200%) distance for 0 value structure zone
                    if iDistMod == 1 then iDistMod = nil end
                else
                    iDistMod = nil
                end
                for iUnit, oUnit in tAdjLZTeamData[M28Map.subrefTEnemyUnits] do
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                            table.insert(tEnemyEngineers, oUnit)
                        elseif oUnit.UnitId == 'xsl0101' and M28UnitInfo.GetUnitSpeed(oUnit) < 0.2 and not(M28UnitInfo.CanSeeUnit(aiBrain, oUnit, false)) then
                            --Ignore selen that is potentially cloaked
                        elseif (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then
                            if not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) then
                                table.insert(tSkirmisherDFEnemies, oUnit)
                                if bDebugMessages == true then LOG(sFunctionRef..': recording in tSkirmisherDFEnemies the adj zone enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with name '..(__blueprints[oUnit.UnitId].General.UnitName or 'nil')) end
                            end
                        elseif (oUnit[M28UnitInfo.refiIndirectRange] or 0) > 10 then
                            if oUnit[M28UnitInfo.refiIndirectRange] > 60 and oUnit[M28UnitInfo.refiIndirectRange] < 130 and EntityCategoryContains(M28UnitInfo.refCategoryT3MobileArtillery, oUnit.UnitId) then
                                table.insert(tSkirmisherEnemyT3MobileArti, oUnit)
                                if bDebugMessages == true then LOG(sFunctionRef..': Recording adj zone enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with name '..(__blueprints[oUnit.UnitId].General.UnitName or 'nil')..' with DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..' against tSkirmisherEnemyT3MobileArti') end
                            end --we might be controlling untis in an adjacent zone that have an enemy unit/engeiner near them
                            if not(M28UnitInfo.CanSeeUnit(aiBrain, oUnit, false)) then
                                if not(tHiddenIFEnemies) then tHiddenIFEnemies = {} end
                                table.insert(tHiddenIFEnemies, oUnit)
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurdist='..M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; iClosestDist='..iClosestDist..'; iClosestStructureDist='..iClosestStructureDist..'; iDistMod='..(iDistMod or 'nil')..'; bOnlyCheckForStructureOrDF='..tostring(bOnlyCheckForStructureOrDF)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Mass cost='..(oUnit[M28UnitInfo.refiUnitMassCost] or 'nil')..'; iDistMod='..(iDistMod or 'nil')) end
                        if bOnlyCheckForStructureOrDF then
                            if (((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) >= 50) or EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId)) and oUnit:GetFractionComplete() >= 0.5 then
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                                if iDistMod and not(EntityCategoryContains(M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryLandCombat * categories.EXPERIMENTAL, oUnit.UnitId)) then
                                    iCurDist = iCurDist * iDistMod
                                end
                                if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) then
                                    if iCurDist < iClosestStructureDist then
                                        iClosestStructureDist = iCurDist
                                        oNearestEnemyStructureToMidpoint = oUnit
                                    end
                                end
                                if iCurDist < iClosestDist then
                                    iClosestDist = iCurDist
                                    oNearestEnemyToFriendlyBase = oUnit
                                    if bDebugMessages == true then LOG(sFunctionRef..': Updated oNearestEnemyToFriendlyBase for this enemy') end
                                end
                            end
                        else
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                            if iDistMod then iCurDist = iCurDist * iDistMod end
                            if iCurDist < iClosestDist then
                                if not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) then
                                    iClosestDist = iCurDist
                                    oNearestEnemyToFriendlyBase = oUnit
                                    if bDebugMessages == true then LOG(sFunctionRef..': Updating oNearestEnemyToFriendlyBase to be this unit') end
                                end
                            end
                            if iCurDist < iClosestStructureDist and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) and oUnit:GetFractionComplete() >= 0.5 then
                                iClosestStructureDist = iCurDist
                                oNearestEnemyStructureToMidpoint = oUnit
                            end
                        end
                    end
                end
                if not(bEnemyHasFixedShieldsInThisOrAdjacentZone) and (tAdjLZTeamData[M28Map.subrefThreatEnemyShield] or 0) > 0 then bEnemyHasFixedShieldsInThisOrAdjacentZone = true end
            end
            function GetCombatThreatFromAdjacentZone(tAdjLZTeamData, bAdjustStructureThreat)
                local iAdjCombatThreat = math.max((tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 0.5, (tAdjLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0) + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0))
                if bAdjustStructureThreat and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will reduce adjacent threat by structure threat, tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]='..repru(tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange])) end
                    for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                        if iRange <= 65 then
                            iAdjCombatThreat = iAdjCombatThreat - iThreat * 0.8
                        end
                    end
                end
                return iAdjCombatThreat
            end
            local tbCurOrAdjacentZones = {[iLandZone]=true}
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    tbCurOrAdjacentZones[iAdjLZ] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]))..'; tbAdjacentZoneEnemiesToIgnoreByZone='..tostring(tbAdjacentZoneEnemiesToIgnoreByZone[iAdjLZ] or false)) end
                    if not(tbAdjacentZoneEnemiesToIgnoreByZone[iAdjLZ]) then
                        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                            UpdateForUnitsInAdjacentZone(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam])
                        end
                    end
                end
            end
            if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
                for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                    UpdateForUnitsInAdjacentZone(M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam])
                end
            end

            --Include long range DF enemies that arent in an adjacent zone into skirmisher enemies
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats]) == false then
                for iLREnemy, oLREnemy in tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if should add oLREnemy to skirmisher enemies, oLREnemy='..oLREnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLREnemy)..'; Cur assigned P='..oLREnemy[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1]..'Z'..oLREnemy[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]) end
                    if not(tbCurOrAdjacentZones[oLREnemy[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]]) or not(oLREnemy[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] == iPlateau) then
                        table.insert(tSkirmisherDFEnemies, oLREnemy)
                        if bDebugMessages == true then LOG(sFunctionRef..': Will add oLREnemy to tSkirmisherDFEnemies') end
                    end
                    --If enemy is close to nearestenemytofriendlybase then also update enemy range
                    if oLREnemy[M28UnitInfo.refiDFRange] > iEnemyBestDFRange then
                        if not(oNearestEnemyToFriendlyBase) or (M28Utilities.GetDistanceBetweenPositions(oLREnemy:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition()) - oLREnemy[M28UnitInfo.refiDFRange] <= -10 or M28Utilities.GetDistanceBetweenPositions(oLREnemy:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= 50) then
                            iEnemyBestDFRange = oLREnemy[M28UnitInfo.refiDFRange]
                            if bDebugMessages == true then LOG(sFunctionRef..': Increasing iEnemyBestDFRange to reflect LR enemy DF unit') end
                        end
                    end
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Do we have a valid oNearestEnemyToFriendlyBase='..tostring(M28UnitInfo.IsUnitValid(oNearestEnemyToFriendlyBase))..'; Are there enemies in adjacnet WZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])..'; tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])..'; oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase) or 'nil')) end

            if not(oNearestEnemyToFriendlyBase) and tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                --Consider adjacent water zone enemies (will only consider mobile - i.e. wont update nearest structure unless we're already considering the WZ for a nearest enemy to midpoint)
                local iCurWZ, iCurPond
                for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                    iCurWZ = tSubtable[M28Map.subrefAWZRef]
                    iCurPond = M28Map.tiPondByWaterZone[iCurWZ]
                    local tWZTeamData = M28Map.tPondDetails[iCurPond][M28Map.subrefPondWaterZones][iCurWZ][M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': iCurWZ='..(iCurWZ or 'nil')..'; iCurPond='..(iCurPond or 'nil')..'; tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..(tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')) end
                    if tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 or tWZTeamData[M28Map.subrefiThreatEnemyGroundAA] > 0 then
                        for iUnit, oUnit in tWZTeamData[M28Map.subrefTEnemyUnits] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to add oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; to nearest enemy to midpoint; Is it valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Is it underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; iClosestDist='..iClosestDist) end
                            if M28UnitInfo.IsUnitValid(oUnit) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) and not(EntityCategoryContains(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryHydro + M28UnitInfo.refCategoryLandScout, oUnit.UnitId)) then
                                --Do based on dist to zone midpoint instead of closest friendly base, since it coudl be really far away from this zone (but closer to our base)
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                                if iCurDist < iClosestDist then
                                    iClosestDist = iCurDist
                                    oNearestEnemyToFriendlyBase = oUnit
                                end
                                --Note - below effectively means are only considering structures in water if the WZ has combat units in it and there are no enemy units on land nearby (so isn't 100% accurate)
                                if iCurDist < iClosestStructureDist and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) and oUnit:GetFractionComplete() >= 0.5 then
                                    iClosestStructureDist = iCurDist
                                    oNearestEnemyStructureToMidpoint = oUnit
                                end
                            end
                        end
                        if oNearestEnemyToFriendlyBase then
                            --Check if need manual attack order
                            if EntityCategoryContains(M28UnitInfo.refCategoryAmphibious, oNearestEnemyToFriendlyBase.UnitId) then bNearestEnemyNeedsManualAttack = true end
                        end
                    end
                end
                if not(oNearestEnemyToFriendlyBase) and bSuicideIntoFatboyOrACU and oClosestFatboyOrACUInIslandToSuicideInto then oNearestEnemyToFriendlyBase = oClosestFatboyOrACUInIslandToSuicideInto end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished checking adjacent water zones for enemy units, iClosestDist='..iClosestDist..'; oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase) or 'nil')) end
            end
            if not(oNearestEnemyToFriendlyBase) and M28Utilities.IsTableEmpty(tUnitsNearFatboyInFurtherAwayZones) == false then
                for iUnit, oUnit in tUnitsNearFatboyInFurtherAwayZones do
                    --Do based on dist to this midpoint instead of closest friendly base since not dealing with units in this zone
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                    if iCurDist < iClosestDist then
                        iClosestDist = iCurDist
                        oNearestEnemyToFriendlyBase = oUnit
                    end
                end
            end
            if not(oNearestEnemyToFriendlyBase) then
                if not(bIgnoreEnemiesInThisZone) or bConsiderEnemiesInAtLeastOneAdjacentZone then
                    if bDebugMessages == true then LOG(sFunctionRef..': LZ has flagged it has enemies here or in adjacent LZ but couldnt find any; iPlateau='..iPlateau..'; LZ='..iLandZone) end
                    tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] = false
                end
            end

            --Update enemy best DF range to reflect closest unit (which might be a DF unit)
            if (oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0) >= 10 then
                iEnemyBestDFRange = math.max(iEnemyBestDFRange, oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange])
                if bDebugMessages == true then LOG(sFunctionRef..': Updated iEnemyBestDFRange for oNearestEnemyToFriendlyBase, oNearestEnemyToFriendlyBase DF range='..(oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 'nil')) end
                if EntityCategoryContains(categories.MOBILE, oNearestEnemyToFriendlyBase.UnitId) then iEnemyBestMobileDFRange = math.max(iEnemyBestMobileDFRange, oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange])
                else iEnemyBestStructureDFRange = math.max(iEnemyBestStructureDFRange, oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange])
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for nearest enemy unit, is it valid='..tostring(M28UnitInfo.IsUnitValid(oNearestEnemyToFriendlyBase))..'; Zone it is assigned to='..(oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] or 'nil')..'; Is table of enemy units in this zone empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))) end
            local iAdjacentDistGeneralMod = math.min(tLZData[M28Map.subrefLZMaxSegX] - tLZData[M28Map.subrefLZMinSegX], tLZData[M28Map.subrefLZMaxSegZ] - tLZData[M28Map.subrefLZMinSegZ]) * M28Map.iLandZoneSegmentSize
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) then iAdjacentDistGeneralMod = iAdjacentDistGeneralMod + 25 end
            local iDistToClosestEnemyThreshold --If nil then will ignore this check
            local oClosestFriendlyUnitToCompareTo --If nil will ignore this check; if set, then when deciding whether to include units in adajcent zones we will assess if they are likely close enough (relative to the nearest enemy unit) to be of concern to our closest friendly unit
            local iDistToClosestFriendlyThreshold
            if oNearestEnemyToFriendlyBase then
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false and oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone then
                    iDistToClosestEnemyThreshold = 30 --Include units within 30 of being in range of the closest enemy
                elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false and tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] == 0 and not(M28Utilities.bCPUPerformanceMode) then
                    local iClosestFriendlyToEnemyBaseDist = 100000
                    local iCurFriendlyDist
                    for iFriendly, oFriendly in tAvailableCombatUnits do
                        iCurFriendlyDist = M28Utilities.GetDistanceBetweenPositions(oFriendly:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase]) - (oFriendly[M28UnitInfo.refiCombatRange] or 0)
                        if iCurFriendlyDist < iClosestFriendlyToEnemyBaseDist then
                            iClosestFriendlyToEnemyBaseDist = iCurFriendlyDist
                            oClosestFriendlyUnitToCompareTo = oFriendly
                        end
                    end
                    if oClosestFriendlyUnitToCompareTo then
                        iDistToClosestFriendlyThreshold = M28Utilities.GetDistanceBetweenPositions(oClosestFriendlyUnitToCompareTo:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition()) - math.max((oNearestEnemyToFriendlyBase[M28UnitInfo.refiCombatRange] or 0), (oClosestFriendlyUnitToCompareTo[M28UnitInfo.refiCombatRange] or 0)) + 20
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': oClosestFriendlyUnitToCompareTo='..oClosestFriendlyUnitToCompareTo.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestFriendlyUnitToCompareTo)..'; iClosestFriendlyToEnemyBaseDist='..iClosestFriendlyToEnemyBaseDist..'; iDistToClosestFriendlyThreshold=;..iDistToClosestFriendlyThreshold') end

                end
            end
            function AddUnitFromAdjacentZoneToTableIfCloseEnough(tAdjLZTeamData, tNearbyAdjacentEnemies, iAdjacentDistThreshold, iStructureFurtherDistAdjust, iAngleFromClosestFriendlyUnitToMidpoint)
                --Only include units in the threat calculation if they are close enough to this LZ, or we have a firebase threat adjust
                if tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 10 then
                    iEnemyBestStructureDFRange = math.max(iEnemyBestStructureDFRange, (tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0))
                    local tPotentialEnemyUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryPD, tAdjLZTeamData[M28Map.subrefTEnemyUnits])
                    if M28Utilities.IsTableEmpty(tPotentialEnemyUnits) == false then
                        local iDistUntilInRangeOfMidpointOrClosestEnemy
                        local bAdd = false
                        for iUnit, oUnit in tPotentialEnemyUnits do
                            bAdd = false
                            if oUnit:GetFractionComplete() >= 0.95 and M28UnitInfo.IsUnitValid(oUnit) then
                                iDistUntilInRangeOfMidpointOrClosestEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                if oNearestEnemyToFriendlyBase then iDistUntilInRangeOfMidpointOrClosestEnemy = math.min(iDistUntilInRangeOfMidpointOrClosestEnemy, M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition())) end
                                iDistUntilInRangeOfMidpointOrClosestEnemy = iDistUntilInRangeOfMidpointOrClosestEnemy - math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0))
                                if bDebugMessages == true then LOG(sFunctionRef..': AddUnitFromAdjacentZoneToTableIfCloseEnough: Deciding whether to add enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Dist to midpoint='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])..'; Dist to closest enemy='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition())..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; iDistToClosestEnemyThreshold='..(iDistToClosestEnemyThreshold or 'nil')..'; iDistUntilInRangeOfMidpointOrClosestEnemy='..iDistUntilInRangeOfMidpointOrClosestEnemy) end
                                if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) then
                                    if iDistUntilInRangeOfMidpointOrClosestEnemy  <= iAdjacentDistThreshold + iStructureFurtherDistAdjust + iAdjacentDistGeneralMod then
                                        if iDistUntilInRangeOfMidpointOrClosestEnemy <= iAdjacentDistGeneralMod then
                                            if bDebugMessages == true then LOG(sFunctionRef..': PD is almost within its DF range of the midpoint of target zone, oUnit[M28UnitInfo.refiDFRange]='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; iDistUntilInRangeOfMidpointOrClosestEnemy='..iDistUntilInRangeOfMidpointOrClosestEnemy) end
                                            bAdd = true
                                        elseif iDistUntilInRangeOfMidpointOrClosestEnemy * 2 <= math.min(40, iAdjacentDistThreshold + iStructureFurtherDistAdjust) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': PD is within half of the target range even after applying structure dist adj, iAdjacentDistThreshold + iStructureFurtherDistAdjust='..iAdjacentDistThreshold + iStructureFurtherDistAdjust) end
                                            bAdd = true
                                        elseif M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]), iAngleFromClosestFriendlyUnitToMidpoint) <= 50 then
                                            bAdd = true
                                            if bDebugMessages == true then LOG(sFunctionRef..': Angle dif is low enough that we are including PD, angle dif='..M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]), iAngleFromClosestFriendlyUnitToMidpoint)) end
                                        end
                                    end
                                    if bAdd and (oUnit[M28UnitInfo.refiDFRange] or 0) > iEnemyBestStructureDFRange then iEnemyBestStructureDFRange = oUnit[M28UnitInfo.refiDFRange] end

                                else
                                    if iDistUntilInRangeOfMidpointOrClosestEnemy  <= iAdjacentDistThreshold + iAdjacentDistGeneralMod then
                                        bAdd = true
                                        if (oUnit[M28UnitInfo.refiDFRange] or 0) > iEnemyBestMobileDFRange then iEnemyBestMobileDFRange = oUnit[M28UnitInfo.refiDFRange] end
                                    end
                                end
                                if bAdd then
                                    --NOTE: Added in v226 to cover scenario where ACU in AdjZB meant our tanks wouldnt attack AdjZA (in scenario 2 position)
                                    --if this leads to skirmishers suiciding into nearby enemies then may want to refine so we figure out based on the previous cycle if we were in scenario 1, 2 or 3, and we only add this check if we were in scenarios 2 or 3
                                    if not(bAreInScenario1) and iDistToClosestEnemyThreshold and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0) >= iDistToClosestEnemyThreshold then
                                        if bDebugMessages == true then LOG(sFunctionRef..': We are actually too far from the nearest enemy to friendly base so will ignore') end
                                        bAdd = false
                                    end
                                    if not(bAreInScenario1) and oClosestFriendlyUnitToCompareTo and bAdd then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Dist to closest friendly unit='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFriendlyUnitToCompareTo:GetPosition())..'; Unit combat range='..(oUnit[M28UnitInfo.refiCombatRange] or 0)..'; iDistToClosestFriendlyThreshold='..iDistToClosestFriendlyThreshold) end
                                        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFriendlyUnitToCompareTo:GetPosition()) - (oUnit[M28UnitInfo.refiCombatRange] or 0) > iDistToClosestFriendlyThreshold then
                                            bAdd = false
                                            if bDebugMessages == true then LOG(sFunctionRef..': We are too far from the closest friendly unit with this enemy unit to consider at this stage') end
                                        end
                                    end
                                end
                                if bDebugMessages == true then
                                    LOG(sFunctionRef..': Considering whether to add enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to adjacent enemies, bAdd='..tostring(bAdd)..'; iDistUntilInRangeOfMidpointOrClosestEnemy='..iDistUntilInRangeOfMidpointOrClosestEnemy..'; iAdjacentDistGeneralMod='..iAdjacentDistGeneralMod..'; iAdjacentDistThreshold='..iAdjacentDistThreshold)
                                    LOG('threat of this unit='..M28UnitInfo.GetCombatThreatRating({oUnit}, true)..'; Fraction complete='..oUnit:GetFractionComplete()..'; iDistUntilInRangeOfMidpointOrClosestEnemy of midpoint='..iDistUntilInRangeOfMidpointOrClosestEnemy..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Angle to midpoint='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])..'; iAngleFromClosestFriendlyUnitToMidpoint='..(iAngleFromClosestFriendlyUnitToMidpoint or 'nil'))
                                end
                                if bAdd then
                                    table.insert(tNearbyAdjacentEnemies, oUnit)
                                    --If this is an ACU then consider adding to table of ACUs
                                    if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                                        --Is it already in the table?
                                        local bAlreadyInTable = false
                                        if M28Utilities.IsTableEmpty(toEnemyACUsNearZone) == false then
                                            for iACU, oACU in toEnemyACUsNearZone do
                                                if oACU == oUnit then
                                                    bAlreadyInTable = true
                                                    break
                                                end
                                            end
                                        end
                                        if not(bAlreadyInTable) then
                                            table.insert(toEnemyACUsNearZone, oUnit)
                                            if bConsiderAttackingACU then
                                                --Do we still want to do this?
                                                local iMobileDFWanted = math.min(7500, M28UnitInfo.GetCombatThreatRating(toEnemyACUsNearZone, true))
                                                if iMobileDFWanted <= 3000 or tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] > iMobileDFWanted then
                                                    --Will continue attacking
                                                else
                                                    bConsiderAttackingACU = false
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have ACU in an adjacent zone that is near enough to include, iMobileDFWanted to consider attacking it='..iMobileDFWanted..'; bConsiderAttackingACU after update='..tostring(bConsiderAttackingACU)) end
                                            end
                                        end
                                    end
                                    --Also make sure the best enemy range includes any units added from adjacent zones that are close enough to be relevant (as the more general range method used isn't 100% accurate)
                                    if (oUnit[M28UnitInfo.refiDFRange] or 0) > iEnemyBestDFRange then
                                        --If this exceeds our best DF range then are no longer in scenario1
                                        if bAreInScenario1 and not(iDFRangeOverrideForScenario1) and (iEnemyBestDFRange <= iFriendlyBestMobileDFRange or iEnemyBestDFRange < iFriendlyBestMobileIndirectRange) and oUnit[M28UnitInfo.refiDFRange] >= iFriendlyBestMobileDFRange and oUnit[M28UnitInfo.refiDFRange] >= iFriendlyBestMobileIndirectRange and ((oUnit[M28UnitInfo.refiDFRange] > iFriendlyBestMobileDFRange or (oUnit[M28UnitInfo.refiDFRange] == iFriendlyBestMobileDFRange and oUnit[M28UnitInfo.refiDFRange] > iFriendlyBestMobileIndirectRange)))  then
                                            bAreInScenario1 = false
                                            bDebugMessages = true
                                            if bDebugMessages == true then LOG(sFunctionRef..': Are no longer in scenario 1 as have nearby enemy that outranges (or equals and outranges IF) our best range') end
                                        end
                                        iEnemyBestDFRange = oUnit[M28UnitInfo.refiDFRange]
                                        if bDebugMessages == true then LOG(sFunctionRef..': Updated iEnemyBestDFRange for adjacent unit range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; bAreInScenario1='..tostring(bAreInScenario1)) end

                                    end

                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': AddUnitFromAdjacentZoneToTableIfCloseEnough - Threat of all enemy units='..M28UnitInfo.GetCombatThreatRating(tAdjLZTeamData[M28Map.subrefTEnemyUnits], true)..'; Threat of tPotentialEnemyUnits='..M28UnitInfo.GetCombatThreatRating(tPotentialEnemyUnits, true)..'; Threat of tNearbyAdjacentEnemies (which includes cumulative htreat of other adj zones before this one)='..M28UnitInfo.GetCombatThreatRating(tNearbyAdjacentEnemies, true)) end
                end
            end

            function DoManualAttack(oUnit, oTargetToManuallyAttack, sOrderDesc)
                if oUnit.UnitId == 'xsl0401' and EntityCategoryContains(M28UnitInfo.refCategoryLandCombat * categories.TECH3, oTargetToManuallyAttack.UnitId) and M28Utilities.GetDistanceBetweenPositions(oTargetToManuallyAttack:GetPosition(), oUnit:GetPosition()) <= oUnit[M28UnitInfo.refiCombatRange] then
                    local tTargetLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28UnitInfo.GetUnitFacingAngle(oUnit), 6, true)
                    M28Orders.IssueTrackedAggressiveMove(oUnit, tTargetLocation, math.min(20, oUnit[M28UnitInfo.refiCombatRange]), false, sOrderDesc..'YAM', false)
                else
                    M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, sOrderDesc, false)
                end
            end

            local iEnemyNearbyCombatThreatIfRelevant
            function GetEnemyCombatThreatInAdjacentZones()
                if not(iEnemyNearbyCombatThreatIfRelevant) then
                    local iCurAndAdjCombat = math.max((tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 0.5, (tLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0) + (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0))
                    if bDebugMessages == true then LOG(sFunctionRef..': Getting enemy combat threat, threat in this zone='..iCurAndAdjCombat) end

                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                            local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]))..'; Enemy combat='..(tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)..'; Enemy DF Structure='..(tAdjLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0)..'; Enemy DF Mobile='..(tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)) end
                            iCurAndAdjCombat = iCurAndAdjCombat + math.max((tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 0.5, (tAdjLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0) + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0))
                        end
                    end
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                        iCurAndAdjCombat = math.max(iCurAndAdjCombat, M28UnitInfo.GetCombatThreatRating(tLZTeamData[M28Map.reftoNearestDFEnemies], true))
                    end
                    iEnemyNearbyCombatThreatIfRelevant = iCurAndAdjCombat
                    if bDebugMessages == true then LOG(sFunctionRef..': Setting iEnemyNearbyCombatThreatIfRelevant=iCurAndAdjCombat='..(iCurAndAdjCombat or 'nil')) end
                end
                return iEnemyNearbyCombatThreatIfRelevant
            end
            local iEnemyCombatThreat
            local bHaveACUInTroubleAndRecentlyInCombat = nil --updated as part of CalculateNearbyEnemyCombatThreatFriendlyDFAndIfFriendlyACUInCombat, and also ProtectFriendlyACUInTroubleIfRelevant if is nil
            local bACUInCombatButProbablySafe
            local iOurDFAndT1ArtiCombatThreat
            local tbFriendlyACUsConsidered = {}
            local tOurDFAndT1ArtiUnits
            function IncreaseCombatThreatForACU(oACU, iFarAwayFactorOverride)
                if not(tbFriendlyACUsConsidered[oACU.EntityId]) and M28UnitInfo.IsUnitValid(oACU) then
                    tbFriendlyACUsConsidered[oACU.EntityId] = true
                    if (not(oACU:IsUnitState('Upgrading')) and GetGameTimeSeconds() - (oACU[M28ACU.refiTimeLastWantedToRun] or -100) >= 10) or (tLZTeamData[M28Map.subrefLZbCoreBase] and (GetGameTimeSeconds() - (oACU[M28UnitInfo.refiLastWeaponEvent] or 0) <= 15)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have ACU that isnt upgrading, and doesnt want to run, in this zone, so will include unless far behind; altenratively ACU is in core base and recently fired its weapon') end
                        local iACUFactor = 1
                        if M28Map.iMapSize > 256 then iACUFactor = 0.9 end
                        if iEnemyBestStructureDFRange >= 50 then iACUFactor = 0.5 end
                        local iCurACUFactor
                        iCurACUFactor = iACUFactor
                        if not(M28Conditions.CloseToEnemyUnit(oACU:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], (oACU[M28UnitInfo.refiDFRange] or 0) + 6, iTeam, false, nil, nil, oACU, nil, false)) or (oACU:IsUnitState('Building') or oACU:IsUnitState('Repairing')) then
                            --If it has been a while since the ACU last fired its gun then treat it as not being in combat
                            if bDebugMessages == true then LOG(sFunctionRef..': ACU isnt close to nearest enemy, if last weapon event more than 5s then will reduce ACU value, time since last weapon event='..GetGameTimeSeconds() - (oACU[M28Events.refiLastWeaponEvent] or -100)) end
                            if GetGameTimeSeconds() - (oACU[M28Events.refiLastWeaponEvent] or -100) >= 5 then
                                iCurACUFactor = iCurACUFactor * (iFarAwayFactorOverride or 0.25)
                                --Reduce even further if ACU is quite far away
                                if not(M28UnitInfo.IsUnitValid(oACU[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) or M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oACU[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()) >= 15 + (oACU[M28UnitInfo.refiDFRange] or 0) then
                                    iCurACUFactor = iCurACUFactor * 0.3 --i.e. apply almost no value to the ACU
                                end
                            end
                        end
                        iOurDFAndT1ArtiCombatThreat = iOurDFAndT1ArtiCombatThreat + M28UnitInfo.GetCombatThreatRating({ oACU}, false) * iCurACUFactor
                        if bDebugMessages == true then LOG(sFunctionRef..': iACUFactor='..iACUFactor..'; iCurACUFactor='..iCurACUFactor..'; Threat of ACU='..M28UnitInfo.GetCombatThreatRating({ oACU }, false) * iACUFactor..'; Closest enemy unit to ACU='..(oACU[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oACU[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or 'nil')..'; Close to enemy DF units='..tostring(M28Conditions.CloseToEnemyUnit(oACU:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], (oACU[M28UnitInfo.refiDFRange] or 0) + 6, iTeam, false)))
                            if oACU[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] then
                                LOG(sFunctionRef..': Dist form ACU to nearest enemy='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oACU[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()))
                            end
                        end
                    end
                end
            end
            local tNearbyAdjacentEnemies = {}
            function CalculateNearbyEnemyCombatThreatFriendlyDFAndIfFriendlyACUInCombat(tAvailableUnitOverride)
                --tAvailableUnitOverride is so we can just send short range units here to calculate threat in scenario 1 to decide if we want to attack with them
                local bUpdateEnemyCombatThreat = false
                if not(iEnemyCombatThreat) then bUpdateEnemyCombatThreat = true end
                iEnemyCombatThreat = math.max((iEnemyCombatThreat or 0), tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 0.5, tLZTeamData[M28Map.subrefThreatEnemyDFStructures] + tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]) --we end up only including nearby enemy threats in adj zones, not all adj zone threats
                local bAdjustStructureThreat = false

                --First calculate our DF threat (recalulate if already done this, as may be dealing with SR units)
                if bDebugMessages == true then LOG(sFunctionRef..': CalculateNearbyEnemyCombatThreatFriendlyDFAndIfFriendlyACUInCombat start of code, bUpdateEnemyCombatThreat='..tostring(bUpdateEnemyCombatThreat)) end
                tOurDFAndT1ArtiUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandCombat, tAvailableUnitOverride or tAvailableCombatUnits)
                if M28Utilities.IsTableEmpty(tOurDFAndT1ArtiUnits) == false then
                    iOurDFAndT1ArtiCombatThreat = M28UnitInfo.GetCombatThreatRating(tOurDFAndT1ArtiUnits, false)
                    if not(tAvailableUnitOverride) and M28Utilities.IsTableEmpty(tUnavailableUnitsInThisLZ) == false then
                        local tUnavailableDFAndT1Arti = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandCombat, tUnavailableUnitsInThisLZ)
                        if M28Utilities.IsTableEmpty(tUnavailableDFAndT1Arti) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..'; Combat threat before including unavailable units='..iOurDFAndT1ArtiCombatThreat..'; Threat of unavailable units in this LZ='..M28UnitInfo.GetCombatThreatRating(tUnavailableDFAndT1Arti, false)) end
                            iOurDFAndT1ArtiCombatThreat = iOurDFAndT1ArtiCombatThreat + M28UnitInfo.GetCombatThreatRating(tUnavailableDFAndT1Arti, false)
                        end
                    end
                else
                    --T1DFAndT1Arti is empty
                    if bUpdateEnemyCombatThreat then --use placeholder value so we dont do lots of calculations when it doesnt really matter (and we just want a rough guide of how big a threat there is here)
                        bUpdateEnemyCombatThreat = false
                        if not(iEnemyNearbyCombatThreatIfRelevant) then GetEnemyCombatThreatInAdjacentZones() end
                        iEnemyCombatThreat = math.max(iEnemyNearbyCombatThreatIfRelevant, (iEnemyCombatThreat or 0), tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal])
                    end
                end

                if bUpdateEnemyCombatThreat then
                    if (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0) > 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats]) == false then
                        --If enemy LR threat is buildings rather than mobile units then increase enemy combat threat by this, so we are less likely to engage unless confident we will win
                        local bHaveDFBuildingsInLRThreat = false
                        for iUnit, oUnit in tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats] do
                            if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) then
                                bHaveDFBuildingsInLRThreat = true
                                break
                            end
                        end
                        if bHaveDFBuildingsInLRThreat then
                            iEnemyCombatThreat = iEnemyCombatThreat + tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat]
                            if bDebugMessages == true then LOG(sFunctionRef..': Increasing enemy LR threat for long range building threat, tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat]='..tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat]..'; iEnemyCombatThreat after increase='..iEnemyCombatThreat) end
                        end
                    end
                    local tbZonesConsidered = {}
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': Calculating enemy threat, iFirebaseThreatAdjust='..iFirebaseThreatAdjust) end
                        if iFirebaseThreatAdjust == 0 then
                            local iAdjacentDistThreshold = 0
                            local iCurDist
                            local iMinDist = 1000
                            local oClosestFriendlyUnit
                            --If dealing with PD, then will only include as a 'close enough' threat if the dist is closer than mobile units, factoring in range

                            for iUnit, oUnit in tOurDFAndT1ArtiUnits do --have already confirmed this isnt empty earlier
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                if iCurDist > iAdjacentDistThreshold then iAdjacentDistThreshold = iCurDist end
                                if iCurDist < iMinDist then
                                    iMinDist = iCurDist
                                    oClosestFriendlyUnit = oUnit
                                end
                            end
                            local iAngleFromClosestFriendlyUnit = 0
                            if oClosestFriendlyUnit then iAngleFromClosestFriendlyUnit = M28Utilities.GetAngleFromAToB(oClosestFriendlyUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) end
                            iAdjacentDistThreshold = iAdjacentDistThreshold + 20
                            local iStructureUnitDistThresholdAdjust = math.max(-30, -iAdjacentDistThreshold + 15)
                            if iAdjacentDistThreshold + iStructureUnitDistThresholdAdjust > iMinDist + 10 then
                                iStructureUnitDistThresholdAdjust = iMinDist + 10 - iAdjacentDistThreshold
                            end
                            if iEnemyBestStructureDFRange >= 50 then iAdjacentDistThreshold = math.max(iAdjacentDistThreshold + math.max(0, 5 + iEnemyBestStructureDFRange - (iFriendlyBestMobileDFRange or 0)), 35) end
                            --we adjust the distsances more generally based on the current zone size, so reduce the adj dist threshold based on this
                            if iAdjacentDistThreshold > 10 then iAdjacentDistThreshold = math.max(10, iAdjacentDistThreshold - iAdjacentDistGeneralMod) end
                            bACUInCombatButProbablySafe = false
                            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                if bHaveACUInTroubleAndRecentlyInCombat == nil then bHaveACUInTroubleAndRecentlyInCombat = false end --so we know we have considered this
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy threat in adjacent zone '..iAdjLZ..'; tbAdjacentZoneEnemiesToIgnoreByZone[iAdjLZ]='..tostring(tbAdjacentZoneEnemiesToIgnoreByZone[iAdjLZ] or false)..'; tbZonesConsidered[iAdjLZ]='..tostring(tbZonesConsidered[iAdjLZ] or false)) end
                                if not(tbAdjacentZoneEnemiesToIgnoreByZone[iAdjLZ]) and not(tbZonesConsidered[iAdjLZ]) then
                                    tbZonesConsidered[iAdjLZ] = true
                                    --If dealing with a core base or an ACU that is in combat then include friendly ACUs
                                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of allied ACUs empty='..tostring(M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefAlliedACU]))..'; tAdjLZTeamData[M28Map.refbACUInTrouble]='..tostring(tAdjLZTeamData[M28Map.refbACUInTrouble] or false)..'; Enemy mobile DF in AdjLZ='..(tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)..'; Is table of enemy DF units for AdjLZ empty='..tostring(M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftoNearestDFEnemies]))) end
                                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefAlliedACU]) == false then
                                        if not(bHaveACUInTroubleAndRecentlyInCombat) and tAdjLZTeamData[M28Map.refbACUInTrouble] and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                                            for iACU, oACU in tAdjLZTeamData[M28Map.subrefAlliedACU] do
                                                if GetGameTimeSeconds() - (oACU[M28UnitInfo.refiLastWeaponEvent] or 0) <= 10 then
                                                    bHaveACUInTroubleAndRecentlyInCombat = true
                                                    break
                                                end
                                            end
                                        end
                                        for iACU, oACU in tAdjLZTeamData[M28Map.subrefAlliedACU] do
                                            if not(oACU.Dead) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': About to consider whether to incrase threat for friendly ACU in adjacent zone') end
                                                IncreaseCombatThreatForACU(oACU, 0.1)
                                                if not(bACUInCombatButProbablySafe) and GetGameTimeSeconds() - (oACU[M28UnitInfo.refiLastWeaponEvent] or 0) <= 2 and M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.95 then
                                                    bACUInCombatButProbablySafe = true
                                                end
                                            end
                                        end
                                    end
                                    AddUnitFromAdjacentZoneToTableIfCloseEnough(tAdjLZTeamData, tNearbyAdjacentEnemies, iAdjacentDistThreshold, iStructureUnitDistThresholdAdjust, iAngleFromClosestFriendlyUnit)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Cumulative threat of tNearbyAdjacentEnemies after updating for iAdjLZ='..iAdjLZ..'='..M28UnitInfo.GetCombatThreatRating(tNearbyAdjacentEnemies, false)..'; Mass cost='..M28UnitInfo.GetMassCostOfUnits(tNearbyAdjacentEnemies, true)) end
                                end
                            end

                            if M28Utilities.IsTableEmpty(tUnitsNearFatboyInFurtherAwayZones) == false then
                                for iEnemy, oEnemy in tUnitsNearFatboyInFurtherAwayZones do
                                    table.insert(tNearbyAdjacentEnemies, oEnemy)
                                end
                            end
                            iEnemyCombatThreat = iEnemyCombatThreat + M28UnitInfo.GetCombatThreatRating(tNearbyAdjacentEnemies, false)
                        else
                            if tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= 5000 then bAdjustStructureThreat = true end
                            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                --Only include 20% of enemy structure threat in adjacent zones if we have high threat value
                                if not(tbAdjacentZoneEnemiesToIgnoreByZone[iAdjLZ]) then
                                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                    iEnemyCombatThreat = iEnemyCombatThreat + math.max((tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)*0.5, (tAdjLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0) + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0))
                                    if bAdjustStructureThreat and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will reduce adjacent threat by structure threat, tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]='..repru(tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange])) end
                                        for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                                            if iRange <= 65 then
                                                iEnemyCombatThreat = iEnemyCombatThreat - iThreat * 0.8
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end

                    --Update for nearby plateaus with threats
                    if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
                        for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                            if not(tbZonesConsidered[tPlateauAndZone[2]]) or not(tPlateauAndZone[1] == iPlateau) then --redundancy, in theory shoudlnt be possible for adjacent zone to be recorded as dangerous nearby zone
                                if tPlateauAndZone[1] == iPlateau then
                                    tbZonesConsidered[tPlateauAndZone[2]] = true
                                end
                                iEnemyCombatThreat = iEnemyCombatThreat + GetCombatThreatFromAdjacentZone(M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam], bAdjustStructureThreat)
                            end
                        end
                    end
                end
            end

            if oNearestEnemyToFriendlyBase and M28Conditions.IsLocationInPlayableArea(oNearestEnemyToFriendlyBase:GetPosition()) then
                if tLZTeamData[M28Map.subrefLZbCoreBase] then
                    --Adjust rally points for core base if nearby enemy in case we end up going closer to the enemy instead of furhter away
                    if M28Utilities.GetDistanceBetweenPositions(tAmphibiousRallyPoint, tLZData[M28Map.subrefMidpoint]) <= 5 then
                        tAmphibiousRallyPoint = M28Utilities.MoveInDirection(tLZData[M28Map.subrefMidpoint], M28Utilities.GetAngleFromAToB(oNearestEnemyToFriendlyBase:GetPosition(), tLZData[M28Map.subrefMidpoint]), 40, true, false, true)
                    end
                    if M28Utilities.GetDistanceBetweenPositions(tRallyPoint, tLZData[M28Map.subrefMidpoint]) <= 5 then
                        tRallyPoint = M28Utilities.MoveInDirection(tLZData[M28Map.subrefMidpoint], M28Utilities.GetAngleFromAToB(oNearestEnemyToFriendlyBase:GetPosition(), tLZData[M28Map.subrefMidpoint]), 40, true, false, true)
                    end
                end


                --Do we have shot blocked on non-skirmisher units, no indirect fire units, and have signficantly more threat than the enemy or are on an island beachhead? If so then move instead of attakc-moving when attacking
                local bMoveBlockedNotAttackMove = false
                if (iFriendlyBestMobileIndirectRange == 0 or tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] < tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] * 0.2 or iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 3) and (iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 1.75 or tLZTeamData[M28Map.refbIslandBeachhead] or (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) and iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 0.9)) then
                    bMoveBlockedNotAttackMove = true
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished deciding whether to move units whose shot is blocked, tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]..'; Is table of nearby t2 arti empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]))..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; Adjacent zone enemy threat='..GetEnemyCombatThreatInAdjacentZones()) end

                local bConsiderSpecialMMLLogic = false --if this is true then will consider synchronising MML shots and adjusting who they will target from the default
                local tMMLForSynchronisation = {}
                local bOnlyRetreatIndirectIfEnemyDFAlmostInRange = false --if this is true (e.g. dealing with t2 arti and dont want T3 mobile arti to run from low level enemy threats) then indirect fire units should only run from nearest enemy if it is almost in range of them
                if iFriendlyBestMobileIndirectRange > 0 then
                    local iAvailableMMLThreat = 0
                    local tFriendlyMML = EntityCategoryFilterDown(M28UnitInfo.refCategoryMML, tAvailableCombatUnits)
                    if M28Utilities.IsTableEmpty(tFriendlyMML) == false then
                        iAvailableMMLThreat = M28UnitInfo.GetMassCostOfUnits(tFriendlyMML)
                    end

                    bConsiderSpecialMMLLogic = M28Conditions.DoWeWantToSynchroniseMMLShots(iPlateau, iLandZone, tLZData, tLZTeamData, iTeam, iFriendlyBestMobileIndirectRange, iEnemyBestDFRange, iAvailableMMLThreat, oClosestUnitFromAllFirebases)
                    if iAvailableCombatUnitThreat >= 2500 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false and iFriendlyBestMobileIndirectRange >= 40 then
                        --How much available DF threat do we have?
                        local iRoughAvailableDFThreat = 0
                        for iUnit, oUnit in tAvailableCombatUnits do
                            if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and EntityCategoryContains(M28UnitInfo.refCategoryLandCombat - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) then
                                iRoughAvailableDFThreat = iRoughAvailableDFThreat + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
                                if iRoughAvailableDFThreat >= 1000 then
                                    bOnlyRetreatIndirectIfEnemyDFAlmostInRange = true
                                    break
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iRoughAvailableDFThreat (to max of 1k)='..iRoughAvailableDFThreat..'; bOnlyRetreatIndirectIfEnemyDFAlmostInRange='..tostring(bOnlyRetreatIndirectIfEnemyDFAlmostInRange)) end
                    end
                end

                local bAttackWithSameRange = false
                if ((tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0) == 0 or iFriendlyBestMobileDFRange >= 100) and --No long range enemy threat (i.e. t2 arti); and
                        (iFirebaseThreatAdjust == 0 or (iFriendlyBestMobileDFRange >= 100 and iFirebaseThreatAdjust < 6000 and tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= 8000) or (not(bRunFromFirebase) and (iFriendlyBestMobileDFRange >= 60 or iFriendlyBestMobileIndirectRange >= 60))) and --No enemy firebase or we have large threat that should be able to overwhelm it; and
                        ((iFriendlyBestMobileDFRange or 0) > (iEnemyBestDFRange or 0) + 2 or --we outrange enemy with our direct fire, or
                                --Important to not increase more than +4 range without more complicated logic, as T1 arti need to engage T1 PD, and outrange T1 PD by 4
                                ((iFriendlyBestMobileIndirectRange or 0) >= (iEnemyBestDFRange or 0) + 4 and ((iEnemyBestStructureDFRange or 0) > 0 or (tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] or 0) > 0 or (tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] or 0) > 1.4 * (tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)))) then --we have indirect fire with better range than enemy direct fire, and the enemy has structures in this LZ such that we want to attack

                    bAreInScenario1 = true
                    if (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0) > 0 or iFirebaseThreatAdjust > 0 then
                        bAttackWithSameRange = true
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Normal scenario 1 criteria satisfied, iFriendlyBestMobileDFRange='..(iFriendlyBestMobileDFRange or 'nil')..'; iEnemyBestDFRange='..(iEnemyBestDFRange or 'nil')..'; iFirebaseThreatAdjust='..(iFirebaseThreatAdjust or 'nil')..'; subrefiNearbyEnemyLongRangeDFThreat='..(tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0)..'; iFriendlyBestMobileIndirectRange='..(iFriendlyBestMobileIndirectRange or 'nil')..'; iEnemyBestStructureDFRange='..(iEnemyBestStructureDFRange or 'nil')..'; subrefLZThreatAllyMobileIndirectTotal='..(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] or 'nil')) end
                elseif iFirebaseThreatAdjust == 0 and (iFriendlyBestMobileDFRange or 0) >= math.max(10, (iEnemyBestDFRange or 0) - 3) then
                    --NOTE: THis isnt the main 'if we outrange closest enemy' logic (which is further on below)
                    local iBestEnemyLRThreatCombatRange = 0
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat]) == false then
                        for iUnit, oUnit in tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] do
                            if oUnit[M28UnitInfo.refiCombatRange] and oUnit[M28UnitInfo.refiCombatRange] > iBestEnemyLRThreatCombatRange then iBestEnemyLRThreatCombatRange = oUnit[M28UnitInfo.refiCombatRange] end
                        end
                    end
                    if iFriendlyBestMobileDFRange < iBestEnemyLRThreatCombatRange then
                        if bDebugMessages == true then LOG(sFunctionRef..': We dont match or beat nearest enemy DF range') end
                        --If we significantly outrange the closest enemy unit then should try and kill it
                    elseif  iFriendlyBestMobileDFRange > (oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0) + 5 and iFriendlyBestMobileDFRange >= iEnemyBestDFRange then --e.g. gattling bots vs hoplites
                        bAreInScenario1 = true
                        bAttackWithSameRange = true
                        if bDebugMessages == true then LOG(sFunctionRef..': We significantly outrange nearest enemy unit and have equivalent DF range overall so will act as though in scenario 1') end
                    elseif not(EntityCategoryContains(M28UnitInfo.refCategoryStructure, oNearestEnemyToFriendlyBase.UnitId)) then --i.e. nearest enemy is a mobile enemy with (likely) the same or slightly better range than us
                        --Do we have significantly more threat than enemy at the highest range?
                        local iEnemyBestRangeDFThreat = 0
                        local iOurBestRangeDFThreat = 0
                        local iRangeThreshold = math.min(iFriendlyBestMobileDFRange, iEnemyBestDFRange)
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
                            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                                if iRange >= iRangeThreshold then
                                    iOurBestRangeDFThreat = iThreat
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) == false then
                            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] do
                                if iRange >= iRangeThreshold then
                                    iEnemyBestRangeDFThreat = iThreat
                                end
                            end
                        end
                        --Consider enemy LR threat in adjacent zones if we might have enough threat
                        if iOurBestRangeDFThreat > 1.5 * iEnemyBestRangeDFThreat then
                            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) == false then
                                        for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] do
                                            if iRange >= iRangeThreshold then
                                                iEnemyBestRangeDFThreat = iEnemyBestRangeDFThreat + iThreat
                                            end
                                        end
                                    end
                                end
                            end
                            if iOurBestRangeDFThreat > 1.5 * iEnemyBestRangeDFThreat then
                                bAreInScenario1 = true
                                if bDebugMessages == true then LOG(sFunctionRef..': We have significantly more threat than enemy at the longer rnage so will act as though are in scenario 1 so we just attack with our longer ranged units, iRangeThreshold='..iRangeThreshold) end
                                iDFRangeOverrideForScenario1 = iFriendlyBestMobileDFRange
                                bAttackWithSameRange = true
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': If are in scenario 1 will consider disabling if we cant see the nearest enemy, or if it is a naval unit and we dont significantly outrange it, bAreInScenario1='..tostring(bAreInScenario1)..'; oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase) or 'nil')..'; iFirebaseThreatAdjust='..iFirebaseThreatAdjust..'; tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat]='..(tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 'nil')..'; iFriendlyBestMobileDFRange='..iFriendlyBestMobileDFRange..'; iEnemyBestDFRange='..iEnemyBestDFRange..'; iFriendlyBestMobileIndirectRange='..iFriendlyBestMobileIndirectRange..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat)
                    if oNearestEnemyToFriendlyBase then LOG(sFunctionRef..': Can see oNearestEnemyToFriendlyBase='..tostring(M28UnitInfo.CanSeeUnit(ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]], oNearestEnemyToFriendlyBase, false))..'; tLZTeamData[M28Map.refiRadarCoverage]='..tLZTeamData[M28Map.refiRadarCoverage]) end
                end
                if bAreInScenario1 and oNearestEnemyToFriendlyBase then
                    local iUnitSegmentX, iUnitSegmentZ = M28Map.GetPathingSegmentFromPosition(oNearestEnemyToFriendlyBase:GetPosition())
                    if M28Map.tWaterZoneBySegment[iUnitSegmentX][iUnitSegmentZ] then
                        bAreInScenario1 = false
                        local iBestRange = math.max(iFriendlyBestMobileDFRange, iFriendlyBestMobileIndirectRange)
                        local tLandPoint = M28Utilities.MoveInDirection(oNearestEnemyToFriendlyBase:GetPosition(), M28Utilities.GetAngleFromAToB(oNearestEnemyToFriendlyBase:GetPosition(), tLZData[M28Map.subrefMidpoint]), iBestRange, true, false, not(M28Map.bIsCampaignMap))
                        if tLandPoint and NavUtils.GetLabel(M28Map.refPathingTypeLand, tLandPoint) == tLZData[M28Map.subrefLZIslandRef] then
                            bAreInScenario1 = true
                        else
                            --Check if we have hover units or antinavy units that outrange them
                            local tFriendlyHover = EntityCategoryFilterDown(categories.HOVER + categories.ANTINAVY, tAvailableCombatUnits)

                            if M28Utilities.IsTableEmpty(tFriendlyHover) == false then
                                for iHover, oHover in tFriendlyHover do
                                    if bDebugMessages == true then LOG(sFunctionRef..': oHover or antinavy='..oHover.UnitId..M28UnitInfo.GetUnitLifetimeCount(oHover)..' with antinavy range='.. (oHover[M28UnitInfo.refiAntiNavyRange] or 0)..' and DF range='..(oHover[M28UnitInfo.refiDFRange] or 'nil')) end
                                    if (oHover[M28UnitInfo.refiAntiNavyRange] or 0) > iEnemyBestDFRange or ((oHover[M28UnitInfo.refiDFRange] or 0) > iEnemyBestDFRange and EntityCategoryContains(categories.HOVER, oHover.UnitId)) then
                                        bAreInScenario1 = true
                                        break
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': We think we are in scenario 1 but nearest enemy is in the water, checking if we can hit them if we move towards them, Island ref (if is one)='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tLandPoint) or 'nil')..'; This zone island ref='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..'; bAreInScenario1 after checking this='..tostring(bAreInScenario1)) end

                    end
                    if bAreInScenario1 and oNearestEnemyToFriendlyBase and not(M28UnitInfo.CanSeeUnit(ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]], oNearestEnemyToFriendlyBase, false)) and not(EntityCategoryContains(M28UnitInfo.refCategoryStructure, oNearestEnemyToFriendlyBase.UnitId)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': we dont have intel of the closest enemy so dont want to be in scenario 1 afterall (unless we have friendly ACU  or land scout in this zone or the zone with the nearest enemy, and not dealing with very long range units), will flag that we lack intel, nearest enemy combat range='..(oNearestEnemyToFriendlyBase[M28UnitInfo.refiCombatRange] or 'nil')..'; Dist between last known position and actual position='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; iFriendlyBestMobileIndirectRange='..iFriendlyBestMobileIndirectRange..'; iEnemyBestDFRange='..(iEnemyBestDFRange or 'nil')) end
                        bAreInScenario1 = false
                        if tLZTeamData[M28Map.refiRadarCoverage] < iIntelThresholdForPriorityScout then
                            tLZTeamData[M28Map.refiTimeLastFailedToKiteDueToScoutIntel] = GetGameTimeSeconds()
                        end
                        if M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 3 then
                            bAreInScenario1 = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Unit hasnt moved much from when we last had intel so reasonable to assume AI would infer roughly where it is') end
                        else
                            if iFriendlyBestMobileIndirectRange > (iEnemyBestDFRange or 0) then
                                local iActualDistToMidpoint = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                local iExpectedDistToMidpoint = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tLZData[M28Map.subrefMidpoint])
                                if bDebugMessages == true then LOG(sFunctionRef..': iActualDistToMidpoint='..iActualDistToMidpoint..'; iExpectedDistToMidpoint='..iExpectedDistToMidpoint) end
                                if iActualDistToMidpoint >= iExpectedDistToMidpoint then
                                    bAreInScenario1 = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': We have indirect fire units, and enemy isnt any closer to our midpoint than we would expect from the last known position, so a chance we can get some lucky hits on other units based on where we recalled them being since we outrange them') end
                                end
                            end
                            if not(bAreInScenario1) and oNearestEnemyToFriendlyBase[M28UnitInfo.refiCombatRange] <= 45 then

                                local iNearestEnemyPlateau, iNearestEnemyZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oNearestEnemyToFriendlyBase:GetPosition())
                                if not(iNearestEnemyZone == iLandZone) and iNearestEnemyPlateau == iPlateau then
                                    local tNearestEnemyTeamData = M28Map.tAllPlateaus[iNearestEnemyPlateau][M28Map.subrefPlateauLandZones][iNearestEnemyZone][M28Map.subrefLZTeamData][iTeam]
                                    if M28Utilities.IsTableEmpty(tNearestEnemyTeamData[M28Map.subrefAlliedACU]) == false then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have friendly ACU in the same zone as nearest enemy so will actually stick to being scenario 1') end
                                        bAreInScenario1 = true
                                    end --subrefLZTAlliedCombatUnits
                                elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false and iNearestEnemyZone == iLandZone then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have friendly ACU in this zone which enemy is in, so will actually stick to being scenario 1') end
                                    bAreInScenario1 = true
                                end
                            end
                        end
                    end
                end
                --If we outrange nearest enemy unit (both DF and IF), then lower the DF range requirement for units to try and kite it, and consider going into scenario 1 even if we wouldnt normally
                if (iFriendlyBestMobileDFRange > (oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0) or (oNearestEnemyToFriendlyBase:IsUnitState('Upgrading') and (bAreInScenario1 or iFriendlyBestMobileIndirectRange > oNearestEnemyToFriendlyBase[M28UnitInfo.refiCombatRange])) or (iFriendlyBestMobileIndirectRange > iEnemyBestDFRange + 10 and iFriendlyBestMobileIndirectRange > oNearestEnemyToFriendlyBase[M28UnitInfo.refiCombatRange] and M28UnitInfo.CanSeeUnit(ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]], oNearestEnemyToFriendlyBase, false)))
                        and (not(bAreInScenario1) or math.max(iFriendlyBestMobileDFRange, iFriendlyBestMobileIndirectRange) > (oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0) + 6) and oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] == iPlateau and iFirebaseThreatAdjust == 0
                        and ((oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0) < iEnemyBestDFRange or (oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0) < iFriendlyBestMobileIndirectRange)
                then
                    --If enemy has LR threat then get range of this
                    local iBestEnemyLRThreatCombatRange = 0
                    local iEnemyRangeThreshold = (oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 5)
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats]) == false then
                        for iUnit, oUnit in tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats] do
                            if oUnit[M28UnitInfo.refiCombatRange] and oUnit[M28UnitInfo.refiCombatRange] > iBestEnemyLRThreatCombatRange then iBestEnemyLRThreatCombatRange = oUnit[M28UnitInfo.refiCombatRange] end
                        end
                    end
                    --Get the zone the nearest enemy is in (so we can reference DF units in that zone)
                    local tNearestEnemyLZTeamData
                    if oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone then
                        tNearestEnemyLZTeamData = tLZTeamData
                    else
                        tNearestEnemyLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]][M28Map.subrefLZTeamData][iTeam]
                    end
                    --How close is an enemy unit to being in range of the nearest enemy (i.e. negative value means it can attack our units once they get this distance away)
                    local iClosestDistLessRange = 10000
                    local iCurDistToClosestEnemy, iCurDistToFriendlyBase, iCurModDistLessRange
                    local iClosestEnemyDistToFriendlyBase = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                    if M28Utilities.IsTableEmpty(tNearestEnemyLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                        for iEnemy, oEnemy in tNearestEnemyLZTeamData[M28Map.reftoNearestDFEnemies] do
                            --Only consider enemies that outrange the nearest enemy (since if they're the same or less range then we can kite them with the same units that can kite the nearest enemy)
                            if bDebugMessages == true then LOG(sFunctionRef..': considering how close nearby DF units are to closest enemy, factoring in their range, oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; DF range='..oEnemy[M28UnitInfo.refiDFRange]..'; iEnemyRangeThreshold='..iEnemyRangeThreshold..'; Dist between positions='..M28Utilities.GetDistanceBetweenPositions(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oNearestEnemyToFriendlyBase:GetPosition())..'; iClosestDistLessRange before update='..iClosestDistLessRange) end
                            if (oEnemy[M28UnitInfo.refiDFRange] or 0) > iEnemyRangeThreshold then
                                iCurDistToClosestEnemy = M28Utilities.GetDistanceBetweenPositions(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oNearestEnemyToFriendlyBase:GetPosition())
                                iCurDistToFriendlyBase = M28Utilities.GetDistanceBetweenPositions(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tLZTeamData[M28Map.reftClosestFriendlyBase])
                                --Enemy unit might be say 30 to the nearest enemy, but a friendly unit attacking the nearest enemy might be less than 30 additional distance to the enemy; as a rough proxy will therefore go with 50% of this (so double the differential in dist to closest base)
                                iCurModDistLessRange = math.min(iCurDistToClosestEnemy, math.max(1, iCurDistToClosestEnemy - (oEnemy[M28UnitInfo.refiDFRange] or 0), (iClosestEnemyDistToFriendlyBase - iCurDistToFriendlyBase) * 2)) - oEnemy[M28UnitInfo.refiDFRange]
                                if iCurModDistLessRange < iClosestDistLessRange then iClosestDistLessRange = iCurModDistLessRange end
                            end
                        end
                    end
                    --Check nearby IF threats
                    if not(bAreInScenario1) and iClosestDistLessRange > 0 and M28Utilities.IsTableEmpty(tNearestEnemyLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                        for iEnemy, oEnemy in tNearestEnemyLZTeamData[M28Map.subrefTEnemyUnits] do
                            --Only consider enemies that outrange the nearest enemy (since if they're the same or less range then we can kite them with the same units that can kite the nearest enemy)
                            if bDebugMessages == true then LOG(sFunctionRef..': considering how close nearby IF units are to closest enemy, factoring in their range, oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; DF range='..(oEnemy[M28UnitInfo.refiDFRange] or 'nil')..'; iEnemyRangeThreshold='..(iEnemyRangeThreshold or 'nil')..'; Dist between positions='..M28Utilities.GetDistanceBetweenPositions(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oNearestEnemyToFriendlyBase:GetPosition())..'; iClosestDistLessRange before update='..(iClosestDistLessRange or 'nil')) end
                            if oEnemy[M28UnitInfo.refiIndirectRange] and oEnemy[M28UnitInfo.refiIndirectRange] > iEnemyRangeThreshold and oEnemy[M28UnitInfo.refiIndirectRange] > (oEnemy[M28UnitInfo.refiDFRange] or 0) then
                                iCurDistToClosestEnemy = M28Utilities.GetDistanceBetweenPositions(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oNearestEnemyToFriendlyBase:GetPosition())
                                iCurDistToFriendlyBase = M28Utilities.GetDistanceBetweenPositions(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tLZTeamData[M28Map.reftClosestFriendlyBase])
                                --Enemy unit might be say 30 to the nearest enemy, but a friendly unit attacking the nearest enemy might be less than 30 additional distance to the enemy; as a rough proxy will therefore go with 50% of this (so double the differential in dist to closest base)
                                iCurModDistLessRange = math.min(iCurDistToClosestEnemy, math.max(1, iCurDistToClosestEnemy - oEnemy[M28UnitInfo.refiCombatRange], (iClosestEnemyDistToFriendlyBase - iCurDistToFriendlyBase) * 2)) - oEnemy[M28UnitInfo.refiCombatRange]
                                if iCurModDistLessRange < iClosestDistLessRange then iClosestDistLessRange = iCurModDistLessRange end
                            end
                        end
                    end
                    --Check LR threats
                    if iBestEnemyLRThreatCombatRange > 0 and iBestEnemyLRThreatCombatRange + 3 >= iFriendlyBestMobileDFRange and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats]) == false then
                        for iEnemy, oEnemy in tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats] do
                            iCurDistToClosestEnemy = M28Utilities.GetDistanceBetweenPositions(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oNearestEnemyToFriendlyBase:GetPosition())
                            iCurDistToFriendlyBase = M28Utilities.GetDistanceBetweenPositions(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tLZTeamData[M28Map.reftClosestFriendlyBase])
                            --Enemy unit might be say 30 to the nearest enemy, but a friendly unit attacking the nearest enemy might be less than 30 additional distance to the enemy; as a rough proxy will therefore go with 50% of this (so double the differential in dist to closest base)
                            iCurModDistLessRange = math.min(iCurDistToClosestEnemy, math.max(1, iCurDistToClosestEnemy - (oEnemy[M28UnitInfo.refiDFRange] or 0), (iClosestEnemyDistToFriendlyBase - iCurDistToFriendlyBase) * 2)) - oEnemy[M28UnitInfo.refiCombatRange]
                            if iCurModDistLessRange < iClosestDistLessRange then iClosestDistLessRange = iCurModDistLessRange end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iClosestDistLessRange after checking DF, IF and LR units='..iClosestDistLessRange) end
                    local iFriendlyDFRangeThresholdBasedOnAbove
                    if iClosestDistLessRange * -1 + 8 > (oNearestEnemyToFriendlyBase[M28UnitInfo.refiCombatRange] or 0) then
                        iFriendlyDFRangeThresholdBasedOnAbove = iClosestDistLessRange * -1 + 8
                        if bDebugMessages == true then LOG(sFunctionRef..': Updating range threshold for +8, iFriendlyDFRangeThresholdBasedOnAbove='..iFriendlyDFRangeThresholdBasedOnAbove..'; iClosestDistLessRange='..iClosestDistLessRange) end
                    else
                        iFriendlyDFRangeThresholdBasedOnAbove = (oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0) + 3
                        if bDebugMessages == true then LOG(sFunctionRef..': Updating range threshold for +3, iFriendlyDFRangeThresholdBasedOnAbove='..iFriendlyDFRangeThresholdBasedOnAbove..'; iClosestDistLessRange='..iClosestDistLessRange) end
                    end

                    if iDFRangeOverrideForScenario1 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Updating threshold to the lower of iDFRangeOverrideForScenario1 and iFriendlyDFRangeThresholdBasedOnAbove, iDFRangeOverrideForScenario1='..iDFRangeOverrideForScenario1..'; iFriendlyDFRangeThresholdBasedOnAbove='..iFriendlyDFRangeThresholdBasedOnAbove) end
                        iDFRangeOverrideForScenario1 = math.min(iDFRangeOverrideForScenario1, iFriendlyDFRangeThresholdBasedOnAbove)
                    elseif bAreInScenario1 and iFriendlyBestMobileDFRange > iEnemyBestDFRange + 2 then
                        iDFRangeOverrideForScenario1 = math.min(iFriendlyDFRangeThresholdBasedOnAbove, iEnemyBestDFRange + 2)
                        if bDebugMessages == true then LOG(sFunctionRef..': Are in scenario 1 so making lower of enemy range and the other values, iDFRangeOverrideForScenario1='..(iDFRangeOverrideForScenario1 or 'nil')..'; iFriendlyBestMobileDFRange='..iFriendlyBestMobileDFRange..'; iEnemyBestDFRange='..iEnemyBestDFRange) end
                    elseif bAreInScenario1 and iFriendlyBestMobileIndirectRange > iEnemyBestDFRange + 3 then
                        iDFRangeOverrideForScenario1 = math.min(iFriendlyDFRangeThresholdBasedOnAbove, iFriendlyBestMobileIndirectRange)
                    else
                        iDFRangeOverrideForScenario1 = iFriendlyDFRangeThresholdBasedOnAbove
                        --Disable scenario1 flag as althoguh we outrange the enemy it isnt by much and so we could end up in scenario where we have no units better than this
                        if iDFRangeOverrideForScenario1 > iFriendlyBestMobileIndirectRange and iDFRangeOverrideForScenario1 > iFriendlyBestMobileDFRange then
                            bAreInScenario1 = false
                            if bDebugMessages == true then LOG(sFunctionRef..': Disabling the scenario 1 flag given we dont outrange enemy by much and not by enough for the desired override') end
                        end
                    end
                    if not(bAreInScenario1) then
                        --If enemy has nearby DF or IF units that are within range of the closest enemy unit, then check that we still have units that significantly outrange these to switch to scenario 1
                        if iClosestDistLessRange < 0 and iClosestDistLessRange * -1 > math.max(iFriendlyBestMobileIndirectRange + 10, iFriendlyBestMobileDFRange + 5) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy ahs DF or IF that are too close to the nearest enemy so we cant safely attack nearest enemy') end
                        elseif iFriendlyBestMobileDFRange > iDFRangeOverrideForScenario1 then
                            bAreInScenario1 = true
                        elseif iFriendlyBestMobileIndirectRange > iDFRangeOverrideForScenario1 + 5 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Our indirectfire outranges their units so will proceed with scenario 1 logic') end
                            bAreInScenario1 = true
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if we think closest enemy unit is vulnerable to a kiting attack, bAreInScenario1='..tostring(bAreInScenario1 or false)..'; iDFRangeOverrideForScenario1='..(iDFRangeOverrideForScenario1 or 'nil')..'; nearest enemy unit state='..M28UnitInfo.GetUnitState(oNearestEnemyToFriendlyBase)) end
                end

                function ConsiderManualAttackInsteadOfAttackMove(oUnit, oUnitTarget, tAttackMovePosition, iOrderDistanceReassess, sOrderBaseDesc)
                    --Intended where units have an attackmove range that is shorter than their main combat range
                    local bGivenManualAttack = false
                    local toPotentialTargets = {}
                    local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnitTarget:GetPosition())
                    local aiBrain = oUnit:GetAIBrain()
                    if iDistToTarget <= oUnit[M28UnitInfo.refiCombatRange] and iDistToTarget > oUnit[M28UnitInfo.refiWeaponScanRange] and M28UnitInfo.CanSeeUnit(aiBrain, oUnitTarget, false) then
                        table.insert(toPotentialTargets, oUnitTarget)
                    end
                    if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and not(oUnitTarget == oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                        iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())
                        if iDistToTarget <= oUnit[M28UnitInfo.refiCombatRange] and  iDistToTarget > oUnit[M28UnitInfo.refiWeaponScanRange] and M28UnitInfo.CanSeeUnit(aiBrain, oUnitTarget, false) then
                            table.insert(toPotentialTargets, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])
                        end
                    end
                    --Consider each unit weapon and its current target, if there is one
                    if oUnit.WeaponInstances then
                        for iWeapon, oWeapon in oUnit.WeaponInstances do
                            if oWeapon.GetCurrentTarget then
                                local oCurTarget = oWeapon:GetCurrentTarget()
                                if M28UnitInfo.IsUnitValid(oCurTarget) and EntityCategoryContains(categories.ALLUNITS - M28UnitInfo.refCategoryAllAir - M28UnitInfo.refCategorySubmarine, oCurTarget.UnitId) then
                                    table.insert(toPotentialTargets, oCurTarget)
                                end
                            end
                        end
                    end
                    --If we had an attack order before consider this as well
                    local oLastUnitTarget = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]][M28Orders.subrefoOrderUnitTarget]
                    if M28UnitInfo.IsUnitValid(oLastUnitTarget) then
                        iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oLastUnitTarget:GetPosition())
                        if iDistToTarget <= oUnit[M28UnitInfo.refiCombatRange] and  iDistToTarget > oUnit[M28UnitInfo.refiWeaponScanRange] and M28UnitInfo.CanSeeUnit(aiBrain, oLastUnitTarget, false) then
                            table.insert(toPotentialTargets, oLastUnitTarget)
                        end
                    end
                    if M28Utilities.IsTableEmpty(toPotentialTargets) == false then
                        --Target the highest mass cost unit in potential targets
                        local iHighestMassCost = 30 --dont bother manual attacks for cheaper units than this
                        local oUnitToManuallyAttack
                        for iPotentialUnit, oPotentialUnit in toPotentialTargets do
                            if oPotentialUnit[M28UnitInfo.refiUnitMassCost] > iHighestMassCost then
                                oUnitToManuallyAttack = oPotentialUnit
                                iHighestMassCost = oPotentialUnit[M28UnitInfo.refiUnitMassCost]
                            end
                        end
                        if oUnitToManuallyAttack then
                            bGivenManualAttack = true
                            M28Orders.IssueTrackedAttack(oUnit, oUnitToManuallyAttack, false, sOrderBaseDesc..'mA', false)
                        end
                    end
                    if not(bGivenManualAttack) then
                        M28Orders.IssueTrackedAttackMove(oUnit, tAttackMovePosition, iOrderDistanceReassess, false, sOrderBaseDesc..'m'..iLandZone, false)
                    end
                end

                function ProtectFriendlyACUInTroubleIfRelevant(tUnitsToConsiderAndUpdate)
                    --If have an ACU in trouble then sends non-skrimisher DF units in tUnitsToConsiderAndUpdate to protect the ACU
                    local toFriendlyACUsNearby = {}
                    if bDebugMessages == true then LOG(sFunctionRef..': ProtectFriendlyACUInTroubleIfRelevant: bHaveACUInTroubleAndRecentlyInCombat==nil='..tostring(bHaveACUInTroubleAndRecentlyInCombat==nil)..'; bHaveACUInTroubleAndRecentlyInCombat == true='..tostring(bHaveACUInTroubleAndRecentlyInCombat or false)..'; oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase) or 'nil')) end
                    if oNearestEnemyToFriendlyBase and (bHaveACUInTroubleAndRecentlyInCombat == nil or bHaveACUInTroubleAndRecentlyInCombat) then --we havent considered properly if there are ACUs in danger if this is nil
                        --Check this and adjacent zones for if ACU in trouble, and if so then populate
                        if tLZTeamData[M28Map.refbACUInTrouble] and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false then
                            bHaveACUInTroubleAndRecentlyInCombat = true
                            for iACU, oACU in tLZTeamData[M28Map.subrefAlliedACU] do
                                if not(oACU.Dead) then table.insert(toFriendlyACUsNearby, oACU) end
                            end
                        end
                        --Consider adjacent zones
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then --and M28Utilities.IsTableEmpty(toFriendlyACUsNearby) then
                            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                if tAdjLZTeamData[M28Map.refbACUInTrouble] and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefAlliedACU]) == false then
                                    bHaveACUInTroubleAndRecentlyInCombat = true
                                    for iACU, oACU in tAdjLZTeamData[M28Map.subrefAlliedACU] do
                                        if not(oACU.Dead) then table.insert(toFriendlyACUsNearby, oACU) end
                                    end
                                end
                            end
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': ProtectFriendlyACUInTroubleIfRelevant: Is table of ACUs in this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]))..'; Is bACUInCombatButProbablySafe nil='..tostring(bACUInCombatButProbablySafe == nil)..'; bACUInCombatButProbablySafe='..tostring(bACUInCombatButProbablySafe or false)) end
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false then
                            for iACU, oACU in tLZTeamData[M28Map.subrefAlliedACU] do
                                if bDebugMessages == true then LOG(sFunctionRef..': Time since ACU owned by '..oACU:GetAIBrain().Nickname..' time since fired weapon='..GetGameTimeSeconds() - (oACU[M28UnitInfo.refiLastWeaponEvent] or 0)..'; Health%='..M28UnitInfo.GetUnitHealthPercent(oACU)) end
                                if GetGameTimeSeconds() - (oACU[M28UnitInfo.refiLastWeaponEvent] or 0) <= 2 and M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.95 then
                                    bACUInCombatButProbablySafe = true
                                    table.insert(toFriendlyACUsNearby, oACU)
                                end
                            end
                        end
                        if (bACUInCombatButProbablySafe == nil or bACUInCombatButProbablySafe) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                if bDebugMessages == true then LOG(sFunctionRef..': Is ACUs in iAdjLZ='..iAdjLZ..'empty='..tostring(M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefAlliedACU]))) end
                                if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefAlliedACU]) == false then
                                    for iACU, oACU in tAdjLZTeamData[M28Map.subrefAlliedACU] do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Adj zone ACU, owned by '..oACU:GetAIBrain().Nickname..' time since fired weapon='..GetGameTimeSeconds() - (oACU[M28UnitInfo.refiLastWeaponEvent] or 0)..'; Health%='..M28UnitInfo.GetUnitHealthPercent(oACU)) end
                                        if not(oACU.Dead) and GetGameTimeSeconds() - (oACU[M28UnitInfo.refiLastWeaponEvent] or 0) <= 2 and M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.95 then
                                            table.insert(toFriendlyACUsNearby, oACU)
                                            bACUInCombatButProbablySafe = true
                                        end
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': bHaveACUInTroubleAndRecentlyInCombat='..tostring(bHaveACUInTroubleAndRecentlyInCombat)..'; Is table of friendly ACUs nearby='..tostring(M28Utilities.IsTableEmpty(toFriendlyACUsNearby))..'; bACUInCombatButProbablySafe='..tostring(bACUInCombatButProbablySafe)) end
                    local oACUToProtect
                    local oOptionalEnemyToBeCloserTo
                    local iACUDistToEnemy
                    if bHaveACUInTroubleAndRecentlyInCombat and M28Utilities.IsTableEmpty(toFriendlyACUsNearby) == false then
                        local iLowestHealthACU = 100000
                        for iACU, oACU in toFriendlyACUsNearby do
                            --Get lowest health ACU in this or adj zone that we can path to
                            if oACU:GetHealth() < iLowestHealthACU and oACU[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] == iPlateau and  M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][oACU[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]][M28Map.subrefLZIslandRef] == tLZData[M28Map.subrefLZIslandRef] then
                                iLowestHealthACU = oACU:GetHealth()
                                oACUToProtect = oACU
                            end
                        end
                    elseif bACUInCombatButProbablySafe and M28Utilities.IsTableEmpty(toFriendlyACUsNearby) == false then
                        --Get closest DF enemy to the ACU; if it's relatively close to being in range of the ACU then attack-move with units that are a bit further away
                        local oNearestACUToEnemy
                        local iCurDist
                        local iClosestACUToEnemy = 10000
                        for iACU, oACU in toFriendlyACUsNearby do
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition())
                            if iCurDist < iClosestACUToEnemy then
                                iClosestACUToEnemy = iCurDist
                                oNearestACUToEnemy = oACU
                            end
                        end
                        local oEnemyNearACU
                        --Get the closest DF enemy to enemy ACU
                        if iClosestACUToEnemy < (oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0) + 1 then
                            oEnemyNearACU = oNearestEnemyToFriendlyBase
                        elseif M28Utilities.IsTableEmpty(tSkirmisherDFEnemies) == false then
                            local iClosestDFEnemyDistLessRange = 1 --i.e. attack if enemy is within 1 of being in range of our ACU                            for iEnemy, oEnemy in tSkirmisherDFEnemies do
                            for iEnemy, oEnemy in tSkirmisherDFEnemies do
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oNearestACUToEnemy:GetPosition(), oEnemy:GetPosition()) - (oEnemy[M28UnitInfo.refiDFRange] or 0)
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..' with DF range='..(oEnemy[M28UnitInfo.refiDFRange] or 0)..'; Dist to ACU='..M28Utilities.GetDistanceBetweenPositions(oNearestACUToEnemy:GetPosition(), oEnemy:GetPosition())) end
                                if iCurDist < iClosestDFEnemyDistLessRange then
                                    iClosestDFEnemyDistLessRange = iCurDist
                                    oEnemyNearACU = oEnemy
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': oNearestACUToEnemy owner='..oNearestACUToEnemy:GetAIBrain().Nickname..'; oEnemyNearACU='..(oEnemyNearACU.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEnemyNearACU) or 'nil')) end
                        if oEnemyNearACU then
                            oACUToProtect = oNearestACUToEnemy
                            oOptionalEnemyToBeCloserTo = oEnemyNearACU

                            if bDebugMessages == true then LOG(sFunctionRef..': Will send DF units to attack as our ACU is in combat and not on full health, but will attack-move and try and stay behind our ACU, oACUToProtect owner='..oACUToProtect:GetAIBrain().Nickname..'; oOptionalEnemyToBeCloserTo='..oOptionalEnemyToBeCloserTo.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOptionalEnemyToBeCloserTo)) end
                        end
                    end
                    if oACUToProtect then
                        local iCombatUnitsTableSize = table.getn(tUnitsToConsiderAndUpdate)
                        local iDistInfrontOfACUWanted
                        local tProtectiveMovePoint
                        local iOptionalMinDistToNearestEnemy
                        if oOptionalEnemyToBeCloserTo then
                            iACUDistToEnemy = M28Utilities.GetDistanceBetweenPositions(oACUToProtect:GetPosition(), oOptionalEnemyToBeCloserTo:GetPosition())
                            iOptionalMinDistToNearestEnemy = iACUDistToEnemy + 4
                            iDistInfrontOfACUWanted = math.max(5, iACUDistToEnemy - 5)
                            tProtectiveMovePoint = M28Utilities.MoveInDirection(oACUToProtect:GetPosition(), M28Utilities.GetAngleFromAToB(oACUToProtect:GetPosition(), oOptionalEnemyToBeCloserTo:GetPosition()), iDistInfrontOfACUWanted, true, false, M28Map.bIsCampaignMap)
                        else
                            iDistInfrontOfACUWanted = math.min(20, 5 + iCombatUnitsTableSize * 0.25)
                            tProtectiveMovePoint = M28Utilities.MoveInDirection(oACUToProtect:GetPosition(), M28Utilities.GetAngleFromAToB(tLZTeamData[M28Map.reftClosestFriendlyBase], oACUToProtect:GetPosition()), iDistInfrontOfACUWanted, true, false, M28Map.bIsCampaignMap)
                        end
                        local iAltPlateau, iAltLandZone
                        if tProtectiveMovePoint then iAltPlateau, iAltLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tProtectiveMovePoint) end
                        if not(iAltPlateau == iPlateau) then
                            --GetPositionAtOrNearTargetInPathingGroup(tStartPos,                 tTargetPos,            iDistanceFromTargetToStart, iAngleAdjust, oPathingUnit, bMoveCloserBeforeFurtherIfBlocked, bCheckIfExistingTargetIsBetter, iMinDistanceFromExistingCommandTarget)
                            tProtectiveMovePoint = M28Map.GetPositionAtOrNearTargetInPathingGroup(tProtectiveMovePoint,         oACUToProtect:GetPosition(),        iDistInfrontOfACUWanted,  0,    oACUToProtect,       true,                              false,                           nil)
                            if not(tProtectiveMovePoint) then tProtectiveMovePoint = oACUToProtect:GetPosition() end
                        end
                        local iACUDistToAlliedBase = M28Utilities.GetDistanceBetweenPositions(oACUToProtect:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to try and protect ACU owned by brain '..oACUToProtect:GetAIBrain().Nickname..', iACUDistToAlliedBase='..iACUDistToAlliedBase..'; tProtectiveMovePoint='..repru(tProtectiveMovePoint)..'; ACU position='..repru(oACUToProtect:GetPosition())) end
                        bGivenCombatUnitsOrders = true
                        for iCurUnit = iCombatUnitsTableSize, 1, -1 do
                            local oUnit = tUnitsToConsiderAndUpdate[iCurUnit]
                            if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId)) and (bHaveACUInTroubleAndRecentlyInCombat or (oOptionalEnemyToBeCloserTo and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oOptionalEnemyToBeCloserTo:GetPosition()) >= iOptionalMinDistToNearestEnemy)) then
                                --If further from allied base than ACU then move to the move point, otherwise attack-move
                                if bHaveACUInTroubleAndRecentlyInCombat and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) > iACUDistToAlliedBase then
                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                    M28Orders.IssueTrackedMove(oUnit, tProtectiveMovePoint, 3, false, 'RetPrACUM', false)
                                else
                                    if bHaveACUInTroubleAndRecentlyInCombat then oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime end
                                    M28Orders.IssueTrackedAttackMove(oUnit, tProtectiveMovePoint, 3, false, 'RetPrACUA', false)
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': sending unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to protect our ACU, bHaveACUInTroubleAndRecentlyInCombat='..tostring(bHaveACUInTroubleAndRecentlyInCombat)) end
                                table.remove(tUnitsToConsiderAndUpdate, iCurUnit)
                            end
                        end
                    elseif bHaveACUInTroubleAndRecentlyInCombat then
                        M28Utilities.ErrorHandler('Thought we would be protecting an ACU but no ACU to protect')
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if should move blocked units, bMoveBlockedNotAttackMove='..tostring(bMoveBlockedNotAttackMove)..'; iFriendlyBestMobileIndirectRange='..(iFriendlyBestMobileIndirectRange or 'nil')..';  tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; Enemy DF structure='..(tLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0)..'; Enemy DF mobile='..(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)..'; tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]='..(tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 'nil')..'; iFriendlyBestMobileDFRange='..(iFriendlyBestMobileDFRange or 'nil')..'; Enemy best DF range='..iEnemyBestDFRange..'; iFriendlyBestMobileIndirectRange='..(iFriendlyBestMobileIndirectRange or 'nil')..'; iEnemyBestStructureDFRange='..(iEnemyBestStructureDFRange or 'nil')..'; Enemy structure threat indirect='..(tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] or 'nil')..'; bEnemyHasNoDFUnits='..tostring(bEnemyHasNoDFUnits or false)..'; iEnemyBestDFRange='..(iEnemyBestDFRange or 'nil')..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] or 'nil')..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal]='..(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 'nil')..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; subrefiNearbyEnemyLongRangeDFThreat='..(tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0)..'; bAreInScenario1='..tostring(bAreInScenario1)) end
                --SCENARIO 1 - We outrange enemy DF units (mobile and fix), or have equal range but with either significantly more threat at that range, or nearest enemy lacks that range
                if bAreInScenario1 then
                    --ARE IN SCENARIO 1

                    if bDebugMessages == true then LOG(sFunctionRef..': In scenario 1, so we either outrange enemy, or we have significantly more threat at their best range - i.e. equal range, bAttackWithSameRange='..tostring(bAttackWithSameRange)) end
                    local tOutrangedCombatUnits = {}
                    local tUnitsToSupport = {}
                    local tFriendlyT2Arti --keep as nil, as will update if we think it is relevant
                    local bAttackWithOutrangedDFUnits = false
                    local iAngleThresholdForRally --i.e. what angle dif need between us and nearest enemy to just retreat in opposite direction instead of going to rally
                    local iSkirmisherDistToNearestEnemy
                    local bNearestEnemyIsACU = false
                    local bConsiderAttackingAdjacentZoneEnemyWithOutrangedUnits --if we have outranged IF like t1 arti and they outrange enemy in adjacent zone (but not this zone) then consider having them attack that zone; nil if not considered yet, otherwise true or false
                    local oAdjacentZoneEnemyToAttackWithOutrangedIF
                    if EntityCategoryContains(categories.COMMAND, oNearestEnemyToFriendlyBase.UnitId) then
                        bNearestEnemyIsACU = true
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': About to consider whether to attack with outranged units, is this core base='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])..'; are there dangerous enemies in this LZ='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])..'; Our mobile DF threat='..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]..'; Enemy combat total for this zone='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; Enemy threat in adj zones='..GetEnemyCombatThreatInAdjacentZones()) end
                    if tLZTeamData[M28Map.subrefLZbCoreBase] and tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] then
                        if bDebugMessages == true then LOG(sFunctionRef..': Are in core base so want to attack with outranged units if enemy is in this zone, subrefbDangerousEnemiesInThisLZ='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])) end
                        bAttackWithOutrangedDFUnits = true
                    elseif (tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] > 1.3 * math.max(20, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 0.5, tLZTeamData[M28Map.subrefThreatEnemyDFStructures] + tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]) and iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 1.1) then
                        bAttackWithOutrangedDFUnits = true

                        --Change to false if we are likeyl to have outranged DF units and enemy has significant nearby threat
                        local bExpectToHaveOutrangedDF = false
                        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                            if iThreat > 0 and iRange <= iEnemyBestDFRange then
                                bExpectToHaveOutrangedDF = true
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Our DF Threat '..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]..' exceeds enemy total combat threat '..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..' so want to attack with outranged DF units if this is also the case factoring in adjacent enemy zone threat, bExpectToHaveOutrangedDF='..tostring(bExpectToHaveOutrangedDF)) end
                        CalculateNearbyEnemyCombatThreatFriendlyDFAndIfFriendlyACUInCombat() --Updates iEnemyCombatThreat to reflect this zone, and also includes adjacent zones where enemis are close enough to join combat

                        if iEnemyCombatThreat > iOurDFAndT1ArtiCombatThreat or (iEnemyCombatThreat * 1.25 > iOurDFAndT1ArtiCombatThreat and (iEnemyCombatThreat > GetEnemyCombatThreatInAdjacentZones() * 0.8 or iOurDFAndT1ArtiCombatThreat <= 5000 or (iFriendlyBestMobileDFRange >= 60 and iEnemyBestDFRange < 60) or (tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] >= iOurDFAndT1ArtiCombatThreat * 0.3 and tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] >= tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] * 0.75))) then
                            bAttackWithOutrangedDFUnits = false
                            --Dont charge into PD unless have overwhelming force
                        elseif iEnemyBestStructureDFRange > 0 and iOurDFAndT1ArtiCombatThreat < 5000 and (tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] > iEnemyCombatThreat * 0.15 or (iEnemyBestStructureDFRange < 50 and iOurDFAndT1ArtiCombatThreat <= 2000 and tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] > 0)) and iEnemyCombatThreat * 3 > iOurDFAndT1ArtiCombatThreat then
                            bAttackWithOutrangedDFUnits = false
                            if bDebugMessages == true then LOG(sFunctionRef..': Dont ahve overwhelming mobile DF threat and have some indirect fire forces so wont launch all out attack just yet') end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iEnemyCombatThreat after factoring in nearby zones='..iEnemyCombatThreat..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]..'; bAttackWithOutrangedDFUnits='..tostring(bAttackWithOutrangedDFUnits)..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]..'; iEnemyBestStructureDFRange='..iEnemyBestStructureDFRange) end
                    end
                    --Want to avoid scenarios where e.g. lots of t3 mobile arti all fire at an enemy t1 engineer - if closest enemy is a non-combat unit or LAB and we have more threat generally then consider engaging logic
                    local bIFAttackNearestSignificantEnemy = false
                    if tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] >= 3000 and oNearestEnemyToFriendlyBase[M28UnitInfo.refiUnitMassCost] <= 150 then
                        CalculateNearbyEnemyCombatThreatFriendlyDFAndIfFriendlyACUInCombat() --in case not already calculated
                        if (bAttackWithOutrangedDFUnits or (tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] >= 8000 and iOurDFAndT1ArtiCombatThreat >= 1000) or (iOurDFAndT1ArtiCombatThreat >= iEnemyCombatThreat * 0.8 and tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] >= iEnemyCombatThreat) and (EntityCategoryContains(categories.MOBILE - M28UnitInfo.refCategoryLandCombat, oNearestEnemyToFriendlyBase.UnitId) or (oNearestEnemyToFriendlyBase[M28UnitInfo.refCategoryLandCombat] <= 42 and not(EntityCategoryContains(categories.MOBILE, oNearestEnemyToFriendlyBase.UnitId)))))  then
                            bIFAttackNearestSignificantEnemy = true
                        end
                    end

                    local toAdjacentEnemyMexes = GetMexesInThisOrAdjacentLandZone(tLZData, tLZTeamData, iTeam, iPlateau)--mexes in this or adjacent zones (so we can consider if one of these is closer to our unit than the nearest enemy)

                    if bDebugMessages == true then LOG(sFunctionRef..' Finished deciding if IF units should attack nearest significant enemy, bIFAttackNearestSignificantEnemy='..tostring(bIFAttackNearestSignificantEnemy)..'; Indirect total for this zone='..tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]..'; iOurDFAndT1ArtiCombatThreat='..(iOurDFAndT1ArtiCombatThreat or 'nil')..'; iEnemyCombatThreat if calculated='..(iEnemyCombatThreat or 'nil')..'; Nearest enemy mass value='..oNearestEnemyToFriendlyBase[M28UnitInfo.refiUnitMassCost]..'; UnitId='..oNearestEnemyToFriendlyBase.UnitId..'; oNearestEnemyToFriendlyBase DF range='..(oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 'nil')..'; Combat range='..(oNearestEnemyToFriendlyBase[M28UnitInfo.refiCombatRange] or 'nil')..'; Is toAdjacentEnemyMexes empty='..tostring(M28Utilities.IsTableEmpty(toAdjacentEnemyMexes))) end


                    local bUpdateNearestUnit = false
                    local bCheckIfNearestUnitVisible = false
                    if M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) >= 10 then bCheckIfNearestUnitVisible = true end
                    if oNearestEnemyToFriendlyBase[M28UnitInfo.refiCombatRange] >= 10 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding nearest enemy unit '..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..' to skirmisher enemies') end
                        table.insert(tSkirmisherDFEnemies, oNearestEnemyToFriendlyBase)
                        if oNearestEnemyToFriendlyBase[M28UnitInfo.refiIndirectRange] > 60 and oNearestEnemyToFriendlyBase[M28UnitInfo.refiIndirectRange] < 130 and EntityCategoryContains(M28UnitInfo.refCategoryT3MobileArtillery, oNearestEnemyToFriendlyBase.UnitId) then
                            table.insert(tSkirmisherEnemyT3MobileArti, oNearestEnemyToFriendlyBase)
                            if bDebugMessages == true then LOG(sFunctionRef..': Also adding enemy against tSkirmisherEnemyT3MobileArti') end
                        end
                    end
                    local bMoveToStopPDConstruction = false
                    local bMoveTowardsEngineers = false
                    if bDebugMessages == true then LOG(sFunctionRef..': In scenario 1, checking if enemy engineers, Is table of enemy engineers empty='..tostring(M28Utilities.IsTableEmpty(tEnemyEngineers))..'; enemy combat='..(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat) end
                    if M28Utilities.IsTableEmpty(tEnemyEngineers) == false and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 100 and (iAvailableCombatUnitThreat or 0) >= math.min(40, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 3) and iAvailableCombatUnitThreat <= 1500 and GetEnemyCombatThreatInAdjacentZones() <= 500  then
                        local tEnemyPD = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD, tLZTeamData[M28Map.subrefTEnemyUnits])
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy PD empty='..tostring(M28Utilities.IsTableEmpty(tEnemyPD))) end
                        if M28Utilities.IsTableEmpty(tEnemyPD) == false then
                            bMoveToStopPDConstruction = true
                            for iPD, oPD in tEnemyPD do
                                if oPD:GetFractionComplete() == 1 then
                                    bMoveToStopPDConstruction = false
                                    break
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': bMoveToStopPDConstruction before doublechecking threats='..tostring(bMoveToStopPDConstruction)) end
                            if bMoveToStopPDConstruction then
                                --Check we have significantly more threat if excluding under-construction PD
                                bMoveToStopPDConstruction = false
                                local iPDThreat = M28UnitInfo.GetCombatThreatRating(tEnemyPD, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': iPDThreat='..iPDThreat) end
                                if (iAvailableCombatUnitThreat or 0) > 2 * tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] - iPDThreat and iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() then
                                    bMoveToStopPDConstruction = true
                                end
                            end
                        else
                            --do we have engineers to attack instead?
                            if iAvailableCombatUnitThreat <= 400 and iAvailableCombatUnitThreat <= 300 then
                                bMoveTowardsEngineers = true
                            end
                        end
                    end

                    local iDistFromNearestEnemyToFriendlyBase = 10000 --used in some niche scenarios so we attack nearest unit e.g. mex instead of further away one
                    if oNearestEnemyToFriendlyBase then iDistFromNearestEnemyToFriendlyBase = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tLZTeamData[M28Map.reftClosestFriendlyBase]) end

                    function GivenIndirectAdjacentZoneKitingOrder(oUnit)
                        local bGivenOrder = false
                        if oAdjacentZoneEnemyToAttackWithOutrangedIF then
                            if bDebugMessages == true then LOG(sFunctionRef..': GivenIndirectAdjacentZoneKitingOrder is the unit close to reftoNearestDFEnemies='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 25, iTeam, true, nil, nil, oUnit, 15, false))) end
                            if not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 25, iTeam, true, nil, nil, oUnit, 15, false)) then
                                --Get the zone the enemy unit is in
                                local tTargetZoneTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][oAdjacentZoneEnemyToAttackWithOutrangedIF[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]][M28Map.subrefLZTeamData][iTeam]
                                if bDebugMessages == true then LOG(sFunctionRef..': GivenIndirectAdjacentZoneKitingOrder is the unit close to the target zone reftoNearestDFEnemies='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tTargetZoneTeamData[M28Map.reftoNearestDFEnemies], 5, iTeam, true, nil, nil, oUnit, 3, false))) end
                                if oAdjacentZoneEnemyToAttackWithOutrangedIF[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone or M28Utilities.IsTableEmpty(tTargetZoneTeamData[M28Map.reftoNearestDFEnemies]) or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tTargetZoneTeamData[M28Map.reftoNearestDFEnemies], 5, iTeam, true, nil, nil, oUnit, 3, false)) then
                                    --We can advance
                                    M28Orders.IssueTrackedAttackMove(oUnit, oAdjacentZoneEnemyToAttackWithOutrangedIF:GetPosition(), 3, false, 'SRIFAdjZ', false)
                                    bGivenOrder = true
                                end
                            end
                        else
                            M28Utilities.ErrorHandler('Running code without valid unit to consider attacking')
                        end
                        return bGivenOrder
                    end


                    if bDebugMessages == true then LOG(sFunctionRef..': Scenario 1 - will cycle through available combat units, is tSkirmisherDFEnemies empty='..tostring(M28Utilities.IsTableEmpty(tSkirmisherDFEnemies))..'; oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase) or 'nil')..'; bAreInScenario1 after potential update while in Scenario1='..tostring(bAreInScenario1)) end
                    bGivenCombatUnitsOrders = true
                    local bFiringAtNegligibleThreatInLRExperimentalRange = false --used for megalith and fatboy so won't attack-move towards enemy
                    if bAreInScenario1 then --Recheck as we might have changed to false if on checking adjacent zones an enemy outranges us
                        for iUnit, oUnit in tAvailableCombatUnits do
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Considering orders to give for scenario 1, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; iEnemyBestDFRange='..(iEnemyBestDFRange or 'nil')..'; bEnemyHasNoDFUnits='..tostring(bEnemyHasNoDFUnits or false)..'; Close to enemy unit (DF only) ='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], (oUnit[M28UnitInfo.refiDFRange] or 0) * 0.94, iTeam, false))..'; Was last shot blocked='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked] or false)..'; Is unit underwtaer='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; Can unit kite='..tostring(oUnit[M28UnitInfo.refbCanKite] or false)..'; Is table of enemy engineers empty='..tostring(M28Utilities.IsTableEmpty(tEnemyEngineers))..'; Time since last weapon event='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0)..'; Time between DF shots='..(oUnit[M28UnitInfo.refiTimeBetweenDFShots] or 'nil')..'; IF range='..(oUnit[M28UnitInfo.refiIndirectRange] or 0)..'; Time since last dropped='..'Time since last dropped='..(GetGameTimeSeconds() - (oUnit[M28Air.refiTimeLastDropped] or 0)))
                                if oUnit[M28UnitInfo.refiUnitMassCost] >= 10000 then LOG(sFunctionRef..': Have high value unit, does it have significant enemy threat if it was to attack the nearest enemy unit even if it is outranged? signif threat='..tostring(M28Conditions.HaveSignificantEnemyThreatWithinRange(tLZData, tLZTeamData, iPlateau, iTeam, M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition()) + 15, oNearestEnemyToFriendlyBase:GetPosition(), math.min(oUnit[M28UnitInfo.refiUnitMassCost] * 0.75, M28UnitInfo.GetCombatThreatRating({ oUnit }) * 0.8), nil, nil, true, true))..'; Unit threat rating='..M28UnitInfo.GetCombatThreatRating({ oUnit })..'; Dist to nearest enemy unit (actual dist)='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition())) end
                            end

                            --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                            if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end

                            --if bCheckIfNearLocationToAvoid and EntityCategoryContains(categories.TECH1 + categories.TECH2 - categories.COMMAND, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbSpecialMicroActive]) and M28Conditions.HaveSentOrderToRunAwayFromLocationToAvoid(oUnit, tLZTeamData[M28Map.reftiLocationsToAvoid], 4) then
                            --if bDebugMessages == true then LOG(sFunctionRef..': Told unit to avoid a location to avoid') end
                            if oUnit[M28UnitInfo.refiDFRange] > iEnemyBestDFRange or (bAttackWithSameRange and oUnit[M28UnitInfo.refiDFRange] >= iEnemyBestDFRange) or (iDFRangeOverrideForScenario1 and (oUnit[M28UnitInfo.refiDFRange] or 0) >= iDFRangeOverrideForScenario1)
                                    --Experimental exception - even if enemy threat in adjacent zones such we dont want to attack with everything, still consider attacking with experimental units
                                    or ((oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) >= 10000 and not(bAttackWithOutrangedDFUnits) and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < oUnit[M28UnitInfo.refiUnitMassCost] and not(M28Conditions.HaveSignificantEnemyThreatWithinRange(tLZData, tLZTeamData, iPlateau, iTeam, M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition()) + 15, oNearestEnemyToFriendlyBase:GetPosition(), math.min(oUnit[M28UnitInfo.refiUnitMassCost] * 0.75, M28UnitInfo.GetCombatThreatRating({ oUnit }) * 0.8), nil, nil, true, true)))
                            then
                                table.insert(tUnitsToSupport, oUnit)
                                if ProceedWithUnitOrder(oUnit, true) then
                                    --Consider kiting logic unless want to use shot blocked override logic
                                    if bDebugMessages == true then LOG(sFunctionRef..': We outrange enemy, considering if we want ot kite enemy or not, bMoveTowardsEngineers='..tostring(bMoveTowardsEngineers)..'; oUnit[M28UnitInfo.refbLastShotBlocked]='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked] or false)..'; Is unit underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; oUnit[M28UnitInfo.refbScoutCombatOverride]='..tostring(oUnit[M28UnitInfo.refbScoutCombatOverride] or false)..'; Is skirmisher category='..tostring(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId))) end
                                    if bMoveBlockedNotAttackMove and ((oUnit[M28UnitInfo.refbLastShotBlocked] and (not(oUnit[M28UnitInfo.refiDFMinRange]) or oUnit[M28UnitInfo.refiDFRange] <= 120)) or M28UnitInfo.IsUnitUnderwater(oUnit)) and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) and not(oUnit[M28UnitInfo.refbScoutCombatOverride]) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Think we are blocked so will move to nearest enemy') end
                                        M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'BlckM'..iLandZone)
                                    else
                                        --Easy mode logic?
                                        if oUnit[M28UnitInfo.refbEasyBrain] then
                                            --Attack-move to nearest enemy
                                            if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                M28Orders.IssueTrackedAttackMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'EsyLRAM'..iLandZone)
                                            end
                                        else
                                            --Experimental specific - attack ACU if in-range
                                            local bUseNormalLogic = true
                                            if bDebugMessages == true and oClosestFatboyOrACUInIslandToSuicideInto then LOG(sFunctionRef..': bConsiderAttackingACU='..tostring(bConsiderAttackingACU)..'; Dist to oClosestFatboyOrACUInIslandToSuicideInto='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFatboyOrACUInIslandToSuicideInto:GetPosition())..'; Unit combat range='..oUnit[M28UnitInfo.refiCombatRange]) end
                                            if bConsiderAttackingACU and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbScoutCombatOverride]) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), toEnemyACUsNearZone, 6 + oUnit[M28UnitInfo.refiDFRange], iTeam, false, nil, nil, nil, nil, nil) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Want to attack ACU with our experimental') end
                                                GetUnitToAttackNearestACUOrOverrideUnit(oUnit)
                                                bUseNormalLogic = false
                                            elseif bSuicideIntoFatboyOrACU and oClosestFatboyOrACUInIslandToSuicideInto and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId)) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFatboyOrACUInIslandToSuicideInto:GetPosition()) <= oUnit[M28UnitInfo.refiCombatRange] + 8 then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Are in range or almost in range of fatboy or acu to suicide into') end
                                                GetUnitToAttackNearestACUOrOverrideUnit(oUnit, oClosestFatboyOrACUInIslandToSuicideInto)
                                                bUseNormalLogic = false
                                            elseif bMoveTowardsEngineers and oUnit[M28UnitInfo.refiDFRange] > 0 and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + categories.EXPERIMENTAL + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) and not(oUnit[M28UnitInfo.refbScoutCombatOverride]) then
                                                local oNearestEngineerToUnit = M28Utilities.GetNearestUnit(tEnemyEngineers, oUnit:GetPosition())
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering moving towards nearest enemy engineer, oNearestEngineerToUnit='..(oNearestEngineerToUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEngineerToUnit) or 'nil')) end
                                                if oNearestEngineerToUnit then
                                                    --Use normal logic if are almost in reclaim range of the engineer
                                                    local iDistToEngineer = M28Utilities.GetDistanceBetweenPositions(oNearestEngineerToUnit:GetPosition(), oUnit:GetPosition())
                                                    if bDebugMessages == true then LOG(sFunctionRef..': oNearestEngineerToUnit='..oNearestEngineerToUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEngineerToUnit)..'; iDistToEngineer='..iDistToEngineer..'; oUnit[M28UnitInfo.refiDFRange]='..oUnit[M28UnitInfo.refiDFRange] ..'; Eng build range='..(oNearestEngineerToUnit:GetBlueprint().Economy.MaxBuildDistance or 0)) end
                                                    if not(iDistToEngineer <= math.min(oUnit[M28UnitInfo.refiDFRange] - 3, (oNearestEngineerToUnit:GetBlueprint().Economy.MaxBuildDistance or 0) + 5)) then
                                                        --Move towards the engineer, or attack move if are close
                                                        bUseNormalLogic = false
                                                        if iDistToEngineer <= oUnit[M28UnitInfo.refiDFRange] - 2.5 then
                                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEngineerToUnit:GetPosition(), math.min(4, oUnit[M28UnitInfo.refiDFRange] * 0.5), false, 'EnAMve'..iLandZone, false)
                                                        else
                                                            M28Orders.IssueTrackedMove(oUnit, oNearestEngineerToUnit:GetPosition(), math.min(4, oUnit[M28UnitInfo.refiDFRange]  * 0.5), false, 'EnMve'..iLandZone, false)
                                                        end
                                                    end
                                                end
                                            end
                                            if bUseNormalLogic then
                                                --Experimental specific - update the bFiringAtNegligibleThreatInLRExperimentalRange flag
                                                bFiringAtNegligibleThreatInLRExperimentalRange = false
                                                --Note - iVisibleLandCombatMassInFatboyRange uses getunitsaroundpoint so wont factor in memory; therefore want to use more accurate method to avoid fatboy charging towards a monkeylord that recently fired at us
                                                if (oUnit[M28UnitInfo.refiDFRange] or 0) >= 60 and EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and (iVisibleLandCombatMassInFatboyRange <= 3000 or not(EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId))) then
                                                    --Only consider if we have fired in the last 10s (otherwise it doesnt matter)
                                                    local iMassThresholdForNegligibleThreat = 1600
                                                    if oUnit[M28UnitInfo.refiLastWeaponEvent] and GetGameTimeSeconds() - oUnit[M28UnitInfo.refiLastWeaponEvent] <= 10 then
                                                        --Get accurate measure of enemy threat within our range
                                                        local iFriendlyExpFactor = 1 --If we have lots of fatboys nearby want to be much more aggressive
                                                        if not(tFriendlyNearbyExperimentals) then tFriendlyNearbyExperimentals = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental, tAvailableCombatUnits) end
                                                        if M28Utilities.IsTableEmpty(tFriendlyNearbyExperimentals) == false then
                                                            for iExp, oExp in tFriendlyNearbyExperimentals do
                                                                if not(oExp == oUnit) and M28UnitInfo.GetUnitHealthAndShieldPercent(oUnit) >= 0.75 then
                                                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oExp:GetPosition(), oUnit:GetPosition())
                                                                    if iCurDist <= 60 and (iCurDist <= 30 or oUnit[M28UnitInfo.refiDFRange] >= 90 or (iCurDist <= 45 and oUnit[M28UnitInfo.refiDFRange] >= 60)) then
                                                                        iFriendlyExpFactor = iFriendlyExpFactor + 1
                                                                    elseif iCurDist <= 70 then
                                                                        iFriendlyExpFactor = iFriendlyExpFactor + 0.4
                                                                    end
                                                                end
                                                            end
                                                        end
                                                        iMassThresholdForNegligibleThreat = iMassThresholdForNegligibleThreat * iFriendlyExpFactor
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Assing if enemy has negligible threat, iFriendlyExpFactor='..iFriendlyExpFactor..'; iMassThresholdForNegligibleThreat='..iMassThresholdForNegligibleThreat) end
                                                        --HaveSignificantEnemyThreatWithinRange(tLZData, tLZTeamData, iPlateau, iTeam, iSearchDistance, tStartPoint, iEnemyMassTotalThreshold, iOptionalSearchCategory, tOptionalAdditionalUnits, bOnlyIncludeDFUnits, bIncludeEnemyCombatRange)
                                                        bFiringAtNegligibleThreatInLRExperimentalRange = not(M28Conditions.HaveSignificantEnemyThreatWithinRange(tLZData, tLZTeamData, iPlateau, iTeam, oUnit[M28UnitInfo.refiDFRange] + 3, oUnit:GetPosition(), iMassThresholdForNegligibleThreat, M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryT2PlusPD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryNavalSurface - categories.TECH1 + categories.COMMAND, tUnitsNearFatboyInFurtherAwayZones))
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': bFiringAtNegligibleThreatInLRExperimentalRange='..tostring(bFiringAtNegligibleThreatInLRExperimentalRange)..'; Time since we last fired weapon='..(GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0))..'; Have significant enemy threat within range='..tostring(M28Conditions.HaveSignificantEnemyThreatWithinRange(tLZData, tLZTeamData, iPlateau, iTeam, (oUnit[M28UnitInfo.refiDFRange] or 0) + 3, oUnit:GetPosition(), iMassThresholdForNegligibleThreat, M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryT2PlusPD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryNavalSurface - categories.TECH1 + categories.COMMAND, tUnitsNearFatboyInFurtherAwayZones))..'; tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]='..tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]) end
                                                end

                                                --Are we in range of any enemy or cant kite?
                                                --CloseToEnemyUnit(tStartPosition,      tUnitsToCheck,         iDistThreshold,             iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure)                                                                                                                                                                                     CloseToEnemyUnit(tStartPosition,      tUnitsToCheck,                                        iDistThreshold,             iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure)
                                                if bDebugMessages == true then LOG(sFunctionRef..': About to check if we are about to be in range of the enemy and so want to do a kiting retreat, our DF range='..oUnit[M28UnitInfo.refiDFRange]..'; iEnemyBestDFRange='..iEnemyBestDFRange..'; Expected threshold for close to enemy='..math.min(oUnit[M28UnitInfo.refiDFRange], math.max(oUnit[M28UnitInfo.refiDFRange] - 3,  iEnemyBestDFRange + oUnit:GetBlueprint().Physics.MaxSpeed + 2))..'; bUseNormalLogic before fatboy adj='..tostring(bUseNormalLogic)..'; iVisibleLandCombatMassInFatboyRange='..(iVisibleLandCombatMassInFatboyRange or 'nil')..'; Dist to nearest enemy to friendly base='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition())..'; DF Enemies within 7 of our range='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiCombatRange] - 7, iTeam, false, nil, nil, oUnit, nil, false))) end
                                                --Fatboy special logic if fatboy not in water - although default logic works fori t, want to do a more detailed check that looks into further away zones for nearby enemies
                                                if (oUnit[M28UnitInfo.refiDFRange] or 0) >= 100 and not(bFiringAtNegligibleThreatInLRExperimentalRange) and oUnit[M28UnitInfo.refbCanKite] and (GetEnemyCombatThreatInAdjacentZones() >= 8000 or iVisibleLandCombatMassInFatboyRange >= 3000) then
                                                    --First make sure the fatboy is closer to enemy base than the closest friendly base is (otherwise we risk 'retreating' to a base that takes us closer to the enemy)
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if fatboy is closer to enemy base than our closest friendly base, and significant visible mass, iVisibleLandCombatMassInFatboyRange='..iVisibleLandCombatMassInFatboyRange..'; Is table of nearby enemy t2 arti empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]))..'; Mod dist%='..tLZTeamData[M28Map.refiModDistancePercent]..'; Dist to oNearestEnemyToFriendlyBase='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition()))
                                                        if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then LOG(sFunctionRef..'; [M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]='..oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])..'; Dist to this='..M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition())..'; Can see this unit='..tostring(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], false))) end
                                                    end
                                                    if (iVisibleLandCombatMassInFatboyRange >= 6000 or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) or (tLZTeamData[M28Map.refiModDistancePercent] >= 0.1 and not(bFiringAtNegligibleThreatInLRExperimentalRange and GetEnemyCombatThreatInAdjacentZones() >= 8000)))
                                                            and oNearestEnemyToFriendlyBase and (M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition()) < oUnit[M28UnitInfo.refiDFRange] - 10 or (iVisibleLandCombatMassInFatboyRange >= 12000 and M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()) < oUnit[M28UnitInfo.refiDFRange] - 4))
                                                            and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase]) < M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], tLZTeamData[M28Map.reftClosestEnemyBase]) then
                                                        bUseNormalLogic = false
                                                        local oClosestEnemy
                                                        local iDistToClosestEnemy
                                                        if (iVisibleLandCombatMassInFatboyRange >= 8000 and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange] - 6, iTeam, false, nil, oUnit, oUnit, oUnit[M28UnitInfo.refiDFRange] - 10, false)) or M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                                                            if not(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) then
                                                                oClosestEnemy = oNearestEnemyToFriendlyBase
                                                                iDistToClosestEnemy = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition())
                                                            else
                                                                local iDistToClosestToBaseEnemy = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition())
                                                                local iDistToLastEnemyCheckEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition())
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to go with closest enemy from last check, or nearest enemy to friendly base, iDistToClosestToBaseEnemy='..iDistToClosestToBaseEnemy..'; iDistToLastEnemyCheckEnemy='..iDistToLastEnemyCheckEnemy) end
                                                                if iDistToLastEnemyCheckEnemy < iDistToClosestToBaseEnemy then
                                                                    iDistToClosestEnemy = iDistToLastEnemyCheckEnemy
                                                                    oClosestEnemy = oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]
                                                                else
                                                                    iDistToClosestEnemy = iDistToClosestToBaseEnemy
                                                                    oClosestEnemy = oNearestEnemyToFriendlyBase
                                                                end
                                                            end
                                                        else
                                                            oClosestEnemy = oNearestEnemyToFriendlyBase
                                                            iDistToClosestEnemy = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition())
                                                        end
                                                        if bDebugMessages == true then LOG(sFunctionRef..': iDistToClosestEnemy='..iDistToClosestEnemy..'; oClosestEnemy='..oClosestEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemy)) end
                                                        --QUIET/LOUD - special logic where attack-move towards enemy instead of kiting if it isnt too close (due to fatboy being inaccurate when firing)
                                                        if (M28Utilities.bQuietModActive or M28Utilities.bLoudModActive) and iDistToClosestEnemy >= oUnit[M28UnitInfo.refiCombatRange] - 25 and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) or M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiCombatRange] - 7, iTeam, false, nil, nil, oUnit, nil, false)) then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': QUIET/LOUD exception - attackmove as enemy in range but not too close') end
                                                            M28Orders.IssueTrackedAttackMove(oUnit, oClosestEnemy:GetPosition(), 3, false, 'FatbKtQT',false)
                                                        else
                                                            --Want to do kiting retreat towards nearest friendly base, or (if in a significantly different direction to the nearest enemy unit and mod dist is low
                                                            local tBaseRally
                                                            local iBackupDist = (oUnit:GetBlueprint().Physics.BackUpDistance or 0)
                                                            local bCanPathToBase = false
                                                            if iPlateau == NavUtils.GetLabel(M28Map.refPathingTypeHover, tLZTeamData[M28Map.reftClosestFriendlyBase]) then
                                                                --Are we amphibious, or on the same island as the closest base?
                                                                if EntityCategoryContains(M28UnitInfo.refCategoryAmphibious + categories.HOVER, oUnit.UnitId) or NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition()) == tLZData[M28Map.subrefLZIslandRef] then
                                                                    bCanPathToBase = true
                                                                end
                                                            end

                                                            if bCanPathToBase then
                                                                tBaseRally = {tLZTeamData[M28Map.reftClosestFriendlyBase][1], tLZTeamData[M28Map.reftClosestFriendlyBase][2], tLZTeamData[M28Map.reftClosestFriendlyBase][3]}
                                                            else
                                                                tBaseRally = {tRallyPoint[1], tRallyPoint[2], tRallyPoint[3]}
                                                            end

                                                            local tFatboyRetreatLocation
                                                            local iCurDistToBackup = math.max(0, iBackupDist - 1)
                                                            if iBackupDist >= 3 then
                                                                local iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tBaseRally)

                                                                --Further check - consider angle to enemy unit nearest midpoint, and also angle to nearest enemy base
                                                                local iAngleToRetreat
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering fatboy kiting retreat location, LZData mod dist%='.. tLZTeamData[M28Map.refiModDistancePercent]..'; iAngleToRally='..iAngleToRally..'; Angle to nearest enemy to midpoint='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Angle to nearest enemy base='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase])..'; Dist to closest friendly base='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])) end
                                                                --if bDebugMessages == true then LOG(sFunctionRef..': Considering fatboy kiting retreat location, LZData mod dist%='.. tLZTeamData[M28Map.refiModDistancePercent]..'; iAngleToRally='..iAngleToRally..'; Angle to nearest enemy to midpoint='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Angle to nearest enemy base='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase])..'; Dist to closest friendly base='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]))
                                                                local iAngleToNearestEnemy
                                                                if oNearestEnemyToFriendlyBase then
                                                                    iAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oClosestEnemy:GetPosition())
                                                                else
                                                                    iAngleToNearestEnemy = iAngleToRally - 180 --redundancy
                                                                end
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to go in opposite direction to nearest enemy, or to the rally, Angle dif between algoe to enemy and angle to rally='.. M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToRally)..'; iDistToClosestEnemy='..iDistToClosestEnemy..'; Closest enemy DF range='..(oClosestEnemy[M28UnitInfo.refiDFRange] or 0)..'; ClosestEnemy='..oClosestEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemy)) end
                                                                local bRunFromNearestEnemy = false
                                                                local iAngleToRunFromNearestEnemy = iAngleToNearestEnemy - 180
                                                                local iAngleDifFromRunningFromEnemyAndRally = M28Utilities.GetAngleDifference(iAngleToRunFromNearestEnemy, iAngleToRally)
                                                                local iAngleToNearestEnemyBase = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase])

                                                                if tLZTeamData[M28Map.refiModDistancePercent] <= 0.4 and (M28Utilities.GetAngleDifference(iAngleToRally, iAngleToNearestEnemyBase) <= 115 or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 60) then
                                                                    --Moving towards the rally point isn't htat much of a dif from moving to the closest enemy or from moving to the closest enemy base, and our mod dist is already fairly low, so we may well be moving towards danger with the nearest base being overrun
                                                                    bRunFromNearestEnemy = true
                                                                elseif iAngleDifFromRunningFromEnemyAndRally <= 10 then
                                                                    --Might as well run to the rally
                                                                elseif (iVisibleLandCombatMassInFatboyRange >= 10000 and iAngleDifFromRunningFromEnemyAndRally <= 80) or (tLZTeamData[M28Map.refiModDistancePercent] <= 0.4 and iDistToClosestEnemy - (oClosestEnemy[M28UnitInfo.refiDFRange] or 0) <= 60 and iDistToClosestEnemy >= 30) then
                                                                    --Might as well run from nearest enemy as not that much dif to running to the nearest rally, but enough fo a difference that we may well turn around for a while trying to go to the rally
                                                                    bRunFromNearestEnemy = true
                                                                end
                                                                if bRunFromNearestEnemy then
                                                                    --Double check if we move 30 back we can path there
                                                                    local tFurtherBackupDist = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToRunFromNearestEnemy, 30, true, true, false)
                                                                    if M28Utilities.IsTableEmpty(tFurtherBackupDist) or not(NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, tFurtherBackupDist) == iPlateau) then
                                                                        bRunFromNearestEnemy = false
                                                                    end
                                                                end
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to go to rally or away from nearest enemy, bRunFromNearestEnemy='..tostring(bRunFromNearestEnemy)..'; iAngleDifFromRunningFromEnemyAndRally='..iAngleDifFromRunningFromEnemyAndRally..'; iDistToClosestEnemy='..iDistToClosestEnemy..'; Dist until in range of them='..iDistToClosestEnemy - (oClosestEnemy[M28UnitInfo.refiDFRange] or 0) <= 60) end
                                                                if bRunFromNearestEnemy then
                                                                    iAngleToRetreat = iAngleToRunFromNearestEnemy
                                                                else
                                                                    iAngleToRetreat = iAngleToRally
                                                                end



                                                                while iCurDistToBackup >= 2 do
                                                                    tFatboyRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToRetreat, iCurDistToBackup, true, true, false)
                                                                    if tFatboyRetreatLocation and NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover,tFatboyRetreatLocation) == iPlateau then
                                                                        break
                                                                    else
                                                                        iCurDistToBackup = iCurDistToBackup - 2
                                                                    end
                                                                end
                                                                if iCurDistToBackup < 2 then
                                                                    tFatboyRetreatLocation = tBaseRally
                                                                end
                                                            else --redundancy
                                                                tFatboyRetreatLocation = tBaseRally
                                                            end

                                                            if bDebugMessages == true then LOG(sFunctionRef..': Giving kiting retreat order to fatboy, iCurDistToBackup='..iCurDistToBackup) end
                                                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                            ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tFatboyRetreatLocation, iPlateau, 'FatbKit', true, nil, 60)
                                                        end
                                                        --M28Orders.IssueTrackedMove(oUnit, tFatboyRetreatLocation, math.min(math.max(1, iCurDistToBackup - 3), 8), false, 'FatbKit', false)
                                                    end
                                                end
                                                --Finished considering fatboy specific logic (if relevant), iwll now proceed with normal logic for all units (and fatboy if we didnt give it specific orders)
                                                if bUseNormalLogic then
                                                    oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] = false --will be replaced by making it nil if we do the closest unit check
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Is unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' a skirmisher='..tostring(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId))..'; Are we close to skirmisher enemies='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tSkirmisherDFEnemies, oUnit[M28UnitInfo.refiDFRange], iTeam, false,                  nil,                    oUnit,                              oUnit                                   ,   math.min(oUnit[M28UnitInfo.refiDFRange], math.max(oUnit[M28UnitInfo.refiDFRange] - 3,  iEnemyBestDFRange + oUnit:GetBlueprint().Physics.MaxSpeed + 2))))..'; oUnit:GetPosition() used for closetoenemycheck='..repru(oUnit:GetPosition())..'; iDFRangeOverrideForScenario1='..(iDFRangeOverrideForScenario1 or 'nil')..'; Line1Cond='..tostring(bFiringAtNegligibleThreatInLRExperimentalRange)..'; Line2Cond='..tostring((bEnemyHasNoDFUnits and (iAvailableCombatUnitThreat >= 1500 or M28Utilities.IsTableEmpty(tEnemyEngineers))))..'; Line3Cond='..tostring(not(oUnit[M28UnitInfo.refbCanKite]))..'; Line4Cond='..tostring(((EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) or oUnit[M28UnitInfo.refbScoutCombatOverride]) and not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tSkirmisherDFEnemies, oUnit[M28UnitInfo.refiDFRange], iTeam, false,                  nil,                    oUnit,                              oUnit                                   ,   math.min(oUnit[M28UnitInfo.refiDFRange], math.max(oUnit[M28UnitInfo.refiDFRange] - 3,  iEnemyBestDFRange + oUnit:GetBlueprint().Physics.MaxSpeed + 2))))))..'; Line5Cond='..tostring(((not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) and not(oUnit[M28UnitInfo.refbScoutCombatOverride]) and (iAvailableCombatUnitThreat >= 1500 or M28Utilities.IsTableEmpty(tEnemyEngineers) or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tEnemyEngineers, math.min(15, oUnit[M28UnitInfo.refiDFRange] - 4.5), iTeam, false, nil, nil))))))..'; Line6Cond='..tostring(((not(iDFRangeOverrideForScenario1) or oUnit[M28UnitInfo.refiDFRange] > iEnemyBestDFRange) and not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange] * 0.94, iTeam, false,                   nil,                    nil,                                oUnit                                       , math.min(oUnit[M28UnitInfo.refiDFRange] * 0.94, math.max(oUnit[M28UnitInfo.refiDFRange] * 0.94 - 4,  iEnemyBestDFRange + 4))))))..'; Line7Cond='..tostring((iDFRangeOverrideForScenario1 and oUnit[M28UnitInfo.refiDFRange] <= iEnemyBestDFRange and not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], math.max(oUnit[M28UnitInfo.refiDFRange] * 0.94,6, iDFRangeOverrideForScenario1 - (oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0)), iTeam, true,                   nil,                    nil,                                oUnit                                       , nil))))..'; bSuicideIntoFatboyOrACU='..tostring(bSuicideIntoFatboyOrACU or false)) end
                                                    --CloseToEnemyUnit(tStartPosition,      tUnitsToCheck,      iDistThreshold,              iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                                                    if      bFiringAtNegligibleThreatInLRExperimentalRange or
                                                            (bEnemyHasNoDFUnits and (iAvailableCombatUnitThreat >= 1500 or M28Utilities.IsTableEmpty(tEnemyEngineers))) or
                                                            not(oUnit[M28UnitInfo.refbCanKite]) or
                                                            ((EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) or oUnit[M28UnitInfo.refbScoutCombatOverride]) and not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tSkirmisherDFEnemies, oUnit[M28UnitInfo.refiDFRange], iTeam, false,                  nil,                    oUnit,                              oUnit                                   ,   math.min(oUnit[M28UnitInfo.refiDFRange], math.max(oUnit[M28UnitInfo.refiDFRange] - 3,  iEnemyBestDFRange + oUnit:GetBlueprint().Physics.MaxSpeed + 2)))) and (not(tHiddenIFEnemies) or not(M28Conditions.CloseToIFUnit(oUnit, tHiddenIFEnemies, iTeam, 6)))) or
                                                            --CloseToEnemyUnit(tStartPosition,      tUnitsToCheck,                            iDistThreshold,                     iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                                                            ((not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) and not(oUnit[M28UnitInfo.refbScoutCombatOverride]) and (iAvailableCombatUnitThreat >= 1500 or M28Utilities.IsTableEmpty(tEnemyEngineers) or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tEnemyEngineers, math.min(15, oUnit[M28UnitInfo.refiDFRange] - 4.5), iTeam, false, nil, nil))) and
                                                                    --Closet to enemy check for the immediate row above - if this unit is outranged by best enemy unit, but is trying to attack the closest enemy unit (that it outranges) then adjust the close to enemy unit check to include enemy range
                                                                    ((not(iDFRangeOverrideForScenario1) or oUnit[M28UnitInfo.refiDFRange] > iEnemyBestDFRange) and not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange] * 0.94, iTeam, false,                   nil,                    nil,                                oUnit                                       , math.min(oUnit[M28UnitInfo.refiDFRange] * 0.94, math.max(oUnit[M28UnitInfo.refiDFRange] * 0.94 - 4,  iEnemyBestDFRange + 4)))))))
                                                            --CloseToEnemyUnit(tStartPosition, tUnitsToCheck,                               6,                                  iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                                                            --NOTE: line 6 condition above does a close to enemy check if we outrange enemy best range; so only consider below if we dont outrange enemy best DF range, for performance reasons
                                                            or (iDFRangeOverrideForScenario1 and oUnit[M28UnitInfo.refiDFRange] <= iEnemyBestDFRange and not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], math.max(oUnit[M28UnitInfo.refiDFRange] - oUnit[M28UnitInfo.refiDFRange],6, iDFRangeOverrideForScenario1 - (oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0)), iTeam, true,                   nil,                    nil,                                oUnit                                       , nil))) then


                                                        if bDebugMessages == true then
                                                            LOG(sFunctionRef..': Not in range of enemy yet or we cant kite, and we outrange enemy; bFiringAtNegligibleThreatInLRExperimentalRange='..tostring(bFiringAtNegligibleThreatInLRExperimentalRange)..'; bEnemyHasNoDFUnits='..tostring(bEnemyHasNoDFUnits)..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..oUnit[M28UnitInfo.refiDFRange]..'; oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..'; oNearestEnemyToFriendlyBase DF range='..(oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oNearestEnemyToFriendlyBase:GetPosition())..'; Enemy last recorded position='..repru(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; LZ midpoint position='..repru(tLZData[M28Map.subrefMidpoint])..'; Is closest enemy unit from last check valid='..tostring(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]))..'; Closeest unit from last check='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or 'nil')..'; Do we have a Sera sniperbot='..tostring(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher * categories.SERAPHIM, oUnit.UnitId))..'; bNearestEnemyNeedsManualAttack='..tostring(bNearestEnemyNeedsManualAttack))
                                                            if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                                                                LOG(sFunctionRef..': Distance to the closest enemy from check='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())..'; Is unit visible='..tostring(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]))..'; Is unit T1 mobile land='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryMobileLand * categories.TECH1 - categories.COMMAND, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId)))
                                                            end
                                                        end

                                                        --Sniperbot where enemy has mobile arti, and we lack shield coverage and our shot is blocked - retreat instead of attacking
                                                        if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoMobileArtiRecentlyRanFrom]) then
                                                            local bRecordedAlready = false
                                                            if M28Utilities.IsTableEmpty(tSkirmisherEnemyT3MobileArti) == false then
                                                                for iMobileArti, oMobileArti in tSkirmisherEnemyT3MobileArti do
                                                                    if oMobileArti == oUnit[M28UnitInfo.refoMobileArtiRecentlyRanFrom] then bRecordedAlready = true break end
                                                                end
                                                            end
                                                            if not(bRecordedAlready) then table.insert(tSkirmisherEnemyT3MobileArti, oUnit[M28UnitInfo.refoMobileArtiRecentlyRanFrom]) end
                                                        end
                                                        if M28Utilities.IsTableEmpty(tSkirmisherEnemyT3MobileArti) == false and EntityCategoryContains(M28UnitInfo.refCategorySniperBot + M28UnitInfo.refCategoryAbsolver - categories.EXPERIMENTAL, oUnit.UnitId) and (not(M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileShield])) or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[refoAssignedMobileShield]:GetPosition()) >= 12) then
                                                            --Check we are close manually (as dont want to override refoClosestEnemyFromLastCloseToEnemyUnitCheck, and want to check if either shot is blocked or the arti is the closest enemy unit)
                                                            local oClosestEnemyMobileArti
                                                            local iClosestEnemyMobileArtiDist = 1000
                                                            local iMobileArtiAlmostWithinRange = 0

                                                            for iMobileArti, oMobileArti in tSkirmisherEnemyT3MobileArti do
                                                                if oMobileArti[M28UnitInfo.refiCombatRange] > oUnit[M28UnitInfo.refiCombatRange] then
                                                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oMobileArti:GetPosition(), oUnit:GetPosition()) - oMobileArti[M28UnitInfo.refiCombatRange]
                                                                    if iCurDist < iClosestEnemyMobileArtiDist then
                                                                        iClosestEnemyMobileArtiDist = iCurDist
                                                                        oClosestEnemyMobileArti = oMobileArti
                                                                    end
                                                                    if iCurDist <= 40 then iMobileArtiAlmostWithinRange = iMobileArtiAlmostWithinRange + 1 end
                                                                end
                                                            end
                                                            --If our shot is blocked or enemy has 4+ nearby mobile arti then consider retreating
                                                            if bDebugMessages == true then LOG(sFunctionRef..': oClosestEnemyMobileArti='..(oClosestEnemyMobileArti.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyMobileArti) or 'nil')..'; Combat range='..(oClosestEnemyMobileArti[M28UnitInfo.refiCombatRange] or 'nil')..'; iClosestEnemyMobileArtiDist after reducing for combat range='..iClosestEnemyMobileArtiDist..'; iMobileArtiAlmostWithinRange='..iMobileArtiAlmostWithinRange)
                                                                if oClosestEnemyMobileArti then LOG(sFunctionRef..': Is shot blocked to nearest mobile arti='..tostring(M28Logic.IsShotBlocked(oUnit, oClosestEnemyMobileArti))) end
                                                            end
                                                            --Did 12 dist threshold but due to high firing randomness were still sometimes dying to mobile arti
                                                            if oClosestEnemyMobileArti and iClosestEnemyMobileArtiDist < 20 and (iMobileArtiAlmostWithinRange >= 4 or M28Logic.IsShotBlocked(oUnit, oClosestEnemyMobileArti)) then --within 12 of being in range of their mobile arti
                                                                --Do we have friendly T2 arti firing at their arti/in range of it? if so then attack with sniperbots still if our sniperbots will be ready to fire soon
                                                                local bHaveFriendlyT2Arti
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Will consider if enemy t3 arti in range of friendly t2 arti, Time since refiTimeOurT2ArtiLastFired='..GetGameTimeSeconds() - (tLZTeamData[M28Map.refiTimeOurT2ArtiLastFired] or 0)..'; Time since oUnit fired='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0)..'; refiTimeBetweenDFShots='..(oUnit[M28UnitInfo.refiTimeBetweenDFShots] or 0)) end
                                                                if tLZTeamData[M28Map.refiTimeOurT2ArtiLastFired] and GetGameTimeSeconds() - tLZTeamData[M28Map.refiTimeOurT2ArtiLastFired] <= 30 and (not(oUnit[M28UnitInfo.refiLastWeaponEvent]) or GetGameTimeSeconds() - oUnit[M28UnitInfo.refiLastWeaponEvent] + 2 >= (oUnit[M28UnitInfo.refiTimeBetweenDFShots] or 3)) then
                                                                    if not(tFriendlyT2Arti) then tFriendlyT2Arti = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) end
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': is tFriendlyT2Arti empty='..tostring(M28Utilities.IsTableEmpty(tFriendlyT2Arti))) end
                                                                    if M28Utilities.IsTableEmpty(tFriendlyT2Arti) == false then
                                                                        for iT2Arti, oT2Arti in  tFriendlyT2Arti do
                                                                            if bDebugMessages == true then LOG(sFunctionRef..': Dist between oT2Arti='..oT2Arti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oT2Arti)..' and oClosestEnemyMobileArti='..oClosestEnemyMobileArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyMobileArti)..'='..M28Utilities.GetDistanceBetweenPositions(oT2Arti:GetPosition(), oClosestEnemyMobileArti:GetPosition())) end
                                                                            if oT2Arti:GetFractionComplete() >= 1 and M28Utilities.GetDistanceBetweenPositions(oT2Arti:GetPosition(), oClosestEnemyMobileArti:GetPosition()) <= oT2Arti[M28UnitInfo.refiIndirectRange] then
                                                                                bHaveFriendlyT2Arti = true
                                                                                break
                                                                            end
                                                                        end
                                                                    end
                                                                end
                                                                if not(bHaveFriendlyT2Arti) then
                                                                    bUseNormalLogic = false
                                                                    local tRetreatLocationToUse
                                                                    local iAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oClosestEnemyMobileArti:GetPosition())
                                                                    local iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tAmphibiousRallyPoint)
                                                                    if M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToRally) <= 65 then
                                                                        local tPotentialRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToNearestEnemy - 180, 15, true, nil, M28Map.bIsCampaignMap)
                                                                        if M28Utilities.IsTableEmpty(tPotentialRetreatLocation) == false and NavUtils.GetLabel(M28Map.refPathingTypeHover, tPotentialRetreatLocation) == iPlateau then
                                                                            tRetreatLocationToUse = {tPotentialRetreatLocation[1], tPotentialRetreatLocation[2], tPotentialRetreatLocation[3]}
                                                                        end
                                                                    end
                                                                    if not(tRetreatLocationToUse) then
                                                                        --Enemy has DF units and they are already in our range so retreat
                                                                        if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                                                            tRetreatLocationToUse = {tAmphibiousRallyPoint[1], tAmphibiousRallyPoint[2], tAmphibiousRallyPoint[3]}
                                                                        else
                                                                            tRetreatLocationToUse = {tRallyPoint[1], tRallyPoint[2], tRallyPoint[3]}
                                                                        end
                                                                    end
                                                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                                    oUnit[M28UnitInfo.refoMobileArtiRecentlyRanFrom] = oClosestEnemyMobileArti
                                                                    M28Orders.IssueTrackedMove(oUnit, tRetreatLocationToUse, 6, false, 'MobArRetr'..iLandZone)
                                                                end
                                                            end
                                                        end


                                                        --Megalith - consider moving backwards if enemy in range and we outrange enemy
                                                        if not(bFiringAtNegligibleThreatInLRExperimentalRange) and not(oUnit[M28UnitInfo.refbCanKite]) and EntityCategoryContains(M28UnitInfo.refCategoryMegalith, oUnit.UnitId) and bUseNormalLogic then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering moving backwards for megalith, iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; Enemy threat in adj zones='..GetEnemyCombatThreatInAdjacentZones()..'; Is closest enemy from last close to enemy check valid='..tostring(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]))..'; Are we close to nearby enemy DF units='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], (oUnit[M28UnitInfo.refiDFRange] or 0) - 1, iTeam, false, nil, nil, oUnit))..';  oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]='..( oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount( oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or 'nil')) end
                                                            if iAvailableCombatUnitThreat < GetEnemyCombatThreatInAdjacentZones() * 8 and ((not(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], (oUnit[M28UnitInfo.refiDFRange] or 0) - 1, iTeam, false, nil, nil, oUnit)) or (M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]))) and EntityCategoryContains(categories.TECH3 + categories.EXPERIMENTAL - M28UnitInfo.refCategoryStructure, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId) then
                                                                local iDistToNearestEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition())
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to do kiting retreat with megalith, iDistToNearestEnemy='..iDistToNearestEnemy) end
                                                                --If 3 inside our range, or just inside our range but enemy is moving towards us, then consider kiting
                                                                if iDistToNearestEnemy < oUnit[M28UnitInfo.refiDFRange] - 3 or (iDistToNearestEnemy < oUnit[M28UnitInfo.refiDFRange] and oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:IsUnitState('Moving') and M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), M28UnitInfo.GetUnitFacingAngle(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) <= 45) then
                                                                    --Are we in range of the enemy? If so then stop microing back in case it risks hurting our DPS, and so we can focus down the lowest health enemy experimental; exception if no enemy exps, in which case retreating might help us get closer to friendly units
                                                                    --Have put a weapon event <=6s to try and cover the scenario where megalith is trying to retreat back but all the enemy units have gotten bheind it and it ends up unable to fire (havent actually seen in practice, so is a preemptive change)
                                                                    if iDistToNearestEnemy >= (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 0) or (EntityCategoryContains(categories.TECH3, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId) and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0) <= 6 and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.EXPERIMENTAL, tLZTeamData[M28Map.reftoNearestDFEnemies])))) then
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to do megalith retreat micro for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                                                        if M28Micro.MegalithRetreatMicro(oUnit, tAmphibiousRallyPoint, tLZTeamData[M28Map.reftClosestFriendlyBase], oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                                                                            bUseNormalLogic = false
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                            --Also kiting retreat even if nearest enemy unit is say a T2 PD (instead of mobile t3+ unit) if overall enemy threat is high, and enemy threat within our range is high, to avoid scenario where e.g. an enemy GC is approaching our megalith but it doesnt try and kite because the enemy T2 PD is slightly closer to being in range, and we have been firing recently
                                                            if bUseNormalLogic and iAvailableCombatUnitThreat < GetEnemyCombatThreatInAdjacentZones() * 2 and oUnit[M28UnitInfo.refiDFRange] and M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                                                                local iDistToClosestUnit = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition())
                                                                if iDistToClosestUnit < oUnit[M28UnitInfo.refiDFRange] - 5 and iDistToClosestUnit > (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 0) + 1 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0) <= 5 then
                                                                    local tNearbyEnemiesInOurRange = oUnit:GetAIBrain():GetUnitsAroundPoint(categories.DIRECTFIRE + categories.INDIRECTFIRE, oUnit:GetPosition(), oUnit[M28UnitInfo.refiDFRange] - 2, 'Enemy')
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Threat of DF and IF units in megalith range='..M28UnitInfo.GetCombatThreatRating(tNearbyEnemiesInOurRange, true, false)) end
                                                                    if M28UnitInfo.GetCombatThreatRating(tNearbyEnemiesInOurRange, true, false) >= 5000 then
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and retreat megalith with micro unless we are almost in range of a significant enemy force') end
                                                                        local toEnemiesAlmostInRange = {}
                                                                        local iClosestEnemyDist = 10000
                                                                        local oClosestEnemyToMegalith
                                                                        for iEnemy, oEnemy in tNearbyEnemiesInOurRange do
                                                                            if (oEnemy[M28UnitInfo.refiCombatRange] or 0) > 0 then
                                                                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())
                                                                                if iCurDist < oEnemy[M28UnitInfo.refiCombatRange] + 3 then
                                                                                    table.insert(toEnemiesAlmostInRange, oEnemy)
                                                                                    if iCurDist < iClosestEnemyDist then
                                                                                        iClosestEnemyDist = iCurDist
                                                                                        oClosestEnemyToMegalith = oEnemy
                                                                                    end
                                                                                end
                                                                            end
                                                                        end
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Mass cost of enemies almost in range='..M28UnitInfo.GetMassCostOfUnits(toEnemiesAlmostInRange, true)) end
                                                                        if M28Utilities.IsTableEmpty(toEnemiesAlmostInRange) or M28UnitInfo.GetMassCostOfUnits(toEnemiesAlmostInRange, true) < 10000 then
                                                                            if M28Micro.MegalithRetreatMicro(oUnit, tAmphibiousRallyPoint, tLZTeamData[M28Map.reftClosestFriendlyBase], oClosestEnemyToMegalith) then
                                                                                bUseNormalLogic = false
                                                                            end
                                                                        else
                                                                            --To be safe will check for manual attack - in theory below code would already do this, but as we know there's 10k+ threat want to make sure by doing here
                                                                            local oTargetToManuallyAttack, bMoveNotManualAttack = GetManualAttackTargetIfWantManualAttack(oUnit)
                                                                            if bDebugMessages == true then LOG(sFunctionRef..': Mega kiting manual attack oTargetToManuallyAttack='..(oTargetToManuallyAttack.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTargetToManuallyAttack) or 'nil')) end
                                                                            if oTargetToManuallyAttack then
                                                                                if bMoveNotManualAttack then M28Orders.IssueTrackedMove(oUnit, oTargetToManuallyAttack:GetPosition(), 2, false, 'MegaManM', false)
                                                                                else
                                                                                    DoManualAttack(oUnit, oTargetToManuallyAttack, 'MegaManA')
                                                                                end
                                                                                bUseNormalLogic = false
                                                                            end
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if we should do kiting retreat with megalith, iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; Enemy combat threat='..GetEnemyCombatThreatInAdjacentZones()..'; Is closest enemy from last close to enemy check valid='..tostring(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]))..'; bUseNormalLogic='..tostring(bUseNormalLogic)) end
                                                        end
                                                        if bUseNormalLogic then

                                                            --Non-kiting units (e.g. megalith) - consider manual attack if multiple potential targets
                                                            local oTargetToManuallyAttack, bMoveNotManualAttack
                                                            if bNearestEnemyNeedsManualAttack then --i.e. amphibious unit that is in a water zone, so wont get targeted normally
                                                                oTargetToManuallyAttack = oNearestEnemyToFriendlyBase
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Want manual attack on nearest enemy') end
                                                            elseif not(oUnit[M28UnitInfo.refbCanKite]) then
                                                                oTargetToManuallyAttack, bMoveNotManualAttack = GetManualAttackTargetIfWantManualAttack(oUnit)
                                                                if bDebugMessages == true then LOG(sFunctionRef..': We cant kite so checking if we want a target to manually attack, oTargetToManuallyAttack='..(oTargetToManuallyAttack.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTargetToManuallyAttack) or 'nil')..'; bMoveNotManualAttack='..tostring(bMoveNotManualAttack)) end
                                                            end
                                                            --Combat scout specific - use manual attack order if enemy is almost in our range
                                                            if not(oTargetToManuallyAttack) and oUnit[M28UnitInfo.refbScoutCombatOverride] and M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()) <= oUnit[M28UnitInfo.refiDFRange] + 3 then
                                                                oTargetToManuallyAttack = oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]
                                                                bMoveNotManualAttack = false
                                                                if bDebugMessages == true then LOG(sFunctionRef..': We are still near the nearest enemy unit, and we have a land scout, so will do a manual attack order to reduce risk of going in its range') end
                                                            end

                                                            --Not in range yet, so attack move to the nearest enemy (unless bFiringAtNegligibleThreatInLRExperimentalRange is true)
                                                            if oTargetToManuallyAttack then
                                                                if bMoveNotManualAttack then
                                                                    M28Orders.IssueTrackedMove(oUnit, oTargetToManuallyAttack:GetPosition(), 2, false, 'NKManM', false)
                                                                else
                                                                    --ythotha - attack move infront of ythotha
                                                                    DoManualAttack(oUnit, oTargetToManuallyAttack, 'NKManA')
                                                                end
                                                            else
                                                                --Skirmishers - if enemy is almost in range of us then consider an attack-move order slightly away from them; if they are inside our range and we have far more threat then instead consider a manual attack order
                                                                if not(bFiringAtNegligibleThreatInLRExperimentalRange) and (EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) or oUnit[M28UnitInfo.refbScoutCombatOverride]) and M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                                                                    --If we lack land scout in this zone and lack good intel coverage then flag the skirmisher for a priority land scout
                                                                    if not(oUnit[M28UnitInfo.refbScoutCombatOverride]) and tLZTeamData[M28Map.refiRadarCoverage] < iIntelThresholdForPriorityScout then
                                                                        if M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmniVision] then --redundancy
                                                                            tLZTeamData[M28Map.refbWantLandScout] = false
                                                                            tLZTeamData[M28Map.refiRadarCoverage] = 5000
                                                                        else
                                                                            tLZTeamData[M28Map.refbWantLandScout] = true
                                                                            ConsiderPriorityLandScoutFlag(oUnit)
                                                                        end
                                                                    end

                                                                    iSkirmisherDistToNearestEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition())
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': have got a skirmisher unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..', will check if close to the closest enemy unit, Dist to it='..iSkirmisherDistToNearestEnemy..'; Enemy unit range='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 'nil')..'; Our DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Dif between their facing and angle to us='..M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), M28UnitInfo.GetUnitFacingAngle(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]))..'; Their unit state='..M28UnitInfo.GetUnitState(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; Nearby enemy combat threat='..GetEnemyCombatThreatInAdjacentZones()) end
                                                                    if ((oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiCombatRange] or 0) <= 7 and iSkirmisherDistToNearestEnemy >= (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiCombatRange] or 0) + 7)
                                                                            or (iSkirmisherDistToNearestEnemy < (oUnit[M28UnitInfo.refiDFRange] or 0) and iSkirmisherDistToNearestEnemy > math.min((oUnit[M28UnitInfo.refiDFRange] or 0) - 3, (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 0) + 10) and not(EntityCategoryContains(M28UnitInfo.refCategoryMobileLand * categories.TECH1 - categories.COMMAND, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId)) and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 8) then
                                                                        M28Orders.IssueTrackedAttack(oUnit, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], false, 'InRngEn', false)
                                                                        bUseNormalLogic = false
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Will issue an attack order on the target, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]='..oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])..'; Can see unit='..tostring(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], false))..'; Is oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] valid='..tostring(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]))) end

                                                                        --Angle dif - even at 30.9 angle dif we ended up getting too close, so changed to 32.5
                                                                    elseif iSkirmisherDistToNearestEnemy <= (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 0) + 11 and (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 0) >= (oUnit[M28UnitInfo.refiDFRange] or 0) - 11 and (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:IsUnitState('Moving') or oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:IsUnitState('Attacking')) and (iSkirmisherDistToNearestEnemy <= (oUnit[M28UnitInfo.refiDFRange] or 0) - 1 and M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), M28UnitInfo.GetUnitFacingAngle(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) <= 60 or M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), M28UnitInfo.GetUnitFacingAngle(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) <= 32.5) then
                                                                        --move slightly in the rally point direction
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to consider retreating slightly as nearest enemy is getting close to being in range and is facing towards us, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or 'nil')..' with range ='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 'nil')..' and dist '..(iSkirmisherDistToNearestEnemy or 'nil')..'; our skirmisher range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Dif between closest unit facing direction and angle to us='..(M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), M28UnitInfo.GetUnitFacingAngle(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) or 'nil')) end
                                                                        bUseNormalLogic = false
                                                                        --tried 1.5 first, then 3; 3 ended up causing the units to stay too far away so would fire much less, 1.5 means they often do a mini-turn
                                                                        oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                                        M28Orders.IssueTrackedMove(oUnit, M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), 2, true, false, false), 1, false, 'KStpM'..iLandZone)
                                                                        --queue up attack-move after this in case we switch zones and end up idling for a while
                                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), 5, true, false, false), 1, true, 'KStpM'..iLandZone)
                                                                    end
                                                                end
                                                                --Attackmove (unless we have far more threat in this zone and arent a megalith); note that oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] is false if we havent done a close to check yet
                                                                if bUseNormalLogic then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will attack move unless we have significantly more threat, bFiringAtNegligibleThreatInLRExperimentalRange='..tostring(bFiringAtNegligibleThreatInLRExperimentalRange)..'; bMoveToStopPDConstruction='..tostring(bMoveToStopPDConstruction)..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; GetEnemyCombatThreatInAdjacentZones='..GetEnemyCombatThreatInAdjacentZones()..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or 'nil')..'; iVisibleLandCombatMassInFatboyRange='..(iVisibleLandCombatMassInFatboyRange or 'nil')..'; (oUnit[M28UnitInfo.refiDFMinRange]='..(oUnit[M28UnitInfo.refiDFMinRange] or 0)..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]..'; oUnit[M28UnitInfo.refiDFRange]='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Is unit a fatboy='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId))..'; Ignore due to being stuck='..tostring(IgnoreOrderDueToStuckUnit(oUnit) or false)..'; Is unit a skirmisher='..tostring(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId))..'; Is available threat more tahn 4x enemy='..tostring(iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 4)..'; Main condition requirements='..tostring((iAvailableCombatUnitThreat > 1000 and iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 4 and (not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) or (iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 20 and (not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId) and not(oUnit[M28UnitInfo.refbScoutCombatOverride]))))))..'; Sub2 condition='..tostring((EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and EntityCategoryContains(categories.TECH1 + categories.TECH2, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId) and M28UnitInfo.GetCombatThreatRating(oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure, oUnit:GetPosition(), oUnit[M28UnitInfo.refiDFRange], 'Enemy'), true, true) <= 2000))..'; Sub3 condition='..tostring((M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange] + 4, iTeam, false,               nil,                    nil,                                  oUnit,                              math.min(oUnit[M28UnitInfo.refiDFRange], math.max(oUnit[M28UnitInfo.refiDFRange] - 3,  iEnemyBestDFRange + oUnit:GetBlueprint().Physics.MaxSpeed + 5))))))..'; Dist to nearest enemy='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition())) end
                                                                    if bFiringAtNegligibleThreatInLRExperimentalRange or
                                                                            (oUnit[M28UnitInfo.refiDFRange] <= 120 and (oUnit[M28UnitInfo.refiDFMinRange] or 0) <= 30 and
                                                                                    (bMoveToStopPDConstruction or
                                                                                            --Fatboy - if negligible threat in its range then consider moving (however for QUIET+LOUD be less likely to move due to issue with weapon cycling)
                                                                                            ((oUnit[M28UnitInfo.refiDFRange] or 0) >= 90 and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId) and iVisibleLandCombatMassInFatboyRange <= 2000 and tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] <= 4000 and (M28Utilities.bFAFActive or M28Utilities.bSteamActive or not(oNearestEnemyToFriendlyBase) or M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition()) > oUnit[M28UnitInfo.refiCombatRange] - 20)) or
                                                                                            --Main condition: Consider various sub conditions where we have more than 4 times the enemy threat in adjacent zones, and aren't dealing with a skirmisher unit (with rare exceptions):
                                                                                            (iAvailableCombatUnitThreat > 1000 and iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 4 and (not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) or (iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 20 and (not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId) and not(oUnit[M28UnitInfo.refbScoutCombatOverride])))) and
                                                                                                    --Sub1 - shorter ranged units (since we have significantly more threat)
                                                                                                    (oUnit[M28UnitInfo.refiDFRange] or 0) < 64 or
                                                                                                    --Sub2 - Further negligible threat option for land experimentals such as megalith to ignore T1-T2 units
                                                                                                    (EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and EntityCategoryContains(categories.TECH1 + categories.TECH2, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId) and M28UnitInfo.GetCombatThreatRating(oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure, oUnit:GetPosition(), oUnit[M28UnitInfo.refiDFRange], 'Enemy'), true, true) <= 2000) or
                                                                                                    --Sub3 - Not close to an enemy unit
                                                                                                    --CloseToEnemyUnit(tStartPosition,      tUnitsToCheck,                                  iDistThreshold,             iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                                                                                                    (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange] + 4, iTeam, false,               nil,                    nil,                                  oUnit,                              math.min(oUnit[M28UnitInfo.refiDFRange], math.max(oUnit[M28UnitInfo.refiDFRange] - 3,  iEnemyBestDFRange + oUnit:GetBlueprint().Physics.MaxSpeed + 5)))))
                                                                                            )
                                                                                    )
                                                                            )
                                                                    then
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Special case where want to move instead of attack move, bar exception if have land exp that is already close to the move target') end

                                                                        if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                                            local oNearestEnemyToConsider = oNearestEnemyToFriendlyBase
                                                                            local iDistToUs
                                                                            local iClosestDistToUs = 10000
                                                                            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) > iDistFromNearestEnemyToFriendlyBase then
                                                                                --Get nearest enemy to this unit (to cover cases e.g. like on the ditch where we have to travel around water, meaning the closest enemy to the base won't be the closest unit to us, causing us to ignore mexes, engineers etc. that may be undefended to attack a much further away target

                                                                                for iEnemy, oEnemy in tLZTeamData[M28Map.subrefTEnemyUnits] do
                                                                                    iDistToUs = M28Utilities.GetDistanceBetweenPositions(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())
                                                                                    if iDistToUs < iClosestDistToUs then
                                                                                        iClosestDistToUs = iDistToUs
                                                                                        oNearestEnemyToConsider = oEnemy
                                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Updating oNearestEnemyToConsider to be '..oNearestEnemyToConsider.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToConsider)..' with iDistToUs='..iDistToUs) end
                                                                                    end
                                                                                end
                                                                            end
                                                                            if  toAdjacentEnemyMexes and M28Utilities.IsTableEmpty(toAdjacentEnemyMexes) == false then
                                                                                for iMex, oMex in toAdjacentEnemyMexes do
                                                                                    iDistToUs = M28Utilities.GetDistanceBetweenPositions(oMex[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())
                                                                                    if bDebugMessages == true then LOG(sFunctionRef..': iClosestDistToUs='..iClosestDistToUs..'; Considering if oMex is closer, oMex='..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)..'; iDistToUs='..iDistToUs) end
                                                                                    if iDistToUs < iClosestDistToUs then
                                                                                        iClosestDistToUs = iDistToUs
                                                                                        oNearestEnemyToConsider = oMex
                                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Mex is closer than nearest enemy unit so will target mex instead') end
                                                                                    end
                                                                                end
                                                                            end
                                                                            --Normally want to move, but exception came across where ythotha told to move at an enemy factory wouldn't move, so if dealing with a structure, and it isn't too far away, then want to attack-move
                                                                            local iDistToNearestEnemy
                                                                            if (iClosestDistToUs or 0) >= 1000 then iDistToNearestEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToConsider[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                                                                            else iDistToNearestEnemy = iClosestDistToUs
                                                                            end
                                                                            if ((oUnit[M28UnitInfo.refiUnitMassCost] or GetUnitMassCost(oUnit)) >= 2000 and iDistToNearestEnemy <= 7) or (EntityCategoryContains(M28UnitInfo.refCategoryStructure, oNearestEnemyToConsider.UnitId) and oUnit[M28UnitInfo.refiCombatRange] >= 10 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToConsider:GetPosition()) <= 8 and M28UnitInfo.GetBuildingSize(oNearestEnemyToConsider.UnitId) >= 3) then
                                                                                if bDebugMessages == true then LOG(sFunctionRef..': Will give an attack move order due to how close we are') end
                                                                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToConsider[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'KMvAe'..iLandZone, false)
                                                                                --Further exception for QUIET/LOUD with a fatboy
                                                                            elseif oUnit[M28UnitInfo.refiDFRange] >= 90 and iVisibleLandCombatMassInFatboyRange >= 1500 and (M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) and not(oUnit[M28UnitInfo.refbLastShotBlocked]) and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId) then
                                                                                if bDebugMessages == true then LOG(sFunctionRef..': QUIET and LOUD fatboy attackmove eception due to firing issues') end
                                                                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToConsider[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'FBKMvAe'..iLandZone, false)
                                                                                --If enemy has no combat attack or is very close then attackmove to avoid friendly fire
                                                                            elseif(((oNearestEnemyToConsider[M28UnitInfo.refiCombatRange] or 0) == 0 and iDistToNearestEnemy <= oUnit[M28UnitInfo.refiCombatRange] - 4) or (iDistToNearestEnemy <= 12 and (oUnit[M28UnitInfo.refiCombatRange] >= 15 or iDistToNearestEnemy <= oUnit[M28UnitInfo.refiCombatRange] - 5))) then
                                                                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToConsider[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'ClKAMve'..iLandZone, false)
                                                                            else
                                                                                if bDebugMessages == true then LOG(sFunctionRef..': Will give a move order to the nearest enemy') end
                                                                                M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToConsider[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'KMve'..iLandZone, false)
                                                                            end


                                                                        end
                                                                    else
                                                                        if not(oUnit.UnitId == 'xnl0403') or DontHaveJerichoAttackTarget(oUnit) then
                                                                            if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                                                if bDebugMessages == true then LOG(sFunctionRef..': Will give an aggressive move order (or in some cases a manua lattack order)') end
                                                                                if oUnit[M28UnitInfo.refiWeaponScanRange] and oUnit[M28UnitInfo.refiWeaponScanRange] + 5 < oUnit[M28UnitInfo.refiCombatRange] then
                                                                                    ConsiderManualAttackInsteadOfAttackMove(oUnit, oNearestEnemyToFriendlyBase, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, 'KAMve')
                                                                                    --Skirmishers facing an enemy combat unit they cant 1-shot - do manual attack if close to being in range of that unit (so e.g. hoplites are more likely to attack instead of attack-move a nearby enemy ACU)
                                                                                elseif (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 0) > 10 and EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId) and oUnit[M28UnitInfo.refiStrikeDamage] and not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].Dead) and oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetHealth() > math.max(200, oUnit[M28UnitInfo.refiStrikeDamage]) and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()) <= 6 + oUnit[M28UnitInfo.refiDFRange] and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], false) then
                                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Giving skirmisher manual attack order') end
                                                                                    M28Orders.IssueTrackedAttack(oUnit, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], false, 'KManA'..iLandZone, false)
                                                                                else
                                                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'KAMve'..iLandZone)
                                                                                end
                                                                            end
                                                                            --Dont need else here as jerichoattacktarget gives order if it applies
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                            --If we cant kite and enemy is close to us, then flag we want SR support
                                                            if not(bAttackWithOutrangedDFUnits) and not(oUnit[M28UnitInfo.refbCanKite]) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 4, iTeam, true) then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy is close to our unit which cant kite, our unit= '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so want to attack with outranged DF units') end
                                                                bAttackWithOutrangedDFUnits = true
                                                            end
                                                        end
                                                    else
                                                        --Enemy has DF units and they are already in our range, and we can kite;
                                                        --Check if we are in the scenario where closest enemy to us is just in our range and isnt moving, and we havent fired recently
                                                        local bStillAttack = false
                                                        if oUnit[M28UnitInfo.refiDFRange] > oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiCombatRange] and M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and ((not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) and not(oUnit[M28UnitInfo.refbScoutCombatOverride])) or not(oUnit[M28UnitInfo.refiLastWeaponEvent]) or GetGameTimeSeconds() - oUnit[M28UnitInfo.refiLastWeaponEvent] >= (oUnit[M28UnitInfo.refiTimeBetweenDFShots]or 0) - 0.4) then
                                                            local iDistToClosestEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())
                                                            if iDistToClosestEnemy - oUnit[M28UnitInfo.refiDFRange] >= -1.5 and iDistToClosestEnemy - oUnit[M28UnitInfo.refiDFRange] <= 2 then
                                                                --Get where enemy will move towards
                                                                local iVelocityX, iVelocityY, iVelocityZ = oUnit:GetVelocity()
                                                                local tCurEnemyPosition = oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()
                                                                if bDebugMessages == true then LOG(sFunctionRef..': iDistToClosestEnemy='..iDistToClosestEnemy..'; Dist to position based on enemy movement='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), {tCurEnemyPosition[1]+iVelocityX, tCurEnemyPosition[2], tCurEnemyPosition[3] + iVelocityZ})) end
                                                                if iDistToClosestEnemy <= M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), {tCurEnemyPosition[1]+iVelocityX, tCurEnemyPosition[2], tCurEnemyPosition[3] + iVelocityZ}) then
                                                                    bStillAttack = true
                                                                end
                                                            end
                                                        end
                                                        --If trying to suicide into ACU that we arent in range yet then still be aggressive rather than kiting
                                                        if not(bStillAttack) and M28UnitInfo.IsUnitValid(oClosestFatboyOrACUInIslandToSuicideInto) and (oClosestFatboyOrACUInIslandToSuicideInto == oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(),oClosestFatboyOrACUInIslandToSuicideInto:GetPosition()) - oUnit[M28UnitInfo.refiDFRange] <= 14) and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId)) then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Dont want to kite as are almost in range of unit to suicide into') end
                                                            bStillAttack = true
                                                        end
                                                        if bStillAttack then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Normally would do kiting retreat, but in this case will do manual attack as enemy on cusp of our range and not moving closer to us') end
                                                            M28Orders.IssueTrackedAttack(oUnit, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], false, 'KMnA'..iLandZone, false)
                                                        elseif bNearestEnemyNeedsManualAttack then
                                                            if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                                                if M28Utilities.GetDistanceBetweenPositions(tAmphibiousRallyPoint, oUnit:GetPosition()) <= 10 then
                                                                    local oTargetToManuallyAttack, bMoveNotManualAttack = GetManualAttackTargetIfWantManualAttack(oUnit)
                                                                    if not( oTargetToManuallyAttack) then oTargetToManuallyAttack = oNearestEnemyToFriendlyBase end
                                                                    if bMoveNotManualAttack then
                                                                        M28Orders.IssueTrackedMove(oUnit, oTargetToManuallyAttack:GetPosition(), 2, false, 'UnderWARM', false)
                                                                    else
                                                                        DoManualAttack(oUnit, oTargetToManuallyAttack, 'UnderWARA')
                                                                    end
                                                                    --M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'UnderWARA', false)
                                                                else
                                                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                                    ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tAmphibiousRallyPoint, tLZData[M28Map.subrefLZIslandRef], 'AKRetrU'..iLandZone)
                                                                    --M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AKRetrU'..iLandZone)
                                                                end
                                                            else
                                                                if M28Utilities.GetDistanceBetweenPositions(tRallyPoint, oUnit:GetPosition()) <= 10 then
                                                                    local oTargetToManuallyAttack, bMoveNotManualAttack = GetManualAttackTargetIfWantManualAttack(oUnit)
                                                                    if not(oTargetToManuallyAttack) then oTargetToManuallyAttack = oNearestEnemyToFriendlyBase end
                                                                    if bMoveNotManualAttack then M28Orders.IssueTrackedMove(oUnit, oTargetToManuallyAttack:GetPosition(), 2, false, 'UnderWARC', false)
                                                                    else
                                                                        DoManualAttack(oUnit, oTargetToManuallyAttack, 'UnderWARB')
                                                                    end
                                                                    --M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'UnderWARB', false)
                                                                else
                                                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                                    ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tRallyPoint, tLZData[M28Map.subrefLZIslandRef],'KRetrU'..iLandZone)
                                                                    --M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'KRetrU'..iLandZone)
                                                                end
                                                            end
                                                        elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                                            --If the angle towards the rally point is similar to the angle towards the enemy then instead run from the nearest enemy
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Will either backup to rally point, or away from nearest enemy, is M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] valid='..tostring(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])))
                                                                if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                                                                    LOG(sFunctionRef..': Angle from closest enemy to unit='..M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition())..'; Angle to rally from unit='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tAmphibiousRallyPoint)..'; dif for closest enemy to unit; vs unit to rally='..M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tAmphibiousRallyPoint)))
                                                                end
                                                            end
                                                            --If retreating in opposite direction to nearest enemy would take us a significantly different angle to the rally point then retreat in opposite direction; however if there woudl't be much dif (i.e. within 45 degrees, so 90 degrees overall) then just go to the rally point instead of the opposite direction
                                                            if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tAmphibiousRallyPoint)) > 45 then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Will try and go to temporary retreat location by moving in opposite direction to nearest enemy unit, since going to the rally would take us a signif dif angle') end
                                                                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                                local iBackupDist = (oUnit:GetBlueprint().Physics.BackUpDistance or 0)
                                                                local tTemporaryRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), (iBackupDist or 9) - 1, true, false, M28Map.bIsCampaignMap)
                                                                if M28Utilities.IsTableEmpty(tTemporaryRetreatLocation) == false and NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, tTemporaryRetreatLocation) == iPlateau then
                                                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                                    ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tTemporaryRetreatLocation, iPlateau, 'AKRetNE'..iLandZone, true, math.min(iBackupDist, 9))
                                                                    --M28Orders.IssueTrackedMove(oUnit, tTemporaryRetreatLocation, 6, false, 'AKRetNE'..iLandZone)
                                                                else
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': If we moved ino pposite direction to enemy unit it wouldnt be that different to going to rally point so will go to rally point') end
                                                                    ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tAmphibiousRallyPoint, iPlateau, 'AKRetFA', true, math.min(iBackupDist, 9))
                                                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                                    --M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AKRetFA'..iLandZone)
                                                                end
                                                            else
                                                                --Not much dif in angle so will just go to the rally point
                                                                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Will try and backup to amphibious rally point, tAmphibiousRallyPoint='..repru(tAmphibiousRallyPoint)..'; Unit position='..repru(oUnit:GetPosition())) end
                                                                ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tAmphibiousRallyPoint, tLZData[M28Map.subrefLZIslandRef], 'AKRetr'..iLandZone)
                                                                --M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AKRetr'..iLandZone)
                                                            end


                                                        else
                                                            if EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) or oUnit[M28UnitInfo.refbScoutCombatOverride] then iAngleThresholdForRally = 100 else iAngleThresholdForRally = 70 end
                                                            if bDebugMessages == true then
                                                                LOG(sFunctionRef..': is refoClosestEnemyFromLastCloseToEnemyUnitCheck valid='..tostring(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])))
                                                                if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                                                                    LOG(sFunctionRef..': Angle from unit to nearest enemy='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())..'; Angle to rally point='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)..'; Angle dif='..M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint))..'; iAngleThresholdForRally='..iAngleThresholdForRally)
                                                                end
                                                            end

                                                            --LOUD specific - some units (e.g. hoplites) can't kite as well as they can in FAF
                                                            local bAttackMove = false
                                                            if M28Utilities.bLoudModActive and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0) > (oUnit[M28UnitInfo.refiTimeBetweenDFShots] or 100) + 2 and EntityCategoryContains(M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategorySniperBot, oUnit.UnitId) then
                                                                bAttackMove = true
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Will use attack move for skirmisher '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at time='..GetGameTimeSeconds()) end
                                                                --If closest enemy is visible, and either a building or not moving, and is only just in our range, then do attackmove
                                                            elseif M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and oUnit[M28UnitInfo.refiCombatRange] > oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiCombatRange] + 6 and (EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId) or (oUnit[M28UnitInfo.refiCombatRange] > oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiCombatRange] + 10 and M28UnitInfo.GetUnitSpeed(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) <= 0.01)) and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and oUnit[M28UnitInfo.refiCombatRange] - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()) <= 4 then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': We are only just in range of a stationery enemy we outrange so will do attackmove instead of move to pull back for the skirmisher') end
                                                                bAttackMove = true
                                                            end

                                                            if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)) <= iAngleThresholdForRally then
                                                                local tTemporaryRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), 8, true, false, M28Map.bIsCampaignMap)
                                                                if bDebugMessages == true then LOG(sFunctionRef..': tTemporaryRetreatLocation='..repru(tTemporaryRetreatLocation)..'; Land label='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tTemporaryRetreatLocation) or 'nil')..'; Island ref='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..'; Unit position='..repru(oUnit:GetPosition())..'; bAttackMove='..tostring(bAttackMove))
                                                                    --M28Utilities.DrawLocation(tTemporaryRetreatLocation)
                                                                end
                                                                if M28Utilities.IsTableEmpty(tTemporaryRetreatLocation) == false and NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tTemporaryRetreatLocation) == tLZData[M28Map.subrefLZIslandRef] then
                                                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                                    if bAttackMove then M28Orders.IssueTrackedAggressiveMove(oUnit, tTemporaryRetreatLocation, 4, false, 'KARetNE'..iLandZone)
                                                                    else
                                                                        M28Orders.IssueTrackedMove(oUnit, tTemporaryRetreatLocation, 4, false, 'KRetNE'..iLandZone)
                                                                    end
                                                                else
                                                                    if bAttackMove then
                                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, tRallyPoint, 4, false, 'KARetFA'..iLandZone)
                                                                    else
                                                                        ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tRallyPoint, tLZData[M28Map.subrefLZIslandRef], 'KRetFA')
                                                                    end
                                                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                                    --M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'KRetFA'..iLandZone)
                                                                end
                                                            else
                                                                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                                if bAttackMove then
                                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, tRallyPoint, 4, false, 'KARetr'..iLandZone)
                                                                else
                                                                    ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tRallyPoint, tLZData[M28Map.subrefLZIslandRef], 'KRetr'..iLandZone)
                                                                end
                                                                --M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'KRetr'..iLandZone)
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Will move unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to rally point (kiting retreat), rallypoint='..repru(tRallyPoint)..'; unit position='..repru(oUnit:GetPosition())) end
                                                            end
                                                        end
                                                        --If enemy is able to shoot us then get DF support (unless its an ACU shooting us, in which case want an overwhelming threat to attack)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if enemy is able to shoot our unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Closest enemy from prev check='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or 'nil')..'; Are we close to nearest DF enemies using a basic distance threshold (actual dist threshold we used to get here may be dif)='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 4, iTeam, true))..'; bNearestEnemyNeedsManualAttack='..tostring(bNearestEnemyNeedsManualAttack)..'; Is this unit amphibious or navy='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId))..'; Is closest enemy from last unit check valid='..tostring(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]))..'; Unit='..(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]).UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) or 'nil')) end
                                                        if not(bAttackWithOutrangedDFUnits) and (not(bNearestEnemyIsACU) or iAvailableCombatUnitThreat >= 2000) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 4, iTeam, true, nil, nil, oUnit) and (iAvailableCombatUnitThreat >= 2000 or not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or not(EntityCategoryContains(categories.COMMAND, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId))) then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy is close to unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so want to attack with outranged DF units') end
                                                            bAttackWithOutrangedDFUnits = true
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            else
                                if ProceedWithUnitOrder(oUnit) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': We dont outrange enemy, will consider if we want to be a SR support unit') end
                                    if oUnit[M28UnitInfo.refiDFRange] > 0 and ((oUnit[M28UnitInfo.refiIndirectRange] or 0) <= (oUnit[M28UnitInfo.refiDFRange] or 0)) then
                                        --We dont outrange the enemy, but we do have other units that do

                                        --Skirmishers - Still retreat if are in range of enemy, even if we dont outraneg them, as may e.g. be other units that we do outrange
                                        if (EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) or oUnit[M28UnitInfo.refbScoutCombatOverride]) and not(oUnit[M28UnitInfo.refbEasyBrain]) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we are in range of an enemy unit for a skirmisher as it doesnt have enough DF to outrange enemy DF; bEnemyHasNoDFUnits='..tostring(bEnemyHasNoDFUnits)..'; Is close to enemy='..tostring(not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange] - math.max(2, math.min(8, oUnit[M28UnitInfo.refiDFRange] * 0.1)), iTeam, false)))..'; bAttackWithOutrangedDFUnits='..tostring(bAttackWithOutrangedDFUnits)..'; Close to nearest DF enemies based on enemy range='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 6, iTeam, true))..'; Close to skirmisher enemies based on their range='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tSkirmisherDFEnemies, 6, iTeam, true))..'; Close to LR enemy IF units='..tostring(M28Conditions.IsUnitInRangeOfLRIndirectFireUnits(oUnit, tLZTeamData, 5) or false)) end
                                            if bAttackWithOutrangedDFUnits then
                                                --Check we arent in range of enemy indirect fire units including t2 arti

                                                --CloseToEnemyUnit(tStartPosition, tUnitsToCheck,                                       iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                                                if (bEnemyHasNoDFUnits or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tSkirmisherDFEnemies, 6, iTeam, true))) and not(M28Conditions.IsUnitInRangeOfLRIndirectFireUnits(oUnit, tLZTeamData, 5)) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Not in range of enemy yet, and we outrange enemy; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..oUnit[M28UnitInfo.refiDFRange]..'; oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..' owned by '..oNearestEnemyToFriendlyBase:GetAIBrain().Nickname..'; oNearestEnemyToFriendlyBase DF range='..(oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oNearestEnemyToFriendlyBase:GetPosition())..'; Enemy last recorded position='..repru(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; LZ midpoint position='..repru(tLZData[M28Map.subrefMidpoint])) end
                                                    --Not in range yet, so attack move to the nearest enemy
                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SK1AMve'..iLandZone)
                                                else
                                                    local tRetreatLocationToUse
                                                    if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                                                        local iAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())
                                                        local iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tAmphibiousRallyPoint)
                                                        if M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToRally) <= 65 then
                                                            local tPotentialRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToNearestEnemy - 180, 15, true, nil, M28Map.bIsCampaignMap)
                                                            if M28Utilities.IsTableEmpty(tPotentialRetreatLocation) == false and NavUtils.GetLabel(M28Map.refPathingTypeHover, tPotentialRetreatLocation) == iPlateau then
                                                                tRetreatLocationToUse = {tPotentialRetreatLocation[1], tPotentialRetreatLocation[2], tPotentialRetreatLocation[3]}
                                                            end
                                                        end
                                                    end
                                                    if not(tRetreatLocationToUse) then
                                                        --Enemy has DF units and they are already in our range so retreat
                                                        if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                                            tRetreatLocationToUse = {tAmphibiousRallyPoint[1], tAmphibiousRallyPoint[2], tAmphibiousRallyPoint[3]}
                                                        else
                                                            tRetreatLocationToUse = {tRallyPoint[1], tRallyPoint[2], tRallyPoint[3]}
                                                        end
                                                    end
                                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                    M28Orders.IssueTrackedMove(oUnit, tRetreatLocationToUse, 6, false, 'SKRetr'..iLandZone)
                                                end
                                            else
                                                --Only attack with skirmishers if wont get in range of enemy unit
                                                --CloseToEnemyUnit(tStartPosition, tUnitsToCheck, iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                                                if bEnemyHasNoDFUnits or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tSkirmisherDFEnemies, 8, iTeam, true,                        nil,                    nil,                                oUnit)) and not(M28Conditions.IsUnitInRangeOfLRIndirectFireUnits(oUnit, tLZTeamData, 5)) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Not in range of enemy yet, and we outrange enemy; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..oUnit[M28UnitInfo.refiDFRange]..'; oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..'; oNearestEnemyToFriendlyBase DF range='..(oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oNearestEnemyToFriendlyBase:GetPosition())..'; Enemy last recorded position='..repru(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; LZ midpoint position='..repru(tLZData[M28Map.subrefMidpoint])) end
                                                    --Not in range yet, so attack move to the nearest enemy
                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SK2AMve'..iLandZone)
                                                else
                                                    if bDebugMessages == true then
                                                        LOG(sFunctionRef..': Enemy has DF units in our range so will retreat to the rally point, unless closest enemy unit is close enough and at such an angle that we shoudl try running away from it, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or 'nil')..'; DF range='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 'nil'))
                                                    end
                                                    --Enemy has DF units and they are already in our range so retreat

                                                    local tRetreatLocationToUse
                                                    if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] > 0 then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Dist to last known position='..M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Our unit DF range='.. oUnit[M28UnitInfo.refiDFRange]..'; Actual dist to our unit='..M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition())) end
                                                        if M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition()) <= oUnit[M28UnitInfo.refiDFRange] + 8 then
                                                            local iAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())
                                                            local iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tAmphibiousRallyPoint)
                                                            if M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToRally) <= 65 then
                                                                local tPotentialRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToNearestEnemy - 180, 15, true, nil, M28Map.bIsCampaignMap)
                                                                if M28Utilities.IsTableEmpty(tPotentialRetreatLocation) == false and NavUtils.GetLabel(M28Map.refPathingTypeHover, tPotentialRetreatLocation) == iPlateau then
                                                                    tRetreatLocationToUse = {tPotentialRetreatLocation[1], tPotentialRetreatLocation[2], tPotentialRetreatLocation[3]}
                                                                end
                                                            end
                                                            if bDebugMessages == true then LOG(sFunctionRef..': tRetreatLocationToUse after considering whether to run in opposite direction to nearest enemy='..repru(tRetreatLocationToUse)..'; iAngleToNearestEnemy='..iAngleToNearestEnemy..'; iAngleToRally='..iAngleToRally) end
                                                        end
                                                    end
                                                    if not(tRetreatLocationToUse) then
                                                        if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                                            tRetreatLocationToUse = {tAmphibiousRallyPoint[1], tAmphibiousRallyPoint[2], tAmphibiousRallyPoint[3]}
                                                        else
                                                            tRetreatLocationToUse = {tRallyPoint[1], tRallyPoint[2], tRallyPoint[3]}
                                                        end
                                                    end

                                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                    M28Orders.IssueTrackedMove(oUnit, tRetreatLocationToUse, 6, false, 'SK2Retr'..iLandZone)


                                                end
                                            end
                                        else
                                            if bDebugMessages == true then LOG(sFunctionRef..': DF unit is outranged so adding to tOutrangedCombatUnits') end
                                            table.insert(tOutrangedCombatUnits, oUnit)
                                        end
                                    elseif oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                                        if (iDFRangeOverrideForScenario1 and oUnit[M28UnitInfo.refiIndirectRange] >= iDFRangeOverrideForScenario1) or (not(iDFRangeOverrideForScenario1) and oUnit[M28UnitInfo.refiIndirectRange] > iEnemyBestDFRange) then
                                            table.insert(tUnitsToSupport, oUnit)
                                            if bDebugMessages == true then LOG(sFunctionRef..': We exceed DF range override for this IF so adding to tUnitsToSupport') end
                                            if oUnit[M28UnitInfo.refbEasyBrain] then
                                                --Attackmove to nearest enemy
                                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                    M28Orders.IssueTrackedAttackMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'EsyIFAM'..iLandZone)
                                                end
                                            else
                                                if (bConsiderSpecialMMLLogic or bEnemyHasFixedShieldsInThisOrAdjacentZone) and EntityCategoryContains(M28UnitInfo.refCategoryMML, oUnit.UnitId) then
                                                    table.insert(tMMLForSynchronisation, oUnit)
                                                    --T1 arti drops - suicide into enemy buildings
                                                elseif oUnit[M28Air.refiTimeLastDropped] and GetGameTimeSeconds() - oUnit[M28Air.refiTimeLastDropped] <= 60 and oNearestEnemyStructureToMidpoint then
                                                    SuicideUnitIntoEnemyStructure(oUnit)
                                                else
                                                    iIndirectDistanceInsideRangeThreshold = iIndirectRunFigureNormal
                                                    if oUnit[M28UnitInfo.refbWeaponUnpacks] then iIndirectDistanceInsideRangeThreshold = iIndirectDistanceInsideRangeThreshold + iIndirectRunFigureDeployedAdjust end
                                                    if bOnlyRetreatIndirectIfEnemyDFAlmostInRange then iIndirectDistanceInsideRangeThreshold = math.max(iIndirectDistanceInsideRangeThreshold + 10, ((oUnit[M28UnitInfo.refiIndirectRange] or 0) - iEnemyBestDFRange)) end


                                                    if bDebugMessages == true then
                                                        LOG(sFunctionRef..': Have Indirect unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that outranges the enemy (our IF range='..oUnit[M28UnitInfo.refiIndirectRange]..'; Enemy best DF range='..iEnemyBestDFRange..'), WIll list every unit in the nearest DF enemies and their distance to us; our position='..repru(oUnit:GetPosition())..'; Do we have a valid shield assigned='..tostring(oUnit[refoAssignedMobileShield] or false))
                                                        for iEnemy, oEnemy in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                                                            LOG(sFunctionRef..': oEnemy '..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..' is '..M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())..'; distance based on last known position='..M28Utilities.GetDistanceBetweenPositions(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; oEnemy DF range='..(oEnemy[M28UnitInfo.refiDFRange] or 'nil')..'; Enemy Indirect range='..(oEnemy[M28UnitInfo.refiIndirectRange] or 'nil'))
                                                        end
                                                    end
                                                    local iDistThreshold
                                                    if bOnlyRetreatIndirectIfEnemyDFAlmostInRange then
                                                        iDistThreshold = math.max(oUnit[M28UnitInfo.refiIndirectRange] - iIndirectDistanceInsideRangeThreshold, math.min(iEnemyBestDFRange + 5, oUnit[M28UnitInfo.refiIndirectRange] - 2))
                                                        if M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileShield]) then iDistThreshold = iDistThreshold - 5 end
                                                    else
                                                        iDistThreshold = math.max(oUnit[M28UnitInfo.refiIndirectRange] - iIndirectDistanceInsideRangeThreshold, math.min(iEnemyBestDFRange + 10, oUnit[M28UnitInfo.refiIndirectRange] - 2))
                                                        if M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileShield]) then iDistThreshold = iDistThreshold - 5 end
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': iDistThreshold='..iDistThreshold..'; oUnit[M28UnitInfo.refiIndirectRange]='..oUnit[M28UnitInfo.refiIndirectRange]..'; iIndirectDistanceInsideRangeThreshold='..iIndirectDistanceInsideRangeThreshold..'; iEnemyBestDFRange='..iEnemyBestDFRange) end
                                                    --CloseToEnemyUnit(tStartPosition,      tUnitsToCheck,                              iDistThreshold,                                                                                                                                                          iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure)
                                                    if not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 5, iTeam, true                  , iDistThreshold,                  nil,                                oUnit, math.min(iEnemyBestDFRange + 4.5, oUnit[M28UnitInfo.refiIndirectRange] - 2))) then
                                                        --Issue specific attack if there is a structure in range due to issue where MMLs dont fire at certain buildings (such as PD) that are in range until getting close
                                                        if bDebugMessages == true then
                                                            if M28UnitInfo.IsUnitValid((oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId or 'nil')) then LOG(sFunctionRef..': [M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]='..oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])..'; DF range='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 'nil')..'; Dist to this unit='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())) end
                                                            if oNearestEnemyStructureToMidpoint then
                                                                LOG(sFunctionRef..': Not too close, will attack structure if it is within our range, oNearestEnemyStructureToMidpoint='..(oNearestEnemyStructureToMidpoint.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyStructureToMidpoint) or 'nil')..'; Dist to this='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyStructureToMidpoint:GetPosition())..'; Dist between actual position and last known position='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyStructureToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oNearestEnemyStructureToMidpoint:GetPosition()))
                                                            else
                                                                LOG(sFunctionRef..': Not too close but dont have a nearest enemy structure to midpoint so will just to attack move (or gorund attack in some cases)')
                                                            end
                                                        end

                                                        if (oNearestEnemyStructureToMidpoint and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyStructureToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) < oUnit[M28UnitInfo.refiIndirectRange]) then
                                                            M28Orders.IssueTrackedAttack(oUnit, oNearestEnemyStructureToMidpoint, false, 'ISAtc'..iLandZone, false)
                                                        elseif bNearestEnemyIsACU and oNearestEnemyToFriendlyBase:IsUnitState('Upgrading') and (M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oNearestEnemyToFriendlyBase, false) or M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 2) then
                                                            --Attack
                                                            M28Orders.IssueTrackedAttack(oUnit, oNearestEnemyToFriendlyBase, false, 'InEnACUU'..iLandZone, false)
                                                        elseif M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()) < oUnit[M28UnitInfo.refiIndirectRange] then
                                                            M28Orders.IssueTrackedAttack(oUnit, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], false, 'INSAtc'..iLandZone, false)
                                                        else
                                                            --Consider attacking an enemy further away if closest enemy is insignificant
                                                            local iDistToNearestEnemy = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition())
                                                            local oMexToConsiderTargetetingInstead
                                                            if iDistToNearestEnemy > (oUnit[M28UnitInfo.refiIndirectRange] + 10) and M28Utilities.IsTableEmpty(toAdjacentEnemyMexes) == false then
                                                                for iMex, oMex in toAdjacentEnemyMexes do
                                                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oMex:GetPosition(), oUnit:GetPosition())
                                                                    if iCurDist < iDistToNearestEnemy then
                                                                        iDistToNearestEnemy = iCurDist
                                                                        oMexToConsiderTargetetingInstead = oMex
                                                                    end
                                                                end
                                                            end

                                                            if bDebugMessages == true then LOG(sFunctionRef..': Will consider switching to a snigifcant enemy target if relevant, is closest enemy from last check valid='..tostring(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]))..'; Mass cost of closest enemy='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiUnitMassCost] or 'nil')..'; oMexToConsiderTargetetingInstead='..(oMexToConsiderTargetetingInstead.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oMexToConsiderTargetetingInstead) or 'nil')) end
                                                            if bIFAttackNearestSignificantEnemy and (not(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) or oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiUnitMassCost] <= 45 or not(EntityCategoryContains(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryIndirect + M28UnitInfo.refCategoryStructure, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId)) or iDistToNearestEnemy > oUnit[M28UnitInfo.refiIndirectRange] + 3) then
                                                                --If enemy has a building then focus on this
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Want to attack nearest significant enemy, oNearestEnemyStructureToMidpoint='..(oNearestEnemyStructureToMidpoint.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyStructureToMidpoint) or 'nil')) end
                                                                if oNearestEnemyStructureToMidpoint and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oNearestEnemyStructureToMidpoint) then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': will target closest enemy structure') end
                                                                    M28Orders.IssueTrackedAttack(oUnit, oNearestEnemyStructureToMidpoint, false, 'ISNglSA'..iLandZone, false)
                                                                else
                                                                    local oEnemyToConsiderAttacking
                                                                    local iClosestEnemyToIndirect = 1000
                                                                    if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiUnitMassCost] >= 45 and EntityCategoryContains(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryIndirect + M28UnitInfo.refCategoryStructure, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId) then
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Will target closest enemy from last close to enemy check') end
                                                                        oEnemyToConsiderAttacking = oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]
                                                                    else
                                                                        for iEnemy, oEnemy in tLZTeamData[M28Map.subrefTEnemyUnits] do
                                                                            if oEnemy[M28UnitInfo.refiUnitMassCost] >= 45 and not(EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oEnemy.UnitId)) then
                                                                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                                                                                if iCurDist < iClosestEnemyToIndirect then
                                                                                    oEnemyToConsiderAttacking = oEnemy
                                                                                    iClosestEnemyToIndirect = iCurDist
                                                                                end
                                                                            end
                                                                        end
                                                                        if not(oEnemyToConsiderAttacking) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                                                                            --Just get the closest enemy unit
                                                                            for iEnemy, oEnemy in tLZTeamData[M28Map.reftoNearestDFEnemies] do

                                                                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                                                                                if iCurDist < iClosestEnemyToIndirect and not(oEnemy.Dead) then
                                                                                    oEnemyToConsiderAttacking = oEnemy
                                                                                    iClosestEnemyToIndirect = iCurDist
                                                                                end
                                                                            end
                                                                        end
                                                                    end
                                                                    if not(iClosestEnemyToIndirect) then --redundancy
                                                                        if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then oEnemyToConsiderAttacking = oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] else oEnemyToConsiderAttacking = oNearestEnemyToFriendlyBase end
                                                                        iClosestEnemyToIndirect = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToConsiderAttacking[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                                                                    end
                                                                    if bDebugMessages == true then
                                                                        if not(M28UnitInfo.IsUnitValid(oEnemyToConsiderAttacking)) then LOG(sFunctionRef..': oEnemyToConsiderAttacking is dead so will attack closest enemy base as a redundancy')
                                                                        else
                                                                            LOG(sFunctionRef..': oEnemyToConsiderAttacking='..oEnemyToConsiderAttacking.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToConsiderAttacking)..'; Can see this unit='..tostring(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemyToConsiderAttacking)))
                                                                        end
                                                                    end
                                                                    if not(M28UnitInfo.IsUnitValid(oEnemyToConsiderAttacking)) then --redundancy
                                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, tLZTeamData[M28Map.reftClosestEnemyBase], 5, false, 'IKADead'..iLandZone)
                                                                        --AOE ground attack option similar to below logic for hidden attackers we know are there and which arent moving
                                                                    elseif iClosestEnemyToIndirect <= oUnit[M28UnitInfo.refiIndirectRange] and (oUnit[M28UnitInfo.refiIndirectAOE] or 0) > 0 and oUnit[M28UnitInfo.refiTimeBetweenIFShots] and not(oEnemyToConsiderAttacking:IsUnitState('Moving')) and not(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemyToConsiderAttacking)) and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or -1) > 1 + oUnit[M28UnitInfo.refiTimeBetweenIFShots] * 1.2 and M28Utilities.GetDistanceBetweenPositions(oEnemyToConsiderAttacking:GetPosition(), oUnit:GetPosition()) <= (oUnit[M28UnitInfo.refiIndirectRange] or 0) then
                                                                        M28Orders.IssueTrackedGroundAttack(oUnit, oEnemyToConsiderAttacking:GetPosition(), math.min(1, oUnit[M28UnitInfo.refiIndirectAOE] * 0.5), false, 'INglHidA', false)
                                                                    elseif not(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemyToConsiderAttacking)) then
                                                                        --Just attack move as normal since we dont know enemy unit is there
                                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oEnemyToConsiderAttacking:GetPosition(), math.max(15, iIndirectDistanceInsideRangeThreshold), false, 'IKANgM'..iLandZone)
                                                                    else
                                                                        --We can see the enemy, so manual attack
                                                                        M28Orders.IssueTrackedAttack(oUnit, oEnemyToConsiderAttacking, false, 'IFNglAE'..iLandZone, false)
                                                                    end
                                                                end

                                                                --If have aoe attack and nearest enemy is in range and we havent fired recently and the nearest enemy isnt moving, but we have temporarily lost intel of it, then ground fire it
                                                            elseif (oUnit[M28UnitInfo.refiIndirectAOE] or 0) > 0 and oUnit[M28UnitInfo.refiTimeBetweenIFShots] and M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:IsUnitState('Moving')) and not(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or -1) > 1 + oUnit[M28UnitInfo.refiTimeBetweenIFShots] * 1.2 and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()) <= (oUnit[M28UnitInfo.refiIndirectRange] or 0) then
                                                                M28Orders.IssueTrackedGroundAttack(oUnit, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), math.min(1, oUnit[M28UnitInfo.refiIndirectAOE] * 0.5), false, 'IHidAtc', false)
                                                            elseif oMexToConsiderTargetetingInstead then
                                                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                                    if iDistToNearestEnemy <= oUnit[M28UnitInfo.refiCombatRange] + 3 then
                                                                        M28Orders.IssueTrackedAttack(oUnit, oMexToConsiderTargetetingInstead, false, 'IAtMx'..iLandZone, false)
                                                                    else
                                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oMexToConsiderTargetetingInstead:GetPosition(), 5, false, 'IAmMx'..iLandZone)
                                                                    end
                                                                end
                                                            else
                                                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(15, iIndirectDistanceInsideRangeThreshold), false, 'IKAMve'..iLandZone)
                                                                end
                                                            end
                                                        end
                                                    else
                                                        --Retreat IF units (will only have IF units if are at this point) temporarily from enemy units, unless we are a T1-T2 indirect fire unit that hasnt fired for a while and enemy isn't in our range yet
                                                        local iCurDistToDFEnemy = 1000
                                                        if oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] then
                                                            iCurDistToDFEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition())
                                                            if bDebugMessages == true then LOG(sFunctionRef..': refoClosestEnemyFromLastCloseToEnemyUnitCheck='..oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])..'; DFRange='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 'nil')..'; iCurDistToDFEnemy='..iCurDistToDFEnemy..'; Unit speed='..M28UnitInfo.GetUnitSpeed(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) end
                                                        end
                                                        local bTemporaryKiting = false

                                                        if (oUnit[M28UnitInfo.refiIndirectAOE] or 0) > 0 and oUnit[M28UnitInfo.refiTimeBetweenIFShots] and M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or -1) > 1 + oUnit[M28UnitInfo.refiTimeBetweenIFShots] * 1.2 and iCurDistToDFEnemy > (oUnit[M28UnitInfo.refiIndirectRange] or 0)
                                                                --exception - if up against a DF unit that outranges us, or almost outranges us and is moving
                                                                and (not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 0) + 4 < oUnit[M28UnitInfo.refiCombatRange] or (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] < oUnit[M28UnitInfo.refiCombatRange] and M28UnitInfo.GetUnitSpeed(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) < 0.2)) then

                                                            --Ground fire near the enemy unit
                                                            --MoveInDirection(tStart, iAngle, iDistance, bKeepInMapBounds, bTravelUnderwater, bKeepInCampaignPlayableArea)
                                                            local tGroundFireLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()), oUnit[M28UnitInfo.refiIndirectRange] - 2, true, false, M28Map.bIsCampaignMap)
                                                            M28Orders.IssueTrackedGroundAttack(oUnit, tGroundFireLocation, 2, false, 'IFKiAG'..iLandZone, false, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])
                                                        elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                            if (oUnit[M28UnitInfo.refbWeaponUnpacks] or not(oUnit[M28UnitInfo.refbCanKite])) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tAmphibiousRallyPoint) <= 13 then
                                                                M28Orders.IssueTrackedAggressiveMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AIKRetr'..iLandZone)
                                                            else
                                                                M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AIKRetr'..iLandZone)
                                                            end
                                                        else
                                                            if iCurDistToDFEnemy <= math.max((oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiCombatRange] or 0) + 8, (oUnit[M28UnitInfo.refiCombatRange] or 0) - 10) then
                                                                local tTemporaryRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), 8, true, false, M28Map.bIsCampaignMap)
                                                                if tTemporaryRetreatLocation and NavUtils.GetLabel(M28Map.refPathingTypeLand, tTemporaryRetreatLocation) == tLZData[M28Map.subrefLZIslandRef] then
                                                                    bTemporaryKiting = true
                                                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                                    M28Orders.IssueTrackedMove(oUnit, tTemporaryRetreatLocation, 6, false, 'IKEnRetr'..iLandZone)
                                                                end
                                                            end
                                                            if not(bTemporaryKiting) then
                                                                if (oUnit[M28UnitInfo.refbWeaponUnpacks] or not(oUnit[M28UnitInfo.refbCanKite])) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint) <= 13 then
                                                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, tRallyPoint, 6, false, 'IKRetr'..iLandZone)
                                                                else
                                                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'IKRetr'..iLandZone)
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        else
                                            --Consider if there are enemies in other adjacent zones that we do outrange
                                            if bDebugMessages == true and bConsiderAttackingAdjacentZoneEnemyWithOutrangedUnits == nil then LOG(sFunctionRef..': Considering if enemy has units in adj zone that we outrange even if we dont outrange cur zone, subrefLZThreatEnemyBestMobileDFRange='..tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]..'; refiIndirectRange='..oUnit[M28UnitInfo.refiIndirectRange]) end
                                            if bConsiderAttackingAdjacentZoneEnemyWithOutrangedUnits == nil then
                                                if tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] > 0 then
                                                    bConsiderAttackingAdjacentZoneEnemyWithOutrangedUnits = false
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy has nearby LR DF threat so wont consider') end
                                                elseif tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] < oUnit[M28UnitInfo.refiIndirectRange] or tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] < 50 then
                                                    bConsiderAttackingAdjacentZoneEnemyWithOutrangedUnits = false

                                                    --Is there an adjacent zone we could target? only consider if enemy mobile DF threat is outranged by us
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will check for vulnerable enemy units we outrange in adjacent zones, is subrefLZAdjacentLandZones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]))) end
                                                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                                        local toEnemiesThatOutrangeUs = {}
                                                        for iRecordedEnemy, oRecordedEnemy in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                                                            if oRecordedEnemy[M28UnitInfo.refiCombatRange] >= oUnit[M28UnitInfo.refiIndirectRange] then
                                                                table.insert(toEnemiesThatOutrangeUs, oRecordedEnemy)
                                                            end
                                                        end
                                                        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                                            local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                                                            local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; subrefLZThreatEnemyBestMobileDFRange='..tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]..'; subrefLZThreatEnemyBestStructureDFRange (which factors in nearest adj zone)='..tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange]..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]))) end
                                                            if tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] < oUnit[M28UnitInfo.refiIndirectRange] and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                                                                --Get closest enemy unit in this zone
                                                                local oClosestAdjacentPotentialEnemy
                                                                local iClosestAdjacentPotentialEnemy = 200
                                                                for iAdjacentEnemy, oAdjacentEnemy in tAdjLZTeamData[M28Map.subrefTEnemyUnits] do
                                                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oAdjacentEnemy:GetPosition())
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Checking for vulnerable targets we outrange in adj zone, oAdjacentEnemy='..oAdjacentEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oAdjacentEnemy)..'; iCurDist='..iCurDist) end
                                                                    if iCurDist < iClosestAdjacentPotentialEnemy then
                                                                        iClosestAdjacentPotentialEnemy = iCurDist
                                                                        oClosestAdjacentPotentialEnemy = oAdjacentEnemy
                                                                    end
                                                                end
                                                                if oClosestAdjacentPotentialEnemy then
                                                                    --Is this near any of the enemies that outrange us?
                                                                    local bNearToLongerRangedEnemies = false
                                                                    if M28Utilities.IsTableEmpty(toEnemiesThatOutrangeUs) == false then
                                                                        local iAngleToPotentialEnemy = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oClosestAdjacentPotentialEnemy:GetPosition())
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': oClosestAdjacentPotentialEnemy='..oClosestAdjacentPotentialEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestAdjacentPotentialEnemy)..'; iAngleToPotentialEnemy='..iAngleToPotentialEnemy) end
                                                                        for iEnemyToAvoid, oEnemyToAvoid in toEnemiesThatOutrangeUs do
                                                                            if bDebugMessages == true then LOG(sFunctionRef..': oEnemyToAvoid='..oEnemyToAvoid.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToAvoid)..'; Dist to oClosestAdjacentPotentialEnemy='..M28Utilities.GetDistanceBetweenPositions(oEnemyToAvoid:GetPosition(), oClosestAdjacentPotentialEnemy:GetPosition())..' Combat range='..oEnemyToAvoid[M28UnitInfo.refiCombatRange]..'; Angle from oUnit to oEnemyToAvoid='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oEnemyToAvoid:GetPosition())..'; Angle Dif='..M28Utilities.GetAngleDifference(iAngleToPotentialEnemy, M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oEnemyToAvoid:GetPosition()))) end
                                                                            if M28Utilities.GetDistanceBetweenPositions(oEnemyToAvoid:GetPosition(), oClosestAdjacentPotentialEnemy:GetPosition()) <= 35 + oEnemyToAvoid[M28UnitInfo.refiCombatRange] then
                                                                                bNearToLongerRangedEnemies = true
                                                                                break
                                                                            elseif M28Utilities.GetAngleDifference(iAngleToPotentialEnemy, M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oEnemyToAvoid:GetPosition())) <= 20 then
                                                                                bNearToLongerRangedEnemies = true
                                                                                break
                                                                            end
                                                                        end
                                                                    end
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': bNearToLongerRangedEnemies='..tostring(bNearToLongerRangedEnemies)) end
                                                                    if not(bNearToLongerRangedEnemies) then
                                                                        oAdjacentZoneEnemyToAttackWithOutrangedIF = oClosestAdjacentPotentialEnemy
                                                                        bConsiderAttackingAdjacentZoneEnemyWithOutrangedUnits = true
                                                                        break
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                            if bConsiderAttackingAdjacentZoneEnemyWithOutrangedUnits and GivenIndirectAdjacentZoneKitingOrder(oUnit) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will try attacking enemy unit in adjacent zone that this unit outranges') end
                                            else
                                                --Treat the same as outranged DF units
                                                if bDebugMessages == true then LOG(sFunctionRef..': Adding IF unit to outranged combat units') end
                                                table.insert(tOutrangedCombatUnits, oUnit)
                                            end
                                        end
                                    else
                                        M28Utilities.ErrorHandler('Have a unit without DF or indirect range, so will retreat with it')
                                        if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AUnkRetr'..iLandZone)
                                        else
                                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'UnkRetr'..iLandZone)
                                        end
                                    end
                                elseif (oUnit[M28UnitInfo.refiIndirectRange] or 0) > iEnemyBestDFRange then
                                    table.insert(tUnitsToSupport, oUnit)
                                end
                            end
                        end

                        if M28Utilities.IsTableEmpty(tOutrangedCombatUnits) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have outranged combat units, bAttackWithOutrangedDFUnits='..tostring(bAttackWithOutrangedDFUnits or false)..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; GetEnemyCombatThreatInAdjacentZones()='..GetEnemyCombatThreatInAdjacentZones()) end
                            ProtectFriendlyACUInTroubleIfRelevant(tOutrangedCombatUnits)
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of outranged units empty after checking for supporting ACU in trouble='..tostring(M28Utilities.IsTableEmpty(tOutrangedCombatUnits))) end
                            if not(bHaveACUInTroubleAndRecentlyInCombat) or M28Utilities.IsTableEmpty(tOutrangedCombatUnits) == false then
                                --Consider still attacking if we have a large threat for our outranged combat units
                                if not(bAttackWithOutrangedDFUnits) then
                                    if bSuicideIntoFatboyOrACU and oClosestFatboyOrACUInIslandToSuicideInto then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to suicide into fatboy or ACU so will attack with outranged DF units after all') end
                                        bAttackWithOutrangedDFUnits = true
                                    else
                                        CalculateNearbyEnemyCombatThreatFriendlyDFAndIfFriendlyACUInCombat(tOutrangedCombatUnits)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding if want to attack with outranged units, iOurDFAndT1ArtiCombatThreat using only SR units='..(iOurDFAndT1ArtiCombatThreat or 'nil')..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; Enemy combat in adj zones='..GetEnemyCombatThreatInAdjacentZones()..'; iOutrangedThreat='..M28UnitInfo.GetCombatThreatRating(tOutrangedCombatUnits, false, false)..'; iEnemyCombatThreat='..(iEnemyCombatThreat or 'nil')) end
                                        if iOurDFAndT1ArtiCombatThreat > iEnemyCombatThreat then
                                            if iOurDFAndT1ArtiCombatThreat > iEnemyCombatThreat * 5 or (iOurDFAndT1ArtiCombatThreat >= 16000 and iOurDFAndT1ArtiCombatThreat > iEnemyCombatThreat * 1.5) then
                                                bAttackWithOutrangedDFUnits = true
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering only enemy units nearby, we have enough to attack, iEnemyCombatThreat='..iEnemyCombatThreat..'; iOurDFAndT1ArtiCombatThreat='..iOurDFAndT1ArtiCombatThreat) end
                                            else
                                                local iOutrangedThreat = M28UnitInfo.GetCombatThreatRating(tOutrangedCombatUnits, false, false)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Our iOutrangedThreat='..iOutrangedThreat..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; iEnemyBestDFRange='..iEnemyBestDFRange..'; iFriendlyBestMobileDFRange='..iFriendlyBestMobileDFRange..'; iEnemyBestStructureDFRange='..(iEnemyBestStructureDFRange or 'nil')..'; iFirebaseThreatAdjust='..iFirebaseThreatAdjust..'; oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange]='..(oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 'nil')) end
                                                if iOutrangedThreat / iAvailableCombatUnitThreat >= 0.8 then
                                                    bAttackWithOutrangedDFUnits = true
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Our long ranged threat is only a small proportion of our total combat threat so we will attack with everything') end
                                                elseif iEnemyBestDFRange <= 26 and iFriendlyBestMobileDFRange <= 33 and iOutrangedThreat / iAvailableCombatUnitThreat >= 0.25 and (iEnemyBestStructureDFRange or 0) == 0 and iFirebaseThreatAdjust == 0 and (oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0) <= 26 then
                                                    bAttackWithOutrangedDFUnits = true
                                                    if bDebugMessages == true then LOG(sFunctionRef..': our and enemy ranges suggest may still be at the t1 stage so will attack as a significant part of our force is SR units, and overall we think we have enough threat to handle enemy') end
                                                elseif iOutrangedThreat > iEnemyCombatThreat * 1.5 then
                                                    if iOutrangedThreat > iEnemyCombatThreat * 3 or (iOutrangedThreat > iEnemyCombatThreat * 2.5 and iOutrangedThreat / iAvailableCombatUnitThreat >= 0.5) then
                                                        bAttackWithOutrangedDFUnits = true
                                                    else
                                                        --Get threat of SR units near the nearest enemy unit - if we have enough of a force with SR units alone then press attack
                                                        local oClosestSRUnitToEnemy
                                                        local iClosestSRUnitToEnemy = 100000
                                                        for iSRUnit, oSRUnit in tOutrangedCombatUnits do
                                                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oSRUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition()) - oSRUnit[M28UnitInfo.refiCombatRange]
                                                            if iCurDist < iClosestSRUnitToEnemy then
                                                                iClosestSRUnitToEnemy =  iCurDist
                                                                oClosestSRUnitToEnemy = oSRUnit
                                                            end
                                                        end
                                                        local iSRThreatNearFront = 0
                                                        for iCurSRUnit = table.getn(tOutrangedCombatUnits), 1, -1 do
                                                            local oSRUnit = tOutrangedCombatUnits[iCurSRUnit]
                                                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oSRUnit:GetPosition(), oClosestSRUnitToEnemy:GetPosition()) + oClosestSRUnitToEnemy[M28UnitInfo.refiCombatRange] - oSRUnit[M28UnitInfo.refiCombatRange]
                                                            if iCurDist <= 40 then
                                                                iSRThreatNearFront = iSRThreatNearFront + (oSRUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oSRUnit))
                                                            else
                                                                --Consolidate further away SR Units
                                                                M28Orders.IssueTrackedMove(oSRUnit, oClosestSRUnitToEnemy:GetPosition(), 5, false, 'SRConsol', false)
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Will consoliate further away SRUnit='..oSRUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSRUnit)) end
                                                                table.remove(tOutrangedCombatUnits, iCurSRUnit)
                                                            end
                                                        end
                                                        if bDebugMessages == true then LOG(sFunctionRef..': iSRThreatNearFront='..iSRThreatNearFront..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; iOutrangedThreat / iAvailableCombatUnitThreat='..iOutrangedThreat / iAvailableCombatUnitThreat) end
                                                        if iSRThreatNearFront > iEnemyCombatThreat and (iSRThreatNearFront > iEnemyCombatThreat * 1.5 or (iSRThreatNearFront > iEnemyCombatThreat * 1.2 and iOutrangedThreat / iAvailableCombatUnitThreat >= 0.55)) then
                                                            bAttackWithOutrangedDFUnits = true
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                                --Override for if enemy ACU nearby
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering adjustment if want to attack with outranged DF units but enemy has ACU nearby, bAttackWithOutrangedDFUnits before adjust='..tostring(bAttackWithOutrangedDFUnits)..'; Is table of ACUs in zone empty='..tostring(M28Utilities.IsTableEmpty(toEnemyACUsNearZone))..'; bConsiderAttackingACU='..tostring(bConsiderAttackingACU)) end
                                if bAttackWithOutrangedDFUnits and M28Utilities.IsTableEmpty(toEnemyACUsNearZone) == false and not(bConsiderAttackingACU) then
                                    --If enemy ACU is within 30 of the closest enemy unit then dont attack with outranged DF units
                                    local iDistThresholdForACU = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) - 30
                                    local iDistToNearestEnemyThreshold = 30
                                    if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oNearestEnemyToFriendlyBase.UnitId) and (oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0) <= 10 then
                                        iDistThresholdForACU = iDistThresholdForACU + 7
                                        iDistToNearestEnemyThreshold = iDistToNearestEnemyThreshold - 7
                                    end
                                    for iACU, oACU in toEnemyACUsNearZone do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Dist between ACU and nearest enemy to friendly base='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition())) end
                                        if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition()) <= iDistToNearestEnemyThreshold or M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) <= iDistThresholdForACU then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy ACU is too close to nearest enemy unit so wont have our SR DF units attack') end
                                            bAttackWithOutrangedDFUnits = false
                                            break
                                        end
                                    end
                                end
                                if bAttackWithOutrangedDFUnits then
                                    for iUnit, oUnit in tOutrangedCombatUnits do
                                        if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end

                                        if bMoveBlockedNotAttackMove and (oUnit[M28UnitInfo.refbLastShotBlocked] or M28UnitInfo.IsUnitUnderwater(oUnit)) and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) and not(oUnit[M28UnitInfo.refbScoutCombatOverride]) then
                                            M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'OBlckM'..iLandZone)
                                            --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                        else
                                            if oUnit[M28UnitInfo.refbEasyBrain] then
                                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                    M28Orders.IssueTrackedAttackMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'EsySRAM'..iLandZone)
                                                end
                                            else
                                                if bConsiderAttackingACU and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbScoutCombatOverride]) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), toEnemyACUsNearZone, 6 + oUnit[M28UnitInfo.refiDFRange], iTeam, false, nil, nil, nil, nil, nil) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to attack ACU with experimental') end
                                                    GetUnitToAttackNearestACUOrOverrideUnit(oUnit)
                                                    --Attackmove (unless we have far more threat in this zone)

                                                elseif oUnit[M28Air.refiTimeLastDropped] and oUnit[M28UnitInfo.refiIndirectRange] > 0 and GetGameTimeSeconds() - oUnit[M28Air.refiTimeLastDropped] <= 60 and oNearestEnemyStructureToMidpoint then
                                                    SuicideUnitIntoEnemyStructure(oUnit)
                                                else
                                                    local oTargetToManuallyAttack, bMoveNotManualAttack = GetManualAttackTargetIfWantManualAttack(oUnit)
                                                    oUnit[refoSREnemyTarget] = oTargetToManuallyAttack
                                                    if not(oTargetToManuallyAttack) then oUnit[refoSREnemyTarget] = oNearestEnemyToFriendlyBase end
                                                    oUnit[refiTimeOfSREnemyTarget] = GetGameTimeSeconds()
                                                    if oTargetToManuallyAttack then
                                                        if bMoveNotManualAttack then M28Orders.IssueTrackedMove(oUnit, oTargetToManuallyAttack:GetPosition(), 2, false, 'SRManM', false)
                                                        else
                                                            DoManualAttack(oUnit, oTargetToManuallyAttack, 'SRManA')
                                                        end
                                                        --M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'SRManA', false)
                                                    elseif iAvailableCombatUnitThreat > 5000 and iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 8 and not((oUnit[M28UnitInfo.refiDFRange] or 0) >= 64 or EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) or oUnit[M28UnitInfo.refbScoutCombatOverride]) then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to move unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to SREnemy target='..(oUnit[refoSREnemyTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit[refoSREnemyTarget]) or 'nil')) end
                                                        if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                            M28Orders.IssueTrackedMove(oUnit, oUnit[refoSREnemyTarget][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SRDFM'..iLandZone, false)
                                                        end
                                                    else
                                                        --Exception - experimentals that are in range of enemy PD
                                                        if EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and not(EntityCategoryContains(M28UnitInfo.refCategoryStructure * categories.TECH2 + categories.TECH3 + categories.COMMAND - M28UnitInfo.refCategoryEngineer, oNearestEnemyToFriendlyBase.UnitId)) and GetEnemyCombatThreatInAdjacentZones() >= 5000 then
                                                            --Want to try and find nearby enemy high value units
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with experimental '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so will look for high value enemuy threats nearby to target') end
                                                            if EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and not(EntityCategoryContains(M28UnitInfo.refCategoryStructure * categories.TECH2 + categories.TECH3 + categories.COMMAND - M28UnitInfo.refCategoryEngineer, oNearestEnemyToFriendlyBase.UnitId)) and GetEnemyCombatThreatInAdjacentZones() >= 5000 then
                                                                local tNearbyHighValueUnits = oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryExperimentalLevel + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryStructure * categories.TECH3 - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryPD + categories.COMMAND, oUnit:GetPosition(), (oUnit[M28UnitInfo.refiDFRange] or 20) + 15, 'Enemy')
                                                                local bMoveNotAttack = false
                                                                if M28Utilities.IsTableEmpty(tNearbyHighValueUnits) == false then
                                                                    local tACUsInNearbyHighValueUnits = EntityCategoryFilterDown(categories.COMMAND, tNearbyHighValueUnits)
                                                                    oTargetToManuallyAttack = nil
                                                                    if M28Utilities.IsTableEmpty( tACUsInNearbyHighValueUnits) == false then
                                                                        oTargetToManuallyAttack, bMoveNotAttack = GetManualAttackTargetIfWantManualAttack(oUnit)
                                                                    end
                                                                    if not(oTargetToManuallyAttack) then
                                                                        oTargetToManuallyAttack = M28Utilities.GetNearestUnit(tNearbyHighValueUnits, oUnit:GetPosition())
                                                                    end
                                                                end
                                                                if oTargetToManuallyAttack and not(oTargetToManuallyAttack:IsUnitState('Attached')) and not(M28UnitInfo.IsUnitUnderwater(oTargetToManuallyAttack)) then
                                                                    if not(bMoveNotAttack) and M28Utilities.GetDistanceBetweenPositions(oTargetToManuallyAttack:GetPosition(), oUnit:GetPosition()) <= (oUnit[M28UnitInfo.refiDFRange] or 0) + 1 then
                                                                        DoManualAttack(oUnit, oTargetToManuallyAttack, 'SRManX')
                                                                        --M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'SRManA', false)
                                                                    else
                                                                        M28Orders.IssueTrackedMove(oUnit, oTargetToManuallyAttack:GetPosition(), 10, 'SRxpTO', false)
                                                                    end
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Targeting oTargetToManuallyAttack='..oTargetToManuallyAttack.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTargetToManuallyAttack)) end
                                                                else
                                                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                                        if oUnit[M28UnitInfo.refiWeaponScanRange] and oUnit[M28UnitInfo.refiWeaponScanRange] + 5 < oUnit[M28UnitInfo.refiCombatRange] then
                                                                            ConsiderManualAttackInsteadOfAttackMove(oUnit, oUnit[refoSREnemyTarget], oUnit[refoSREnemyTarget][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, 'SRDFEA')
                                                                        else
                                                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oUnit[refoSREnemyTarget][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SRDFEA'..iLandZone)
                                                                        end
                                                                    end
                                                                end
                                                            else
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Targeting nearest SR enemy target via attack move, target='..oUnit[refoSREnemyTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[refoSREnemyTarget])) end
                                                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                                    if oUnit[M28UnitInfo.refiWeaponScanRange] and oUnit[M28UnitInfo.refiWeaponScanRange] + 5 < oUnit[M28UnitInfo.refiCombatRange] then
                                                                        ConsiderManualAttackInsteadOfAttackMove(oUnit, oUnit[refoSREnemyTarget], oUnit[refoSREnemyTarget][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, 'SRDFExA')
                                                                    else
                                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oUnit[refoSREnemyTarget][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SRDFExA'..iLandZone)
                                                                    end
                                                                end
                                                            end
                                                        else
                                                            if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                                if oUnit[M28UnitInfo.refiWeaponScanRange] and oUnit[M28UnitInfo.refiWeaponScanRange] + 5 < oUnit[M28UnitInfo.refiCombatRange] then
                                                                    ConsiderManualAttackInsteadOfAttackMove(oUnit, oUnit[refoSREnemyTarget], oUnit[refoSREnemyTarget][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, 'SRDFA')
                                                                else
                                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oUnit[refoSREnemyTarget][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SRDFA'..iLandZone)
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                else
                                    --Arent attacking enemy with SR units so just want to be nearby to be ready to support
                                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of units to support empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToSupport))) end
                                    if M28Utilities.IsTableEmpty(tUnitsToSupport) == false then
                                        --Short range DF units can stay back and provide support - stay inbetween our long range DF units and the rally point

                                        local iCurDist
                                        local iClosestDist = 100000
                                        local oClosestUnit
                                        local iDistToRetreat = 10
                                        local bNearestEnemyIsExperimental = false
                                        if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oNearestEnemyToFriendlyBase.UnitId) then
                                            bNearestEnemyIsExperimental = true
                                        end

                                        local tNearbyEnemyDFExperimentals = {}
                                        local bEnemyHasNearbyExperimentals = false
                                        if oNearestEnemyToFriendlyBase and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                                            tNearbyEnemyDFExperimentals = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental, tLZTeamData[M28Map.reftoNearestDFEnemies])
                                            if M28Utilities.IsTableEmpty(tNearbyEnemyDFExperimentals) == false then
                                                bEnemyHasNearbyExperimentals = true
                                            end
                                        end

                                        local tSRRallyOverride --Used if nearest enemy is a similar angle as our closest friendly base
                                        if oNearestEnemyToFriendlyBase then
                                            local oClosestLRToRally
                                            local iClosestLRToRally = 100000
                                            for iLRUnit, oLRUnit in tUnitsToSupport do
                                                iCurDist = M28Utilities.GetRoughDistanceBetweenPositions(oLRUnit:GetPosition(), tAmphibiousRallyPoint)
                                                if iCurDist < iClosestLRToRally then
                                                    iClosestLRToRally = iCurDist
                                                    oClosestLRToRally = oLRUnit
                                                end
                                            end
                                            local iAngleToRally = M28Utilities.GetAngleFromAToB(oClosestLRToRally:GetPosition(), tAmphibiousRallyPoint)
                                            local iAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(oClosestLRToRally:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition())
                                            if bDebugMessages == true then LOG(sFunctionRef..': oClosestLRToRally='..oClosestLRToRally.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestLRToRally)..'; iAngleToRally='..iAngleToRally..'; iAngleToNearestEnemy='..iAngleToNearestEnemy..'; Angle dif='..M28Utilities.GetAngleDifference(iAngleToRally, iAngleToNearestEnemy)) end
                                            if M28Utilities.GetAngleDifference(iAngleToRally, iAngleToNearestEnemy) <= 90 then
                                                tSRRallyOverride = M28Utilities.MoveInDirection(oClosestLRToRally:GetPosition(), iAngleToNearestEnemy + 180, 20, true, nil, not(M28Map.bIsCampaignMap))
                                                if bDebugMessages == true then
                                                    LOG(sFunctionRef..': Land label of tSRRallyOverride='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tSRRallyOverride) or 'nil')..'; Island ref of this LZ='..(tLZData[M28Map.subrefLZIslandRef] or 'nil'))
                                                    --M28Utilities.DrawLocation(tSRRallyOverride)
                                                end
                                                if tSRRallyOverride and NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tSRRallyOverride) == tLZData[M28Map.subrefLZIslandRef] then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Setting SR rally override so we go away from the nearest enemy to our base due to risk otherwise that we move closer to that enemy by moving towards the rally') end
                                                else
                                                    tSRRallyOverride = nil
                                                end
                                            end
                                        end

                                        --Expand units to support to include friendly units in an adjacent zone if that zone has mobile DF units that outrange our SR threshold (as long ranged units and skirmishers are assigned to the zone they are in)
                                        local iAdjacentRangeThreshold = iDFRangeOverrideForScenario1 or iEnemyBestDFRange
                                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                            local iDistToClosestEnemyFromMidpointThreshold = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oNearestEnemyToFriendlyBase:GetPosition()) + 10
                                            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                                --Is this zone closer to the nearest enemy than our current zone?
                                                local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                                                if M28Utilities.GetDistanceBetweenPositions(tAdjLZData[M28Map.subrefMidpoint], oNearestEnemyToFriendlyBase:GetPosition()) <= iDistToClosestEnemyFromMidpointThreshold then
                                                    local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                                                    local bHaveLRUnit = false
                                                    if tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] > 0 and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZTAlliedCombatUnits]) == false and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
                                                        for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                                                            if iRange >= iAdjacentRangeThreshold and iThreat > 0 then
                                                                bHaveLRUnit = true
                                                                break
                                                            end
                                                        end
                                                    end
                                                    if bHaveLRUnit then
                                                        for iAdjUnit, oAdjUnit in tAdjLZTeamData[M28Map.subrefLZTAlliedCombatUnits] do
                                                            if oAdjUnit[M28UnitInfo.refiDFRange] and oAdjUnit[M28UnitInfo.refiDFRange] > iAdjacentRangeThreshold and not(oAdjUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone) and not(oAdjUnit.Dead) then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit in adjacent zone to units to support, oAdjUnit='..oAdjUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oAdjUnit)..' with range='..oAdjUnit[M28UnitInfo.refiDFRange]) end
                                                                table.insert(tUnitsToSupport, oAdjUnit)
                                                            end
                                                        end
                                                    end
                                                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefAlliedACU]) == false then
                                                        if not(tAdjLZTeamData[M28Map.subrefLZbCoreBase]) or not(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs]) then --no point supporting an ACU hiding in our base
                                                            for iAdjACU, oAdjACU in tAdjLZTeamData[M28Map.subrefAlliedACU] do
                                                                --If ACU isnt the longest range it wont be included as a unit to support, but we still want to cover it
                                                                if not(oAdjACU[M28ACU.refiTimeLastWantedToRun]) or GetGameTimeSeconds() - oAdjACU[M28ACU.refiTimeLastWantedToRun] >= 10 or (oAdjACU[M28UnitInfo.refiLastWeaponEvent] and GetGameTimeSeconds() - oAdjACU[M28UnitInfo.refiLastWeaponEvent] <= 10) or tAdjLZTeamData[M28Map.refbACUInTrouble] then
                                                                    table.insert(tUnitsToSupport, oAdjACU)
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false then
                                            if not(tLZTeamData[M28Map.subrefLZbCoreBase]) or tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 or not(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs]) then --no point supporting an ACU hiding in our base
                                                for iACU, oACU in tLZTeamData[M28Map.subrefAlliedACU] do
                                                    --If ACU isnt the longest range it wont be included as a unit to support, but we still want to cover it
                                                    if not(oACU[M28ACU.refiTimeLastWantedToRun]) or GetGameTimeSeconds() - oACU[M28ACU.refiTimeLastWantedToRun] >= 10 or (oACU[M28UnitInfo.refiLastWeaponEvent] and GetGameTimeSeconds() - oACU[M28UnitInfo.refiLastWeaponEvent] <= 10) or tLZTeamData[M28Map.refbACUInTrouble] then
                                                        table.insert(tUnitsToSupport, oACU)
                                                    end
                                                end
                                            end
                                        end

                                        for iSRUnit, oSRUnit in tOutrangedCombatUnits do
                                            --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                            if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oSRUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                                            iClosestDist = 100000
                                            for iLRUnit, oLRUnit in tUnitsToSupport do
                                                iCurDist = M28Utilities.GetRoughDistanceBetweenPositions(oSRUnit:GetPosition(), oLRUnit:GetPosition())
                                                if iCurDist < iClosestDist then
                                                    iClosestDist = iCurDist
                                                    oClosestUnit = oLRUnit
                                                end
                                            end
                                            if bNearestEnemyIsACU then iDistToRetreat = 20
                                            elseif bNearestEnemyIsExperimental and not(EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oSRUnit.UnitId)) then iDistToRetreat = 18
                                            elseif tSRRallyOverride then iDistToRetreat = 15
                                            else iDistToRetreat = 10
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': oSRUnit='..oSRUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSRUnit)..'; oSRUnit[M28UnitInfo.refbCanKite]='..tostring(oSRUnit[M28UnitInfo.refbCanKite] or false)..'; iClosestDist='..iClosestDist..'; oClosestUnit='..(oClosestUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestUnit))..'; do we have an amphibious oSRUnit='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oSRUnit.UnitId))..'; iDistToRetreat='..iDistToRetreat..'; Is special micro active for SR unit='..tostring(oSRUnit[M28UnitInfo.refbSpecialMicroActive] or false)..'; Time since micro started='..GetGameTimeSeconds() - (oSRUnit[M28UnitInfo.refiGameTimeMicroStarted] or 0)) end
                                            if oSRUnit[M28UnitInfo.refbEasyBrain] then
                                                oSRUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                M28Orders.IssueTrackedAttackMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), (tSRRallyOverride or tRallyPoint)), iDistToRetreat, true, false, true), 4, false, 'SReASup'..iLandZone)
                                            elseif oSRUnit[M28Air.refiTimeLastDropped] and oSRUnit[M28UnitInfo.refiIndirectRange] > 0 and GetGameTimeSeconds() - oSRUnit[M28Air.refiTimeLastDropped] <= 60 and oNearestEnemyStructureToMidpoint then
                                                SuicideUnitIntoEnemyStructure(oSRUnit)
                                            else
                                                if (bConsiderAttackingACU or oSRUnit[M28UnitInfo.refiUnitMassCost] >= 17000 and oSRUnit[M28UnitInfo.refiDFRange] <= 64 and M28Utilities.IsTableEmpty(toEnemyACUsNearZone) == false) and not(oSRUnit[M28UnitInfo.refbLastShotBlocked]) and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryAbsolver, oSRUnit.UnitId) and not(oSRUnit[M28UnitInfo.refbScoutCombatOverride]) and M28Conditions.CloseToEnemyUnit(oSRUnit:GetPosition(), toEnemyACUsNearZone, 6 + oSRUnit[M28UnitInfo.refiDFRange], iTeam, false, nil, nil, nil, nil, nil) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Have an experimental we want to attack enemy ACU with') end
                                                    GetUnitToAttackNearestACUOrOverrideUnit(oSRUnit)
                                                    --Non-fatboy experimental - if we are almost in range of enemy experimental unit then attack
                                                elseif bEnemyHasNearbyExperimentals and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryLandCombat * categories.TECH3 - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryAbsolver, oSRUnit.UnitId) and not(oSRUnit[M28UnitInfo.refbScoutCombatOverride]) and M28Conditions.CloseToEnemyUnit(oSRUnit:GetPosition(), tNearbyEnemyDFExperimentals, 5, iTeam, true, math.min(oSRUnit[M28UnitInfo.refiDFRange] or 20) - 5, oSRUnit, oSRUnit) then

                                                    --Consider manual attack target
                                                    local oTargetToManuallyAttack, bMoveNotManualAttack = GetManualAttackTargetIfWantManualAttack(oSRUnit, oSRUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or oNearestEnemyToFriendlyBase

                                                    --Consider moving instead of attacking if not well within range
                                                    if bDebugMessages == true then LOG(sFunctionRef..': SR unit Want to attack or move towards enemy manual attack target, dist to target='..M28Utilities.GetDistanceBetweenPositions(oTargetToManuallyAttack:GetPosition(), oSRUnit:GetPosition())..'; Our DF range='..oSRUnit[M28UnitInfo.refiDFRange]..'; oTargetToManuallyAttack='..(oTargetToManuallyAttack.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTargetToManuallyAttack) or 'nil')) end
                                                    if not(oTargetToManuallyAttack) or bMoveNotManualAttack or M28Utilities.GetDistanceBetweenPositions(oTargetToManuallyAttack:GetPosition(), oSRUnit:GetPosition()) > oSRUnit[M28UnitInfo.refiDFRange] - 5 then
                                                        M28Orders.IssueTrackedMove(oSRUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'ExpSRM'..iLandZone)
                                                    else
                                                        DoManualAttack(oSRUnit, oTargetToManuallyAttack, 'ExpSRA')
                                                    end
                                                elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oSRUnit.UnitId) then
                                                    if oSRUnit[M28UnitInfo.refbCanKite] then
                                                        if bDebugMessages == true then
                                                            LOG(sFunctionRef..': Want unit to move towards tAmphibiousRallyPoint, position to move to towards this='..repru(M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), (tSRRallyOverride or tAmphibiousRallyPoint)), 5, true, false, true))..'; cur position='..repru(oSRUnit:GetPosition())..'; Last orders='..reprs(oSRUnit[M28Orders.reftiLastOrders])..'; Angle from cur position to new position='..M28Utilities.GetAngleFromAToB(oSRUnit:GetPosition(), tAmphibiousRallyPoint)..'; IgnoreOrderDueToStuckUnit(oSRUnit)='..tostring(IgnoreOrderDueToStuckUnit(oSRUnit) or false))
                                                        end
                                                        --if not(IgnoreOrderDueToStuckUnit(oSRUnit)) then --(removed in v129 as was having cases of SR units suiciding into enemy due to this, and since we are here we want the SR unit to run from enemy and dont have enough threat to overwhelm enemy
                                                        M28Orders.IssueTrackedMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), (tSRRallyOverride or tAmphibiousRallyPoint)), iDistToRetreat, true, false, true), 5, false, 'ASRSup'..iLandZone)
                                                        --end
                                                    else
                                                        --if not(IgnoreOrderDueToStuckUnit(oSRUnit)) then
                                                        M28Orders.IssueTrackedAttackMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), (tSRRallyOverride or tAmphibiousRallyPoint)), iDistToRetreat, true, false, true), 5, false, 'AASRSup'..iLandZone)
                                                        --end
                                                    end

                                                else
                                                    if oSRUnit[M28UnitInfo.refbCanKite] then
                                                        --if not(IgnoreOrderDueToStuckUnit(oSRUnit)) then --(removed in v129 as was having cases of SR units suiciding into enemy due to this, and since we are here we want the SR unit to run from enemy and dont have enough threat to overwhelm enemy
                                                        M28Orders.IssueTrackedMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), (tSRRallyOverride or tRallyPoint)), iDistToRetreat, true, false, true), 4, false, 'SRSup'..iLandZone)
                                                        --end
                                                    else
                                                        --if not(IgnoreOrderDueToStuckUnit(oSRUnit)) then
                                                        M28Orders.IssueTrackedAttackMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), (tSRRallyOverride or tRallyPoint)), iDistToRetreat, true, false, true), 4, false, 'SRASup'..iLandZone)
                                                        --end
                                                    end
                                                end
                                            end
                                        end
                                    else
                                        --Maybe the units have micro active so arent being included? havent traced back the code to confirm
                                        M28Utilities.ErrorHandler('We somehow think we outrange the enemy with DF units, but have no DF units with a long range, P'..iPlateau..'Z'..iLandZone, true)
                                    end
                                end
                            end
                        end

                        if math.max(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]* 0.7,tLZTeamData[M28Map.subrefThreatEnemyDFStructures] + tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal])  * 1.5 > iAvailableCombatUnitThreat then
                            bWantReinforcements = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Want reinforcements as enemy combat DF exceeds our combat rating, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Our combat units rating='..iAvailableCombatUnitThreat) end
                        end

                        if bUpdateNearestUnit and aiBrain then
                            --[[if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                                local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                                if aiBrain then--]]
                            M28Team.UpdateUnitLastKnownPosition(aiBrain, oNearestEnemyToFriendlyBase, true)
                            --[[end
                        else
                            M28Utilities.ErrorHandler('No active M28 brain')
                        end--]]
                        end
                    end
                end
                if not(bAreInScenario1) then
                    --SCENARIO 2 - we dont outrange enemy with DF, but have slightly more threat than them, or have nowhere left to run
                    local bAttackWithEverything = false
                    if bSuicideIntoFatboyOrACU and oClosestFatboyOrACUInIslandToSuicideInto then
                        if bDebugMessages == true then LOG(sFunctionRef..': We want to suicide into enemy fatboy or ACU') end
                        bAttackWithEverything = true
                    elseif tLZTeamData[M28Map.subrefLZbCoreBase] and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false or M28UnitInfo.GetCombatThreatRating(tAvailableCombatUnits) >= 2500) and ((tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0) == 0 or (GetGameTimeSeconds() >= 600 or (GetGameTimeSeconds() >= 300 / M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier] and not(M28Map.bIsCampaignMap)))) then
                        --Attack with everything if enemy has any units in core zone, or close to core zone
                        if bDebugMessages == true then LOG(sFunctionRef..': Core base, so attack if enemies here, is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))) end
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                            bAttackWithEverything = true
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': No enemies in this zone, distance of nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), tLZData[M28Map.subrefMidpoint])..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]..'; Is nearest structure to midpoint valid='..tostring(M28UnitInfo.IsUnitValid(oNearestEnemyStructureToMidpoint))..'; tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange]='..tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange]) end

                            if oNearestEnemyToFriendlyBase then
                                local iDistToNearestEnemy
                                iDistToNearestEnemy = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                if iDistToNearestEnemy <= 80 or (iDistToNearestEnemy <= 120 and tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] <= 300) or (iDistToNearestEnemy <= 130 and EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oNearestEnemyToFriendlyBase.UnitId)) then
                                    --Attack with everything unless nearest enemy unit is a structure and we have indirect threat in this zone or that zone that outranges it

                                    bAttackWithEverything = true
                                elseif oNearestEnemyStructureToMidpoint and M28Utilities.GetDistanceBetweenPositions(oNearestEnemyStructureToMidpoint:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= 160 and iFriendlyBestMobileIndirectRange >= 50 then
                                    bAttackWithEverything = true
                                end
                                if bDebugMessages == true and oNearestEnemyStructureToMidpoint then LOG(sFunctionRef..': oNearestEnemyStructureToMidpoint='..oNearestEnemyStructureToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyStructureToMidpoint)..'; Distance to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyStructureToMidpoint:GetPosition(), tLZData[M28Map.subrefMidpoint])..'; IF range='..iFriendlyBestMobileIndirectRange..'; bAttackWithEverything='..tostring(bAttackWithEverything)) end
                            end
                            if not(bAttackWithEverything) then
                                --Still attack if we have significant threat
                                if table.getn(tAvailableCombatUnits) >= 60 then bAttackWithEverything = true end
                            end
                        end
                    else
                        --Are we close to a core zone and enemy has a structure threat in this zone and we haev indirect fire?
                        if bDebugMessages == true and oNearestEnemyStructureToMidpoint then LOG(sFunctionRef..': Non core zone, oNearestEnemyStructureToMidpoint'..oNearestEnemyStructureToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyStructureToMidpoint)..'; Dist to closest friendly base from this zone midpoint='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase])..'; Enemy structure value='..tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] >= 100) end
                        if oNearestEnemyStructureToMidpoint and iFriendlyBestMobileIndirectRange >= 50 and tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] >= 100 and M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 175 then
                            bAttackWithEverything = true
                        end
                    end
                    local bConsolidateAtMidpoint = false
                    local bOnlyAttackWithUnitsInThisZone = false
                    local bAttackWithLowerThreatRatio = true
                    CalculateNearbyEnemyCombatThreatFriendlyDFAndIfFriendlyACUInCombat()
                    if iOurDFAndT1ArtiCombatThreat > 0 and M28Utilities.IsTableEmpty(tOurDFAndT1ArtiUnits) == false then
                        local iOurDFAndT1ArtiUnits = table.getn(tOurDFAndT1ArtiUnits)
                        if not(bAttackWithEverything) and iOurDFAndT1ArtiUnits >= 125 and iOurDFAndT1ArtiUnits - table.getn(tLZTeamData[M28Map.subrefTEnemyUnits]) >= 50 and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) or table.getn(tLZTeamData[M28Map.reftoNearestDFEnemies]) < iOurDFAndT1ArtiUnits * 0.25) then bAttackWithEverything = true end
                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to attack with everything - pre firebase and beachhead adjust bAttackWithEverything='..tostring(bAttackWithEverything)..'; iOurDFAndT1ArtiCombatThreat='..iOurDFAndT1ArtiCombatThreat..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; iFirebaseThreatAdjust='..iFirebaseThreatAdjust..'; bHaveSignificantCombatCloserToFirebase='..tostring(bHaveSignificantCombatCloserToFirebase)..'; tLZTeamData[M28Map.subrefLZTValue]='..tLZTeamData[M28Map.subrefLZTValue]..'; Have enough threat to attack (ignoring lower modifier for if nearby ACU or if this zone has PD)='..tostring(M28Conditions.HaveEnoughThreatToAttack(iPlateau, iLandZone, tLZData, tLZTeamData, iOurDFAndT1ArtiCombatThreat, iEnemyCombatThreat, math.max(iFirebaseThreatAdjust, (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0)), bHaveSignificantCombatCloserToFirebase, iTeam))..'; oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..'; Is brain civilian='..tostring(M28Conditions.IsCivilianBrain(oNearestEnemyToFriendlyBase:GetAIBrain()))..'; iClosestFriendlyUnitToAnEnemyFirebase='..(iClosestFriendlyUnitToAnEnemyFirebase or 'nil')..'; iFirebaseThreatAdjust='..(iFirebaseThreatAdjust or 'nil')) end
                        if not(bAttackWithEverything) and (not(EntityCategoryContains(M28UnitInfo.refCategoryPD, oNearestEnemyToFriendlyBase.UnitId)) or not(M28Conditions.IsCivilianBrain(oNearestEnemyToFriendlyBase:GetAIBrain()))) then
                            if M28Utilities.IsTableEmpty(toEnemyACUsNearZone) == false then bAttackWithLowerThreatRatio = false
                            elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefThreatEnemyDFStructures]) == false then bAttackWithLowerThreatRatio = false
                            end
                            --HaveEnoughThreatToAttack(iPlateau, iLandZone, tLZData, tLZTeamData, iOurCombatThreat,             iEnemyCombatThreat, iFirebaseThreatAdjust,                                                                       bHaveSignificantCombatCloserToFirebase, iTeam, iOptionalOverrideDefaultThreatRatioWanted, bOptionalUseSlightlyLowerThreatRatio)
                            if M28Conditions.HaveEnoughThreatToAttack(iPlateau, iLandZone, tLZData, tLZTeamData, iOurDFAndT1ArtiCombatThreat, iEnemyCombatThreat, math.max(iFirebaseThreatAdjust, (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0)), bHaveSignificantCombatCloserToFirebase, iTeam, nil,                                        bAttackWithLowerThreatRatio) then
                                --Extra check if have a firebase - only want to include friendly units that are near our closest unit to enemy firebase
                                if iClosestFriendlyUnitToAnEnemyFirebase <= 170 and iFirebaseThreatAdjust > 0 then
                                    --Get new combat threat based on allied mobile DF and indirect fire units around this unit
                                    local iSearchRange = math.max(40, math.min(140, 15 + table.getn(tOurDFAndT1ArtiUnits)))

                                    local iNearbyCombatThreat = math.min(iOurDFAndT1ArtiCombatThreat, M28UnitInfo.GetCombatThreatRating(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains][1]:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat, oClosestFriendlyUnitToAnEnemyFirebase:GetPosition(), iSearchRange, 'Ally'), false))
                                    if bDebugMessages == true then LOG(sFunctionRef..': Nearby combat threat='..iNearbyCombatThreat..'; iEnemyCombatThreat='..iEnemyCombatThreat) end
                                    if iNearbyCombatThreat > iEnemyCombatThreat * 1.5 or (iNearbyCombatThreat > iEnemyCombatThreat * 1.15 and iNearbyCombatThreat >= 20000) or (iNearbyCombatThreat > iEnemyCombatThreat and bHaveSignificantCombatCloserToFirebase) then
                                        bAttackWithEverything = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': Nearby combat threat is greater than enemy, so will attack with everything') end
                                    else
                                        bAttackWithEverything = false
                                        bConsolidateAtMidpoint = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to consolidate at midpoint instead of attacking with everything') end
                                    end
                                else
                                    bAttackWithEverything = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have enough threat to attack, and non earby enemy firebase, so will attack with everything') end
                                end
                                --Extra check if enemy has ACU, to avoid feeding it mass if we only have a slight combat advantage
                                if bAttackWithEverything and not(bConsiderAttackingACU) and M28Utilities.IsTableEmpty(toEnemyACUsNearZone) == false and iOurDFAndT1ArtiCombatThreat < math.max(iEnemyCombatThreat * 2, iEnemyCombatThreat + 600) and iFirebaseThreatAdjust == 0 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': enemy has ACU so want to be more cautious, is the closest enemy an ACU='..tostring(EntityCategoryContains(categories.COMMAND, oNearestEnemyToFriendlyBase.UnitId))) end
                                    if EntityCategoryContains(categories.COMMAND, oNearestEnemyToFriendlyBase.UnitId) then
                                        if M28UnitInfo.GetUnitHealthPercent(oNearestEnemyToFriendlyBase) >= 0.3 and ((oNearestEnemyToFriendlyBase[M28ACU.refiUpgradeCount] or 0) >= 2 or M28UnitInfo.GetUnitHealthPercent(oNearestEnemyToFriendlyBase) >= 0.5) then
                                            bAttackWithEverything = false
                                        end
                                    else
                                        --Exception - enemy ACU isnt the closest enemy unit, and is far enough away from the closest enemy unit that we can potentially attack to do some damage to it
                                        local iDistThresholdForACU = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) - 30
                                        local iDistToNearestEnemyThreshold = 30
                                        if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oNearestEnemyToFriendlyBase.UnitId) and (oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0) <= 10 then
                                            iDistThresholdForACU = iDistThresholdForACU + 7
                                            iDistToNearestEnemyThreshold = iDistToNearestEnemyThreshold - 7
                                        end
                                        for iACU, oACU in toEnemyACUsNearZone do
                                            if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) <= iDistThresholdForACU or M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition()) <= iDistToNearestEnemyThreshold and (M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.3 and ((oACU[M28ACU.refiUpgradeCount] or 0) >= 2 or M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.5)) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy ACU is too close to nearest enemy unit so wont have our units attack') end
                                                bAttackWithEverything = false
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                            --NOTE: We have "suicide into mex logic" later on; however htis also does a similar thing but is intended to mean units like microbots will be more aggressive early on to target engis and mexes
                            if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to try attacking exposed enemy unit, iOurDFAndT1ArtiCombatThreat='..iOurDFAndT1ArtiCombatThreat..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; iFirebaseThreatAdjust='..iFirebaseThreatAdjust..'; oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..'; is table of shields covering empty='..tostring(M28Utilities.IsTableEmpty(oNearestEnemyToFriendlyBase[M28Building.reftoShieldsProvidingCoverage]))) end
                            if not(bAttackWithEverything) and iOurDFAndT1ArtiCombatThreat > 0 and iOurDFAndT1ArtiCombatThreat <= 3500 and iEnemyCombatThreat + (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0) <= 5000 and (iFirebaseThreatAdjust == 0 or (EntityCategoryContains(M28UnitInfo.refCategoryStructure, oNearestEnemyToFriendlyBase.UnitId) and M28Utilities.IsTableEmpty(oNearestEnemyToFriendlyBase[M28Building.reftoShieldsProvidingCoverage])) and (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0) == 0 and oNearestEnemyToFriendlyBase and EntityCategoryContains(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryStructure - categories.DIRECTFIRE, oNearestEnemyToFriendlyBase.UnitId)) then
                                local iDistToNearestEnemyDFUnitLessRange = 10000
                                local oClosestDFEnemy
                                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                                    local iCurDistLessRange
                                    for iEnemy, oEnemy in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                                        iCurDistLessRange = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), tLZData[M28Map.subrefMidpoint]) - (oEnemy[M28UnitInfo.refiDFRange] or 0)
                                        if iCurDistLessRange < iDistToNearestEnemyDFUnitLessRange then
                                            iDistToNearestEnemyDFUnitLessRange = iCurDistLessRange
                                            oClosestDFEnemy = oEnemy
                                        end
                                    end
                                end
                                local iDistToNearestEnemy = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oNearestEnemyToFriendlyBase:GetPosition())
                                if bDebugMessages == true then LOG(sFunctionRef..': iDistToNearestEnemy='..iDistToNearestEnemy..'; iDistToNearestEnemyDFUnitLessRange='..iDistToNearestEnemyDFUnitLessRange..'; oClosestDFEnemy='..(oClosestDFEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestDFEnemy) or 'nil')) end
                                if iDistToNearestEnemyDFUnitLessRange > iDistToNearestEnemy + 25 then
                                    --Good chance we can attack the enemy engi/mex before we die
                                    bAttackWithEverything = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and attack nearest enemy unit') end
                                    --LABs - if closest enemy is at a significantly different angle, then we can potentially still raid (will only c onsider if we have low combat threat for cpu performance reasons and also to avoid a big mass donation)
                                elseif iDistToNearestEnemyDFUnitLessRange >= 50 and iOurDFAndT1ArtiCombatThreat <= 200 and oClosestDFEnemy then
                                    --Get the closet friendly unit to the midpoint
                                    local iClosestFriendlyDist = 1000
                                    local oClosestFriendlyCombat
                                    for iUnit, oUnit in tAvailableCombatUnits do
                                        if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or ((oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0 and EntityCategoryContains(categories.TECH1, oUnit.UnitId)) then
                                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                            if iCurDist < iClosestFriendlyDist then
                                                iClosestFriendlyDist = iCurDist
                                                oClosestFriendlyCombat = oUnit
                                            end
                                        end
                                    end
                                    local iAngleFromFriendlyToDFEnemy = M28Utilities.GetAngleFromAToB(oClosestFriendlyCombat:GetPosition(), oClosestDFEnemy:GetPosition())
                                    local iAngleFromFriendlyToNearestEnemy = M28Utilities.GetAngleFromAToB(oClosestFriendlyCombat:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition())
                                    local iAngleDif = M28Utilities.GetAngleDifference(iAngleFromFriendlyToDFEnemy, iAngleFromFriendlyToNearestEnemy)
                                    if bDebugMessages == true then LOG(sFunctionRef..':iAngleFromFriendlyToDFEnemy='..iAngleFromFriendlyToDFEnemy..'; iAngleFromFriendlyToNearestEnemy='..iAngleFromFriendlyToNearestEnemy..'; Dist from friendly unit to closest df enemy='..M28Utilities.GetDistanceBetweenPositions(oClosestFriendlyCombat:GetPosition(), oClosestDFEnemy:GetPosition())..'; Dist from closest DF enemy to nearest enemy='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oClosestDFEnemy:GetPosition())..'; oClosestDFEnemy DF range='..oClosestDFEnemy[M28UnitInfo.refiDFRange]..'; oClosestFriendlyCombat='..oClosestFriendlyCombat.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestFriendlyCombat)..'; Dist from DF enemy to nearest enemy, less DF range='..M28Utilities.GetDistanceBetweenPositions(oClosestDFEnemy:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition())) end
                                    if M28Utilities.GetDistanceBetweenPositions(oClosestDFEnemy:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition()) - oClosestDFEnemy[M28UnitInfo.refiDFRange] + oClosestDFEnemy[M28UnitInfo.refiDFRange] >= 20 and M28Utilities.GetDistanceBetweenPositions(oClosestFriendlyCombat:GetPosition(), oClosestDFEnemy:GetPosition()) - oClosestDFEnemy[M28UnitInfo.refiDFRange] >= 10 then
                                        if iAngleDif >= 70 or iAngleDif <= 30 then --if angle dif <=20 then enemy DF unit is likely behind the nearest enemy unit (so we are ok to attack); if angle is >=45 then hopefully it is at too far of an angle to be able to easily assist if we advance?
                                            if bDebugMessages == true then LOG(sFunctionRef..': Closest DF seems too far out of position to help so will attack') end
                                            bAttackWithEverything = true
                                        end
                                    end
                                end
                            end
                        end

                        --Enemy in a nearby zone - include that zone threat when deciding whether to attack
                        if bAttackWithEverything and not(bSuicideIntoFatboyOrACU) then
                            if oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] and not(oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) and oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] == iPlateau then
                                if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy is in a different zone but the same plateau, so will check threat of that zone and revert the attack with everything flag if it is too much, iEnemyCombatThreat before update='..iEnemyCombatThreat) end
                                local tNearestEnemyLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]]
                                local tNearestEnemyLZTeamData = tNearestEnemyLZData[M28Map.subrefLZTeamData][iTeam]
                                iEnemyCombatThreat = math.max(iEnemyCombatThreat, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] + tNearestEnemyLZTeamData[M28Map.subrefTThreatEnemyCombatTotal])
                                if bDebugMessages == true then LOG(sFunctionRef..': iEnemyCombatThreat after update='..iEnemyCombatThreat..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; iFirebaseThreatAdjust='..iFirebaseThreatAdjust..'; threat of tSkirmisherDFEnemies='..M28UnitInfo.GetCombatThreatRating(tSkirmisherDFEnemies, true, false)..'; Mass value of skirmisher enemies='..M28UnitInfo.GetMassCostOfUnits(tSkirmisherDFEnemies, true)) end
                                if iEnemyCombatThreat * 1.4 >= iAvailableCombatUnitThreat and (iFirebaseThreatAdjust == 0 or iEnemyCombatThreat >= iAvailableCombatUnitThreat) and not(bConsiderAttackingACU and oNearestEnemyToFriendlyBase.UnitId and EntityCategoryContains(categories.COMMAND, oNearestEnemyToFriendlyBase.UnitId) and M28UnitInfo.GetUnitHealthPercent(oNearestEnemyToFriendlyBase) <= 0.75) then
                                    bAttackWithEverything = false
                                    if bDebugMessages == true then LOG(sFunctionRef..': Changing flag back to false due to enemy unit in a dif zone that has a significant threat in it') end
                                end
                            end
                            --Extra check - if take threat of skirmisher enemies, is it higher than our available combat threat? (but ignore if we are attacking ACU)
                            if bAttackWithEverything and not(bConsiderAttackingACU and oNearestEnemyToFriendlyBase.UnitId and EntityCategoryContains(categories.COMMAND, oNearestEnemyToFriendlyBase.UnitId) and M28UnitInfo.GetUnitHealthPercent(oNearestEnemyToFriendlyBase) <= 0.75) then
                                local iEnemyThreatBasedOnSkirmisherEnemies = M28UnitInfo.GetCombatThreatRating(tSkirmisherDFEnemies, true, false)
                                if iEnemyThreatBasedOnSkirmisherEnemies * 1.5 > iAvailableCombatUnitThreat then
                                    --Do a detailed check based on skirmisher enemies that are close to being in range of the closest enemy unit
                                    local iMassOfNearbySkirmisherEnemies = 0
                                    for iEnemy, oEnemy in tSkirmisherDFEnemies do
                                        if not(oEnemy.Dead) and M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition()) - (oEnemy[M28UnitInfo.refiCombatRange] or 0) <= 30 then
                                            iMassOfNearbySkirmisherEnemies = iMassOfNearbySkirmisherEnemies + (oEnemy[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oEnemy))
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Inconsistent enemy threat values so will play it safe and not attack if mass of enemy DF units near the nearest enemy is high enough, iMassOfNearbySkirmisherEnemies='..iMassOfNearbySkirmisherEnemies..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; iEnemyThreatBasedOnSkirmisherEnemies='..iEnemyThreatBasedOnSkirmisherEnemies) end
                                    if iMassOfNearbySkirmisherEnemies * 1.3 >= iAvailableCombatUnitThreat then
                                        bAttackWithEverything = false
                                        if bDebugMessages == true then LOG(sFunctionRef..': Wont attack with everything afterall') end
                                    elseif iMassOfNearbySkirmisherEnemies * 2 >= iAvailableCombatUnitThreat then
                                        --Calculate our threat more precisely, based on the short ranged directfire units we have
                                        local toTempSRDFUnits = {}
                                        for iUnit, oUnit in tAvailableCombatUnits do
                                            if (oUnit[M28UnitInfo.refiDFRange] or 0) < iEnemyBestDFRange or (oUnit[M28UnitInfo.refiDFRange] == iEnemyBestDFRange and not(bAttackWithSameRange)) then
                                                table.insert(toTempSRDFUnits, oUnit)
                                            end
                                        end
                                        local iOurDFThreatWithWorseRange = 0
                                        if M28Utilities.IsTableEmpty(toTempSRDFUnits) == false then
                                            iOurDFThreatWithWorseRange = M28UnitInfo.GetCombatThreatRating(toTempSRDFUnits, false)
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': iOurDFThreatWithWorseRange='..iOurDFThreatWithWorseRange..'; iMassOfNearbySkirmisherEnemies='..iMassOfNearbySkirmisherEnemies) end
                                        if iMassOfNearbySkirmisherEnemies * 1.2 > iOurDFThreatWithWorseRange then
                                            bAttackWithEverything = false
                                            if bDebugMessages == true then LOG(sFunctionRef..': Wont attack with everything as our units that outrange enemy arent strong enough yet') end
                                        elseif iEnemyThreatBasedOnSkirmisherEnemies > iOurDFThreatWithWorseRange and iOurDFThreatWithWorseRange > 50 then
                                            --Check how much nearby DF threat we have - get oru closest SR unit to the nearest enemy unit, and then get units within 30 of that
                                            local oClosestSRFriendlyToEnemy
                                            local iClosestSRFriendlyDistLessRange = 10000
                                            local iCurDist
                                            for iUnit, oUnit in toTempSRDFUnits do
                                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0)
                                                if iCurDist < iClosestSRFriendlyDistLessRange then
                                                    iClosestSRFriendlyDistLessRange = iCurDist
                                                    oClosestSRFriendlyToEnemy = oUnit
                                                end
                                            end
                                            local toNearbySRDFUnits = {}
                                            for iUnit, oUnit in toTempSRDFUnits do
                                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestSRFriendlyToEnemy:GetPosition())
                                                if iCurDist < 30 then
                                                    table.insert(toNearbySRDFUnits, oUnit)
                                                end
                                            end
                                            local iThreatOfNearbyFriendlySR = M28UnitInfo.GetCombatThreatRating(toNearbySRDFUnits, false)
                                            if bDebugMessages == true then LOG(sFunctionRef..': iThreatOfNearbyFriendlySR='..iThreatOfNearbyFriendlySR..'; oClosestSRFriendlyToEnemy='..(oClosestSRFriendlyToEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestSRFriendlyToEnemy) or 'nil')..'; iClosestSRFriendlyDistLessRange='..iClosestSRFriendlyDistLessRange) end
                                            if iMassOfNearbySkirmisherEnemies * 1.2 > iThreatOfNearbyFriendlySR and (iClosestSRFriendlyDistLessRange >= 5 or iMassOfNearbySkirmisherEnemies > iThreatOfNearbyFriendlySR) then
                                                bAttackWithEverything = false
                                                if bDebugMessages == true then LOG(sFunctionRef..': Wont attack with everything as our shorter ranged units are spread out too much') end
                                            end
                                        end
                                    end
                                end
                            end
                        end


                        --Enemy close to our base, with a firebase, and we have experimental level threat that has a lifetime count of 1 - do a more detailed assessment
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to be aggressive with 1st experimental if relevant, iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase) or 'nil')..'; This zone mod dist='..tLZTeamData[M28Map.refiModDistancePercent] <= 0.25..'; Constructed exp count='..M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount]) end
                        if not(bAttackWithEverything) and iAvailableCombatUnitThreat >= 5000 and iEnemyCombatThreat <= 40000 and oNearestEnemyToFriendlyBase and tLZTeamData[M28Map.refiModDistancePercent] <= 0.25 and iAvailableCombatUnitThreat > iEnemyCombatThreat * 0.5 and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] <= 3 and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= 1 then
                            local toFriendlySRExperimentals = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryMegalith, tAvailableCombatUnits)
                            if bDebugMessages == true then LOG(sFunctionRef..': is table of SR exp empty='..tostring(M28Utilities.IsTableEmpty(toFriendlySRExperimentals))) end
                            if M28Utilities.IsTableEmpty(toFriendlySRExperimentals) == false then
                                --Do we have an EXP with LC = 1 (want to be more aggressive with the first exp)?
                                local oClosestSRExpToEnemy
                                local iClosestSRExpToEnemy = 1000
                                for iExp, oExp in toFriendlySRExperimentals do
                                    if M28UnitInfo.GetUnitLifetimeCount(oExp) == 1 and (oExp[M28UnitInfo.refiDFRange] or 0) <= 60 and ((oExp[M28UnitInfo.refiDFRange] or 0) > 0 or oExp[M28UnitInfo.refiCombatRange] <= 60) then
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oExp:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition())
                                        if iCurDist <= iClosestSRExpToEnemy then
                                            oClosestSRExpToEnemy = oExp
                                            iClosestSRExpToEnemy = iCurDist
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': oClosestSRExpToEnemy='..oClosestSRExpToEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestSRExpToEnemy)..'; iClosestSRExpToEnemy='..iClosestSRExpToEnemy..'; oClosestSRExpToEnemy[M28UnitInfo.refiDFRange]='..oClosestSRExpToEnemy[M28UnitInfo.refiDFRange]) end
                                if oClosestSRExpToEnemy and iClosestSRExpToEnemy - (oClosestSRExpToEnemy[M28UnitInfo.refiDFRange] or oClosestSRExpToEnemy[M28UnitInfo.refiCombatRange]) <= 40 then --we are within 40 of being in range of an enemy
                                    --Get precise threat calc - assume we get into range of the closest enemy, and then consider all DF enemies around the closest enemy who are within 10 of being in range of that position - do we expect to win the fight with this unit alone?
                                    local tInRangeOfEnemyPosition
                                    if iClosestSRExpToEnemy - oClosestSRExpToEnemy[M28UnitInfo.refiDFRange] <= 1 then
                                        tInRangeOfEnemyPosition = oClosestSRExpToEnemy:GetPosition()
                                    else
                                        local iAngleToEnemy = M28Utilities.GetAngleFromAToB(oClosestSRExpToEnemy:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition())
                                        tInRangeOfEnemyPosition = M28Utilities.MoveInDirection(oClosestSRExpToEnemy:GetPosition(), iAngleToEnemy, iClosestSRExpToEnemy - oClosestSRExpToEnemy[M28UnitInfo.refiDFRange], true, true, M28Map.bIsCampaignMap)
                                        if tInRangeOfEnemyPosition and not(NavUtils.GetLabel(M28Map.refPathingTypeLand, tInRangeOfEnemyPosition) == tLZData[M28Map.subrefLZIslandRef]) then tInRangeOfEnemyPosition= nil end
                                    end
                                    if tInRangeOfEnemyPosition then
                                        local tTargetPositionLZData, tTargetPositionLZTeamData = M28Map.GetLandOrWaterZoneData(tInRangeOfEnemyPosition, true, iTeam)
                                        if tTargetPositionLZTeamData then
                                            local tEnemyDFUnitsNearTarget = {}
                                            local tbEntityIDIncluded = {}
                                            if M28Utilities.IsTableEmpty(tTargetPositionLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                                                for iUnit, oUnit in tTargetPositionLZTeamData[M28Map.reftoNearestDFEnemies] do
                                                    if not(oUnit.Dead) and (oUnit[M28UnitInfo.refiDFRange] or 0) >= 10 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tInRangeOfEnemyPosition) - oUnit[M28UnitInfo.refiDFRange] <= 15 then --Within 15 of being in range
                                                        table.insert(tEnemyDFUnitsNearTarget, oUnit)
                                                        tbEntityIDIncluded[oUnit.EntityId] = true
                                                    end
                                                end
                                            end
                                            if M28Utilities.IsTableEmpty(tTargetPositionLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                                for _, iAdjLZ in tTargetPositionLZData[M28Map.subrefLZAdjacentLandZones] do
                                                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                                                        for iUnit, oUnit in tAdjLZTeamData[M28Map.reftoNearestDFEnemies] do
                                                            if not(oUnit.Dead) and (oUnit[M28UnitInfo.refiDFRange] or 0) >= 10 and not(tbEntityIDIncluded[oUnit.EntityId]) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tInRangeOfEnemyPosition) - oUnit[M28UnitInfo.refiDFRange] <= 10 then --Within 10 of being in range
                                                                table.insert(tEnemyDFUnitsNearTarget, oUnit)
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                            local iEnemyThreatWithinRange = M28UnitInfo.GetCombatThreatRating(tEnemyDFUnitsNearTarget, true, false)
                                            local iOurExpThreat = M28UnitInfo.GetCombatThreatRating({oClosestSRExpToEnemy}, false, false)
                                            if bDebugMessages == true then LOG(sFunctionRef..': oClosestSRExpToEnemy='..oClosestSRExpToEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestSRExpToEnemy)..'; iEnemyThreatWithinRange='..iEnemyThreatWithinRange..'; iOurExpThreat='..iOurExpThreat..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; Mod dist of this zone='..tLZTeamData[M28Map.refiModDistancePercent]..'; Mod dist of target zone='..tTargetPositionLZTeamData[M28Map.refiModDistancePercent]..'; iClosestSRExpToEnemy='..iClosestSRExpToEnemy..'; oClosestSRExpToEnemy[M28UnitInfo.refiDFRange]='..oClosestSRExpToEnemy[M28UnitInfo.refiDFRange]) end
                                            if (iOurExpThreat > iEnemyThreatWithinRange or iOurExpThreat + (iAvailableCombatUnitThreat - iOurExpThreat) * 0.4 > iEnemyThreatWithinRange * 1.1
                                                    --Monkeylord further exception as we might be able to close in distance on enemy without being seen; and similarly ythotha who deathball might damage enemy; but only consider if mod dist low enough that we are desparate
                                                    or (tTargetPositionLZTeamData[M28Map.refiModDistancePercent] <= 0.2 and EntityCategoryContains(M28UnitInfo.refCategoryMonkeylord + M28UnitInfo.refCategoryYthotha, oClosestSRExpToEnemy.UnitId) and iOurExpThreat > iEnemyThreatWithinRange * 0.8 and (iOurExpThreat > iEnemyThreatWithinRange * (0.8 + (0.95 - 0.8) * math.max(0, (iClosestSRExpToEnemy - oClosestSRExpToEnemy[M28UnitInfo.refiDFRange])) / 40))))
                                                    and (iEnemyThreatWithinRange <= 2000 or M28Utilities.IsTableEmpty(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategoryFatboy, tEnemyDFUnitsNearTarget))

                                            then
                                                if bDebugMessages == true then LOG(sFunctionRef..': will try attacking with everything afterall') end
                                                bAttackWithEverything = true
                                            end
                                        end
                                    end
                                end
                            end
                        end

                        --Include threat of friendly zones attacking the same target - if this is enough to change our decision on whether to attack, then
                        if bDebugMessages == true then LOG(sFunctionRef..': Decision before including other zones with same target='..tostring(bAttackWithEverything)..'; iLandZone='..iLandZone..'; oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam]=P'..oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1]..'Z'..oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]) end
                        if not(bAttackWithEverything) and oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] == iPlateau then
                            local iLikelyTargetZone = oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]
                            local tLikelyTargetLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLikelyTargetZone][M28Map.subrefLZTeamData][iTeam]
                            if bDebugMessages == true then LOG(sFunctionRef..': We are likely to be targeting nearest enemy in LZ='..(iLikelyTargetZone or 'nil')..'; is subreftiLandZonesTargetingThisWithOurDF empty='..tostring(M28Utilities.IsTableEmpty(tLikelyTargetLZTeamData[M28Map.subreftiLandZonesTargetingThisWithOurDF]))) end
                            if tLikelyTargetLZTeamData and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                local iAdjacentMobileDFThreat = 0
                                local tbAdjZoneUnitsInAvailableCombatUnits
                                if M28Utilities.IsTableEmpty(tLikelyTargetLZTeamData[M28Map.subreftiLandZonesTargetingThisWithOurDF]) == false then
                                    local tbZonesAdjacentToThis = {}
                                    for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                        tbZonesAdjacentToThis[iAdjLZ] = true
                                    end
                                    local bIncludeCurZoneDF = false
                                    for iOtherLZ, iAttackingType in tLikelyTargetLZTeamData[M28Map.subreftiLandZonesTargetingThisWithOurDF] do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iOtherLZ='..iOtherLZ..'; tbZonesAdjacentToThis[iOtherLZ]='..tostring(tbZonesAdjacentToThis[iOtherLZ] or false)..'; iLikelyTargetZone='..iLikelyTargetZone) end
                                        if tbZonesAdjacentToThis[iOtherLZ] and not(iLikelyTargetZone == iOtherLZ) then
                                            local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam]
                                            if bDebugMessages == true then LOG(sFunctionRef..': subrefLZThreatAllyMobileDFTotal for otherLZ='..(tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 'nil')..'; OtherLZ subrefLZTValue='..(tAdjLZTeamData[M28Map.subrefLZTValue] or 'nil')..'; ThisLandZone subrefLZTValue='..(tLZTeamData[M28Map.subrefLZTValue] or 'nil')) end
                                            if tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] > 0 then
                                                --Include this zone unless we think we are giving orders to its units in availablecombatunits
                                                bIncludeCurZoneDF = true
                                                if tAdjLZTeamData[M28Map.subrefLZTValue] < tLZTeamData[M28Map.subrefLZTValue] then
                                                    --Higher risk we may be giving orders to units in the adjacent zone
                                                    if not(tbAdjZoneUnitsInAvailableCombatUnits) then
                                                        tbAdjZoneUnitsInAvailableCombatUnits = {}
                                                        for iUnit, oUnit in tAvailableCombatUnits do
                                                            if oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone and not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then tbAdjZoneUnitsInAvailableCombatUnits[oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]] = true end
                                                        end
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': tbAdjZoneUnitsInAvailableCombatUnits='..repru(tbAdjZoneUnitsInAvailableCombatUnits)) end
                                                    if tbAdjZoneUnitsInAvailableCombatUnits[iOtherLZ] then bIncludeCurZoneDF = false end
                                                end
                                                if bIncludeCurZoneDF then

                                                    if iAttackingType == M28Map.subrefiLZTMovingToOtherZone then
                                                        --We might have units that are far away, so only include if they are relatively close to our available units, and arent skirmishers
                                                        local toUnitsToInclude = {}
                                                        local toPotentialUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryMobileDFLand - M28UnitInfo.refCategorySkirmisher, tAdjLZTeamData[M28Map.subrefLZTAlliedCombatUnits])
                                                        if M28Utilities.IsTableEmpty(toPotentialUnits) == false then
                                                            local iClosestFriendlyToOtherZoneDist = 10000
                                                            local oClosestFriendlyToOtherZone
                                                            local tOtherZoneMidpoint = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefMidpoint]
                                                            for iUnit, oUnit in tAvailableCombatUnits do
                                                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOtherZoneMidpoint)
                                                                if iCurDist < iClosestFriendlyToOtherZoneDist then
                                                                    iClosestFriendlyToOtherZoneDist = iCurDist
                                                                    oClosestFriendlyToOtherZone = oUnit
                                                                end
                                                            end
                                                            if oClosestFriendlyToOtherZone then
                                                                for iUnit, oUnit in toPotentialUnits do
                                                                    if not(oUnit.Dead) then
                                                                        --Are we within 50 of being in range? then include
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Dist between units='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFriendlyToOtherZone:GetPosition())..'; CombatRange='..oUnit[M28UnitInfo.refiCombatRange]..'; Dist until in range='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFriendlyToOtherZone:GetPosition()) - oUnit[M28UnitInfo.refiCombatRange]) end
                                                                        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFriendlyToOtherZone:GetPosition()) - oUnit[M28UnitInfo.refiCombatRange] <= 30 then
                                                                            table.insert(toUnitsToInclude, oUnit)
                                                                        end
                                                                    end
                                                                end
                                                                if M28Utilities.IsTableEmpty(toUnitsToInclude) == false then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Combat threat of units that are including='..M28UnitInfo.GetCombatThreatRating(toUnitsToInclude, false)) end
                                                                    iAdjacentMobileDFThreat = iAdjacentMobileDFThreat + M28UnitInfo.GetCombatThreatRating(toUnitsToInclude, false)
                                                                end
                                                            end
                                                        end
                                                    else
                                                        iAdjacentMobileDFThreat = iAdjacentMobileDFThreat + (tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0)
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Including threat of friendly DF units in iOtherLZ='..iOtherLZ..', iAdjacentMobileDFThreat after this='..iAdjacentMobileDFThreat) end
                                                end
                                            end
                                        end
                                    end
                                end
                                --Include any units already in the target zone as well
                                if tLikelyTargetLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] > 0 and not(iLikelyTargetZone == iLandZone) then
                                    if not(tbAdjZoneUnitsInAvailableCombatUnits) then
                                        tbAdjZoneUnitsInAvailableCombatUnits = {}
                                        for iUnit, oUnit in tAvailableCombatUnits do
                                            if oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone and not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then tbAdjZoneUnitsInAvailableCombatUnits[oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]] = true end
                                        end
                                    end
                                    if not(tbAdjZoneUnitsInAvailableCombatUnits[iLikelyTargetZone]) then
                                        iAdjacentMobileDFThreat = iAdjacentMobileDFThreat + (tLikelyTargetLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Including threat of friendly DF units in iLikelyTargetZone, iAdjacentMobileDFThreat after this='..iAdjacentMobileDFThreat) end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': iAdjacentMobileDFThreat after including adj zones with the same targetLZ as us='..iAdjacentMobileDFThreat) end
                                if iAdjacentMobileDFThreat > 40 then
                                    --M28Conditions.HaveEnoughThreatToAttack(iPlateau, iLandZone, tLZData, tLZTeamData, iOurCombatThreat,                                     iEnemyCombatThreat, iFirebaseThreatAdjust,                                                                              bHaveSignificantCombatCloserToFirebase, iTeam, iOptionalOverrideDefaultThreatRatioWanted, bOptionalUseSlightlyLowerThreatRatio)
                                    bAttackWithEverything = M28Conditions.HaveEnoughThreatToAttack(iPlateau, iLandZone, tLZData, tLZTeamData, iOurDFAndT1ArtiCombatThreat + iAdjacentMobileDFThreat, iEnemyCombatThreat, math.max(iFirebaseThreatAdjust, (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0)), bHaveSignificantCombatCloserToFirebase, iTeam,    nil,                                        bAttackWithLowerThreatRatio)
                                    if bDebugMessages == true then LOG(sFunctionRef..': bAttackWithEverything after including adjacent zones iwth same target='..tostring(bAttackWithEverything or false)) end
                                end
                            end
                        end

                        if bDebugMessages == true then LOG(sFunctionRef..': bAttackWithEverything after initial assessment='..tostring(bAttackWithEverything)..'; tLZTeamData[M28Map.refbIslandBeachhead]='..tostring(tLZTeamData[M28Map.refbIslandBeachhead] or false)) end
                        if not(bAttackWithEverything) and tLZTeamData[M28Map.refbIslandBeachhead] then
                            --May have units nearby underwater that want to include
                            local iSearchRange = math.max(40, math.min(140, 15 + table.getn(tOurDFAndT1ArtiUnits)))

                            local oClosestFriendlyToEnemy
                            local iCurDist
                            local iClosestDist = 100000
                            for iUnit, oUnit in tAvailableCombatUnits do
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                if iCurDist < iClosestDist then
                                    iClosestDist = iCurDist
                                    oClosestFriendlyToEnemy = oUnit
                                end
                            end
                            local iNearbyCombatThreat = math.max(iOurDFAndT1ArtiCombatThreat, M28UnitInfo.GetCombatThreatRating(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains][1]:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat, oClosestFriendlyToEnemy:GetPosition(), iSearchRange, 'Ally'), false))
                            --Are there significant units left out of the normal threat calculation e.g. due to an amphibious assault with friendly units nearby in the water? If so then consider attacking
                            if iOurDFAndT1ArtiCombatThreat < iNearbyCombatThreat * 1.25 then
                                if iNearbyCombatThreat > iEnemyCombatThreat then
                                    bAttackWithEverything = true
                                elseif iNearbyCombatThreat > 1.2 * math.max(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 0.5, tLZTeamData[M28Map.subrefThreatEnemyDFStructures] + tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]) and tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] then
                                    bAttackWithEverything = true
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Island beachhead Nearby combat threat='..iNearbyCombatThreat..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; tLZTeamData[M28Map.subrefThreatEnemyDFStructures]='..tLZTeamData[M28Map.subrefThreatEnemyDFStructures]..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]..'; bAttackWithEverythign='..tostring(bAttackWithEverything)..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])) end
                        end
                        --Dont have a massive army - consider staying if enemy has mexes in this zone and we have more threat than enemy threat that is just in this zone
                        if not(bAttackWithEverything) and iOurDFAndT1ArtiCombatThreat < 10000 and iOurDFAndT1ArtiCombatThreat > (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) and tLZData[M28Map.subrefLZOrWZMexCount] > 0 and tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] > 10 then
                            local bCouldDoSomeDamage = false
                            local tEnemyBuildings = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryPD - M28UnitInfo.refCategoryStructureAA - M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subrefTEnemyUnits])
                            if M28Utilities.IsTableEmpty(tEnemyBuildings) == false then
                                for iUnit, oUnit in tEnemyBuildings do
                                    if oUnit:GetFractionComplete() == 1 then
                                        bCouldDoSomeDamage = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will consider being more aggressive as enemy has buildings we could try and kill even if overall we might be outnumbered soon') end
                                        break
                                    end
                                end
                            end
                            if bCouldDoSomeDamage then
                                --Would our retreat path take us somewhere dangerous? in which case stay and attack
                                local tAdjacentZoneRally = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 1, false)
                                if M28Utilities.IsTableEmpty(tAdjacentZoneRally) then
                                    bAttackWithEverything = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Nowhere to retreat so will attack to try and do some damage') end
                                else
                                    local tAdjacentRallyData, tAdjacentRallyTeamData = M28Map.GetLandOrWaterZoneData(tAdjacentZoneRally, true, iTeam)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy combat in adj rally point zone='..tAdjacentRallyTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; iOurDFAndT1ArtiCombatThreat='..iOurDFAndT1ArtiCombatThreat) end
                                    if tAdjacentRallyTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 0.4 * iOurDFAndT1ArtiCombatThreat then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Is dangerous to retreat so might as well attack and try and do some damage') end
                                        bAttackWithEverything = true
                                    end
                                end
                                if bAttackWithEverything then bOnlyAttackWithUnitsInThisZone = true end --This is needed to e.g. stop fatboy from suiciding into enemy mexes despite facing a major enemy threat in an adjacent zone (happened in v118)
                            end
                        end

                        if iOurDFAndT1ArtiCombatThreat < iEnemyCombatThreat * 1.4 or not(bAttackWithEverything) or (iEnemyCombatThreat >= 5000 and iOurDFAndT1ArtiCombatThreat < 7000 + math.max(0, (iEnemyCombatThreat - 15000)) * 3.5 + math.min(10000, iEnemyCombatThreat - 5000) * 2.5) then
                            bWantReinforcements = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Want reinforcements as iOurDFAndT1ArtiCombatThreat='..iOurDFAndT1ArtiCombatThreat..'; iEnemyCombatThreat='..iEnemyCombatThreat) end
                        end

                        --Attack with everythign if ACU is in trouble and in combat
                        if bHaveACUInTroubleAndRecentlyInCombat then
                            bAttackWithEverything = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Will attack with everything as ACU is in trouble') end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': We dont outrange enemy, considering if we have much more threat than them, iEnemyCombatThreat='..iEnemyCombatThreat..'; iOurDFAndT1ArtiCombatThreat='..iOurDFAndT1ArtiCombatThreat..'; bWantReinforcements='..tostring(bWantReinforcements)..'; bAttackWithEverything='..tostring(bAttackWithEverything)..'; iClosestFriendlyUnitToAnEnemyFirebase='..iClosestFriendlyUnitToAnEnemyFirebase..'; iFirebaseThreatAdjust='..iFirebaseThreatAdjust..'; bHaveACUInTroubleAndRecentlyInCombat='..tostring(bHaveACUInTroubleAndRecentlyInCombat or false)..'; tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat]='..tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat]..'; bAttackWithEverything='..tostring(bAttackWithEverything)) end
                        --Early game where enemy might outrange us slightly e.g. unupgraded ACU vs t1 tanks
                        if not(bAttackWithEverything) and iEnemyBestDFRange <= 22 and (tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0) == 0 and iOurDFAndT1ArtiCombatThreat > math.max(900, iEnemyCombatThreat * 1.2) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy still is relatively short range so press attack') end
                            bAttackWithEverything = true
                        end

                        --More precise check in earlier-mid stages of game to avoid retreating from most of map due e.g. to enemy ACU that is nearby, but not near enough to stop us attacking the nearest enemy
                        if not(bAttackWithEverything) and (M28Map.iMapSize <= 512 or (GetGameTimeSeconds() <= 1200 and not(M28Utilities.bCPUPerformanceMode))) and (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0) == 0 and iOurDFAndT1ArtiCombatThreat <= 5000 and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] == 0 and M28Utilities.IsTableEmpty(tSkirmisherDFEnemies) == false and oNearestEnemyToFriendlyBase and (oNearestEnemyToFriendlyBase[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oNearestEnemyToFriendlyBase)) < 0.5 * iOurDFAndT1ArtiCombatThreat then
                            --Get threat within 20 of being in range of the closest enemy unit
                            local toEnemiesNearNearestEnemy = {}
                            local iDistThreshold = 16 + math.max(0, math.min(14, iEnemyBestDFRange - 20))
                            local iCurCombatUnits = table.getn(tAvailableCombatUnits)
                            if iCurCombatUnits >= 10 then iDistThreshold = iDistThreshold + iCurCombatUnits / 10 end

                            for iUnit, oUnit in tSkirmisherDFEnemies do
                                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition()) - oUnit[M28UnitInfo.refiCombatRange] <= iDistThreshold then
                                    table.insert(toEnemiesNearNearestEnemy, oUnit)
                                end
                            end
                            local iThreatOfEnemiesNearestClosestEnemy = M28UnitInfo.GetCombatThreatRating(toEnemiesNearNearestEnemy, true)
                            if bDebugMessages == true then LOG(sFunctionRef..': iThreatOfEnemiesNearestClosestEnemy='..iThreatOfEnemiesNearestClosestEnemy..'; iOurDFAndT1ArtiCombatThreat='..iOurDFAndT1ArtiCombatThreat..'; iDistThreshold='..iDistThreshold) end
                            if iThreatOfEnemiesNearestClosestEnemy < 0.5 * iOurDFAndT1ArtiCombatThreat then
                                --Get our closest unit to the enemy, and get all friendly units within a similar distance to the nearest enemy
                                local oClosestFriendlyDFToEnemy
                                local iClosestToEnemyDist = 10000
                                local iCurDist
                                for iUnit, oUnit in tAvailableCombatUnits do
                                    if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition()) - oUnit[M28UnitInfo.refiCombatRange]
                                        if iCurDist < iClosestToEnemyDist then
                                            iClosestToEnemyDist = iCurDist
                                            oClosestFriendlyDFToEnemy = oUnit
                                        end
                                    end
                                end
                                if oClosestFriendlyDFToEnemy then
                                    if iDistThreshold < 40 then iDistThreshold = math.min(40, iDistThreshold + 10) end --We arent including range for friendly units so icnrease the distance
                                    local toFriendlyUnitsNearOurClosestUnit = {}
                                    for iUnit, oUnit in tAvailableCombatUnits do
                                        if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then
                                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFriendlyDFToEnemy:GetPosition())
                                            if iCurDist < iDistThreshold then
                                                table.insert(toFriendlyUnitsNearOurClosestUnit, oUnit)
                                            end
                                        end
                                    end
                                    local iFriendlyDFThreatNearFriendlyUnit = M28UnitInfo.GetCombatThreatRating(toFriendlyUnitsNearOurClosestUnit, false)
                                    if bDebugMessages == true then LOG(sFunctionRef..': iFriendlyDFThreatNearFriendlyUnit='..iFriendlyDFThreatNearFriendlyUnit..'; iThreatOfEnemiesNearestClosestEnemy='..iThreatOfEnemiesNearestClosestEnemy) end
                                    if iFriendlyDFThreatNearFriendlyUnit * 0.5 > iThreatOfEnemiesNearestClosestEnemy then
                                        bAttackWithEverything = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': If we attack the nearest enemy units we should be able to overwhelm them despite enemy having stronger overall force nearby') end
                                    end
                                end
                            end
                        end
                    else
                        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                            bWantReinforcements = true
                            if bDebugMessages == true then LOG(sFunctionRef..': We have no friendly units in this LZ but enemy has units here or adjacent LZ so want reinforcements. iFriendlyBestMobileIndirectRange='..iFriendlyBestMobileIndirectRange..'; Is there a valid enemy structure to midpoint='..tostring(M28UnitInfo.IsUnitValid(oNearestEnemyStructureToMidpoint))) end
                        end
                        if iFriendlyBestMobileIndirectRange == 0 or not(oNearestEnemyStructureToMidpoint) then
                            bAttackWithEverything = false
                        end
                    end
                    local bSuicideUnitsNearAMex = false
                    local tNearbyMexes
                    if not(bAttackWithEverything) and oNearestEnemyToFriendlyBase then
                        if tLZTeamData[M28Map.subrefLZSValue] > 10 and (tLZTeamData[M28Map.subrefLZbCoreBase] or (tLZTeamData[M28Map.subrefLZCoreExpansion] and (tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or iOurDFAndT1ArtiCombatThreat > iEnemyCombatThreat * 0.9 or (tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][1] > math.max(1, tLZData[M28Map.subrefLZOrWZMexCount] or 0))))) then
                            --Is enemy almost in range of the midpoint for this zone such that we want to attack even though we will probably lose?
                            if M28Utilities.GetDistanceBetweenPositions(       tLZData[M28Map.subrefMidpoint], oNearestEnemyToFriendlyBase:GetPosition()) <= 15 + math.max((oNearestEnemyToFriendlyBase[M28UnitInfo.refiIndirectRange] or 0), (oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy unit is almost in range of our midpoint and this is a high value location to defend') end
                                bAttackWithEverything = true
                                --CloseToEnemyUnit(tStartPosition,                  tUnitsToCheck,                              iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure)
                            elseif M28Conditions.CloseToEnemyUnit(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftoNearestDFEnemies],    10,             iTeam, true                  , nil,                  nil,                                nil,                                       nil) then
                                bAttackWithEverything = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy DF units are almost in range of our midpoint and this is a high value location to defend') end
                            end
                        end
                        --Suicide into mex logic
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to suicide mex, iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; EnemyMobileDFTotal='..(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)..'; Ally mobile DF total='..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]..'; Ally mobile IF total='..tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]..'; Enemy best structure DF range='..(tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0)..'; Mex count='..tLZData[M28Map.subrefLZOrWZMexCount]..'; Enemy structure mass='..(tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0)..'; Is table of enemy mexes empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tLZTeamData[M28Map.subrefTEnemyUnits])))) end
                        if not(bAttackWithEverything) then
                            if tLZData[M28Map.subrefLZOrWZMexCount] > 0 and iAvailableCombatUnitThreat >= math.min(100, (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)) and (tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) > 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                                tNearbyMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tLZTeamData[M28Map.subrefTEnemyUnits])
                                if M28Utilities.IsTableEmpty(tNearbyMexes) == false then
                                    if (iAvailableCombatUnitThreat >= iEnemyCombatThreat or EntityCategoryContains(M28UnitInfo.refCategoryMex, oNearestEnemyToFriendlyBase.UnitId)) and (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) and tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] + tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] > (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) and (tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0) == 0 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try attacking with everything as we may be able to kill some mexes as weh ave more threat than enemy in this zone specifically') end
                                        bAttackWithEverything = true
                                    elseif (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0) <= 10000 then --dont want to consider suiciding where we have large armies or experimentals
                                        --Do we have units close enough to mexes that they could probably try and kill it even if enemy has a stronger force overall?
                                        bSuicideUnitsNearAMex = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': when retreating we will consider still attacking with units that are near a mex') end
                                    end
                                end
                            end
                        end
                        --Support attacking experimental
                        if not(bAttackWithEverything) then
                            if HaveAttackingExperimentalToSupport(tLZTeamData) then
                                bAttackWithEverything = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to support a friendly attacking experimental') end
                            end
                        end
                    end

                    --Adjustment of nearest enemy unit is in water - dont attack with everything
                    if bAttackWithEverything and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false and EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oNearestEnemyToFriendlyBase.UnitId) then
                        local iUnitSegmentX, iUnitSegmentZ = M28Map.GetPathingSegmentFromPosition(oNearestEnemyToFriendlyBase:GetPosition())
                        if M28Map.tWaterZoneBySegment[iUnitSegmentX][iUnitSegmentZ] then
                            --Nearest enemy is in a water zone, will reassess if we want to attack with everything - include enemy threat in that zone and adjacent water zones, but also factor in our threat

                            local tOurAvailableHoverAndAntiNavyUnits = EntityCategoryFilterDown(categories.HOVER + M28UnitInfo.refCategoryAntiNavy, tAvailableCombatUnits)
                            local iOurAvailableHoverAndAntiNavyCombatThreat = 0
                            if M28Utilities.IsTableEmpty(tOurAvailableHoverAndAntiNavyUnits) == false then
                                iOurAvailableHoverAndAntiNavyCombatThreat = M28UnitInfo.GetCombatThreatRating(tOurAvailableHoverAndAntiNavyUnits, false, false, false, false, true, false, false)
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy is in water zone, iOurAvailableHoverAndAntiNavyCombatThreat='..iOurAvailableHoverAndAntiNavyCombatThreat) end
                            if iOurAvailableHoverAndAntiNavyCombatThreat <= 10 then
                                bAttackWithEverything = false
                            else
                                local iWaterZone = M28Map.tWaterZoneBySegment[iUnitSegmentX][iUnitSegmentZ]
                                local tWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone]
                                local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                                local iAdjacentAlliedSubmersibleThreat = 0
                                local iAdjacentEnemyAntiNavyThreat = 0
                                local iAdjacentAlliedCombatThreat = iOurAvailableHoverAndAntiNavyCombatThreat
                                local iAdjacentEnemyCombatThreat = 0

                                if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                                    for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do --Include enemy threats in adjacent water zones, including 100% of the threat (vs WZ which normally includes only 20%)
                                        local tAdjWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                                        iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat = M28Navy.IncludeThreatOfAdjacentZone(iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, tWZData, tAdjWZTeamData, iAdjWZ, true, true, true, true, 1)
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': iAdjacentAlliedSubmersibleThreat='..iAdjacentAlliedSubmersibleThreat..'; iAdjacentEnemyAntiNavyThreat='..iAdjacentEnemyAntiNavyThreat..'; iAdjacentAlliedCombatThreat='..iAdjacentAlliedCombatThreat..'; iAdjacentEnemyCombatThreat='..iAdjacentEnemyCombatThreat..'; Do we want to attack using WZ logic='..tostring(M28Conditions.WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible], iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, true ))) end
                                if not(M28Conditions.WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible], iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, true )) then
                                    bAttackWithEverything = false
                                end
                            end
                        end
                    end

                    if bDebugMessages == true then LOG(sFunctionRef..': Dont outrange enemy, bAttackWithEverything='..tostring(bAttackWithEverything)..'; Is table of ACUs in the LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]))) end
                    local bUpdateNearestUnit = false
                    local bCheckIfNearestUnitVisible = bUpdateNearestUnit
                    if not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) >= 10 then
                        bCheckIfNearestUnitVisible = true
                    end

                    if bAttackWithEverything then
                        if not(oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) and oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] == iPlateau then
                            RecordDFLandZoneTarget(oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2], M28Map.subrefiLZTAttackingUnit)
                        end
                        --oTODO
                        local bMoveToStopPDConstruction = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Seeing if we have enough threat to try and stop PD being built, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; iAvailableCombatUnitThreat='..(iAvailableCombatUnitThreat or 'nil')) end
                        if M28Utilities.IsTableEmpty(tEnemyEngineers) == false and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 100 and (iAvailableCombatUnitThreat or 0) >= math.min(40, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 3) and GetEnemyCombatThreatInAdjacentZones() <= 500  then
                            local tEnemyPD = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD, tLZTeamData[M28Map.subrefTEnemyUnits])
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy PD empty='..tostring(M28Utilities.IsTableEmpty(tEnemyPD))) end
                            if M28Utilities.IsTableEmpty(tEnemyPD) == false then
                                bMoveToStopPDConstruction = true
                                for iPD, oPD in tEnemyPD do
                                    if oPD:GetFractionComplete() == 1 then
                                        bMoveToStopPDConstruction = false
                                        break
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': bMoveToStopPDConstruction before doublechecking threats='..tostring(bMoveToStopPDConstruction)) end
                                if bMoveToStopPDConstruction then
                                    --Check we have significantly more threat if excluding under-construction PD
                                    bMoveToStopPDConstruction = false
                                    local iPDThreat = M28UnitInfo.GetCombatThreatRating(tEnemyPD, true)
                                    if bDebugMessages == true then LOG(sFunctionRef..': iPDThreat='..iPDThreat) end
                                    if (iAvailableCombatUnitThreat or 0) > 2 * tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] - iPDThreat and (iAvailableCombatUnitThreat or 0) >= GetEnemyCombatThreatInAdjacentZones() then
                                        bMoveToStopPDConstruction = true
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Will attack with everything, oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oNearestEnemyToFriendlyBase))..'; oNearestEnemyToFriendlyBase position='..repru(oNearestEnemyToFriendlyBase:GetPosition())..'; Last known position='..repru(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; bMoveToStopPDConstruction='..tostring(bMoveToStopPDConstruction or false)) end
                        local bMoveTowardsEngineers = false
                        if M28Utilities.IsTableEmpty(tEnemyEngineers) == false and iAvailableCombatUnitThreat <= 400 and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 100 and (iAvailableCombatUnitThreat or 0) >= math.min(40, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 3) and GetEnemyCombatThreatInAdjacentZones() <= 500 then
                            bMoveTowardsEngineers = true
                        end
                        local bFiringAtNegligibleThreatInLRExperimentalRange = false
                        --local bCheckIfNearLocationToAvoid = not(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftiLocationsToAvoid]))

                        bGivenCombatUnitsOrders = true
                        local bMoveWithDFUnitsForM28Easy = nil
                        for iUnit, oUnit in tAvailableCombatUnits do
                            --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                            if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                            if bDebugMessages == true then LOG(sFunctionRef..': Attacking with everything, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Special micro active='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive] or false)..'; bOnlyAttackWithUnitsInThisZone='..tostring(bOnlyAttackWithUnitsInThisZone)) end
                            if bOnlyAttackWithUnitsInThisZone and oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone and oUnit[refiCurrentAssignmentPlateauAndLZ][1] == iPlateau then
                                if bDebugMessages == true then LOG(sFunctionRef..': Wont attack with this unit as were doing a suicide attack with units from the cur zone only') end
                                oUnit[refiCurrentAssignmentValue] = 0
                            elseif ProceedWithUnitOrder(oUnit) then
                                if oUnit[M28UnitInfo.refbEasyBrain] then
                                    if bMoveWithDFUnitsForM28Easy == nil then
                                        --Consider if we want to move to attack
                                        bMoveWithDFUnitsForM28Easy = false
                                        --Does enemy have signific indirect threat?
                                        local iEnemyIndirectInThisAndAdjacentZones = tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal]
                                        local iEnemyDFInThisAndAdjacentZones = tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] + tLZTeamData[M28Map.subrefThreatEnemyDFStructures]
                                        if M28Utilities.IsTableEmpty(tNearbyAdjacentEnemies) == false then
                                            local tEnemyIndirect = EntityCategoryFilterDown(M28UnitInfo.refCategoryIndirect, tNearbyAdjacentEnemies)
                                            if M28Utilities.IsTableEmpty(tEnemyIndirect) == false then
                                                iEnemyIndirectInThisAndAdjacentZones = iEnemyIndirectInThisAndAdjacentZones + M28UnitInfo.GetCombatThreatRating(tEnemyIndirect, true, false, true, false, false, false, false)
                                            end
                                            local tEnemyNonSkirmisherDirect = EntityCategoryFilterDown(categories.DIRECTFIRE - M28UnitInfo.refCategorySkirmisher, tNearbyAdjacentEnemies)
                                            iEnemyDFInThisAndAdjacentZones = iEnemyDFInThisAndAdjacentZones + M28UnitInfo.GetCombatThreatRating(tEnemyNonSkirmisherDirect, true, false, false)
                                        end
                                        if iOurDFAndT1ArtiCombatThreat > iEnemyDFInThisAndAdjacentZones and iEnemyIndirectInThisAndAdjacentZones > 0 and (iOurDFAndT1ArtiCombatThreat > 2.5 * iEnemyDFInThisAndAdjacentZones or (iEnemyIndirectInThisAndAdjacentZones > math.min(iEnemyDFInThisAndAdjacentZones * 0.2, iOurDFAndT1ArtiCombatThreat * 0.15))) then
                                            bMoveWithDFUnitsForM28Easy = true
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Finished considering whether to move instead of attackmove for normal M28Easy units in LZ='..iLandZone..', bMoveWithDFUnitsForM28Easy='..tostring(bMoveWithDFUnitsForM28Easy)..'; iOurDFAndT1ArtiCombatThreat='..iOurDFAndT1ArtiCombatThreat..'; iEnemyDFInThisAndAdjacentZones='..iEnemyDFInThisAndAdjacentZones) end
                                    end
                                    if (bMoveWithDFUnitsForM28Easy or (bMoveBlockedNotAttackMove and (oUnit[M28UnitInfo.refbLastShotBlocked] or M28UnitInfo.IsUnitUnderwater(oUnit)))) and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) and not(oUnit[M28UnitInfo.refbScoutCombatOverride]) then
                                        M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'BAesWE'..iLandZone)
                                    else
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'AWes'..iLandZone)
                                    end
                                else
                                    --if bCheckIfNearLocationToAvoid and EntityCategoryContains(categories.TECH1 + categories.TECH2 - categories.COMMAND, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbSpecialMicroActive]) and M28Conditions.HaveSentOrderToRunAwayFromLocationToAvoid(oUnit, tLZTeamData[M28Map.reftiLocationsToAvoid], 4) then
                                    --if bDebugMessages == true then LOG(sFunctionRef..': Unit will run away from location to avoid') end
                                    if oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                                        if oUnit[M28Air.refiTimeLastDropped] and oUnit[M28UnitInfo.refiIndirectRange] > 0 and GetGameTimeSeconds() - oUnit[M28Air.refiTimeLastDropped] <= 60 and oNearestEnemyStructureToMidpoint then
                                            SuicideUnitIntoEnemyStructure(oUnit)
                                        elseif oUnit[M28UnitInfo.refiIndirectRange] >= iEnemyBestDFRange then
                                            if bConsiderSpecialMMLLogic and EntityCategoryContains(M28UnitInfo.refCategoryMML, oUnit.UnitId) then table.insert(tMMLForSynchronisation, oUnit)
                                            else
                                                iIndirectDistanceInsideRangeThreshold = iIndirectRunFigureNormal
                                                if oUnit[M28UnitInfo.refbWeaponUnpacks] then iIndirectDistanceInsideRangeThreshold = iIndirectDistanceInsideRangeThreshold + iIndirectRunFigureDeployedAdjust end
                                                if bOnlyRetreatIndirectIfEnemyDFAlmostInRange then iIndirectDistanceInsideRangeThreshold = math.max(iIndirectDistanceInsideRangeThreshold + 10, ((oUnit[M28UnitInfo.refiIndirectRange] or 0) - iEnemyBestDFRange)) end

                                                local iDistThreshold
                                                if bOnlyRetreatIndirectIfEnemyDFAlmostInRange then
                                                    iDistThreshold = math.max(oUnit[M28UnitInfo.refiIndirectRange] - iIndirectDistanceInsideRangeThreshold, math.min(iEnemyBestDFRange + 5, oUnit[M28UnitInfo.refiIndirectRange] - 2))
                                                    if M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileShield]) then iDistThreshold = iDistThreshold - 5 end
                                                else
                                                    iDistThreshold = math.max(oUnit[M28UnitInfo.refiIndirectRange] - iIndirectDistanceInsideRangeThreshold, math.min(iEnemyBestDFRange + 10, oUnit[M28UnitInfo.refiIndirectRange] - 2))
                                                    if M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileShield]) then iDistThreshold = iDistThreshold - 5 end
                                                end

                                                if not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], iDistThreshold, iTeam, false)) then
                                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(15, iIndirectDistanceInsideRangeThreshold), false, 'I2KAMve'..iLandZone)
                                                    end
                                                else
                                                    --Retreat temporarily from enemy units
                                                    if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                                        oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                        M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AI2KRetr'..iLandZone)
                                                    else
                                                        oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'I2KRetr'..iLandZone)
                                                    end
                                                end
                                            end
                                        else
                                            --Treat the same as outranged DF units
                                            if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'I2AWE'..iLandZone)
                                            end
                                        end
                                    elseif EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) or oUnit[M28UnitInfo.refbScoutCombatOverride] then
                                        --Still retreat if are in range of enemy, even if we dont outraneg them, as may e.g. be other units that we do outrange
                                        if bEnemyHasNoDFUnits or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange] - math.max(2, oUnit[M28UnitInfo.refiDFRange] * 0.06), iTeam, false)) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Not in range of enemy yet, and we outrange enemy; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..oUnit[M28UnitInfo.refiDFRange]..'; oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..'; oNearestEnemyToFriendlyBase DF range='..(oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oNearestEnemyToFriendlyBase:GetPosition())..'; Enemy last recorded position='..repru(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; LZ midpoint position='..repru(tLZData[M28Map.subrefMidpoint])) end
                                            --Not in range yet, so attack move to the nearest enemy
                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SKAMve'..iLandZone)
                                        else
                                            --Enemy has DF units and they are already in our range so retreat
                                            if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ASKRetr'..iLandZone)
                                            else
                                                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'SKRetr'..iLandZone)
                                            end

                                        end
                                    else
                                        if bSuicideIntoFatboyOrACU and oClosestFatboyOrACUInIslandToSuicideInto then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will move to nearest fatboy='..oClosestFatboyOrACUInIslandToSuicideInto.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestFatboyOrACUInIslandToSuicideInto)..' with unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                            if (oUnit[M28UnitInfo.refiUnitMassCost] or GetUnitMassCost(oUnit)) >= 2000 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFatboyOrACUInIslandToSuicideInto:GetPosition()) <= 5 then
                                                M28Orders.IssueTrackedAggressiveMove(oUnit, oClosestFatboyOrACUInIslandToSuicideInto:GetPosition(), 6, false, 'SuicFBA'..iLandZone)
                                            else
                                                --Special micro to close in the gap
                                                if oUnit[M28UnitInfo.refiUnitMassCost] >= 10000 and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oClosestFatboyOrACUInIslandToSuicideInto.UnitId) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFatboyOrACUInIslandToSuicideInto:GetPosition()) > math.max(50, oUnit[M28UnitInfo.refiDFRange] or 5) and NavUtils.GetLabel(M28Map.refPathingTypeLand, oClosestFatboyOrACUInIslandToSuicideInto:GetPosition()) == tLZData[M28Map.subrefLZIslandRef] then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will run special micro to suicide experimental into fatboy unless micro is already active') end
                                                    if not(oUnit[M28UnitInfo.refbSpecialMicroActive]) then
                                                        ForkThread(M28Micro.SuicideExperimentalIntoFatboy, oUnit, oClosestFatboyOrACUInIslandToSuicideInto, iTeam, iPlateau)
                                                    end
                                                else
                                                    M28Orders.IssueTrackedMove(oUnit, oClosestFatboyOrACUInIslandToSuicideInto:GetPosition(), 6, false, 'SuicFBM'..iLandZone)
                                                end
                                            end
                                        elseif bMoveBlockedNotAttackMove and (oUnit[M28UnitInfo.refbLastShotBlocked] or M28UnitInfo.IsUnitUnderwater(oUnit)) and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbScoutCombatOverride])) then
                                            M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'BAWE'..iLandZone)
                                        else
                                            if bConsiderAttackingACU and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbScoutCombatOverride]) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), toEnemyACUsNearZone, 6 + oUnit[M28UnitInfo.refiDFRange], iTeam, false, nil, nil, nil, nil, nil) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will attack ACU with experimental') end
                                                GetUnitToAttackNearestACUOrOverrideUnit(oUnit)

                                                --Fatboy and megalith - want to be more cautious than normal units but less so than skirmishers
                                            elseif (oUnit[M28UnitInfo.refiDFRange] or 0) >= 64 and EntityCategoryContains(M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryMegalith, oUnit.UnitId) then
                                                --Attackmove unless enemy threat is minimal in this zone and dont have notable neemies in range using getunitsaroundpoint
                                                bFiringAtNegligibleThreatInLRExperimentalRange = false
                                                --Note - iVisibleLandCombatMassInFatboyRange uses getunitsaroundpoint so wont factor in memory; therefore want to use more accurate method to avoid fatboy charging towards a monkeylord that recently fired at us
                                                if (oUnit[M28UnitInfo.refiDFRange] or 0) >= 60 and EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and (iVisibleLandCombatMassInFatboyRange <= 3000 or not(EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId))) then
                                                    --Only consider if we have fired in the last 10s (otherwise it doesnt matter)
                                                    local iMassThresholdForNegligibleThreat = 1600
                                                    if oUnit[M28UnitInfo.refiLastWeaponEvent] and GetGameTimeSeconds() - oUnit[M28UnitInfo.refiLastWeaponEvent] <= 10 then
                                                        --Get accurate measure of enemy threat within our range
                                                        local iFriendlyExpFactor = 1 --If we have lots of fatboys nearby want to be much more aggressive
                                                        if not(tFriendlyNearbyExperimentals) then tFriendlyNearbyExperimentals = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental, tAvailableCombatUnits) end
                                                        if M28Utilities.IsTableEmpty(tFriendlyNearbyExperimentals) == false then
                                                            for iExp, oExp in tFriendlyNearbyExperimentals do
                                                                if not(oExp == oUnit) and M28UnitInfo.GetUnitHealthAndShieldPercent(oUnit) >= 0.75 then
                                                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oExp:GetPosition(), oUnit:GetPosition())
                                                                    if iCurDist <= 60 and (iCurDist <= 30 or oUnit[M28UnitInfo.refiDFRange] >= 90 or (iCurDist <= 45 and oUnit[M28UnitInfo.refiDFRange] >= 60)) then
                                                                        iFriendlyExpFactor = iFriendlyExpFactor + 1
                                                                    elseif iCurDist <= 70 then
                                                                        iFriendlyExpFactor = iFriendlyExpFactor + 0.4
                                                                    end
                                                                end
                                                            end
                                                        end
                                                        iMassThresholdForNegligibleThreat = iMassThresholdForNegligibleThreat * iFriendlyExpFactor
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Scen 2 Assing if enemy has negligible threat, iFriendlyExpFactor='..iFriendlyExpFactor..'; iMassThresholdForNegligibleThreat='..iMassThresholdForNegligibleThreat) end
                                                        --HaveSignificantEnemyThreatWithinRange(tLZData, tLZTeamData, iPlateau, iTeam, iSearchDistance, tStartPoint, iEnemyMassTotalThreshold, iOptionalSearchCategory, tOptionalAdditionalUnits, bOnlyIncludeDFUnits, bIncludeEnemyCombatRange)
                                                        bFiringAtNegligibleThreatInLRExperimentalRange = not(M28Conditions.HaveSignificantEnemyThreatWithinRange(tLZData, tLZTeamData, iPlateau, iTeam, oUnit[M28UnitInfo.refiDFRange] + 3, oUnit:GetPosition(), iMassThresholdForNegligibleThreat, M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryT2PlusPD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryNavalSurface - categories.TECH1 + categories.COMMAND, tUnitsNearFatboyInFurtherAwayZones))
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Scen2 bFiringAtNegligibleThreatInLRExperimentalRange='..tostring(bFiringAtNegligibleThreatInLRExperimentalRange)..'; Time since we last fired weapon='..(GetGameTimeSeconds() - oUnit[M28UnitInfo.refiLastWeaponEvent] or 0)..'; Have significant enemy threat within range='..tostring(M28Conditions.HaveSignificantEnemyThreatWithinRange(tLZData, tLZTeamData, iPlateau, iTeam, oUnit[M28UnitInfo.refiDFRange] + 3, oUnit:GetPosition(), iMassThresholdForNegligibleThreat, M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryT2PlusPD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryNavalSurface - categories.TECH1 + categories.COMMAND, tUnitsNearFatboyInFurtherAwayZones))) end
                                                end

                                                if bFiringAtNegligibleThreatInLRExperimentalRange or (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 1500 and GetEnemyCombatThreatInAdjacentZones() <= 6000 and M28Utilities.IsTableEmpty(oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryNavalSurface - categories.TECH1 - categories.TECH2 * categories.MOBILE * categories.LAND + categories.COMMAND, oUnit:GetPosition(), (oUnit[M28UnitInfo.refiDFRange] or 0), 'Enemy'))) then
                                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                        if (oUnit[M28UnitInfo.refiUnitMassCost] or GetUnitMassCost(oUnit)) >= 2000 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 7 then
                                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'FBMAWE'..iLandZone, false)
                                                        else
                                                            M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'FBMWE'..iLandZone, false)
                                                        end
                                                    end
                                                else
                                                    local oTargetToManuallyAttack, bMoveNotManualAttack = GetManualAttackTargetIfWantManualAttack(oUnit)
                                                    if oTargetToManuallyAttack and not(oTargetToManuallyAttack == oNearestEnemyToFriendlyBase) then
                                                        if bMoveNotManualAttack then M28Orders.IssueTrackedMove(oUnit, oTargetToManuallyAttack:GetPosition(), 2, false, 'Sc2LRManM', false)
                                                        else
                                                            DoManualAttack(oUnit, oTargetToManuallyAttack, 'Sc2LRManA')
                                                        end
                                                        --M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'Sc2LRManA', false)
                                                    else
                                                        if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'FBAWE'..iLandZone)
                                                        end
                                                    end
                                                end

                                                --Attackmove (unless we have far more threat in this zone)
                                            else
                                                local bUseNormalLogic = true
                                                if bMoveTowardsEngineers and oUnit[M28UnitInfo.refiDFRange] > 0 and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) and not(oUnit[M28UnitInfo.refbScoutCombatOverride]) then
                                                    local oNearestEngineerToUnit = M28Utilities.GetNearestUnit(tEnemyEngineers, oUnit:GetPosition())
                                                    if oNearestEngineerToUnit then
                                                        --Use normal logic if are almost in reclaim range of the engineer
                                                        local iDistToEngineer = M28Utilities.GetDistanceBetweenPositions(oNearestEngineerToUnit:GetPosition(), oUnit:GetPosition())
                                                        if bDebugMessages == true then LOG(sFunctionRef..': oNearestEngineerToUnit='..oNearestEngineerToUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEngineerToUnit)..'; iDistToEngineer='..iDistToEngineer..'; oUnit[M28UnitInfo.refiDFRange]='..oUnit[M28UnitInfo.refiDFRange] ..'; Eng build range='..(oNearestEngineerToUnit:GetBlueprint().Economy.MaxBuildDistance or 0)) end
                                                        if not(iDistToEngineer <= math.min(oUnit[M28UnitInfo.refiDFRange] - 3, (oNearestEngineerToUnit:GetBlueprint().Economy.MaxBuildDistance or 0) + 5)) then
                                                            --Move towards the engineer, or attack move if are close
                                                            bUseNormalLogic = false
                                                            if iDistToEngineer <= oUnit[M28UnitInfo.refiDFRange] - 2.5 then
                                                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEngineerToUnit:GetPosition(), math.min(4, oUnit[M28UnitInfo.refiDFRange] * 0.5), false, 'EnS2AMve'..iLandZone, false)
                                                            else
                                                                M28Orders.IssueTrackedMove(oUnit, oNearestEngineerToUnit:GetPosition(), math.min(4, oUnit[M28UnitInfo.refiDFRange]  * 0.5), false, 'EnS2Mve'..iLandZone, false)
                                                            end
                                                        end
                                                    end
                                                end
                                                if bUseNormalLogic then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to move or attack move to target (or in some cases do manuyal attack), iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; GetEnemyCombatThreatInAdjacentZones='..GetEnemyCombatThreatInAdjacentZones()..'; Enemy indirect threat='..(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 'nil')..'; oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase))..'; tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat]='..(tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 'nil')..'; Unit DF threat='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Can unit kite='..tostring(oUnit[M28UnitInfo.refbCanKite])..'; oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase) or 'nil')..'; Dist from this unit to last known position for the enemy='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), (oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or {0,0,0}))..'; Can we see this unit='..tostring(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), (oNearestEnemyToFriendlyBase or oUnit), false))) end
                                                    if  ((bMoveToStopPDConstruction and not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tEnemyEngineers, math.min(15, oUnit[M28UnitInfo.refiDFRange] - 4.5), iTeam, false, nil, nil))) or ((iAvailableCombatUnitThreat > 5000 or EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategoryFatboy, oUnit.UnitId)) and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) and not(oUnit[M28UnitInfo.refbScoutCombatOverride]))) and
                                                            ((iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 5) or
                                                                    --If lots of T1 arti want to keep moving with experimentals/other units or theyll get slaughtered; similarly if lots of low order spam and nothing significant in range then keep moving; also keep moving if we have more threat than all enemy nearby units
                                                                    (iAvailableCombatUnitThreat > math.max(800, GetEnemyCombatThreatInAdjacentZones() * 0.8) and tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] > 500 and (oUnit[M28UnitInfo.refiDFRange] or 0) > 0) or
                                                                    (iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() and EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and (iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 1.4 or tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] > 0 or EntityCategoryContains(M28UnitInfo.refCategoryIndirect + M28UnitInfo.refCategorySkirmisher, oNearestEnemyToFriendlyBase.UnitId) or M28Utilities.IsTableEmpty(oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryExperimentalLevel + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryStructure * categories.TECH3 - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryPD, oUnit:GetPosition(), (oUnit[M28UnitInfo.refiDFRange] or 20), 'Enemy')))) or
                                                                    --Below to try and e.g. stop megalith attack-moving when enemy has nearby ravagers
                                                                    (not(oUnit[M28UnitInfo.refbCanKite]) and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategoryFatboy, oUnit.UnitId)) and tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] > 500) then

                                                        --If have experimental unit and closest enemy unit to midpoint isn't a priority then consider alternative targets
                                                        local oTargetToManuallyAttack, bMoveNotManualAttack = GetManualAttackTargetIfWantManualAttack(oUnit, oNearestEnemyToFriendlyBase)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Will move instead of attack move subject to manual attack overrides, Do we have a target to manually attack? oTargetToManuallyAttack='..(oTargetToManuallyAttack.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTargetToManuallyAttack) or 'nil')..'; oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase) or 'nil')) end
                                                        if oTargetToManuallyAttack and not(oTargetToManuallyAttack == oNearestEnemyToFriendlyBase) then
                                                            if bMoveNotManualAttack then M28Orders.IssueTrackedMove(oUnit, oTargetToManuallyAttack:GetPosition(), 2, false, 'Sc3ManM', false)
                                                            else
                                                                DoManualAttack(oUnit, oTargetToManuallyAttack, 'Sc3ManA')
                                                            end
                                                            --M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'Sc3ManA', false)
                                                        else
                                                            if bDebugMessages == true then LOG(sFunctionRef..': If dealing with an experimental then want to find nearby high value enemy targets, Is this an experimental='..tostring(EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId))..'; oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..'; GetEnemyCombatThreatInAdjacentZones='..GetEnemyCombatThreatInAdjacentZones()) end
                                                            if EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and not(EntityCategoryContains(M28UnitInfo.refCategoryStructure * categories.TECH2 + categories.TECH3 + categories.COMMAND - M28UnitInfo.refCategoryEngineer, oNearestEnemyToFriendlyBase.UnitId)) and GetEnemyCombatThreatInAdjacentZones() >= 5000 then
                                                                --Want to try and find nearby enemy high value units
                                                                local iSearchHigherThreshold = 50
                                                                if (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0) > 1000 then iSearchHigherThreshold = 73 end
                                                                local tNearbyHighValueUnits = oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryExperimentalLevel + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryStructure * categories.TECH3 - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryPD, oUnit:GetPosition(), math.max((oUnit[M28UnitInfo.refiDFRange] or 20) + 15, iSearchHigherThreshold), 'Enemy')
                                                                if M28Utilities.IsTableEmpty(tNearbyHighValueUnits) == false then
                                                                    oTargetToManuallyAttack = M28Utilities.GetNearestUnit(tNearbyHighValueUnits, oUnit:GetPosition())
                                                                end
                                                                if oTargetToManuallyAttack and not(oTargetToManuallyAttack:IsUnitState('Attached')) and not(M28UnitInfo.IsUnitUnderwater(oTargetToManuallyAttack)) then
                                                                    if M28Utilities.GetDistanceBetweenPositions(oTargetToManuallyAttack:GetPosition(), oUnit:GetPosition()) <= (oUnit[M28UnitInfo.refiDFRange] or 0) + 1 then
                                                                        DoManualAttack(oUnit, oTargetToManuallyAttack, 'Sc4ManX')
                                                                        --M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'Sc4ManA', false)
                                                                    else
                                                                        M28Orders.IssueTrackedMove(oUnit, oTargetToManuallyAttack:GetPosition(), 10, 'MExpTO', false)
                                                                    end
                                                                else
                                                                    --Do same as below
                                                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                                        if (oUnit[M28UnitInfo.refiUnitMassCost] or GetUnitMassCost(oUnit)) >= 2000 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 7 then
                                                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'MExpAWE'..iLandZone, false)
                                                                        else
                                                                            M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'MExpWE'..iLandZone, false)
                                                                        end
                                                                    end
                                                                end
                                                            else
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Will just move to the nearest enemy, Dist from us to the last known position of nearest enemy='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), (oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or oNearestEnemyToFriendlyBase:GetPosition()))) end
                                                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                                    --Attack-move if almost at target and dealing with a high value unit (mainly to stop issue with e.g. ythotha just standing looking at target)
                                                                    if (oUnit[M28UnitInfo.refiUnitMassCost] or GetUnitMassCost(oUnit)) >= 2000 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 7 then
                                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'MWAE'..iLandZone, false)
                                                                    else
                                                                        M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'MWE'..iLandZone, false)
                                                                    end
                                                                end
                                                            end
                                                        end
                                                        --Consider moving to attack ACU or the nearest enemy if it outranges us, instead of attack-moving, if we aren't very close to it
                                                    elseif bConsiderAttackingACU and oUnit[M28UnitInfo.refiDFRange] and oUnit[M28UnitInfo.refiDFRange] <= (oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0) and oNearestEnemyToFriendlyBase.UnitId and oUnit[M28UnitInfo.refiDFRange] - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition()) < 6 then
                                                        if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                            if EntityCategoryContains(categories.COMMAND, oNearestEnemyToFriendlyBase.UnitId) then
                                                                M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'MvACU'..iLandZone)
                                                            else
                                                                local oTargetToManuallyAttack, bMoveNotManualAttack = GetManualAttackTargetIfWantManualAttack(oUnit)
                                                                if oTargetToManuallyAttack and not(oTargetToManuallyAttack == oNearestEnemyToFriendlyBase) then
                                                                    if bMoveNotManualAttack then M28Orders.IssueTrackedMove(oUnit, oTargetToManuallyAttack:GetPosition(), 2, false, 'Sc2bManM', false)
                                                                    else
                                                                        DoManualAttack(oUnit, oTargetToManuallyAttack, 'Sc2bManA')
                                                                    end
                                                                else
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will move to the nearest enemy, oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..'; Dist to us='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])) end
                                                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'AWE'..iLandZone)
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    else
                                                        local oTargetToManuallyAttack, bMoveNotManualAttack = GetManualAttackTargetIfWantManualAttack(oUnit)
                                                        if oTargetToManuallyAttack and not(oTargetToManuallyAttack == oNearestEnemyToFriendlyBase) then
                                                            if bMoveNotManualAttack then M28Orders.IssueTrackedMove(oUnit, oTargetToManuallyAttack:GetPosition(), 2, false, 'Sc2ManM', false)
                                                            else
                                                                DoManualAttack(oUnit, oTargetToManuallyAttack, 'Sc2ManA')
                                                            end
                                                            --M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'Sc2ManA', false)
                                                        else
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Will attackmove to the nearest enemy, oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..'; Dist to us='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])) end
                                                            if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'AWE'..iLandZone)
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    else
                        --SCENARIO 3 - Enemy outranges us and we dont ahve enough threat / high enough priority location to defend so want to retreat; exception to this if enemy has an experimental unit and it is in the same LZ as us, in which case want to attack with any units that are within 10 of being in range of it
                        --Also exceptio nif we have an experimental unit that cant kite, in which case it will attack-move to the rally point
                        local tNearbyEnemyExperimentals
                        local bConsiderAttackingExperimental = false
                        local iThresholdDistUntilInRangeToAttackExp = 10 --If dist to enemy exp less our range is less than this value, then will attack instead of retreating
                        local oClosestEnemyExpToBase
                        local oClosestEnemyExpToMidpoint
                        if oNearestEnemyToFriendlyBase then
                            tNearbyEnemyExperimentals = EntityCategoryFilterDown(categories.EXPERIMENTAL, tLZTeamData[M28Map.reftoNearestDFEnemies])
                            if M28Utilities.IsTableEmpty(tNearbyEnemyExperimentals) == false then
                                bConsiderAttackingExperimental = true
                                local iCurDist
                                local iClosestExpToBaseDist = 100000
                                local iClosestExpToMidpointDist = 100000
                                local iBestEnemyExpRange = 0
                                for iExp, oExp in tNearbyEnemyExperimentals do
                                    iBestEnemyExpRange = math.max(iBestEnemyExpRange, (oExp[M28UnitInfo.refiCombatRange] or 0))
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oExp:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                                    if iCurDist < iClosestExpToBaseDist then
                                        iClosestExpToBaseDist = iCurDist
                                        oClosestEnemyExpToBase = oExp
                                    end
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oExp:GetPosition(), tLZData[M28Map.subrefMidpoint]) - (oExp[M28UnitInfo.refiDFRange] or 0)
                                    if iCurDist < iClosestExpToMidpointDist then
                                        oClosestEnemyExpToMidpoint = oExp
                                        iClosestExpToMidpointDist = iCurDist
                                    end
                                end
                                --Are we against an enemy fatboy and we have nearby T2 arti? If so then only attack experimental if our unit is already in range of it/near to it depending on if enemy in range of firebase
                                local bNearbyFriendlyFirebaseVsFatboy = false
                                if iBestEnemyExpRange >= 80 and oClosestEnemyExpToBase then
                                    local iDistUntilInRangeOfArti = 100000
                                    local oClosestT2ArtiToEnemyExp
                                    local iClosestT2ArtiToEnemyDist = 100000
                                    function ConsiderClosestT2ArtiForZone(tCurLZTeamData)
                                        if tCurLZTeamData[M28Map.subrefLZThreatAllyStructureIndirect] >= 3000 then
                                            local tT2Arti = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, tCurLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                            if M28Utilities.IsTableEmpty(tT2Arti) == false then
                                                for iArti, oArti in tT2Arti do
                                                    if M28UnitInfo.IsUnitValid(oArti) and (oArti[M28UnitInfo.refiCombatRange] or 0) >= iBestEnemyExpRange then
                                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oArti:GetPosition(), oClosestEnemyExpToBase:GetPosition())
                                                        if not(oClosestEnemyExpToBase == oClosestEnemyExpToMidpoint) and oClosestEnemyExpToMidpoint and oClosestEnemyExpToMidpoint[M28UnitInfo.refiCombatRange] > 62 then iCurDist = math.min(iCurDist, M28Utilities.GetDistanceBetweenPositions(oArti:GetPosition(), oClosestEnemyExpToMidpoint:GetPosition())) end
                                                        if iCurDist < iClosestT2ArtiToEnemyDist then
                                                            iClosestT2ArtiToEnemyDist = iCurDist
                                                            oClosestT2ArtiToEnemyExp = oArti
                                                            iDistUntilInRangeOfArti = math.min(iDistUntilInRangeOfArti, iCurDist - oArti[M28UnitInfo.refiCombatRange])
                                                            if iDistUntilInRangeOfArti <= 3 then
                                                                break
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    ConsiderClosestT2ArtiForZone(tLZTeamData)
                                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false and iDistUntilInRangeOfArti > 3 then
                                        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                            ConsiderClosestT2ArtiForZone(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam])
                                            if iDistUntilInRangeOfArti <= 3 then break end
                                        end
                                    end
                                    if oClosestT2ArtiToEnemyExp and iDistUntilInRangeOfArti > 3 then
                                        bNearbyFriendlyFirebaseVsFatboy = true
                                    end
                                end
                                if bNearbyFriendlyFirebaseVsFatboy then
                                    --Wnat to retreat as we have nearby t2 arti that could support us, so only engage if are almost in range
                                    iThresholdDistUntilInRangeToAttackExp = 10 --i.e. attack if withi n10 of being in range
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have firebase so will rely on firebase to help us and retreat unless almost in range') end
                                else
                                    --Pre-v235 this was  iThresholdDistUntilInRangeToAttackExp =  iBestEnemyExpRange + 15, presumably to stop experimentals idling while taking fatboy fire; however it'd also result in them suiciding into enemy fatboy, so have changed in v235 to below, may need to adjust further though
                                    if tLZTeamData[M28Map.refiTimeOurT2ArtiLastFired] and GetGameTimeSeconds() - tLZTeamData[M28Map.refiTimeOurT2ArtiLastFired] <= 20 then
                                        iThresholdDistUntilInRangeToAttackExp = math.min(iBestEnemyExpRange + 20, 50)
                                    else
                                        iThresholdDistUntilInRangeToAttackExp = math.min(iBestEnemyExpRange + 15, 40)
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Time since t2 arti last fired='..GetGameTimeSeconds() - (tLZTeamData[M28Map.refiTimeOurT2ArtiLastFired] or 0)..'; iThresholdDistUntilInRangeToAttackExp='..iThresholdDistUntilInRangeToAttackExp..'; iBestEnemyExpRange='..iBestEnemyExpRange) end
                                end
                            end
                        end

                        local sRetreatMessage = 'GenRetr'

                        --Rescue ACU - move slightly infront of ACU relative to our closest base instead of retreating
                        ProtectFriendlyACUInTroubleIfRelevant(tAvailableCombatUnits)
                        if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
                            if bConsolidateAtMidpoint then
                                if oClosestFriendlyUnitToAnEnemyFirebase then
                                    tRallyPoint = M28Utilities.MoveInDirection(oClosestFriendlyUnitToAnEnemyFirebase:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestFriendlyUnitToAnEnemyFirebase:GetPosition(), tLZData[M28Map.subrefMidpoint]), math.min(M28Utilities.GetDistanceBetweenPositions(oClosestFriendlyUnitToAnEnemyFirebase:GetPosition(), tRallyPoint), 15), true, false, true)
                                    local iAltPlateau, iAltLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tRallyPoint)
                                    if not(iAltPlateau == iPlateau) then
                                        tRallyPoint = M28Map.GetPositionAtOrNearTargetInPathingGroup(oClosestFriendlyUnitToAnEnemyFirebase:GetPosition(), tRallyPoint, 0, 0, oClosestFriendlyUnitToAnEnemyFirebase, false, false, nil)
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and consolidate based on the closest unit to enemy firebase, tRallyPoint adjusted for this='..repru(tRallyPoint)) end
                                else
                                    tRallyPoint = {tLZData[M28Map.subrefMidpoint][1], tLZData[M28Map.subrefMidpoint][2], tLZData[M28Map.subrefMidpoint][3]}
                                end
                                sRetreatMessage = 'ConsRP'
                            end
                            if M28Map.bIsCampaignMap and not(M28Conditions.IsLocationInPlayableArea(tRallyPoint)) then
                                --If closest friendly base is in playable area go here
                                if M28Conditions.IsLocationInPlayableArea(tLZTeamData[M28Map.reftClosestFriendlyBase]) then
                                    tRallyPoint = {tLZTeamData[M28Map.reftClosestFriendlyBase][1], tLZTeamData[M28Map.reftClosestFriendlyBase][2], tLZTeamData[M28Map.reftClosestFriendlyBase][3]}
                                else
                                    local tMoveTowardsBase = M28Utilities.MoveInDirection(tLZData[M28Map.subrefMidpoint], M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase]), 60, true, false, true)
                                    if tMoveTowardsBase then
                                        tRallyPoint = tMoveTowardsBase
                                    elseif M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then
                                        tRallyPoint = {tLZData[M28Map.subrefMidpoint][1], tLZData[M28Map.subrefMidpoint][2], tLZData[M28Map.subrefMidpoint][3]}
                                    elseif oNearestEnemyToFriendlyBase then
                                        --Just go to the closest enemy unit
                                        tRallyPoint = oNearestEnemyToFriendlyBase:GetPosition()
                                    end
                                end
                            end
                            local bUnitIsSuicidingIntoMex = false
                            local bConsiderAttackMoveIfClose = false
                            local bMonkeylordSpecialMicro
                            local iCurDistToRally
                            if M28Utilities.GetDistanceBetweenPositions(tRallyPoint, tLZData[M28Map.subrefMidpoint]) <= 20 then bConsiderAttackMoveIfClose = true end

                            if bDebugMessages == true then LOG(sFunctionRef..': We are outranged by enemy and dont have enough threat to press the attack, will either retreat to prev LZ, or this LZ midpoint; bConsolidateAtMidpoint='..tostring(bConsolidateAtMidpoint)..'; bConsiderAttackingExperimental='..tostring(bConsiderAttackingExperimental)..'; tRallyPoint='..repru(tRallyPoint)..'; bSuicideUnitsNearAMex='..tostring(bSuicideUnitsNearAMex)..'; Is table of nearby mexes empty='..tostring(M28Utilities.IsTableEmpty(tNearbyMexes))) end

                            --local bCheckIfNearLocationToAvoid = not(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftiLocationsToAvoid]))
                            bGivenCombatUnitsOrders = true
                            for iUnit, oUnit in tAvailableCombatUnits do
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end

                                --Only retreat units from this LZ
                                if bDebugMessages == true then
                                    LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; will only retreat with unit if it is from this LZ, iLandZone='..iLandZone..'; Unit assigned zone='..(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] or 'nil')..'; Is special micro active='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive])..'; oClosestEnemyExpToBase='..(oClosestEnemyExpToBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyExpToBase) or 'nil')..'; iThresholdDistUntilInRangeToAttackExp='..(iThresholdDistUntilInRangeToAttackExp or 'nil')..'; oClosestEnemyExpToMidpoint='..(oClosestEnemyExpToMidpoint.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyExpToMidpoint) or 'nil'))
                                    if oClosestEnemyExpToBase.UnitId and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oClosestEnemyExpToBase.UnitId) then
                                        LOG(sFunctionRef..': Dist until reach enemy fatboy='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestEnemyExpToBase:GetPosition())..'; our DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; CloseToEnemy check re fatboy='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tNearbyEnemyExperimentals, 5, iTeam, true,                    nil,                    oUnit,                              oUnit))..'; Unit is assigned to this LZ and should proceed='..tostring(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone and ProceedWithUnitOrder(oUnit)))
                                    end
                                end

                                if oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone and ProceedWithUnitOrder(oUnit) then

                                    --if bCheckIfNearLocationToAvoid and EntityCategoryContains(categories.TECH1 + categories.TECH2 - categories.COMMAND, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbSpecialMicroActive]) and M28Conditions.HaveSentOrderToRunAwayFromLocationToAvoid(oUnit, tLZTeamData[M28Map.reftiLocationsToAvoid], 4) then
                                    --if bDebugMessages == true then LOG(sFunctionRef..': Unit will run away from location to avoid') end

                                    --Shot not blocked - consider attackign ACU with experimentals
                                    if bConsiderAttackingACU and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbScoutCombatOverride]) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), toEnemyACUsNearZone, 6 + (oUnit[M28UnitInfo.refiCombatRange] or 0), iTeam, false, nil, nil, nil, nil, nil) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Experimental - attack nearest ACU') end
                                        GetUnitToAttackNearestACUOrOverrideUnit(oUnit)
                                        --CloseToEnemyUnit(tStartPosition,       tUnitsToCheck, iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                                    elseif bConsiderAttackingExperimental and
                                            (((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or ((oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0 and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oClosestEnemyExpToBase.UnitId))) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestEnemyExpToBase:GetPosition()) - oUnit[M28UnitInfo.refiCombatRange] <= iThresholdDistUntilInRangeToAttackExp and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tNearbyEnemyExperimentals, 5, iTeam, true,                    nil,                    oUnit,                              oUnit) and (not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryIndirect, oUnit.UnitId)) or ((oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0 and (oUnit[M28UnitInfo.refiIndirectRange] < oClosestEnemyExpToBase[M28UnitInfo.refiCombatRange] or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestEnemyExpToBase:GetPosition()) - oUnit[M28UnitInfo.refiCombatRange] >= 10)) or (tLZTeamData[M28Map.refiTimeOurT2ArtiLastFired] and GetGameTimeSeconds() - tLZTeamData[M28Map.refiTimeOurT2ArtiLastFired] <= 10 and oClosestEnemyExpToBase[M28UnitInfo.refiCombatRange] >= math.max(60, oUnit[M28UnitInfo.refiCombatRange])))
                                                    or (not(oClosestEnemyExpToMidpoint == oClosestEnemyExpToBase) and oClosestEnemyExpToMidpoint and ((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or ((oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0 and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oClosestEnemyExpToMidpoint.UnitId))) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestEnemyExpToMidpoint:GetPosition()) - oUnit[M28UnitInfo.refiCombatRange] <= iThresholdDistUntilInRangeToAttackExp and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tNearbyEnemyExperimentals, 5, iTeam, true,                    nil,                    oUnit,                              oUnit) and (not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryIndirect, oUnit.UnitId)) or ((oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0 and (oUnit[M28UnitInfo.refiIndirectRange] < oClosestEnemyExpToMidpoint[M28UnitInfo.refiCombatRange] or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestEnemyExpToMidpoint:GetPosition()) - oUnit[M28UnitInfo.refiCombatRange] >= 10)) or (tLZTeamData[M28Map.refiTimeOurT2ArtiLastFired] and GetGameTimeSeconds() - tLZTeamData[M28Map.refiTimeOurT2ArtiLastFired] <= 10 and oClosestEnemyExpToMidpoint[M28UnitInfo.refiCombatRange] >= math.max(60, oUnit[M28UnitInfo.refiCombatRange]))))) then
                                        --move to nearest enemy experimental if we arent in range of it yet but a friendly unit is, and we are an experimental level unit or it is a fatboy
                                        local bMoveTowardsExperimental = false
                                        --Want to move instead of attackmove if we are an experimental (or up against a fatboy) and aren't already in range (by a reasonable margin if against a fatboy)
                                        local oTargetToManuallyAttack, bMoveNotManualAttack = GetManualAttackTargetIfWantManualAttack(oUnit)
                                        if oTargetToManuallyAttack then
                                            --Consider moving instead of attacking if not well within range
                                            if bDebugMessages == true then LOG(sFunctionRef..': Want to attack or move towards enemy manual attack target, dist to target='..M28Utilities.GetDistanceBetweenPositions(oTargetToManuallyAttack:GetPosition(), oUnit:GetPosition())..'; Our DF range='..oUnit[M28UnitInfo.refiDFRange]..'; bMoveNotManualAttack='..tostring(bMoveNotManualAttack)) end
                                            if bMoveNotManualAttack then
                                                M28Orders.IssueTrackedMove(oUnit, oTargetToManuallyAttack:GetPosition(), 6, false, 'ExpMM'..iLandZone)
                                            else
                                                local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oTargetToManuallyAttack:GetPosition(), oUnit:GetPosition())
                                                if iDistToTarget > oUnit[M28UnitInfo.refiDFRange] - 3 or (iDistToTarget > oUnit[M28UnitInfo.refiDFRange] - 8 and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId)) then
                                                    M28Orders.IssueTrackedMove(oUnit, oTargetToManuallyAttack:GetPosition(), 6, false, 'ExpoM'..iLandZone)
                                                else
                                                    DoManualAttack(oUnit, oTargetToManuallyAttack, 'ExpMA')
                                                    --M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'ExpMA', false)
                                                end
                                            end
                                        else
                                            local tTargetToMoveTowards

                                            if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oUnit.UnitId) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFatboy, tNearbyEnemyExperimentals)) == false then
                                                local oNearestEnemyExp
                                                local iClosestEnemyExpDist = 100000
                                                local iCurExpDist
                                                for iExperimental, oExperimental in tNearbyEnemyExperimentals do
                                                    iCurExpDist = M28Utilities.GetDistanceBetweenPositions(oExperimental:GetPosition(), oUnit:GetPosition())
                                                    if iCurExpDist < iClosestEnemyExpDist then
                                                        iClosestEnemyExpDist = iCurExpDist
                                                        oNearestEnemyExp = oExperimental
                                                    end
                                                end
                                                if iClosestEnemyExpDist > (oUnit[M28UnitInfo.refiCombatRange] or 0) - 3 then
                                                    bMoveTowardsExperimental = true
                                                end
                                                tTargetToMoveTowards = oNearestEnemyExp:GetPosition()
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will advance towards closest experimental='..(oNearestEnemyExp.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyExp) or 'nil')..'; iClosestEnemyExpDist='..iClosestEnemyExpDist..'; tTargetToMoveTowards='..repru(tTargetToMoveTowards)) end
                                            end
                                            if not(tTargetToMoveTowards) then tTargetToMoveTowards = {oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam][1], oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam][2], oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam][3]} end
                                            --If shot is blocked then move instad of attack move
                                            if oUnit[M28UnitInfo.refbLastShotBlocked] and not(bMoveTowardsExperimental) then
                                                if not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryFatboy, oUnit.UnitId)) or (iFriendlyBestMobileIndirectRange == 0 or tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] < tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] * 0.2 or iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 3) and (iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 1.75 or tLZTeamData[M28Map.refbIslandBeachhead] or (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) and iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 0.9)) then
                                                    bMoveTowardsExperimental = true
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Shot is blocked so will mov towards the experimental') end
                                                else
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Shot is blocked but not sure we want to move closer') end
                                                end
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Want to advance to enemy experimental, bMoveTowardsExperimental='..tostring(bMoveTowardsExperimental)..'; oUnit[M28UnitInfo.refbLastShotBlocked]='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked])) end
                                            if bMoveTowardsExperimental then
                                                M28Orders.IssueTrackedMove(oUnit, tTargetToMoveTowards, 6, false, 'ExpM'..iLandZone)
                                            else
                                                --Attackmove towards the experimental
                                                M28Orders.IssueTrackedAggressiveMove(oUnit, tTargetToMoveTowards, 6, false, 'ExpA'..iLandZone)
                                            end
                                        end
                                    elseif oUnit[M28Air.refiTimeLastDropped] and oUnit[M28UnitInfo.refiIndirectRange] > 0 and GetGameTimeSeconds() - oUnit[M28Air.refiTimeLastDropped] <= 60 and oNearestEnemyStructureToMidpoint then
                                        SuicideUnitIntoEnemyStructure(oUnit)
                                    else
                                        if bSuicideUnitsNearAMex and M28Utilities.IsTableEmpty(tNearbyMexes) == false then
                                            bUnitIsSuicidingIntoMex = false
                                            if not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryT3MobileArtillery + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) and not(oUnit[M28UnitInfo.refbScoutCombatOverride]) then
                                                local iClosestMex = math.max(25, (oUnit[M28UnitInfo.refiCombatRange] or 0) + 15)
                                                local oClosestMex
                                                local iCurMexDist
                                                for iMex, oMex in tNearbyMexes do
                                                    iCurMexDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oMex:GetPosition())
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Dist of oMex='..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)..' to unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'='..iCurMexDist) end
                                                    if iCurMexDist < iClosestMex then
                                                        oClosestMex = oMex
                                                        iClosestMex = iCurMexDist
                                                    end
                                                end
                                                if oClosestMex then
                                                    --Have a mex that is close; if the closest distance is almost in our range then attack it; but dont attack if we arent in range of enemy units yet and narest enemy unit is further from our rally than we are
                                                    if iClosestMex <= (oUnit[M28UnitInfo.refiCombatRange] + 3) then
                                                        bUnitIsSuicidingIntoMex = true
                                                    else
                                                        local bInRangeOfEnemy = M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 4, iTeam, true, nil, nil, oUnit)
                                                        if not(bInRangeOfEnemy) then
                                                            if not(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) then
                                                                bUnitIsSuicidingIntoMex = true
                                                            else
                                                                --We arent in range of the enemy; but if we move to be in range of the mex will we be in range of them?
                                                                local iDistToClosestEnemyLessRange = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()) - (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 0)
                                                                if iDistToClosestEnemyLessRange > (iClosestMex - (oUnit[M28UnitInfo.refiCombatRange] or 0)) then
                                                                    bUnitIsSuicidingIntoMex = true
                                                                    --Is the enemy closer to our rally point? if so then also want to suicide
                                                                elseif M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), tRallyPoint) < M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint) then
                                                                    bUnitIsSuicidingIntoMex = true
                                                                end
                                                            end
                                                        else
                                                            --We are in range of the enemy already; if enemy is closer to our rally point than us then still suicide
                                                            if M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), tRallyPoint) < M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint) then
                                                                bUnitIsSuicidingIntoMex = true
                                                            end
                                                        end
                                                    end
                                                    if bUnitIsSuicidingIntoMex then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Will suicide unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' into oClosestMex='..oClosestMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestMex)) end
                                                        if iClosestMex <= oUnit[M28UnitInfo.refiCombatRange] + 2 then
                                                            M28Orders.IssueTrackedAttack(oUnit, oClosestMex, false, 'SuicMxAt')
                                                        else
                                                            if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                                M28Orders.IssueTrackedMove(oUnit, oClosestMex:GetPosition(), 2, false, 'SuicMxM')
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                        if not(bUnitIsSuicidingIntoMex) then

                                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                            --Monkkeylord - special micro retreat logic
                                            if oUnit.UnitId == 'url0402' then
                                                --Do we want to advance on enemy? I.e. if we outrange the enemy or the nearest enemy unit if we use our longer range of 64? Dont consider this if enemy has air to ground threat here though
                                                local bEnemyAlmostInRangeOfUs = M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tSkirmisherDFEnemies, 11, iTeam, true, nil, nil, oUnit, 6, false)
                                                local bWantToKiteTowardsEnemy = false
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to advance towards enemy, bEnemyAlmostInRangeOfUs='..tostring(bEnemyAlmostInRangeOfUs)..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Monkey oUnit health%='..M28UnitInfo.GetUnitHealthPercent(oUnit)) end
                                                if not(bEnemyAlmostInRangeOfUs) and (tLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) <= 250 and M28UnitInfo.GetUnitHealthPercent(oUnit) >= 0.2 then
                                                    local oEnemyToConsiderAdvancingTowards
                                                    --Do we want to advance towards the nearest enmey?
                                                    if not(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) then
                                                        if M28UnitInfo.IsUnitValid(oNearestEnemyToFriendlyBase) then
                                                            oEnemyToConsiderAdvancingTowards = oNearestEnemyToFriendlyBase
                                                        end
                                                    else
                                                        if M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()) < M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition()) then
                                                            oEnemyToConsiderAdvancingTowards = oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]
                                                        else
                                                            oEnemyToConsiderAdvancingTowards = oNearestEnemyToFriendlyBase
                                                        end
                                                    end
                                                    if oEnemyToConsiderAdvancingTowards and (oEnemyToConsiderAdvancingTowards[M28UnitInfo.refiDFRange] or 0) < 60 then
                                                        local iDistToNearestEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToConsiderAdvancingTowards:GetPosition())
                                                        --Are we far enough from the enemy that if we start microing back we will still fire?
                                                        if iDistToNearestEnemy > 58 then
                                                            if not(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemyToConsiderAdvancingTowards, false)) then
                                                                if tLZTeamData[M28Map.refiRadarCoverage] < iIntelThresholdForPriorityScout then
                                                                    tLZTeamData[M28Map.refiTimeLastFailedToKiteDueToScoutIntel] = GetGameTimeSeconds()
                                                                end
                                                            else
                                                                --If we move to be in range of the enemy will the closest enemy combat unit be able to reach us?
                                                                bWantToKiteTowardsEnemy = true
                                                                if iDistToNearestEnemy > 70 and (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 0) >= 60 and not(oEnemyToConsiderAdvancingTowards == oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and M28UnitInfo.IsUnitValid( oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                                                                    local iDistFromDangerousEnemyToTarget = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oEnemyToConsiderAdvancingTowards:GetPosition())
                                                                    if iDistFromDangerousEnemyToTarget < iDistToNearestEnemy + 10 then
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': The enemy unit closest to being able to attack us has a similar or better range than us, and is similar or closer to the enemy we want to attack, so wont attack and will just do gneeral retreat') end
                                                                        bWantToKiteTowardsEnemy = false
                                                                    end
                                                                end
                                                                if bWantToKiteTowardsEnemy then
                                                                    bMonkeylordSpecialMicro = true
                                                                    --Advance towards the enemy
                                                                    M28Orders.IssueTrackedMove(oUnit, oEnemyToConsiderAdvancingTowards:GetPosition(), 6, false, 'MonkAdv', false)
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Instead of retreating we will try kiting with this unit') end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end

                                                if bEnemyAlmostInRangeOfUs or not(bWantToKiteTowardsEnemy) then
                                                    bMonkeylordSpecialMicro = M28Micro.MonkeylordRetreatMicro(oUnit, tAmphibiousRallyPoint, tLZTeamData[M28Map.reftClosestFriendlyBase], oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will do monkeylord retreat micro, bMonkeylordSpecialMicro='..tostring(bMonkeylordSpecialMicro or false)) end
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': Finished considering whether to do monkeylord retreat micro, bEnemyAlmostInRangeOfUs='..tostring(bEnemyAlmostInRangeOfUs or false)..'; bWantToKiteTowardsEnemy='..tostring(bWantToKiteTowardsEnemy or false)..'; bMonkeylordSpecialMicro='..tostring(bMonkeylordSpecialMicro or false)) end
                                            end
                                            if bMonkeylordSpecialMicro then
                                                --Reset for next unit
                                                bMonkeylordSpecialMicro = nil
                                            else
                                                if not(bConsolidateAtMidpoint) and EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                                    --If moving to the rally point would take us closer to the enemy than moving towards our base then move towards base instead
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Amphibious unit and we dont want to consolidate at midpoint, CanKite='..tostring(oUnit[M28UnitInfo.refbCanKite] or false)) end
                                                    if not(oUnit[M28UnitInfo.refbCanKite]) and EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then
                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ExKA'..sRetreatMessage..iLandZone)
                                                    else
                                                        local bMoveTowardsBaseInstead = false
                                                        local iAngleToBase
                                                        if tMoveTowardsBaseRetreatPoint then --If this is not nil then it means the rally point will take us a different angle to the nearest friendly base, which might cause us to move closer/within range of enemy units
                                                            local iAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition())
                                                            iAngleToBase = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])

                                                            if 180 - M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToBase) <= 45 then
                                                                bMoveTowardsBaseInstead = true
                                                            end
                                                        end
                                                        if bMoveTowardsBaseInstead then --see below for similar code if making changes here
                                                            if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMoveTowardsBaseRetreatPoint) <= 12 or M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tMoveTowardsBaseRetreatPoint), iAngleToBase) >= 45 then
                                                                if (oUnit[M28UnitInfo.refbWeaponUnpacks] or not(oUnit[M28UnitInfo.refbCanKite])) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 13 then
                                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, tLZTeamData[M28Map.reftClosestFriendlyBase], 6, false, 'MTBBA'..sRetreatMessage..iLandZone)
                                                                else
                                                                    if bConsiderAttackMoveIfClose and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 20 then
                                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, tLZTeamData[M28Map.reftClosestFriendlyBase], 6, false, 'MTBABA'..iLandZone)
                                                                    else
                                                                        M28Orders.IssueTrackedMove(oUnit, tLZTeamData[M28Map.reftClosestFriendlyBase], 6, false, 'MTBBA'..sRetreatMessage..iLandZone)
                                                                    end
                                                                end

                                                            else
                                                                if (oUnit[M28UnitInfo.refbWeaponUnpacks] or not(oUnit[M28UnitInfo.refbCanKite])) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMoveTowardsBaseRetreatPoint) <= 13 then
                                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, tMoveTowardsBaseRetreatPoint, 6, false, 'MTBNA'..sRetreatMessage..iLandZone)
                                                                else
                                                                    if bConsiderAttackMoveIfClose and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMoveTowardsBaseRetreatPoint) <= 20 then
                                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, tMoveTowardsBaseRetreatPoint, 6, false, 'MTBABA'..iLandZone)
                                                                    else
                                                                        M28Orders.IssueTrackedMove(oUnit, tMoveTowardsBaseRetreatPoint, 6, false, 'MTBNA'..sRetreatMessage..iLandZone)
                                                                    end
                                                                end
                                                            end
                                                        else
                                                            local bAttackMove = false
                                                            if (oUnit[M28UnitInfo.refbWeaponUnpacks] or not(oUnit[M28UnitInfo.refbCanKite])) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tAmphibiousRallyPoint) <= 13 then
                                                                bAttackMove = true
                                                            else
                                                                if bConsiderAttackMoveIfClose and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tAmphibiousRallyPoint) <= 20 then
                                                                    bAttackMove = true
                                                                end
                                                            end
                                                            iCurDistToRally = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tAmphibiousRallyPoint)
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Will go to amphibious rally point, bAttackMove='..tostring(bAttackMove)..'; bConsiderAttackMoveIfClose='..tostring(bConsiderAttackMoveIfClose)..'; iCurDistToRally='..iCurDistToRally..'; Angle to rally='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tAmphibiousRallyPoint)) end
                                                            if iCurDistToRally >= 200 then
                                                                --Had issue where monkeylord got stuck when 251 dist from rally point
                                                                local iAngleToRallyPoint = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tAmphibiousRallyPoint)
                                                                local tMoveTowardsBaseRetreatPoint = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToRallyPoint, 200, true, true, M28Map.bIsCampaignMap)
                                                                if M28Utilities.IsTableEmpty(tMoveTowardsBaseRetreatPoint) == false then
                                                                    if not(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tMoveTowardsBaseRetreatPoint) == tLZData[M28Map.subrefLZIslandRef]) then
                                                                        tMoveTowardsBaseRetreatPoint = nil

                                                                    end
                                                                end
                                                                if bDebugMessages == true then LOG(sFunctionRef..': tMoveTowardsBaseRetreatPoint='..repru(tMoveTowardsBaseRetreatPoint)..'; bAttackMove='..tostring(bAttackMove or false)) end
                                                                if tMoveTowardsBaseRetreatPoint then
                                                                    if bAttackMove then
                                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, tMoveTowardsBaseRetreatPoint, 6, false, 'RAInt'..sRetreatMessage..iLandZone)
                                                                    else
                                                                        M28Orders.IssueTrackedMove(oUnit, tMoveTowardsBaseRetreatPoint, 6, false, 'MInt'..sRetreatMessage..iLandZone)
                                                                    end
                                                                else
                                                                    if bAttackMove then
                                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, tAmphibiousRallyPoint, 6, false, 'RAXInt'..sRetreatMessage..iLandZone)
                                                                    else
                                                                        M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'MXInt'..sRetreatMessage..iLandZone)
                                                                    end
                                                                end
                                                            else
                                                                if bAttackMove then
                                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, tAmphibiousRallyPoint, 6, false, 'RA'..sRetreatMessage..iLandZone)
                                                                else
                                                                    M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'M'..sRetreatMessage..iLandZone)
                                                                end
                                                            end
                                                        end

                                                    end
                                                else
                                                    if not(oUnit[M28UnitInfo.refbCanKite]) and EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then
                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, tRallyPoint, 6, false, 'ExKG'..sRetreatMessage..iLandZone)
                                                    else
                                                        local bMoveTowardsBaseInstead = false
                                                        local iAngleToBase
                                                        local iAngleToNearestEnemy
                                                        if tMoveTowardsBaseRetreatPoint then --If this is not nil then it means the rally point will take us a different angle to the nearest friendly base, which might cause us to move closer/within range of enemy units
                                                            iAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition())
                                                            iAngleToBase = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                                                            if 180 - M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToBase) <= 45 then
                                                                bMoveTowardsBaseInstead = true
                                                            end
                                                            if bDebugMessages == true then LOG(sFunctionRef..': iAngleToNearestEnemy='..iAngleToNearestEnemy..'; iAngleToBase='..iAngleToBase..'; Angle dif between angle to nearest enemy and angle to base='..M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToBase)..'; bMoveTowardsBaseInstead='..tostring(bMoveTowardsBaseInstead)) end
                                                        end
                                                        if bDebugMessages == true then LOG(sFunctionRef..': bMoveTowardsBaseInstead='..tostring(bMoveTowardsBaseInstead)) end
                                                        if bMoveTowardsBaseInstead then --see above for similar code if making changes here
                                                            if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMoveTowardsBaseRetreatPoint) <= 12 or M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tMoveTowardsBaseRetreatPoint), iAngleToBase) >= 45 then
                                                                if (oUnit[M28UnitInfo.refbWeaponUnpacks] or not(oUnit[M28UnitInfo.refbCanKite])) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 13 then
                                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, tLZTeamData[M28Map.reftClosestFriendlyBase], 6, false, 'MTBB'..sRetreatMessage..iLandZone)
                                                                else
                                                                    M28Orders.IssueTrackedMove(oUnit, tLZTeamData[M28Map.reftClosestFriendlyBase], 6, false, 'MTBB'..sRetreatMessage..iLandZone)
                                                                end
                                                            else
                                                                if (oUnit[M28UnitInfo.refbWeaponUnpacks] or not(oUnit[M28UnitInfo.refbCanKite])) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMoveTowardsBaseRetreatPoint) <= 13 then
                                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, tMoveTowardsBaseRetreatPoint, 6, false, 'MTBN'..sRetreatMessage..iLandZone)
                                                                else
                                                                    M28Orders.IssueTrackedMove(oUnit, tMoveTowardsBaseRetreatPoint, 6, false, 'MTBN'..sRetreatMessage..iLandZone)
                                                                end
                                                            end
                                                        else
                                                            if not(iAngleToNearestEnemy) and oNearestEnemyToFriendlyBase then iAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition()) end
                                                            local bRunFromNearestEnemy = false
                                                            if iAngleToNearestEnemy then
                                                                local iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Will retreat towards rally point unless takes us towards nearest enemy, iAngleToNearestEnemy='..(iAngleToNearestEnemy or 'nil')..'; iAngleToRally='..iAngleToRally) end
                                                                if M28Utilities.GetAngleDifference(iAngleToRally, iAngleToNearestEnemy) <= 90 then
                                                                    bRunFromNearestEnemy = true
                                                                    RunFromEnemy(oUnit, oNearestEnemyToFriendlyBase, iTeam, iPlateau, 10)
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will run from the enemy closest to our base') end
                                                                end
                                                            end
                                                            if not(bRunFromNearestEnemy) then
                                                                if bDebugMessages == true then
                                                                    LOG(sFunctionRef..': Will retreat towards rally point, tRallyPoint='..repru(tRallyPoint)..'; Unit position='..repru(oUnit:GetPosition())..'; Unit special micro='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive] or false)..'; last order position='..repru(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]))
                                                                    --M28Utilities.DrawLocation(tRallyPoint)
                                                                end
                                                                if (oUnit[M28UnitInfo.refbWeaponUnpacks] or not(oUnit[M28UnitInfo.refbCanKite])) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint) <= 13 then
                                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, tRallyPoint, 6, false, sRetreatMessage..iLandZone)
                                                                else
                                                                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, sRetreatMessage..iLandZone)
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                else
                                    --Unit is from a different zone - need to change the value of its assignment so it is considered for orders by the zone that it is part of
                                    oUnit[refiCurrentAssignmentValue] = 0
                                end
                            end
                        end
                    end

                    if bUpdateNearestUnit then
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                            if aiBrain then
                                M28Team.UpdateUnitLastKnownPosition(aiBrain, oNearestEnemyToFriendlyBase, true)
                            end
                        else
                            M28Utilities.ErrorHandler('No active M28 brain')
                        end
                    end
                end
                --MML synchronisation logic
                if (bConsiderSpecialMMLLogic or bEnemyHasFixedShieldsInThisOrAdjacentZone) and M28Utilities.IsTableEmpty(tMMLForSynchronisation) == false then
                    --Get table of enemy shields and TMD to consider targeting
                    local tPriorityMMLTargets = {}
                    local bConsiderMultipleTargets = false
                    function IncludeTMDAndShieldsInZone(iAdjLZ, iOverridePlateau, iSearchCategory)
                        local tAdjLZTeamData
                        if iAdjLZ == iLandZone and not(iOverridePlateau) then tAdjLZTeamData = tLZTeamData else tAdjLZTeamData = M28Map.tAllPlateaus[(iOverridePlateau or iPlateau)][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam] end
                        if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                            local tZoneTMDAndShields = EntityCategoryFilterDown(iSearchCategory, tAdjLZTeamData[M28Map.subrefTEnemyUnits])
                            if M28Utilities.IsTableEmpty(tZoneTMDAndShields) == false then
                                for iTMDOrShield, oTMDOrShield in tZoneTMDAndShields do
                                    if oTMDOrShield:GetFractionComplete() >= 0.3 and M28UnitInfo.IsUnitValid(oTMDOrShield) and not(oTMDOrShield:IsUnitState('Attached')) and (oTMDOrShield:GetFractionComplete() >= 0.5 or (oTMDOrShield[M28UnitInfo.refiUnitMassCost] or 0) >= 300) and (not(EntityCategoryContains(categories.MOBILE, oTMDOrShield.UnitId)) or (not(oTMDOrShield:IsUnitState('Moving')) and M28UnitInfo.GetUnitSpeed(oTMDOrShield) <= 0.1)) then
                                        table.insert(tPriorityMMLTargets, oTMDOrShield)
                                    end
                                end
                            end
                        end
                    end

                    local iPrioritySearchCategory = M28UnitInfo.refCategoryTMD + M28UnitInfo.refCategoryFixedShield
                    local iMMLMassValue = M28UnitInfo.GetMassCostOfUnits(tMMLForSynchronisation)
                    --if iMMLMassValue >= 1000 then --removed as want our mml to target stationery enemy mmls even when we only have 1-2 of them
                    iPrioritySearchCategory = iPrioritySearchCategory + (M28UnitInfo.refCategoryIndirect * categories.MOBILE - categories.TECH1)
                    if iMMLMassValue >= 2000 then --have 10+ T2 MML equivalent so include t2 arti when searching
                        bConsiderMultipleTargets = true
                        iPrioritySearchCategory = iPrioritySearchCategory + M28UnitInfo.refCategoryFixedT2Arti
                        if iMMLMassValue >= 4000 then --Include T2 and T3 PD as well
                            iPrioritySearchCategory = iPrioritySearchCategory + M28UnitInfo.refCategoryT2PlusPD
                        end
                    end
                    --end
                    IncludeTMDAndShieldsInZone(iLandZone, nil, iPrioritySearchCategory)
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                            IncludeTMDAndShieldsInZone(iAdjLZ, nil, iPrioritySearchCategory)
                        end
                    end
                    if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
                        for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                            IncludeTMDAndShieldsInZone(tPlateauAndZone[2], tPlateauAndZone[1], iPrioritySearchCategory)
                        end
                    end
                    --Add upgrading enemy ACUs that are near this zone midpoint (except in LOUD where ACUs have TMD) - (will also have a check later on based on ACUs in this specific zone; benefit of below though is it covers adjacent zones)
                    if not(M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) and (M28Utilities.IsTableEmpty(tPriorityMMLTargets) or table.getn(tPriorityMMLTargets) <= iMMLMassValue / 1200) then
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) == false then
                            for iACU, oACU in M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs] do
                                if M28UnitInfo.IsUnitValid(oACU) and oACU:IsUnitState('Upgrading') and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= 120 then
                                    table.insert(tPriorityMMLTargets, oACU)
                                end
                            end
                        end
                    end


                    --Consider orders for each MML
                    local oClosestPotentialTarget
                    local iClosestPotentialTarget
                    local iCurTargetDist
                    local tMMLWithNearbyTargets = {}
                    local toAlreadyCoveredTargets = {}
                    local tiAssignedInRangeThreatByEntity = {}
                    local iDistThresholdForInRange = 5


                    if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through each MML for synchronisation and get a target for it, is tPriorityMMLTargets empty='..tostring(M28Utilities.IsTableEmpty(tPriorityMMLTargets))) end
                    local iDistThresholdFurtherAdjust
                    local tPriorityEnemyScoutTargets = {}
                    for iUnit, oUnit in tMMLForSynchronisation do
                        iDistThresholdFurtherAdjust = 0
                        if oUnit[M28UnitInfo.refiIndirectRange] - iEnemyBestDFRange >= 40 and oUnit[M28UnitInfo.refiIndirectRange] >= 55 then iDistThresholdFurtherAdjust = math.max(8, 20 - iIndirectRunFigureSynchronisation)
                        elseif iEnemyBestDFRange > 30 and oUnit[M28UnitInfo.refiIndirectRange] >= 55 then iDistThresholdFurtherAdjust = math.min(4, 20 - iIndirectRunFigureSynchronisation)
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Is MML '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at position '..repru(oUnit:GetPosition())..' close to enemy DF units='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], iIndirectRunFigureSynchronisation + iDistThresholdFurtherAdjust, iTeam, true, math.min(30, oUnit[M28UnitInfo.refiIndirectRange] - iIndirectRunFigureSynchronisation * 2, math.max(25, iEnemyBestDFRange + 5)), nil,                        oUnit))..'; iDistThresholdFurtherAdjust='..iDistThresholdFurtherAdjust..'; CloseToEnemy based on tSkirmisherDFENemies='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tSkirmisherDFEnemies, iIndirectRunFigureSynchronisation + iDistThresholdFurtherAdjust, iTeam, true, math.min(30, oUnit[M28UnitInfo.refiIndirectRange] - iIndirectRunFigureSynchronisation * 2, math.max(25, iEnemyBestDFRange + 5)), nil,                        oUnit))) end
                        --CloseToEnemyUnit(tStartPosition,      tUnitsToCheck,                                                   iDistThreshold,                                                iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange,                                                                                        oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                        if not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tSkirmisherDFEnemies, iIndirectRunFigureSynchronisation + iDistThresholdFurtherAdjust, iTeam, true, math.min(30, oUnit[M28UnitInfo.refiIndirectRange] - iIndirectRunFigureSynchronisation * 2, math.max(25, iEnemyBestDFRange + 5)), nil,                        oUnit)) then
                            if M28Utilities.IsTableEmpty(tPriorityMMLTargets) then --redundancy - hopefully only scenario we get here is if there is 1 part-complete TMD/shield that is <30% complete
                                M28Orders.IssueTrackedAggressiveMove(oUnit, (oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or oNearestEnemyToFriendlyBase:GetPosition()), math.max(15, (iIndirectDistanceInsideRangeThreshold or 15)), false, 'I2KAMve'..iLandZone)
                            else
                                --Get the closest TMD/shield to this MML, and then decide whether to attack it or not (for performance reasons stop as soon as we have a target within TML range
                                iClosestPotentialTarget = 100000
                                for iTarget, oTarget in tPriorityMMLTargets do
                                    iCurTargetDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTarget:GetPosition())
                                    if iCurTargetDist < iClosestPotentialTarget then
                                        iClosestPotentialTarget = iCurTargetDist
                                        oClosestPotentialTarget = oTarget
                                        if iClosestPotentialTarget < oUnit[M28UnitInfo.refiIndirectRange] then break end
                                    end
                                end
                                if not(oClosestPotentialTarget) and M28Utilities.IsTableEmpty(toAlreadyCoveredTargets) == false then
                                    for iTarget, oTarget in toAlreadyCoveredTargets do
                                        iCurTargetDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTarget:GetPosition())
                                        if iCurTargetDist < iClosestPotentialTarget then
                                            iClosestPotentialTarget = iCurTargetDist
                                            oClosestPotentialTarget = oTarget
                                            if iClosestPotentialTarget < oUnit[M28UnitInfo.refiIndirectRange] then break end
                                        end
                                    end
                                end
                                if not(oClosestPotentialTarget) then
                                    M28Utilities.ErrorHandler('Somehow dont have a target for MML')
                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(15, iIndirectDistanceInsideRangeThreshold), false, 'I2KAMve'..iLandZone)
                                else
                                    if iClosestPotentialTarget - iDistThresholdForInRange > oUnit[M28UnitInfo.refiIndirectRange] then
                                        --Still a bit of distance until we are in range; attack move if we are far away, but do a normal move if we are almost in range
                                        --First check if another target (e.g. upgrading ACU) we should focus fire on first though, if it's significnatly closer than the nearest shield or TMD
                                        local oInRangeUpgradingACU
                                        if M28Utilities.IsTableEmpty(toEnemyACUsNearZone) == false and iClosestPotentialTarget - 10 > oUnit[M28UnitInfo.refiIndirectRange] then
                                            for iACU, oACU in toEnemyACUsNearZone do
                                                if oACU:IsUnitState('Upgrading') and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition()) <= oUnit[M28UnitInfo.refiIndirectRange] then
                                                    oInRangeUpgradingACU = oACU
                                                    break
                                                end
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': oInRangeUpgradingACU='..(oInRangeUpgradingACU.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oInRangeUpgradingACU) or 'nil')..'; iClosestPotentialTarget='..iClosestPotentialTarget..'; oUnit[M28UnitInfo.refiIndirectRange]='..oUnit[M28UnitInfo.refiIndirectRange]..'; oClosestPotentialTarget='..(oClosestPotentialTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestPotentialTarget) or 'nil')) end
                                        if oInRangeUpgradingACU then
                                            M28Orders.IssueTrackedGroundAttack(oUnit, oInRangeUpgradingACU:GetPosition(), (oUnit[M28UnitInfo.refiIndirectAOE] or 0), false, 'MMLSchACU', false)
                                            table.insert(tMMLWithNearbyTargets, oUnit)
                                        elseif iClosestPotentialTarget - 35 > oUnit[M28UnitInfo.refiIndirectRange] then
                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oClosestPotentialTarget:GetPosition(), (oUnit[M28UnitInfo.refiIndirectAOE] or 0), false, 'MMLSchAM'..iLandZone)
                                        else
                                            M28Orders.IssueTrackedMove(oUnit, oClosestPotentialTarget:GetPosition(), (oUnit[M28UnitInfo.refiIndirectAOE] or 0), false, 'MMLSchM'..iLandZone)
                                        end
                                    else
                                        if oClosestPotentialTarget[M28UnitInfo.refbHaveSeenUnitByTeam][iTeam] or not(EntityCategoryContains(M28UnitInfo.refCategoryTMD + M28UnitInfo.refCategoryStealthGenerator, oClosestPotentialTarget.UnitId)) then
                                            --Can attack the unit itself as either in range or almost in range
                                            M28Orders.IssueTrackedGroundAttack(oUnit, oClosestPotentialTarget:GetPosition(), (oUnit[M28UnitInfo.refiIndirectAOE] or 0), false, 'MMLSchGA', false)
                                        else
                                            --Enemy TMD that we dont have intel of
                                            tPriorityEnemyScoutTargets[oClosestPotentialTarget.EntityId] = oClosestPotentialTarget
                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oClosestPotentialTarget:GetPosition(), (oUnit[M28UnitInfo.refiIndirectAOE] or 10) - 5, 'MMLNoVis')
                                        end
                                        table.insert(tMMLWithNearbyTargets, oUnit)
                                        if bConsiderMultipleTargets then
                                            tiAssignedInRangeThreatByEntity[oClosestPotentialTarget.EntityId] = (tiAssignedInRangeThreatByEntity[oClosestPotentialTarget.EntityId] or 0) + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
                                            if tiAssignedInRangeThreatByEntity[oClosestPotentialTarget.EntityId] >= math.max(1000, M28UnitInfo.GetUnitMaxHealthIncludingShield(oUnit) * oUnit:GetFractionComplete() * 0.4) then
                                                --Remove unit from the priority target table and add to the 'other' table
                                                for iEntry, oEntry in  tPriorityMMLTargets do
                                                    if oEntry == oClosestPotentialTarget then
                                                        table.insert(toAlreadyCoveredTargets, oEntry)
                                                        table.remove(tPriorityMMLTargets, iEntry)
                                                        break
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            --If we would be running from an enemy PD (which cant chase us) and we aren't yet in range of it, then switch to attacking that PD instead; do +3 as if we get too close we might trigger dodge shot micro, and/or might move into range of the pd due to dodge shot micro
                        elseif oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId) and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()) > (oUnit[M28UnitInfo.refiDFRange] or 0) + 3 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Normally would retreat but there is an enemy PD that is the closest to being in our range and we can attack it without getting in range') end
                            M28Orders.IssueTrackedAttack(oUnit, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], false, 'MMLAtckNtR', false)
                        else
                            local bTemporaryKiting = false
                            if oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()) <= math.max(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiCombatRange] + 8, oUnit[M28UnitInfo.refiCombatRange] - 10) then
                                local tTemporaryRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), 8, true, false, M28Map.bIsCampaignMap)
                                if tTemporaryRetreatLocation and NavUtils.GetLabel(M28Map.refPathingTypeLand, tTemporaryRetreatLocation) == tLZData[M28Map.subrefLZIslandRef] then
                                    bTemporaryKiting = true
                                    M28Orders.IssueTrackedMove(oUnit, tTemporaryRetreatLocation, 6, false, 'MMLOpERetr'..iLandZone)
                                end
                            end

                            if bDebugMessages == true then
                                if oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] then
                                    LOG(sFunctionRef..': Retreating MML, dist to closest enemy='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())..'; oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]='..oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])..' with DF range='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 'nil'))
                                else
                                    LOG(sFunctionRef..': Will retreat MML') end
                            end
                            --Retreat temporarily from enemy units
                            if not(bTemporaryKiting) then
                                if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                    M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'MMLASKRetr'..iLandZone)
                                else
                                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'MMLSKRetr'..iLandZone)
                                end
                            end
                        end
                    end

                    if M28Utilities.IsTableEmpty(tPriorityEnemyScoutTargets) == false then
                        local iAirSubteam = ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].M28AirSubteam
                        for iEnemy, oEnemy in tPriorityEnemyScoutTargets do
                            M28Air.AddUnitWantingPriorityScout(oEnemy, false, iAirSubteam)
                        end
                    end

                    --Do we have any MML that have targets in-range or almost in range? If so then consider synchronising their weapons (dont do this though if we only want to prioritise TMD and shields and dont want to synchronise)
                    if bDebugMessages == true then LOG(sFunctionRef..': Is tMMLWithNearbyTargets empty='..tostring(M28Utilities.IsTableEmpty(tMMLWithNearbyTargets))) end
                    if bConsiderSpecialMMLLogic and M28Utilities.IsTableEmpty(tMMLWithNearbyTargets) == false then
                        local iMMLWithTargets = table.getn(tMMLWithNearbyTargets)
                        if bDebugMessages == true then LOG(sFunctionRef..': iMMLWithTargets='..iMMLWithTargets) end
                        if iMMLWithTargets >= 4 then
                            local iMMLJustFiredOrReadyToFire = 0
                            local iMMLNotFiredForAges = 0
                            local iMMLReloading = 0

                            local iTimeUntilReadyToFire
                            local iTotalTimeUntilReadyToFire = 0
                            local iMinTimeUntilReady = 100000
                            local iMaxTimeUntilReady = -100000
                            local tiTimeUntilReadyToFire = {}
                            for iUnit, oUnit in tMMLWithNearbyTargets do
                                iTimeUntilReadyToFire = oUnit[M28UnitInfo.refiTimeBetweenIFShots] - (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or -100))
                                if iTimeUntilReadyToFire <= math.min(-7, -oUnit[M28UnitInfo.refiTimeBetweenIFShots] - 1.5) then
                                    iMMLNotFiredForAges = iMMLNotFiredForAges + 1
                                elseif iTimeUntilReadyToFire >= 1.01 then
                                    iMMLReloading = iMMLReloading + 1
                                else
                                    iMMLJustFiredOrReadyToFire = iMMLJustFiredOrReadyToFire + 1
                                end
                                if iTimeUntilReadyToFire < iMinTimeUntilReady then iMinTimeUntilReady = iTimeUntilReadyToFire end
                                if iTimeUntilReadyToFire > iMaxTimeUntilReady then iMaxTimeUntilReady = iTimeUntilReadyToFire end
                                iTotalTimeUntilReadyToFire = iTotalTimeUntilReadyToFire + iTimeUntilReadyToFire
                                table.insert(tiTimeUntilReadyToFire, iTimeUntilReadyToFire)
                                if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTimeUntilReadyToFire='..iTimeUntilReadyToFire..'; oUnit[M28UnitInfo.refiTimeBetweenIFShots]='..oUnit[M28UnitInfo.refiTimeBetweenIFShots]..'; oUnit[M28UnitInfo.refiLastWeaponEvent]='..(oUnit[M28UnitInfo.refiLastWeaponEvent] or 'nil')..'; Cur time='..GetGameTimeSeconds()) end
                            end
                            local iAverageTimeUntilReadyToFire = iTotalTimeUntilReadyToFire / iMMLWithTargets
                            local iMMLWithin1OfAverage = 0
                            for iEntry, iTime in tiTimeUntilReadyToFire do
                                if math.abs(iTime - iAverageTimeUntilReadyToFire) < 1 then
                                    iMMLWithin1OfAverage = iMMLWithin1OfAverage + 1
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iMMLJustFiredOrReadyToFire='..iMMLJustFiredOrReadyToFire..'; iMMLNotFiredForAges='..iMMLNotFiredForAges..'; iMMLWithTargets='..iMMLWithTargets..'; iMMLReloading='..iMMLReloading..'; iMMLWithin1OfAverage='..iMMLWithin1OfAverage..'; iAverageTimeUntilReadyToFire='..iAverageTimeUntilReadyToFire..'; iMaxTimeUntilReady='..iMaxTimeUntilReady..'; iMinTimeUntilReady='..iMinTimeUntilReady) end
                            if iMMLJustFiredOrReadyToFire + iMMLNotFiredForAges >= iMMLWithTargets * 0.75 or iMMLNotFiredForAges >= iMMLWithTargets * 0.25 or iMMLWithin1OfAverage >= iMMLWithTargets * 0.8 or (iMaxTimeUntilReady - iMinTimeUntilReady) <= 1.4 then
                                --Dont want to synchronise as either already synchronised or have lots of MML that havent fired in a while
                                if bDebugMessages == true then LOG(sFunctionRef..': Will enable all MML weapons') end
                                for iUnit, oUnit in tMMLWithNearbyTargets do
                                    M28UnitInfo.EnableUnitWeapon(oUnit) --In addition to separate logic that will enable, as want to enable asap once we decide we want to fire)
                                end
                            else
                                --Want to synchronise shots, disable the weapons (they shoudl be reenabled each cycle)
                                if bDebugMessages == true then LOG(sFunctionRef..': Will disable all MML weapons until they are better synchronised, time='..GetGameTimeSeconds()) end
                                for iUnit, oUnit in tMMLWithNearbyTargets do
                                    M28UnitInfo.DisableUnitWeapon(oUnit)
                                end
                            end
                        end
                    end
                end
            else
                --We dont have a nearest enemy to midpoint - if this is because we are ignoring low threat enemies, then send a small number of our available combat units to deal with them
                if not(bGivenCombatUnitsOrders) and bIgnoreEnemiesInThisZone and not(bConsiderEnemiesInAtLeastOneAdjacentZone) then
                    local oEnemyToFocusOn
                    local iClosestEnemyToFocusOn = 100000
                    local iCurEnemyToFocusOnDist

                    local iMaxThreatToAssign =(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 6 + (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 3
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                        for iEnemy, oEnemy in tLZTeamData[M28Map.subrefTEnemyUnits] do
                            iCurEnemyToFocusOnDist = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), tLZData[M28Map.subrefMidpoint])
                            if iCurEnemyToFocusOnDist < iClosestEnemyToFocusOn then
                                iClosestEnemyToFocusOn = iCurEnemyToFocusOnDist
                                oEnemyToFocusOn = oEnemy
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                            local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                            iMaxThreatToAssign = iMaxThreatToAssign + (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 6 + (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 3
                            if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                                for iEnemy, oEnemy in tAdjLZTeamData[M28Map.subrefTEnemyUnits] do
                                    if M28UnitInfo.IsUnitValid(oEnemy) then
                                        iCurEnemyToFocusOnDist = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                        if iCurEnemyToFocusOnDist < iClosestEnemyToFocusOn then
                                            iClosestEnemyToFocusOn = iCurEnemyToFocusOnDist
                                            oEnemyToFocusOn = oEnemy
                                        end
                                    end
                                end
                            end
                        end
                    end
                    if iMaxThreatToAssign > 0 then iMaxThreatToAssign = math.max(iMaxThreatToAssign, 60) end
                    --T2+ indirect fire units - focus on nearby enemy T2 arti if there is any
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
                        for iCurUnit = table.getn(tAvailableCombatUnits), 1, -1 do
                            local oCurUnit = tAvailableCombatUnits[iCurUnit]
                            if (oCurUnit[M28UnitInfo.refiIndirectRange] or 0) >= 45 then
                                local oNearestT2Arti, iCurArtiDist
                                local iNearestT2Arti = 160 --Ignore T2 arti further away than this
                                for iT2Arti, oT2Arti in tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits] do
                                    iCurArtiDist = M28Utilities.GetDistanceBetweenPositions(oT2Arti:GetPosition(), oCurUnit:GetPosition())
                                    if iCurArtiDist <= iNearestT2Arti then
                                        iNearestT2Arti = iCurArtiDist
                                        oNearestT2Arti = oT2Arti
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Negligible enemy threat in this and adjacent zones but enemy has nearby t2 arti, oNearestT2Arti='..(oNearestT2Arti.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestT2Arti) or 'nil')..'; iNearestT2Arti='..iNearestT2Arti..'; IF unit='..oCurUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(iNearestT2Arti)..'; IF range='..(oCurUnit[M28UnitInfo.refiIndirectRange] or 0)) end
                                if oNearestT2Arti then
                                    if iNearestT2Arti <= (oCurUnit[M28UnitInfo.refiIndirectRange] or 0) + 5 then
                                        M28Orders.IssueTrackedGroundAttack(oCurUnit, oNearestT2Arti:GetPosition(), 0.5, false, 'NegT2ArtAG', false, oNearestT2Arti)
                                    else
                                        M28Orders.IssueTrackedAggressiveMove(oCurUnit, oNearestT2Arti:GetPosition(), 0.5, false, 'NegT2ArtAM', false)
                                    end
                                    table.remove(tAvailableCombatUnits, iCurUnit)
                                end
                            end
                        end
                    end

                    if oEnemyToFocusOn then
                        local iCurAssignedThreat = 0
                        for iCurUnit = table.getn(tAvailableCombatUnits), 1, -1 do
                            if tAvailableCombatUnits[iCurUnit][M28UnitInfo.refiUnitMassCost] <= iMaxThreatToAssign or ((tAvailableCombatUnits[iCurUnit][M28UnitInfo.refiDFRange] or 0) > 0 and (EntityCategoryContains(M28UnitInfo.refCategoryLandCombat - categories.EXPERIMENTAL, tAvailableCombatUnits[iCurUnit].UnitId) and M28UnitInfo.GetUnitLifetimeCount(tAvailableCombatUnits[iCurUnit]) > 3)) then
                                iCurAssignedThreat = iCurAssignedThreat + tAvailableCombatUnits[iCurUnit][M28UnitInfo.refiUnitMassCost]
                                --Issue where ythotha stuck not firing at mex, dist away was 4, so do a dist of 8 to be safe
                                if bDebugMessages == true then LOG(sFunctionRef..': dist to oEnemyToFocusOn='..M28Utilities.GetDistanceBetweenPositions(tAvailableCombatUnits[iCurUnit]:GetPosition(),oEnemyToFocusOn:GetPosition())) end
                                if M28Utilities.GetDistanceBetweenPositions(tAvailableCombatUnits[iCurUnit]:GetPosition(),oEnemyToFocusOn:GetPosition()) <= 8 and (not(tAvailableCombatUnits[iCurUnit][M28UnitInfo.refbLastShotBlocked]) or GetGameTimeSeconds() - (tAvailableCombatUnits[iCurUnit][M28UnitInfo.refiLastWeaponEvent] or 0) > math.max(2, (tAvailableCombatUnits[iCurUnit][M28UnitInfo.refiTimeBetweenDFShots] or 2))) then
                                    M28Orders.IssueTrackedAggressiveMove(tAvailableCombatUnits[iCurUnit], oEnemyToFocusOn:GetPosition(), 5, false, 'NegMZAM'..iLandZone, false)
                                else
                                    M28Orders.IssueTrackedMove(tAvailableCombatUnits[iCurUnit], oEnemyToFocusOn:GetPosition(), 5, false, 'NegMZAC'..iLandZone, false)
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Assigned available combat unit '..tAvailableCombatUnits[iCurUnit].UnitId..M28UnitInfo.GetUnitLifetimeCount(tAvailableCombatUnits[iCurUnit])..' to deal with threats in this and adjacent zones, iCurAssignedThreat='..iCurAssignedThreat..'; iMaxThreatToAssign='..iMaxThreatToAssign..'; oEnemyToFocusOn='..oEnemyToFocusOn.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToFocusOn)) end
                                table.remove(tAvailableCombatUnits, iCurUnit)
                                if iCurAssignedThreat >= iMaxThreatToAssign then break end
                            end
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to run from firebase or long range enemy threat, bRunFromFirebase='..tostring(bRunFromFirebase)..'; Nearby enemy long range threat='..(tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0)..'; Zone combat total='..(tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; bGivenCombatUnitsOrders='..tostring(bGivenCombatUnitsOrders)) end
    if not(bGivenCombatUnitsOrders) and M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
        if (not(bSuicideIntoFatboyOrACU) or not(oClosestFatboyOrACUInIslandToSuicideInto)) and (bRunFromFirebase or bRunFromEnemyAir or ((tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] > math.max(100, tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]) and tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] > iAvailableCombatUnitThreat * 2 and not(bIgnoreEnemiesInThisZone and not(bConsiderEnemiesInAtLeastOneAdjacentZone))))) then
            local bConsiderAttackMoveIfClose = false
            local bContinue
            local iLongRangeAlliedThreshold = 50 --units with a combat range of at least this should still consider being aggressive
            local toEnemiesWithSimilarCombatRange = {}
            local toShorterRangeEnemies = {}
            local iDistUntilInRangeOfEnemyToConsiderAttacking
            local iCurDistUntilEnemyInRange, iCurDist
            local iMobileAdjust = 15 --Mobile units are assumed to be this much closer
            local toAdjacentEnemyMexes
            if tLZTeamData[M28Map.subrefLZAllyBestCombatRange] >= 50 then
                local iNearbyEnemyRangeThreshold = 44
                function UpdateForLongerRangeEnemiesInZone(tCurLZTeamData, bUpdateShorterRangeEnemies)
                    if bUpdateShorterRangeEnemies or tCurLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] > iNearbyEnemyRangeThreshold or tCurLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] > iNearbyEnemyRangeThreshold or tCurLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] > iNearbyEnemyRangeThreshold then
                        for iUnit, oUnit in tCurLZTeamData[M28Map.subrefTEnemyUnits] do
                            if not(oUnit.Dead) then
                                if oUnit[M28UnitInfo.refiCombatRange] >= iNearbyEnemyRangeThreshold then
                                    table.insert(toEnemiesWithSimilarCombatRange, oUnit)
                                elseif bUpdateShorterRangeEnemies and (oUnit[M28UnitInfo.refiCombatRange] or 0) >= 6 then
                                    table.insert(toShorterRangeEnemies, oUnit)
                                end
                            end
                        end
                    end
                end
                UpdateForLongerRangeEnemiesInZone(tLZTeamData, true)
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        UpdateForLongerRangeEnemiesInZone(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam])
                    end
                end
                --Also include long rnage threats
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats]) == false then
                    for iUnit, oUnit in tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats] do
                        table.insert(toEnemiesWithSimilarCombatRange, oUnit)
                    end
                end
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeIFThreats]) == false then
                    for iUnit, oUnit in tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeIFThreats] do
                        table.insert(toEnemiesWithSimilarCombatRange, oUnit)
                    end
                end
                toAdjacentEnemyMexes = GetMexesInThisOrAdjacentLandZone(tLZData, tLZTeamData, iTeam, iPlateau) --only includes mexes in this zone and adjcaent if we have intel of them (so that we know we can hit them from far away)
            end

            if M28Utilities.GetDistanceBetweenPositions(tRallyPoint, tLZData[M28Map.subrefMidpoint]) <= 30 then bConsiderAttackMoveIfClose = true end
            for iUnit, oUnit in tAvailableCombatUnits do --Only retreat units from this LZ
                if oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone then
                    --Experimental units who are in range of an enemy experimental unit - dont retreat
                    bContinue = true
                    if (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) >= 10000 then
                        if bDebugMessages == true then LOG(sFunctionRef..': About to check for manual attack target, oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase) or 'nil')) end
                        if not(oNearestEnemyToFriendlyBase) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                            oNearestEnemyToFriendlyBase = M28Utilities.GetNearestUnit(tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit:GetPosition(), false, nil)
                        end
                        if oNearestEnemyToFriendlyBase then
                            local oTargetToManuallyAttack, bMoveNotManualAttack = GetManualAttackTargetIfWantManualAttack(oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with an experimental unit, will see if we want to do manual attack isntead of retreating, oTargetToManuallyAttack='..(oTargetToManuallyAttack.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTargetToManuallyAttack) or 'nil')..'; Target combaty range='..(oTargetToManuallyAttack[M28UnitInfo.refiCombatRange] or 'nil')..'; Our combat range='..(oUnit[M28UnitInfo.refiCombatRange] or 'nil')) end
                            if oTargetToManuallyAttack and (not(oUnit[M28UnitInfo.refbCanKite]) or (oTargetToManuallyAttack[M28UnitInfo.refiCombatRange] or 0) >= (oUnit[M28UnitInfo.refiCombatRange] or 0)) then
                                bContinue = false
                                if bMoveNotManualAttack then
                                    M28Orders.IssueTrackedMove(oUnit, oTargetToManuallyAttack:GetPosition(), 3, false, 'ExpRetrSuicM')
                                else
                                    M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'ExpRetrSuicA')
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering relevance of longer ranged logic to attack nearest enemy instead of treating, unit combat range='..oUnit[M28UnitInfo.refiCombatRange]..'; Is oNearestEnemyToFriendlyBase nil='..tostring(oNearestEnemyToFriendlyBase == nil)..'; Time since last weapon event='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0)..'; Time between DF shots='..( oUnit[M28UnitInfo.refiTimeBetweenDFShots] or 'nil')..'; Time between IF shots='..(oUnit[M28UnitInfo.refiTimeBetweenIFShots] or 'nil')) end
                    if oUnit[M28UnitInfo.refiCombatRange] > iLongRangeAlliedThreshold and bContinue and (not(oUnit[M28UnitInfo.refiLastWeaponEvent]) or ((oUnit[M28UnitInfo.refiDFRange] or 0) > iLongRangeAlliedThreshold and GetGameTimeSeconds() - oUnit[M28UnitInfo.refiLastWeaponEvent] >= oUnit[M28UnitInfo.refiTimeBetweenDFShots] * 0.7) or ((oUnit[M28UnitInfo.refiIndirectRange] or 0) > iLongRangeAlliedThreshold and GetGameTimeSeconds() - oUnit[M28UnitInfo.refiLastWeaponEvent] >= oUnit[M28UnitInfo.refiTimeBetweenIFShots] * 0.7)) then
                        --Determine nearest enemy to friendly base if havent already
                        if not(oNearestEnemyToFriendlyBase) then
                            local iClosestDistToFriendlyBase = 1000
                            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                                for iEnemy, oEnemy in tLZTeamData[M28Map.subrefTEnemyUnits] do
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                                    if iCurDist < iClosestDistToFriendlyBase then
                                        oNearestEnemyToFriendlyBase = oEnemy
                                        iClosestDistToFriendlyBase = iCurDist
                                    end
                                end
                            elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                                for iEnemy, oEnemy in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                                    if iCurDist < iClosestDistToFriendlyBase then
                                        oNearestEnemyToFriendlyBase = oEnemy
                                        iClosestDistToFriendlyBase = iCurDist
                                    end
                                end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Cant find nearby enemy, so strange we want to run') end
                            end
                        end
                        if oNearestEnemyToFriendlyBase then
                            --Long ranged units - if we think we can attack the nearest enemy to us without getting close to being in range of the enemy firebase or fatboy then also attack
                            --Check we have intel of nearest enemy, or if not that we are closer to an enemy mex than the nearest enemy
                            if bDebugMessages == true then LOG(sFunctionRef..': Checking to see if we outrange nearest enemy to ignore retreat order, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)) end
                            local bHaveVisibilityOfEnemy = M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oNearestEnemyToFriendlyBase)
                            local oEnemyToConsiderOverride
                            --Dont use closetoenemy check as are doing combatrange not df range
                            iDistUntilInRangeOfEnemyToConsiderAttacking = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition())

                            if not(bHaveVisibilityOfEnemy) and M28Utilities.IsTableEmpty(toAdjacentEnemyMexes) == false then
                                local iAdjustForMexDist = oUnit[M28UnitInfo.refiCombatRange] - oNearestEnemyToFriendlyBase[M28UnitInfo.refiCombatRange] - 5
                                for iMex, oMex in toAdjacentEnemyMexes do
                                    if M28Utilities.GetDistanceBetweenPositions(oMex:GetPosition(), oUnit:GetPosition()) + iAdjustForMexDist <= iDistUntilInRangeOfEnemyToConsiderAttacking then
                                        iAdjustForMexDist = 0
                                        oEnemyToConsiderOverride = oMex
                                        iDistUntilInRangeOfEnemyToConsiderAttacking = M28Utilities.GetDistanceBetweenPositions(oMex:GetPosition(), oUnit:GetPosition())
                                        bHaveVisibilityOfEnemy = true
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': bHaveVisibilityOfEnemy='..tostring(bHaveVisibilityOfEnemy or false)..'; oEnemyToConsiderOverride='..(oEnemyToConsiderOverride.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEnemyToConsiderOverride) or 'nil')) end
                            if bHaveVisibilityOfEnemy then
                                iDistUntilInRangeOfEnemyToConsiderAttacking = iDistUntilInRangeOfEnemyToConsiderAttacking - oUnit[M28UnitInfo.refiCombatRange]
                                if bDebugMessages == true then LOG(sFunctionRef..': iDistUntilInRangeOfEnemyToConsiderAttacking='..iDistUntilInRangeOfEnemyToConsiderAttacking) end
                                if iDistUntilInRangeOfEnemyToConsiderAttacking > -3 then
                                    --We arent in range of an enemy that we outrange yet, so check who the closest enemy is, and if htey will get in range of us before we get in range of the enemy to consider attacking
                                    local iDistUntilInRangeOfGoodRangedEnemyWithMobileAdjustment = 1000
                                    if M28Utilities.IsTableEmpty(toEnemiesWithSimilarCombatRange) == false then
                                        for iEnemy, oEnemy in toEnemiesWithSimilarCombatRange do
                                            iCurDistUntilEnemyInRange = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition()) - oEnemy[M28UnitInfo.refiCombatRange]
                                            if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then iCurDistUntilEnemyInRange = iCurDistUntilEnemyInRange - iMobileAdjust end
                                            if iCurDistUntilEnemyInRange < iDistUntilInRangeOfGoodRangedEnemyWithMobileAdjustment then
                                                iDistUntilInRangeOfGoodRangedEnemyWithMobileAdjustment = iCurDistUntilEnemyInRange
                                                if iDistUntilInRangeOfGoodRangedEnemyWithMobileAdjustment < iDistUntilInRangeOfEnemyToConsiderAttacking then break end
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': iDistUntilInRangeOfGoodRangedEnemyWithMobileAdjustment='..iDistUntilInRangeOfGoodRangedEnemyWithMobileAdjustment) end
                                    if iDistUntilInRangeOfGoodRangedEnemyWithMobileAdjustment > 4 and iDistUntilInRangeOfGoodRangedEnemyWithMobileAdjustment > iDistUntilInRangeOfEnemyToConsiderAttacking + 4 then
                                        --We arent in range of enemy combat units; Check if there are any enemy combat units that are close to being in our range
                                        local bInRangeOfShorterRangedEnemy = false
                                        if M28Utilities.IsTableEmpty(toShorterRangeEnemies) == false then
                                            for iEnemy, oEnemy in toShorterRangeEnemies do
                                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())
                                                iCurDistUntilEnemyInRange = iCurDist - oEnemy[M28UnitInfo.refiCombatRange]
                                                if iCurDistUntilEnemyInRange <= 12 then
                                                    bInRangeOfShorterRangedEnemy = true
                                                    break
                                                elseif iCurDist - oUnit[M28UnitInfo.refiCombatRange] < iDistUntilInRangeOfEnemyToConsiderAttacking then
                                                    if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oEnemy.UnitId) or iCurDist - oUnit[M28UnitInfo.refiCombatRange] < iDistUntilInRangeOfEnemyToConsiderAttacking - 5 then
                                                        oEnemyToConsiderOverride = oEnemy
                                                        iDistUntilInRangeOfEnemyToConsiderAttacking = iCurDist - oUnit[M28UnitInfo.refiCombatRange]
                                                    end
                                                end
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': bInRangeOfShorterRangedEnemy='..tostring(bInRangeOfShorterRangedEnemy or false)) end
                                        if not(bInRangeOfShorterRangedEnemy) then
                                            --We want to attack the nearest enemy
                                            bContinue = false
                                            if iDistUntilInRangeOfEnemyToConsiderAttacking <= 3 then
                                                M28Orders.IssueTrackedAttack(oUnit, (oEnemyToConsiderOverride or oNearestEnemyToFriendlyBase), false, 'RetrAtck', false)
                                            else
                                                M28Orders.IssueTrackedAggressiveMove(oUnit, (oEnemyToConsiderOverride or oNearestEnemyToFriendlyBase)[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 5, false, 'RetrAtM', false)
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Normally woudl retreat but we want to try and attack the nearest enemy instead, iDistUntilInRangeOfEnemyToConsiderAttacking='..iDistUntilInRangeOfEnemyToConsiderAttacking..'; oEnemyToConsiderOverride='..(oEnemyToConsiderOverride.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEnemyToConsiderOverride) or 'nil')) end
                                        end
                                    end
                                end
                            end
                        end
                    end

                    --If we have recently been given a short range target, or are almost in range of the target, then we may have moved into this zone temporarily, in which case continue with attacking the target
                    if bDebugMessages == true then LOG(sFunctionRef..': is oUnit[refoSREnemyTarget] valid='..tostring(M28UnitInfo.IsUnitValid(oUnit[refoSREnemyTarget]))..'; refiTimeOfSREnemyTarget='..(oUnit[refiTimeOfSREnemyTarget] or 'nil')..'; unit df range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; time='..GetGameTimeSeconds()..'; bContinue='..tostring(bContinue)..'; oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase) or 'nil')) end
                    if bContinue then
                        if M28UnitInfo.IsUnitValid(oUnit[refoSREnemyTarget]) and oUnit[refiTimeOfSREnemyTarget] and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) and not(oUnit[M28UnitInfo.refbScoutCombatOverride]) and (GetGameTimeSeconds() - oUnit[refiTimeOfSREnemyTarget] <= 20 or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[refoSREnemyTarget]:GetPosition()) <= (oUnit[M28UnitInfo.refiDFRange] or 0) + 10) then
                            if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnit.UnitId) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[refoSREnemyTarget]:GetPosition()) <= (oUnit[M28UnitInfo.refiDFRange] or 0) - 10 then
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oUnit[refoSREnemyTarget]:GetPosition(), 6, false, 'SRHistAT'..iLandZone)
                            else
                                M28Orders.IssueTrackedMove(oUnit, oUnit[refoSREnemyTarget]:GetPosition(), 6, false, 'SRHistMT'..iLandZone)
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                            if bConsiderAttackMoveIfClose and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tAmphibiousRallyPoint) <= 30 then
                                M28Orders.IssueTrackedAggressiveMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AFBARetr'..iLandZone)
                            else
                                M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AFBMRetr'..iLandZone)
                            end
                        else
                            if bConsiderAttackMoveIfClose and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint) <= 30 then
                                M28Orders.IssueTrackedAggressiveMove(oUnit, tRallyPoint, 6, false, 'FBARetr'..iLandZone)
                            else
                                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'FBRetr'..iLandZone)
                            end
                        end
                    end
                else
                    --Clear unit assignment value so it is used by other zones
                    oUnit[refiCurrentAssignmentValue] = 0
                end
            end
        else --if not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) then --Done via separate if condition instead of else as we might set this to false if we couldnt find a nearest enemy in the above logic
            --Split units available to reinforce into DF and indirect fire units
            local tDFUnits = {}
            local tIndirectUnits = {}
            for iUnit, oUnit in tAvailableCombatUnits do
                if oUnit[M28UnitInfo.refiDFRange] > 0 then
                    table.insert(tDFUnits, oUnit)
                elseif oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                    table.insert(tIndirectUnits, oUnit)
                else
                    M28Utilities.ErrorHandler('Combat unit with no DF or indirect range')
                end
            end

            --DF units - suicide into fatboy if was one
            if M28Utilities.IsTableEmpty(tDFUnits) == false and bSuicideIntoFatboyOrACU and oClosestFatboyOrACUInIslandToSuicideInto then
                RecordDFLandZoneTarget(oClosestFatboyOrACUInIslandToSuicideInto[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2], M28Map.subrefiLZTAttackingUnit)
                for iUnit, oUnit in tDFUnits do
                    M28Orders.IssueTrackedMove(oUnit, oClosestFatboyOrACUInIslandToSuicideInto:GetPosition(), 6, false, 'LRFBSuic'..iLandZone)
                end
                tDFUnits = {}
            end

            --Indirect special 'bombardment' type logic against nearby different plateaus
            if M28Utilities.IsTableEmpty(tIndirectUnits) == false then
                if M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]) then
                    local tOrderPosition = tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]:GetPosition()
                    for iUnit, oUnit in tIndirectUnits do
                        --Note - issue on maps like air wars - the range factors in height so if the target plateau is very far away it can lead to strange results
                        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOrderPosition) > oUnit[M28UnitInfo.refiIndirectRange] - 1 then
                            M28Orders.IssueTrackedAggressiveMove(oUnit, tOrderPosition, 3, false, 'InPlBom', false)
                        else
                            M28Orders.IssueTrackedGroundAttack(oUnit, tOrderPosition, 3, false, 'InPlAGBm', false, tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere])
                        end
                    end
                    tIndirectUnits = {}
                elseif tLZTeamData[M28Map.refbEnemiesInNearbyPlateau] and iFriendlyBestMobileIndirectRange > 0 then
                    --Check for mobile units within range
                    local oNearestEnemyMobileUnit = GetNearestEnemyInOtherPlateau(iPlateau, tLZData, iTeam)
                    if oNearestEnemyMobileUnit then
                        --Is this unit likely to be reachable by our best indirect fire range unit?
                        local tOrderPosition = oNearestEnemyMobileUnit:GetPosition()
                        local tPotentialFireFromPosition = M28Utilities.MoveInDirection(tOrderPosition, M28Utilities.GetAngleFromAToB(tOrderPosition, tLZData[M28Map.subrefMidpoint]), math.min(iFriendlyBestMobileIndirectRange, M28Utilities.GetDistanceBetweenPositions(tOrderPosition, tLZData[M28Map.subrefMidpoint])), true, false, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have enemy unit in nearby plateau, oNearestEnemyMobileUnit='..oNearestEnemyMobileUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyMobileUnit)..'; iOurBestIndirectRange='..iFriendlyBestMobileIndirectRange..'; tPotentialFireFromPosition='..repru(tPotentialFireFromPosition)..'; Island ref='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tPotentialFireFromPosition) or 'nil')..'; This LZ island ref='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')) end
                        if M28Utilities.IsTableEmpty(tPotentialFireFromPosition) == false and NavUtils.GetLabel(M28Map.refPathingTypeLand, tPotentialFireFromPosition) == (tLZData[M28Map.subrefLZIslandRef] or NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint])) then

                            for iUnit, oUnit in tIndirectUnits do
                                --Note - issue on maps like air wars - the range factors in height so if the target plateau is very far away it can lead to strange results
                                M28Orders.IssueTrackedAggressiveMove(oUnit, tOrderPosition, 3, false, 'InPlMBom', false)
                            end
                            tIndirectUnits = {}
                        end
                    end
                end
            end


            --Do we have adjacent zones wanting reinforcements?
            local iIndirectLZToSupport
            local iDFLZToSupport
            --if M28Utilities.IsTableEmpty(tDFUnits) then iDFLZToSupport = -1 end --set to -1 so not nil so we can ignore checking the threat for indirect/direct respectively
            --(dont set the DFLZ to -1 yet, as we want to support a zone wanting DF units iwth indirect if we have spare indirect
            if M28Utilities.IsTableEmpty(tIndirectUnits) then iIndirectLZToSupport = -1 end

            local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
            if bDebugMessages == true then LOG(sFunctionRef..': Dont have any enemy units in this LZ or adjacent LZ, so will consider supporting other land zones, is tDFUnits empty='..tostring(M28Utilities.IsTableEmpty(tDFUnits))..'; Is adjacent LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]))..'; subrefiNearbyEnemyLongRangeDFThreat='..tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat]) end
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                --If have T2 arti nearby then adjust iIndirectLZToSupport for the closest zone which has units flagging they had shots intercepted, if closer to the firebase than this zone
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false or oNearestFirebaseUnit then
                    if not(oNearestFirebaseUnit) then
                        local iClosestUnit = 10000
                        local iCurDist
                        for iUnit, oUnit in tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits] do
                            if M28UnitInfo.IsUnitValid(oUnit) then
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                if iCurDist < iClosestUnit then
                                    iClosestUnit = iCurDist
                                    oNearestFirebaseUnit = oUnit
                                end
                            end
                        end
                        if oNearestFirebaseUnit then
                            if iClosestUnit >= 10000 then iClosestUnit = M28Utilities.GetDistanceBetweenPositions(oNearestFirebaseUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) end
                            local iClosestZoneWithNoMMLIntercepts
                            local iClosestZoneWithMMLIntercepts
                            local iDistOfClosestNoMMLIntercept = iClosestUnit - 10 --no point moving to an adjacent zone unless it is noticeably closer to the firebase than this zone
                            local iDistOfClosestWithMMLIntercept = iClosestUnit - 10 --no point moving to an adjacent zone unless it is noticeably closer to the firebase than this zone
                            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oNearestFirebaseUnit:GetPosition(), tAdjLZData[M28Map.subrefMidpoint])
                                if iCurDist <= iDistOfClosestNoMMLIntercept or iCurDist <= iDistOfClosestWithMMLIntercept then
                                    local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                                    if GetGameTimeSeconds() - (tAdjLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -100) <= 30 then
                                        iDistOfClosestWithMMLIntercept = iCurDist
                                        iClosestZoneWithMMLIntercepts = iAdjLZ
                                    elseif iCurDist <= iDistOfClosestNoMMLIntercept and tLZTeamData[M28Map.subrefbLZWantsIndirectSupport] then
                                        iDistOfClosestNoMMLIntercept = iCurDist
                                        iClosestZoneWithNoMMLIntercepts = iAdjLZ
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': IF support will prioritise zones nearer to the enemy firebase or t2 arti, iClosestUnit='..iClosestUnit..'; iClosestZoneWithMMLIntercepts='..(iClosestZoneWithMMLIntercepts or 'nil')..'; iClosestZoneWithNoMMLIntercepts='..(iClosestZoneWithNoMMLIntercepts or 'nil')..'; iDistOfClosestWithMMLIntercept='..iDistOfClosestWithMMLIntercept..'; iDistOfClosestNoMMLIntercept='..iDistOfClosestNoMMLIntercept) end
                            if iClosestZoneWithMMLIntercepts then iIndirectLZToSupport = iClosestZoneWithMMLIntercepts
                            elseif iClosestZoneWithNoMMLIntercepts then iIndirectLZToSupport = iClosestZoneWithNoMMLIntercepts  end
                        end
                    end
                end

                local iEnemyStructureThresholdForNegligibleEnemies
                if bIgnoreEnemiesInThisZone and not(bConsiderEnemiesInAtLeastOneAdjacentZone) then
                    iEnemyStructureThresholdForNegligibleEnemies = math.min(1500, M28UnitInfo.GetMassCostOfUnits(tIndirectUnits) * 0.1)
                end
                for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether iLandZone '..iLandZone..' wants to support adjacent LZ iAdjLZ='..iAdjLZ..'; Does it want DF support='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport])..'; Does it want indirect support='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsIndirectSupport])..'; tbAdjacentZoneEnemiesToIgnoreByZone[iAdjLZ]='..tostring(tbAdjacentZoneEnemiesToIgnoreByZone[iAdjLZ] or false)) end
                    if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMidpoint])) then
                        if not(iIndirectLZToSupport) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsIndirectSupport] then
                            if tbAdjacentZoneEnemiesToIgnoreByZone[iAdjLZ] and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefThreatEnemyStructureTotalMass] < iEnemyStructureThresholdForNegligibleEnemies then
                                --Do nothing - dont want to support as we shouldve already sent units to deal with any enemies as part of above logic
                            else
                                iIndirectLZToSupport = iAdjLZ
                                if iDFLZToSupport or M28Utilities.IsTableEmpty(tDFUnits) then break end
                            end
                        end
                        if not(iDFLZToSupport) and (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport]) then
                            if tbAdjacentZoneEnemiesToIgnoreByZone[iAdjLZ] then
                                --Do nothing - dont want to support as we shouldve already sent units to deal with any enemies as part of above logic
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to ignore this zone as shouldve already sent enough units to deal with the threat') end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': iAdjLZ '..iAdjLZ..' wants DF support so will support here') end
                                iDFLZToSupport = iAdjLZ
                                if  iIndirectLZToSupport then break end
                            end
                        end
                    end
                end
            end

            if iIndirectLZToSupport and not(iDFLZToSupport) and M28Utilities.IsTableEmpty(tDFUnits) then iDFLZToSupport = -1 end
            if bDebugMessages == true then LOG(sFunctionRef..': iDFLZToSupport after initial check='..(iDFLZToSupport or 'nil')..'; iIndirectLZToSupport after initial check='..(iIndirectLZToSupport or 'nil')) end
            if not(iIndirectLZToSupport) or not(iDFLZToSupport) then
                --Are there any further away LZs on this plateau that want support?
                local iClosestLZDFDist = 100000
                local iCurDist
                local iClosestLZIndirectDist = 100000
                local iClosestDFLZRef
                local iClosestIndirectLZRef
                local iMinEnemyValueToAttack = iAvailableCombatUnitThreat * 0.1
                local tiIndirectLZWithNegligibleEnemies = {}
                local tiDFLZWithNegligibleEnemies = {}

                if M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau] then
                    local iIslandWanted = tLZData[M28Map.subrefLZIslandRef]
                    for iOtherLZ, bWantsSupport in M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau] do
                        if bWantsSupport and not(iOtherLZ == iLandZone) and not(tbAdjacentZoneEnemiesToIgnoreByZone[iOtherLZ]) then
                            local tOtherLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ]
                            if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tOtherLZData[M28Map.subrefMidpoint])) then
                                if iIslandWanted == tOtherLZData[M28Map.subrefLZIslandRef] then --If in dif island then want to leave for the amphibious logic later
                                    --Check not negligible value
                                    if (tOtherLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefThreatEnemyStructureTotalMass] or 0) + (tOtherLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] or 0) >= iMinEnemyValueToAttack then
                                        if not(iDFLZToSupport) and tOtherLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport] then
                                            --Redundancy - if we cant path using land units then treat distance as 10k + straight line distance, so we prioritise locations that are land pathable (although ideally wouldnt have any such zones anyway?)
                                            iCurDist = (M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iOtherLZ) or 10000) --M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefMidpoint])
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to support iOtherLZ '..iOtherLZ..'; iCurDist='..iCurDist..'; iClosestLZDFDist='..iClosestLZDFDist..'; straight line dist from our start='..M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam][M28Map.reftClosestFriendlyBase], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefMidpoint])) end
                                            if iCurDist >= 10000 and iCurDist < iClosestLZDFDist then iCurDist = iCurDist + M28Utilities.GetDistanceBetweenPositions(tOtherLZData[M28Map.subrefMidpoint], tLZData[M28Map.subrefMidpoint]) end
                                            if iCurDist and iCurDist < iClosestLZDFDist then
                                                iClosestLZDFDist = iCurDist
                                                iClosestDFLZRef = iOtherLZ
                                            end
                                            if not(iIndirectLZToSupport) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsIndirectSupport] then
                                                if iCurDist and iCurDist < iClosestLZIndirectDist then
                                                    iClosestLZIndirectDist = iCurDist
                                                    iClosestIndirectLZRef = iOtherLZ
                                                end
                                            end
                                        elseif not(iIndirectLZToSupport) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsIndirectSupport] then
                                            iCurDist = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iOtherLZ) --M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefMidpoint])
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to support witih indirect iOtherLZ '..iOtherLZ..'; iLandZone='..iLandZone..'; iCurDist='..repru(iCurDist)..'; iClosestLZIndirectDist='..repru(iClosestLZIndirectDist)..'; straight line dist from our start='..M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam][M28Map.reftClosestFriendlyBase], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefMidpoint])) end
                                            if iCurDist and iCurDist < iClosestLZIndirectDist then
                                                iClosestLZIndirectDist = iCurDist
                                                iClosestIndirectLZRef = iOtherLZ
                                            end
                                        end
                                    else
                                        if not(iDFLZToSupport) and tOtherLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport] then
                                            table.insert(tiDFLZWithNegligibleEnemies, iOtherLZ)
                                        end
                                        if not(iIndirectLZToSupport) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsIndirectSupport] then
                                            table.insert(tiIndirectLZWithNegligibleEnemies, iOtherLZ)
                                        end

                                    end
                                end
                            end
                        end
                    end
                end

                if not(iDFLZToSupport) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have no DFLZToSupport, so will set it to iClosestDFLZRef in case that isnt nil, iClosestDFLZRef='..(iClosestDFLZRef or 'nil')) end
                    iDFLZToSupport = iClosestDFLZRef
                end

                --If we have any negligible zones, then send some units to these first and remove them from the table of DF or IF units
                if M28Utilities.IsTableEmpty(tiDFLZWithNegligibleEnemies) == false and M28Utilities.IsTableEmpty(tDFUnits) == false then
                    --Cycle through each zone and assign DF units
                    local iMaxThreatToAssign, iCurAssignedThreat, iMaxExistingAssignedDFThreatToConsider
                    for iEntry, iOtherLZ in tiDFLZWithNegligibleEnemies do
                        --Calc threat to assign
                        local tOtherLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ]
                        local tOtherLZTeamData = tOtherLZData[M28Map.subrefLZTeamData][iTeam]
                        iCurAssignedThreat = 0
                        iMaxThreatToAssign = ((tOtherLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 6 + (tOtherLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0)) * 3
                        iMaxExistingAssignedDFThreatToConsider = math.max(iMaxThreatToAssign * 2, 1300)
                        --First assign any units last assigned to this zone
                        for iCurDFUnit = table.getn(tDFUnits), 1, -1 do
                            if tDFUnits[iCurDFUnit][refiLastNegLZAssignment] == iOtherLZ and tDFUnits[iCurDFUnit][M28UnitInfo.refiUnitMassCost] < iMaxExistingAssignedDFThreatToConsider then
                                iCurAssignedThreat = iCurAssignedThreat + tDFUnits[iCurDFUnit][M28UnitInfo.refiUnitMassCost]
                                M28Orders.IssueTrackedMove(tDFUnits[iCurDFUnit], tOtherLZData[M28Map.subrefMidpoint], 5, false, 'NegZDFX'..iLandZone..'To'..iOtherLZ, false)
                                if bDebugMessages == true then LOG(sFunctionRef..': Already Assigned DF unit '..tDFUnits[iCurDFUnit].UnitId..M28UnitInfo.GetUnitLifetimeCount(tDFUnits[iCurDFUnit])..' to the negligible threat zone '..iOtherLZ..'; iCurAssignedThreat='..iCurAssignedThreat..'; iMaxThreatToAssign='..iMaxThreatToAssign) end
                                table.remove(tDFUnits, iCurDFUnit)
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iCurAssignedThreat='..iCurAssignedThreat..'; iMaxThreatToAssign='..iMaxThreatToAssign..'; iMaxExistingAssignedDFThreatToConsider='..iMaxExistingAssignedDFThreatToConsider) end
                        if iCurAssignedThreat < iMaxThreatToAssign then
                            for iCurDFUnit = table.getn(tDFUnits), 1, -1 do
                                if tDFUnits[iCurDFUnit][M28UnitInfo.refiUnitMassCost] < iMaxThreatToAssign or (EntityCategoryContains(M28UnitInfo.refCategoryLandCombat - categories.EXPERIMENTAL, tDFUnits[iCurDFUnit].UnitId) and M28UnitInfo.GetUnitLifetimeCount(tDFUnits[iCurDFUnit]) > 3) then
                                    iCurAssignedThreat = iCurAssignedThreat + tDFUnits[iCurDFUnit][M28UnitInfo.refiUnitMassCost]
                                    M28Orders.IssueTrackedMove(tDFUnits[iCurDFUnit], tOtherLZData[M28Map.subrefMidpoint], 5, false, 'NegZDFN'..iLandZone..'To'..iOtherLZ, false)
                                    tDFUnits[iCurDFUnit][refiLastNegLZAssignment] = iOtherLZ
                                    if bDebugMessages == true then LOG(sFunctionRef..': Assigned DF unit '..tDFUnits[iCurDFUnit].UnitId..M28UnitInfo.GetUnitLifetimeCount(tDFUnits[iCurDFUnit])..' to the negligible threat zone '..iOtherLZ..'; iCurAssignedThreat='..iCurAssignedThreat..'; iMaxThreatToAssign='..iMaxThreatToAssign) end
                                    table.remove(tDFUnits, iCurDFUnit)
                                    if iCurAssignedThreat >= iMaxThreatToAssign then break end
                                end
                            end
                        end
                    end
                end

                if M28Utilities.IsTableEmpty(tiIndirectLZWithNegligibleEnemies) == false and M28Utilities.IsTableEmpty(tIndirectUnits) == false then
                    --Cycle through each zone and assign DF units
                    local iMaxThreatToAssign, iCurAssignedThreat
                    local bOnlyIncludeStructureThreat = not(M28Utilities.IsTableEmpty(tDFUnits)) --if we still have DF units available then we have already assigned enough DF units to handle the zone by themselves
                    for iEntry, iOtherLZ in tiIndirectLZWithNegligibleEnemies do
                        --Calc threat to assign
                        local tOtherLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ]
                        local tOtherLZTeamData = tOtherLZData[M28Map.subrefLZTeamData][iTeam]
                        iCurAssignedThreat = 0
                        if bOnlyIncludeStructureThreat then
                            iMaxThreatToAssign = (tOtherLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) * 5
                        else
                            iMaxThreatToAssign = ((tOtherLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 2 + (tOtherLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0)) * 5
                        end
                        --First assign any units last assigned to this zone
                        for iCurUnit = table.getn(tIndirectUnits), 1, -1 do
                            if tIndirectUnits[iCurUnit][refiLastNegLZAssignment] == iOtherLZ then
                                iCurAssignedThreat = iCurAssignedThreat + tIndirectUnits[iCurUnit][M28UnitInfo.refiUnitMassCost]
                                M28Orders.IssueTrackedMove(tIndirectUnits[iCurUnit], tOtherLZData[M28Map.subrefMidpoint], 5, false, 'NegZIF'..iLandZone..'To'..iOtherLZ, false)
                                if bDebugMessages == true then LOG(sFunctionRef..': Already Assigned IF unit '..tIndirectUnits[iCurUnit].UnitId..M28UnitInfo.GetUnitLifetimeCount(tIndirectUnits[iCurUnit])..' to the negligible threat zone '..iOtherLZ..'; iCurAssignedThreat='..iCurAssignedThreat..'; iMaxThreatToAssign='..iMaxThreatToAssign) end
                                table.remove(tIndirectUnits, iCurUnit)
                            end
                        end
                        if iCurAssignedThreat < iMaxThreatToAssign then
                            for iCurUnit = table.getn(tIndirectUnits), 1, -1 do
                                if tIndirectUnits[iCurUnit][M28UnitInfo.refiUnitMassCost] < iMaxThreatToAssign then
                                    iCurAssignedThreat = iCurAssignedThreat + tIndirectUnits[iCurUnit][M28UnitInfo.refiUnitMassCost]
                                    M28Orders.IssueTrackedMove(tIndirectUnits[iCurUnit], tOtherLZData[M28Map.subrefMidpoint], 5, false, 'NegZIF'..iLandZone..'To'..iOtherLZ, false)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Assigned IF unit '..tIndirectUnits[iCurUnit].UnitId..M28UnitInfo.GetUnitLifetimeCount(tIndirectUnits[iCurUnit])..' to the negligible threat zone '..iOtherLZ..'; iCurAssignedThreat='..iCurAssignedThreat..'; iMaxThreatToAssign='..iMaxThreatToAssign) end
                                    tIndirectUnits[iCurUnit][refiLastNegLZAssignment] = iOtherLZ
                                    table.remove(tIndirectUnits, iCurUnit)
                                    if iCurAssignedThreat >= iMaxThreatToAssign then break end
                                end
                            end
                        end
                    end
                end


                --If still not found somewhere to support, check for nearby islands wanting support
                if bDebugMessages == true then LOG(sFunctionRef..': Checking for LZs to send DF units to support at time '..GetGameTimeSeconds()..' for LZ '..(iLandZone or 'nil')..' on island '..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..', pre island iDFLZToSupport='..(iDFLZToSupport or 'nil')..'; is pathing to other islands empty='..tostring(tLZData[M28Map.subrefLZPathingToOtherIslands] or false)) end
                if not(iDFLZToSupport) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false and M28Utilities.IsTableEmpty(tDFUnits) == false then
                    --Do we have amphibious or hover units in our available units?
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of amphib combat empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryAmphibiousCombat, tDFUnits)))) end
                    local tAmphibiousDFUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryAmphibiousCombat, tDFUnits)
                    if M28Utilities.IsTableEmpty(tAmphibiousDFUnits) == false then
                        local bConsiderAttackingEnemyBase = false
                        --If enemy has long range threat then consider sending experimentals to attack their base
                        if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure]) == false then
                            local iAmphibiousCombatThreat = M28UnitInfo.GetCombatThreatRating(tAmphibiousDFUnits, false, false)
                            if bDebugMessages == true then LOG(sFunctionRef..': iAmphibiousCombatThreat='..iAmphibiousCombatThreat) end
                            if iAmphibiousCombatThreat >= 19000 then --Monkeylord is 20k
                                --Do we have at least as many land experimentals as the enemy? (otherwise we risk suiciding into their base)
                                local iEnemyExperimentalCount = 0
                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
                                    iEnemyExperimentalCount = table.getn(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals])
                                end
                                if iEnemyExperimentalCount > 0 then
                                    local iFriendlyExperimentalCount = 0
                                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                        iFriendlyExperimentalCount = iFriendlyExperimentalCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandExperimental)
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': iFriendlyExperimentalCount='..iFriendlyExperimentalCount..'; iEnemyExperimentalCount='..iEnemyExperimentalCount) end
                                    if iFriendlyExperimentalCount > iEnemyExperimentalCount then
                                        bConsiderAttackingEnemyBase = true
                                    end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy has no land experimentals so will attack') end
                                    bConsiderAttackingEnemyBase = true
                                end

                            end
                        end
                        local iDistanceThreshold
                        if bConsiderAttackingEnemyBase then
                            iDistanceThreshold = math.max(400, M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) * 1.25)
                        else
                            iDistanceThreshold = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) * 0.75
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': bConsiderAttackingEnemyBase='..tostring(bConsiderAttackingEnemyBase)..'; iDistanceThreshold='..iDistanceThreshold) end

                        for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering island '..tPathingData[M28Map.subrefIslandNumber]..'; tPathingData[M28Map.subrefIslandTravelDist]='..tPathingData[M28Map.subrefIslandTravelDist]..'; iDistanceThreshold='..iDistanceThreshold..'; Does LZ want support='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsSupport])..'; tPathingData[M28Map.subrefIslandClosestLZRef]='..tPathingData[M28Map.subrefIslandClosestLZRef]) end
                            if tPathingData[M28Map.subrefIslandTravelDist] > iDistanceThreshold then break end

                            if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsSupport] then
                                if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea( M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefMidpoint])) then
                                    iDFLZToSupport = tPathingData[M28Map.subrefIslandClosestLZRef]
                                    M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.refbIslandBeachhead] = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will support the closeest LZ ref, iDFLZToSupport='..iDFLZToSupport) end
                                    break
                                end
                            end
                        end
                    end
                end

                if not(iIndirectLZToSupport) then
                    iIndirectLZToSupport = (iClosestIndirectLZRef or iDFLZToSupport)
                end
            end

            if iDFLZToSupport > 0 and M28Utilities.IsTableEmpty(tDFUnits) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to support LZ '..iDFLZToSupport..'; Will adjust DF to get via point if it is far away; midpoint of iDFToSupport='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iDFLZToSupport][M28Map.subrefMidpoint])..'; Midpoint of this LZ='..repru(tLZData[M28Map.subrefMidpoint])) end
                iDFLZToSupport = ReviseTargetLZIfFarAway(tLZData, iTeam, iPlateau, iLandZone, iDFLZToSupport, 2)
                RecordDFLandZoneTarget(iDFLZToSupport, M28Map.subrefiLZTMovingToOtherZone)
                if bDebugMessages == true then LOG(sFunctionRef..': iDFLZToSupport after revising target for far away LZ='..iDFLZToSupport..'; Midpoint of this zone='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iDFLZToSupport][M28Map.subrefMidpoint])) end

                for iUnit, oUnit in tDFUnits do
                    --Remove assignment value if the unit isnt part of this zone
                    if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                        oUnit[refiCurrentAssignmentValue] = 0
                    else
                        --Attack-move if very long range (unless negligible nearby enemy threat)
                        if (oUnit[M28UnitInfo.refiDFRange] >= 60 and (not(oUnit[M28UnitInfo.refbLastShotBlocked]) or oUnit[M28UnitInfo.refiDFRange] >= 130)) or (oUnit[M28UnitInfo.refiDFMinRange] or 0) >= 20 then
                            --jericho - workaround for attackmove not working
                            if not(oUnit.UnitId == 'xnl0403') or DontHaveJerichoAttackTarget(oUnit) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will send unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' towards iDFLZToSupport='..iDFLZToSupport..' (unless ignoring due to being stuck)') end
                                if GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0) <= 10 and M28Conditions.HaveSignificantEnemyThreatWithinRange(tLZData, tLZTeamData, iPlateau, iTeam, oUnit[M28UnitInfo.refiDFRange] + 3, oUnit:GetPosition(), 1500, M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryT2PlusPD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryNavalSurface - categories.TECH1 + categories.COMMAND, tUnitsNearFatboyInFurtherAwayZones) then
                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iDFLZToSupport][M28Map.subrefMidpoint], 6, false, 'DFAMvLZ'..iDFLZToSupport..';'..iLandZone)
                                    end
                                else
                                    --Negligible enemy threat so just move
                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                        M28Orders.IssueTrackedMove(oUnit, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iDFLZToSupport][M28Map.subrefMidpoint], 6, false, 'DFXMvLZ'..iDFLZToSupport..';'..iLandZone)
                                    end
                                end
                            end
                        else
                            if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                if bDebugMessages == true then LOG('About to issue tracked moved to unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Special micro active='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive])) end
                                M28Orders.IssueTrackedMove(oUnit, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iDFLZToSupport][M28Map.subrefMidpoint], 6, false, 'DFMovLZ'..iDFLZToSupport..';'..iLandZone)
                            end
                        end
                    end
                end
                tDFUnits = nil
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Deciding where to send IF units, iIndirectLZToSupport='..(iIndirectLZToSupport or 'nil')..'; is table of IF units empty='..tostring(M28Utilities.IsTableEmpty(M28Utilities.IsTableEmpty(tIndirectUnits)))) end
            if iIndirectLZToSupport > 0 and M28Utilities.IsTableEmpty(tIndirectUnits) == false then
                iIndirectLZToSupport = ReviseTargetLZIfFarAway(tLZData, iTeam, iPlateau, iLandZone, iIndirectLZToSupport, 2)
                --Attack-move if nearby enemy T2 arti (as had scenario where longer ranged IF unit moved towards enemy T2 arti when the arti was in its range)
                local bConsiderAttackMoveForNearbyUnits = not(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits])) or not(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats]))
                local oLRUnitToAttackInstead
                local iLRRangeThreshold, iDistUntilInRangeOfClosestLREnemy, iCurDistUntilInRange
                if bConsiderAttackMoveForNearbyUnits then iLRRangeThreshold = 8 end

                function UpdateLongRangeUnitToAttackInstead(oUnit)
                    oLRUnitToAttackInstead = nil
                    if oUnit[M28UnitInfo.refiCombatRange] > 0 then --redundancy
                        iDistUntilInRangeOfClosestLREnemy = iLRRangeThreshold
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
                            for iEnemy, oEnemy in tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits] do
                                iCurDistUntilInRange = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition()) - oUnit[M28UnitInfo.refiCombatRange]
                                if bDebugMessages == true then LOG(sFunctionRef..': dist until oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is in range of oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'is iCurDistUntilInRange='..iCurDistUntilInRange) end
                                if  iCurDistUntilInRange < iDistUntilInRangeOfClosestLREnemy then
                                    iDistUntilInRangeOfClosestLREnemy = iCurDistUntilInRange
                                    oLRUnitToAttackInstead = oEnemy
                                end
                            end
                        end
                        if iDistUntilInRangeOfClosestLREnemy > 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats]) == false then
                            for iEnemy, oEnemy in tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats] do
                                iCurDistUntilInRange = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition()) - oUnit[M28UnitInfo.refiCombatRange]
                                if bDebugMessages == true then LOG(sFunctionRef..': dist until oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is in range of oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'is iCurDistUntilInRange='..iCurDistUntilInRange) end
                                if  iCurDistUntilInRange < iDistUntilInRangeOfClosestLREnemy then
                                    iDistUntilInRangeOfClosestLREnemy = iCurDistUntilInRange
                                    oLRUnitToAttackInstead = oEnemy
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': oLRUnitToAttackInstead after check='..(oLRUnitToAttackInstead.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oLRUnitToAttackInstead) or 'nil')) end
                end
                for iUnit, oUnit in tIndirectUnits do
                    if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is in a different zone to this so will set its asisgnment value to 0 so it can be assigned by that zone') end
                        oUnit[refiCurrentAssignmentValue] = 0
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Do we want to ignore orders due to having a stuck unit? oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Ignore due to stuck unit='..tostring(IgnoreOrderDueToStuckUnit(oUnit) or false)) end
                        if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                            if bConsiderAttackMoveForNearbyUnits then UpdateLongRangeUnitToAttackInstead(oUnit) end
                            if oLRUnitToAttackInstead then
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oLRUnitToAttackInstead:GetPosition(), 6, false, 'IFMvAtLR'..iLandZone)
                            else
                                M28Orders.IssueTrackedMove(oUnit, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iIndirectLZToSupport][M28Map.subrefMidpoint], 6, false, 'IFMovLZ'..iIndirectLZToSupport..';'..iLandZone)
                            end
                        end
                    end
                end
                tIndirectUnits = nil
            end
            local tRemainingLandUnits = {}
            if M28Utilities.IsTableEmpty(tDFUnits) == false then
                for iUnit, oUnit in tDFUnits do
                    table.insert(tRemainingLandUnits, oUnit)
                end
            end
            if M28Utilities.IsTableEmpty(tIndirectUnits) == false then
                for iUnit, oUnit in tIndirectUnits do
                    table.insert(tRemainingLandUnits, oUnit)
                end
            end
            if M28Utilities.IsTableEmpty(tRemainingLandUnits) == false then
                --Search for a zone with enemy units and attack it, if there is one
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                    for iEntry, tSubtable in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                        local tCurZoneTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                        if M28Utilities.IsTableEmpty(tCurZoneTeamData[M28Map.subrefTEnemyUnits]) == false then
                            local tCurLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefLZNumber]]
                            if not(tLZTeamData[M28Map.subreftiLandZoneTargetedByOurDF]) then --Only record if we havent already recorded above (or else we will end up overriding cur zone target); not sure if such a scenario could arise but best to be safe
                                RecordDFLandZoneTarget(tSubtable[M28Map.subrefLZNumber], M28Map.subrefiLZTMovingToOtherZone)
                            end
                            for iUnit, oUnit in tRemainingLandUnits do
                                if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                                    oUnit[refiCurrentAssignmentValue] = 0
                                else
                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                        M28Orders.IssueTrackedMove(oUnit, tCurLZData[M28Map.subrefMidpoint], 6, false, 'BkMvLZ'..tSubtable[M28Map.subrefLZNumber]..';'..iLandZone)
                                    end
                                end
                            end
                            tRemainingLandUnits = nil
                            break
                        end
                    end

                    if M28Utilities.IsTableEmpty(tRemainingLandUnits) == false then

                        if NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint]) then
                            if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZTeamData[M28Map.reftClosestEnemyBase])) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will send all land units to closest enemy base') end
                                for iUnit, oUnit in tRemainingLandUnits do
                                    if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                                        oUnit[refiCurrentAssignmentValue] = 0
                                    else
                                        if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                            M28Orders.IssueTrackedMove(oUnit, tLZTeamData[M28Map.reftClosestEnemyBase], 6, false, 'MTDEnB'..iLandZone)
                                        end
                                    end
                                end
                            end
                        end
                        if tRemainingLandUnits then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have remaining land units with nowhere to go, is pathing of closest enemy base same as pathing of this land zone? enemy base land label='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) or 'nil')..'; label of this zone='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint]) or 'nil')..'; Is table of units empty after considering sending to enemy base='..tostring(M28Utilities.IsTableEmpty(tRemainingLandUnits))) end
                            if M28Utilities.IsTableEmpty(tRemainingLandUnits) == false then
                                --Campaign specific - send to main enemy campaign base
                                if M28Map.bIsCampaignMap and M28Utilities.IsTableEmpty(M28Team.GetEnemyMainCampaignBase(iTeam)) == false and NavUtils.GetLabel(M28Map.refPathingTypeHover, M28Team.GetEnemyMainCampaignBase(iTeam)) == iPlateau then
                                    if NavUtils.GetLabel(M28Map.refPathingTypeLand, M28Team.GetEnemyMainCampaignBase(iTeam)) == tLZData[M28Map.subrefLZIslandRef] then
                                        for iUnit, oUnit in tRemainingLandUnits do
                                            if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                                                oUnit[refiCurrentAssignmentValue] = 0
                                            else
                                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                    M28Orders.IssueTrackedMove(oUnit, M28Team.GetEnemyMainCampaignBase(iTeam), 6, false, 'CmpEnB'..iLandZone)
                                                end
                                            end
                                        end
                                    else
                                        --Do we have any amphibious or hover units?
                                        local tbGivenIndexUnitOrder = {}
                                        for iUnit, oUnit in tRemainingLandUnits do
                                            if EntityCategoryContains(M28UnitInfo.refCategoryAmphibious + categories.HOVER, oUnit.UnitId) then
                                                if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                                                    oUnit[refiCurrentAssignmentValue] = 0
                                                else
                                                    tbGivenIndexUnitOrder[iUnit] = true
                                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                        M28Orders.IssueTrackedMove(oUnit, M28Team.GetEnemyMainCampaignBase(iTeam), 6, false, 'CmpHEnB'..iLandZone)
                                                    end
                                                end
                                            end
                                        end
                                        if M28Utilities.IsTableEmpty(tbGivenIndexUnitOrder) == false then
                                            for iCurUnit = table.getn(tRemainingLandUnits), 1, -1 do
                                                if tbGivenIndexUnitOrder[iCurUnit] then table.remove(tRemainingLandUnits, iCurUnit) end
                                            end
                                        end
                                    end
                                end
                                if M28Utilities.IsTableEmpty(tRemainingLandUnits) == false then
                                    --Can we path to the enemy base with land? if so then send units to it
                                    if NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint]) then
                                        if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZTeamData[M28Map.reftClosestEnemyBase])) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will send all land units to closest enemy base') end
                                            for iUnit, oUnit in tRemainingLandUnits do
                                                if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                                                    oUnit[refiCurrentAssignmentValue] = 0
                                                else
                                                    M28Orders.IssueTrackedMove(oUnit, tLZTeamData[M28Map.reftClosestEnemyBase], 6, false, 'MTDEnB'..iLandZone)
                                                end
                                            end
                                            tRemainingLandUnits = nil
                                        end
                                    end
                                    if tRemainingLandUnits then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have remaining land units with nowhere to go, is pathing of closest enemy base same as pathing of this land zone? enemy base land label='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) or 'nil')..'; label of this zone='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint]) or 'nil')..'; Is table of units empty after considering sending to enemy base='..tostring(M28Utilities.IsTableEmpty(tRemainingLandUnits))) end
                                        if M28Utilities.IsTableEmpty(tRemainingLandUnits) == false then
                                            --Cant go to enemy base, so just follow land scouting path
                                            if bDebugMessages == true then LOG(sFunctionRef..': Follow land scouting path if we have one, is patrol path empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subreftPatrolPath]))) end
                                            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subreftPatrolPath]) == false then
                                                --Patrol the land zone
                                                for iUnit, oUnit in tRemainingLandUnits do
                                                    if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                                                        oUnit[refiCurrentAssignmentValue] = 0
                                                    else
                                                        M28Orders.PatrolPath(oUnit, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subreftPatrolPath], false, 'SP', false, true)
                                                    end
                                                end
                                            else
                                                --Do nothing
                                            end
                                        end
                                    end
                                end
                                --M28Orders.IssueTrackedMove(oUnit, tLZTeamData[M28Map.reftClosestEnemyBase], 6, false, 'MTDEnB'..iLandZone)
                            end
                        end
                    end
                end
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code for iLandZOne '..iLandZone..', bWantReinforcements='..tostring(bWantReinforcements)..'; bWantIndirectReinforcements='..tostring(bWantIndirectReinforcements)) end
    local bWantDFReinforcements = bWantReinforcements
    if bWantReinforcements then
        --Do we want to get indirect fire instead of direct fire as an override?
        if tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] >= 400 then
            local iEnemyStructureThreatTotal = 0
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                    iEnemyStructureThreatTotal = iEnemyStructureThreatTotal + iThreat
                end
            end
            if tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] < tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] * 1.3 then
                --We have enough DF threat, if we want more indirect threat then no longer flag as wanting DF support and instead flag that we want indirect support
                if iEnemyStructureThreatTotal * 1.4 > math.max(50, tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]) then
                    local iDFRatio = tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] / math.max(1, tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal])
                    local iIndirectRatio = math.max(50, tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]) / math.max(iEnemyStructureThreatTotal, 1)
                    if iIndirectRatio < iDFRatio then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want more indirect units due to the ratio of indirect to DF units, iIndirectRatio='..iIndirectRatio..'; iDFRatio='..iDFRatio) end
                        bWantIndirectReinforcements = true
                        --Dont disable requesting DF reinforcements if we may be able to overwhelm with land experimentals
                        if tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] > 5000 and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] > 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will still request DF reinforcements as well though') end
                        else
                            bWantDFReinforcements = false
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking override for reinforcement type, bWantDFReinforcements='..tostring(bWantDFReinforcements)..'; bWantIndirectReinforcements='..tostring(bWantIndirectReinforcements)..'; iEnemyStructureThreatTotal='..iEnemyStructureThreatTotal..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]) end
        end
    end
    if not(bWantIndirectReinforcements) and GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -100) <= 30 then
        if bDebugMessages == true then LOG(sFunctionRef..': It has been '..GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -100)..' since MML were firing near TMD so want more indirect fire so get more MML') end
        bWantIndirectReinforcements = true
    end
    if bWantDFReinforcements and not(bWantIndirectReinforcements) then
        --If we already have higher DF threat than enemy DF threat in this zone, then consider adjacent zones and whether we want some indirect fire threat here
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to change to requesting indirect units, tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]) end
        if tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] > tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] and tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] > tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] then
            local iNearbyEnemyMobileDFThreat = (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)
            local iNearbyEnemyStructureThreat = 0
            if tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] > 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                    iNearbyEnemyStructureThreat = iNearbyEnemyStructureThreat + iThreat
                end
            end
            local iNearbyAllyMobileDFThreat = (tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0)
            local iNearbyAllyMobileIndirectThreat = (tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] or 0)
            function UpdateForAdjacentLZ(tAdjLZTeamData)
                iNearbyEnemyMobileDFThreat = iNearbyEnemyMobileDFThreat + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)
                if tAdjLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] > 0 and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                    for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                        iNearbyEnemyStructureThreat = iNearbyEnemyStructureThreat + iThreat
                    end
                end
                iNearbyAllyMobileDFThreat = iNearbyAllyMobileDFThreat + (tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0)
                iNearbyAllyMobileIndirectThreat = iNearbyAllyMobileIndirectThreat + (tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] or 0)
            end
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                UpdateForAdjacentLZ(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam])
            end
            if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
                for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                    UpdateForAdjacentLZ(M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam])
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': iNearbyEnemyMobileDFThreat='..iNearbyEnemyMobileDFThreat..'; iNearbyEnemyStructureThreat='..iNearbyEnemyStructureThreat..'; iNearbyAllyMobileDFThreat='..iNearbyAllyMobileDFThreat..'; iNearbyAllyMobileIndirectThreat='..iNearbyAllyMobileIndirectThreat) end
            if iNearbyEnemyMobileDFThreat < iNearbyAllyMobileDFThreat and iNearbyAllyMobileIndirectThreat < iNearbyEnemyStructureThreat then
                bWantIndirectReinforcements = true
            end
        end
    end

    --Enemy structure in nearby plateau that we can probably reach

    if bDebugMessages == true then LOG(sFunctionRef..': Checking if want to request indirect reinforcements for dif plateau threat, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; enemies in this or adjacent='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; bWantIndirectReinforcements='..tostring(bWantIndirectReinforcements)..'; Valid structure in other plateau='..tostring(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere])..'; Highest friendly land fac tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]) end
    if not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and not(bWantIndirectReinforcements) and M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3 then
        bWantIndirectReinforcements = M28Conditions.IsNearbyStructureThatWeCanReachWithIndirect(tLZData, tLZTeamData, iTeam)
    end
    if not(bWantIndirectReinforcements) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and (tLZTeamData[M28Map.subrefLZbCoreBase] or tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][2] >= 3) then
        bWantIndirectReinforcements = true
    end

    UpdateIfLandZoneWantsSupport(tLZTeamData, iPlateau, iLandZone, iTeam, bWantDFReinforcements, bWantIndirectReinforcements)
    if bDebugMessages == true then
        LOG(sFunctionRef..': Just recorded if this LZ wants support, bWantDFReinforcements='..tostring(bWantDFReinforcements)..'; bWantIndirectReinforcements='..tostring(bWantIndirectReinforcements)..'; tLZTeamData[M28Map.subrefbLZWantsSupport] = '..tostring(tLZTeamData[M28Map.subrefbLZWantsSupport])..'; tLZTeamData[M28Map.subrefbLZWantsDFSupport]='..tostring(tLZTeamData[M28Map.subrefbLZWantsDFSupport])..'; subreftiLandZoneTargetedByOurDF='..(tLZTeamData[M28Map.subreftiLandZoneTargetedByOurDF] or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RetreatOtherUnits(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tOtherUnitsToRetreat)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RetreatOtherUnits'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2)
    local tAmphibiousRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2, true)
    local iCurTime = math.floor(GetGameTimeSeconds())
    local bConsiderKitingRetreat = tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]
    local oNearestEnemyCombatToRallyPoint
    for iUnit, oUnit in tOtherUnitsToRetreat do
        oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
        --Fatboy (and megalith although wouldnt expect megalith to use this function) - consider retreating slowly instead of running around, and also retreating in opposite direction to the nearest enemy (instead of going to the rally point)
        if bDebugMessages == true then LOG(sFunctionRef..': Considering retreating unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bConsiderKitingRetreat='..tostring(bConsiderKitingRetreat or false)..'; Combat range='..(oUnit[M28UnitInfo.refiCombatRange] or 0)..'; Is a fatboy/mega='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryMegalith, oUnit.UnitId))) end
        if bConsiderKitingRetreat and (oUnit[M28UnitInfo.refiCombatRange] or 0) > 30 and EntityCategoryContains(M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryMegalith, oUnit.UnitId) then
            if not(oNearestEnemyCombatToRallyPoint) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                oNearestEnemyCombatToRallyPoint = M28Utilities.GetNearestUnit(tLZTeamData[M28Map.reftoNearestDFEnemies], tAmphibiousRallyPoint)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': oNearestEnemyCombatToRallyPoint='..(oNearestEnemyCombatToRallyPoint.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyCombatToRallyPoint) or 'nil')) end
            local bDoneKitingRetreat = false
            if oNearestEnemyCombatToRallyPoint then
                local iCurDist = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyCombatToRallyPoint:GetPosition(), oUnit:GetPosition())
                if iCurDist <= oUnit[M28UnitInfo.refiCombatRange] and iCurDist >= math.max(10, (oUnit[M28UnitInfo.refiCombatRange] or 0) - 5) then
                    --Want to consider retreating
                    local iBackupDist = (oUnit:GetBlueprint().Physics.BackUpDistance or 0)
                    if iBackupDist > 3 then
                        local iAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oNearestEnemyCombatToRallyPoint:GetPosition())
                        local iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tAmphibiousRallyPoint)
                        local tRetreatLocationToUse
                        if M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToRally) >= 145 then --i.e. 70 degree section where will go with rally point instead of opposite direction
                            tRetreatLocationToUse = {tAmphibiousRallyPoint[1], tAmphibiousRallyPoint[2], tAmphibiousRallyPoint[3]}
                        else
                            local tPotentialRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToNearestEnemy - 180, iBackupDist - 3, true, nil, M28Map.bIsCampaignMap)
                            if M28Utilities.IsTableEmpty(tPotentialRetreatLocation) == false and NavUtils.GetLabel(M28Map.refPathingTypeHover, tPotentialRetreatLocation) == iPlateau then
                                tRetreatLocationToUse = {tPotentialRetreatLocation[1], tPotentialRetreatLocation[2], tPotentialRetreatLocation[3]}
                            else
                                tRetreatLocationToUse = {tAmphibiousRallyPoint[1], tAmphibiousRallyPoint[2], tAmphibiousRallyPoint[3]}
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try backing up for fatboy or similar unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; tRetreatLocationToUse='..repru(tRetreatLocationToUse)..'; oNearestEnemyCombatToRallyPoint='..oNearestEnemyCombatToRallyPoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyCombatToRallyPoint)) end
                        bDoneKitingRetreat = true
                        ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tRetreatLocationToUse, iPlateau, 'SpFBlsRetr', true, math.min(9, iBackupDist))
                        --M28Orders.IssueTrackedMove(oUnit, tRetreatLocationToUse, 3, false, 'SpFBlsRetr')
                    end
                end
            end
            if not(bDoneKitingRetreat) then
                M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 10, false, 'FMNoERetr')
            end
        elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 10, false, 'AOtRet')
        else
            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 10, false, 'OtRet', false)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordUnitAsReceivingLandZoneAssignment(oUnit, iPlateau, iLandZone, iCurLZValue)
    oUnit[refiCurrentAssignmentValue] = iCurLZValue --This is also updated for units that are part of a separate zone
    oUnit[refiCurrentAssignmentPlateauAndLZ] = {iPlateau, iLandZone}
    oUnit[refiTimeOfLastAssignment] = GetGameTimeSeconds()
    if oUnit[M28Navy.refiCurrentWZAssignmentValue] then
        oUnit[M28Navy.refiCurrentWZAssignmentValue] = nil
        oUnit[M28Navy.refiCurrentAssignmentWaterZone] = nil
    end
end

function ManageSpecificLandZone(aiBrain, iTeam, iPlateau, iLandZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageSpecificLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(aiBrain) or aiBrain.M28IsDefeated then
        --if Brain hasn't died in the last couple of ticks then give error message
        if GetGameTimeSeconds() - (M28Overseer.iTimeLastPlayerDefeat or 0) >= 0.3 then M28Utilities.ErrorHandler('Trying to run M28 logic on a defeated brain') end
        aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        if not(aiBrain) or aiBrain.M28IsDefeated then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return nil
        end
    end

    --Record enemy threat
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]

    --Omni vision AIx - record we have visual of this LZ
    if M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmniVision] then
        tLZTeamData[M28Map.refiTimeLastHadVisual] = GetGameTimeSeconds()
    end

    --Update unit positions and if still valid
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
        --UpdateUnitPositionsAndLandZone(aiBrain, tUnits,                               iTeam, iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
        UpdateUnitPositionsAndLandZone(aiBrain, tLZTeamData[M28Map.subrefTEnemyUnits], iTeam, iPlateau,             iLandZone,          M28Map.bIsCampaignMap, false, tLZTeamData,  false,                      true)
        if bDebugMessages == true then LOG(sFunctionRef..': Just ran updateunitpositions for enemy units in this zone') end
    end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) == false then
        --Update air positions if we have units in the zone or has been a while to approximate a player being able to tell if enemy air force is still there
        local bAlwaysUpdateEnemyAirUnitPositions = M28Map.bIsCampaignMap --campaign map players are more likely to know when air attacks iwll attack and from where
        if bAlwaysUpdateEnemyAirUnitPositions or (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false or GetGameTimeSeconds() - (tLZTeamData[M28Map.refiTimeOfLastAirUpdate] or -100) >= 12 or (M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.reftLZEnemyAirUnits][1]) and M28UnitInfo.CanSeeUnit(aiBrain, tLZTeamData[M28Map.reftLZEnemyAirUnits][1])) or (tLZTeamData[M28Map.refiRadarCoverage] or 0) > 0) then
            if bDebugMessages == true then LOG(sFunctionRef..': Updating air unit positions in the zone') end
            tLZTeamData[M28Map.refiTimeOfLastAirUpdate] = GetGameTimeSeconds()
            --UpdateUnitPositionsAndLandZone(aiBrain, tUnits,                       iTeam, iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
            UpdateUnitPositionsAndLandZone(aiBrain, tLZTeamData[M28Map.reftLZEnemyAirUnits], iTeam, iPlateau, iLandZone, false, true, tLZTeamData, false,                               true)
        else
            --UpdateUnitPositionsAndLandZone(aiBrain, tUnits,                           iTeam, iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
            UpdateUnitPositionsAndLandZone(aiBrain, tLZTeamData[M28Map.reftLZEnemyAirUnits], iTeam, iPlateau, iLandZone,        M28Map.bIsCampaignMap, true, tLZTeamData,   false,                                  true)
        end
    end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        UpdateUnitPositionsAndLandZone(aiBrain, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits], iTeam, iPlateau, iLandZone, false, false, tLZTeamData)
    end

    if bDebugMessages == true then LOG(sFunctionRef..': About to update threat for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; Is LZTeamData empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData))..'; Time='..GetGameTimeSeconds()) end
    RecordGroundThreatForLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone)
    RecordAirThreatForLandZone(tLZTeamData, iTeam, iPlateau, iLandZone)

    tLZTeamData[M28Map.subrefLZTAlliedCombatUnits] = {}
    tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield] = {}
    tLZTeamData[M28Map.refbLZWantsMobileShield] = false --will change later
    tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth] = {}
    tLZTeamData[M28Map.refbLZWantsMobileStealth] = false --will change later
    tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts] = nil --will change later
    tLZTeamData[M28Map.refiSpareLandScouts] = 0

    --Build location tracker
    tLZData[M28Map.subrefSegmentsConsideredThisTick] = 0

    local tEngineers, tScouts, tMobileShields, tMobileStealths, tOtherUnitsToRetreat, tSACUs, tSACUsToGoToWaterZone
    local iCurShield, iMaxShield
    local bLandZoneOrAdjHasUnitsWantingScout = false
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
    local bUpdateEnemyDataHere = true --Will handle this logic in logic for managing land zone units if htis is false

    local bAlliedUnitsHereOrInAdjacentZone = not(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))
    local bHaveCombatUnitsFromAdjZone = false
    if not(bAlliedUnitsHereOrInAdjacentZone) then
        for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
            local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
            bAlliedUnitsHereOrInAdjacentZone = M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if bAlliedUnitsHereOrInAdjacentZone then break end

        end
    end
    if bAlliedUnitsHereOrInAdjacentZone then
        --Decide on what to do with units in this LZ
        tEngineers = {}
        tScouts = {}
        tMobileShields = {}
        tMobileStealths = {}
        tSACUs = {}
        tOtherUnitsToRetreat = {} --Intended for e.g. fatboys and units with personal shield
        local bUseRASInCombat = false
        if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 then bUseRASInCombat = true end
        local tAvailableCombatUnits = {}
        local tUnavailableUnitsInThisLZ = {}
        local tTempOtherUnits = {}
        local tAvailableMAA = {}
        local iCurLZValue = tLZTeamData[M28Map.subrefLZTValue]

        local iOurBestDFRange = 0
        local iOurBestIndirectRange = 0
        local bIncludeUnit
        local iAvailableCombatCount = 0 --used to decide whether to only issue orders to hover units every 6s

        local iEnemyOmniCoverage = M28Conditions.GetEnemyOmniCoverageOfZone(iPlateau, iLandZone, iTeam)

        local iMobileShieldMassThreshold = 150 --When assigning mobile shields will also restrict further so e.g. seraphim mobile shields will have a higher threshold
        --Shield overflow mechanic doesnt exist outside faf so consider shielding weaker units
        if not(M28Utilities.bFAFActive) and tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= 300 then iMobileShieldMassThreshold = 40 end --want to consider shielding t1 units in the zone if we potentially have a decent t1 force
        local iMobileShieldHigherMAAMassThreshold = 400 --for if we have MAA and enemy doesnt have much air threat
        local iMobileStealthMassThreshold = 200 --will get adjusted further
        local iMobileStealthHigherMassThreshold = 500 --i.e. wont stealth loyalists and titans
        local iUnitMassCost, iShieldPercentageAdjust, iCurHealthPercent
        local iMobileStealthLowerThresholdCount = 0 --Used to avoid assigning too many mobile stealth at once to units not exceeding the higher mass threshold
        if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 600 and (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 2000 or tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0) then iMobileShieldHigherMAAMassThreshold = iMobileShieldMassThreshold end
        local bConsiderMobileShieldsForT2Arti = false
        local bConsiderMobileShieldsForT2PD = false
        local tRaiders
        if tLZTeamData[M28Map.subrefLZbCoreBase] then
            if (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false or (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0) > 0) then
                bConsiderMobileShieldsForT2Arti = true
                bConsiderMobileShieldsForT2PD = true
            elseif tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                bConsiderMobileShieldsForT2PD = true
            end

        end

        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            local bConsiderMobileShieldsForBuildingsDueToNovax = false
            if M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] > 0 and tLZTeamData[M28Map.refiTimeOfNearbyEnemyNovax] and GetGameTimeSeconds() - tLZTeamData[M28Map.refiTimeOfNearbyEnemyNovax] <= 2 then bConsiderMobileShieldsForBuildingsDueToNovax = true end
            local bConsiderMobileShieldForGETemplate
            if M28Team.tTeamData[iTeam][M28Team.refbEnemyHasTeleport] and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates]) == false then
                if not(tLZTeamData[M28Map.subrefbGEShieldSACU]) then
                    bConsiderMobileShieldForGETemplate = true
                else
                    for _, tSubtable in tLZTeamData[M28Map.reftActiveGameEnderTemplates] do
                        if M28Utilities.IsTableEmpty(tSubtable[M28Map.subreftoGEShieldSACUs]) == false then
                            bConsiderMobileShieldForGETemplate = true
                            break
                        end
                    end
                end
            end
            local bConsiderPreemptiveMAADefence --nil if not considered yet, false if dont want to, true if want MAA to go infront of ACU/fatboy that they are covering instead of behind
            local oClosestEnemyT1ToT3Bomber, tPreferredPositionToProtectFromBomber     --Used for preemptiveMAADefence
            local bCurUnitWantsMobileShield
            local iSACUCategory = categories.SUBCOMMANDER --[[M28UnitInfo.refCategoryRASSACU
            if (tLZTeamData[M28Map.subrefiTimeLastWantSACUForExp] or tLZTeamData[M28Map.subrefiTimeLastWantSACUForSMD]) and not(bUseRASInCombat) then iSACUCategory = iSACUCategory + categories.SUBCOMMANDER end--]]
            for iUnit, oUnit in tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do

                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with fraction complete '..oUnit:GetFractionComplete()..' owned by brain '..oUnit:GetAIBrain().Nickname..'; Special micro active='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive] or false)..'; Time until micro stopped='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] or 0)..'; Unit combat range='..(oUnit[M28UnitInfo.refiCombatRange] or 'nil')..'; Is unit amphibious='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAmphibious, oUnit.UnitId))..'; Is unit mobile non-air amphibious='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAmphibious * categories.MOBILE - categories.AIR, oUnit.UnitId))..'; is reftArtiTemplateRefs nil='..tostring(oUnit[M28Building.reftArtiTemplateRefs] == nil)) end
                bCurUnitWantsMobileShield = false
                if oUnit[refbFlaggedForPriorityScout] then
                    local bRecorded = false
                    if not(tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts]) then
                        tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts] = {}
                    else
                        for iRecorded, oRecorded in tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts] do
                            if oRecorded == oUnit then bRecorded = true break end
                        end
                    end
                    if not(bRecorded) then
                        table.insert(tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts], oUnit)
                    end
                end
                if oUnit:GetFractionComplete() >= 1 then
                    if EntityCategoryContains(categories.MOBILE - M28UnitInfo.refCategoryScathis, oUnit.UnitId) then
                        if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                            table.insert(tEngineers, oUnit)
                            bLandZoneOrAdjHasUnitsWantingScout = true
                        elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) or oUnit[M28ACU.refbTreatingAsACU] then
                            --ACU logic - handled via M28ACU file, as amy not want to kite with it; acu is still stored in list of allied units for a land zone though
                            if bDebugMessages == true then LOG(sFunctionRef..': ACU is in list of allied units for iPlateau'..iPlateau..'; iLandZone='..iLandZone..'; Does ACU have valid mobile shield assigned='..tostring(M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileShield]))..'; Assigned shield='..(oUnit[refoAssignedMobileShield].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit[refoAssignedMobileShield]) or 'nil')) end
                            bLandZoneOrAdjHasUnitsWantingScout = true
                            bCurUnitWantsMobileShield = true
                            if not(oUnit[refoAssignedMobileShield]) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Adding ACU to table of units wanting mobile shield for this zone') end
                                table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                            elseif M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] > 0 then --when assigning a mobile shield, we should do it to this table first, and to refoAssignedMobileShield last; that way, the below should only be relevant if previously assigned mobile shields have died or retreated; although not perfect since it means a smaller number assigned, hopefully it will be close enough and avoids the risk of inconsistent conditions leading to an infinite cycle of shield assignment (if changing then need to do an M28Conditions function)
                                --If ACU is under fixed shield at core base then dont require mobile shields
                                if tLZTeamData[M28Map.subrefLZbCoreBase] and M28Logic.IsTargetUnderShield(aiBrain, oUnit, 10000, false, true, false, false, false) then
                                    if M28Conditions.IsTableOfUnitsStillValid(oUnit[reftoAdditionalAssignedMobileShields]) then
                                        --Remove all extra assigned mobile shields if have ACU under fixed shield
                                        for iCurMobileShield = table.getn(oUnit[reftoAdditionalAssignedMobileShields]), 1, -1 do
                                            ClearCurrentShieldTarget(oUnit[reftoAdditionalAssignedMobileShields][iCurMobileShield])
                                        end
                                    end
                                elseif not(M28Conditions.IsTableOfUnitsStillValid(oUnit[reftoAdditionalAssignedMobileShields])) then
                                    table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                                end
                            end
                            if iEnemyOmniCoverage <= 20 and (not(oUnit.HasEnhancement) or (oUnit[M28ACU.refiUpgradeCount] or 0) == 0 or not((oUnit:HasEnhancement('StealthGenerator') or oUnit:HasEnhancement('CloakingGenerator') or oUnit:HasEnhancement('FAF_SelfRepairSystem')))) then
                                if not(oUnit[refoAssignedMobileStealth]) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Adding ACU to table of units wanting mobile stealth, UpgradeCount='..(oUnit[M28ACU.refiUpgradeCount] or 0)..'; oUnit.HasEnhancement == nil='..tostring(oUnit.HasEnhancement == nil)..'; Has stealthgen enhancement='..tostring(oUnit:HasEnhancement('StealthGenerator'))..'; Has cloaking enhancement='..tostring(oUnit:HasEnhancement('CloakingGenerator'))..'; Has self repair system='..tostring(oUnit:HasEnhancement('FAF_SelfRepairSystem'))) end
                                    table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth], oUnit)
                                end
                            end

                            if not(oUnit[M28ACU.refbTreatingAsACU]) and oUnit:GetAIBrain().M28AI then ForkThread(M28ACU.ManageACU, oUnit:GetAIBrain(), oUnit) end --redundancy, wouldnt expect this to normally trigger
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit.UnitId) then
                            if not(oUnit[M28UnitInfo.refbLurkerMode]) then
                                if oUnit[M28UnitInfo.refbScoutCombatOverride] then
                                    bIncludeUnit = true
                                    table.insert(tAvailableCombatUnits, oUnit)
                                    if oUnit[M28UnitInfo.refiDFRange] > iOurBestDFRange then
                                        iOurBestDFRange = oUnit[M28UnitInfo.refiDFRange]
                                    end
                                else
                                    table.insert(tScouts, oUnit)
                                end
                            elseif bDebugMessages == true then LOG(sFunctionRef..': Scout is in lurker mode so ignoring as handled by separate logic')
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMobileLandShield, oUnit.UnitId) then
                            table.insert(tMobileShields, oUnit)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMobileLandStealth, oUnit.UnitId) then
                            table.insert(tMobileStealths, oUnit)
                        elseif EntityCategoryContains(iSACUCategory, oUnit.UnitId) and not(bUseRASInCombat) then
                            --Only include for new orders if not already building something; otherwise do nothing with the unit (as hopefully we already have logic applying to it)
                            if not(oUnit:IsUnitState('Building') or oUnit:IsUnitState('Repairing')) and M28Utilities.IsTableEmpty(oUnit[M28Building.reftArtiTemplateRefs]) then
                                if oUnit[M28UnitInfo.refiSACUWaterZoneTarget] then
                                    if not(tSACUsToGoToWaterZone) then tSACUsToGoToWaterZone = {} end
                                    table.insert(tSACUsToGoToWaterZone, oUnit)
                                else
                                    table.insert(tSACUs, oUnit)
                                end
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryMobileLand - categories.COMMAND, oUnit.UnitId) or (oUnit[M28UnitInfo.refiCombatRange] > 0 and EntityCategoryContains(M28UnitInfo.refCategoryAmphibious * categories.MOBILE - categories.AIR, oUnit.UnitId)) then
                            --Tanks, skirmishers, and indirect fire units - handled by main combat unit manager
                            bIncludeUnit = false
                            bLandZoneOrAdjHasUnitsWantingScout = true
                            --Is the unit available for use by this land zone?
                            if oUnit:GetFractionComplete() == 1 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Does unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' have a valid guard? Guard='..(oUnit[refoAssignedUnitToGuard].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit[refoAssignedUnitToGuard]) or 'nil')..'; refiRaidingTargetZone='..(oUnit[refiRaidingTargetZone] or 'nil')) end
                                if oUnit[refiRaidingTargetZone] then
                                    if not(tRaiders) then tRaiders = {} end
                                    table.insert(tRaiders, oUnit)
                                elseif oUnit[refoAssignedUnitToGuard] and M28UnitInfo.IsUnitValid(oUnit[refoAssignedUnitToGuard]) and (EntityCategoryContains(M28UnitInfo.refCategoryAmphibious + categories.HOVER, oUnit.UnitId) or not(M28UnitInfo.IsUnitUnderwater(oUnit[refoAssignedUnitToGuard]))) then

                                    --Guard actually causes MAA to move a bit too far away so will just move towards the unit; currently are just using this for MAA covering a fatboy so moving directly to the unit means it works out well since they wont block the fatboy and will rotate instead to be to the fatboy's rear at all times
                                    --Temporarily run if we are in range of enemy units in the zone
                                    --CloseToEnemyUnit(tStartPosition, tUnitsToCheck,                       iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                                    if (oUnit[M28UnitInfo.refiAARange] or 0) > 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 4,    iTeam, true,                    nil,                    nil,                                oUnit,                                  nil,                                false) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have MAA assigned to guard a unit but enemy DF are close so want to retreat to rally point') end
                                        table.insert(tOtherUnitsToRetreat, oUnit)
                                    else
                                        --Consider having MAA go infront of our unit if worried about enemy bomber snipe threat (if dealing with fatboy or ACU outside of core base), provided not close to being in range
                                        if bConsiderPreemptiveMAADefence == nil then
                                            bConsiderPreemptiveMAADefence = false
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to preemptively move to defend against air snipe, M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; Core base='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase] or false)) end
                                            if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 4000 and not(tLZTeamData[M28Map.subrefLZbCoreBase]) then
                                                --Does enemy ahve any nearby bombers to us and we lack fixed AA in this zone?
                                                local tEnemyBombers = EntityCategoryFilterDown(M28UnitInfo.refCategoryBomber - categories.EXPERIMENTAL, M28Team.tTeamData[iTeam][M28Team.reftoAllEnemyAir])
                                                local iMaxDistance = 300
                                                local iClosestBomberDist = iMaxDistance --Ignore if bomber further than this
                                                local iCurDist
                                                local iMaxCount = 80
                                                if M28Utilities.bCPUPerformanceMode then iMaxCount = 40 end
                                                local tComparisonPosition
                                                if (oUnit[refoAssignedUnitToGuard][M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone and oUnit[refoAssignedUnitToGuard][M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] == iPlateau) or M28Utilities.GetDistanceBetweenPositions(oUnit[refoAssignedUnitToGuard]:GetPosition(), oUnit:GetPosition()) <= 20 then
                                                    tComparisonPosition = oUnit[refoAssignedUnitToGuard]:GetPosition()
                                                else
                                                    tComparisonPosition = tLZData[M28Map.subrefMidpoint]
                                                end
                                                if M28Utilities.IsTableEmpty(tEnemyBombers) == false then
                                                    local iEnemyBomberMassNearby = 0
                                                    local bEnemyDoesntHaveBigEnoughBomberThreat = true
                                                    local bCustomThreat = M28UnitInfo.bCustomThreatFactor
                                                    for iBomber, oBomber in tEnemyBombers do
                                                        if not(oBomber.Dead) then
                                                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oBomber:GetPosition(),tComparisonPosition)
                                                            if iCurDist < iClosestBomberDist then
                                                                iClosestBomberDist = iCurDist
                                                                oClosestEnemyT1ToT3Bomber = oBomber
                                                            end
                                                            if bEnemyDoesntHaveBigEnoughBomberThreat and iCurDist < iMaxDistance then
                                                                if bCustomThreat then
                                                                    iEnemyBomberMassNearby = iEnemyBomberMassNearby + (oBomber[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * M28UnitInfo.iThreatFactor
                                                                else
                                                                    iEnemyBomberMassNearby = iEnemyBomberMassNearby + (oBomber[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
                                                                end
                                                                if iEnemyBomberMassNearby >= 1500 and (iEnemyBomberMassNearby >= 4000 or (iCurDist < 200 and (iCurDist < 120 or iEnemyBomberMassNearby >= 2500))) then
                                                                    bEnemyDoesntHaveBigEnoughBomberThreat = false
                                                                end
                                                            end
                                                            if bDebugMessages == true then LOG(sFunctionRef..': oBomber='..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; iCurDist='..iCurDist..'; iClosestBomberDist='..iClosestBomberDist..'; iEnemyBomberMassNearby='..iEnemyBomberMassNearby..'; iBomber='..iBomber) end
                                                            if iBomber > iMaxCount and ((bEnemyDoesntHaveBigEnoughBomberThreat and not(oClosestEnemyT1ToT3Bomber)) or iBomber > iMaxCount + 50) then break end
                                                        end
                                                    end
                                                    if bEnemyDoesntHaveBigEnoughBomberThreat then oClosestEnemyT1ToT3Bomber = nil end
                                                end
                                                if oClosestEnemyT1ToT3Bomber and iClosestBomberDist >= 35 then bConsiderPreemptiveMAADefence = true end
                                                if bDebugMessages == true then LOG(sFunctionRef..': bConsiderPreemptiveMAADefence='..tostring(bConsiderPreemptiveMAADefence)) end
                                            end

                                        end
                                        if bConsiderPreemptiveMAADefence then
                                            --Check covering fatboy or ACU and dont have enemy threat that can target our MAA
                                            if bDebugMessages == true then
                                                if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                                                    LOG(sFunctionRef..': refoClosestEnemyFromLastCloseToEnemyUnitCheck is valid='..oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])..'; Dist to it='..M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition())..'; refiCombatRange of it='..oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiCombatRange]..'; oUnit[refoAssignedUnitToGuard]='..oUnit[refoAssignedUnitToGuard].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[refoAssignedUnitToGuard])..'; Is this a fatboy or acu='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryFatboy + categories.COMMAND, oUnit[refoAssignedUnitToGuard].UnitId)))
                                                else
                                                    LOG(sFunctionRef..': refoClosestEnemyFromLastCloseToEnemyUnitCheck is not valid, oUnit[refoAssignedUnitToGuard]='..oUnit[refoAssignedUnitToGuard].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[refoAssignedUnitToGuard]))
                                                end
                                            end
                                            if (not(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) or M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()) - oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiCombatRange] >= 15) and EntityCategoryContains(M28UnitInfo.refCategoryFatboy + categories.COMMAND, oUnit[refoAssignedUnitToGuard].UnitId) then
                                                if not(tPreferredPositionToProtectFromBomber) then
                                                    --Move between fatboy/ACU and closest bomber
                                                    local iAngleToBomber = M28Utilities.GetAngleFromAToB(oUnit[refoAssignedUnitToGuard]:GetPosition(), oClosestEnemyT1ToT3Bomber:GetPosition())
                                                    local iStartingDistToMove
                                                    if M28Utilities.GetDistanceBetweenPositions( oClosestEnemyT1ToT3Bomber:GetPosition(), oUnit[refoAssignedUnitToGuard]:GetPosition()) <= 120 then
                                                        iStartingDistToMove = 40
                                                    else
                                                        iStartingDistToMove = 30
                                                    end
                                                    for iDistToMove = iStartingDistToMove, 10, -10 do
                                                        tPreferredPositionToProtectFromBomber = M28Utilities.MoveInDirection(oUnit[refoAssignedUnitToGuard]:GetPosition(), iAngleToBomber, iDistToMove, true, false, M28Map.bIsCampaignMap)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iDistToMove='..iDistToMove..'; iAngleToBomber='..iAngleToBomber..'; tPreferredPositionToProtectFromBomber='..repru(tPreferredPositionToProtectFromBomber)..'; Land label='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tPreferredPositionToProtectFromBomber) or 'nil')..'; tLZData[M28Map.subrefLZIslandRef]='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')) end
                                                        if M28Utilities.IsTableEmpty(tPreferredPositionToProtectFromBomber) == false and NavUtils.GetLabel(M28Map.refPathingTypeLand, tPreferredPositionToProtectFromBomber) == tLZData[M28Map.subrefLZIslandRef] then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Have valid intercept location so will use this') end
                                                            break
                                                        else tPreferredPositionToProtectFromBomber = nil
                                                        end
                                                    end
                                                    if not(tPreferredPositionToProtectFromBomber) then tPreferredPositionToProtectFromBomber = oUnit[refoAssignedUnitToGuard]:GetPosition() end --redundancy
                                                end
                                                M28Orders.IssueTrackedMove(oUnit, tPreferredPositionToProtectFromBomber, 3, false, 'SpecPreAA', false)
                                            else
                                                M28Orders.IssueTrackedMove(oUnit, oUnit[refoAssignedUnitToGuard]:GetPosition(), 3, false, 'SpecH', false)
                                            end
                                        else
                                            M28Orders.IssueTrackedMove(oUnit, oUnit[refoAssignedUnitToGuard]:GetPosition(), 3, false, 'SpecG', false)
                                        end
                                    end
                                elseif oUnit[M28Engineer.refiAssignedAction] == M28Engineer.refActionLoadOntoTransport or oUnit:IsUnitState('Attached') then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Unit is either attached or abut to load into a transport so will ignore') end
                                    --M28Orders.IssueTrackedGuard(oUnit, oUnit[refoAssignedUnitToGuard], false, 'SpecG', false)
                                else
                                    --NOTE: If making changes to below line condition, then update simialr line in M28Team
                                    if oUnit[M28UnitInfo.refiCombatRange] > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId)) then table.insert(tLZTeamData[M28Map.subrefLZTAlliedCombatUnits], oUnit) end
                                    --Is the unit's priority lower than this?
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if have available combat unit, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[refiCurrentAssignmentValue]='..(oUnit[refiCurrentAssignmentValue] or 'nil')..'; oUnit[refiCurrentAssignmentPlateauAndLZ]='..repru(oUnit[refiCurrentAssignmentPlateauAndLZ])..'; iCurLZValue='..iCurLZValue..'; Unit mass cost='..(oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))..'; iMobileShieldMassThreshold='..iMobileShieldMassThreshold) end
                                    if (oUnit[refiCurrentAssignmentValue] or 0) <= iCurLZValue or (oUnit[refiCurrentAssignmentPlateauAndLZ][1] == iPlateau and (oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone or (GetGameTimeSeconds() - (oUnit[refiTimeOfLastAssignment] or 0) >= 5))) then
                                        --Is it a unit with a shield that wants to retreat so its shield can regen?
                                        iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, true)
                                        iShieldPercentageAdjust = 0
                                        if iCurShield > 0 then
                                            iCurHealthPercent = M28UnitInfo.GetUnitHealthPercent(oUnit)
                                            if iCurHealthPercent < 0.7 and (iCurHealthPercent < 0.5 or EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId)) then
                                                if M28UnitInfo.GetUnitHealthPercent(oUnit) < 0.2 then iShieldPercentageAdjust = 0.25
                                                else iShieldPercentageAdjust = 0.15
                                                end
                                            elseif EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
                                                iShieldPercentageAdjust = 0.075
                                            end
                                        end

                                        if bDebugMessages == true then LOG(sFunctionRef..': iCurShield='..iCurShield..'; iMaxShield='..iMaxShield..'; Unit max health='..oUnit:GetMaxHealth()..'; Is team stalling energy='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; Team M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount]='..M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount]..'; Is unit paused='..tostring(oUnit[M28UnitInfo.refbPaused] or false)..'; Is shield enabled='..tostring(M28UnitInfo.IsUnitShieldEnabled(oUnit))..'; is oUnit[refbShieldIsDisabled] nil='..tostring(oUnit[M28UnitInfo.refbShieldIsDisabled] == nil)) end
                                        if not(oUnit[M28UnitInfo.refbEasyBrain]) and iMaxShield > 0 and iCurShield < iMaxShield * (0.35 + iShieldPercentageAdjust) and (iCurShield == 0 or iMaxShield > oUnit:GetMaxHealth() * 0.8 or iCurShield < iMaxShield * (iShieldPercentageAdjust + 0.05)) then --Fatboy and in theory SACUs retreat when shield is low; titans etc. retreat when shield is almost gone
                                            if bDebugMessages == true then LOG(sFunctionRef..': Added unit to table of units to retreat') end
                                            table.insert(tOtherUnitsToRetreat, oUnit)
                                            RecordUnitAsReceivingLandZoneAssignment(oUnit, iPlateau, iLandZone, 100000)
                                            --Redundancy for rare cases where a units shield can be disabled from a transfer
                                            if iCurShield == 0 and oUnit[M28UnitInfo.refbTransferredUnit] and not(oUnit[M28UnitInfo.refbPaused]) and (not(M28UnitInfo.IsUnitShieldEnabled(oUnit)) or oUnit[M28UnitInfo.refbShieldIsDisabled] == nil) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will enable shield for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                                M28UnitInfo.EnableUnitShield(oUnit)
                                            end
                                        else
                                            if EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId) then
                                                table.insert(tAvailableMAA, oUnit)
                                                bIncludeUnit =  true
                                            elseif ((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or (oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0) then
                                                table.insert(tAvailableCombatUnits, oUnit)
                                                iAvailableCombatCount = iAvailableCombatCount + 1
                                                if oUnit[M28UnitInfo.refiDFRange] > iOurBestDFRange and not(EntityCategoryContains(M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) then iOurBestDFRange = oUnit[M28UnitInfo.refiDFRange] end
                                                if oUnit[M28UnitInfo.refiIndirectRange] > iOurBestIndirectRange then iOurBestIndirectRange = oUnit[M28UnitInfo.refiIndirectRange] end
                                                bIncludeUnit = true
                                            end
                                            if bIncludeUnit then
                                                RecordUnitAsReceivingLandZoneAssignment(oUnit, iPlateau, iLandZone, iCurLZValue)
                                            end
                                        end
                                    else
                                        table.insert(tUnavailableUnitsInThisLZ, oUnit)
                                    end
                                    iUnitMassCost = (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
                                    if iUnitMassCost >= iMobileShieldMassThreshold and (iUnitMassCost >= iMobileShieldHigherMAAMassThreshold or iMobileShieldHigherMAAMassThreshold == iMobileShieldMassThreshold or not(EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId))) then
                                        bCurUnitWantsMobileShield = true
                                        if not(oUnit[refoAssignedMobileShield]) then
                                            table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Wnat mobile shield for unit') end
                                        elseif iUnitMassCost > 2000 and M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] > 0 and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId) then
                                            --Fatboys - have +1 mobile shield per enemy novax (max of 5 incl base)
                                            if not(M28Conditions.IsTableOfUnitsStillValid(oUnit[reftoAdditionalAssignedMobileShields])) or table.getn(oUnit[reftoAdditionalAssignedMobileShields]) < math.min(4, M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount]) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Want extra mobile shield for fatboy due to enemy novax') end
                                                table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                                            end
                                        end
                                    end
                                    if iEnemyOmniCoverage <= 20 and not(EntityCategoryContains(M28UnitInfo.refCategoryStealth, oUnit.UnitId)) then
                                        if iUnitMassCost >= iMobileStealthHigherMassThreshold then
                                            if not(oUnit[refoAssignedMobileStealth]) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Want mobile stealth for unit') end
                                                table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth], oUnit)
                                            end
                                        elseif iUnitMassCost >= iMobileStealthMassThreshold and EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryIndirect + M28UnitInfo.refCategoryAbsolver - categories.TECH1, oUnit.UnitId) then
                                            --Only say we want a mobile stealth if the unit doesnt have one assigned
                                            iMobileStealthLowerThresholdCount = iMobileStealthLowerThresholdCount + 1

                                            if iMobileStealthLowerThresholdCount >= 3 or oUnit[refoAssignedMobileStealth] then
                                                iMobileStealthLowerThresholdCount = 0
                                                if not(oUnit[refoAssignedMobileStealth]) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Want mobile stealth for lower threshold unit') end
                                                    table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth], oUnit)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        elseif EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                            --Structure logic - handled separately e.g. via M28Factory for factories
                        else
                            --Unexpected unit type - could e.g. be a naval unit on a location thought to be a land zone; only flag as error if unit has no orders
                            table.insert(tTempOtherUnits, oUnit)
                            bLandZoneOrAdjHasUnitsWantingScout = true
                        end
                    else
                        if bConsiderMobileShieldForGETemplate and oUnit[M28Building.reftArtiTemplateRefs] and EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oUnit.UnitId) then
                            bCurUnitWantsMobileShield = true
                            if not(oUnit[refoAssignedMobileShield]) then
                                table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                            end
                        elseif bConsiderMobileShieldsForBuildingsDueToNovax and M28Utilities.IsTableEmpty(oUnit[M28Building.reftoShieldsProvidingCoverage]) and EntityCategoryContains(M28UnitInfo.refCategoryPower - categories.TECH1 + M28UnitInfo.refCategoryEnergyStorage, oUnit.UnitId) then
                            bCurUnitWantsMobileShield = true
                            if not(oUnit[refoAssignedMobileShield]) then
                                table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                            end
                        elseif bConsiderMobileShieldsForT2Arti and EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) and M28Utilities.IsTableEmpty(oUnit[M28Building.reftoShieldsProvidingCoverage]) then
                            bCurUnitWantsMobileShield = true
                            if not(oUnit[refoAssignedMobileShield]) then
                                table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                            end
                        elseif bConsiderMobileShieldsForT2PD and EntityCategoryContains(M28UnitInfo.refCategoryT2PlusPD, oUnit.UnitId) and M28Utilities.IsTableEmpty(oUnit[M28Building.reftoShieldsProvidingCoverage]) then
                            bCurUnitWantsMobileShield = true
                            if not(oUnit[refoAssignedMobileShield]) then
                                table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                            end
                        end

                    end
                else
                    --Under construction unit
                    if bConsiderMobileShieldForGETemplate and oUnit[M28Building.reftArtiTemplateRefs] and EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oUnit.UnitId) then
                        bCurUnitWantsMobileShield = true
                        if not(oUnit[refoAssignedMobileShield]) then
                            table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                        end
                    elseif bConsiderMobileShieldsForBuildingsDueToNovax and M28Utilities.IsTableEmpty(oUnit[M28Building.reftoShieldsProvidingCoverage]) and EntityCategoryContains(M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryStructure * categories.EXPERIMENTAL + M28UnitInfo.refCategoryScathis, oUnit.UnitId) then
                        bCurUnitWantsMobileShield = true
                        if not(oUnit[refoAssignedMobileShield]) then
                            table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                        end
                    elseif (bConsiderMobileShieldsForT2PD or bConsiderMobileShieldsForT2Arti) and oUnit:GetFractionComplete() >= 0.2 then
                        if bConsiderMobileShieldsForT2Arti then
                            if EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) and M28Utilities.IsTableEmpty(oUnit[M28Building.reftoShieldsProvidingCoverage]) then
                                bCurUnitWantsMobileShield = true
                                if not(oUnit[refoAssignedMobileShield]) then
                                    table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                                end
                            end
                        end
                        if bConsiderMobileShieldsForT2PD then
                            if EntityCategoryContains(M28UnitInfo.refCategoryT2PlusPD, oUnit.UnitId) and M28Utilities.IsTableEmpty(oUnit[M28Building.reftoShieldsProvidingCoverage]) then
                                bCurUnitWantsMobileShield = true
                                if not(oUnit[refoAssignedMobileShield]) then
                                    table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                                end
                            end
                        end
                    end
                end
                if oUnit[refoAssignedMobileShield] and not(bCurUnitWantsMobileShield) and oUnit[refoAssignedMobileShield][refoMobileShieldTarget] == oUnit then
                    ClearCurrentShieldTarget(oUnit[refoAssignedMobileShield])
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Is table of engineers empty='..tostring(M28Utilities.IsTableEmpty(tEngineers))..'; Is table of combat units just for this zone empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))) end

        --Mobile shield data:
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield]) == false then
            for iUnit, oUnit in tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield] do
                if oUnit[refoAssignedMobileShield] then
                    if not(M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileShield])) then
                        oUnit[refoAssignedMobileShield] = nil
                        tLZTeamData[M28Map.refbLZWantsMobileShield] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording that the land zone '..iLandZone..' wants mobile shields as a unit that had a mobile shield no longerh as a valid one') end
                    end
                else
                    tLZTeamData[M28Map.refbLZWantsMobileShield] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording that the land zone '..iLandZone..' wants mobile shields as it has a unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that doesnt have an assigned mobile shield yet') end
                end
            end
        end
        tLZTeamData[M28Map.subrefiAvailableMobileShieldThreat] = 0
        if M28Utilities.IsTableEmpty(tMobileShields) == false then
            tLZTeamData[M28Map.subrefiAvailableMobileShieldThreat] = M28UnitInfo.GetMassCostOfUnits(tMobileShields)
            ManageMobileShieldsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tMobileShields)
        end
        --Mobile stealth data:
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth]) == false then

            for iUnit, oUnit in tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth] do
                if iEnemyOmniCoverage > 20 then
                    if M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileStealth]) then
                        oUnit[refoAssignedMobileStealth][refoMobileStealthTarget] = nil
                        oUnit[refoAssignedMobileStealth] = nil
                    end
                elseif oUnit[refoAssignedMobileStealth] then
                    if not(M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileStealth])) then
                        oUnit[refoAssignedMobileStealth] = nil
                        tLZTeamData[M28Map.refbLZWantsMobileStealth] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording that the land zone '..iLandZone..' wants mobile Stealths as a unit that had a mobile Stealth no longerh as a valid one') end
                    end
                else
                    tLZTeamData[M28Map.refbLZWantsMobileStealth] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording that the land zone '..iLandZone..' wants mobile Stealths as it has a unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that doesnt have an assigned mobile Stealth yet') end
                end
            end
            if iEnemyOmniCoverage > 20 then tLZTeamData[M28Map.refbLZWantsMobileStealth] = false end
        end

        if M28Utilities.IsTableEmpty(tMobileStealths) == false then
            ManageMobileStealthsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tMobileStealths, iEnemyOmniCoverage)
        end

        local iCurDFThreat = 0
        local iCurIndirectThreat = 0
        local iCurMAAThreat = tLZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA]
        local iMinIndirectRangeNeededForThreat = tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] + 1
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] do
                if iRange >= iMinIndirectRangeNeededForThreat then
                    iCurIndirectThreat = iCurIndirectThreat + iThreat
                end
            end
        end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                iCurDFThreat = iCurDFThreat + iThreat
            end
        end


        local bConsiderAdjacentDF = false
        local bConsiderAdjacentIndirect = false
        local bConsiderAdjacentMAA = false
        if bDebugMessages == true then LOG(sFunctionRef..': Setting whether we want to consider indirect threat, iCurIndirectThreat='..(iCurIndirectThreat or 'nil')..'; tLZTeamData[M28Map.subrefLZIndirectThreatWanted]='..(tLZTeamData[M28Map.subrefLZIndirectThreatWanted] or 'nil')) end
        if iCurIndirectThreat < tLZTeamData[M28Map.subrefLZIndirectThreatWanted] then bConsiderAdjacentIndirect = true end
        if iCurDFThreat < tLZTeamData[M28Map.subrefLZDFThreatWanted] then bConsiderAdjacentDF = true end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false and iCurMAAThreat < tLZTeamData[M28Map.subrefLZMAAThreatWanted] and tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 and (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] == 0 or (tLZTeamData[M28Map.subrefLZSValue] or 0) > 0 or tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 0.7) then bConsiderAdjacentMAA = true end




        --Add adjacent combat units if the land zone is lower priority than us and the adjacent LZ doesnt have DF units of a significant threat in it
        local iCurUnitThreat
        if bDebugMessages == true then LOG(sFunctionRef..': Will consider including adjacent combat units for LZ '..iLandZone..' with iCurLZValue='..iCurLZValue..'; is table of adjacent LZs empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]))..'; bConsiderAdjacentIndirect='..tostring(bConsiderAdjacentIndirect)..'; bConsiderAdjacentDF='..tostring(bConsiderAdjacentDF)..'; bConsiderAdjacentMAA='..tostring(bConsiderAdjacentMAA or false)) end
        local bConsiderGivingOrdersToUnits
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                local tAltLZTeam = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; Base LZ='..iLandZone..'; iAdjLZ='..iAdjLZ..'; LZTValue='..repru(tAltLZTeam[M28Map.subrefLZTValue])..'; Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tAltLZTeam[M28Map.subreftoLZOrWZAlliedUnits]))) end
                if not(bLandZoneOrAdjHasUnitsWantingScout) and M28Utilities.IsTableEmpty(tAltLZTeam[M28Map.subrefLZTAlliedCombatUnits]) == false then bLandZoneOrAdjHasUnitsWantingScout = true end
                --if (bConsiderAdjacentIndirect or bConsiderAdjacentDF) then
                bConsiderGivingOrdersToUnits = false
                if tAltLZTeam[M28Map.subrefLZTValue] < iCurLZValue and tAltLZTeam[M28Map.subrefLZThreatEnemyMobileDFTotal] <= 50 then bConsiderGivingOrdersToUnits = true end-- and M28Utilities.IsTableEmpty(tAltLZTeam[M28Map.subrefLZTAlliedCombatUnits]) == false then
                if M28Utilities.IsTableEmpty(tAltLZTeam[M28Map.subrefLZTAlliedCombatUnits]) == false then
                    for iUnit, oUnit in tAltLZTeam[M28Map.subrefLZTAlliedCombatUnits] do

                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to add adjacent oUnit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' with cur assignment value '..(oUnit[refiCurrentAssignmentValue] or 0)..' and cur assignemnt LZ='..(oUnit[refiCurrentAssignmentPlateauAndLZ][2] or 'nil')..'; DFRange='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Is this a LAB='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryLightAttackBot, oUnit.UnitId))) end
                        if not(oUnit.Dead) and oUnit:GetFractionComplete() == 1 and ((oUnit[refiCurrentAssignmentValue] or 0) < iCurLZValue or (oUnit[refiCurrentAssignmentPlateauAndLZ][1] == iPlateau and oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone)) and not(oUnit[refiRaidingTargetZone]) then
                            --Combat unit related
                            if not(bConsiderGivingOrdersToUnits) then
                                if oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone then
                                    oUnit[refiCurrentAssignmentValue] = -1
                                end
                                --Units to not consider from adjacent zones - SACUs, skirmishers, combat scouts, and long ranged units
                            elseif oUnit[M28UnitInfo.refiSACUWaterZoneTarget] or ((oUnit[M28UnitInfo.refiDFRange] or 0) >= 10 and (oUnit[M28UnitInfo.refiDFRange] >= 64 or oUnit[M28UnitInfo.refbScoutCombatOverride] or (oUnit[M28UnitInfo.refiDFRange] >= 34 and EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId)) or (M28UnitInfo.GetUnitLifetimeCount(oUnit) <= 5 and EntityCategoryContains(M28UnitInfo.refCategoryLightAttackBot, oUnit.UnitId)))) then
                                --Dont want long ranged DF units to receive orders from an adjacent zone as we risk them not taking into account all nearby enemies
                                if bDebugMessages == true then LOG(sFunctionRef..': Skirmisher, combat scout or LR DF unit so only want it assigned to the zone it is in, Cur LZ assigned='..oUnit[refiCurrentAssignmentPlateauAndLZ][2]..'; iLandZone='..iLandZone..'; if are the same will clear assignment value') end
                                if oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone then
                                    oUnit[refiCurrentAssignmentValue] = -1
                                end
                            else
                                if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and not(bConsiderAdjacentDF) and oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone then
                                    oUnit[refiCurrentAssignmentValue] = -1
                                elseif (oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0 and not(bConsiderAdjacentIndirect) and oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone then
                                    oUnit[refiCurrentAssignmentValue] = -1
                                elseif (bConsiderAdjacentDF and oUnit[M28UnitInfo.refiDFRange] > 0) or (bConsiderAdjacentIndirect and oUnit[M28UnitInfo.refiIndirectRange] > 0) then
                                    bHaveCombatUnitsFromAdjZone = true
                                    table.insert(tAvailableCombatUnits, oUnit)
                                    iAvailableCombatCount = iAvailableCombatCount + 1
                                    RecordUnitAsReceivingLandZoneAssignment(oUnit, iPlateau, iLandZone, iCurLZValue)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Recording this unit from the adjacent zone '..iAdjLZ..' as being available for zone '..iLandZone) end

                                    iCurUnitThreat = nil
                                    if oUnit[M28UnitInfo.refiDFRange] > 0 then
                                        if oUnit[M28UnitInfo.refiDFRange] > iOurBestDFRange and not(EntityCategoryContains(M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) then iOurBestDFRange = oUnit[M28UnitInfo.refiDFRange] end
                                        iCurUnitThreat = M28UnitInfo.GetCombatThreatRating({ oUnit })
                                        iCurDFThreat = iCurDFThreat + iCurUnitThreat
                                        if iCurDFThreat > tLZTeamData[M28Map.subrefLZDFThreatWanted] then
                                            bConsiderAdjacentDF = false
                                            --if not(bConsiderAdjacentIndirect) and not(bConsiderAdjacentMAA) then break end
                                        end
                                    end
                                    if oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                                        if oUnit[M28UnitInfo.refiIndirectRange] > iOurBestIndirectRange then iOurBestIndirectRange = oUnit[M28UnitInfo.refiIndirectRange] end
                                        if oUnit[M28UnitInfo.refiIndirectRange] > iMinIndirectRangeNeededForThreat then
                                            if not(iCurUnitThreat) then iCurUnitThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }) end
                                            iCurIndirectThreat = iCurIndirectThreat + iCurUnitThreat
                                            if iCurIndirectThreat > tLZTeamData[M28Map.subrefLZIndirectThreatWanted] then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Just increased our indirect threat for oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurUnitThreat='..iCurUnitThreat..'; iCurIndirectThreat after increase='..iCurIndirectThreat..'; tLZTeamData[M28Map.subrefLZIndirectThreatWanted]='..(tLZTeamData[M28Map.subrefLZIndirectThreatWanted] or 'nil')) end
                                                bConsiderAdjacentIndirect = false
                                                --if not(bConsiderAdjacentDF) and not(bConsiderAdjacentMAA) then break end
                                            end
                                        end
                                    end
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId) then
                                    if bConsiderAdjacentMAA then
                                        table.insert(tAvailableMAA, oUnit)
                                        RecordUnitAsReceivingLandZoneAssignment(oUnit, iPlateau, iLandZone, iCurLZValue)

                                        iCurUnitThreat = M28UnitInfo.GetAirThreatLevel({ oUnit }, false, false, true)
                                        iCurMAAThreat = iCurMAAThreat + iCurUnitThreat
                                        if iCurMAAThreat > tLZTeamData[M28Map.subrefLZMAAThreatWanted] then
                                            bConsiderAdjacentMAA = false
                                            --if not(bConsiderAdjacentIndirect) and not(bConsiderAdjacentDF) then break end
                                        end
                                    elseif oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone then
                                        oUnit[refiCurrentAssignmentValue] = -1
                                    end
                                end
                            end
                        end
                    end
                end
                --if not(bConsiderAdjacentDF) and not(bConsiderAdjacentIndirect) and not(bConsiderAdjacentMAA) then break end
            end
            --end
        end

        if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
            if tLZData[M28Map.subrefbPacifistArea] then
                RetreatOtherUnits(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableCombatUnits)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': About to manage combat units in the LZ, iOurBestIndirectRange='..(iOurBestIndirectRange or 'nil')..'; bConsiderAdjacentIndirect='..tostring(bConsiderAdjacentIndirect or false)..'; iAvailableCombatCount='..iAvailableCombatCount) end
                --ManageCombatUnitsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableCombatUnits, iFriendlyBestMobileDFRange, iFriendlyBestMobileIndirectRange, bWantIndirectReinforcements, tUnavailableUnitsInThisLZ, bDelayOrdersForHover, bHaveCombatUnitsFromAdjZone)
                ManageCombatUnitsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableCombatUnits, iOurBestDFRange, iOurBestIndirectRange, bConsiderAdjacentIndirect, tUnavailableUnitsInThisLZ, iAvailableCombatCount >= 30, bHaveCombatUnitsFromAdjZone)
                bUpdateEnemyDataHere = false
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is tAvailableCombatUnits empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))..'; table of MAA empty='..tostring(M28Utilities.IsTableEmpty(tAvailableMAA))..'; Is table of entity filtered dow nto MAA empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMAA, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))) end
        if M28Utilities.IsTableEmpty(tAvailableMAA) == false then
            if tLZData[M28Map.subrefbPacifistArea] then
                RetreatOtherUnits(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableMAA)
            else
                ManageMAAInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableMAA)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Will retreat other units if any, is table empty='..tostring(M28Utilities.IsTableEmpty(tOtherUnitsToRetreat))) end
        if M28Utilities.IsTableEmpty(tOtherUnitsToRetreat) == false then
            RetreatOtherUnits(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tOtherUnitsToRetreat)
        end
        if M28Utilities.IsTableEmpty(tSACUs) == false then
            ManageRASSACUsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tSACUs)
        end
        if tSACUsToGoToWaterZone then
            SendSACUsToWaterZone(tSACUsToGoToWaterZone, tLZTeamData)
        end
        if tRaiders then
            ManageRaidersInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tRaiders)
        end

        if M28Utilities.IsTableEmpty(tTempOtherUnits) == false then
            --If have temp other units then manage these
            local tNearestWZ
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                    local iNearestWZRef = tSubtable[M28Map.subrefAWZRef]
                    tNearestWZ = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iNearestWZRef]][M28Map.subrefPondWaterZones][iNearestWZRef][M28Map.subrefMidpoint]
                    break
                end
            end
            for iUnit, oUnit in tTempOtherUnits do
                M28Orders.UpdateRecordedOrders(oUnit)
                if oUnit[M28Orders.refiOrderCount] == 0 then
                    --Is this a naval unit?
                    if EntityCategoryContains(M28UnitInfo.refCategoryAllNavy, oUnit.UnitId) then
                        if not(tNearestWZ) then
                            M28Utilities.ErrorHandler('Have naval unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' in land zone with no orders and no adjacent WZ, will move randomly')

                            local tRandomTarget = oUnit:GetPosition()
                            local iRandX = math.random(10, 30)
                            if math.random(0,1) == 0 then iRandX = iRandX * -1 end
                            local iRandZ = math.random(10, 30)
                            if math.random(0,1) == 0 then iRandZ = iRandZ * -1 end
                            tRandomTarget[1] = tRandomTarget[1] + iRandX
                            tRandomTarget[3] = tRandomTarget[3] + iRandZ
                            tRandomTarget[2] = GetSurfaceHeight(tRandomTarget[1], tRandomTarget[3])

                            M28Orders.IssueTrackedMove(oUnit, tRandomTarget, 5, false, 'RandNM', false)
                        else
                            M28Orders.IssueTrackedMove(oUnit, tNearestWZ, 5, false, 'NavInLZBckup', false)
                        end
                    else
                        M28Utilities.ErrorHandler('Have non naval unit with no orders that is of an unrecognised category in LZ, Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; will move randomly')
                        local tRandomTarget = oUnit:GetPosition()
                        local iRandX = math.random(10, 30)
                        if math.random(0,1) == 0 then iRandX = iRandX * -1 end
                        local iRandZ = math.random(10, 30)
                        if math.random(0,1) == 0 then iRandZ = iRandZ * -1 end
                        tRandomTarget[1] = tRandomTarget[1] + iRandX
                        tRandomTarget[3] = tRandomTarget[3] + iRandZ
                        tRandomTarget[2] = GetSurfaceHeight(tRandomTarget[1], tRandomTarget[3])
                        M28Orders.IssueTrackedMove(oUnit, tRandomTarget, 5, false, 'RandLM', false)
                    end
                end
            end
        end
    else
        --No allied units - if this was flagged as an expansion LZ then clear the flag
        if tLZTeamData[M28Map.subrefLZCoreExpansion] then tLZTeamData[M28Map.subrefLZCoreExpansion] = nil end
    end
    --Update enemy ranges for this LZ and decide if this LZ still wants support, if we havent run our main combat management logic
    if bDebugMessages == true then LOG(sFunctionRef..': Will update enemy data for this LZ if are enemies in this LZ. bUpdateEnemyDataHere='..tostring(bUpdateEnemyDataHere or false)) end
    if bUpdateEnemyDataHere then
        UpdateBestEnemyRangesForThisLandZone(tLZData, tLZTeamData, iPlateau, iTeam)
        RecordClosestAdjacentEnemiesAndGetBestEnemyRange(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
        if bDebugMessages == true then LOG(sFunctionRef..': Updating if we want more DF or indirect units for this LZ, tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or false)..'; tLZTeamData[M28Map.subrefLZTValue]='..(tLZTeamData[M28Map.subrefLZTValue] or 'nil')..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal]='..tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal]) end
        local bWantDFSupport = false
        function UpdateDFSupportForEarlyGameEngineers()
            if not(bWantDFSupport) and GetGameTimeSeconds() <= 360 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefMexUnbuiltLocations]) == false and M28Utilities.IsTableEmpty(tEngineers) == false and M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) < M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZTeamData[M28Map.reftClosestFriendlyBase]) * 0.9 then
                bWantDFSupport = true
            end
        end
        if (tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and tLZTeamData[M28Map.subrefLZTValue] >= 200) or tLZData[M28Map.subrefbPacifistArea] then
            local bWantIndirectSupport = false
            if not(tLZData[M28Map.subrefbPacifistArea]) then
                if tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] > 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy has a structure with a DF range so want indirect fire support') end
                    bWantIndirectSupport = true
                end
                if tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] > 0 or tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] > 0 then bWantDFSupport = true end
                --If havent flagged for any support but enemy has units in this LZ (presumably non-combat) and we have no combat units, then flag for support
                if not(bWantIndirectSupport) and not(bWantDFSupport) and tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] == 0 and tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] == 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.MOBILE * categories.LAND, tLZTeamData[M28Map.subrefTEnemyUnits])) == false then
                        bWantDFSupport = true
                    elseif M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.STRUCTURE, tLZTeamData[M28Map.subrefTEnemyUnits])) == false then
                        if bDebugMessages == true then
                            local tEnemyBuildings = EntityCategoryFilterDown(categories.STRUCTURE, tLZTeamData[M28Map.subrefTEnemyUnits])
                            for iBuilding, oBuilding in tEnemyBuildings do
                                LOG(sFunctionRef..': Flagging we want indirect due to enemy having buildings in this zone, enemy building iBuilding='..iBuilding..'; oBuilding='..oBuilding.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBuilding))
                            end
                        end
                        bWantIndirectSupport = true
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': bWantIndirectSupport after initial checks based on enemy units in the zone='..tostring(bWantIndirectSupport)) end
                --If enemy has PD in this or adjacent zone then flag we want indirect support
                if not(bWantIndirectSupport) then
                    if bDebugMessages == true then LOG(sFunctionRef..': We wouldnt normally want indirect fire support for this zone, but if MML have been firing near TMD or shield then will flag we want indirect support, time since last firing near TMD or shield='..GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -100)) end
                    if GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -100) <= 30 then bWantIndirectSupport = true end
                    if not(bWantIndirectSupport) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Not fired near TMD recently, checking we dont have too much IF in the zone before considering adjacent zone PD, tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='.. tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]) end
                        if tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] <= math.min(2000 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech], tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] * 3) then
                            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                local iAdjacentMobileDFThreat = 0
                                local iAdjacentPDOrStructureThreat = 0
                                for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                    local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                    iAdjacentMobileDFThreat = iAdjacentMobileDFThreat + (tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)
                                    if tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] > 0 then
                                        iAdjacentPDOrStructureThreat = iAdjacentPDOrStructureThreat + math.max((tAltLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0), tAltLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy has a DF building in an adjacent zone so want IF support, iAdjacentMobileDFThreat cumulative='..iAdjacentMobileDFThreat..'; Enemy PD threat='..tAltLZTeamData[M28Map.subrefThreatEnemyDFStructures]..'; iAdjacentPDOrStructureThreat='..iAdjacentPDOrStructureThreat..'; Enemy structure mass='..tAltLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]) end
                                        if iAdjacentMobileDFThreat >= 1000 and iAdjacentMobileDFThreat >= iAdjacentPDOrStructureThreat * 4 then
                                            --Dont build indirect fire just because of the PD Threat
                                        else
                                            bWantIndirectSupport = true break
                                        end
                                    end
                                end
                                if iAdjacentPDOrStructureThreat > 0 and iAdjacentPDOrStructureThreat > iAdjacentMobileDFThreat / 4 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Overall we want indirect fire due to level of PD threat') end
                                    bWantIndirectSupport = true
                                end
                            end
                        end
                        if not(bWantIndirectSupport) then
                            if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
                                for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                                    local tAdjLZTeamData = M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam]
                                    if tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] > 0 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy has a nearby firebase type zone so want IF support') end
                                        bWantIndirectSupport = true break
                                    end
                                end
                            end
                        end
                    end
                end

                --Early game - flag that we want support if we have engineers and unclaimed mexes
                UpdateDFSupportForEarlyGameEngineers()
            end
            UpdateIfLandZoneWantsSupport(tLZTeamData, iPlateau, iLandZone, iTeam, bWantDFSupport, bWantIndirectSupport)
            if bDebugMessages == true then LOG(sFunctionRef..': Will update if this land zone wants some DF support='..tostring(bWantDFSupport)..'; bWantIndirectSupport='..tostring(bWantIndirectSupport)) end
        else
            local bWantIndirectSupport = false
            if bDebugMessages == true then LOG(sFunctionRef..': Are there enemis in this or adjacent LZ, for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Do we have a valid nearby structure in other plateau='..tostring( M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]))..'; Our highest land tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]..'; bWantDFSupport='..tostring(bWantDFSupport)) end
            if GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -100) <= 30 and not(tLZData[M28Map.subrefbPacifistArea]) then
                if bDebugMessages == true then LOG(sFunctionRef..': Have had MML firing recently near TMD so want more indirect fire support') end
                bWantIndirectSupport = true
            elseif not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and not(bWantIndirectSupport) and M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3 then
                bWantIndirectSupport = M28Conditions.IsNearbyStructureThatWeCanReachWithIndirect(tLZData, tLZTeamData, iTeam)
                if bDebugMessages == true then LOG(sFunctionRef..': bWantIndirectSupport after checking if nearby structure we can reach with indirect='..tostring(bWantIndirectSupport)) end
            end
            UpdateDFSupportForEarlyGameEngineers()
            UpdateIfLandZoneWantsSupport(tLZTeamData, iPlateau, iLandZone, iTeam, bWantDFSupport, bWantIndirectSupport)
        end
    end
    --Handle engineers and even if no engineers still decide what engineers we would want for hte LZ
    M28Engineer.ConsiderLandOrWaterZoneEngineerAssignment(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tEngineers) --Should update the land zone engineer requirements, even if tEngineers itself is empty

    ManageLandZoneScouts(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tScouts, bLandZoneOrAdjHasUnitsWantingScout)

    --Update ACU in trouble incase ACU moved zones
    if tLZTeamData[M28Map.refbACUInTrouble] and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) then tLZTeamData[M28Map.refbACUInTrouble] = false end
    --Update visual based on omni
    if tLZTeamData[M28Map.refiOmniCoverage] > 30 then tLZTeamData[M28Map.refiTimeLastHadVisual] = GetGameTimeSeconds() end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Is unbuild locations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]))) end

    --Update BP wanted for adjacent zones - will just have a flag in the engineer assignment that sets subrefTbWantBP to true/false so commented out the below
    --[[tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted] = {[1]=0, [2]=0,[3]=0}
    tLZTeamData[M28Map.subrefTbWantBP] = false
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[M28Map.iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjLZ in M28Map.tAllPlateaus[M28Map.iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones] do
            for iTech = 1, 3, 1 do
                tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted] = math.max(tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted][iTech], (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][iTech] or 0))
            end
        end
    end
    for iTech = 1, 3, 1 do
        if tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted][iTech] > 0 or tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted][iTech] > 0 then
            tLZTeamData[M28Map.subrefTbWantBP] = true
        end
    end--]]
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AssignValuesToLandZones(iTeam)
    --Periodically cycles through every land zone and refreshes the unit details
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignValuesToLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
    if aiBrain then

        if bDebugMessages == true then
            LOG(sFunctionRef..': About to start the main loop for assigning values to land zones provided we have friendly M28 brains in the team '..iTeam..'; is table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))..'; will list out the plateau and LZ for each member of the team')
            local iStartPlateau, iStartLZ
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                iStartPlateau, iStartLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                LOG(sFunctionRef..': Brain '..oBrain.Nickname..' has start position '..repru(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])..' with iStartPlateau='..(iStartPlateau or 'nil')..' and iStartLZ='..(iStartLZ or 'nil'))
            end
        end
        local iCurValue
        local tFriendlyNonPDBuildings
        local bAdjacentToCoreFactory
        local iFriendlyBuildingValue
        local iCurCycleCount = 0
        local iZonesSinceWait = 0
        local iTotalLandZones = 0
        for iPlateau, tPlateauData in M28Map.tAllPlateaus do
            iTotalLandZones = iTotalLandZones + (tPlateauData[M28Map.subrefLandZoneCount] or 0)
        end
        local iZonesPerTick = math.max(1, math.floor(iTotalLandZones / 20))
        while M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false do
            iCurCycleCount = iCurCycleCount + 1 --used so we dont wait the first time, so we have recorded which zones are core zones
            local tiPlateauAndLZWithFriendlyStartPosition = {}
            local iBaseCategory
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                if iPlateau and iLandZone then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iBrain='..iBrain..'; oBrain='..oBrain.Nickname..'; Army index='..oBrain:GetArmyIndex()..'; Player start point='..repru(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])..'; Plateau and LZ of this start point='..iPlateau..'-'..iLandZone) end
                    if not(tiPlateauAndLZWithFriendlyStartPosition[iPlateau]) then tiPlateauAndLZWithFriendlyStartPosition[iPlateau] = {} end
                    if (iLandZone or 0) > 0 then
                        tiPlateauAndLZWithFriendlyStartPosition[iPlateau][iLandZone] = true
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished recording the friendly start positions for each brain, tiPlateauAndLZWithFriendlyStartPosition='..repru(tiPlateauAndLZWithFriendlyStartPosition)) end
            iBaseCategory = categories.TECH3 * M28UnitInfo.refCategoryAllHQFactories + M28UnitInfo.refCategoryAirHQ * categories.TECH2
            --[[if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then iBaseCategory = categories.TECH3 * M28UnitInfo.refCategoryAllHQFactories + M28UnitInfo.refCategoryAirHQ * categories.TECH2
            elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 then iBaseCategory = M28UnitInfo.refCategoryAllHQFactories - categories.TECH1
            else iBaseCategory = M28UnitInfo.refCategoryAirFactory --Dont want to include t1 land facs since might be in a minor zone
            end--]]

            for iPlateau, tPlateauData in M28Map.tAllPlateaus do
                if M28Utilities.IsTableEmpty(tPlateauData[M28Map.subrefPlateauLandZones]) == false then

                    --tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
                    for iLandZone, tLandZoneData in tPlateauData[M28Map.subrefPlateauLandZones] do
                        iZonesSinceWait = iZonesSinceWait + 1
                        local tLZTeamData = tLandZoneData[M28Map.subrefLZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': About to refresh value of iPlateau='..iPlateau..'; iLandZone='..iLandZone..' for team '..iTeam) end
                        --Decide on value of the land zone ignoring distance:
                        --Treat each mex position as being worth 250 mass, value reclaim at 25% of the total value, and reflect the value of all non-PD in the area
                        iCurValue = tLandZoneData[M28Map.subrefLZOrWZMexCount] * 250 + (tLandZoneData[M28Map.subrefTotalMassReclaim] or 0) * 0.25
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                            tFriendlyNonPDBuildings = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryPD, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                            iFriendlyBuildingValue = M28UnitInfo.GetMassCostOfUnits(tFriendlyNonPDBuildings)
                            iCurValue = iCurValue + iFriendlyBuildingValue
                        else
                            iFriendlyBuildingValue = 0
                        end

                        --Increase for value of enemy mexes if moddist >=25%
                        if tLandZoneData[M28Map.refiModDistancePercent] >= 0.25 and tLandZoneData[M28Map.subrefLZOrWZMexCount] > 0 then
                            iCurValue = iCurValue + math.min(0, (tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) - (tLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0) * 3)
                        end

                        if tLZTeamData[M28Map.refbACUInTrouble] then
                            iCurValue = iCurValue + M28ACU.GetValueIncreaseForACUInTrouble(iTeam)
                        end

                        --Record the value
                        tLZTeamData[M28Map.subrefLZTValue] = iCurValue
                        tLZTeamData[M28Map.subrefLZSValue] = iFriendlyBuildingValue
                        tLZTeamData[M28Map.subrefLZbCoreBase] = nil

                        --Is this a core base land zone?
                        if bDebugMessages == true then LOG(sFunctionRef..': iCurValue based on this zone='..iCurValue..'; iFriendlyBuildingValue='..iFriendlyBuildingValue..'; Checking if we are a friendly land zone - tiPlateauAndLZWithFriendlyStartPosition='..repru(tiPlateauAndLZWithFriendlyStartPosition)..'; Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))..'; tLZTeamData[M28Map.subrefLZSValue] (if nil will ignore core zone)='..(tLZTeamData[M28Map.subrefLZSValue] or 0)) end
                        if (tiPlateauAndLZWithFriendlyStartPosition[iPlateau][iLandZone] or tLZTeamData[M28Map.subrefbCoreBaseOverride]) and ((tLZTeamData[M28Map.subrefLZSValue] or 0) > 0 or GetGameTimeSeconds() <= 300 or M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] <= 1) then
                            tLZTeamData[M28Map.subrefLZbCoreBase] = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Core LZ='..iLandZone..' for plateau '..iPlateau..'; All adjacent zones='..repru(tLandZoneData[M28Map.subrefLZAdjacentLandZones])..'; tiPlateauAndLZWithFriendlyStartPosition[iPlateau][iLandZone]=nil='..tostring(tiPlateauAndLZWithFriendlyStartPosition[iPlateau][iLandZone] == nil)..'; tLZTeamData[M28Map.subrefbCoreBaseOverride]='..tostring(tLZTeamData[M28Map.subrefbCoreBaseOverride] or false)..'; Island ref='..(tLandZoneData[M28Map.subrefLZIslandRef] or 'nil')) end
                            if not(M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iPlateau]) then
                                if not(M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau]) then M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau] = {} end
                                M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iPlateau] = {}
                            end
                            M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iPlateau][iLandZone] = true
                            --adjacent zones iwth lots of mexes in them and high mex count - consider treating as a core base
                        elseif tLandZoneData[M28Map.subrefLZOrWZMexCount] >= 4 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                            --Are we adjacent to a core zone and we contain a factory or high value unit? If so then treat us as a core LZ
                            bAdjacentToCoreFactory = false
                            if M28Utilities.IsTableEmpty(tLandZoneData[M28Map.subrefLZAdjacentLandZones]) == false then
                                for iEntry, iAdjLZ in tLandZoneData[M28Map.subrefLZAdjacentLandZones] do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we are adjacent to a core LZ, iAdjLZ='..iAdjLZ..'; Is AdjLZ a core LZ='..tostring(tPlateauData[M28Map.subrefPlateauLandZones][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase])) end
                                    if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] then
                                        bAdjacentToCoreFactory = true
                                        break
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': bAdjacentToCoreFactory='..tostring(bAdjacentToCoreFactory)..'; Is table of factory HQs empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(iBaseCategory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))) end
                                if bAdjacentToCoreFactory and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(iBaseCategory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Are adjacent to a core factory, and have iBaseCategory units in this zone, iLandZone='..iLandZone..'; iPlateau='..iPlateau) end
                                    tLZTeamData[M28Map.subrefLZbCoreBase] = true
                                    if not(M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iPlateau]) then
                                        if not(M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau]) then M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau] = {} end
                                        M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iPlateau] = {}
                                    end
                                    M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iPlateau][iLandZone] = true
                                end
                            end
                        end
                        --'Rebuild former core base of a dead teammate' logic - handle this via separate function that rechecks every 30s if we want to reflag as a core base, ReviewTreatingOldBaseAsCoreBase


                        if iZonesSinceWait >= iZonesPerTick and iCurCycleCount > 1 then --dont want to wait the first time, as on large maps can mean a delay in the ACU building
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitTicks(1)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                            iZonesSinceWait = 0
                        end
                    end
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1) --Needed to avoid infinite loop if are no LZs (e.g. on a water map)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    else
        M28Utilities.ErrorHandler('No active M28 brain')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageAllLandZones(aiBrain, iTeam, bIgnoreMinorPlateaus, iCurMinorPlateauCycleRef)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageAllLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iLastRefreshCount = (tLZRefreshCountByTeam[iTeam] or 1)
    local iCurRefreshCount = 0
    local iTicksToSpreadOver = iTicksPerLandCycle --Default is 10, i.e. 1 second
    local iRefreshThreshold = math.max(2, math.ceil(iLastRefreshCount * 0.95 / iTicksToSpreadOver))
    local iCurCycleRefreshCount = 0
    local iCurTicksWaited = 0

    if bDebugMessages == true then
        LOG(sFunctionRef..': Start of code, Time='..GetGameTimeSeconds()..'; iTeam='..iTeam..'; If have an ACU will list its plateau and land zone. iRefreshThreshold='..iRefreshThreshold..'; iLastRefreshCount='..iLastRefreshCount..'; iTicksToSpreadOver='..iTicksToSpreadOver)
        local tOurACU = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
        if M28Utilities.IsTableEmpty(tOurACU) == false then
            local iACUPlateau, iACULZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tOurACU[1]:GetPosition(), true, tOurACU[1])
            LOG(sFunctionRef..': ACU is at plateau '..iACUPlateau..'; LZ='..iACULZ)
        end
    end

    --Cycle through land zones
    for iPlateau, tPlateauData in M28Map.tAllPlateaus do
        if bIgnoreMinorPlateaus or not(tPlateauData[M28Map.subrefiMinorCycleRef]) or tPlateauData[M28Map.subrefiMinorCycleRef] == iCurMinorPlateauCycleRef then
            RefreshLandRallyPoints(iTeam, iPlateau)

            if M28Utilities.IsTableEmpty(tPlateauData[M28Map.subrefPlateauLandZones]) == false then
                if bDebugMessages == true then
                    LOG(sFunctionRef..': About to cycle through every land zone in plateau '..iPlateau..'; subrefLandZoneCount='..tPlateauData[M28Map.subrefLandZoneCount])
                end
                for iLandZone, tLandZoneDataByTeam in tPlateauData[M28Map.subrefPlateauLandZones] do
                    local tLZTeamData = tLandZoneDataByTeam[M28Map.subrefLZTeamData][iTeam]

                    if bDebugMessages == true then
                        LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Is table of enemey units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))..'; Is table of friendly units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))..'; GameTime='..GetGameTimeSeconds()..'; Is table of enemy air units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]))..'; iTeam='..iTeam)
                    end
                    --First check all units in here are alive
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                        iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                        --UpdateUnitPositionsAndLandZone(aiBrain, tUnits,                               iTeam, iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
                        if bDebugMessages == true then LOG(sFunctionRef..': Just ran updateunitpositions for enemy units in this zone') end
                    end
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) == false then
                        iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                    end
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                        iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                    end

                    ForkThread(ManageSpecificLandZone, aiBrain, iTeam, iPlateau, iLandZone)
                    iCurCycleRefreshCount = iCurCycleRefreshCount + 1

                    if iCurCycleRefreshCount >= iRefreshThreshold then
                        iCurRefreshCount = iCurRefreshCount + iCurCycleRefreshCount
                        iCurCycleRefreshCount = 0
                        if iCurTicksWaited < iTicksToSpreadOver then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitTicks(1)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                            iCurTicksWaited = iCurTicksWaited + 1
                            if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting 1 tick as reached iCurCycleRefreshCount='..iCurCycleRefreshCount..'; aiBrain.M28IsDefeated='..tostring(aiBrain.M28IsDefeated or false)..'; aiBrain='..(aiBrain.Nickname or 'nil')) end
                            if aiBrain.M28IsDefeated or not(aiBrain) then
                                aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                                if not(aiBrain) or aiBrain.M28IsDefeated then
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                    return nil
                                end
                            end
                        end
                    end
                end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Warning - no land zones found for plateau '..iPlateau) end
            end
        end
    end
    iCurRefreshCount = iCurRefreshCount + iCurCycleRefreshCount
    if bDebugMessages == true then LOG(sFunctionRef..': About to update refresh count now that completed loop, iCurRefreshCount='..(iCurRefreshCount or 'nil')..'; tLZRefreshCountByTeam[iTeam] before updating to reflect this='..(tLZRefreshCountByTeam[iTeam] or 'nil')) end
    tLZRefreshCountByTeam[iTeam] = iCurRefreshCount

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function LandZoneOverseer(iTeam)
    --Periodically cycles through every land zone and refreshes the unit details
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'LandZoneOverseer'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
    if aiBrain then
        if aiBrain.HostileCampaignAI and tonumber(ScenarioInfo.Options.CmpAIDelay) > GetGameTimeSeconds() + 1.1 then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(tonumber(ScenarioInfo.Options.CmpAIDelay) - GetGameTimeSeconds() -1.1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end

        if bDebugMessages == true then LOG(sFunctionRef..': About to start the main loop for land zones provided we have friendly M28 brains in the team '..iTeam..'; is table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end
        ForkThread(AssignValuesToLandZones, iTeam)

        local iWaitCount = 0
        while not(M28Map.bMapLandSetupComplete) or GetGameTimeSeconds() <= 5.1 or ((M28Utilities.bLoudModActive or M28Utilities.bQuietModActive or M28Utilities.bSteamActive) and GetGameTimeSeconds() <= 6) do
            iWaitCount = iWaitCount + 1
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if iWaitCount >= 200 then M28Utilities.ErrorHandler('Have waited more than '..iWaitCount..' and map setup not complete, will proceed but likely AI wont work') break end
        end

        local iMinorCycleCount = 0
        while M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false do
            if ScenarioInfo.OpEnded and M28Map.bIsCampaignMap and GetGameTimeSeconds() <= 120 then
                while ScenarioInfo.OpEnded do
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(1)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                end
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) then break end
            end
            iMinorCycleCount = iMinorCycleCount + 1
            if iMinorCycleCount > 10 then iMinorCycleCount = 1 end
            if bDebugMessages == true then LOG(sFunctionRef..': Will call logic to refresh every unit in a land zone, iMinorCycleCount='..iMinorCycleCount) end
            ForkThread(ManageAllLandZones, aiBrain, iTeam, (GetGameTimeSeconds() <= 10 or M28Map.iPlateauCount <= 2000), iMinorCycleCount)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(iTicksPerLandCycle)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if aiBrain.M28IsDefeated and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': About to restart the loop for team '..iTeam..'; aiBrain referred to='..(aiBrain.Nickname or 'nil')..'; Is table of active m28 brains='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetLandZoneToRunTo(iTeam, iPlateau, iCurLandZone, sPathing, tOptionalStartPosition, tOptionalEnemyPositionToRunFrom)
    --Returns cur LZ if no LZ to run to, otherwise returns the land zone we think is best to run to from iCurLandZone
    --tOptionalStartPosition - if nil then will use midpoint of iCurLandZone
    --tOptionalEnemyPositionToRunFrom - if this is specified, then will pick al ocation based on angle from the start position to the location vs the start position angle to the enemy position to run to (so we run in the opposite direction to the enemy position if the opposite direction LZ is safe)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetLandZoneToRunTo'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': iTeam='..iTeam..'; iPlateau='..iPlateau..'; iCurLandZone='..iCurLandZone..'; sPathing='..sPathing..'; tOptionalStartPosition='..repru(tOptionalStartPosition)..'; tOptionalEnemyPositionToRunFrom='..repru(tOptionalEnemyPositionToRunFrom)) end

    local tLZShortlist = {}
    --See if we have any adjacent LZs with no enemy combat units in them - if so, then run here
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjacentLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefLZAdjacentLandZones] do
            if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjacentLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] == 0 then
                table.insert(tLZShortlist, iAdjacentLZ)
            end
        end
    end
    if M28Utilities.IsTableEmpty(tLZShortlist) then
        --Add each team start point on the same plateau
        local iPotentialPlateau, iPotentialLZ
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                iPotentialPlateau, iPotentialLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                if iPotentialPlateau == iPlateau and not(iPotentialLZ == iCurLandZone) then
                    table.insert(tLZShortlist, iPotentialLZ)
                end
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Getting LZ to run to from, iTeam='..iTeam..'; iPlateau='..iPlateau..'; iCurLandZone='..iCurLandZone..'; sPathing='..sPathing..'; tLZShortlist='..repru(tLZShortlist)) end
    if M28Utilities.IsTableEmpty(tLZShortlist) then
        --Nowhere to run to
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return iCurLandZone
    else
        local tStartPoint = (tOptionalStartPosition or M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefMidpoint])
        local iPreferredLZRef
        if tOptionalEnemyPositionToRunFrom then
            --Go to the angle furthest in angle away from the nearest enemy
            local iAngleToEnemy = M28Utilities.GetAngleFromAToB(tStartPoint, tOptionalEnemyPositionToRunFrom)
            local iCurAngleDif
            local iHighestAngleDif = 0
            for _, iPossibleLZ in tLZShortlist do
                iCurAngleDif = M28Utilities.GetAngleDifference(iAngleToEnemy, M28Utilities.GetAngleFromAToB(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefMidpoint]))
                if iCurAngleDif > iHighestAngleDif then
                    iHighestAngleDif = iCurAngleDif
                    iPreferredLZRef = iPossibleLZ
                end
            end
        else
            --dont have angle to nearest enemy so just pick the closest land zone

            local iClosestLZDistance = 100000
            local iClosestLZRef
            local iCurDist
            for _, iPossibleLZ in tLZShortlist do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering distance from tStartPoint to iPossibleLZ '..(iPossibleLZ or 'nil')..'; Midpoint of that LZ='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefMidpoint])..'; iCurDist='..(M28Utilities.GetTravelDistanceBetweenPositions(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefMidpoint], sPathing) or 'nil')) end
                iCurDist = M28Utilities.GetTravelDistanceBetweenPositions(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefMidpoint], sPathing)
                --Backup - if the built in pathfinding doesnt htink we can path there (e.g. we are by a cliff) then use straight line distance
                if not(iCurDist) then iCurDist = M28Utilities.GetDistanceBetweenPositions(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefMidpoint]) + 30 end

                if iCurDist < iClosestLZDistance then
                    iClosestLZDistance = iCurDist
                    iPreferredLZRef = iPossibleLZ
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return iPreferredLZRef
    end
end

function IsLandZonePathSafe(iPlateau, tLZData, iTeam, iPathingRef, bIslandPathing)
    --More performant version of IsItSafeToPathBetweenLandZones, to check if safe to path from the tLZData land zone to the tAltLZ land zone, based on iPathingRef for tLZData
    --bIslandPathing shoudl be true if are trying to path to an island (i.e. that a land unit cant get to), so the correct table references are used
    if bIslandPathing then
        for _, iLandZoneRef in tLZData[M28Map.subrefLZPathingToOtherIslands][iPathingRef][M28Map.subrefIslandLZPath] do
            --Are there any units in this LZ that are dangerous?
            if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZoneRef][iTeam][M28Map.subrefbDangerousEnemiesInThisLZ] then
                return false
            end
        end
    else
        if tLZData[M28Map.subrefLZPathingToOtherLandZones][iPathingRef][M28Map.subrefLZPath] then
            for _, iLandZoneRef in tLZData[M28Map.subrefLZPathingToOtherLandZones][iPathingRef][M28Map.subrefLZPath] do
                --Are there any units in this LZ that are dangerous?
                if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZoneRef][iTeam][M28Map.subrefbDangerousEnemiesInThisLZ] then
                    return false
                end
            end
        end
    end
    return true
end

--Below code should function but when used for engineers took way too long so redid using IsLandZonePathSafe - look to make use of the varaibles recorded for this to come up with a more performant approach to the below if want the below functionality
--[[function IsItSafeToPathBetweenLandZones(iTeam, iPlateau, iStartLandZone, iEndLandZone, sPathing)
    --Returns true if no enemy threats in any of the land zones that will path through (doesnt consider adjacent zones for performance reasons)
        --Only combat threats should be considered
        --WARNING - Very intensive function, use sparingly - in most cases referring to subrefLZPathingToOtherLandZones is better which will record 3 layers of adjacency to the current zone (more for core LZs)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsItSafeToPathBetweenLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tFullPath, iPathSize, iDistance = NavUtils.PathTo((sPathing or 'Land'), M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iStartLandZone][M28Map.subrefMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iEndLandZone][M28Map.subrefMidpoint], nil)
    if M28Utilities.IsTableEmpty(tFullPath) == false then
        local tLZConsidered = {}
        local iCurPlateau, iCurLZ
        for iPath, tPath in tFullPath do
            iCurPlateau, iCurLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tPath)
            if iCurPlateau and iCurLZ then
                if not(tLZConsidered[iCurLZ]) then
                    tLZConsidered[iCurLZ] = true
                    --Are there any units in this LZ that are dangerous?
                    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                        for iUnit, oUnit in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits] do
                            if ((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or (oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0) and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) then
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return false
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return true
end--]]

function DrawReclaimSegmentsInLandZone(iPlateau, iLandZone, bIncludeMassValues)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DrawReclaimSegmentsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local rCurRect
    if bDebugMessages == true then LOG(sFunctionRef..': About to draw reclaim segnemtns for iPlateau '..iPlateau..' iLandZone '..iLandZone..'; Table of reclaim segments='..repru(tLZData[M28Map.subrefReclaimSegments])) end

    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefReclaimSegments]) == false then
        for iCount, tSegmentXZ in tLZData[M28Map.subrefReclaimSegments] do
            rCurRect = M28Utilities.GetRectAroundLocation(M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][M28Map.refReclaimSegmentMidpoint], M28Map.iReclaimSegmentSizeX * 0.5)
            M28Utilities.DrawRectangle(rCurRect)
            if bIncludeMassValues then LOG(sFunctionRef..': Considering segment '..reprs(tSegmentXZ)..'; Total mass reclaim='..M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][M28Map.refReclaimTotalMass]..'; Signif mass reclaim='..M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][M28Map.refReclaimTotalSignificantMass]) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function UpdateRecordedAllPlayerOmni(oRadar, bDestroyed)
    local oBP = oRadar:GetBlueprint()
    local iRadarOmni =  (oBP.Intel.OmniRadius or 0)

    if iRadarOmni > 0 then
        local iMaxZoneDistance = iRadarOmni + 50

        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oRadar:GetPosition())
        if iPlateau and iLandZone then
            local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
            if tLZData then
                function UpdateOmniCoverageForZone(iCurPlateauOrPond, iCurLZOrWZ, bIsWaterZone)
                    local tCurLZOrWZData
                    if bIsWaterZone then
                        tCurLZOrWZData = M28Map.tPondDetails[iCurPlateauOrPond][M28Map.subrefPondWaterZones][iCurLZOrWZ]
                    else tCurLZOrWZData = M28Map.tAllPlateaus[iCurPlateauOrPond][M28Map.subrefPlateauLandZones][iCurLZOrWZ]
                    end

                    --Remove oRadar from the table of omni in this zone
                    if bDestroyed then
                        if M28Utilities.IsTableEmpty(tCurLZOrWZData[M28Map.reftoAllOmniRadar]) == false then
                            --Update the table
                            local iEntryCount = table.getn(tCurLZOrWZData[M28Map.reftoAllOmniRadar])
                            for iCurEntry = iEntryCount, 1, -1 do
                                local oUnit = tCurLZOrWZData[M28Map.reftoAllOmniRadar][iCurEntry]
                                if not(M28UnitInfo.IsUnitValid(oUnit)) or oUnit == oRadar then
                                    table.remove(tCurLZOrWZData[M28Map.reftoAllOmniRadar], iCurEntry)
                                end
                            end
                        end
                    else
                        local bAddToTable = true
                        if not(tCurLZOrWZData[M28Map.reftoAllOmniRadar]) then tCurLZOrWZData[M28Map.reftoAllOmniRadar] = {}
                        else
                            for iUnit, oUnit in tCurLZOrWZData[M28Map.reftoAllOmniRadar] do
                                if oUnit == oRadar then bAddToTable = false break end
                            end
                        end
                        if bAddToTable and iRadarOmni - M28Utilities.GetDistanceBetweenPositions(oRadar:GetPosition(), tCurLZOrWZData[M28Map.subrefMidpoint]) > 0 then
                            table.insert(tCurLZOrWZData[M28Map.reftoAllOmniRadar], oRadar)
                        end
                    end

                    local iBestOmniCoverage = 0
                    if M28Utilities.IsTableEmpty(tCurLZOrWZData[M28Map.reftoAllOmniRadar]) == false then
                        local iCurOmniCoverage
                        for iUnit, oUnit in tCurLZOrWZData[M28Map.reftoAllOmniRadar] do
                            iCurOmniCoverage = (oUnit:GetBlueprint().Intel.OmniRadius or 0)
                            if iCurOmniCoverage > iBestOmniCoverage  then
                                iCurOmniCoverage = math.max(0, iCurOmniCoverage - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tCurLZOrWZData[M28Map.subrefMidpoint]))
                                if iCurOmniCoverage > iBestOmniCoverage then
                                    iBestOmniCoverage = iCurOmniCoverage
                                end
                            end
                        end

                    end
                    tCurLZOrWZData[M28Map.refiAllOmniCoverage] = iBestOmniCoverage
                end

                UpdateOmniCoverageForZone(iPlateau, iLandZone, false)
                M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData)
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                    for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                        if tSubtable[M28Map.subrefiDistance] > iMaxZoneDistance then break end
                        UpdateOmniCoverageForZone(tSubtable[M28Map.subrefiPlateauOrPond], tSubtable[M28Map.subrefiLandOrWaterZoneRef], tSubtable[M28Map.subrefbIsWaterZone])
                    end
                end
            end
        end
    end
end

function UpdateRadarCoverageForDestroyedRadar(oRadar)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateRadarCoverageForDestroyedRadar'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --First update land zones
    if bDebugMessages == true then LOG(sFunctionRef..': oRadar has been destroyed, oRadar='..oRadar.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRadar)..'; Time='..GetGameTimeSeconds()..'; Is table of zones covered by team empty='..tostring(M28Utilities.IsTableEmpty(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam]))) end
    if M28Utilities.IsTableEmpty(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam]) == false then
        for iTeam, tRadarData in oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam] do
            --local aiBrain = oRadar:GetAIBrain()
            --local iTeam = aiBrain.M28Team
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            if aiBrain then
                for iEntry, tiPlateauAndLZ in tRadarData do
                    local tLZData = M28Map.tAllPlateaus[tiPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][tiPlateauAndLZ[2]]
                    if tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar] == oRadar then
                        tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar] = nil
                        if M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmniVision] then
                            tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] = 5000
                            tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiOmniCoverage] = 5000
                        else
                            tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] = 0
                            tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiOmniCoverage] = 0
                        end

                        local tNearbyRadar = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryRadar, tLZData[M28Map.subrefMidpoint], 600, 'Ally')
                        local iCurIntelRange
                        local iBestIntelRange = 0
                        local oBestRadar
                        local iCurDist
                        local oBP
                        local iCurOmniRange
                        local iBestOmniRange = 0
                        if M28Utilities.IsTableEmpty(tNearbyRadar) == false then
                            for iUnit, oUnit in tNearbyRadar do
                                oBP = oUnit:GetBlueprint()
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                iCurIntelRange = (oBP.Intel.RadarRadius or 0) - iCurDist
                                iCurOmniRange = (oBP.Intel.OmniRadius or 0) - iCurDist
                                if iCurIntelRange > iBestIntelRange then
                                    iBestIntelRange = iCurIntelRange
                                    oBestRadar = oUnit
                                end
                                if iCurOmniRange > iBestOmniRange then
                                    iBestOmniRange = iCurOmniRange
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering nearby radar units for P='..tiPlateauAndLZ[1]..'Z'..tiPlateauAndLZ[2]..'; Is table of nearby radar empty='..tostring(M28Utilities.IsTableEmpty(tNearbyRadar))..'; oBestRadar='..(oBestRadar.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBestRadar) or 'nil')) end
                        if oBestRadar then
                            tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar] = oBestRadar
                            if M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmniVision] then
                                tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] = 5000
                                tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiOmniCoverage] = 5000
                            else
                                tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] = iBestIntelRange
                                tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiOmniCoverage] = iBestOmniRange
                            end
                            if not(oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam]) then oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam] = {} end
                            if not(oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam]) then oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam] = {} end
                            table.insert(oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam], {tiPlateauAndLZ[1], tiPlateauAndLZ[2]})
                        end
                    end
                end
            end
        end
    end
    --Then update water zones:
    if M28Utilities.IsTableEmpty(oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam]) == false then
        for iTeam, tRadarData in oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam] do
            --local aiBrain = oRadar:GetAIBrain()
            --local iTeam = aiBrain.M28Team

            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            if aiBrain then
                local iPond
                for iEntry, iWaterZone in tRadarData do
                    iPond = M28Map.tiPondByWaterZone[iWaterZone]
                    local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
                    local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                    if tWZTeamData[M28Map.refoBestRadar] == oRadar then
                        tWZTeamData[M28Map.refoBestRadar] = nil
                        if M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmniVision] then
                            tWZTeamData[M28Map.refiRadarCoverage] = 5000
                            tWZTeamData[M28Map.refiOmniCoverage] = 5000
                        else
                            tWZTeamData[M28Map.refiRadarCoverage] = 0
                            tWZTeamData[M28Map.refiOmniCoverage] = 0
                        end
                        local tNearbyRadar = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryRadar, tWZData[M28Map.subrefMidpoint], 600, 'Ally')
                        local iCurIntelRange
                        local iBestIntelRange = 0
                        local oBestRadar
                        local iCurDist
                        local oBP
                        local iCurOmniRange
                        local iBestOmniRange = 0
                        if M28Utilities.IsTableEmpty(tNearbyRadar) == false then
                            for iUnit, oUnit in tNearbyRadar do
                                oBP = oUnit:GetBlueprint()
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tWZData[M28Map.subrefMidpoint])
                                iCurIntelRange = (oBP.Intel.RadarRadius or 0) - iCurDist
                                if iCurIntelRange > iBestIntelRange then
                                    iBestIntelRange = iCurIntelRange
                                    oBestRadar = oUnit
                                end
                                iCurOmniRange = (oBP.Intel.OmniRadius or 0) - iCurDist
                                if iCurOmniRange > iBestOmniRange then
                                    iBestOmniRange = iCurOmniRange
                                end
                            end
                        end
                        if oBestRadar then
                            tWZTeamData[M28Map.refoBestRadar] = oBestRadar
                            if M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmniVision] then
                                tWZTeamData[M28Map.refiRadarCoverage] = 5000
                                tWZTeamData[M28Map.refiOmniCoverage] = 5000
                            else
                                tWZTeamData[M28Map.refiRadarCoverage] = iBestIntelRange
                                tWZTeamData[M28Map.refiOmniCoverage] = iBestOmniRange
                            end
                            if not(oBestRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam]) then oBestRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam] = {} end
                            if not(oBestRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam]) then oBestRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam] = {} end
                            table.insert(oBestRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam], iWaterZone)
                        end
                    end
                end
            end
        end
    end
    --Then update enemy recorded omni range
    UpdateRecordedAllPlayerOmni(oRadar, true)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateZoneIntelForRadar(oRadar)
    --If just built radar then want to update all land zones for the team to indicate the intel coverage
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateZoneIntelForRadar'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iTeam = oRadar:GetAIBrain().M28Team
    if bDebugMessages == true then LOG(sFunctionRef..': Just built radar '..oRadar.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRadar)..' owned by '..oRadar:GetAIBrain().Nickname..' with M28Team '..iTeam..'; is the table of active m28 brains for this team empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))..'; Time='..GetGameTimeSeconds()) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        if not(oRadar['M28UpdatedIntel']) then
            oRadar['M28UpdatedIntel'] = true
            local oBP = oRadar:GetBlueprint()
            local iIntelRange = (oBP.Intel.RadarRadius or 0)
            local iCurIntelRange
            local iOmniRange = (oBP.Intel.OmniRadius or 0)
            if bDebugMessages == true then LOG(sFunctionRef..': Radar intel range='..iIntelRange) end
            if iIntelRange > 0 or iOmniRange > 0 then
                --Update land zones:
                local iBasePlateau, iBaseZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oRadar:GetPosition())
                local bImprovedIntelCoverageOfZone = false
                local tPotentiallyObsoleteRadar = {}
                for iPlateau, tPlateauSubtable in M28Map.tAllPlateaus do
                    for iLandZone, tLZData in tPlateauSubtable[M28Map.subrefPlateauLandZones] do
                        if tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] < iIntelRange then
                            iCurIntelRange = iIntelRange - M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oRadar:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateau '..iPlateau..' Land zone '..iLandZone..'; iCurIntelRange factoring in distance='..iCurIntelRange..'; Distance='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oRadar:GetPosition())..'; LZ current radar coverage='..tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage]..'; tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar]='..(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar]) or 'nil')) end
                            if iCurIntelRange > tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] then
                                if iCurIntelRange > iIntelThresholdForPriorityScout then bImprovedIntelCoverageOfZone = true end
                                --First remove this plateau and LZ from the existing radar if there was one
                                if M28UnitInfo.IsUnitValid(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar]) then
                                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar][reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam]) == false then
                                        for iEntry, tiPlateauAndLZ in tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar][reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam] do
                                            if tiPlateauAndLZ[1] == iPlateau and tiPlateauAndLZ[2] == iLandZone then
                                                table.remove(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar][reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam], iEntry)
                                                break
                                            end
                                        end
                                    end
                                    if not(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar]:IsUnitState('Upgrading')) then
                                        table.insert(tPotentiallyObsoleteRadar, tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar])
                                        if bDebugMessages == true then LOG(sFunctionRef..': Added radar '..tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar].UnitId..M28UnitInfo.GetUnitLifetimeCount(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar])..' to potentially obsolete table') end
                                    end
                                end
                                if M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmniVision] then
                                    tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] = 5000
                                    tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiOmniCoverage] = 5000
                                else
                                    tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] = iCurIntelRange
                                    tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar] = oRadar
                                end
                                if not(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam]) then oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam] = {} end
                                if not(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam]) then oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam] = {} end
                                table.insert(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam], {iPlateau, iLandZone})
                                if bDebugMessages == true then LOG(sFunctionRef..': Finished udpating for the new intel range, tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage]='..tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage]) end
                            end
                        end
                        if iOmniRange > (tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiOmniCoverage] or 0) then
                            tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiOmniCoverage] = math.max((tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiOmniCoverage] or 0), iOmniRange - M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oRadar:GetPosition()))
                        end
                    end
                end
                --Update any units wanting priority land scouts in cae they now have good enough coverage
                local tiLandSubteams = {}
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    tiLandSubteams[oBrain.M28LandSubteam] = true
                end

                for iLandSubteam, _ in tiLandSubteams do
                    if M28Conditions.IsTableOfUnitsStillValid(M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout]) then
                        for iCurEntry = table.getn(M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout]), 1, -1 do
                            local oRecorded =  M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout][iCurEntry]
                            if oRecorded[refiCurrentAssignmentPlateauAndLZ][2] then
                                local tCurLZTeamData = M28Map.tAllPlateaus[oRecorded[refiCurrentAssignmentPlateauAndLZ][1]][M28Map.subrefPlateauLandZones][oRecorded[refiCurrentAssignmentPlateauAndLZ][2]][M28Map.subrefLZTeamData][iTeam]
                                if tCurLZTeamData[M28Map.refiRadarCoverage] >= iIntelThresholdForPriorityScout then
                                    oRecorded[refbFlaggedForPriorityScout] = nil
                                    oRecorded[refiTimeLastBuiltLandScoutForUnit] = nil
                                    table.remove(M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout], iCurEntry)
                                end
                            end
                        end
                    end
                end

                --Update water zones
                for iPond, tPondSubtable in M28Map.tPondDetails do
                    if M28Utilities.IsTableEmpty(tPondSubtable[M28Map.subrefPondWaterZones]) == false then
                        for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
                            local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                            if tWZTeamData[M28Map.refiRadarCoverage] < iIntelRange then
                                iCurIntelRange = iIntelRange - M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oRadar:GetPosition())
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering iPond '..iPond..' Water zone '..iWaterZone..'; iCurIntelRange factoring in distance='..iCurIntelRange..'; Distance='..M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oRadar:GetPosition())..'; WZ current radar coverage='..tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiRadarCoverage]) end
                                if iCurIntelRange > tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiRadarCoverage] then
                                    --First remove this WZ from the existing (worse) radar if there was one
                                    if M28UnitInfo.IsUnitValid(tWZTeamData[M28Map.refoBestRadar]) then
                                        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.refoBestRadar][M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam]) == false then
                                            for iEntry, iRecordedWaterZone in tWZTeamData[M28Map.refoBestRadar][M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam] do
                                                if iRecordedWaterZone == iWaterZone then
                                                    table.remove(tWZTeamData[M28Map.refoBestRadar][M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam], iEntry)
                                                    break
                                                end
                                            end
                                        end
                                    end
                                    --Now assign this WZ to this radar as providing the best coverage
                                    if M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmniVision] then
                                        tWZTeamData[M28Map.refiRadarCoverage] = 5000
                                        tWZTeamData[M28Map.refiOmniCoverage] = 5000
                                    else
                                        tWZTeamData[M28Map.refiRadarCoverage] = iCurIntelRange
                                    end
                                    tWZTeamData[M28Map.refoBestRadar] = oRadar
                                    if not(oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam]) then oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam] = {} end
                                    if not(oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam]) then oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam] = {} end
                                    table.insert(oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam], iWaterZone)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished udpating for the new intel range, iWaterZone='..iWaterZone..'; tWZTeamData[M28Map.refiRadarCoverage]='..tWZTeamData[M28Map.refiRadarCoverage]) end
                                    table.insert(tPotentiallyObsoleteRadar, tWZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar])
                                end
                            end
                            if iOmniRange > (tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiOmniCoverage] or 0) then
                                tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiOmniCoverage] = math.max((tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiOmniCoverage] or 0), iOmniRange - M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oRadar:GetPosition()))
                            end
                        end
                    end
                end

                --Filter to obsolete radar and ctrl-K these (or record against the best radar if the best radar isn't constructed yet)
                if bDebugMessages == true then LOG(sFunctionRef..': Finished cycling through zones, is table of obsolete radar empty='..tostring(M28Utilities.IsTableEmpty(tPotentiallyObsoleteRadar))) end
                oRadar[reftoUnitsToKillOnCompletion] = nil
                if M28Utilities.IsTableEmpty(tPotentiallyObsoleteRadar) == false then
                    local tUniqueList = {}
                    local iUnitRef
                    local oBrain
                    for iUnit, oUnit in tPotentiallyObsoleteRadar do
                        oBrain = oUnit:GetAIBrain()
                        if oBrain.M28AI then
                            iUnitRef = oBrain:GetArmyIndex()..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Will add unit with ref incl ai index of '..iUnitRef..' to tUniqueList') end
                            if not(tUniqueList[iUnitRef]) then
                                tUniqueList[iUnitRef] = oUnit
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is tUniqueList empty='..tostring( M28Utilities.IsTableEmpty(tUniqueList))) end
                    if M28Utilities.IsTableEmpty(tUniqueList) == false then
                        local tUnitsToKill = {}
                        for iUnit, oUnit in tUniqueList do
                            local oBP = oUnit:GetBlueprint()
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with radar radius '..(oBP.Intel.RadarRadius or 0)..' vs iIntelRange='..iIntelRange..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)) end
                            if (oBP.Intel.RadarRadius or 0) < math.max(1, iIntelRange) and (oBP.Intel.OmniRadius or 0) < math.max(1, iOmniRange) then
                                if (not(oUnit[M28UnitInfo.refbCampaignTriggerAdded]) or not(M28Map.bIsCampaignMap)) and (not(oUnit:IsUnitState('Upgrading')) or (M28UnitInfo.GetUnitTechLevel(oRadar) >= 3 and EntityCategoryContains(categories.TECH1, oUnit.UnitId))) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Adding unit to list of units to kill on completeion') end
                                    table.insert(tUnitsToKill, oUnit)
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(tUnitsToKill) == false then
                            if oRadar:GetFractionComplete() < 1 then
                                oRadar[reftoUnitsToKillOnCompletion] = tUnitsToKill
                            else
                                local iTotalCount = table.getn(tUnitsToKill)
                                for iEntry = iTotalCount, 1, -1 do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Radar '..tUnitsToKill[iEntry].UnitId..M28UnitInfo.GetUnitLifetimeCount(tUnitsToKill[iEntry])..' has radar range of '..(tUnitsToKill[iEntry]:GetBlueprint().Intel.RadarRadius or 0)..' and is obsolete by oRadar '..oRadar.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRadar)..'; with iIntelRange='..iIntelRange) end
                                    M28Orders.IssueTrackedKillUnit(tUnitsToKill[iEntry])
                                end
                            end
                        end
                    end
                end
                local tBaseLZTeamData = M28Map.tAllPlateaus[iBasePlateau][M28Map.subrefPlateauLandZones][iBaseZone][M28Map.subrefLZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': iBasePlateau='..iBasePlateau..'; iBaseZone='..iBaseZone..'; tBaseLZTeamData radar coverage='..tBaseLZTeamData[M28Map.refiRadarCoverage]) end
                --Backup - have the zone the radar is in have a minimum level of coverage so we dont massively overbuild
                local iRadarThreshold = math.max(iIntelRange * 0.6, iIntelRange - 80)
                if tBaseLZTeamData[M28Map.refiRadarCoverage] < iRadarThreshold then
                    tBaseLZTeamData[M28Map.refiRadarCoverage] = iRadarThreshold
                    if bDebugMessages == true then LOG(sFunctionRef..': Setting radar range equal to 60% of the units, iRadarThreshold='..iRadarThreshold) end
                end

                --Remove priority land scout flag on any ACUs if we have just built omni
                if iIntelRange > M28UnitInfo.iT2RadarSize and M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftM28ACUs]) then
                    for iACU, oACU in M28Team.tTeamData[iTeam][M28Team.reftM28ACUs] do
                        RemoveUnitFromPriorityLandScoutFlagTable(oACU)
                    end
                end
            end
            UpdateRecordedAllPlayerOmni(oRadar, false)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TrackWallSegment(oWall, bJustBuilt)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TrackWallSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oWall:GetPosition())
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oWall='..(oWall.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oWall) or 'nil')..'; bJustBuilt='..tostring(bJustBuilt)..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; Time='..GetGameTimeSeconds()) end
    if iLandZone > 0 then
        local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
        if bJustBuilt then
            local bAlreadyRecorded = false
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPlayerWallSegments]) == false then
                for iUnit, oUnit in tLZData[M28Map.subrefLZPlayerWallSegments] do
                    if oWall == oUnit then
                        bAlreadyRecorded = true
                        break
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished considering whether to add wall, bAlreadyRecorded='..tostring(bAlreadyRecorded)) end
            if not(bAlreadyRecorded) then
                table.insert(tLZData[M28Map.subrefLZPlayerWallSegments], oWall)
                --Consider adding to nearby zones incase wall is built inbetween two zones
                local iAltPlateau, iAltLandZone
                local tbZonesConsidered = {}
                tbZonesConsidered[iLandZone] = true
                for iCurAngle = 0, 315, 45 do
                    local tAltPosition = M28Utilities.MoveInDirection(oWall:GetPosition(), iCurAngle, 8, true, false, false)
                    if tAltPosition then
                        iAltPlateau, iAltLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tAltPosition)
                        if iAltLandZone and not(tbZonesConsidered[iAltLandZone]) and iAltPlateau == iPlateau then
                            tbZonesConsidered[iAltLandZone] = true
                            local tAltLZData = M28Map.tAllPlateaus[iAltPlateau][M28Map.subrefPlateauLandZones][iAltLandZone]
                            if not(tAltLZData[M28Map.subrefLZPlayerWallSegments]) then tAltLZData[M28Map.subrefLZPlayerWallSegments] = {} end
                            table.insert(tAltLZData[M28Map.subrefLZPlayerWallSegments], oWall)
                            if not(oWall[M28UnitInfo.reftiWallAdjacentLandZonesRecorded]) then oWall[M28UnitInfo.reftiWallAdjacentLandZonesRecorded] = {} end
                            table.insert(oWall[M28UnitInfo.reftiWallAdjacentLandZonesRecorded], iAltLandZone)
                        end
                    end
                end
            end
        else
            function RemoveWallFromLandZone(tCurLZData)
                if M28Utilities.IsTableEmpty(tCurLZData[M28Map.subrefLZPlayerWallSegments]) == false then
                    --Remove any old entries
                    local iRevisedIndex = 1
                    local iTableSize = table.getn(tCurLZData[M28Map.subrefLZPlayerWallSegments])
                    if bDebugMessages == true then LOG(sFunctionRef..': Will remove wall from table, iTableSize='..iTableSize) end
                    for iOrigIndex=1, iTableSize do
                        if tCurLZData[M28Map.subrefLZPlayerWallSegments][iOrigIndex] then
                            if not(tCurLZData[M28Map.subrefLZPlayerWallSegments][iOrigIndex] == oWall) and M28UnitInfo.IsUnitValid(tCurLZData[M28Map.subrefLZPlayerWallSegments][iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                                --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                                if (iOrigIndex ~= iRevisedIndex) then
                                    tCurLZData[M28Map.subrefLZPlayerWallSegments][iRevisedIndex] = tCurLZData[M28Map.subrefLZPlayerWallSegments][iOrigIndex];
                                    tCurLZData[M28Map.subrefLZPlayerWallSegments][iOrigIndex] = nil;
                                end
                                iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                            else
                                tCurLZData[M28Map.subrefLZPlayerWallSegments][iOrigIndex] = nil;
                            end
                        end
                    end
                    if iRevisedIndex < iTableSize then
                        --table.setn(tCurLZData[M28Map.subrefLZPlayerWallSegments], iRevisedIndex - 1)
                        for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
                            table.remove(tCurLZData[M28Map.subrefLZPlayerWallSegments], iRemovalEntry)
                        end
                    end
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Finished removing, is table empty='..tostring(M28Utilities.IsTableEmpty(tCurLZData[M28Map.subrefLZPlayerWallSegments])))
                        if M28Utilities.IsTableEmpty(tCurLZData[M28Map.subrefLZPlayerWallSegments]) == false then
                            LOG(sFunctionRef..': Table size after removing='..table.getn(tCurLZData[M28Map.subrefLZPlayerWallSegments]))
                        end
                    end
                end
            end
            RemoveWallFromLandZone(tLZData)

            if M28Utilities.IsTableEmpty(oWall[M28UnitInfo.reftiWallAdjacentLandZonesRecorded]) == false then
                for _, iAdjLZ in oWall[M28UnitInfo.reftiWallAdjacentLandZonesRecorded] do
                    local tAltLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                    RemoveWallFromLandZone(tAltLZData)
                end
                oWall[M28UnitInfo.reftiWallAdjacentLandZonesRecorded] = nil
            end
        end
    end
end

function RecordEnemyFirebase(iTeam, iPlateau, iLandZone)
    --Searches for all nearby land zones to iLandZone and flags that there is an enemy firebase nearby
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordEnemyFirebase'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; iTeam='..iTeam..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone) end

    if not(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau]) then M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau] = {} end
    M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone] = {[M28Team.subrefiNearbyPlateauAndLandZones] = {}, [M28Team.subrefbInRangeOfCoreLZ] = false, {}}
    --Record any land zones in range of here
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]

    M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData)
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
        local iLandLZThreshold = 163
        local iWaterLZThreshold = 200
        if M28Map.iMapSize >= 1000 then iLandLZThreshold = 190 iWaterLZThreshold = 230 end
        --Further increase threshold for if this is a large LZ
        local iBaseLZAverageSize = 0.5*((tLZData[M28Map.subrefLZMaxSegX] - tLZData[M28Map.subrefLZMinSegX])*M28Map.iLandZoneSegmentSize + (tLZData[M28Map.subrefLZMaxSegZ] - tLZData[M28Map.subrefLZMinSegZ])*M28Map.iLandZoneSegmentSize)

        iLandLZThreshold = math.max(iLandLZThreshold, iBaseLZAverageSize + 20, iBaseLZAverageSize * 0.5 + 125)
        iWaterLZThreshold = math.max(iWaterLZThreshold, iLandLZThreshold + 20)
        if bDebugMessages == true then LOG(sFunctionRef..': LZ X size='..(tLZData[M28Map.subrefLZMaxSegX] - tLZData[M28Map.subrefLZMinSegX])*M28Map.iLandZoneSegmentSize..'; LZ Z size='..(tLZData[M28Map.subrefLZMaxSegZ] - tLZData[M28Map.subrefLZMinSegZ])*M28Map.iLandZoneSegmentSize..'; iWaterLZThreshold='..iWaterLZThreshold..'; iLandLZThreshold='..iLandLZThreshold) end
        for iEntry, tPathingData in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering alt LZ entry='..tPathingData[M28Map.subrefiLandOrWaterZoneRef]..'; tPathingData[M28Map.subrefiDistance]='..tPathingData[M28Map.subrefiDistance]..'; Is water zone='..tostring(tPathingData[M28Map.subrefbIsWaterZone] or false)) end
            if tPathingData[M28Map.subrefiDistance] > iWaterLZThreshold then
                break
            end --163 used for land zones, 200 for water zones
            local tAltLZOrWZData
            local tAltLZOrWZTeamData
            if tPathingData[M28Map.subrefbIsWaterZone] then
                tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[tPathingData[M28Map.subrefiLandOrWaterZoneRef]]][M28Map.subrefPondWaterZones][tPathingData[M28Map.subrefiLandOrWaterZoneRef]]
                tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
            elseif tPathingData[M28Map.subrefiDistance] >= 163 then
                tAltLZOrWZData = M28Map.tAllPlateaus[tPathingData[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefiLandOrWaterZoneRef]]
                tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
            end
            if tAltLZOrWZData then
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iAltLZ='..tPathingData[M28Map.subrefiLandOrWaterZoneRef]..'; Dist from that LZ midpoint to the firebase LZ midpoint='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tAltLZOrWZData[M28Map.subrefMidpoint])..'; tPathingData[M28Map.subrefiDistance]='..tPathingData[M28Map.subrefiDistance]) end
                --The LZ is potentially within range of this firebase so record against that LZ
                if not(tAltLZOrWZTeamData[M28Map.subreftEnemyFirebasesInRange]) then tAltLZOrWZTeamData[M28Map.subreftEnemyFirebasesInRange] = {} end
                table.insert(tAltLZOrWZTeamData[M28Map.subreftEnemyFirebasesInRange], {iPlateau, iLandZone})

                --Also record against the base plateau and LZ all the alt LZs that we have been recorded against
                if tPathingData[M28Map.subrefbIsWaterZone] then
                    --Water zone
                    if not(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefiNearbyWaterZones]) then M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefiNearbyWaterZones] = {} end
                    table.insert(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefiNearbyWaterZones], tPathingData[M28Map.subrefLZNumber])
                    if bDebugMessages == true then LOG(sFunctionRef..': Recorded enemy firebase against teh water zone '..tPathingData[M28Map.subrefiLandOrWaterZoneRef]) end
                else
                    --Land zone - shorter dist threhsold
                    if tPathingData[M28Map.subrefiDistance] > iLandLZThreshold + math.max(0, iBaseLZAverageSize - 0.5*((tAltLZOrWZData[M28Map.subrefLZMaxSegX] - tAltLZOrWZData[M28Map.subrefLZMinSegX])*M28Map.iLandZoneSegmentSize + (tAltLZOrWZData[M28Map.subrefLZMaxSegZ] - tAltLZOrWZData[M28Map.subrefLZMinSegZ])*M28Map.iLandZoneSegmentSize)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': LZ too far away so wont record against here') end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Recorded enemy firebase against land zone '..tPathingData[M28Map.subrefiLandOrWaterZoneRef]) end
                        table.insert(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefiNearbyPlateauAndLandZones], {iPlateau, tPathingData[M28Map.subrefLZNumber]})

                        --If it is a core LZ then record that (as will want to adjust our behaviour accordingly)
                        if tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] then
                            M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefbInRangeOfCoreLZ] = true
                        end
                    end
                end
            end
        end
    end
    --Also add to this LZ
    if not(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]) then tLZTeamData[M28Map.subreftEnemyFirebasesInRange] = {} end
    table.insert(tLZTeamData[M28Map.subreftEnemyFirebasesInRange], {iPlateau, iLandZone})
    --Also record against the base plateau and LZ all the alt LZs that we have been recorded against
    table.insert(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefiNearbyPlateauAndLandZones], {iPlateau, iLandZone})


    if bDebugMessages == true then LOG(sFunctionRef..': Finished recording for all LZ likely in range of the firebase, reprs of reftEnemyFirebaseByPlateauAndLZ for this plateau and LZ='..reprs(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RemoveEnemyFirebase(iTeam, iPlateau, iLandZone)
    --Goes through all land zones that recirded iLandZone as having a firebase in range of them, and removes this entry
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefiNearbyPlateauAndLandZones]) == false then
        for iEntry, tPlateauAndLZ in M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefiNearbyPlateauAndLandZones] do
            local tAltLZTeamData = M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][tPlateauAndLZ[2]][M28Map.subrefLZTeamData][iTeam]
            if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
                for iFirebase, tPlateauAndLZ in tAltLZTeamData[M28Map.subreftEnemyFirebasesInRange] do
                    if tPlateauAndLZ[1] == iPlateau and tPlateauAndLZ[2] == iLandZone then
                        table.remove(tAltLZTeamData[M28Map.subreftEnemyFirebasesInRange], iFirebase)
                        break
                    end
                end
            end
        end
    end
    --Do same for water zones
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefiNearbyWaterZones]) == false then
        for iEntry, iWaterZone in M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefiNearbyWaterZones] do
            local tAltWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][iTeam]
            if M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
                for iFirebase, tPlateauAndLZ in tAltWZTeamData[M28Map.subreftEnemyFirebasesInRange] do
                    if tPlateauAndLZ[1] == iPlateau and tPlateauAndLZ[2] == iLandZone then
                        table.remove(tAltWZTeamData[M28Map.subreftEnemyFirebasesInRange], iFirebase)
                        break
                    end
                end
            end
        end
    end
end

function ConsiderIfHaveEnemyFirebase(iTeam, oT2Arti)
    --Considers if hte land zone that oT2Arti is in has enough T2 arti threat to justify being a firebase
    --Idea is to only flag a firebase for something that MML are not expected to be able to break through - e.g. 3+ T2 arti; for smaller amounts the hope is that the arti can be overwhelmed
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderIfHaveEnemyFirebase'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oT2Arti:GetPosition())
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
    if (iLandZone or 0) > 0 then
        local bHaveFirebase = false
        local tArtiLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
        local tAllT2Arti = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, tArtiLZTeamData[M28Map.subrefTEnemyUnits])
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of all T2 arti for this zone empty='..tostring(M28Utilities.IsTableEmpty(tAllT2Arti))) end
        if M28Utilities.IsTableEmpty(tAllT2Arti) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Table size='.. table.getn(tAllT2Arti)) end
            if (M28Utilities.bQuietModActive and table.getn(tAllT2Arti) >= 4) or (not(M28Utilities.bQuietModActive) and table.getn(tAllT2Arti) >= 3) then
                bHaveFirebase = true
            else
                local iConstructedT2Arti = 0
                local iShieldedT2Arti = 0
                for iArti, oArti in tAllT2Arti do
                    if M28UnitInfo.IsUnitValid(oArti) and oArti:GetFractionComplete() == 1 then
                        iConstructedT2Arti = iConstructedT2Arti + 1
                    end
                    if M28Utilities.IsTableEmpty(oArti[M28Building.reftoShieldsProvidingCoverage]) == false then
                        iShieldedT2Arti = iShieldedT2Arti + 1
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iConstructedT2Arti='..iConstructedT2Arti..'; iShieldedT2Arti='..iShieldedT2Arti) end
                if iConstructedT2Arti >= 1 and (M28Utilities.bLoudModActive or M28Utilities.bQuietModActive or (iConstructedT2Arti >= 2 and iShieldedT2Arti >= 1)) then
                    local iModDistThreshold = 0.5
                    if M28Map.iMapSize >= 1000 then iModDistThreshold = 0.45
                    elseif M28Map.iMapSize >= 512 then iModDistThreshold = 0.55
                    else
                        iModDistThreshold = 0.75
                    end
                    if tArtiLZTeamData[M28Map.refiModDistancePercent] >= iModDistThreshold then
                        bHaveFirebase = true
                    end
                end
                local iTotalKills = 0
                for iUnit, oUnit in tAllT2Arti do
                    iTotalKills = iTotalKills + (oUnit.VetExperience or oUnit.Sync.totalMassKilled or 0)
                end
                if iTotalKills >= 2500 or (iTotalKills >= 1500 and table.getn(tAllT2Arti) == 1) then
                    bHaveFirebase = true
                end
            end
        end
        if bHaveFirebase then
            --If we dont have a firebase recorded already then record one
            if bDebugMessages == true then LOG(sFunctionRef..': Will record firebase if havent already, is it nil for this plateau and zone='..tostring(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone] == nil)) end
            if not(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone]) then
                RecordEnemyFirebase(iTeam, iPlateau, iLandZone)
            end
        elseif M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone] then
            --If we have recorded a firebase for this LZ then need to remove it
            RemoveEnemyFirebase(iTeam, iPlateau, iLandZone)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderIfAnyEnemyTeamsStillHaveFirebaseOnT2ArtiDeath(oT2Arti)
    local iBaseTeam = oT2Arti:GetAIBrain().M28Team
    for iTeam = 1, M28Team.iTotalTeamCount do
        if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 0 and not(iTeam == iBaseTeam) then
            ConsiderIfHaveEnemyFirebase(iTeam, oT2Arti)
            --update tracking of t2 arti to reflect it is dead
            M28Team.RecordEnemyT2ArtiAgainstNearbyZones(iTeam, oT2Arti, true)
        end
    end
end

function ConsiderAssigningMAABodyguardToFatboy(oMAA, oFatboy, bJustReturnIfWantMoreMAAOrNot)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderAssigningMAABodyguardToFatboy'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain
    if bJustReturnIfWantMoreMAAOrNot then aiBrain = oFatboy:GetAIBrain() else aiBrain = oMAA:GetAIBrain() end
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oMAA='..(oMAA.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oMAA) or 'nil')..'; oFatboy='..oFatboy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFatboy)..'; Brain='..aiBrain.Nickname..'; Time='..GetGameTimeSeconds()) end
    local bWantToAssign = false
    if aiBrain.M28AI then
        local iExistingMAA = 0
        if not(M28Conditions.IsTableOfUnitsStillValid(oFatboy[reftoAssignedMAAGuards])) then
            oFatboy[reftoAssignedMAAGuards] = {}
        else
            iExistingMAA = table.getn(oFatboy[reftoAssignedMAAGuards])
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iExistingMAA='..iExistingMAA) end
        if iExistingMAA < iFatboySafeMAACount then
            if iExistingMAA < iFatboyBaseMAACount then bWantToAssign = true
            elseif M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyAirToGroundThreat] >= 7000 then
                if not(M28Conditions.TeamHasAirControl(aiBrain.M28Team)) or M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyAirToGroundThreat] >= 30000 then
                    bWantToAssign = true
                else
                    local tEnemyBombers = EntityCategoryFilterDown(M28UnitInfo.refCategoryBomber - categories.EXPERIMENTAL, M28Team.tTeamData[aiBrain.M28Team][M28Team.reftoAllEnemyAir])
                    if M28Utilities.IsTableEmpty(tEnemyBombers) == false then
                        local iBomberThreat = M28UnitInfo.GetMassCostOfUnits(tEnemyBombers, true)
                        if iBomberThreat >= 6000 then bWantToAssign = true end
                    end
                end
            end
        end
        if bWantToAssign and not(bJustReturnIfWantMoreMAAOrNot) then
            table.insert(oFatboy[reftoAssignedMAAGuards], oMAA)
            oMAA[refoAssignedUnitToGuard] = oFatboy
            if bDebugMessages == true then LOG(sFunctionRef..': Assigned MAA to guard the fatboy') end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bJustReturnIfWantMoreMAAOrNot then return bWantToAssign end
end

function ConsiderAssigningMAABodyguardToACU(oMAA)
    local oACU = oMAA:GetAIBrain()[M28ACU.refoPrimaryACU]
    if M28UnitInfo.IsUnitValid(oACU) and not(M28Conditions.IsTableOfUnitsStillValid(oACU[reftoAssignedMAAGuards])) then
        --if enemy has T2+ air or air to ground threat then assign
        local iTeam = oMAA:GetAIBrain().M28Team
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 2 or (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] or 0) > 0 then
            --Want to assign
            if not(oACU[reftoAssignedMAAGuards]) then oACU[reftoAssignedMAAGuards] = {} end
            table.insert(oACU[reftoAssignedMAAGuards], oMAA)
            oMAA[refoAssignedUnitToGuard] = oACU
        end
    end
end

function DontHaveJerichoAttackTarget(oJericho)
    if not(oJericho[M28UnitInfo.refbEasyBrain]) then
        local aiBrain = oJericho:GetAIBrain()
        local tEnemiesInRange = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryMobileLand * categories.TECH3 + M28UnitInfo.refCategoryNavalSurface - categories.TECH1, oJericho:GetPosition(), oJericho[M28UnitInfo.refiDFRange], 'Enemy')
        local oUnitToTarget
        if M28Utilities.IsTableEmpty(tEnemiesInRange) == false then
            local iHighestValue = 0
            local iCurValue
            local iMinRange = (oJericho[M28UnitInfo.refiDFMinRange] or -10) + 10
            for iUnit, oUnit in tEnemiesInRange do
                --Non-attached on land near-built unit that isnt inside minimum range?
                if not(oUnit:IsUnitState('Attached')) and oUnit:GetFractionComplete() >= 0.5 and not(M28UnitInfo.IsUnitUnderwater(oUnit)) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oJericho:GetPosition()) >= iMinRange then
                    iCurValue = (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * oUnit:GetFractionComplete()
                    if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then iCurValue = iCurValue * 0.1 end
                    if iCurValue > iHighestValue then
                        if (M28UnitInfo.GetBuildingSize(oUnit.UnitId) or 0) <= 4 then iCurValue = iCurValue * 0.3 end
                        if iCurValue > iHighestValue then
                            iHighestValue = iCurValue
                            oUnitToTarget = oUnit
                        end
                    end
                end
            end
        end
        if oUnitToTarget then
            --consider target leading
            local tGroundTarget
            if (oJericho[M28UnitInfo.refiDFAOE] or 0) > 0 and EntityCategoryContains(categories.MOBILE, oUnitToTarget.UnitId) and oUnitToTarget:IsUnitState('Moving') then
                local iWeaponVelocity
                local oBP = oJericho:GetBlueprint()
                if oBP.Weapon then
                    for iCurWeapon, oCurWeapon in oBP.Weapon do
                        if oCurWeapon.DamageRadius == oJericho[M28UnitInfo.refiDFAOE] then
                            iWeaponVelocity = oCurWeapon.MuzzleVelocity
                            break
                        end
                    end
                end
                if (iWeaponVelocity or 0) > 0 then
                    local iDistToEnemy = M28Utilities.GetDistanceBetweenPositions(oUnitToTarget:GetPosition(), oJericho:GetPosition())
                    local iTimeToImpact = 0.5 + iDistToEnemy / iWeaponVelocity
                    local iCurFacingDirection = M28UnitInfo.GetUnitFacingAngle(oUnitToTarget)
                    local iDistToLead = iTimeToImpact * (oUnitToTarget:GetBlueprint().Physics.MaxSpeed or 0)
                    local tLeadingTarget = M28Utilities.MoveInDirection(oUnitToTarget:GetPosition(), iCurFacingDirection, iDistToLead, true, false, M28Map.bIsCampaignMap)
                    if tLeadingTarget and M28Utilities.GetDistanceBetweenPositions(tLeadingTarget, oJericho:GetPosition()) >= (oJericho[M28UnitInfo.refiDFMinRange] or 0) then
                        tGroundTarget = {tLeadingTarget[1], tLeadingTarget[2], tLeadingTarget[3]}
                    end
                end
            end

            if tGroundTarget then
                M28Orders.IssueTrackedGroundAttack(oJericho, tGroundTarget, 1, false, 'JerGrnd', false, oUnitToTarget)
            else
                M28Orders.IssueTrackedAttack(oJericho, oUnitToTarget, false, 'JetAtk', false)
            end
            return false
        end
    end
    return true
end

function GetFarAwayLandThreatOfLongRangeUnits(tStartPoint, iTeam, bMinorZoneAdjustment, bAdjustForNearbyTML)
    local iLongRangeFurtherAwayThreat = 0
    local iPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tStartPoint)
    if iPlateau and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoLongRangeEnemyDFUnits]) == false then
        local tMobileLandLRThreat = EntityCategoryFilterDown(categories.MOBILE * categories.LAND, M28Team.tTeamData[iTeam][M28Team.reftoLongRangeEnemyDFUnits])
        local iUnitBaseThreat, iDistToMidpoint, iUnitPlateau, iUnitLandZone
        if M28Utilities.IsTableEmpty(tMobileLandLRThreat) == false then
            local iDistThreshold = 750
            if bMinorZoneAdjustment then iDistThreshold = 625 end
            for iUnit, oUnit in tMobileLandLRThreat do
                if M28UnitInfo.IsUnitValid(oUnit) then
                    --Only consider powerful units - e.g. fatboy
                    iUnitBaseThreat = (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) --want mass value since fatboy could regain its shield at any point
                    if bMinorZoneAdjustment then iUnitBaseThreat = iUnitBaseThreat * oUnit:GetFractionComplete() end
                    if iUnitBaseThreat >= 1000 then
                        --Only include if it can path to this zone
                        if NavUtils.GetLabel(M28Map.refPathingTypeHover, oUnit:GetPosition()) == iPlateau then
                            iDistToMidpoint = M28Utilities.GetDistanceBetweenPositions(tStartPoint, oUnit:GetPosition())
                            if iDistToMidpoint <= iDistThreshold then
                                if iDistToMidpoint <= 150 and not(bMinorZoneAdjustment) then
                                    iLongRangeFurtherAwayThreat = iLongRangeFurtherAwayThreat + iUnitBaseThreat * 1.2
                                elseif iDistToMidpoint <= 200 then
                                    iLongRangeFurtherAwayThreat = iLongRangeFurtherAwayThreat + iUnitBaseThreat
                                elseif iDistToMidpoint <= 400 then
                                    iLongRangeFurtherAwayThreat = iLongRangeFurtherAwayThreat + iUnitBaseThreat * 0.75
                                elseif iDistToMidpoint <= 600 then
                                    iLongRangeFurtherAwayThreat = iLongRangeFurtherAwayThreat + iUnitBaseThreat * 0.5
                                else
                                    iLongRangeFurtherAwayThreat = iLongRangeFurtherAwayThreat + iUnitBaseThreat * 0.25
                                end
                            end
                        end
                    end
                end
            end
            --Halve threat if we have a nearby TML battery
            if bAdjustForNearbyTML and iLongRangeFurtherAwayThreat > 2000 then
                local iBasePlateau, iBaseLZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tStartPoint)
                if iBasePlateau and iBaseLZ  then
                    local tLZTeamData = M28Map.tAllPlateaus[iBasePlateau][M28Map.subrefPlateauLandZones][iBaseLZ][M28Map.subrefLZTeamData][iTeam]
                    if tLZTeamData[M28Map.refbNearbyTMLBattery] or tLZTeamData[M28Map.refbGetTMLBattery] then
                        local tEnemyExperimental = EntityCategoryFilterDown(M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryMegalith, tMobileLandLRThreat)
                        if M28Utilities.IsTableEmpty(tEnemyExperimental) == false then
                            if M28Team.tTeamData[iTeam][M28Team.refbTMLBatteryMissedLots] then
                                --Only reduce threat slightly
                                iLongRangeFurtherAwayThreat = math.max(2000, iLongRangeFurtherAwayThreat * 0.8, iLongRangeFurtherAwayThreat - M28UnitInfo.GetMassCostOfUnits(tEnemyExperimental, true))
                            else
                                iLongRangeFurtherAwayThreat = math.max(2000, iLongRangeFurtherAwayThreat * 0.5, iLongRangeFurtherAwayThreat - M28UnitInfo.GetMassCostOfUnits(tEnemyExperimental, true))
                            end
                        end
                    end
                end
            end
        end
    end
    return iLongRangeFurtherAwayThreat
end

function RemoveUnitFromPriorityLandScoutFlagTable(oUnit)
    if oUnit[refbFlaggedForPriorityScout] then
        oUnit[refbFlaggedForPriorityScout] = nil
        local iLandSubteam = oUnit:GetAIBrain().M28LandSubteam
        if M28Conditions.IsTableOfUnitsStillValid(M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout]) then
            for iRecorded, oRecorded in M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout] do
                if oRecorded == oUnit then
                    table.remove(M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout], iRecorded)
                    break
                end
            end
        end
    end
end

function ConsiderPriorityLandScoutFlag(oUnit)
    if not(M28UnitInfo.IsUnitValid(oUnit[refoAssignedLandScout])) then
        local bInTable = false
        local iLandSubteam = oUnit:GetAIBrain().M28LandSubteam
        if oUnit[refbFlaggedForPriorityScout] == nil then
            if M28Utilities.IsTableEmpty(M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout]) == false then
                for iRecorded, oRecorded in M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout] do
                    if oRecorded == oUnit then
                        bInTable = true
                        oUnit[refbFlaggedForPriorityScout] = true
                        break
                    end
                end
            end
        end

        if not(bInTable) then
            if not(M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout]) then M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout] = {} end
            table.insert(M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout], oUnit)
            oUnit[refbFlaggedForPriorityScout] = true
        end
    end
end


function LandSubteamOverseer(iLandSubteam)
    local iStartPlateau, iStartZone
    local oFirstBrain
    for iBrain, oBrain in M28Team.tLandSubteamData[iLandSubteam][M28Team.subreftoFriendlyM28Brains] do
        oFirstBrain = oBrain
        break
    end
    iStartPlateau, iStartZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(M28Map.GetPlayerStartPosition(oFirstBrain))
    local iTeam = oFirstBrain.M28Team
    --Wait ticks based on team to spread out between different seconds
    WaitTicks(iTeam)
    local tStartLZData = M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iStartZone]
    local tStartLZTeamData = tStartLZData[M28Map.subrefLZTeamData][iTeam]

    while M28Utilities.IsTableEmpty(M28Team.tLandSubteamData[iLandSubteam][M28Team.subreftoFriendlyM28Brains]) == false do
        ForkThread(CompareNearbyAlliedAndEnemyLandThreats, iTeam, iLandSubteam, iStartPlateau, tStartLZData, tStartLZTeamData)
        WaitSeconds(10)
    end
end

function CompareNearbyAlliedAndEnemyLandThreats(iTeam, iLandSubteam, iStartPlateau, tStartLZData, tStartLZTeamData)
    --Assesses enemy mobile land threat and MAA threat on same island as our start position
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CompareNearbyAlliedAndEnemyLandThreats'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iMaxModDistance = 0.6
    local iMaxTravelDist = M28Map.iMapSize * 0.75
    local bHaveTeammates = false
    if table.getn(M28Team.tLandSubteamData[iLandSubteam][M28Team.subreftoFriendlyM28Brains]) > 1 then bHaveTeammates = true end
    local iOurMobileDFThreat = tStartLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
    local iEnemyMobileDFThreat = tStartLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]
    local iEnemyGroundAAThreat = tStartLZTeamData[M28Map.subrefiThreatEnemyGroundAA]
    local iCurLZ
    local iEnemyNetMobileDFCloseToBase = 0
    if M28Utilities.IsTableEmpty(tStartLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
        for iEntry, tPathingData in tStartLZData[M28Map.subrefLZPathingToOtherLandZones] do
            iCurLZ = tPathingData[M28Map.subrefLZNumber]
            local tCurLZData = M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iCurLZ]
            local tCurLZTeamData = tCurLZData[M28Map.subrefLZTeamData][iTeam]
            if tCurLZTeamData[M28Map.refiModDistancePercent] <= iMaxModDistance then
                iOurMobileDFThreat = iOurMobileDFThreat + tCurLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
                iEnemyMobileDFThreat = iEnemyMobileDFThreat + tCurLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]
                iEnemyGroundAAThreat = iEnemyGroundAAThreat + tCurLZTeamData[M28Map.subrefiThreatEnemyGroundAA]
                if (tCurLZTeamData[M28Map.refiModDistancePercent] or 1) <= 0.3 then iEnemyNetMobileDFCloseToBase = iEnemyNetMobileDFCloseToBase + math.max(0, (tCurLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) - (tCurLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0)) end
            else
                if not(bHaveTeammates) or tCurLZTeamData[M28Map.refiModDistancePercent] >= 0.9 or tPathingData[M28Map.subrefLZTravelDist] >= iMaxTravelDist then
                    break
                end
            end
        end
    end
    M28Team.tLandSubteamData[iLandSubteam][M28Team.refiAllyMobileDFThreatNearOurSide] = iOurMobileDFThreat
    if bDebugMessages == true then LOG(sFunctionRef..': iOurMobileDFThreat='..iOurMobileDFThreat..'; M28Team.tLandSubteamData[iLandSubteam][M28Team.refiAllyMobileDFThreatNearOurSide]='..M28Team.tLandSubteamData[iLandSubteam][M28Team.refiAllyMobileDFThreatNearOurSide]) end
    M28Team.tLandSubteamData[iLandSubteam][M28Team.refiEnemyMobileDFThreatNearOurSide] = iEnemyMobileDFThreat
    if bDebugMessages == true then LOG(sFunctionRef..': M28Team.tLandSubteamData[iLandSubteam][M28Team.refiAllyMobileDFThreatNearOurSide] after doing enemy threat='..M28Team.tLandSubteamData[iLandSubteam][M28Team.refiAllyMobileDFThreatNearOurSide]) end
    M28Team.tLandSubteamData[iLandSubteam][M28Team.refiEnemyGroundAAThreatNearOurSide] = iEnemyGroundAAThreat

    --Decide if we want to prioritise production over ecoing temporarily
    local bPrioritiseProduction = false
    if iEnemyNetMobileDFCloseToBase >= 800 and (iEnemyNetMobileDFCloseToBase * 4 >= M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] or M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] < iEnemyGroundAAThreat * 2) then bPrioritiseProduction = true
        bPrioritiseProduction = true
    elseif iOurMobileDFThreat < iEnemyMobileDFThreat and M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] < math.max(iEnemyMobileDFThreat * 0.4, iEnemyGroundAAThreat * 2) then
        --Further restrictions if campaign map or low threat values
        local iEnemyPlayerCount = table.getn(M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains])
        if not(M28Map.bIsCampaignMap) and GetGameTimeSeconds() >= 600 / M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier] and (iEnemyMobileDFThreat > 2000 * iEnemyPlayerCount or iEnemyMobileDFThreat - iOurMobileDFThreat > 1000 + 1000*iEnemyPlayerCount) then
            bPrioritiseProduction = true
            if iEnemyMobileDFThreat <= 8000 + 2000 * iEnemyPlayerCount then
                if iEnemyMobileDFThreat < iOurMobileDFThreat + math.max(iOurMobileDFThreat * 0.25, 1500) then
                    bPrioritiseProduction = false
                end
            end
        end
    end

    local bPreviouslyPrioritising = M28Team.tLandSubteamData[iLandSubteam][M28Team.refbPrioritiseProduction]
    M28Team.tLandSubteamData[iLandSubteam][M28Team.refbPrioritiseProduction] = bPrioritiseProduction
    if bPrioritiseProduction and not(bPreviouslyPrioritising) then
        --Consider unpausing any paused land and air factories if are in a mass stall
        if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] then
            for iBrain, oBrain in M28Team.tLandSubteamData[iLandSubteam][M28Team.subreftoFriendlyM28Brains] do
                local tFactoriesToUnpause = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryAirFactory, false, true)
                if M28Utilities.IsTableEmpty(tFactoriesToUnpause) == false then
                    for iUnit, oUnit in tFactoriesToUnpause do
                        if oUnit[M28UnitInfo.refbPaused] then
                            M28UnitInfo.PauseOrUnpauseMassUsage(oUnit, false, iTeam)
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code for land subteam '..iLandSubteam..' on team '..iTeam..', iOurMobileDFThreat='..iOurMobileDFThreat..'; iEnemyMobileDFThreat='..iEnemyMobileDFThreat..'; ur gunship threat='..M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat]..'; iEnemyGroundAAThreat='..iEnemyGroundAAThreat..'; bPrioritiseProduction='..tostring(bPrioritiseProduction)..'; Gross mass inc on team='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; iEnemyNetMobileDFCloseToBase='..iEnemyNetMobileDFCloseToBase..'; M28Team.tLandSubteamData[iLandSubteam][M28Team.refiAllyMobileDFThreatNearOurSide='..(M28Team.tLandSubteamData[iLandSubteam][M28Team.refiAllyMobileDFThreatNearOurSide] or 'nil')..'; M28Team.tLandSubteamData[iLandSubteam][M28Team.refiEnemyMobileDFThreatNearOurSide]='..M28Team.tLandSubteamData[iLandSubteam][M28Team.refiEnemyMobileDFThreatNearOurSide]..'; Time='..GetGameTimeSeconds()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderAssigningScoutToLurkerLogic(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderAssigningScoutToLurkerLogic'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
    if M28UnitInfo.IsUnitValid(oUnit) then
        local aiBrain = oUnit:GetAIBrain()
        local iTeam = aiBrain.M28Team
        --Only want to use lurker logic early game for now, or occasionally later game
        local iLifetimeCount = M28UnitInfo.GetUnitLifetimeCount(oUnit)
        --First selen - want to have normal attack logic
        if iLifetimeCount > 1 and (iLifetimeCount <= 6 or math.floor(iLifetimeCount / 4) == iLifetimeCount / 4) then
            --Are we in the same land zone as the closest friendly base?
            local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
            if bDebugMessages == true then LOG(sFunctionRef..': iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')) end
            if iPlateauOrZero and iPlateauOrZero > 0 then
                local tLZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                local iIsland = tLZData[M28Map.subrefLZIslandRef]
                if bDebugMessages == true then LOG(sFunctionRef..': iIsland='..(iIsland or 'nil')..'; is M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauIslandLurkerZones][iIsland] nil='..tostring(M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauIslandLurkerZones][iIsland] == nil)) end
                if iIsland then
                    if not(M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauIslandLurkerZones][iIsland]) then
                        --Setup potential lurker zones
                        M28Map.RecordLurkerZonesForIsland(iPlateauOrZero, iIsland, iTeam)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of zones for this island to lurk empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauIslandLurkerZones][iIsland]))) end
                    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauIslandLurkerZones][iIsland]) == false then
                        local iClosestZoneDist = 10000
                        local iClosestZoneRef, iCurDist
                        local iLowestLurkCount = 2 --i.e. wont assign more than 3 selens to the same zone in the course of the game
                        for iEntry, iZone in M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauIslandLurkerZones][iIsland] do
                            local tPotentialZoneData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iZone]
                            local tPotentialZoneTeamData = tPotentialZoneData[M28Map.subrefLZTeamData][iTeam]
                            if tPotentialZoneTeamData and (tPotentialZoneTeamData[M28Map.refiAssignedLurkerCount] or 0) <= iLowestLurkCount then
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(tPotentialZoneData[M28Map.subrefMidpoint], tLZData[M28Map.subrefMidpoint])
                                if iCurDist < iClosestZoneDist then
                                    iClosestZoneDist = iCurDist
                                    iClosestZoneRef = iZone
                                    if (tPotentialZoneTeamData[M28Map.refiAssignedLurkerCount] or 0) < iLowestLurkCount then
                                        iLowestLurkCount = (tPotentialZoneTeamData[M28Map.refiAssignedLurkerCount] or 0)
                                    end
                                end
                            end
                        end
                        if iClosestZoneRef then
                            ForkThread(HaveScoutLurkAtZone, oUnit, iPlateauOrZero, iClosestZoneRef, iTeam)
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function HaveScoutLurkAtZone(oScout, iPlateau, iZone, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'HaveScoutLurkAtZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    oScout[M28UnitInfo.refbLurkerMode] = true
    M28Micro.EnableUnitMicroUntilManuallyTurnOff(oScout, true)
    --oScout[M28UnitInfo.refbSpecialMicroActive] = true
    --oScout[M28UnitInfo.refbLowerPriorityMicroActive] = true
    local tTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iZone]
    local tTargetLZTeamData = tTargetLZData[M28Map.subrefLZTeamData][iTeam]
    tTargetLZTeamData[M28Map.refiAssignedLurkerCount] = (tTargetLZTeamData[M28Map.refiAssignedLurkerCount] or 0) + 1

    --Manage land scout
    local bInCloakMode = false
    local iRadarRange = oScout:GetBlueprint().Intel.RadarRadius or 0
    local tEnemiesToRunFrom
    local tEnemiesToAttack
    local iCurDist, iClosestEnemyDist, oClosestEnemy, bGivenOrder
    local iAttackThresholdDist = oScout[M28UnitInfo.refiCombatRange] + 5
    local iCheckForAirThresholdDist = iAttackThresholdDist + 10 --if enemy to attack further away than this then will consider cloaking instead of attacking
    local iMinAttackDist = oScout[M28UnitInfo.refiCombatRange] - 10
    local aiBrain = oScout:GetAIBrain()
    if bDebugMessages == true then LOG(sFunctionRef..': About to start main lurker loop, oScout='..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..' for P'..iPlateau..'Z'..iZone..' on taem '..iTeam) end

    while M28UnitInfo.IsUnitValid(oScout) do
        --Decide whether want to move towards zone; stay still; run from enemies; or attack engineer
        --Choice is either to attack engineer, stay still, run (from ACU), or abort (because we have enough units in this zone that we should move on)
        if bDebugMessages == true then LOG(sFunctionRef..': Start of cycle for oScout='..(oScout.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oScout) or 'nil')..', target P='..(iPlateau or 'nil')..'Z'..(iZone or 'nil')..', scout team='..(iTeam or 'nil')..'; Target LZSValue='..(tTargetLZTeamData[M28Map.subrefLZSValue] or 'nil')..'; Scout assigned plateau and zone='..repru(oScout[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam])..'; iRadarRange='..(iRadarRange or 'nil')..'; Is table of enemies empty for target LZ='..tostring(M28Utilities.IsTableEmpty(tTargetLZTeamData[M28Map.subrefTEnemyUnits]))..'; tTargetLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..(tTargetLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; tTargetLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]='..(tTargetLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 'nil')..'; bInCloakMode='..tostring(bInCloakMode)..'; oScout fraction complete='..oScout:GetFractionComplete()..'; Time='..GetGameTimeSeconds()) end
        if tTargetLZTeamData[M28Map.subrefLZSValue] >= 250 then --i.e. equiv to 1 t2 mex, also covers having pd or land facs then
            --Want to free up scout for something else
            if bDebugMessages == true then LOG(sFunctionRef..': we have enough buildings in here that we want scout to lurk somewhere else') end
            break
        else
            bGivenOrder = false
            tEnemiesToRunFrom = nil
            tEnemiesToAttack = nil
            local tCurLZData = M28Map.tAllPlateaus[oScout[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1]][M28Map.subrefPlateauLandZones][oScout[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]]
            local tLCurZTeamData = tCurLZData[M28Map.subrefLZTeamData][iTeam]

            --If are in a different zone then check if we want to run from enemies
            if not(oScout[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iZone) or not(oScout[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] == iPlateau) then
                --Only check for enemies in scout intel range
                tEnemiesToRunFrom = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat, oScout:GetPosition(), iRadarRange, 'Enemy')
                if bDebugMessages == true then LOG(sFunctionRef..': Scout isnt in zone yet, is tEnemiesToRunFrom empty from getunitsaroundpoint='..tostring(M28Utilities.IsTableEmpty(tEnemiesToRunFrom))) end
                --Extra check - are there close DF enemies in cur zone?
                if M28Utilities.IsTableEmpty(tEnemiesToRunFrom) then
                    local tPotentiallyNearbyDFEnemies = {}
                    if M28Utilities.IsTableEmpty(tLCurZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                        for iEnemy, oEnemy in tLCurZTeamData[M28Map.reftoNearestDFEnemies] do
                            if not(oEnemy.Dead) and oEnemy:GetFractionComplete() >= 0.9 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Extra check for DF enemies in this zone, oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; Dist to our scout='..M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oScout:GetPosition())..'; DF range='..oEnemy[M28UnitInfo.refiDFRange]) end
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oScout:GetPosition())
                                if iCurDist <= 60 and (iCurDist <= iRadarRange or M28UnitInfo.CanSeeUnit(aiBrain, oEnemy, false) and iCurDist - oEnemy[M28UnitInfo.refiDFRange] <= 8) and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oEnemy.UnitId)) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Adding to table of enemies to run from') end
                                    if not(tEnemiesToRunFrom) then tEnemiesToRunFrom = {} end
                                    table.insert(tEnemiesToRunFrom, oEnemy)
                                elseif iCurDist <= iRadarRange + (oEnemy[M28UnitInfo.refiDFRange] or 0) + 10 then
                                    table.insert(tPotentiallyNearbyDFEnemies, oEnemy)
                                end
                            end
                        end
                    end
                    --If no enemies to run from, is there an enemy to attack?
                    if bDebugMessages == true then LOG(sFunctionRef..': Is tEnemiesToRunFrom empty (after checking zone scout is in)='..tostring(M28Utilities.IsTableEmpty(tEnemiesToRunFrom))..'; Is table of enemy units in zone empyt='..tostring(M28Utilities.IsTableEmpty(tLCurZTeamData[M28Map.subrefTEnemyUnits]))..'; Scout cur assigned zone=P'..oScout[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1]..'Z'..oScout[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]) end
                    if M28Utilities.IsTableEmpty(tEnemiesToRunFrom) and M28Utilities.IsTableEmpty(tLCurZTeamData[M28Map.subrefTEnemyUnits]) == false then
                        local tPotentialEnemiesToAttack = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryRadar, tLCurZTeamData[M28Map.subrefTEnemyUnits])
                        if bDebugMessages == true then LOG(sFunctionRef..': Is tPotentialEnemiesToAttack empty='..tostring(M28Utilities.IsTableEmpty(tPotentialEnemiesToAttack))) end
                        if M28Utilities.IsTableEmpty(tPotentialEnemiesToAttack) == false then
                            local bTargetNearDFEnemies = false
                            for iEnemy, oEnemy in tPotentialEnemiesToAttack do
                                if not(oEnemy.Dead) and oEnemy:GetFractionComplete() >= 0.9 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; Dist to oEnemy='..M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oScout:GetPosition())) end
                                    if M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oScout:GetPosition()) <= iRadarRange then
                                        bTargetNearDFEnemies = false
                                        if M28Utilities.IsTableEmpty(tPotentiallyNearbyDFEnemies) == false then
                                            for iDFEnemy, oDFEnemy in tPotentiallyNearbyDFEnemies do
                                                if bDebugMessages == true then LOG(sFunctionRef..': Dist between potential target enemy to attack and oDFEnemy '..oDFEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oDFEnemy)..'='..M28Utilities.GetDistanceBetweenPositions(oDFEnemy:GetPosition(), oEnemy:GetPosition())..'; Enemy DF range='..oDFEnemy[M28UnitInfo.refiDFRange]) end
                                                if M28Utilities.GetDistanceBetweenPositions(oDFEnemy:GetPosition(), oEnemy:GetPosition()) - oDFEnemy[M28UnitInfo.refiDFRange] <= 6 then
                                                    bTargetNearDFEnemies = true
                                                    break
                                                end
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': bTargetNearDFEnemies='..tostring(bTargetNearDFEnemies)) end
                                        if not(bTargetNearDFEnemies) then
                                            if not(tEnemiesToAttack) then tEnemiesToAttack = {} end
                                            table.insert(tEnemiesToAttack, oEnemy)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Adding to table of enemy units to attack') end
                                        end
                                    end

                                end
                            end
                        end
                    end
                else
                    --Check units are near-constructed
                    for iEnemy = table.getn(tEnemiesToRunFrom), 1, -1 do
                        if tEnemiesToRunFrom[iEnemy]:GetFractionComplete() < 0.7 then --tried with 90% threshold but PD could be built too soon and kill the selens
                            if bDebugMessages == true then LOG(sFunctionRef..': Removing enemy '..tEnemiesToRunFrom[iEnemy].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEnemiesToRunFrom[iEnemy])..' from enemies to run from as it isnt complete yet, fraction complete='..tEnemiesToRunFrom[iEnemy]:GetFractionComplete()) end
                            table.remove(tEnemiesToRunFrom, iEnemy)
                        end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tEnemiesToRunFrom) then
                --Does enemy have ACU in zone? if so then run; otherwise if enemy has combat units then stay hidden
                if M28Utilities.IsTableEmpty(tTargetLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                    tEnemiesToRunFrom = EntityCategoryFilterDown(categories.COMMAND, tTargetLZTeamData[M28Map.reftoNearestDFEnemies])
                    local iDistUntilEnemyACUInRangeOfUs = 10000
                    if M28Conditions.IsTableOfUnitsStillValid(tEnemiesToRunFrom) then
                        for iUnit, oUnit in tEnemiesToRunFrom do
                            iDistUntilEnemyACUInRangeOfUs = math.min(iDistUntilEnemyACUInRangeOfUs, M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oScout:GetPosition()) - oUnit[M28UnitInfo.refiCombatRange])
                        end
                        --Want to run
                        if bDebugMessages == true then LOG(sFunctionRef..': ACU in target zone or near it so want to run if we will be in range of it soon, iDistUntilEnemyACUInRangeOfUs='..iDistUntilEnemyACUInRangeOfUs) end
                    end
                    if iDistUntilEnemyACUInRangeOfUs > 35 then
                        tEnemiesToRunFrom = nil
                        if tTargetLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 100 or tTargetLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] > 10 then
                            --Stay hidden if we are in cloak mode as enemy has combat units; if we arent in cloak mode then run
                            if bInCloakMode and GetGameTimeSeconds() - (oScout[M28UnitInfo.refiLastWeaponEvent] or 0) >= 2 then
                                bGivenOrder = true --i.e. order is to do nothing if in cloak mode
                            else
                                tEnemiesToRunFrom = EntityCategoryFilterDown(categories.DIRECTFIRE + categories.INDIRECTFIRE, tTargetLZTeamData[M28Map.subrefTEnemyUnits])
                                if bInCloakMode and M28Utilities.IsTableEmpty(tEnemiesToRunFrom) == false then bGivenOrder = true end
                            end
                            --Also stay hidden if enemies are in adjacent zone that are near to us
                        elseif bInCloakMode and M28Utilities.IsTableEmpty(tTargetLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                            --Check any nearby enemy DF units not assigned to this zone
                            for iEnemy, oEnemy in tTargetLZTeamData[M28Map.reftoNearestDFEnemies] do
                                if not(oEnemy[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam] == iZone) and M28Utilities.GetDistanceBetweenPositions(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) - (oEnemy[M28UnitInfo.refiDFRange] or 0) <= 5 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to stay cloaked due to nearby enemy in adjacent zone') end
                                    bGivenOrder = true
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy combat total='..tTargetLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Enemy DF range='..tTargetLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]..'; bGivenOrder='..tostring(bGivenOrder)..'; Is tEnemiesToRunFrom empty='..tostring(M28Utilities.IsTableEmpty(tEnemiesToRunFrom))) end
                        if not(bGivenOrder) and not(M28Conditions.IsTableOfUnitsStillValid(tEnemiesToRunFrom)) then
                            tEnemiesToAttack = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryRadar, tTargetLZTeamData[M28Map.subrefTEnemyUnits])
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy engineers and radar empty='..tostring(M28Utilities.IsTableEmpty(tEnemiesToAttack))) end
                            if M28Utilities.IsTableEmpty(tEnemiesToAttack) then
                                --Does the enemy have mexes for us to attack?
                                tEnemiesToAttack = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tTargetLZTeamData[M28Map.subrefTEnemyUnits])
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Is tEnemiesToAttack empty='..tostring(M28Utilities.IsTableEmpty(tEnemiesToAttack))) end
                        end
                    end
                else
                    --Enemy has no units, so do nothing and wait
                    if bInCloakMode then bGivenOrder = true end --i.e. order is to do nothing if are already cloaked
                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy has no units in the target zone') end
                end
            end


            --Process what we have decided to do
            if not(bGivenOrder) then
                if bDebugMessages == true then LOG(sFunctionRef..': Not given order yet so deciding whether to run or attack, is tEnemiesToRunFrom empty='..tostring(M28Utilities.IsTableEmpty(tEnemiesToRunFrom))..'; is tEnemiesToAttack empty='..tostring(M28Utilities.IsTableEmpty(tEnemiesToAttack))..'; refiEnemyAirToGroundThreat='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] ) end
                --Consider if we want to cloak to hide from enemy gunships (but not bombers as we might manage to dodge their bombs)
                local bHideFromAir = false
                if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 0 then
                    function ConsiderIfWantToCloakFromAir(tZoneTeamData, oScout)
                        if bDebugMessages == true then LOG(sFunctionRef..': Do we want to hide from air for cur zone being considered, refiEnemyAirToGroundThreat='..tZoneTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Is table of enemy air units empty='..tostring(M28Utilities.IsTableEmpty(tZoneTeamData[M28Map.reftLZEnemyAirUnits]))) end
                        if tZoneTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 and M28Utilities.IsTableEmpty(tZoneTeamData[M28Map.reftLZEnemyAirUnits]) == false then
                            for iAir, oAir in tZoneTeamData[M28Map.reftLZEnemyAirUnits] do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to cloak due to nearby gunship, oAir='..oAir.UnitId..M28UnitInfo.GetUnitLifetimeCount(oAir)..'; Dist between scout and this='..M28Utilities.GetDistanceBetweenPositions(oAir:GetPosition(), oScout:GetPosition())) end
                                if EntityCategoryContains(M28UnitInfo.refCategoryGunship, oAir.UnitId) and M28Utilities.GetDistanceBetweenPositions(oAir:GetPosition(), oScout:GetPosition()) <= 70 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to hide from air') end
                                    return true
                                end
                            end
                        end
                    end
                    bHideFromAir = ConsiderIfWantToCloakFromAir(tLCurZTeamData, oScout)
                    if not(bHideFromAir) and M28Utilities.IsTableEmpty(tCurLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for _, iAdjLZ in tCurLZData[M28Map.subrefLZAdjacentLandZones] do
                            local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                            local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                            bHideFromAir = ConsiderIfWantToCloakFromAir(tAdjLZTeamData, oScout)
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iAjdLZ='..iAdjLZ..' for if want to run from gunships') end
                            if bHideFromAir then break end
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tEnemiesToRunFrom) == false then
                    if bHideFromAir then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to try hiding from enemy air by cloaking instead of running from nearby land enemies, oScout='..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..'; bInCloakMode='..tostring(bInCloakMode)) end
                        bGivenOrder = true
                        if bInCloakMode then
                            --Do nothing
                        else
                            M28UnitInfo.CloakUnit(oScout)
                            bInCloakMode = true
                        end
                    else
                        --Get the closest and run from here in opposite direction, or towards rally point, unless we are really far away in which case consider just being assigned to a different zone
                        bInCloakMode = false
                        iClosestEnemyDist = 1000
                        oClosestEnemy = nil
                        for iUnit, oUnit in tEnemiesToRunFrom do
                            if M28UnitInfo.IsUnitValid(oUnit) then
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oScout:GetPosition())
                                if iCurDist < iClosestEnemyDist then
                                    oClosestEnemy = oUnit
                                    iClosestEnemyDist = iCurDist
                                end
                            end

                        end
                        if oClosestEnemy then
                            bGivenOrder = true
                            bInCloakMode = false
                            RunFromEnemy(oScout, oClosestEnemy, iTeam, iPlateau, 10)
                            if bDebugMessages == true then LOG(sFunctionRef..': Running from oClosestEnemy='..oClosestEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemy)..'; iClosestEnemyDist='..iClosestEnemyDist..'; tTargetLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tTargetLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; will also abort lurker logic') end
                            if iClosestEnemyDist > 150 or tTargetLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 100 then
                                ForkThread(ConsiderAssigningScoutToLurkerLogic, oScout)
                                break
                            end
                        end
                    end
                elseif M28Utilities.IsTableEmpty(tEnemiesToAttack) == false then
                    iClosestEnemyDist = 100 --Dont want to go further away than this when hunting for targets
                    if bHideFromAir then iClosestEnemyDist = (oScout[M28UnitInfo.refiDFRange] or 19) + 5 end --If we arent already in range or almost in range then we wont manage to damage enemy before gunship kills us
                    oClosestEnemy = nil
                    for iUnit, oUnit in tEnemiesToAttack do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oScout:GetPosition())
                            if iCurDist < iClosestEnemyDist then
                                oClosestEnemy = oUnit
                                iClosestEnemyDist = iCurDist
                            end
                        end

                    end
                    if oClosestEnemy then
                        bInCloakMode = false
                        --Attack
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to attack oClosestEnemy='..oClosestEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemy)..'; iClosestEnemyDist='..iClosestEnemyDist..'; iMinAttackDist='..iMinAttackDist) end
                        if iClosestEnemyDist <= iAttackThresholdDist then
                            if iClosestEnemyDist <= iMinAttackDist and EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oClosestEnemy.UnitId) then
                                --Dont want to be reclaimed by the engineer, so move back slightly
                                local tMovePoint, tPotentialMovePoint
                                local iAngleFromEngi = M28Utilities.GetAngleFromAToB(oClosestEnemy:GetPosition(), oScout:GetPosition())

                                for iAngleAdjust = 0, 90, 45 do
                                    for iFactor = -1, 1, 2 do
                                        tPotentialMovePoint = M28Utilities.MoveInDirection(oScout:GetPosition(), iAngleFromEngi + iAngleAdjust * iFactor, 5, true, false, true)
                                        if M28Utilities.IsTableEmpty(tPotentialMovePoint) == false and NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tPotentialMovePoint) == tTargetLZData[M28Map.subrefLZIslandRef] then
                                            tMovePoint = tPotentialMovePoint
                                            break
                                        end
                                    end
                                end
                                if tMovePoint then
                                    bInCloakMode = false
                                    M28Orders.IssueTrackedMove(oScout, tMovePoint, 3, false, 'LurkMvEg', oScout[M28UnitInfo.refbLowerPriorityMicroActive])
                                    bGivenOrder = true
                                else
                                    --Attack as backup
                                    bInCloakMode = false
                                    M28Orders.IssueTrackedAttack(oScout, oClosestEnemy, false, 'LurkAtEg', oScout[M28UnitInfo.refbLowerPriorityMicroActive])
                                    bGivenOrder = true
                                end
                            else
                                --Attack enemy, unless it is an engineer that we are getting too close to
                                bInCloakMode = false
                                M28Orders.IssueTrackedAttack(oScout, oClosestEnemy, false, 'LurkAtEn', oScout[M28UnitInfo.refbLowerPriorityMicroActive])
                                bGivenOrder = true
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': want to move to enemy to attack them') end
                            --Move to enemy
                            bInCloakMode = false
                            M28Orders.IssueTrackedMove(oScout, oClosestEnemy:GetPosition(), 3, false, 'LurkMvEn', oScout[M28UnitInfo.refbLowerPriorityMicroActive])
                            bGivenOrder = true
                        end
                    elseif bHideFromAir then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to try hiding from enemy air by cloaking instead of attacking nearby land enemies, oScout='..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..'; bInCloakMode='..tostring(bInCloakMode)) end
                        bGivenOrder = true
                        if bInCloakMode then
                            --Do nothing
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Will give order for unit to try and cloak') end
                            M28UnitInfo.CloakUnit(oScout)
                            bInCloakMode = true
                        end
                    end
                    --Consider reassigning if we have multiple selens assigned here
                elseif bHideFromAir then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to try hiding from enemy air by cloaking, oScout='..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..'; bInCloakMode='..tostring(bInCloakMode)) end
                    bGivenOrder = true
                    if bInCloakMode then
                        --Do nothing
                    else
                        M28UnitInfo.CloakUnit(oScout)
                        bInCloakMode = true
                    end
                elseif not(bGivenOrder) and tTargetLZTeamData[M28Map.refiAssignedLurkerCount] >= 3 then
                    if oScout[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iZone and oScout[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] == iPlateau and M28Utilities.IsTableEmpty(tTargetLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                        local iCurAssignedSelens = 1
                        local tScoutsInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryCombatScout, tTargetLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                        if M28Utilities.IsTableEmpty(tScoutsInZone) == false then
                            for iPotentialLurker, oPotentialLurker in tScoutsInZone do
                                if not(oPotentialLurker == oScout) and oPotentialLurker[M28UnitInfo.refbLurkerMode] then
                                    iCurAssignedSelens = iCurAssignedSelens + 1
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have too many selens in a zone, iCurAssignedSelens='..iCurAssignedSelens) end
                        if iCurAssignedSelens >= 3 then
                            --Do we have adjacent land zones with mexes and no enemy combat threat?
                            local bReassign = false
                            for _, iAdjLZ in tTargetLZData[M28Map.subrefLZAdjacentLandZones] do
                                local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                                if (tAdjLZData[M28Map.subrefLZOrWZMexCount] or 0) > 0 then
                                    local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                                    if tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 30 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have adjacent zone iAdjLZ='..iAdjLZ..' with insufficient combat threat and it has a mex, so will send this scout for reassignment') end
                                        bReassign = true
                                        break
                                    end
                                end
                            end
                            if bReassign then break end
                        end
                    end
                end
                if not(bGivenOrder) then
                    if bInCloakMode then
                        bGivenOrder = true
                        if bDebugMessages == true then LOG(sFunctionRef..': No actions, as are in cloak mode will remain in cloak mode') end
                    else
                        --We dont have enemies to run from or attack; do we want to move to target, or cloak?
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oScout:GetPosition(), tTargetLZData[M28Map.subrefMidpoint])
                        if bDebugMessages == true then LOG(sFunctionRef..': Not given an order, so will either move to target if far away, or clock, iCurDist='..iCurDist) end
                        if iCurDist <= 5 then
                            --Want to cloak
                            bInCloakMode = true
                            M28UnitInfo.CloakUnit(oScout)
                            bGivenOrder = true
                        else
                            --Want to move to target
                            bInCloakMode = false
                            M28Orders.IssueTrackedMove(oScout, tTargetLZData[M28Map.subrefMidpoint], 3, false, 'LurkMvMp', oScout[M28UnitInfo.refbLowerPriorityMicroActive])
                            bGivenOrder = true
                        end
                    end
                end
                if not(bGivenOrder) then M28Utilities.ErrorHandler('Missing code for an eventuality so selen has no order, bInCloakMode='..tostring(bInCloakMode), true) end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(iTicksPerLandCycle)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    --for if we aborted due to wanting to assign to a dif zone:
    oScout[M28UnitInfo.refbLurkerMode] = false
    if oScout[M28UnitInfo.refbLowerPriorityMicroActive] then --we might have overridden this with higher priority micro
        oScout[M28UnitInfo.refbSpecialMicroActive] = false
        oScout[M28UnitInfo.refbLowerPriorityMicroActive] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedGetFirstEnhancementOnUnit(oUnit, iDelayInSeconds)
    WaitSeconds(iDelayInSeconds)
    local sFunctionRef = 'DelayedGetFirstEnhancementOnUnit'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28UnitInfo.IsUnitValid(oUnit) then
        local sFirstEnhancement
        local tEnhancements = oUnit:GetBlueprint().Enhancements
        if tEnhancements then
            if bDebugMessages == true then LOG(sFunctionRef..': tEnhancements='..repru(tEnhancements)) end
            for sEnhancement, tEnhancementData in tEnhancements do
                sFirstEnhancement = sEnhancement
                break
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': sFirstEnhancement='..(sFirstEnhancement or 'nil')..'; oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; oUnit[M28UnitInfo.refbSpecialMicroActive]='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive] or false)..'; Time='..GetGameTimeSeconds()) end
        if sFirstEnhancement and not(oUnit:HasEnhancement(sFirstEnhancement)) then
            while oUnit[M28UnitInfo.refbSpecialMicroActive] and M28UnitInfo.IsUnitValid(oUnit) do
                WaitSeconds(1)
            end
            if M28UnitInfo.IsUnitValid(oUnit) then
                local iTeam = oUnit:GetAIBrain().M28Team
                local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                if bDebugMessages == true then LOG(sFunctionRef..': Is tLZTeamData nil='..tostring(tLZTeamData == nil)..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] or false)..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..(tLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 'nil')) end
                if tLZTeamData and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and tLZTeamData[M28Map.refiEnemyAirToGroundThreat] == 0 and (not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange])) then
                    M28Orders.IssueTrackedEnhancement(oUnit, sFirstEnhancement, false, 'GetUEnh')
                    --Flag as micro active so we dont abort
                    M28Micro.EnableUnitMicroUntilManuallyTurnOff(oUnit)
                    --oUnit[M28UnitInfo.refbSpecialMicroActive] = true
                    if oUnit[M28UnitInfo.refbLowerPriorityMicroActive] then oUnit[M28UnitInfo.refbLowerPriorityMicroActive] = nil end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished trying to get enhancement for the unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at time='..GetGameTimeSeconds()..'; oUnit[M28UnitInfo.refbSpecialMicroActive]='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive] or false)) end
                end
            end
        end
    end
end

function SendSACUsToWaterZone(tSACUs, tLZOrWZTeamData)
    local iWaterZone
    local tOrigRecordedSACUs = tLZOrWZTeamData[M28Map.subreftoSACUsTravelingToWaterZoneFromHere]
    local bRecorded
    for iSACU, oSACU in tSACUs do
        iWaterZone = oSACU[M28UnitInfo.refiSACUWaterZoneTarget]
        local tWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone]
        if tWZData[M28Map.subrefMidpoint] then
            M28Orders.IssueTrackedMove(oSACU, tWZData[M28Map.subrefMidpoint], 5, false, 'MvWZ'..iWaterZone, false)
            bRecorded = false
            if tOrigRecordedSACUs then
                for iRecorded, oRecorded in tOrigRecordedSACUs do
                    if oRecorded == oSACU then
                        bRecorded = true
                        break
                    end
                end
            end
            if not(bRecorded) then
                if not(tLZOrWZTeamData[M28Map.subreftoSACUsTravelingToWaterZoneFromHere]) then tLZOrWZTeamData[M28Map.subreftoSACUsTravelingToWaterZoneFromHere] = {} end
                table.insert(tLZOrWZTeamData[M28Map.subreftoSACUsTravelingToWaterZoneFromHere], oSACU)
            end
        else
            M28Utilities.ErrorHandler('SACU doesnt have valid WZ target so clearing')
            oSACU[M28UnitInfo.refiSACUWaterZoneTarget] = nil
        end
    end
end

function GetMexesInThisOrAdjacentLandZone(tLZData, tLZTeamData, iTeam, iPlateau, bRequireVisibilityOfMex)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetMexesInThisOrAdjacentLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local toAdjacentEnemyMexes
    local aiBrainForVisibilityCheck
    if bRequireVisibilityOfMex then aiBrainForVisibilityCheck = ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]] end
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
            local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
            if bDebugMessages == true then LOG(sFunctionRef..': Checking if enemy has mexes in adjacent LZ, iAdjLZ='..iAdjLZ..'; tAdjLZData[M28Map.subrefLZOrWZMexCount]='..(tAdjLZData[M28Map.subrefLZOrWZMexCount] or 'nil')..'; Is tAdjLZData[M28Map.subrefMexUnbuiltLocations] empty='..tostring(M28Utilities.IsTableEmpty(tAdjLZData[M28Map.subrefMexUnbuiltLocations]))) end
            if (tAdjLZData[M28Map.subrefLZOrWZMexCount] or 0) > 0 then
                if bDebugMessages == true and M28Utilities.IsTableEmpty(tAdjLZData[M28Map.subrefMexUnbuiltLocations]) == false then LOG(sFunctionRef..': Size of table of unbuilt locations='..table.getn(tAdjLZData[M28Map.subrefMexUnbuiltLocations])) end
                if M28Utilities.IsTableEmpty(tAdjLZData[M28Map.subrefMexUnbuiltLocations]) or table.getn(tAdjLZData[M28Map.subrefMexUnbuiltLocations]) < tAdjLZData[M28Map.subrefLZOrWZMexCount] then
                    local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': subrefThreatEnemyStructureTotalMass='..(tAdjLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 'nil')..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]))) end
                    if tAdjLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] > 0 and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then

                        local tEnemyMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tAdjLZTeamData[M28Map.subrefTEnemyUnits])
                        if bDebugMessages == true then LOG(sFunctionRef..': Is tEnemyMexes empty='..tostring(M28Utilities.IsTableEmpty(tEnemyMexes))) end
                        if M28Utilities.IsTableEmpty(tEnemyMexes) == false then
                            for iMex, oMex in tEnemyMexes do
                                if M28UnitInfo.IsUnitValid(oMex) and (not(bRequireVisibilityOfMex) or M28UnitInfo.CanSeeUnit(aiBrainForVisibilityCheck, oMex)) then
                                    if not(toAdjacentEnemyMexes) then toAdjacentEnemyMexes = {} end
                                    table.insert(toAdjacentEnemyMexes, oMex)
                                    if bDebugMessages == true then LOG(sFunctionRef..': recording enemy oMex='..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)) end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    if tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] > 0 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefMexUnbuiltLocations]) or table.getn(tLZData[M28Map.subrefMexUnbuiltLocations]) < tLZData[M28Map.subrefLZOrWZMexCount] then
        local tEnemyMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tLZTeamData[M28Map.subrefTEnemyUnits])
        if M28Utilities.IsTableEmpty(tEnemyMexes) == false then
            for iMex, oMex in tEnemyMexes do
                if M28UnitInfo.IsUnitValid(oMex) then
                    if not(toAdjacentEnemyMexes) then toAdjacentEnemyMexes = {} end
                    table.insert(toAdjacentEnemyMexes, oMex)
                    if bDebugMessages == true then LOG(sFunctionRef..': recording enemy oMex='..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)) end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return toAdjacentEnemyMexes
end

function RecordAttackingExperimental(tLZTeamData, oExperimental)
    local bNotRecorded = true
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoAttackingFriendlyExperimentals]) == false then
        for iExistingExp, oExistingExp in tLZTeamData[M28Map.reftoAttackingFriendlyExperimentals] do
            if oExistingExp == oExperimental then
                bNotRecorded = false
                break
            end
        end
    end
    if bNotRecorded then
        if not(tLZTeamData[M28Map.reftoAttackingFriendlyExperimentals]) then tLZTeamData[M28Map.reftoAttackingFriendlyExperimentals] = {} end
        table.insert(tLZTeamData[M28Map.reftoAttackingFriendlyExperimentals], oExperimental)
    end
    oExperimental[M28UnitInfo.refiAttackingExperimentalTime] = GetGameTimeSeconds()
end

function HaveAttackingExperimentalToSupport(tLZTeamData)
    if M28Conditions.IsTableOfUnitsStillValid(tLZTeamData[M28Map.reftoAttackingFriendlyExperimentals]) and M28Utilities.IsTableEmpty( tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
        for iExp, oExp in tLZTeamData[M28Map.reftoAttackingFriendlyExperimentals] do
            if oExp[M28UnitInfo.refiAttackingExperimentalTime] and GetGameTimeSeconds() - oExp[M28UnitInfo.refiAttackingExperimentalTime] <= 30 and (oExp[M28UnitInfo.refbSpecialMicroActive] or GetGameTimeSeconds() - oExp[M28UnitInfo.refiAttackingExperimentalTime] <= 10) then
                --Is this experimental close to a DF enemy?
                local iDistanceThreshold = math.max(30, math.min((oExp[M28UnitInfo.refiDFRange] or 0) + 5, 50))
                for iEnemy, oEnemy in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                    if M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oExp:GetPosition()) <= iDistanceThreshold then return true end
                end
            end
        end
    end
end

function ConsiderAssigningRaider(oFactory, oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderAssigningRaider'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true and not(oUnit.Dead) then LOG(sFunctionRef..': Start of code, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' built by oFactory='..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..' and owned by '..oUnit:GetAIBrain().Nickname..'; considering whether will be a raider, combatrange='..( oUnit[M28UnitInfo.refiCombatRange] or 'nil')..'; oFactory[M28Factory.refiTotalBuildCount]='..(oFactory[M28Factory.refiTotalBuildCount] or 'nil')..'; Time='..GetGameTimeSeconds()) end
    if oUnit[M28UnitInfo.refiCombatRange] > 28 and (oFactory[M28Factory.refiTotalBuildCount] or 0) >= 4 and M28UnitInfo.IsUnitValid(oUnit) and M28UnitInfo.IsUnitValid(oFactory) and M28UnitInfo.GetUnitLifetimeCount(oUnit)  >= 3 and GetGameTimeSeconds() >= 300 then
        local iTeam = oFactory:GetAIBrain().M28Team
        local iBuildPlateau = oFactory[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1]
        if bDebugMessages == true then LOG(sFunctionRef..' iBuildPlateau='..(iBuildPlateau or 'nil')..'; iBuildZone='..(oFactory[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] or 'nil')) end
        if iBuildPlateau and iBuildPlateau > 0 then
            local iBuildZone = oFactory[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]
            if iBuildZone and iBuildZone > 0 then
                local tBuildLZData = M28Map.tAllPlateaus[iBuildPlateau][M28Map.subrefPlateauLandZones][iBuildZone]
                local tBuildLZTeamData = tBuildLZData[M28Map.subrefLZTeamData][iTeam]

                if not(tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiCurRaidingZoneTarget]) then
                    GetRaidingZoneTarget(iBuildPlateau, iBuildZone, iTeam, oUnit[M28UnitInfo.refiCombatRange] - 3)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': subrefiCurRaidingZoneTarget='..(tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiCurRaidingZoneTarget] or 'nil')) end
                if tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiCurRaidingZoneTarget] then
                    tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiPotentialRaiderUnitsSinceLastCreatedRaiderAssigned] = (tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiPotentialRaiderUnitsSinceLastCreatedRaiderAssigned] or 0) + 1
                    --Dont raid if nearby firebase/t2 arti
                    if (tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiActiveRaidersCreatedByThisZone] or 0) < 4 and (tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiPotentialRaiderUnitsSinceLastCreatedRaiderAssigned] >= 4 or not(tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiTimeSinceLastConstructedRaiderAssignment])) and GetGameTimeSeconds() - (tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiTimeSinceLastConstructedRaiderAssignment] or 0) >= 30 and M28Utilities.IsTableEmpty(tBuildLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) and M28Utilities.IsTableEmpty(tBuildLZTeamData[M28Map.subreftEnemyFirebasesInRange]) then
                        GetRaidingZoneTarget(iBuildPlateau, iBuildZone, iTeam, oUnit[M28UnitInfo.refiCombatRange] - 3) --Will reassess if been a while since we last considered best zone to raid
                        local iTargetZone = tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiCurRaidingZoneTarget]
                        if iTargetZone then
                            local tTargetLZTeamData = M28Map.tAllPlateaus[iBuildPlateau][M28Map.subrefPlateauLandZones][iTargetZone][M28Map.subrefLZTeamData][iTeam]
                            if bDebugMessages == true then LOG(sFunctionRef..': iTargetZone='..(iTargetZone or 'nil')..'; subrefiActiveRaidersTargetingThisZone='..((tTargetLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiActiveRaidersTargetingThisZone] or 'nil'))) end
                            if (tTargetLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiActiveRaidersTargetingThisZone] or 0) < 2 then
                                --Check we dont want t1 arti for a transport
                                local bWantT1ArtiForTransport = false
                                if M28Utilities.IsTableEmpty(tBuildLZTeamData[M28Map.reftoTransportsWaitingForUnits]) == false then
                                    for iTransport, oTransport in tBuildLZTeamData[M28Map.reftoTransportsWaitingForUnits] do
                                        if (oTransport[M28Air.refiEngisWanted] or 0) > 0 or not(oTransport[M28Air.refbCombatDrop]) then
                                            --Transport waiting for engis
                                        elseif (oTransport[M28Air.refiCombatUnitsWanted] or 0) > 0 then
                                            bWantT1ArtiForTransport = true
                                            break
                                        end
                                    end
                                end
                                if not(bWantT1ArtiForTransport) then
                                    AssignUnitAsRaiderForTargetZone(oUnit, iTargetZone, iBuildPlateau, iBuildZone)
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AssignUnitAsRaiderForTargetZone(oUnit, iTargetZone, iOptionalBuildPlateau, iOptionalBuildZone)
    --If iOptionalBuildPlateau and iOptionalBuildZone arent specified then unit should already have them recorded (otherwise have an error/issue)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignUnitAsRaiderForTargetZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Starto f code, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..'; iTargetZone='..iTargetZone..'; iOptionalBuildPlateau='..(iOptionalBuildPlateau or 'nil')..'; iOptionalBuildZone='..(iOptionalBuildZone or 'nil')..'; oUnit[refiRaidingBasePlateau]='..(oUnit[refiRaidingBasePlateau] or 'nil')..'; refiRaidingTargetZone='..(oUnit[refiRaidingTargetZone] or 'nil')) end
    local iTeam = oUnit:GetAIBrain().M28Team
    local bFirstTimeAssigning = true
    if oUnit[refiRaidingBasePlateau] or oUnit[refiRaidingTargetZone] then bFirstTimeAssigning = false end

    if iOptionalBuildPlateau then oUnit[refiRaidingBasePlateau] = iOptionalBuildPlateau end
    if iOptionalBuildZone then oUnit[refiRaidingBaseZone] = iOptionalBuildZone end
    local tBuildLZData = M28Map.tAllPlateaus[oUnit[refiRaidingBasePlateau]][M28Map.subrefPlateauLandZones][oUnit[refiRaidingBaseZone]]
    local tBuildLZTeamData = tBuildLZData[M28Map.subrefLZTeamData][iTeam]
    if oUnit.Dead then ClearUnitRaiderStatus(oUnit, iTeam) --redundancy
    elseif tBuildLZTeamData then
        if not(bFirstTimeAssigning) then ClearUnitRaiderStatus(oUnit, iTeam, true) end
        oUnit[refiRaidingTargetZone] = iTargetZone
        oUnit[refbFlaggedForPriorityScout] = true
        local tTargetLZTeamData = M28Map.tAllPlateaus[oUnit[refiRaidingBasePlateau]][M28Map.subrefPlateauLandZones][iTargetZone][M28Map.subrefLZTeamData][iTeam]

        if tTargetLZTeamData then
            if not(tTargetLZTeamData[M28Map.reftRaiderSubtable]) then
                tTargetLZTeamData[M28Map.reftRaiderSubtable] = {}
            end
            tTargetLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiActiveRaidersTargetingThisZone] = (tTargetLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiActiveRaidersTargetingThisZone] or 0) + 1
            tTargetLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiLifetimeRaidersTargetingThisZone] = (tTargetLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiLifetimeRaidersTargetingThisZone] or 0) + 1
        else
            M28Utilities.ErrorHandler('Trying to assign raider to invalid zone, P'..(oUnit[refiRaidingBasePlateau] or 'nil')..'Z'..(iTargetZone or 'nil'))
        end
        if bFirstTimeAssigning then
            if not(tBuildLZTeamData[M28Map.reftRaiderSubtable]) then
                M28Utilities.ErrorHandler('Base raider zone lacks a subtable')
                if tBuildLZTeamData then tBuildLZTeamData[M28Map.reftRaiderSubtable] = {} end
            end
            tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiActiveRaidersCreatedByThisZone] = (tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiActiveRaidersCreatedByThisZone] or 0) + 1
            tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiTimeSinceLastConstructedRaiderAssignment] = GetGameTimeSeconds()
            tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiPotentialRaiderUnitsSinceLastCreatedRaiderAssigned] = 0
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetRaidingZoneTarget(iStartPlateau, iStartZone, iTeam, iRangeThreshold, iOptionalZoneToIgnore)
    --Updates subrefiCurRaidingZoneTarget to the zone to target (or nil if we didnt find any suitable ones)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetRaidingZoneTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tBuildLZData = M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iStartZone]
    local tBuildLZTeamData = tBuildLZData[M28Map.subrefLZTeamData][iTeam]
    if bDebugMessages == true then LOG(sFunctionRef..': iStartPlateau='..(iStartPlateau or 'nil')..'; iStartZone='..(iStartZone or 'nil')..'; iTeam='..iTeam..'; iRangeThreshold='..iRangeThreshold..'; iOptionalZoneToIgnore='..(iOptionalZoneToIgnore or 'nil')..'; is tBuildLZTeamData nil='..tostring(tBuildLZTeamData == nil)) end
    if not(tBuildLZTeamData[M28Map.reftRaiderSubtable]) then
        if tBuildLZTeamData then
            tBuildLZTeamData[M28Map.reftRaiderSubtable] = {}
        else
            M28Utilities.ErrorHandler('Invalid plateau or zone reference, P'..(iStartPlateau or 'nil')..'Z'..(iStartZone or 'nil'))
        end
    end
    if tBuildLZTeamData and (tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiCurRaidingZoneTarget] or GetGameTimeSeconds() - (tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiTimeLastCheckedForZoneToTarget] or 0) >= 30) then
        tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiTimeLastCheckedForZoneToTarget] = math.floor(GetGameTimeSeconds())

        --Decide what zone to target
        local iFirstZoneNoRaiderLimit
        local iLifetimeAssignmentForFirstZone
        local iFirstZoneWithRaiderLimit
        local iFirstLRThreatZoneDist --the first zone we find that is unsuitable due to enemy having t2 arti/longer ranged DF units should be recorded here
        local iFirstZoneRaiderAndAngleLimit
        local iAngleThreshold = 60
        local iAngleToNearestBase = M28Utilities.GetAngleFromAToB(tBuildLZData[M28Map.subrefMidpoint], tBuildLZTeamData[M28Map.reftClosestFriendlyBase])
        local iCurAngle
        function ConsiderTargetingZone(iCurZone, iOptionalDist)
            if not(iCurZone == iOptionalZoneToIgnore) then
                local tAdjLZTeamData = M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iCurZone][M28Map.subrefLZTeamData][iTeam]
                if (tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] >= iRangeThreshold or tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] >= iRangeThreshold or M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false or tAdjLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] > 0)
                        --Also look for enemies that have caused us to run that havent moved much
                        or (M28UnitInfo.IsUnitValid(tAdjLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefoLastEnemyDFLastRunFromWhenTryingToReachThisZone]) and tAdjLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefoLastEnemyDFLastRunFromWhenTryingToReachThisZone][M28UnitInfo.refiDFRange] >= iRangeThreshold and M28Utilities.GetDistanceBetweenPositions(tAdjLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefoLastEnemyDFLastRunFromWhenTryingToReachThisZone]:GetPosition(), tAdjLZTeamData[M28Map.reftRaiderSubtable][M28Map.subreftLastEnemyDFLastRunFromWhenTryingToReachThisZonePosition]) <= 80) then
                    if not(iFirstLRThreatZoneDist) then iFirstLRThreatZoneDist = iOptionalDist or M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iCurZone][M28Map.subrefMidpoint], tBuildLZData[M28Map.subrefMidpoint]) end
                else
                    if (tAdjLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) > 0 then
                        --We want to raid unless this zone already has raiders assigned or has mobile DF units already there that can attack
                        if not(iFirstZoneNoRaiderLimit) then
                            iFirstZoneNoRaiderLimit = iCurZone
                            iLifetimeAssignmentForFirstZone = (tAdjLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiLifetimeRaidersTargetingThisZone] or 0)
                        end
                        if (tAdjLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiActiveRaidersTargetingThisZone] or 0) < 2 and tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] == 0 and (iLifetimeAssignmentForFirstZone < 2 or (tAdjLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiLifetimeRaidersTargetingThisZone] or 0) < iLifetimeAssignmentForFirstZone) then
                            if not(iFirstZoneWithRaiderLimit) then
                                iFirstZoneWithRaiderLimit = iCurZone
                            end
                            --Prefer targets far from angle to enemy base since more likely will raid targets less likely to be under attack from our normal land combat logic
                            iCurAngle = M28Utilities.GetAngleFromAToB(tBuildLZData[M28Map.subrefMidpoint], M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iCurZone][M28Map.subrefMidpoint])
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iCurZone='..iCurZone..'; iCurAngle='..iCurAngle..'; iAngleToNearestBase='..iAngleToNearestBase..'; ANgleDif='..M28Utilities.GetAngleDifference(iCurAngle, iAngleToNearestBase)..'; iOptionalDist='..(iOptionalDist or 'nil')..'; StraightlineDist='..M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iCurZone][M28Map.subrefMidpoint], tBuildLZData[M28Map.subrefMidpoint])) end
                            if M28Utilities.GetAngleDifference(iCurAngle, iAngleToNearestBase) > iAngleThreshold then
                                iFirstZoneRaiderAndAngleLimit = iCurZone
                            end
                        end
                    end
                end

                if not(tBuildLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iCurZone]) then
                    M28Map.ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iStartPlateau, iStartZone, iCurZone, tBuildLZData[M28Map.subrefMidpoint])
                end
            end
        end
        if M28Utilities.IsTableEmpty(tBuildLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
            local iAdjLZ
            for iPathingRef, tPathingDetails in tBuildLZData[M28Map.subrefLZPathingToOtherLandZones] do
                if iFirstLRThreatZoneDist and tPathingDetails[M28Map.subrefLZTravelDist] - 200 > iFirstLRThreatZoneDist then break end
                iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                ConsiderTargetingZone(iAdjLZ, tPathingDetails[M28Map.subrefLZTravelDist])
                if iFirstZoneRaiderAndAngleLimit then break end
            end
        else
            --Just look at adjacent zones (no need for distance check)
            if M28Utilities.IsTableEmpty(tBuildLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                for _, iAdjLZ in tBuildLZData[M28Map.subrefLZAdjacentLandZones] do
                    ConsiderTargetingZone(iAdjLZ)
                    if iFirstZoneRaiderAndAngleLimit then break end
                end
            end
        end
        tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiCurRaidingZoneTarget] = (iFirstZoneRaiderAndAngleLimit or iFirstZoneWithRaiderLimit or iFirstZoneNoRaiderLimit)
        if bDebugMessages == true then LOG(sFunctionRef..': Updated subrefiCurRaidingZoneTarget, iFirstZoneRaiderAndAngleLimit='..(iFirstZoneRaiderAndAngleLimit or 'nil')..'; iFirstZoneWithRaiderLimit='..(iFirstZoneWithRaiderLimit or 'nil')..'; iFirstZoneNoRaiderLimit='..(iFirstZoneNoRaiderLimit or 'nil')..'; tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiCurRaidingZoneTarget]='..(tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiCurRaidingZoneTarget] or 'nil')) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageRaidersInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tRaiders)
    local tEnemiesToConsiderRunningFrom = {}
    local tbUnitByEntityID = {}
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
        for iEnemy, oEnemy in tLZTeamData[M28Map.reftoNearestDFEnemies] do
            table.insert(tEnemiesToConsiderRunningFrom, oEnemy)
            tbUnitByEntityID[oEnemy.EntityId] = true
        end
    end
    --Consider adjacent zone DF enemies
    if GetGameTimeSeconds() - (tLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiTimeLastDoneDetailedEnemyCheck] or 0) >= 10.4 then
        if not(tLZTeamData[M28Map.reftRaiderSubtable]) then
            tLZTeamData[M28Map.reftRaiderSubtable] = {}
        end
        tLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiTimeLastDoneDetailedEnemyCheck] = math.floor(GetGameTimeSeconds())
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                    for iEnemy, oEnemy in tAdjLZTeamData[M28Map.reftoNearestDFEnemies] do
                        if not(tbUnitByEntityID[oEnemy.EntityId]) then
                            table.insert(tEnemiesToConsiderRunningFrom, oEnemy)
                            tbUnitByEntityID[oEnemy.EntityId] = true
                        end
                    end
                end
            end
        end
    end
    --Add in closest enemy to run from recorded for each raider in the zone
    for iRaider, oRaider in tRaiders do
        if M28UnitInfo.IsUnitValid(oRaider[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and (oRaider[M28UnitInfo.refiDFRange] or 0) > 0 then
            if not(tbUnitByEntityID[oRaider[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].EntityId]) then
                table.insert(tEnemiesToConsiderRunningFrom, oRaider[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])
                tbUnitByEntityID[oRaider[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].EntityId] = true
            end
        end
    end

    local bAllRaidersMovingOn = M28Utilities.IsTableEmpty(tEnemiesToConsiderRunningFrom)

    local bRaiderMovingOn, iCurDist, iClosestDist, oClosestImmobile, bRunning, tRallyPoint
    for iRaider, oRaider in tRaiders do
        if not(bAllRaidersMovingOn) and M28Conditions.CloseToEnemyUnit(oRaider:GetPosition(), tEnemiesToConsiderRunningFrom, math.max(5, (oRaider[M28UnitInfo.refiCombatRange]-25) * 0.3), iTeam, true, 3, oRaider, oRaider, oRaider[M28UnitInfo.refiCombatRange] - 4, false) then
            --Run from enemy if it has an attack, or just do manual attack order (or attack ground if unit not visible but is immovable and isnt TMD)
            if (oRaider[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiCombatRange] or 0) > 0 or EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oRaider[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId) then
                RunFromEnemy(oRaider, oRaider[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], iTeam, iPlateau, 10)
                --If enemy outranges us then dont want to raid any more
                if (oRaider[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 0) >= oRaider[M28UnitInfo.refiCombatRange] then
                    ClearUnitRaiderStatus(oRaider, iTeam, true, oRaider[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])
                end
            else
                if M28UnitInfo.CanSeeUnit(oRaider:GetAIBrain(), oRaider[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], false) or EntityCategoryContains(M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryTMD, oRaider[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId) then
                    M28Orders.IssueTrackedAttack(oRaider, oRaider[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], false, 'RaidAt')
                else
                    M28Orders.IssueTrackedAttackMove(oRaider, oRaider[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), 3, false, 'RaidAM')
                end
            end
        else
            --Is there a unit in this zone we want to attack?
            bRaiderMovingOn = true
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                iClosestDist = 10000
                oClosestImmobile = nil
                for iEnemy, oEnemy in tLZTeamData[M28Map.subrefTEnemyUnits] do
                    --Check building or immobile unit (but ignore selens that might be cloaked)
                    if (EntityCategoryContains(M28UnitInfo.refCategoryStructure, oEnemy.UnitId) or M28UnitInfo.GetUnitSpeed(oEnemy) <= 0.1) and (oEnemy[M28UnitInfo.refiDFRange] or 0) < oRaider[M28UnitInfo.refiCombatRange] and (not(oEnemy.UnitId == 'xsl0101') or M28UnitInfo.CanSeeUnit(oRaider:GetAIBrain(), oEnemy)) then
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oRaider:GetPosition(), oEnemy:GetPosition())
                        if iCurDist < iClosestDist then
                            iClosestDist = iCurDist
                            oClosestImmobile = oEnemy
                        end
                    end
                end
                if oClosestImmobile then
                    bRaiderMovingOn = false
                    bRunning = false
                    --Woudl we get near the closest enemy to run from if we target this unit?
                    if (oRaider[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 0) >= oRaider[M28UnitInfo.refiCombatRange] and M28UnitInfo.IsUnitValid(oRaider[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                        local iAngleToNearestThreat = M28Utilities.GetAngleFromAToB(oRaider:GetPosition(), oRaider[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())
                        local iAngleToImmobileTarget = M28Utilities.GetAngleFromAToB(oRaider:GetPosition(), oClosestImmobile:GetPosition())
                        if M28Utilities.GetAngleDifference(iAngleToNearestThreat, iAngleToImmobileTarget) <= 50 and iClosestDist - oRaider[M28UnitInfo.refiCombatRange] <= math.max(0, M28Utilities.GetDistanceBetweenPositions(oRaider:GetPosition(), oRaider[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()) - (oRaider[M28UnitInfo.refiDFRange] or 0)) then
                            if oRaider[refiRaidingTargetZone] == iLandZone then
                                bRunning = true
                                if not(tRallyPoint) then tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 1, false) end
                                M28Orders.IssueTrackedAttackMove(oRaider, tRallyPoint, 3, false, 'RaidRetRal', false)
                            else
                                bRaiderMovingOn = true
                            end
                        end
                    end
                    if not(bRaiderMovingOn) then
                        if M28UnitInfo.CanSeeUnit(oRaider:GetAIBrain(), oClosestImmobile, false) or EntityCategoryContains(M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryTMD, oClosestImmobile.UnitId) then
                            M28Orders.IssueTrackedAttack(oRaider, oClosestImmobile, false, 'RaidImAt')
                        else
                            M28Orders.IssueTrackedAttackMove(oRaider, oClosestImmobile:GetPosition(), 3, false, 'RaidIMAM')
                        end
                    end
                end
            end
            if bRaiderMovingOn then
                --Move to target zone unless we are already there
                if oRaider[refiRaidingTargetZone] == iLandZone then
                    --Reassess where to raid
                    GetRaidingZoneTarget(iPlateau, iLandZone, iTeam, oRaider[M28UnitInfo.refiCombatRange] - 3)
                    if (tLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiCurRaidingZoneTarget] or 0) > 0 then
                        --AssignUnitAsRaiderForTargetZone(oUnit, iTargetZone, iOptionalBuildPlateau, iOptionalBuildZone, bFirstTimeAssigning)
                        AssignUnitAsRaiderForTargetZone(oRaider, tLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiCurRaidingZoneTarget])
                    else
                        ClearUnitRaiderStatus(oRaider, iTeam)
                    end
                else
                    local tTargetZoneLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][oRaider[refiRaidingTargetZone]]
                    M28Orders.IssueTrackedAttackMove(oRaider, tTargetZoneLZData[M28Map.subrefMidpoint], 3, false, 'RaidMvLZ'..oRaider[refiRaidingTargetZone], false)
                end
            end
        end
    end
end

function ClearUnitRaiderStatus(oUnit, iTeam, bOnlyRemoveFromCurTargetZone, oOptionalEnemyCausingUsToRun)
    --set bOnlyRemoveFromCurTargetZone to true if raider is being reassigned (false if unit has died/is permantnly being removed as a raider)
    local iOldTargetZone = oUnit[refiRaidingTargetZone]
    local tOldTargetLZTeamData = M28Map.tAllPlateaus[oUnit[refiRaidingBasePlateau]][M28Map.subrefPlateauLandZones][iOldTargetZone][M28Map.subrefLZTeamData][iTeam]
    if tOldTargetLZTeamData then
        if oOptionalEnemyCausingUsToRun then
            --Dont want to send further raiders here unless they have a better range
            tOldTargetLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiEnemyDFRangeLastRunFromWhenTryingToReachThisZone] = oOptionalEnemyCausingUsToRun[M28UnitInfo.refiDFRange]
            tOldTargetLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefoLastEnemyDFLastRunFromWhenTryingToReachThisZone] = oOptionalEnemyCausingUsToRun
            tOldTargetLZTeamData[M28Map.reftRaiderSubtable][M28Map.subreftLastEnemyDFLastRunFromWhenTryingToReachThisZonePosition] = {oOptionalEnemyCausingUsToRun:GetPosition()[1], oOptionalEnemyCausingUsToRun:GetPosition()[2], oOptionalEnemyCausingUsToRun:GetPosition()[3]}
        end
        --Remove existing tracking
        tOldTargetLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiActiveRaidersTargetingThisZone] = (tOldTargetLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiActiveRaidersTargetingThisZone] or 0) - 1
        tOldTargetLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiLifetimeRaidersTargetingThisZone] = (tOldTargetLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiLifetimeRaidersTargetingThisZone] or 0) - 1
    end
    local tBuildLZData = M28Map.tAllPlateaus[oUnit[refiRaidingBasePlateau]][M28Map.subrefPlateauLandZones][oUnit[refiRaidingBaseZone]]
    local tBuildLZTeamData = tBuildLZData[M28Map.subrefLZTeamData][iTeam]
    if tBuildLZTeamData then
        if bOnlyRemoveFromCurTargetZone then
            --Reassess what zone the original should target for raids if it is this
            if tOldTargetLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiCurRaidingZoneTarget] == iOldTargetZone then GetRaidingZoneTarget(oUnit[refiRaidingBasePlateau], oUnit[refiRaidingBaseZone], iTeam, oUnit[M28UnitInfo.refiCombatRange] - 3, iOldTargetZone) end
        else
            --Remove from base zone
            tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiActiveRaidersCreatedByThisZone] = math.max(0, (tBuildLZTeamData[M28Map.reftRaiderSubtable][M28Map.subrefiActiveRaidersCreatedByThisZone] or 0) - 1)
        end
    end
    if not(bOnlyRemoveFromCurTargetZone) then oUnit[refbFlaggedForPriorityScout] = nil end
end