---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 09/12/2022 07:49
---
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')

--Global
tLZRefreshCountByTeam = {}
--Land zone subteam data - see M28Map for main variables; threat specific values are included here

--Varaibles against specific units
reftiPlateauAndLZToMoveTo = 'M28LandPlatAndLZToMoveTo' --If tell a unit to mvoe to a LZ then will update this with the plateau and land zone wanted
refiCurrentAssignmentValue = 'M28LandAssignedValue' --when a combat unit is given an order for a land zone, the value of that land zone should be recorded
refiCurrentAssignmentPlateauAndLZ = 'M28LandAssignedPlatLZ' --returns {iPlateau, iLandZone} that the units orders have been coordinated by
refiTimeOfLastAssignment = 'M28LandLastAssignmenttime' --returns gametimeseconds that the unit was last assigned to the available units of a land zone
reftiRadarPlateauAndLandZonesCoveredByTeam = 'M28LandRadarLZs' --Returns talbes of {iPlateau, iLandZone} that the radar is providing the best radar coverage of
reftiRadarPlateauAndLandZonesCoveredByOmni = 'M28LandOmniLZs' --Returns talbes of {iPlateau, iLandZone} that the radar is providing some omni coverage of
refoSREnemyTarget = 'M28LndSRTrg' --If we have a SR unit told to target an enemy, this tracks it so we dont switch to retreat logic when we move into a new zone in pursuit
refiTimeOfSREnemyTarget = 'M28LndSRTTim' --Gametimeseconds
reftoUnitsToKillOnCompletion = 'M28RadCtrlK' --Table of units to ctrlk when this unit finishes construction

--See M28navy for sonar equivalent
refoAssignedMobileShield = 'M28LandAssignedMobileShield' --Gives the mobile shield assigned ot this unit
refoMobileShieldTarget = 'M28LandMobileShieldTarget' --the unit that the mobile shield is trying to protect
refoAssignedMobileStealth = 'M28LandAssignedMobileStealth' --If a mobile stealth is assigned to this unit, then returns the mobile stealth unit assigned
refoMobileStealthTarget = 'M28LandMobileStealthTarget' --Against mobile stleaht units, returns the unit the mobile stealth is trying to cover

function UpdateIfLandZoneWantsSupport(tLZTeamData, iPlateau, iLandZone, iTeam, bWantDFSupport, bWantIndirectSupport)
    tLZTeamData[M28Map.subrefbLZWantsSupport] = (bWantDFSupport or bWantIndirectSupport)
    tLZTeamData[M28Map.subrefbLZWantsDFSupport] = bWantDFSupport
    tLZTeamData[M28Map.subrefbLZWantsIndirectSupport] = bWantIndirectSupport
    if not(M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau]) then
        M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau] = {}
    end
    M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau][iLandZone] = tLZTeamData[M28Map.subrefbLZWantsSupport]
end


function GetUnitPlateauAndLandZoneOverride(oUnit)
    --Return true if have changed something
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnitPlateauAndLandZoneOverride'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iPossiblePlateau
    local iPossibleLZ
    local iBestPlateau
    local iBestLZ
    local bFoundAlternative

    if bDebugMessages == true then LOG(sFunctionRef..': Unit position='..repru(oUnit:GetPosition())..'; Reprs of unit assigned plateau and land zone by team='..reprs(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam])..'; Unit owner='..oUnit:GetAIBrain().Nickname..'; Unit owner team='..oUnit:GetAIBrain().M28Team..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; TIme='..GetGameTimeSeconds()) end

    --Dont override if we are an amphibious/hover unit that is showing as on water
    local iNavPlateau
    local iNavIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition())
    if not(iNavIsland) then
        iNavPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, oUnit:GetPosition())
        if iNavPlateau then
            if M28UnitInfo.GetUnitPathingType(oUnit) == M28Map.refPathingTypeHover then
                if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is on water and is amphibious or hover pathing, so makes sense that it doesnt have a valid land zone') end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return false
            end
        end
    end

    if M28Utilities.IsTableEmpty(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) == false then
        for iTeam, tTeamPlateauAndLZ in oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] do
            if tTeamPlateauAndLZ[2] > 0 then
                if iTeam == oUnit:GetAIBrain().M28Team and M28Utilities.IsTableEmpty(tTeamPlateauAndLZ) == false then
                    iBestPlateau = tTeamPlateauAndLZ[1]
                    iBestLZ = tTeamPlateauAndLZ[2]
                    break
                else
                    iPossiblePlateau = tTeamPlateauAndLZ[1]
                    iPossibleLZ = tTeamPlateauAndLZ[2]
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Just considered iTeam='..iTeam..'; tTeamPlateauAndLZ='..repru(tTeamPlateauAndLZ)..'; iBestPlateau='..(iBestPlateau or 'nil')..'; iBestLZ='..(iBestLZ or 'nil')..'; iPossiblePlateau='..(iPossiblePlateau or 'nil')..'; iPossibleLZ='..(iPossibleLZ or 'nil')) end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iBestPlateau='..(iBestPlateau or 'nil')..'; iBestLZ='..(iBestLZ or 'nil')..'; iPossiblePlateau='..(iPossiblePlateau or 'nil')..'; iPossibleLZ='..(iPossibleLZ or 'nil')) end
        if iBestPlateau and iBestLZ then
            M28Map.AddLocationToPlateauExceptions(oUnit:GetPosition(), iBestPlateau, iBestLZ)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        elseif iPossiblePlateau and iPossibleLZ then

            M28Map.AddLocationToPlateauExceptions(oUnit:GetPosition(), iPossiblePlateau, iPossibleLZ)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end
    else
        --If we look in a 2x2 box around the unit can we find a valid plateau?
        local iDistAdjust
        local tBasePosition = oUnit:GetPosition()

        for iBaseAdjust = 1, 3 do
            iDistAdjust = math.max(2, M28Map.iLandZoneSegmentSize) * iBaseAdjust
            local tLocationAdjust = {{-iDistAdjust,0}, {-iDistAdjust, -iDistAdjust}, {-iDistAdjust, iDistAdjust}, {0, -iDistAdjust}, {0, iDistAdjust}, {iDistAdjust, -iDistAdjust}, {iDistAdjust, 0}, {iDistAdjust,iDistAdjust}}
            if bDebugMessages == true then LOG(sFunctionRef..': Will look in a box around the unit to see if can find a valid plateau, iDistAdjust='..iDistAdjust) end
            for iEntry, tAdjustXZ in tLocationAdjust do
                iPossiblePlateau, iPossibleLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition({ tBasePosition[1] + tAdjustXZ[1], tBasePosition[2], tBasePosition[3] + tAdjustXZ[2] })
                if bDebugMessages == true then LOG(sFunctionRef..': Considering tBasePosition='..repru(tBasePosition)..'; tAdjustXZ='..repru(tAdjustXZ)..'; iPossiblePlateau='..(iPossiblePlateau or 'nil')..'; iPossibleLZ='..(iPossibleLZ or 'nil')..'; NavUtils plateau for this position='..(NavUtils.GetLabel(M28Map.refPathingTypeHover, { tBasePosition[1] + tAdjustXZ[1], tBasePosition[2], tBasePosition[3] + tAdjustXZ[2] }) or 'nil')) end
                if (iPossiblePlateau or 0) > 0 and (iPossibleLZ or 0) > 0 and M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones][iPossibleLZ] then
                    if bDebugMessages == true then LOG('Found a plateau override for oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at position '..repru(oUnit:GetPosition())..' and tAdjustXZ='..repru(tAdjustXZ)) end
                    bFoundAlternative = true
                    M28Map.AddLocationToPlateauExceptions(oUnit:GetPosition(), iPossiblePlateau, iPossibleLZ)
                    break
                end
            end
            if not(bFoundAlternative) then
                --Try in a 1x1 box around the unit to see if we can find a plateau that is land pathable, and if so, see if we can path to a land zone, and if so then update to record this as the closest land zone
                iDistAdjust = 1
                tLocationAdjust = {{0,0}, {-iDistAdjust,0}, {-iDistAdjust, -iDistAdjust}, {-iDistAdjust, iDistAdjust}, {0, -iDistAdjust}, {0, iDistAdjust}, {iDistAdjust, -iDistAdjust}, {iDistAdjust, 0}, {iDistAdjust,iDistAdjust}}
                if bDebugMessages == true then LOG(sFunctionRef..': Will look in a smaller radius box around the unit to see if can find a valid plateau, iDistAdjust='..iDistAdjust) end
                for iEntry, tAdjustXZ in tLocationAdjust do
                    local tAltLocation = { tBasePosition[1] + tAdjustXZ[1], tBasePosition[2], tBasePosition[3] + tAdjustXZ[2] }
                    iPossiblePlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tAltLocation)
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering tAltLocation='..repru(tAltLocation)..'; iPossiblePlateau='..(iPossiblePlateau or 'nil')..'; iPossibleLZ='..(iPossibleLZ or 'nil')..'; NavUtils land pathing label='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tAltLocation) or 'nil')..'; Is table of land zones for this plateau empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones]))) end
                    if (iPossiblePlateau or 0) > 0 and (NavUtils.GetLabel(M28Map.refPathingTypeLand, tAltLocation) or 0) > 0 then
                        --We have a plateau, but dont have a land zone for this position even though it is pathable by land - is there a land zone for this plateau nearby that can path here?
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering nearby LZs that might be able to path here, is table of LZs empty for plateau '..iPossiblePlateau..' = '..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones]))) end
                        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones]) == false then
                            local iClosestLZDist = 100000
                            local iClosestUnpathableLZDist = 100000
                            local iClosestUnpathableLZRef
                            local iCurLZDist
                            for iLandZone, tAltLZData in M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones] do
                                iCurLZDist = M28Utilities.GetDistanceBetweenPositions(tAltLocation, M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMidpoint])

                                if iCurLZDist < iClosestLZDist then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Can we path from alt location to midpoint of land zone '..iLandZone..' with iCurLZDist='..iCurLZDist..'='..tostring(NavUtils.CanPathTo(M28Map.refPathingTypeLand, tAltLocation, M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones][M28Map.subrefMidpoint]))) end
                                    if NavUtils.CanPathTo(M28Map.refPathingTypeLand, tAltLocation, M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones][M28Map.subrefMidpoint]) then
                                        if iCurLZDist < iClosestLZDist then
                                            iClosestLZDist = iCurLZDist
                                            iPossibleLZ = iLandZone
                                        end
                                    elseif not(iPossibleLZ) and iCurLZDist < iClosestUnpathableLZDist then
                                        iClosestUnpathableLZDist = iCurLZDist
                                        iClosestUnpathableLZRef = iLandZone
                                    end
                                end
                            end
                            if not(iPossibleLZ) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Couldnt find any LZs that are actually pathable, closest unpaathable dist='..iClosestUnpathableLZDist..'; if this is within 50 then will use this') end
                                if iClosestUnpathableLZDist < 50 then
                                    iPossibleLZ = iClosestUnpathableLZRef
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Finsihed considering alternative entries in 1x1 box, iPossiblePlateau='..(iPossiblePlateau or 'nil')..'; iPossibleLZ='..(iPossibleLZ or 'nil')..'; If couldnt find anywhere will draw this units position in red; plateau if use hover pathing='..(NavUtils.GetLabel('Hover', oUnit:GetPosition()) or 'nil'))
                        if not(iPossibleLZ) then M28Utilities.DrawLocation(oUnit:GetPosition(), 2) end
                    end
                    if (iPossiblePlateau or 0) > 0 and (iPossibleLZ or 0) > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Identified a backup land zone override for oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at position '..repru(oUnit:GetPosition())..' and tAdjustXZ='..repru(tAdjustXZ)..'; will add to list of exceptions, iPossibleLZ='..(iPossibleLZ or 'nil')) end
                        bFoundAlternative = true
                        M28Map.AddLocationToPlateauExceptions(oUnit:GetPosition(), iPossiblePlateau, iPossibleLZ)
                        break
                    end
                end
            end
            if bFoundAlternative then break end
        end

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bFoundAlternative
end

function ConsiderAddingPlateauOverrideForUnit(oUnit)
    --If unit doesnt show as having a plateau, it isnt attached, and it is on land then have its current position assigned  to the most recent plateau
    --Note - other places will also call override, this isnt the only function
    --returns true if has added an override
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderAddingPlateauOverrideForUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bMadeChange = false
    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; Unit position='..repru(oUnit:GetPosition())..'; Map height='..M28Map.iMapWaterHeight) end
    if oUnit.IsUnitState and not(oUnit:IsUnitState('Attached')) and oUnit:GetPosition()[2] > M28Map.iMapWaterHeight then
        local iCurPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, oUnit:GetPosition())
        if bDebugMessages == true then LOG(sFunctionRef..': Unit plateau from NavUtils='..(iCurPlateau or 'nil')) end
        if (iCurPlateau or 0) <= 0 then
            bMadeChange = GetUnitPlateauAndLandZoneOverride(oUnit)
        else
            --Have a valid plateau but for some reason dont have a land zone?
            local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnit:GetPosition())
            if bDebugMessages == true then LOG(sFunctionRef..': iSegmentX-Z='..iSegmentX..'-'..iSegmentZ..'; tLandZoneBySegment[iSegmentX][iSegmentZ]='..(M28Map.tLandZoneBySegment[iSegmentX][iSegmentZ] or 'nil')) end
            if not(M28Map.tLandZoneBySegment[iSegmentX][iSegmentZ]) then
                bMadeChange = GetUnitPlateauAndLandZoneOverride(oUnit)
                if bDebugMessages == true then LOG(sFunctionRef..': bMadeChange after checking unit plateau and LZ override='..tostring(bMadeChange)) end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bMadeChange
end

function RemoveUnitFromListOfUnitsTravelingToLandZone(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RemoveUnitFromListOfUnitsTravelingToLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[reftiPlateauAndLZToMoveTo]='..repru(oUnit[reftiPlateauAndLZToMoveTo])) end
    if oUnit[reftiPlateauAndLZToMoveTo] then
        local sUnitTableRef
        if EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit.UnitId) then
            sUnitTableRef = M28Map.subrefTScoutsTravelingHere
        else
            M28Utilities.ErrorHandler('Need to add code for this unit category')
        end
        if sUnitTableRef then
            local iTargetPlateau = oUnit[reftiPlateauAndLZToMoveTo][1]
            local iTargetLandZone = oUnit[reftiPlateauAndLZToMoveTo][2]
            local tTravelingUnits = M28Map.tAllPlateaus[iTargetPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][sUnitTableRef]
            if M28Utilities.IsTableEmpty(tTravelingUnits) == false then
                for iTravelUnit, oTravelUnit in tTravelingUnits do
                    if oTravelUnit == oUnit then
                        table.remove(tTravelingUnits, iTravelUnit)
                        break
                    end
                end
            end
        end
        oUnit[reftiPlateauAndLZToMoveTo] = nil
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetUnitToTravelToLandZone(oUnit, iTargetPlateau, iTargetLandZone, subrefTScoutsTravelingHere)
    --Intended for non-engineer units (engineers are handled separately)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnitToTravelToLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    M28Navy.RemoveUnitFromAnyExistingLandOrWaterZoneItWasPreviouslyTravelingTo(oUnit, subrefTScoutsTravelingHere)

    oUnit[M28Navy.refiWZToMoveTo] = nil
    oUnit[reftiPlateauAndLZToMoveTo] = {iTargetPlateau, iTargetLandZone}
    local tLZData = M28Map.tAllPlateaus[iTargetPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
    --if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; iTargetPlateau='..iTargetPlateau..'; iTargetLandZone='..iTargetLandZone..'; Is tLZData empty='..tostring(M28Utilities.IsTableEmpty(tLZData))..'; Is tLZTeamData empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData))..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
    if not(tLZTeamData[subrefTScoutsTravelingHere]) then tLZTeamData[subrefTScoutsTravelingHere] = {} end
    table.insert(tLZTeamData[subrefTScoutsTravelingHere], oUnit)
    if bDebugMessages == true then LOG(sFunctionRef..': About to tell unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to go to iTargetPlateau='..iTargetPlateau..'; iTargetLandZone='..iTargetLandZone..'; midpoint of LZ='..repru(tLZData[M28Map.subrefMidpoint])) end
    M28Orders.IssueTrackedMove(oUnit, tLZData[M28Map.subrefMidpoint], 6, false, 'TLZ'..iTargetLandZone)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateUnitPositionsAndLandZone(aiBrain, tUnits, iTeam, iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
    --Similar to UpdateUnitPositionsAndWaterZone; Based on RemoveEntriesFromArrayAndAddToNewTableBasedOnCondition, but more complex as dont always want to add unit to a table
    --bUpdateTimeOfLastEnemyPositionCheck - if bUseLastKnownPosition is false and this is true, then updates subrefiTimeOfLastEnemyUnitPosUpdate
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateUnitPositionsAndLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iRevisedIndex = 1
    local iTableSize = table.getn(tUnits)
    local iActualPlateau, iActualLandZone
    local UpdateUnitLastKnownPosition = M28Team.UpdateUnitLastKnownPosition
    local bUseActualPositionIfEnemy = false
    local bUnitIsAttached
    if bUpdateTimeOfLastEnemyPositionCheck and not(bUseLastKnownPosition) then tLZTeamData[M28Map.subrefiTimeOfLastEnemyUnitPosUpdate] = GetGameTimeSeconds() end
    if not(bUseLastKnownPosition) or (bUseLastKnownPosition and (tLZTeamData[M28Map.refiRadarCoverage] or 0) >= 70) then bUseActualPositionIfEnemy = true end


    for iOrigIndex=1, iTableSize do
        if bDebugMessages == true then LOG(sFunctionRef..': Updating for unit '..(tUnits[iOrigIndex].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tUnits[iOrigIndex]) or 'nil')) end
        --if (tUnits[iOrigIndex].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tUnits[iOrigIndex]) or 'nil') == 'url01071' then bDebugMessages = true else bDebugMessages = false end
        if not(tUnits[iOrigIndex]) or tUnits[iOrigIndex].Dead then
            --Remove the entry
            tUnits[iOrigIndex] = nil
        else
            --Unit still valid, does it have the right plateau and land zone?
            bUnitIsAttached = tUnits[iOrigIndex]:IsUnitState('Attached')
            if bAreEnemyUnits or bUseLastKnownPosition then
                UpdateUnitLastKnownPosition(aiBrain, tUnits[iOrigIndex], bUseActualPositionIfEnemy)
            end
            if bUseLastKnownPosition then
                if bAreAirUnits or bUnitIsAttached then
                    iActualPlateau, iActualLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition( tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                else
                    iActualPlateau, iActualLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], true, tUnits[iOrigIndex])
                end
            else
                --Allied unit (or special use cases where a human will likely infer an enemy unit has moved) so can use actual position
                if bUnitIsAttached or bAreAirUnits then
                    iActualPlateau, iActualLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition( tUnits[iOrigIndex]:GetPosition())
                else
                    iActualPlateau, iActualLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tUnits[iOrigIndex]:GetPosition(), true, tUnits[iOrigIndex])
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iOrigIndex='..iOrigIndex..'; iActualPlateau='..(iActualPlateau or 'nil')..'; iActualLandZone='..(iActualLandZone or 'nil')) end
            end

            if not(iActualPlateau > 0) then
                if not(bAreAirUnits) and not(bUnitIsAttached) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have a valid actual plateau so will use the recorded plateau and land zone') end
                    iActualPlateau = iRecordedPlateau
                    iActualLandZone = iRecordedLandZone
                    --Add location to table of pathing exceptions
                    if bUseLastKnownPosition then
                        M28Map.AddLocationToPlateauExceptions(tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iRecordedPlateau, iRecordedLandZone)
                    else
                        M28Map.AddLocationToPlateauExceptions(tUnits[iOrigIndex]:GetPosition(), iRecordedPlateau, iRecordedLandZone)
                    end
                end
            end

            --Is the plateau and zone correct?
            if bDebugMessages == true then
                LOG('Updating unit position for unit '..tUnits[iOrigIndex].UnitId..M28UnitInfo.GetUnitLifetimeCount(tUnits[iOrigIndex])..'; iRecordedPlateau='..iRecordedPlateau..'; iActualPlateau='..(iActualPlateau or 'nil')..';  iRecordedLandZone='..(iRecordedLandZone or 'nil')..'; iActualLandZone='..(iActualLandZone or 'nil')..'; Unit actual position='..repru(tUnits[iOrigIndex]:GetPosition())..'; Plateau ref using navutils of actual position='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tUnits[iOrigIndex]:GetPosition()) or 'nil')..'; Last known position='..repru(tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Hover nav utils of unit position='..(NavUtils.GetLabel(M28Map.refPathingTypeHover, tUnits[iOrigIndex]:GetPosition()) or 'nil'))
                M28Utilities.DrawLocation(tUnits[iOrigIndex]:GetPosition())
            end
            --If the plateau has changed, and the new one has no valid location, then update the position to the actual position (due to issue with e.g. air units where if they fly over a cliff at the point intel is lost then it causes an error when trying to add them to another zone)
            if not(iRecordedPlateau == iActualPlateau) and bUseLastKnownPosition and (iActualLandZone or 0) > 0 then
                local tRevisedPosition = tUnits[iOrigIndex]:GetPosition()
                tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][iTeam] = {tRevisedPosition[1], tRevisedPosition[2], tRevisedPosition[3]}
                iActualPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tRevisedPosition)
            end
            if iRecordedPlateau == iActualPlateau and iRecordedLandZone == iActualLandZone then
                --No change needed for unit
                if (iOrigIndex ~= iRevisedIndex) then
                    tUnits[iRevisedIndex] = tUnits[iOrigIndex]
                    tUnits[iOrigIndex] = nil
                end
                iRevisedIndex = iRevisedIndex + 1
            else
                local oUnitToAdd = tUnits[iOrigIndex]
                --Want to remove the entry from this table, but then add it to the correct table
                oUnitToAdd[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam] = nil --Done here so we dont try and go through this table again when removing later on
                if iActualPlateau > 0 and iActualLandZone > 0 then
                    --AddUnitToLandZoneForBrain(aiBrain,        oUnit,      iPlateau,       iLandZone,      bIsEnemyAirUnit)
                    M28Team.AddUnitToLandZoneForBrain(aiBrain, oUnitToAdd, iActualPlateau, iActualLandZone, bAreAirUnits)
                    if bDebugMessages == true then LOG('Adding unit to land zone') end
                else
                    local iWaterZone
                    if iActualPlateau > 0 then
                        local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnitToAdd:GetPosition())
                        iWaterZone = M28Map.tWaterZoneBySegment[iSegmentX][iSegmentZ]
                    end
                    if bDebugMessages == true then LOG('Unit water zone='..(iWaterZone or 'nil')) end
                    if iWaterZone then
                        M28Team.AddUnitToWaterZoneForBrain(aiBrain, oUnitToAdd, iWaterZone, bAreAirUnits)
                    else
                        if bAreAirUnits then
                            --Get revised plateau/LZ
                            iActualPlateau, iActualLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnitToAdd:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': Air unit will record in either water or land zone, iActualPlateau='..(iActualPlateau or 'nil')..'; iActualLandZone='..(iActualLandZone or 'nil')) end
                            if iActualPlateau == 0 then
                                --Water zone
                                iWaterZone = iActualLandZone
                                M28Team.AddUnitToWaterZoneForBrain(aiBrain, oUnitToAdd, iWaterZone, bAreAirUnits)
                            else
                                M28Team.AddUnitToLandZoneForBrain(aiBrain, oUnitToAdd, iActualPlateau, iActualLandZone, bAreAirUnits)
                            end
                        else
                            --Not sure where to record unit so call main logic
                            M28Team.AssignUnitToLandZoneOrPond(aiBrain, oUnitToAdd, true)
                        end
                    end
                end

                tUnits[iOrigIndex] = nil
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iRevisedIndex='..iRevisedIndex..'; Is tUnits empty='..tostring(M28Utilities.IsTableEmpty(tUnits))..'; iiRecordedPlateau='..iRecordedPlateau..'; iRecordedLandZone='..iRecordedLandZone..'; GameTime='..GetGameTimeSeconds()..'; bUseLastKnownPosition='..tostring(bUseLastKnownPosition or false)..'; bUseActualPositionIfEnemy='..tostring(bUseActualPositionIfEnemy)..'; bUpdateTimeOfLastEnemyPositionCheck='..tostring(bUpdateTimeOfLastEnemyPositionCheck)) end
end

function RecordAirThreatForLandZone(tLZTeamData, iTeam, iPlateau, iLandZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAirThreatForLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                                                                --GetAirThreatLevel(tUnits,                                   bEnemyUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
    tLZTeamData[M28Map.refiEnemyAirToGroundThreat] = M28UnitInfo.GetAirThreatLevel(tLZTeamData[M28Map.reftLZEnemyAirUnits],     true,       false,              false,              true,               false,                  false)
    tLZTeamData[M28Map.refiEnemyAirAAThreat] = M28UnitInfo.GetAirThreatLevel(tLZTeamData[M28Map.reftLZEnemyAirUnits],           true,       true,               false,              false,              false,                   false)
    tLZTeamData[M28Map.refiEnemyAirOtherThreat] = M28UnitInfo.GetAirThreatLevel(tLZTeamData[M28Map.reftLZEnemyAirUnits],        true,       false,               false,              false,              true,                   true)

    if bDebugMessages == true then LOG(sFunctionRef..': Finished updating enemy air threat values for iTeam '..iTeam..' iPlateau '..iPlateau..'; iLandZOne '..iLandZone..'; AirToGround threat='.. tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Other air threat='..tLZTeamData[M28Map.refiEnemyAirOtherThreat]..'; Is table of enemy air units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]))) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordGroundThreatForLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone)
    --Records the different types of threat for the land zone

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordGroundThreatForLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Track team total threat - first remove the previous entry, then add in the new entry
    M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] - tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
    M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] - tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]
    M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] - tLZTeamData[M28Map.subrefLZThreatAllyMAA]
    M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] - tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at game time '..GetGameTimeSeconds()..' for iTeam='..iTeam..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))) end
    --local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) then
        tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] = 0
        tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] = false
        tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyShield] = 0
    else
        local tMobileUnits = EntityCategoryFilterDown(categories.MOBILE - M28UnitInfo.refCategoryScathis, tLZTeamData[M28Map.subrefTEnemyUnits])
        local tStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryScathis, tLZTeamData[M28Map.subrefTEnemyUnits])
        local tEnemiesExclShieldsAndFixedArti = EntityCategoryFilterDown(categories.MOBILE - M28UnitInfo.refCategoryMobileLandShield + categories.DIRECTFIRE, tLZTeamData[M28Map.subrefTEnemyUnits]) --(shield value gets added later based on the threat excl shields)
        local bHaveDangerousEnemies = false
        tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] = M28UnitInfo.GetCombatThreatRating(tEnemiesExclShieldsAndFixedArti, true)
        if bDebugMessages == true then
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                LOG(sFunctionRef..': Will list out every enemy unit in the zone and its threat, position, and the plateau and land zone of that position')
                for iUnit, oUnit in tLZTeamData[M28Map.subrefTEnemyUnits] do
                    local iUnitPlateau, iUnitZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                    LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has threat '..M28UnitInfo.GetCombatThreatRating({ oUnit }, true)..'; Position='..repru(oUnit:GetPosition())..'; Dist to midpoint='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])..'; iUnitPlateau='..(iUnitPlateau or 'nil')..'; iUnitZone='..(iUnitZone or 'nil'))
                end
            end
        end

        tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] = M28UnitInfo.GetCombatThreatRating(tStructures, true, false, true)
        tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] = M28UnitInfo.GetAirThreatLevel(tLZTeamData[M28Map.subrefTEnemyUnits], true, false, true, false, false, false)
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] = 0
        tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] = M28UnitInfo.GetCombatThreatRating(tStructures, true, true)

        --Increase structure value for under construction experimentals
        local tExperimentals = EntityCategoryFilterDown(categories.EXPERIMENTAL * categories.MOBILE, tLZTeamData[M28Map.subrefTEnemyUnits])
        if M28Utilities.IsTableEmpty(tExperimentals) == false then
            for iUnit, oUnit in tExperimentals do
                if oUnit:GetFractionComplete() < 1 then
                    tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] = tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] + M28UnitInfo.GetCombatThreatRating({ oUnit }, true, true) * oUnit:GetFractionComplete()
                    if bDebugMessages == true then LOG(sFunctionRef..': Have under construction experimental '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' in Plateau '..iPlateau..' Zone '..iZone..'; will increase threat for this, fraction complete='..oUnit:GetFractionComplete()..'; structure threat after increase='..tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]) end
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Plateau '..iPlateau..' LZ '..iLandZone..' has enemy units, Enemy combat total='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Is table of enemy structures empty='..tostring(M28Utilities.IsTableEmpty(tStructures))..'; Is tMobileUnits empty='..tostring(M28Utilities.IsTableEmpty(tMobileUnits))) end
        local iCurThreat
        if M28Utilities.IsTableEmpty(tMobileUnits) == false then
            for iUnit, oUnit in tMobileUnits do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Indirect range='..(oUnit[M28UnitInfo.refiIndirectRange] or 'nil')..'; Combat threat rating='..M28UnitInfo.GetCombatThreatRating({ oUnit }, true)) end
                if (oUnit[M28UnitInfo.refiDFRange] > 0 or oUnit[M28UnitInfo.refiIndirectRange]) and oUnit:GetFractionComplete() >= 0.9 then
                    iCurThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }, true)
                    if iCurThreat > 0 then
                        if oUnit[M28UnitInfo.refiDFRange] > 0 then
                            if not(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) then tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] = {} end
                            tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange][oUnit[M28UnitInfo.refiDFRange]] = (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange][oUnit[M28UnitInfo.refiDFRange]] or 0) + iCurThreat
                            if not(bHaveDangerousEnemies) and iCurThreat > 10 then bHaveDangerousEnemies = true end
                            tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] = tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] + iCurThreat
                        end
                        if oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                            if not(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange]) then tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] = {} end
                            tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange][oUnit[M28UnitInfo.refiIndirectRange]] = (tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange][oUnit[M28UnitInfo.refiIndirectRange]] or 0) + iCurThreat
                            tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] = tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] + iCurThreat
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Enemy mobile indirect range after updating all units='..repru(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange])..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]='..repru(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange])..'; subrefLZThreatEnemyMobileDFTotal='..(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 'nil')) end
        end
        if M28Utilities.IsTableEmpty(tStructures) == false then
            for iUnit, oUnit in tStructures do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; with DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')) end
                if oUnit[M28UnitInfo.refiDFRange] > 0 and oUnit:GetFractionComplete() >= 0.9 then
                    iCurThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Structure iCurThreat='..iCurThreat) end
                    if iCurThreat > 0 then
                        if not(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) then tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] = {} end
                        tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange][oUnit[M28UnitInfo.refiDFRange]] = (tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange][oUnit[M28UnitInfo.refiDFRange]] or 0) + iCurThreat
                        if not(bHaveDangerousEnemies) and iCurThreat > 10 then bHaveDangerousEnemies = true end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': LZ threats by range after updating for all structures='..repru(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange])) end
        end
        tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] = bHaveDangerousEnemies

        --Increase enemy threats for shield values
        local tShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryMobileLandShield, tLZTeamData[M28Map.subrefTEnemyUnits])
        tLZTeamData[M28Map.subrefLZThreatEnemyShield] = 0
        if M28Utilities.IsTableEmpty(tShields) == false then
            local iCurShield, iMaxShield
            local iThreatFactor
            for iUnit, oUnit in tShields do
                if oUnit:GetFractionComplete() >= 0.9 then
                    iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, true)
                    iThreatFactor = math.max(0.1, iCurShield /  iMaxShield)
                    tLZTeamData[M28Map.subrefLZThreatEnemyShield] = tLZTeamData[M28Map.subrefLZThreatEnemyShield] + iThreatFactor * oUnit:GetBlueprint().Economy.BuildCostMass
                end
            end
        end
        if tLZTeamData[M28Map.subrefLZThreatEnemyShield] >= 50 then
            local iMaxShieldRating
            if tLZTeamData[M28Map.subrefLZThreatEnemyShield] >= 4000 then
                iMaxShieldRating = math.min(3200 + (tLZTeamData[M28Map.subrefLZThreatEnemyShield] - 4000) * 0.4, 7000) --shields wont be able to cover everywhere, and more than one shield has lower value due to FAF anti-shield stacking
            else
                iMaxShieldRating = tLZTeamData[M28Map.subrefLZThreatEnemyShield] * 0.8
            end

            tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] = tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] + math.max(iMaxShieldRating * 0.1, math.min(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal], iMaxShieldRating))
            tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] = tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] + math.min(tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect], iMaxShieldRating)
            tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] = tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] + math.min(tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA], iMaxShieldRating)
            tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] = tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] + math.min(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal], iMaxShieldRating * 0.6)
            tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] = tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] + math.min(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal], iMaxShieldRating * 0.6)
        end

    end

    --Include long range threats
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of long range threats empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats]) == false then
        local tNearbyLongRangeThreats = {}
        for iUnit, oUnit in tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats] do
            if M28UnitInfo.IsUnitValid(oUnit) then
                if bDebugMessages == true then LOG(sFunctionRef..': Long range threat unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Dist to midpoint='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])..'; Unit range='..(oUnit[M28UnitInfo.refiCombatRange] or 0)) end
                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= (oUnit[M28UnitInfo.refiCombatRange] or 0) + 55 then
                    table.insert(tNearbyLongRangeThreats, oUnit)
                end
            end
        end
        if M28Utilities.IsTableEmpty(tNearbyLongRangeThreats) then tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] = 0
        else
            tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] = M28UnitInfo.GetCombatThreatRating(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats], true)
        end
    else
        tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] = 0
    end


    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) then
        tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyStructureIndirect] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] = 0
    else
        local tMobileUnits = EntityCategoryFilterDown(categories.MOBILE, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local tStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] = M28UnitInfo.GetCombatThreatRating(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits], false)
        tLZTeamData[M28Map.subrefLZThreatAllyStructureIndirect] = M28UnitInfo.GetCombatThreatRating(tStructures, false, false, true)
        tLZTeamData[M28Map.subrefLZThreatAllyMAA] = M28UnitInfo.GetAirThreatLevel(tMobileUnits, false, false, true, false, false, false)
        tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] = M28UnitInfo.GetAirThreatLevel(tStructures, false, false, true, false, false, false) + tLZTeamData[M28Map.subrefLZThreatAllyMAA]

        tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] = nil
        local iCurThreat
        if bDebugMessages == true then LOG(sFunctionRef..': Calculating threat by range for allied units, is tMobileUnits empty='..tostring(M28Utilities.IsTableEmpty(tMobileUnits))..'; is tStructures empty='..tostring(M28Utilities.IsTableEmpty(tStructures))) end
        if M28Utilities.IsTableEmpty(tMobileUnits) == false then
            for iUnit, oUnit in tMobileUnits do
                if oUnit:GetFractionComplete() >= 1 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; refiDFRange='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; IndirectRange='..(oUnit[M28UnitInfo.refiIndirectRange] or 'nil')..'; Unit combat rating='..M28UnitInfo.GetCombatThreatRating({ oUnit }, false)) end
                    if oUnit[M28UnitInfo.refiDFRange] > 0 or oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                        iCurThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }, false, nil, (oUnit[M28UnitInfo.refiDFRange] or 0) == 0)
                        if iCurThreat > 0 then
                            if oUnit[M28UnitInfo.refiDFRange] > 0 then
                                if not(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) then tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] = {} end
                                tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange][oUnit[M28UnitInfo.refiDFRange]] = (tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange][oUnit[M28UnitInfo.refiDFRange]] or 0) + iCurThreat
                            end
                            if oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                                if not(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange]) then tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] = {} end
                                tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange][oUnit[M28UnitInfo.refiIndirectRange]] = (tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange][oUnit[M28UnitInfo.refiIndirectRange]] or 0) + iCurThreat
                            end
                        end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tStructures) == false then
            for iUnit, oUnit in tStructures do
                if oUnit[M28UnitInfo.refiDFRange] > 0 and oUnit:GetFractionComplete() >= 1 then
                    iCurThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }, true)
                    if iCurThreat > 0 then
                        if not(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) then tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] = {} end
                        tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange][oUnit[M28UnitInfo.refiDFRange]] = (tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange][oUnit[M28UnitInfo.refiDFRange]] or 0) + iCurThreat
                    end
                end
            end
        end
        --Update total DF and indirect threat
        tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] = 0
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] = tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] + iThreat
            end
        end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] do
                tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] = tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] + iThreat
            end
        end

        M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] + tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
        M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] + tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]
        M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] + tLZTeamData[M28Map.subrefLZThreatAllyMAA]
        M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] + tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]

    end
    local bNearbyEnemies = false

    if bDebugMessages == true then LOG(sFunctionRef..': Considering if enemy units in this or adjacent LZ, is table of enemy units for this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))..'; Adjacent LZs='..repru(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
        bNearbyEnemies = true
    else
        --, iPlateau, iLandZone
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones] do
                --NEED to flag as nearby enemies if any enemy units in the LZ, or else can cause problems where we try to attack a unit in an adjacent land zone, and then think there is no such unit due to this flag if it is only based on combat threat
                if bDebugMessages == true then LOG(sFunctionRef..': Enemy combat threat for adjacent LZ iAdjLZ='..iAdjLZ..'; threat='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal]) end
                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                    bNearbyEnemies = true
                    break
                end
            end
        end
    end

    --Calculate core DF and indirect wanted just for this LZ:
    if bNearbyEnemies then
        local iEnemyStructureThreat = 0
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                iEnemyStructureThreat = iEnemyStructureThreat + iThreat
            end
        end
        tLZTeamData[M28Map.subrefLZIndirectThreatWanted] = iEnemyStructureThreat * 2 + tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] * 2
        tLZTeamData[M28Map.subrefLZDFThreatWanted] = math.max(200, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 2)
    else
        tLZTeamData[M28Map.subrefLZDFThreatWanted] = 0
        tLZTeamData[M28Map.subrefLZIndirectThreatWanted] = 0
    end

    --If we have no friendly combat units and enemy has combat threat, then request less MAA, or none if we have no non-MAA/scout units
    if bDebugMessages == true then LOG(sFunctionRef..': Setting the MAA level wanted for iLandZone='..iLandZone..'; tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]='..tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tLZTeamData[M28Map.refiEnemyAirOtherThreat]='..tLZTeamData[M28Map.refiEnemyAirOtherThreat]..'; Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
    if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < 11 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= math.min(1500, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 0.9) or tLZTeamData[M28Map.subrefLZbCoreBase] then
        tLZTeamData[M28Map.subrefLZMAAThreatWanted] = math.max(tLZTeamData[M28Map.refiEnemyAirToGroundThreat] * 0.65 + tLZTeamData[M28Map.refiEnemyAirAAThreat] * 0.15 + tLZTeamData[M28Map.refiEnemyAirOtherThreat] * 0.15, tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] * 0.1)
    elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        local bHaveAlliedNonMAAOrScout = false
        local bHaveAlliedMAA = false
        for iUnit, oUnit in tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do
            if EntityCategoryContains(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryMAA - M28UnitInfo.refCategoryLandScout, oUnit.UnitId) then
                bHaveAlliedNonMAAOrScout = true
                break
            elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId) then
                bHaveAlliedMAA = true
            end
        end -- M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryMAA - M28UnitInfo.refCategoryLandScout, subreftoLZOrWZAlliedUnits
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveAlliedMAA='..tostring(bHaveAlliedMAA)..'; bHaveAlliedNonMAAOrScout='..tostring(bHaveAlliedNonMAAOrScout)) end
        if bHaveAlliedNonMAAOrScout or (bHaveAlliedMAA and tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0) then
            --SIgnificantly less MAA for dealing with non-air to ground threats
            if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                tLZTeamData[M28Map.subrefLZMAAThreatWanted] = math.max(tLZTeamData[M28Map.refiEnemyAirToGroundThreat], (tLZTeamData[M28Map.refiEnemyAirOtherThreat] + tLZTeamData[M28Map.refiEnemyAirAAThreat]) * 0.075, tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] * 0.2)
            else
                tLZTeamData[M28Map.subrefLZMAAThreatWanted] = math.max((tLZTeamData[M28Map.refiEnemyAirOtherThreat] + tLZTeamData[M28Map.refiEnemyAirAAThreat]) * 0.075, tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] * 0.1)
            end
        else
            tLZTeamData[M28Map.subrefLZMAAThreatWanted] = 0
        end
    else
        tLZTeamData[M28Map.subrefLZMAAThreatWanted] = 0
    end

    --Increase MAA wanted if we have ACU in the LZ
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false then
        local tiMAAByTechForACU = {100, 400, 1000}
        if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
            tLZTeamData[M28Map.subrefLZMAAThreatWanted] = tLZTeamData[M28Map.subrefLZMAAThreatWanted] + math.min(1600, tiMAAByTechForACU[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2)
        else
            tLZTeamData[M28Map.subrefLZMAAThreatWanted] = tLZTeamData[M28Map.subrefLZMAAThreatWanted] + tiMAAByTechForACU[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
        end
    end

    --Update if have enemies in adjacent WZ
    tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] = false
    tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = false
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
        local iAdjWZ, iPond
        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
            iAdjWZ = tSubtable[M28Map.subrefAWZRef]
            iPond = M28Map.tiPondByWaterZone[iAdjWZ]
            local tWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
            if (tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 20 and tWZTeamData[M28Map.subrefWZBestEnemyDFRange] > 0 then
                tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] = true
                tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = true
                break
            elseif M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = true
            end
        end
    end

    tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] = bNearbyEnemies
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]='..repru(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange])..'; bNearbyEnemies='..tostring(bNearbyEnemies)..'; Allied combat='..(tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 'nil')..'; tLZTeamData[M28Map.subrefLZMAAThreatWanted]='..tLZTeamData[M28Map.subrefLZMAAThreatWanted]..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tLZTeamData[M28Map.refiEnemyAirOtherThreat]='..tLZTeamData[M28Map.refiEnemyAirOtherThreat]) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RunFromEnemy(oUnitToRun, oEnemy, iTeam, iPlateau, iDistanceToRun)
    --NOTE: Used by waterzone logic as well for scouts to run

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RunFromEnemy'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iAngleFromEnemy = M28Utilities.GetAngleFromAToB(oEnemy:GetPosition(), oUnitToRun:GetPosition())
    --MoveInDirection(tStart, iAngle,           iDistance, bKeepInMapBounds, bTravelUnderwater, bKeepInCampaignPlayableArea)
    local tPotentialRunPosition = M28Utilities.MoveInDirection(oUnitToRun:GetPosition(), iAngleFromEnemy, iDistanceToRun, false,             false,              false)
    if not(M28Conditions.IsLocationInPlayableArea(tPotentialRunPosition)) then
        --Can we do half the distance
        tPotentialRunPosition = M28Utilities.MoveInDirection(oUnitToRun:GetPosition(), iAngleFromEnemy, iDistanceToRun, false,             false,              false)
        if not(M28Conditions.IsLocationInPlayableArea(tPotentialRunPosition)) then
            --Run to the closest rally point instead
            local iUnitPlateau, iUnitZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnitToRun:GetPosition())
            local tRallyPoint
            if (iUnitZone or 0) > 0 then
                local tLZOrWZData

                if iUnitPlateau == 0 then
                    tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iUnitZone]][M28Map.subrefPondWaterZones][iUnitZone]
                    tRallyPoint = M28Navy.GetNearestWaterRallyPoint(tLZOrWZData, iTeam, M28Map.tiPondByWaterZone[iUnitZone], iUnitZone)
                else
                    tLZOrWZData = M28Map.tAllPlateaus[iUnitPlateau][M28Map.subrefPlateauLandZones][iUnitZone]
                    tRallyPoint = GetNearestLandRallyPoint(tLZOrWZData, iTeam, iUnitPlateau, iUnitZone, 2, EntityCategoryContains(categories.HOVER + categories.AMPHIBIOUS, oUnitToRun.UnitId))
                end

            else
                --Run to the unit's brain's start position
                tRallyPoint = M28Map.PlayerStartPoints[oUnitToRun:GetAIBrain():GetArmyIndex()]
            end
            tPotentialRunPosition = {tRallyPoint[1], tRallyPoint[2], tRallyPoint[3]}
        end
    else
        --Are in the playable area; are we in the same plateau? if not then try and move further away by 5 and 10; if still not in same plateau then move back to start position
        local iCurPlateau, iCurLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tPotentialRunPosition)
        local iAlternativeCount = 0
        if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, oUnitToRun='..oUnitToRun.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToRun)..'; Time='..GetGameTimeSeconds()..'; Initial tPotentialRunPosition='..repru(tPotentialRunPosition)..'; iAngleFromEnemy='..iAngleFromEnemy..'; iCurPlateau='..(iCurPlateau or 'nil')..'; iPlateau='..(iPlateau or 'nil')) end
        while not(iCurPlateau == iPlateau) do
            iAlternativeCount = iAlternativeCount + 1
            if iAlternativeCount >= 3 then
                --Go to start instead
                tPotentialRunPosition = M28Map.PlayerStartPoints[oUnitToRun:GetAIBrain():GetArmyIndex()]
                break
            else
                iDistanceToRun = iDistanceToRun + 4
                tPotentialRunPosition = M28Utilities.MoveInDirection(oUnitToRun:GetPosition(), iAngleFromEnemy, iDistanceToRun, true, false, true)
                iCurPlateau, iCurLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tPotentialRunPosition)
            end
        end
    end



    M28Orders.IssueTrackedMove(oUnitToRun, tPotentialRunPosition, math.min(8, iDistanceToRun * 0.25), false, 'RunE'..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy))
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Just tried to give move order for oUnitToRun='..oUnitToRun.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToRun)..' from cur position '..repru(oUnitToRun:GetPosition())..' to position '..repru(tPotentialRunPosition)..' due to enemy '..(oEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEnemy) or 'nil')..' which is at last known position '..repru(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; iDistanceToRun='..(iDistanceToRun or 'nil')..'; Angle to run location='..M28Utilities.GetAngleFromAToB(oUnitToRun:GetPosition(), tPotentialRunPosition)..'; Angle from unit ot enemy='..M28Utilities.GetAngleFromAToB(oUnitToRun:GetPosition(), oEnemy:GetPosition())..'; Actual last order position='..repru(oUnitToRun[M28Orders.reftiLastOrders][oUnitToRun[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition])..'; Unit order count='..(oUnitToRun[M28Orders.refiOrderCount] or 'nil')..'; GameTime='..GetGameTimeSeconds()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageLandZoneScouts(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tScouts, bLandZoneContainsNonScouts)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageLandZoneScouts'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    tLZTeamData[M28Map.refbWantLandScout] = false
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want a land scout for iPlateau '..iPlateau..'; iLandZone='..iLandZone..'; bLandZoneContainsNonScouts='..tostring(bLandZoneContainsNonScouts or false)..'; Enemy combat threat='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Is table of land scouts traveling here empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTScoutsTravelingHere]))..'; Is table of scouts currently in this LZ empty='..tostring(M28Utilities.IsTableEmpty(tScouts))..'; Time='..GetGameTimeSeconds()) end

    --Refresh list of scouts traveling here
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTScoutsTravelingHere]) == false then
        local iTableSize = table.getn(tLZTeamData[M28Map.subrefTScoutsTravelingHere])
        for iCurEntry = iTableSize, 1, -1 do
            if not(M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.subrefTScoutsTravelingHere][iCurEntry])) then
                table.remove(tLZTeamData[M28Map.subrefTScoutsTravelingHere], iCurEntry)
            end
        end
    end

    if (bLandZoneContainsNonScouts or tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 2) and (tLZData[M28Map.subrefLZMexCount] > 0 or tLZData[M28Map.subrefLZTotalSegmentCount] > 30) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTScoutsTravelingHere]) then
        --Want a land scout for htis land zone, unless we already have one traveling here; if we have available land scouts then will change this flag back to false
        if not(tLZData[M28Map.subrefbPacifistArea]) then
            if not(M28Map.bIsCampaignMap) or M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then
                tLZTeamData[M28Map.refbWantLandScout] = true
                if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; We want to get a scout for this LZ '..(iLandZone or 'nil')..' on plateau '..(iPlateau or 'nil')..' with island '..(tLZData[M28Map.subrefLZIslandRef] or 'nil')) end
            end
        end
    end

    --Do we have any land scouts that are available? if so then assign to an adjacent land zone if the adjacent zone wants scouts
    if M28Utilities.IsTableEmpty(tScouts) == false then
        tLZTeamData[M28Map.refiTimeLastHadVisual] = GetGameTimeSeconds()
        local tAvailableScouts = {}
        local bCheckForEnemies = false
        local tEnemyUnitTablesToConsider = {}
        --Check for neemies if there are any in this or adjacent land zone
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
            --if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 then
            table.insert(tEnemyUnitTablesToConsider, tLZTeamData[M28Map.subrefTEnemyUnits])
        end

        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Checking if enemies in iAdjLZ='..iAdjLZ..'; enemy combat total='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal]) end
                if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] > 0 then
                    table.insert(tEnemyUnitTablesToConsider, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits])
                end
            end
        end
        if M28Utilities.IsTableEmpty(tEnemyUnitTablesToConsider) == false then bCheckForEnemies = true end

        local oEnemyToRunFrom
        local oPrevEnemyToRunFrom
        local iRunThreshold = 15 --If get this close to being in range of an enemy should try to run
        local iAttackThreshold = 35
        if bDebugMessages == true then LOG(sFunctionRef..': About to consider orders for scouts in this LZ, size of tScouts='..table.getn(tScouts)..'; bCheckForEnemies='..tostring(bCheckForEnemies)..'; Enemy combat total='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]) end
        local oEnemyToConsiderAttacking
        local iEnemyToConsiderAttackingDist
        local bConsiderAttacking = false
        local iCurDist
        local bStandAlmostStill = false
        local iActualCurDist
        local iClosestDangerousEnemy
        local oClosestDangerousEnemy
        for iScout, oScout in tScouts do
            if oScout:GetFractionComplete() == 1 then

                if bDebugMessages == true then LOG(sFunctionRef..': Considering scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..'; bCheckForEnemies='..tostring(bCheckForEnemies)) end
                if bCheckForEnemies then
                    iClosestDangerousEnemy = 10000
                    oEnemyToRunFrom = nil
                    if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 12 and EntityCategoryContains(M28UnitInfo.refCategoryCombatScout, oScout.UnitId) and (oScout[M28UnitInfo.refiDFRange] or 0) >= 12 then
                        bConsiderAttacking = true
                        iEnemyToConsiderAttackingDist = 100000
                    end
                    if bDebugMessages == true and oPrevEnemyToRunFrom then LOG(sFunctionRef..': oPrevEnemyToRunFrom='..oPrevEnemyToRunFrom.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPrevEnemyToRunFrom)..'; Dist to prev enemy='..M28Utilities.GetDistanceBetweenPositions(oPrevEnemyToRunFrom:GetPosition(), oScout:GetPosition())..'; Enemy range='..(oPrevEnemyToRunFrom[M28UnitInfo.refiDFRange] or 0)..'; Run threshold='..iRunThreshold..'; iLandZone='..iLandZone) end
                    if not(bConsiderAttacking) and oPrevEnemyToRunFrom and M28Utilities.GetDistanceBetweenPositions(oPrevEnemyToRunFrom:GetPosition(), oScout:GetPosition()) - (oPrevEnemyToRunFrom[M28UnitInfo.refiDFRange] or 0) <= iRunThreshold then
                        --Run from same enemy
                        oEnemyToRunFrom = oPrevEnemyToRunFrom
                    else
                        bStandAlmostStill = false
                        for iUnitTable, tUnitTable in tEnemyUnitTablesToConsider do
                            for iUnit, oUnit in tUnitTable do
                                if M28UnitInfo.IsUnitValid(oUnit) then

                                    if bDebugMessages == true then LOG(sFunctionRef..': Looking for enemy to run from for scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..', considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Unit position='..repru(oUnit:GetPosition())..'; Unit last known position='..repru(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Dist between last known position and scout='..M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition())..'; Actual dist using actual position='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oScout:GetPosition())..'; Is unit visible='..tostring(M28UnitInfo.CanSeeUnit(oScout:GetAIBrain(), oUnit, true))..'; Unit range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; iRunThreshold='..iRunThreshold..'; Is distance within run threshold='..tostring(M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0) <= iRunThreshold)..'; bConsiderAttacking='..tostring(bConsiderAttacking)..'; Unit df range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Unit build range='..(oUnit:GetBlueprint().Economy.MaxBuildDistance or 'nil')) end
                                    if bConsiderAttacking or (((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId)) and not(oUnit == oPrevEnemyToRunFrom)) then
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0)
                                        if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then iCurDist = iCurDist - (oUnit:GetBlueprint().Economy.MaxBuildDistance or 0) end
                                        if iCurDist < iClosestDangerousEnemy and (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout * categories.TECH3 - categories.SERAPHIM, oUnit.UnitId))  then
                                            oClosestDangerousEnemy = oUnit
                                            iClosestDangerousEnemy = iCurDist
                                        end
                                        if iCurDist <= iRunThreshold then
                                            oEnemyToRunFrom = oUnit
                                            bStandAlmostStill = false
                                            if bDebugMessages == true then LOG(sFunctionRef..': Want to run from unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so will stop searching') end
                                            if not(bConsiderAttacking) or iClosestDangerousEnemy < iRunThreshold then break end
                                        else
                                            --Adjust run threshold if enemy unit is moving, and facing towards us
                                            if iCurDist - 2 <= iRunThreshold and oUnit:IsUnitState('Moving') and M28Utilities.GetAngleDifference(M28UnitInfo.GetUnitFacingAngle(oUnit), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oScout:GetPosition())) <= 15 then
                                                oEnemyToRunFrom = oUnit
                                                bStandAlmostStill = false
                                                if bDebugMessages == true then LOG(sFunctionRef..': Want to run as unit is facing us and still relatively close, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so will stop searching') end
                                                if not(bConsiderAttacking) or iClosestDangerousEnemy < iRunThreshold then break end
                                            elseif bConsiderAttacking and ((oUnit[M28UnitInfo.refiDFRange] or 0) == 0 or EntityCategoryContains(M28UnitInfo.refCategoryLandScout * categories.TECH3 - categories.SERAPHIM, oUnit.UnitId)) and iCurDist < math.max(iAttackThreshold, iEnemyToConsiderAttackingDist) then
                                                oEnemyToConsiderAttacking = oUnit
                                                iEnemyToConsiderAttackingDist = iCurDist
                                                if bDebugMessages == true then LOG(sFunctionRef..': Want to consider attacking the unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' but will first check no units to run from') end
                                            else
                                                if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is too far away for us to run from it, will keep looking subject to considering if its close enough we should stand still instead, iCurDist='..iCurDist) end
                                                if not(oEnemyToRunFrom) then
                                                    --Try to approximate case where enemy has a unit that is approaching our scout, and we are moving away, only to move back again - a human player would know to only move the scout a small bit to allow intel to catchup on the enemy unit; so will approximate that by having hte scout 'retreat' but not by much, if the enemy near
                                                    iActualCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oScout:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0)
                                                    if iActualCurDist - 5 <= iRunThreshold and (iActualCurDist - 3.5 <= iRunThreshold or oUnit:IsUnitState('Moving')) then
                                                        oEnemyToRunFrom = oUnit
                                                        bStandAlmostStill = true
                                                    end
                                                end
                                            end
                                        end

                                        --Check if about to get in range of engineer that can reclaim us - have done +8 as lower values resulted in some cases in the engineer being able to reclaim the scout
                                    elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) <= 8 + (oUnit:GetBlueprint().Economy.MaxBuildDistance or 3) then
                                        oEnemyToRunFrom = oUnit
                                        break
                                    end
                                end
                            end
                        end
                    end
                    if bConsiderAttacking then
                        if iClosestDangerousEnemy - 8 <= iRunThreshold then oEnemyToConsiderAttacking = nil
                        elseif oEnemyToRunFrom and M28UnitInfo.GetCombatThreatRating({ oEnemyToRunFrom }, true) <= 11 and not(EntityCategoryContains(M28UnitInfo.refCategoryLandCombat, oEnemyToRunFrom.UnitId)) then
                            oEnemyToConsiderAttacking = oEnemyToRunFrom
                            if bDebugMessages == true then LOG(sFunctionRef..': Will consider attacking unit as closest dangerous enemy is still a bit from being in our range, iClosestDangerousEnemy='..iClosestDangerousEnemy) end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Do we have a valid enemy unit to run from='..tostring(M28UnitInfo.IsUnitValid(oEnemyToRunFrom))..'; ENemy ID if any='..(oEnemyToRunFrom.UnitId or 'nil')..'; oEnemyToConsiderAttacking='..(oEnemyToConsiderAttacking.UnitId or 'nil')..'; iClosestDangerousEnemy='..iClosestDangerousEnemy) end
                end
                if oEnemyToConsiderAttacking and M28UnitInfo.IsUnitValid(oEnemyToConsiderAttacking) then
                    tLZTeamData[M28Map.refbWantLandScout] = false
                    if bDebugMessages == true then LOG(sFunctionRef..': Have an enemy to attack with combat scout, oEnemyToConsiderAttacking='..oEnemyToConsiderAttacking.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToConsiderAttacking)) end
                    if M28Utilities.GetDistanceBetweenPositions(oEnemyToConsiderAttacking:GetPosition(), oScout:GetPosition()) >= 9 then
                        M28Orders.IssueTrackedAttackMove(oScout, oEnemyToConsiderAttacking:GetPosition(), 4, false, 'SelSA', false)
                    else
                        --Are too close so run away temporarily
                        RunFromEnemy(oScout, oEnemyToConsiderAttacking, iTeam, iPlateau, 16)
                    end
                    oPrevEnemyToRunFrom = nil --DOnt want to bypass checking enemy units incase there is a threatening one nearby
                elseif oEnemyToRunFrom then
                    tLZTeamData[M28Map.refbWantLandScout] = false
                    if bDebugMessages == true then LOG(sFunctionRef..': Want scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..' to run from oEnemyToRunFrom '..oEnemyToRunFrom.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToRunFrom)..' unless iti s a combat scout vs an engineer/mex in a low threat LZ in which case want it to attack the unit; LZ combat total='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Scout DF range='..(oScout[M28UnitInfo.refiDFRange] or 'nil')..'; Do we have a combat scout='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryCombatScout, oScout.UnitId))..'; Distance to nearest enemy='..M28Utilities.GetDistanceBetweenPositions(oEnemyToRunFrom:GetPosition(), oScout:GetPosition())..'; bStandAlmostStill='..tostring(bStandAlmostStill)) end
                    oPrevEnemyToRunFrom = oEnemyToRunFrom
                    if bStandAlmostStill then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and run from enemy but only a short way as want to almost stand still') end
                        RunFromEnemy(oScout, oEnemyToRunFrom, iTeam, iPlateau, 3)
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and run from the nearest enemy') end
                        RunFromEnemy(oScout, oEnemyToRunFrom, iTeam, iPlateau, 16)
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': No nearby enemy to run from, Considering if scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..' is available; reftiPlateauAndLZToMoveTo='..repru(oScout[reftiPlateauAndLZToMoveTo])) end
                    if oScout[reftiPlateauAndLZToMoveTo] then
                        --Make scout available if its target LZ is this LZ
                        if oScout[reftiPlateauAndLZToMoveTo][2] == iLandZone and oScout[reftiPlateauAndLZToMoveTo][1] == iPlateau then
                            --Clear this unit from list of traveling units, but dont make it available as want a slight delay, so want it to be available on the next cycle
                            if bDebugMessages == true then LOG(sFunctionRef..': Scout is traveling to this land zone and is here so will clear the trackers so next cycle it is shown as available') end
                            RemoveUnitFromListOfUnitsTravelingToLandZone(oScout)
                            tLZTeamData[M28Map.refbWantLandScout] = false
                        else
                            --Scout should be traveling to another land zone - if it has no orders then refresh them
                            if bDebugMessages == true then LOG(sFunctionRef..': Scout should travel to another land zone so order it to travel there') end
                            M28Orders.IssueTrackedMove(oScout, M28Map.tAllPlateaus[oScout[reftiPlateauAndLZToMoveTo][1]][M28Map.subrefPlateauLandZones][oScout[reftiPlateauAndLZToMoveTo][2]][M28Map.subrefMidpoint], 6, false, 'TLZ'..oScout[reftiPlateauAndLZToMoveTo][2])
                        end
                    elseif oScout[M28Navy.refiWZToMoveTo] then
                        --Scout should be traveling to another water zone - if it has no orders then refresh them
                        M28Orders.IssueTrackedMove(oScout, M28Map.tPondDetails[M28Map.tiPondByWaterZone[oScout[M28Navy.refiWZToMoveTo]]][M28Map.subrefPondWaterZones][oScout[M28Navy.refiWZToMoveTo]][M28Map.subrefMidpoint], 6, false, 'TWZ'..oScout[M28Navy.refiWZToMoveTo])
                        if bDebugMessages == true then LOG(sFunctionRef..': Scout should travel to a water zone '..oScout[M28Navy.refiWZToMoveTo]..' so will resend the order to ensure it is still moving there') end
                    else
                        --Scout has no nearby enemies to run from, and isnt traveling to a plateau, so it should be available for use
                        if bDebugMessages == true then LOG(sFunctionRef..': Dont want to run or attack with scout and it isnt already assigned to another LZ so will aadd to table of available scouts, oScout='..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)) end
                        table.insert(tAvailableScouts, oScout)
                    end
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Is available scout table empty='..tostring(M28Utilities.IsTableEmpty(tAvailableScouts))) end

        if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
            --First assign any available scouts to adjacent land zones wanting scouts
            if bDebugMessages == true then LOG(sFunctionRef..': Will first allocate scouts to any adjacent land zones that want a scout. Is table of adj zones empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]))) end
            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
                local bDontCheckInPlayableArea = not(M28Map.bIsCampaignMap)
                for _, iAdjLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Consideri niAdjLZ='..iAdjLZ..'; Does this LZ want land scout='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.refbWantLandScout] or false)..'; Is table of traveling scouts here empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTScoutsTravelingHere]))) end
                    local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                    if tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refbWantLandScout] and (bDontCheckInPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint])) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will send land scout '..tAvailableScouts[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tAvailableScouts[1])..' to go to adjacent land zone '..iAdjLZ..' in plateau '..iPlateau) end
                        if not(tAdjLZData[M28Map.subrefbPacifistArea]) then

                            GetUnitToTravelToLandZone(tAvailableScouts[1], iPlateau, iAdjLZ, M28Map.subrefTScoutsTravelingHere)
                            tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refbWantLandScout] = false
                            table.remove(tAvailableScouts, 1)
                            if M28Utilities.IsTableEmpty(tAvailableScouts) then break end
                        end
                    end
                end

            end
            --Now assign any remaining available scouts to adjacent water zones wanting scouts (if any)
            if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                    local tAmphibiousOrHoverScouts = EntityCategoryFilterDown(categories.AMPHIBIOUS + categories.HOVER, tAvailableScouts)
                    if M28Utilities.IsTableEmpty(tAmphibiousOrHoverScouts) == false then
                        local iPond, iAdjWZ
                        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                            iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                            iPond = M28Map.tiPondByWaterZone[iAdjWZ]
                            local tAdjWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
                            if tAdjWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refbWantLandScout] then
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering tAmphibiousOrHoverScouts, size of table='..table.getn(tAmphibiousOrHoverScouts)) end
                                M28Navy.GetUnitToTravelToWaterZone(tAmphibiousOrHoverScouts[1], iPond, iAdjWZ, M28Map.subrefTScoutsTravelingHere)
                                M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.refbWantLandScout] = false
                                local iAvailableScoutRef
                                for iUnit, oUnit in tAvailableScouts do
                                    if oUnit == tAmphibiousOrHoverScouts[1] then
                                        iAvailableScoutRef = iUnit
                                        break
                                    end
                                end
                                table.remove(tAmphibiousOrHoverScouts, 1)
                                if iAvailableScoutRef then
                                    table.remove(tAvailableScouts, iAvailableScoutRef)
                                end
                                if M28Utilities.IsTableEmpty(tAmphibiousOrHoverScouts) then
                                    break
                                end
                            end
                        end
                    end
                end

                if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
                    tLZTeamData[M28Map.refbWantLandScout] = false
                    --If we are here then we still have available land scouts; if we have ap atrol path then patrol; if we have a mex then go here, if we have an adjcent zone go here, otherwise move randomly if we have no orders
                    for iScout, oScout in tAvailableScouts do
                        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subreftPatrolPath]) == false then
                            --Patrol the land zone
                            M28Orders.PatrolPath(oScout, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subreftPatrolPath], false, 'SP')
                        else
                            --Do nothing if scout is moving as maybe it landed on a segment just out of the zone it shoudl have been in
                            if not(oScout:IsUnitState('Moving')) then
                                M28Orders.UpdateRecordedOrders(oScout)
                                if (oScout[M28Orders.refiOrderCount] or 0) == 0 then
                                    --Want ot get somewhere to move to as a backup
                                    if tLZData[M28Map.subrefLZMexCount] > 0 then
                                        M28Orders.IssueTrackedMove(oScout, tLZData[M28Map.subrefMidpoint], 5, false, 'BackupMid')
                                    else
                                        --Do we have an adjacent LZ? If so move here
                                        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
                                            GetUnitToTravelToLandZone(tAvailableScouts[1], iPlateau, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones][1], M28Map.subrefTScoutsTravelingHere)
                                        else
                                            --No adjacent LZs, and no mexes in this LZ, so just move randomly
                                            M28Orders.IssueTrackedMove(oScout, M28Utilities.MoveInDirection(oScout:GetPosition(), math.random(1, 360), math.random(10, 30), true, false, true), 5, false, 'BackupRnd')
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateBestEnemyRangesForThisLandZone(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateBestEnemyRangesForThisLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Update best range values for enemies and allies
    local iEnemyBestMobileDFRange = 0
    local iEnemyBestStructureDFRange = 0
    local iEnemyBestMobileIndirectRange = 0

    --First get range for this land zone
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) == false then
        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] do
            if iThreat > 20 then iEnemyBestMobileDFRange = math.max(iRange, iEnemyBestMobileDFRange) end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]='..repru(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange])..'; iEnemyBestMobileDFRange='..iEnemyBestMobileDFRange..'; Is table of enemy structure DF by range empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
            if iThreat > 20 then iEnemyBestStructureDFRange = math.max(iRange, iEnemyBestStructureDFRange) end
            if bDebugMessages == true then LOG(sFunctionRef..': iRange='..iRange..'; iThreat='..iThreat..'; iEnemyBestStructureDFRange after update='..iEnemyBestStructureDFRange) end
        end
    end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange]) == false then
        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] do
            if iThreat > 20 then iEnemyBestMobileIndirectRange = math.max(iRange, iEnemyBestMobileIndirectRange) end
        end
    end
    tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] = iEnemyBestMobileDFRange
    tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] = iEnemyBestStructureDFRange
    tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] = iEnemyBestMobileIndirectRange
    if bDebugMessages == true then LOG(sFunctionRef..': End of code for iLandZone '..iLandZone..'; tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]='..tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordClosestAdjacentEnemiesAndGetBestEnemyRange(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordClosestAdjacentEnemiesAndGetBestEnemyRange'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    tLZTeamData[M28Map.reftoNearestDFEnemies] = {}
    tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere] = nil
    local iEnemyBestMobileDFRange = 0
    local iEnemyBestStructureDFRange = 0
    local iEnemyBestMobileIndirectRange = 0
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iTeam='..iTeam..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Enemies in this or adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
    if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] then
        local tNearestCombatEnemies = {}
        iEnemyBestMobileDFRange = (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0)
        iEnemyBestStructureDFRange = (tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0)
        iEnemyBestMobileIndirectRange = (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0)

        --Adjust the ranges to factor in adjacent land zones
        local iLowestDistUntilInRange = 10000
        local oLowestDFDistUntilInRange
        local tMidpoint = tLZData[M28Map.subrefMidpoint]
        local iCurDistUntilInRange
        if bDebugMessages == true then LOG(sFunctionRef..': Best mobile DF range for this zone only='..tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]..'; Mobile structure range='..tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange]..'; Mobile indirect='..tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange]..'; Is table of adjacent LZs empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]))) end
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for iEntry, iAdjLandZone in tLZData[M28Map.subrefLZAdjacentLandZones] do
                iLowestDistUntilInRange = 10000
                oLowestDFDistUntilInRange = nil
                local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLandZone][M28Map.subrefLZTeamData][iTeam]

                iEnemyBestMobileDFRange = math.max(iEnemyBestMobileDFRange, tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange])
                iEnemyBestStructureDFRange = math.max(iEnemyBestStructureDFRange, tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange])
                iEnemyBestMobileIndirectRange = math.max(iEnemyBestMobileIndirectRange, tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange])
                if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent LZ '..iAdjLandZone..'; Enemy mobile DF for this LZ='..tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]..'; Mobile structure range='..tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange]..'; Mobile indirect='..tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange]) end
                if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subrefTEnemyUnits]) == false and tAltLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 10 then
                    for iUnit, oUnit in tAltLZTeamData[M28Map.subrefTEnemyUnits] do
                        if M28UnitInfo.IsUnitValid(oUnit) and oUnit[M28UnitInfo.refiDFRange] > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) then
                            iCurDistUntilInRange = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tMidpoint) - oUnit[M28UnitInfo.refiDFRange]
                            if iCurDistUntilInRange < iLowestDistUntilInRange then
                                oLowestDFDistUntilInRange = oUnit
                                iLowestDistUntilInRange = iCurDistUntilInRange
                            end
                        end
                    end
                end
                if oLowestDFDistUntilInRange  then
                    table.insert(tLZTeamData[M28Map.reftoNearestDFEnemies], oLowestDFDistUntilInRange)
                end
            end
        end

        --Factor in adjacent water zones
        if bDebugMessages == true then LOG(sFunctionRef..': Is tLZData[M28Map.subrefAdjacentWaterZones] empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
        if tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
            local iAdjWZ, iPond
            for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                iPond = M28Map.tiPondByWaterZone[iAdjWZ]
                local tWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjWZ='..iAdjWZ..' for iPond='..iPond..'; Enemy Combat total='..(tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)..'; Is Nearest combat enemies empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]))) end
                if (tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 20 and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]) == false then
                    iEnemyBestMobileDFRange = math.max(iEnemyBestMobileDFRange, (tWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0))
                    iLowestDistUntilInRange = 10000
                    oLowestDFDistUntilInRange = nil

                    for iUnit, oUnit in tWZTeamData[M28Map.reftoNearestCombatEnemies] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0)) end
                        if M28UnitInfo.IsUnitValid(oUnit) and (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then
                            iCurDistUntilInRange = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tMidpoint) - oUnit[M28UnitInfo.refiDFRange]
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurDistUntilInRange='..iCurDistUntilInRange) end
                            if iCurDistUntilInRange < iLowestDistUntilInRange then
                                oLowestDFDistUntilInRange = oUnit
                                iLowestDistUntilInRange = iCurDistUntilInRange
                            end
                        end
                    end
                    if oLowestDFDistUntilInRange  then
                        table.insert(tLZTeamData[M28Map.reftoNearestDFEnemies], oLowestDFDistUntilInRange)
                    end
                end
            end
        end

        --Add all units from this zone into reftoNearestDFEnemies
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] then
            for iUnit, oUnit in tLZTeamData[M28Map.subrefTEnemyUnits] do
                if oUnit[M28UnitInfo.refiDFRange] > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) then
                    table.insert(tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit)
                end
            end
        end
    end

    --Record nearest enemy structure if this land zone is large enough and has no enemies (for performance reasons - dont want to risk doing this calculation on tiny zones/mini plateaus near an enemy base), and currently planned use is only for indirect fire units as a backup target
    if bDebugMessages == true then LOG(sFunctionRef..': Will check for nearby enemy structures if no enemies in this LZ, iPlateau='..iPlateau..'; iLandZOne='..iLandZone..'; Enemies in this or adj LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Total segment count='..tLZData[M28Map.subrefLZTotalSegmentCount]..'; Segment size='..M28Map.iLandZoneSegmentSize..'; is table of other land and water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]))) end
    if not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and tLZData[M28Map.subrefLZTotalSegmentCount] >= 150 / M28Map.iLandZoneSegmentSize then
        M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint])
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
            local iClosestEnemyDist = 10000
            local oClosestEnemy
            local iCurDist
            for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateauOrPond='..tSubtable[M28Map.subrefiPlateauOrPond]..'; Is water zone='..tostring(tSubtable[M28Map.subrefbIsWaterZone])..'; Distance='..tSubtable[M28Map.subrefiDistance]..'; iEntry='..iEntry) end
                if tSubtable[M28Map.subrefiDistance] >= 170 and (iEntry >= 7 or tSubtable[M28Map.subrefiDistance] >= 320) then break end
                if not(iPlateau == tSubtable[M28Map.subrefiPlateauOrPond]) and not(tSubtable[M28Map.subrefbIsWaterZone]) then
                    --Have a nearby land zone in a different plateau, check if there are enemy units in this LZ and (if so) if any of them are structures
                    local tAdjLZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                    if not(tAdjLZData[M28Map.subrefbPacifistArea]) then
                        local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]))) end
                        if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                            local tEnemyStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tAdjLZTeamData[M28Map.subrefTEnemyUnits])
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy structures empty='..tostring(M28Utilities.IsTableEmpty(tEnemyStructures))) end
                            if M28Utilities.IsTableEmpty(tEnemyStructures) == false then
                                for iUnit, oUnit in tEnemyStructures do
                                    if M28UnitInfo.IsUnitValid(oUnit) then
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit:GetPosition())
                                        if iCurDist <= iClosestEnemyDist then
                                            oClosestEnemy = oUnit
                                            iClosestEnemyDist = iCurDist
                                            if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..iCurDist..'; this is the closest unit for now, will cycle through any remaining') end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for enemy structure in nearby different plateau, oClosestEnemy='..(oClosestEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestEnemy) or 'nli')) end
            tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere] = oClosestEnemy
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iEnemyBestMobileDFRange='..iEnemyBestMobileDFRange..'; iEnemyBestStructureDFRange='..iEnemyBestStructureDFRange..'; iEnemyBestMobileIndirectRange='..iEnemyBestMobileIndirectRange) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iEnemyBestMobileDFRange, iEnemyBestStructureDFRange, iEnemyBestMobileIndirectRange
end

function ReviseTargetLZIfFarAway(tLZData, iTeam, iPlateau, iStartLandZone, iTargetLandZone, iMaxLZTowardsRally)
    --If we want to move to a rally point but it is more than iMaxLZTowardsRally land zones away, then go to the iMaxLZTowardsRally'th entry
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReviseTargetLZIfFarAway'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iNewTargetLZ = iTargetLandZone
    if not(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]) then
        M28Map.ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iPlateau, iStartLandZone, iTargetLandZone, tLZData[M28Map.subrefMidpoint])
    end
    if iMaxLZTowardsRally and tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone] then
        if bDebugMessages == true then LOG(sFunctionRef..': WIll consider changing to the '..iMaxLZTowardsRally..' entry along the path; repru of the path='..repru(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath])..'; Position in the path='..tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]) end
        --Change closest LZ to run to to be 2 along the path from cur LZ to the target LZ
        for iEntry, iLZPointInPath in tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath] do
            if iEntry >= iMaxLZTowardsRally then
                if bDebugMessages == true then LOG(sFunctionRef..': Were going to move to iTargetLandZone='..iTargetLandZone..' from LZ'..iStartLandZone..' but it is at least iMaxLZTowardsRally='..iMaxLZTowardsRally..' LZ away so will move to iEntry LZ which is '..iLZPointInPath..'; Total paht size='..table.getn(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath])) end
                iNewTargetLZ = iLZPointInPath
                break
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iNewTargetLZ
end

function GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, iMaxLZTowardsRally, bAmphibiousPathing)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNearestLandRallyPoint'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Gets the location of the nearest rally point; if bAmphibiousPathing is true then will consider other islands, otherwise will only consider current island


    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau]) == false then
        local iCurDist
        local iClosestDist = 100000
        local iClosestLZRef
        local iBaseIsland = tLZData[M28Map.subrefLZIslandRef]
        local iClosestAmphibDist = 100000
        local iClosestAmphibLZRef

        if bDebugMessages == true then LOG(sFunctionRef..': have potential land zones to consider for plateau '..iPlateau..'; bAmphibiousPathing='..tostring(bAmphibiousPathing or false)) end
        for iEntry, iAltLZ in M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau] do
            if bDebugMessages == true then LOG(sFunctionRef..': Looking for rally point for iPlateau '..iPlateau..'; iLandZone '..iLandZone..'; Considering iAltLZ='..iAltLZ..'; Travel distance to here='..(M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iAltLZ) or 'nil')) end
            if iAltLZ == iLandZone then
                iClosestLZRef = iAltLZ
                break
            else
                if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAltLZ][M28Map.subrefLZIslandRef] == iBaseIsland then
                    iCurDist = (M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iAltLZ) or iClosestDist + 1)  --M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAltLZ][M28Map.subrefMidpoint], tLZData[M28Map.subrefMidpoint])
                    if iCurDist < iClosestDist then
                        iClosestDist = iCurDist
                        iClosestLZRef = iAltLZ
                        if bDebugMessages == true then LOG(sFunctionRef..': Have a new closestLZRef that is on same island, iBaseIsland='..iBaseIsland..'; iClosestLZRef='..iClosestLZRef..'; iClosestDist='..iClosestDist) end
                    end
                elseif bAmphibiousPathing and not(iClosestLZRef) then
                    iCurDist = M28Utilities.GetDistanceBetweenPositions( M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAltLZ][M28Map.subrefMidpoint], tLZData[M28Map.subrefMidpoint])
                    if iCurDist < iClosestAmphibDist then
                        iClosestAmphibDist = iCurDist
                        iClosestAmphibLZRef = iAltLZ
                        if bDebugMessages == true then LOG(sFunctionRef..': Have a new closetsAmphibLZRef, iClosestAmphibDist='..iClosestAmphibDist..'; iClosestAmphibLZRef='..iClosestAmphibLZRef) end
                    end
                end
            end
        end
        if not(iClosestLZRef) then
            if bAmphibiousPathing and iClosestAmphibLZRef then iClosestLZRef = iClosestAmphibLZRef
            else
                iClosestLZRef = iLandZone
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Dont have iClosestLZRef, bAmphibiousPathing='..tostring(bAmphibiousPathing or false)..'; iClosestAmphibLZRef='..(iClosestAmphibLZRef or 'nil')..'; iClosestLZRef after updating for amphibious or setting to cur land zone='..iClosestLZRef) end
        else
            iClosestAmphibLZRef = nil
        end
        if iClosestLZRef == iLandZone then
            --Do nothing - wont find a closer one
        else
            --Do we have a path to this rally point from the current land zone? If so move 2 along the path
            if iClosestAmphibLZRef then
                --Do nothign - will just want to go straight to the amphibious LZ
            else
                if not(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef]) then
                    M28Map.ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iPlateau, iLandZone, iClosestLZRef, tLZData[M28Map.subrefMidpoint])
                    if not(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef]) then
                        M28Utilities.ErrorHandler('Dont have pathing recorded for iClosetsLZRef='..iClosestLZRef..'; iPlateau='..iPlateau..'; iBaesLZ='..iLandZone..'; iClosestLZRef='..iClosestLZRef..' even after checking to update pathing, if logs are enabled will draw midpoint of LZ')
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint])..'; subrefLZTotalSegmentCount for closest LZref='..(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef][M28Map.subrefLZTotalSegmentCount] or 'nil')..'; Will draw midpoint in red, and hten draw the base LZ in gold and the closest LZ in cyan')
                            M28Utilities.DrawLocation(tLZData[M28Map.subrefMidpoint], 2, 200)
                            M28Map.DrawSpecificLandZone(iPlateau, iLandZone, 4)
                            M28Map.DrawSpecificLandZone(iPlateau, iClosestLZRef, 6)
                        end
                    end
                end
                if iMaxLZTowardsRally and tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef] then
                    if bDebugMessages == true then LOG(sFunctionRef..': WIll consider changing to the '..iMaxLZTowardsRally..' entry along the path; repru of the path='..repru(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef]][M28Map.subrefLZPath])..'; Position in the path='..tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef]..'; tLZData[M28Map.subrefLZPathingToOtherLZEntryRef]='..repru(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef])..'; iClosestLZRef='..iClosestLZRef..'; Full listing of repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones]='..repru(repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZPathingToOtherLandZones]))) end
                    --Change closest LZ to run to to be 2 along the path from cur LZ to the target LZ
                    for iEntry, iLZPointInPath in tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef]][M28Map.subrefLZPath] do
                        if iEntry >= iMaxLZTowardsRally then
                            if bDebugMessages == true then LOG(sFunctionRef..': iEntry='..iEntry..'; iMaxLZTowardsRally='..iMaxLZTowardsRally..'; iLZPointInPath='..iLZPointInPath) end
                            iClosestLZRef = iLZPointInPath
                            break
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iMaxLZTowardsRally='..(iMaxLZTowardsRally or 'nil')..'; iClosestLZRef='..iClosestLZRef) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return {M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef][M28Map.subrefMidpoint][1], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef][M28Map.subrefMidpoint][2], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef][M28Map.subrefMidpoint][3]}
    else
        M28Utilities.ErrorHandler('No rally point for P'..(iPlateau or 'nil')..' LZ'..(iLandZone or 'nil')..'; will return current midpoint')
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return {tLZData[M28Map.subrefMidpoint][1], tLZData[M28Map.subrefMidpoint][2], tLZData[M28Map.subrefMidpoint][3]}
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshLandRallyPoints(iTeam)
    --For now just has core bases and core expansion points as rally points, may adjust htis in the future
    M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau] = {}
    for iPlateau, tPlateauSubtable in M28Map.tAllPlateaus do
        M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau] = {}
        for iLandZone, tLandZoneInfo in tPlateauSubtable[M28Map.subrefPlateauLandZones] do
            if tLandZoneInfo[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] or tLandZoneInfo[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZCoreExpansion] then
                table.insert(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau], iLandZone)
            end
        end
    end
end

function SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, iLZOrWZToSupport, iMAAFactorAdjust, bWaterZone, tHoverMAAToAdvance)
    --Assigns MAA to the land zone up to the level at which the LZ doesnt want more MAA support, but increases the MAA wanted by the land zone by iMAAFactorAdjust (or 1 if not specified)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SendMAAToSupportLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tAltLZOrWZData
    local tAltTeamLZOrWZData
    local tTargetPosition
    local iPond
    local iMAAThreatWanted, iAllyGroundAA
    if bWaterZone then
        iPond = M28Map.tiPondByWaterZone[iLZOrWZToSupport]
        tAltLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iLZOrWZToSupport]
        tAltTeamLZOrWZData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
        tTargetPosition = tAltLZOrWZData[M28Map.subrefMidpoint]
        iMAAThreatWanted = tAltTeamLZOrWZData[M28Map.subrefWZMAAThreatWanted]
        iAllyGroundAA = tAltTeamLZOrWZData[M28Map.subrefWZThreatAlliedAA]
    else
        tAltLZOrWZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZOrWZToSupport]
        tAltTeamLZOrWZData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
        tTargetPosition = tAltLZOrWZData[M28Map.subrefMidpoint]
        iMAAThreatWanted = tAltTeamLZOrWZData[M28Map.subrefLZMAAThreatWanted]
        iAllyGroundAA = tAltTeamLZOrWZData[M28Map.subrefLZThreatAllyGroundAA]
    end

    local tDistToTargetByRef = {}
    if not(iMAAThreatWanted) or not(iAllyGroundAA) then
        M28Utilities.ErrorHandler('Have nil MAA or AllyGroundAA threat for iLZOrWZToSupport='..(iLZOrWZToSupport or 'nil')..'; see log for more info')
        LOG(sFunctionRef..': MAA iTeam='..(iTeam or 'nil')..'; iPlateau='..(iPlateau or 'nil')..'; iLZOrWZToSupport='..(iLZOrWZToSupport or 'nil')..'; tAltTeamLZOrWZData[M28Map.subrefLZMAAThreatWanted]='..(tAltTeamLZOrWZData[M28Map.subrefLZMAAThreatWanted] or 'nil')..'; tAltTeamLZOrWZData[M28Map.subrefLZThreatAllyGroundAA]='..(tAltTeamLZOrWZData[M28Map.subrefLZThreatAllyGroundAA] or 'nil')..'; reprs of teamLZData='..reprs(tAltTeamLZOrWZData))
    else
        iMAAThreatWanted = iMAAThreatWanted * (iMAAFactorAdjust or 1) - iAllyGroundAA

        for iUnit, oUnit in (tHoverMAAToAdvance or tMAAToAdvance) do
            tDistToTargetByRef[iUnit] = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetPosition)
        end
        local tbRemovedMAAReferencesByRef = {}
        for iUnitRef, iDistance in M28Utilities.SortTableByValue(tDistToTargetByRef, false) do
            if bDebugMessages == true then LOG(sFunctionRef..': About to issue order to move for iUnitRef='..iUnitRef..'; tMAAToAdvance[iUnitRef]='..(tMAAToAdvance[iUnitRef].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tMAAToAdvance[iUnitRef]) or 'nil')..' to go to tTargetPosition='..repru(tTargetPosition)) end
            M28Orders.IssueTrackedMove(tMAAToAdvance[iUnitRef], tTargetPosition, 10, false, 'MVELZ'..iLZOrWZToSupport)
            iMAAThreatWanted = iMAAThreatWanted - M28UnitInfo.GetAirThreatLevel({ tMAAToAdvance[iUnitRef] }, false, false, true, false, false, false)
            tbRemovedMAAReferencesByRef[iUnitRef] = true
            if iMAAThreatWanted < 0 then break end
        end
        if M28Utilities.IsTableEmpty(tbRemovedMAAReferencesByRef) == false then
            --Remove any MAA that have given orders from tMAAToAdvance:
            if M28Utilities.IsTableEmpty(tHoverMAAToAdvance) then
                local iRevisedIndex = 1
                local iTableSize = table.getn(tMAAToAdvance)

                for iOrigIndex=1, iTableSize do
                    if tMAAToAdvance[iOrigIndex] then
                        if not(tbRemovedMAAReferencesByRef[iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                            --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                            if (iOrigIndex ~= iRevisedIndex) then
                                tMAAToAdvance[iRevisedIndex] = tMAAToAdvance[iOrigIndex];
                                tMAAToAdvance[iOrigIndex] = nil;
                            end
                            iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                        else
                            tMAAToAdvance[iOrigIndex] = nil;
                        end
                    end
                end
            else
                --Need to remove from both the hover MAA table, and the main MAA table
                local iRevisedIndex = 1
                local iTableSize = table.getn(tHoverMAAToAdvance)


                for iOrigIndex=1, iTableSize do
                    if tHoverMAAToAdvance[iOrigIndex] then
                        if not(tbRemovedMAAReferencesByRef[iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                            --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                            if (iOrigIndex ~= iRevisedIndex) then
                                tHoverMAAToAdvance[iRevisedIndex] = tHoverMAAToAdvance[iOrigIndex];
                                tHoverMAAToAdvance[iOrigIndex] = nil;
                            end
                            iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                        else
                            --Want to remove the unit - also remove from the original MAA table
                            for iUnit, oUnit in tMAAToAdvance do
                                if oUnit == tHoverMAAToAdvance[iOrigIndex] then
                                    table.remove(tMAAToAdvance, iUnit)
                                    break
                                end
                            end
                            tHoverMAAToAdvance[iOrigIndex] = nil;
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function StealthUnitsInLandZone(tTeamTargetLZData, tStealthsToAssign, bAssignAllStealths)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'StealthUnitsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --local tTargetLandZone = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][iTeam]
    local bNoUnitsWantingStealthing = true
    if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileStealth]) then
        M28Utilities.ErrorHandler('Are trying to send mobile Stealths to support a land zone that has no allied combat units in it and no units wanting Stealthing')
    else
        if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileStealth]) == false then
            for iTarget, oTarget in tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileStealth] do
                if not(oTarget[refoAssignedMobileStealth]) then
                    if M28Utilities.IsTableEmpty(tStealthsToAssign) then
                        bNoUnitsWantingStealthing = false
                        break
                    else
                        --Assign the closest mobile Stealth
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iStealth, oStealth in tStealthsToAssign do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iStealth='..iStealth..'; Stealth unit='..oStealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth)) end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oStealth:GetPosition(), oTarget:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iStealth
                            end
                            break
                        end
                        tStealthsToAssign[iClosestRef][refoMobileStealthTarget] = oTarget
                        oTarget[refoAssignedMobileStealth] = tStealthsToAssign[iClosestRef]
                        MoveToStealthTarget(tStealthsToAssign[iClosestRef], tTeamTargetLZData[M28Map.reftClosestEnemyBase])
                        table.remove(tStealthsToAssign, iClosestRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have just removed Stealth with iClosestRef='..iClosestRef..' from the table of tStealthsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; size of table='..table.getn(tStealthsToAssign)) end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tStealthsToAssign) == false and bAssignAllStealths then
            bNoUnitsWantingStealthing = true
            --No units that want Stealthing - e.g. we might be telling mobile Stealths to defend here temporarily; dont assign the Stealths, instead just give them orders so they are still of some use
            if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) == false then
                for iTarget, oTarget in tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits] do
                    if not(oTarget[refoAssignedMobileStealth]) then --redundancy
                        --Assign the closest mobile Stealth
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iStealth, oStealth in tStealthsToAssign do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iStealth='..iStealth..'; Stealth unit='..oStealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth)) end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oStealth:GetPosition(), oTarget:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iStealth
                            end
                            break
                        end
                        --Dont record the Stealth as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoStealthtarget works
                        tStealthsToAssign[iClosestRef][refoMobileStealthTarget] = oTarget
                        MoveToStealthTarget(tStealthsToAssign[iClosestRef], tTeamTargetLZData[M28Map.reftClosestEnemyBase])
                        tStealthsToAssign[iClosestRef][refoMobileStealthTarget] = nil
                        table.remove(tStealthsToAssign, iClosestRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Backup Stealth assignment - Have removed Stealth with iClosestRef='..iClosestRef..' from the table of tStealthsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; size of table='..table.getn(tStealthsToAssign)) end
                        if M28Utilities.IsTableEmpty(tStealthsToAssign) then break end
                    end
                end

                --Do we still have spare mobile Stealths?
                if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                    --Get closest unit to enemy base and assign all remaining Stealths temporarily here
                    local iCurDist
                    local iClosestDist = 100000
                    local oClosestToEnemyBase

                    for iTarget, oTarget in tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits] do
                        if M28UnitInfo.IsUnitValid(oTarget) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), tTeamTargetLZData[M28Map.reftClosestEnemyBase])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oClosestToEnemyBase = oTarget
                            end
                        end
                    end
                    if oClosestToEnemyBase then
                        local tEnemyBase = tTeamTargetLZData[M28Map.reftClosestEnemyBase]
                        for iStealth, oStealth in tStealthsToAssign do
                            --Dont record the Stealth as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoStealthtarget works
                            if bDebugMessages == true then LOG(sFunctionRef..': About to tell Stealth '..(oStealth.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oStealth) or 'nil')..' to move towards oClosestToEnemyBase='..(oClosestToEnemyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase) or 'nil')) end
                            oStealth[refoMobileStealthTarget] = oClosestToEnemyBase
                            MoveToStealthTarget(oStealth, tEnemyBase)
                            oStealth[refoMobileStealthTarget] = nil
                            if bDebugMessages == true then LOG(sFunctionRef..': Backup Stealth assignment - have told Stealth '..oStealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth)..' to go to the closest enemy in this LZ to enemy base='..oClosestToEnemyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase)) end
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': No friendly units close to enemy base - assuming this is termpoary due to unit being destroyed')
                    end
                end
            end
        end
    end
    if bNoUnitsWantingStealthing then
        --Flag that this LZ no longer wants mobile Stealths
        tTeamTargetLZData[M28Map.refbLZWantsMobileStealth] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ShieldUnitsInLandZone(tTeamTargetLZData, tShieldsToAssign, bAssignAllShields)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ShieldUnitsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --local tTargetLandZone = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][iTeam]
    local bNoUnitsWantingShielding = true
    if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]) and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefAlliedACU]) then
        M28Utilities.ErrorHandler('Are trying to send mobile shields to support a land zone that has no allied combat units in it and no units wanting shielding')
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of units wanting mobile shield empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]))) end
        if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]) == false then
            --Prioritise t2 arti if have enemy t2 arti in zone
            function AssignClosestMobileShieldToTarget(oTarget)
                --Returns false if should abort
                if not(oTarget[refoAssignedMobileShield]) then
                    if M28Utilities.IsTableEmpty(tShieldsToAssign) then
                        bNoUnitsWantingShielding = false
                        return false
                    else
                        --Assign the closest mobile shield
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iShield, oShield in tShieldsToAssign do
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oTarget:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iShield='..iShield..'; Shield unit='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; iCurDist='..iCurDist..'; iClosestDist='..iClosestDist..'; oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)) end
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iShield
                            end
                        end
                        tShieldsToAssign[iClosestRef][refoMobileShieldTarget] = oTarget
                        oTarget[refoAssignedMobileShield] = tShieldsToAssign[iClosestRef]
                        MoveToShieldTarget(tShieldsToAssign[iClosestRef], tTeamTargetLZData[M28Map.reftClosestEnemyBase])
                        table.remove(tShieldsToAssign, iClosestRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have just removed shield with iClosestRef='..iClosestRef..' from the table of tShieldsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; size of table='..table.getn(tShieldsToAssign)) end
                        return not(M28Utilities.IsTableEmpty(tShieldsToAssign))
                    end
                end
            end
            local tT2ArtiToPrioritise
            if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
                tT2ArtiToPrioritise = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield])
                if M28Utilities.IsTableEmpty(tT2ArtiToPrioritise) == false then
                    for iTarget, oTarget in tT2ArtiToPrioritise do
                        if AssignClosestMobileShieldToTarget(oTarget) == false then break end
                    end
                end
            end

            for iTarget, oTarget in tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield] do
                if AssignClosestMobileShieldToTarget(oTarget) == false then break end
            end
        end
        if (M28Utilities.IsTableEmpty(tShieldsToAssign) == false or M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefAlliedACU]) == false) and bAssignAllShields then
            bNoUnitsWantingShielding = true
            --No units that want shielding - e.g. we might be telling mobile shields to defend here temporarily; dont assign the shields, instead just give them orders so they are still of some use
            local tPotentialShieldTargets = {}
            if tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits] then tPotentialShieldTargets = tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits] end
            if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefAlliedACU]) == false then
                for iACU, oACU in tTeamTargetLZData[M28Map.subrefAlliedACU] do
                    table.insert(tPotentialShieldTargets, oACU)
                end
            end

            if M28Utilities.IsTableEmpty(tPotentialShieldTargets) == false then
                for iTarget, oTarget in tPotentialShieldTargets do
                    if not(oTarget[refoAssignedMobileShield]) then --redundancy
                        --Assign the closest mobile shield
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iShield, oShield in tShieldsToAssign do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iShield='..iShield..'; Shield unit='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)) end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oTarget:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iShield
                            end
                            break
                        end
                        --Dont record the shield as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoshieldtarget works
                        tShieldsToAssign[iClosestRef][refoMobileShieldTarget] = oTarget
                        MoveToShieldTarget(tShieldsToAssign[iClosestRef], tTeamTargetLZData[M28Map.reftClosestEnemyBase])
                        tShieldsToAssign[iClosestRef][refoMobileShieldTarget] = nil
                        table.remove(tShieldsToAssign, iClosestRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Backup shield assignment - Have removed shield with iClosestRef='..iClosestRef..' from the table of tShieldsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; size of table='..table.getn(tShieldsToAssign)) end
                        if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                    end
                end

                --Do we still have spare mobile shields?
                if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                    --Get closest unit to enemy base and assign all remaining shields temporarily here
                    local iCurDist
                    local iClosestDist = 100000
                    local oClosestToEnemyBase

                    for iTarget, oTarget in tPotentialShieldTargets do
                        if M28UnitInfo.IsUnitValid(oTarget) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), tTeamTargetLZData[M28Map.reftClosestEnemyBase])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oClosestToEnemyBase = oTarget
                            end
                        end
                    end
                    if oClosestToEnemyBase then
                        local tEnemyBase = tTeamTargetLZData[M28Map.reftClosestEnemyBase]
                        for iShield, oShield in tShieldsToAssign do
                            --Dont record the shield as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoshieldtarget works
                            if bDebugMessages == true then LOG(sFunctionRef..': About to tell shield '..(oShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oShield) or 'nil')..' to move towards oClosestToEnemyBase='..(oClosestToEnemyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase) or 'nil')) end
                            oShield[refoMobileShieldTarget] = oClosestToEnemyBase
                            MoveToShieldTarget(oShield, tEnemyBase)
                            oShield[refoMobileShieldTarget] = nil
                            if bDebugMessages == true then LOG(sFunctionRef..': Backup shield assignment - have told shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' to go to the closest enemy in this LZ to enemy base='..oClosestToEnemyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase)) end
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': No friendly units close to enemy base - assuming this is termpoary due to unit being destroyed')
                    end
                end
            end
        end
    end
    if bNoUnitsWantingShielding then
        --Flag that this LZ no longer wants mobile shields
        tTeamTargetLZData[M28Map.refbLZWantsMobileShield] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MoveToShieldTarget(oShield, tEnemyBase, tOptionalShieldLZTeamData, tOptionalEnemyDFUnits, tOptionalRallyPoint)
    --If tOptionalShieldLZTeamData is specified, then will check if safe to try and shield the unit

    local bMoveToUnit = true
    if tOptionalShieldLZTeamData and tOptionalEnemyDFUnits and tOptionalRallyPoint and (tOptionalShieldLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) >= 180 then
        local iDistToShieldTarget = M28Utilities.GetDistanceBetweenPositions(oShield[refoMobileShieldTarget]:GetPosition(), oShield:GetPosition())
        if iDistToShieldTarget >= 50 then
            local tShieldTargetLZData, tShieldTargetLZTeamData = M28Map.GetLandOrWaterZoneData(oShield[refoMobileShieldTarget]:GetPosition(), true, oShield:GetAIBrain().M28Team)
            if not(tShieldTargetLZTeamData ==  tOptionalShieldLZTeamData) then
                if M28Utilities.GetDistanceBetweenPositions(oShield[refoMobileShieldTarget]:GetPosition(), tOptionalRallyPoint) >= M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), tOptionalRallyPoint) then
                    --Are we almost in range of an enemy unit in this zone?
                    if M28Utilities.IsTableEmpty(tOptionalEnemyDFUnits) == false then
                        if M28Conditions.CloseToEnemyUnit(oShield:GetPosition(), tOptionalEnemyDFUnits, 5, oShield:GetAIBrain().M28Team, true) then
                            --LOG('MoveToShieldTarget: Shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' is in a dangerous zone and target '..oShield[refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield[refoMobileShieldTarget])..' is far away so will retreat; Does shield have active micro='..tostring(oShield[M28UnitInfo.refbSpecialMicroActive] or false)..'; Closest friendly base='..repru(tOptionalShieldLZTeamData[M28Map.reftClosestFriendlyBase]))
                            --M28Utilities.DrawLocation(oShield:GetPosition())
                            bMoveToUnit = false
                            --IssueTrackedMove(oUnit, tOrderPosition,                       iDistanceToReissueOrder, bAddToExistingQueue, sOptionalOrderDesc,                                                                                       bOverrideMicroOrder)
                            M28Orders.IssueTrackedMove(oShield, tOptionalRallyPoint, 5, false,                'ShBl'..oShield[refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield[refoMobileShieldTarget]), false)
                        end
                    end

                end
            end
        end

    end
    if bMoveToUnit then

        local oBP = oShield:GetBlueprint()
        --Decide whether to move towards the unit's target if the unit is moving (so e.g. if we are retreating we are less likely to block the retreating unit)
        local bGivenOrderForRetreating = false
        local tTargetFirstOrder = oShield[refoMobileShieldTarget][M28Orders.reftiLastOrders][1]
        if tTargetFirstOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueMove then
            local iDistToEnemyBaseFromUnit = M28Utilities.GetDistanceBetweenPositions(oShield[refoMobileShieldTarget]:GetPosition(), tEnemyBase)
            local iDistToEnemyBaseFromMoveTarget = M28Utilities.GetDistanceBetweenPositions(tTargetFirstOrder[M28Orders.subreftOrderPosition], tEnemyBase)
            if iDistToEnemyBaseFromMoveTarget > iDistToEnemyBaseFromUnit then
                --We are likely retreating
                bGivenOrderForRetreating = true
                local iShieldRadius = oBP.Defense.Shield.ShieldSize * 0.5
                local iShieldDistanceWanted = math.max(5, oBP.Defense.Shield.ShieldSize * 0.5)
                local iTargetSpeed = (oShield[refoMobileShieldTarget]:GetBlueprint().Physics.MaxSpeed or 0)
                local iDistWithinShieldAlready = iShieldRadius - M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oShield[refoMobileShieldTarget]:GetPosition())
                if iDistWithinShieldAlready >= 1 or iTargetSpeed + 1 + iDistWithinShieldAlready >= iShieldRadius then --More than 1 inside shield range or are likely to run into shield
                    iShieldDistanceWanted = iShieldDistanceWanted + math.max(iDistWithinShieldAlready, iTargetSpeed)
                end

                M28Orders.IssueTrackedMove(oShield, M28Utilities.MoveInDirection(oShield[refoMobileShieldTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(oShield[refoMobileShieldTarget]:GetPosition(), tTargetFirstOrder[M28Orders.subreftOrderPosition]), iShieldDistanceWanted, true, false, true), math.min(3, iShieldDistanceWanted - 1, iShieldRadius - 1), false, 'ShRU'..oShield[refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield[refoMobileShieldTarget]))
            end
        end
        if not(bGivenOrderForRetreating) then
            local iShieldDistanceWanted = math.max(3, oBP.Defense.Shield.ShieldSize * 0.5 - 1 - oBP.Physics.MaxSpeed - (oShield[refoMobileShieldTarget]:GetBlueprint().Physics.MaxSpeed or 0))
            --if oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield) == 'ual030728' and GetGameTimeSeconds() >= 1740 then M28Utilities.ErrorHandler('Audit trail; iShieldDistanceWanted='..iShieldDistanceWanted..'; Shield position='..repru(oShield:GetPosition())..'; Target position='..repru(oShield[refoMobileShieldTarget]:GetPosition())..'; Target='..oShield[refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield[refoMobileShieldTarget])..'; Is target valid='..tostring(M28UnitInfo.IsUnitValid(oShield[refoMobileShieldTarget]))..'; Angle from enemy base to unit to shield='..M28Utilities.GetAngleFromAToB(tEnemyBase,oShield[refoMobileShieldTarget]:GetPosition())..'; Desired target position='..repru(M28Utilities.MoveInDirection(oShield[refoMobileShieldTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(tEnemyBase,oShield[refoMobileShieldTarget]:GetPosition()), iShieldDistanceWanted, true, false))) end
            M28Orders.IssueTrackedMove(oShield, M28Utilities.MoveInDirection(oShield[refoMobileShieldTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(tEnemyBase,oShield[refoMobileShieldTarget]:GetPosition()), iShieldDistanceWanted, true, false, true), math.min(5, iShieldDistanceWanted - 1), false, 'ShU'..oShield[refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield[refoMobileShieldTarget]))
        end
    end
end

function MoveToStealthTarget(oStealth, tEnemyBase)
    local oBP = oStealth:GetBlueprint()
    local iStealthDistanceWanted = math.max(8, oBP.Intel.RadarStealthFieldRadius - 1 - oBP.Physics.MaxSpeed - (oStealth[refoMobileStealthTarget]:GetBlueprint().Physics.MaxSpeed or 0))
    M28Orders.IssueTrackedMove(oStealth, M28Utilities.MoveInDirection(oStealth[refoMobileStealthTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(tEnemyBase,oStealth[refoMobileStealthTarget]:GetPosition()), iStealthDistanceWanted, true, false, true), math.min(5, iStealthDistanceWanted - 1), false, 'StU'..oStealth[refoMobileStealthTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth[refoMobileStealthTarget]))
end

function ManageMobileShieldsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tMobileShields)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMobileShieldsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Size of tMobileShields='..table.getn(tMobileShields)) end

    local iCurShield, iMaxShield
    local tShieldsToRetreat = {}
    local tShieldsToAssign = {}
    local tEnemyBase = tLZTeamData[M28Map.reftClosestEnemyBase]
    if M28Utilities.IsTableEmpty(tEnemyBase) then
        M28Utilities.ErrorHandler('Couldnt find enemy base, will try backup approach')
        local iCurDist
        local iClosestDist = 100000
        local oClosestBrain
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestBrain = oBrain
            end
        end
        tEnemyBase = M28Map.PlayerStartPoints[oClosestBrain:GetArmyIndex()]
    end
    local tEnemyDFUnits
    local tRallyPoint
    if (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 200 then
        tEnemyDFUnits = EntityCategoryFilterDown(categories.DIRECTFIRE, tLZTeamData[M28Map.subrefTEnemyUnits])
        tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 1, false)
    end

    for iUnit, oUnit in tMobileShields do
        iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, false)
        if bDebugMessages == true then LOG(sFunctionRef..': Considering what to do with unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurShield='..iCurShield..'; iMaxShield='..iMaxShield) end
        if iCurShield < iMaxShield * 0.5 then
            --Retreat
            table.insert(tShieldsToRetreat, oUnit)
        elseif oUnit[refoMobileShieldTarget] and M28UnitInfo.IsUnitValid(oUnit[refoMobileShieldTarget]) then
            --make sure we are behind the target
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and get shield '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to move behind the shield target '..oUnit[refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[refoMobileShieldTarget])..'; Unit position='..repru(oUnit:GetPosition())..'; Target last order position='..repru(oUnit[refoMobileShieldTarget][M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition])) end
            MoveToShieldTarget(oUnit, tEnemyBase, tLZTeamData, tEnemyDFUnits, tRallyPoint)
        else
            table.insert(tShieldsToAssign, oUnit)
        end
    end
    if M28Utilities.IsTableEmpty(tShieldsToRetreat) == false then
        local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2)
        local tAmphibiousRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2, true)
        if bDebugMessages == true then LOG(sFunctionRef..': Will give orders to retreat, size of tShieldsToRetreat='..table.getn(tShieldsToRetreat)) end
        for iUnit, oUnit in tShieldsToRetreat do
            if bDebugMessages == true then
                local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, false)
                LOG(sFunctionRef..': About to tell unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to run due to a low shield. iCurShield='..iCurShield..'; iMaxShield='..iMaxShield)
            end
            if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ASRun'..iLandZone)
            else
                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'SRun'..iLandZone)
            end
        end
    end
    if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
        --Cycle through every land zone and record priority ones to shield
        if bDebugMessages == true then LOG(sFunctionRef..': Will give orders to tShieldsToAssign, size of table='..table.getn(tShieldsToAssign)) end
        local tiClosestLZWithNearbyThreat = {}
        local iClosestLZWithNoThreat
        local iClosestLZNotWantingShieldButWithUnits
        local iClosestLZWithAnyCombatUnits
        local tiAllOtherLZWantingShields = {}
        if tLZTeamData[M28Map.subrefbLZWantsSupport] and not(tLZTeamData[M28Map.refbLZWantsMobileShield]) and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedCombatUnits]) == false or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false) then iClosestLZNotWantingShieldButWithUnits = iLandZone end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
            for iEntry, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': iLandZone='..iLandZone..'; Considering other land zone '..tPathingDetails[M28Map.subrefLZNumber]..'; Other land zone DF threat='..(tTeamTargetLZData[M28Map.subrefLZThreatAllyMobileDFTotal] or 'nil')..'; Does this zone want mobile shields='..tostring(tTeamTargetLZData[M28Map.refbLZWantsMobileShield] or false)) end
                if tTeamTargetLZData[M28Map.refbLZWantsMobileShield] then
                    if tTeamTargetLZData[M28Map.refiEnemyAirToGroundThreat] > 0 or tTeamTargetLZData[M28Map.subrefTThreatEnemyCombatTotal] >= 40 then
                        ShieldUnitsInLandZone(tTeamTargetLZData, tShieldsToAssign)
                        if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                    else
                        if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefTEnemyUnits]) == false or tTeamTargetLZData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                            table.insert(tiClosestLZWithNearbyThreat, tPathingDetails[M28Map.subrefLZNumber])
                        else
                            table.insert(tiAllOtherLZWantingShields, tPathingDetails[M28Map.subrefLZNumber])
                            if not(iClosestLZWithNoThreat) then iClosestLZWithNoThreat = tPathingDetails[M28Map.subrefLZNumber] end
                        end
                    end
                elseif not(iClosestLZNotWantingShieldButWithUnits) then
                    if tTeamTargetLZData[M28Map.subrefbLZWantsSupport] and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) == false then
                        iClosestLZNotWantingShieldButWithUnits = tPathingDetails[M28Map.subrefLZNumber]
                    end
                    if not(iClosestLZWithAnyCombatUnits) and (M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) == false or M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefAlliedACU]) == false) then
                        iClosestLZWithAnyCombatUnits = tPathingDetails[M28Map.subrefLZNumber]
                    end
                end

            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished checking other zones we can path to for units wanting shielding, is tShieldsToAssign empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; Is M28Utilities.IsTableEmpty(tiClosestLZWithNearbyThreat) empty='..tostring(M28Utilities.IsTableEmpty(tiClosestLZWithNearbyThreat))) end
        if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
            if M28Utilities.IsTableEmpty(tiClosestLZWithNearbyThreat) == false then
                for _, iTargetLZ in  tiClosestLZWithNearbyThreat do
                    local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLZ][M28Map.subrefLZTeamData][iTeam]
                    ShieldUnitsInLandZone(tTeamTargetLZData, tShieldsToAssign)
                    if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                end
            end
            if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                if iClosestLZWithNoThreat then
                    local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZWithNoThreat][M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Have mobile shields to assign, closest LZ='..iClosestLZWithNoThreat..'; DOes this LZ want mobile shields='..tostring(tTeamTargetLZData[M28Map.refbLZWantsMobileShield] or false)..'; is table of units wanting shielding empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]))) end
                    ShieldUnitsInLandZone(tTeamTargetLZData, tShieldsToAssign)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Is tShieldsToAssign empty after checking for closest LZ with no threat='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; iClosestLZNotWantingShieldButWithUnits='..(iClosestLZNotWantingShieldButWithUnits or 'nil')) end
                if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                    if M28Utilities.IsTableEmpty(tiAllOtherLZWantingShields) == false then
                        for iEntry, iZone in tiAllOtherLZWantingShields do
                            if not(iZone ==iClosestLZWithNoThreat) then
                                local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZWithNoThreat][M28Map.subrefLZTeamData][iTeam]
                                if bDebugMessages == true then LOG(sFunctionRef..': Have mobile shields to assign, considering zone that wants shielding, iZone='..iZone..'; DOes this LZ want mobile shields='..tostring(tTeamTargetLZData[M28Map.refbLZWantsMobileShield] or false)..'; is table of units wanting shielding empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]))) end
                                ShieldUnitsInLandZone(tTeamTargetLZData, tShieldsToAssign)
                                if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': Still have shields to assign after considering all zones with adjacent enemy threats, so will flag that we failed to have shield targets for plateau '..iPlateau..'; For reference, the current land zone considering this is '..iLandZone..'; Time='..GetGameTimeSeconds()) end
                        M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoShieldTargetsByPlateau][iPlateau] = GetGameTimeSeconds()
                        --Dont have any land zones that want a mobile shield, but we have mobile shields - find the closest LZ  that wants DF or IF support and has DF or IF units, and send them here; if that's this LZ, then have them go to the unit closest to the enemy in this LZ, but without assigning them
                        if iClosestLZNotWantingShieldButWithUnits or iClosestLZWithAnyCombatUnits then
                            local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][(iClosestLZNotWantingShieldButWithUnits or iClosestLZWithAnyCombatUnits)][M28Map.subrefLZTeamData][iTeam]
                            if bDebugMessages == true then LOG(sFunctionRef..': Have mobile shields to assign, closest LZ with friendly combat units that wants more units='..(iClosestLZNotWantingShieldButWithUnits or 'nil')..'; iClosestLZWithAnyCombatUnits='..(iClosestLZWithAnyCombatUnits or 'nil')..'; DOes this LZ want mobile shields='..tostring(tTeamTargetLZData[M28Map.refbLZWantsMobileShield] or false)..'; is table of units wanting shielding empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]))) end
                            ShieldUnitsInLandZone(tTeamTargetLZData, tShieldsToAssign, true)
                        end
                        if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                            --cant find any land zones with friendly combat units so have nowhere to assign mobile shields; will send them all to the nearest rally point instead
                            local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2)
                            local tAmphibiousRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2, true)
                            for iUnit, oUnit in tShieldsToAssign do
                                if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                    M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ASBckup'..iLandZone)
                                else
                                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'ShBckup'..iLandZone)
                                end
                            end

                        end
                    end

                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageMobileStealthsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tMobileStealths)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMobileStealthsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then
        local iEnemyOmniCoverage = M28Conditions.GetEnemyOmniCoverageOfZone(iPlateau, iLandZone, iTeam)
        LOG(sFunctionRef..': Start of code, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Size of tMobileStealths='..table.getn(tMobileStealths)..'; iEnemyOmniCoverage='..iEnemyOmniCoverage)
    end

    local tStealthsToAssign = {}
    local tEnemyBase = tLZTeamData[M28Map.reftClosestEnemyBase]
    if M28Utilities.IsTableEmpty(tEnemyBase) then
        M28Utilities.ErrorHandler('Couldnt find enemy base, will try backup approach')
        local iCurDist
        local iClosestDist = 100000
        local oClosestBrain
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestBrain = oBrain
            end
        end
        tEnemyBase = M28Map.PlayerStartPoints[oClosestBrain:GetArmyIndex()]
    end


    for iUnit, oUnit in tMobileStealths do
        if oUnit[refoMobileStealthTarget] and M28UnitInfo.IsUnitValid(oUnit[refoMobileStealthTarget]) then
            --make sure we are behind the target
            MoveToStealthTarget(oUnit, tEnemyBase)
        else
            table.insert(tStealthsToAssign, oUnit)
        end
    end
    if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
        --Cycle through every land zone and record priority ones to Stealth
        if bDebugMessages == true then LOG(sFunctionRef..': Will give orders to tStealthsToAssign, size of table='..table.getn(tStealthsToAssign)) end
        local tiClosestLZWithNearbyThreat = {}
        local iClosestLZWithNoThreat
        local iClosestLZNotWantingStealthButWithUnits
        local iClosestLZWithAnyCombatUnits
        if tLZTeamData[M28Map.subrefbLZWantsSupport] and not(tLZTeamData[M28Map.refbLZWantsMobileStealth]) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedCombatUnits]) == false then iClosestLZNotWantingStealthButWithUnits = iLandZone end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
            for iEntry, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                if tTeamTargetLZData[M28Map.refbLZWantsMobileStealth] then
                    if tTeamTargetLZData[M28Map.refiEnemyAirToGroundThreat] > 0 or tTeamTargetLZData[M28Map.subrefTThreatEnemyCombatTotal] >= 40 then
                        StealthUnitsInLandZone(tTeamTargetLZData, tStealthsToAssign)
                        if M28Utilities.IsTableEmpty(tStealthsToAssign) then break end
                    elseif M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefTEnemyUnits]) == false or tTeamTargetLZData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                        table.insert(tiClosestLZWithNearbyThreat, tPathingDetails[M28Map.subrefLZNumber])
                    elseif not(iClosestLZWithNoThreat) then iClosestLZWithNoThreat = tPathingDetails[M28Map.subrefLZNumber]
                    end
                elseif not(iClosestLZNotWantingStealthButWithUnits) then
                    if tTeamTargetLZData[M28Map.subrefbLZWantsSupport] and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) == false then iClosestLZNotWantingStealthButWithUnits = tPathingDetails[M28Map.subrefLZNumber] end
                    if not(iClosestLZWithAnyCombatUnits) and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) == false then iClosestLZWithAnyCombatUnits = tPathingDetails[M28Map.subrefLZNumber] end
                end

            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished checking other zones we can path to for units wanting Stealthing, is tStealthsToAssign empty='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; Is M28Utilities.IsTableEmpty(tiClosestLZWithNearbyThreat) empty='..tostring(M28Utilities.IsTableEmpty(tiClosestLZWithNearbyThreat))) end
        if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
            if M28Utilities.IsTableEmpty(tiClosestLZWithNearbyThreat) == false then
                for _, iTargetLZ in  tiClosestLZWithNearbyThreat do
                    local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLZ][M28Map.subrefLZTeamData][iTeam]
                    StealthUnitsInLandZone(tTeamTargetLZData, tStealthsToAssign)
                    if M28Utilities.IsTableEmpty(tStealthsToAssign) then break end
                end
            end
            if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                if iClosestLZWithNoThreat then
                    local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZWithNoThreat][M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Have mobile Stealths to assign, closest LZ='..iClosestLZWithNoThreat..'; DOes this LZ want mobile Stealths='..tostring(tTeamTargetLZData[M28Map.refbLZWantsMobileStealth] or false)..'; is table of units wanting Stealthing empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileStealth]))) end
                    StealthUnitsInLandZone(tTeamTargetLZData, tStealthsToAssign)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Is tStealthsToAssign empty after checking for closest LZ with no threat='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; iClosestLZNotWantingStealthButWithUnits='..(iClosestLZNotWantingStealthButWithUnits or 'nil')) end
                if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                    M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoStealthTargetsByPlateau][iPlateau] = GetGameTimeSeconds()
                    --Dont have any land zones that want a mobile Stealth, but we have mobile Stealths - find the closest LZ  that wants DF or IF support and has DF or IF units, and send them here; if that's this LZ, then have them go to the unit closest to the enemy in this LZ, but without assigning them
                    if iClosestLZNotWantingStealthButWithUnits or iClosestLZWithAnyCombatUnits then
                        local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][(iClosestLZNotWantingStealthButWithUnits or iClosestLZWithAnyCombatUnits)][M28Map.subrefLZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Have mobile Stealths to assign, closest LZ with friendly combat units that wants more units='..(iClosestLZNotWantingStealthButWithUnits or 'nil')..'; iClosestLZWithAnyCombatUnits='..(iClosestLZWithAnyCombatUnits or 'nil')..'; DOes this LZ want mobile Stealths='..tostring(tTeamTargetLZData[M28Map.refbLZWantsMobileStealth] or false)..'; is table of units wanting Stealthing empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileStealth]))) end
                        StealthUnitsInLandZone(tTeamTargetLZData, tStealthsToAssign, true)
                    end
                    if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                        --No targets for mobile stealth
                        if bDebugMessages == true then LOG(sFunctionRef..': couldnt find any land zones with friendly combat units so have nowhere to assign mobile Stealths; will send them all to the nearest rally point instead') end
                        local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2)
                        for iUnit, oUnit in tStealthsToAssign do
                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'StBckup'..iLandZone)
                        end

                    end

                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageMAAInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableMAA)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMAAInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2) --Get a LZ up to 3 land zones away to retreat to (i.e. will pick rally point and then move 2 towards it)
    local tAmphibiousRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2, true)

    --First split the MAA into those that need to run (due to being in range of DF units) and those that can advance
    local tMAAToAdvance = {}
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) then
        --No DF enemies so treat all MAA as being available
        tMAAToAdvance = tAvailableMAA
    else
        local iRunThreshold = 14
        if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
            iRunThreshold = 10
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false then
                iRunThreshold = 7
            end
        end
        local bMovingTowardsEnemy, iAngleToRally, iAngleToNearestUnit, bAmphibiousUnit
        local bCampaignMap = M28Map.bIsCampaignMap
        for iUnit, oUnit in tAvailableMAA do
            --Run if within 14 of being in range of enemy direct fire
                                --CloseToEnemyUnit(tStartPosition, tUnitsToCheck,                           iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
            if M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], iRunThreshold, iTeam, true                    , nil,                  nil,                                oUnit) then
                if bDebugMessages == true then
                    LOG(sFunctionRef..': MAA '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is too close to DF enemy, iRunThreshold='..iRunThreshold..'; will run back; will list out enemy units and distance to us in a moment')
                    for iEnemy, oEnemy in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                        LOG('oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; DF r ange='..(oEnemy[M28UnitInfo.refiDFRange] or 'nil')..'; Dist to this MAA unit='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Actual distance using actual position='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemy:GetPosition()))
                    end
                end
                --Does moving towards the rally point take us closer to the enemy?
                bMovingTowardsEnemy = false
                bAmphibiousUnit = EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId)
                local tTempRetreatLocation
                if oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] then
                    local tCurRallyPoint
                    if bAmphibiousUnit then
                        tCurRallyPoint = tAmphibiousRallyPoint
                    else
                        tCurRallyPoint = tRallyPoint
                    end
                    iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)
                    iAngleToNearestUnit = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())
                    if M28Utilities.GetAngleDifference(iAngleToRally, iAngleToNearestUnit) <= 45 then
                        bMovingTowardsEnemy = true
                        --Can we move in the opposite direction to the enemy?
                        tTempRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToNearestUnit + 180, 20, true, false, bCampaignMap)
                        if M28Utilities.IsTableEmpty(tTempRetreatLocation) == false then
                            if not(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tTempRetreatLocation) == tLZData[M28Map.subrefLZIslandRef]) then
                                tTempRetreatLocation = nil
                            end
                        end

                    end
                end
                if M28Utilities.IsTableEmpty(tTempRetreatLocation) == false then
                    M28Orders.IssueTrackedMove(oUnit, tTempRetreatLocation, 6, 'ORun'..iLandZone)
                elseif bAmphibiousUnit then
                    M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ARun'..iLandZone)
                else
                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'Run'..iLandZone)
                end
            else
                table.insert(tMAAToAdvance, oUnit)
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of tMAAToAdvance empty='..tostring(M28Utilities.IsTableEmpty(tMAAToAdvance))) end


    --If enemy has air units in this zone then send the MAA to advance units towards it, but avoid enemy land units
    if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Number of MAA units to advance='..table.getn(tMAAToAdvance)..'; Is table of enemy air units for this LZ '..iLandZone..' empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]))) end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) == false then
            --Move towards the nearest enemy air unit to the LZ midpoint
            local oNearestEnemyToMidpoint
            local iClosestDist = 100000
            local iCurDist
            --Get closest enemy air unit
            for iUnit, oUnit in tLZTeamData[M28Map.reftLZEnemyAirUnits] do
                iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                if iCurDist < iClosestDist then
                    iClosestDist = iCurDist
                    oNearestEnemyToMidpoint = oUnit
                end
            end

            --Move towards the air unit
            local tOrderPosition = oNearestEnemyToMidpoint:GetPosition()
            if bDebugMessages == true then
                LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..' Will order every MAA to move to oNearestEnemyToMidpoint='..oNearestEnemyToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint)..' at position '..repru(oNearestEnemyToMidpoint:GetPosition()))
                M28Utilities.DrawLocation(tOrderPosition)
            end

            for iUnit, oUnit in tMAAToAdvance do
                M28Orders.IssueTrackedMove(oUnit, tOrderPosition, 7, false, 'MNA')
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will do reprs of orders of the first unit in tMAAToAdvance, '..tMAAToAdvance[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tMAAToAdvance[1])..': '..reprs(tMAAToAdvance[1][M28Orders.reftiLastOrders])) end

        else
            --Enemy doesnt have any air units, so consider if there are other land zones we want to support with MAA
            local tLZToReinforceModDistance = {}
            local iCurModDist
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': About to consider all other adjacent land zones to iLandZone '..iLandZone..', reprs of tLZData[M28Map.subrefLZPathingToOtherLandZones]='..reprs(tLZData[M28Map.subrefLZPathingToOtherLandZones])) end
                for iEntry, tPathDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                    local tAltTeamLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to send MAA to assist alt LZ '..tPathDetails[M28Map.subrefLZNumber]..'; tAltTeamLZData[M28Map.subrefLZMAAThreatWanted]='..tAltTeamLZData[M28Map.subrefLZMAAThreatWanted]..'; tAltTeamLZData[M28Map.subrefLZThreatAllyGroundAA]='..tAltTeamLZData[M28Map.subrefLZThreatAllyGroundAA]..'; Air to ground threat in this alt LZ='..tAltTeamLZData[M28Map.refiEnemyAirToGroundThreat]) end
                    if tAltTeamLZData[M28Map.subrefLZMAAThreatWanted] > tAltTeamLZData[M28Map.subrefLZThreatAllyGroundAA] then
                        iCurModDist = tPathDetails[M28Map.subrefLZTravelDist]
                        if tAltTeamLZData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                            iCurModDist = iCurModDist - 200
                            if tAltTeamLZData[M28Map.subrefLZTThreatAllyCombatTotal] > 0 then iCurModDist = iCurModDist - 35 end
                        elseif (tAltTeamLZData[M28Map.refiEnemyAirOtherThreat] + tLZTeamData[M28Map.refiEnemyAirAAThreat]) > 45 then iCurModDist = iCurModDist - 100
                        end
                        if M28Utilities.IsTableEmpty(tAltTeamLZData[M28Map.subreftoLZOrWZAlliedUnits]) then iCurModDist = iCurModDist + 100 end
                        if tAltTeamLZData[M28Map.subrefTThreatEnemyCombatTotal] > 6 then
                            iCurModDist = iCurModDist + 50
                            if tAltTeamLZData[M28Map.subrefLZTThreatAllyCombatTotal] == 0 then
                                iCurModDist = iCurModDist + 150
                            elseif tAltTeamLZData[M28Map.subrefTThreatEnemyCombatTotal] > tAltTeamLZData[M28Map.subrefLZTThreatAllyCombatTotal] then
                                iCurModDist = iCurModDist + 75
                            end
                            --tAltTeamLZData[M28Map.subrefTThreatEnemyCombatTotal] > subrefLZTThreatAllyCombatTotal
                        end
                        tLZToReinforceModDistance[tPathDetails[M28Map.subrefLZNumber]] = iCurModDist
                    end
                end
                for iLZ, iModDist in M28Utilities.SortTableByValue(tLZToReinforceModDistance, false) do
                    SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, iLZ)
                    if M28Utilities.IsTableEmpty(tMAAToAdvance) then
                        break
                    end
                end

                if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                    if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                            for iEntry, tPathDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                                local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                                if not(tAltLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tAltLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false and tAltLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < tAltLZTeamData[M28Map.subrefLZTValue] * 0.1 then
                                    SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, tPathDetails[M28Map.subrefLZNumber])
                                    if M28Utilities.IsTableEmpty(tMAAToAdvance) then break end
                                end
                            end
                        end
                    end
                end
            end



            --Do we have any MAA remaining after sending MAA to any LZ wanting support?
            if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                --Is there an adjacent water zone that wants MAA support?
                if bDebugMessages == true then LOG(sFunctionRef..': Checking if have adjacent water zones, in which case will see if any of them want MAA; is table of adj water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                    local tHoverMAA = EntityCategoryFilterDown(categories.HOVER, tMAAToAdvance)
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of hover MAA empty='..tostring(M28Utilities.IsTableEmpty(tHoverMAA))) end
                    if M28Utilities.IsTableEmpty(tHoverMAA) == false then
                        local iPond, iAdjWZ
                        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                            iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                            iPond = M28Map.tiPondByWaterZone[iAdjWZ]
                            local tAltWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjWZ='..iAdjWZ..'; iPond='..iPond..'; MAA threat wanted='..tAltWZTeamData[M28Map.subrefWZMAAThreatWanted]) end
                            if tAltWZTeamData[M28Map.subrefWZMAAThreatWanted] > math.max(50, tAltWZTeamData[M28Map.subrefWZThreatAlliedAA]) then
                                --Only consider if either no enemy threat, or we have an allied combat threat
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy combat total='..tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Ally combat total='..tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]) end
                                if tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < 10 or tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] > 10 then
                                    SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, iAdjWZ, nil, true, tHoverMAA)
                                    if M28Utilities.IsTableEmpty(tHoverMAA) then break end
                                end
                            end
                        end


                        --Do we still have hover MAA available and have high priority water zoens wanting MAA?
                        if M28Utilities.IsTableEmpty(tHoverMAA) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': Checking list of centrally flagged WZ to see if they want MAA, is table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau]))..'; repru of M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau]='..repru(M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau])) end
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau]) == false then
                                local iDistThreshold = math.max(250, M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase])) * 0.8
                                local iThresholdAdjust
                                for iAdjWZ, bWantsSupport in M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau] do
                                    --If waterzone isn't too far from us then support it (based on simple straight line)
                                    iPond = M28Map.tiPondByWaterZone[iAdjWZ]
                                    local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
                                    iThresholdAdjust = 0
                                    if tAltWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZMAAThreatWanted] >= 2000 and tAltWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefLZTThreatAllyCombatTotal] >= 12000 then iThresholdAdjust = 100 end
                                    if bDebugMessages == true then
                                        --[[if not(iAdjWZ) then LOG('iAdjWZ is nil') end
                                        if not(iDistThreshold) then LOG('iDistThreshold is nil') end
                                        LOG('tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint]))
                                        LOG('tAltWZData[M28Map.subrefMidpoint]='..repru(tAltWZData[M28Map.subrefMidpoint])..'; iAdjWZ='..iAdjWZ..'; iPond='..(iPond or 'nil'))--]]
                                        LOG(sFunctionRef..': Considering WZ further away flagged as wanting MAA, iAdjWZ='..iAdjWZ..'; iDistThreshold='..iDistThreshold..'; Dist to WZ='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tAltWZData[M28Map.subrefMidpoint])..'; iThresholdAdjust='..iThresholdAdjust)
                                    end
                                    if M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tAltWZData[M28Map.subrefMidpoint]) <= iDistThreshold + iThresholdAdjust then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and send MAA to this water zone') end
                                        SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, iAdjWZ, nil, true, tHoverMAA)
                                        if M28Utilities.IsTableEmpty(tHoverMAA) then break end
                                    end
                                end
                            end
                            --Consider sending MAA to all zones (i.e. land and water, and other islands)
                            M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint])
                            if M28Utilities.IsTableEmpty(tHoverMAA) == false and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                                local iZoneMAAWanted
                                for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                                    local tAltLZOrWZData, tAltLZOrWZTeamData
                                    if tSubtable[M28Map.subrefbIsWaterZone] then
                                        tAltLZOrWZData = M28Map.tPondDetails[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                        tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                                        iZoneMAAWanted = tAltLZOrWZTeamData[M28Map.subrefWZMAAThreatWanted]
                                    else
                                        if tSubtable[M28Map.subrefiPlateauOrPond] == iPlateau then
                                            tAltLZOrWZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                            tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                                            iZoneMAAWanted = tAltLZOrWZTeamData[M28Map.subrefLZMAAThreatWanted]
                                        else
                                            iZoneMAAWanted = 0
                                        end
                                    end
                                    if iZoneMAAWanted >= 5 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': About to send MAA to support LZ or WZ ref='..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..'; Is water zone='..tostring(tSubtable[M28Map.subrefbIsWaterZone])..'; iZoneMAAWanted='..iZoneMAAWanted..'; iPlateau='..iPlateau..'; Is table of tHoverMAA empty='..tostring(M28Utilities.IsTableEmpty(tHoverMAA))) end
                                        SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, tSubtable[M28Map.subrefiLandOrWaterZoneRef], 1.5, tSubtable[M28Map.subrefbIsWaterZone], tHoverMAA)
                                        if M28Utilities.IsTableEmpty(tHoverMAA) then break end
                                    end
                                end
                            end
                        end
                    end
                end


                --If sitll have MAA available, then send to existing land zones with a greater factor
                if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                    local iMAALZToSupport
                    local iHighestAirValue = 0
                    local iHighestAirLZ
                    local iCurAirValue
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                        for iEntry, tPathDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering which adjacent LZ has the biggest air threat for leftover MAA, cur entry=LZ'..tPathDetails[M28Map.subrefLZNumber]..'; MAA threat wanted='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZMAAThreatWanted]..'; GroundAA have already='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatAllyGroundAA]..'; Enemy air to ground threat='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.refiEnemyAirToGroundThreat]..'; Air othre threat='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.refiEnemyAirOtherThreat]..'; Is table of enemy air empty for this alt LZ='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.reftLZEnemyAirUnits]))..' iHighestAirValue so far='..iHighestAirValue) end
                            if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZMAAThreatWanted] > M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatAllyGroundAA] then
                                local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                                iCurAirValue = tAltLZTeamData[M28Map.subrefLZMAAThreatWanted] * 0.01 + tAltLZTeamData[M28Map.refiEnemyAirToGroundThreat] + (tAltLZTeamData[M28Map.refiEnemyAirOtherThreat] + tAltLZTeamData[M28Map.refiEnemyAirAAThreat]) * 0.1
                                if iCurAirValue > iHighestAirValue then
                                    iHighestAirValue = iCurAirValue
                                    iHighestAirLZ = tPathDetails[M28Map.subrefLZNumber]
                                end
                            end
                        end
                    end
                    iMAALZToSupport = iHighestAirLZ


                    if bDebugMessages == true then LOG(sFunctionRef..': Do any adjacent zones want support? iMAALZToSupport='..(iMAALZToSupport or 'nil')) end
                    if iMAALZToSupport then
                        local tTargetPosition = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iMAALZToSupport][M28Map.subrefMidpoint]
                        for iUnit, oUnit in tMAAToAdvance do
                            M28Orders.IssueTrackedMove(oUnit, tTargetPosition, 10, false, 'MVBLZ'..iMAALZToSupport)
                        end
                    end
                    if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then --Go back through each LZ assigning 3 times what it would normally want in MAA
                        local iFactorAdjust
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                            for iEntry, tPathDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                                local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                                if (not(tAltLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) or tAltLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > 10 or tAltLZTeamData[M28Map.subrefLZSValue] > 10) then
                                    iFactorAdjust = 2
                                    if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then iFactorAdjust = 3 end
                                    SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, tPathDetails[M28Map.subrefLZNumber], iFactorAdjust)
                                end
                            end
                        end
                    end
                end
            end

            if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Still have spare MAA, tLZData[M28Map.subrefLZIslandRef]='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iPlateau='..(iPlateau or 'nil')) end
                --Only flag that we have no MAA targets for a core base if we have 10+ MAA, including T2+ MAA, with no target
                local bEnoughMAAInZone = false
                if tLZTeamData[M28Map.subrefLZbCoreBase] then
                    local tT2PlusMAAToAdvance = EntityCategoryFilterDown(categories.TECH2 + categories.TECH3, tMAAToAdvance)
                    if table.getn(tT2PlusMAAToAdvance) >= 8 then
                        bEnoughMAAInZone = true
                    end
                elseif tLZTeamData[M28Map.subrefLZCoreExpansion] then
                    if table.getn(tMAAToAdvance) >= 2 then
                        bEnoughMAAInZone = true
                    end
                else
                    bEnoughMAAInZone = true
                end
                if bEnoughMAAInZone then
                    M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoMAATargetsByIsland][tLZData[M28Map.subrefLZIslandRef]] = GetGameTimeSeconds()
                end
                --Go to rally point instead
                for iUnit, oUnit in tMAAToAdvance do
                    if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                        M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 10, false, 'ABRtr'..iLandZone)
                    else
                        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 10, false, 'BRtr'..iLandZone)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageRASSACUsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tRASSACU)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageRASSACUsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Defending against arti - if have a gameender then first consider if have part-complete shield that want to construct
    local oShieldToAssist
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) == false and M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] then
        local tGameEndersForShielding = EntityCategoryFilterDown(M28UnitInfo.refCategoryGameEnder, tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection])
        if M28Utilities.IsTableEmpty(tGameEndersForShielding) == false then
            local oGameEnderToCover
            for iGameEnder, oGameEnder in tGameEndersForShielding do
                if M28Utilities.IsTableEmpty(oGameEnder[M28Building.reftoSpecialAssignedShields]) == false then
                    oGameEnderToCover = oGameEnder
                    break
                end
            end
            if oGameEnderToCover then
                --How much shielding do we have
                local iNearestCompleteShield = 0
                local oNearestCompleteShield
                local iActiveShields = 0
                local iCurShield, iMaxShield
                for iShield, oShield in oGameEnderToCover[M28Building.reftoSpecialAssignedShields] do
                    if oShield:GetFractionComplete() < 1 and oShield:GetFractionComplete() > iNearestCompleteShield then
                        iNearestCompleteShield = oShield:GetFractionComplete()
                        oNearestCompleteShield = oShield
                    else
                        iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                        if iCurShield > 0 then iActiveShields = iActiveShields + 1 end
                    end
                end
                if iActiveShields > 1 or (iActiveShields == 1 and iNearestCompleteShield >= 0.75) then
                    --Do nothing
                else
                    oShieldToAssist = oNearestCompleteShield
                end
            end
        end

    end

    --Defending against arti - if have T3 arti or gameender then want to assist the shield with RAS SACUs (in addition to any engineers that are assisting it)
    if not(oShieldToAssist) then
        local tPriorityUnitsToShield
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code for zone '..iLandZone..'; at time '..GetGameTimeSeconds()..'; DefendAgainstArti='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti])) end
        if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] then
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            tPriorityUnitsToShield = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryGameEnder, tLZData[M28Map.subrefMidpoint], 250, 'Ally')
            if M28Utilities.IsTableEmpty(tPriorityUnitsToShield) then
                tPriorityUnitsToShield = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedT3Arti, tLZData[M28Map.subrefMidpoint], 150, 'Ally')
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of priority units to shield empty='..tostring(M28Utilities.IsTableEmpty(tPriorityUnitsToShield))) end
        if M28Utilities.IsTableEmpty(tPriorityUnitsToShield) == false then
            --Get closest of these that has a shield that is damaged
            local iCurDist
            local iClosestDist = 100000
            local iCurShield, iMaxShield
            local bAssistEvenIfNotDamaged = true
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.4 then bAssistEvenIfNotDamaged = false end
            for iUnit, oUnit in tPriorityUnitsToShield do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering priority unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction compelte='..oUnit:GetFractionComplete()..'; Does it have a shield providing coverage='..tostring(M28UnitInfo.IsUnitValid(oUnit[M28Building.refoPriorityShieldProvidingCoverage]))) end
                if oUnit:GetFractionComplete() >= 0.35 then
                    if M28UnitInfo.IsUnitValid(oUnit[M28Building.refoPriorityShieldProvidingCoverage]) then
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit[M28Building.refoPriorityShieldProvidingCoverage]:GetPosition())
                        if bDebugMessages == true then LOG(sFunctionRef..': Shield='..oUnit[M28Building.refoPriorityShieldProvidingCoverage].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28Building.refoPriorityShieldProvidingCoverage])..'; iCurDist='..iCurDist..'; iCloestDist='..iClosestDist) end
                        if iCurDist < iClosestDist then
                            --Is the shield still active?
                            iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit[M28Building.refoPriorityShieldProvidingCoverage], true)
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurShield='..iCurShield) end
                            if (iCurShield > 0 and (bAssistEvenIfNotDamaged or iCurShield < iMaxShield or GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeLastDamaged] or - 100) <= 25)) or (oUnit[M28Building.refoPriorityShieldProvidingCoverage]:GetFractionComplete() < 1 and (not(oUnit[M28Engineer.refbDontIncludeAsPartCompleteBuildingForConstruction]) or oUnit[M28Building.refoPriorityShieldProvidingCoverage]:GetFractionComplete() <= 0.75)) then
                                iClosestDist = iCurDist
                                oShieldToAssist = oUnit[M28Building.refoPriorityShieldProvidingCoverage]
                            end
                        end
                    end
                end
            end
        end
    end
    if oShieldToAssist then
        if bDebugMessages == true then LOG(sFunctionRef..': Have priority shield to assist') end
        if oShieldToAssist:GetFractionComplete() == 1 then
            for iUnit, oUnit in tRASSACU do
                M28Orders.IssueTrackedGuard(oUnit, oShieldToAssist, false, 'RASAGS', false)
            end
        else
            for iUnit, oUnit in tRASSACU do
                M28Orders.IssueTrackedRepair(oUnit, oShieldToAssist, false, 'RASRS', false)
            end
        end
    else
        --If have mass stored then find the nearest quantum gatway and assist it for now, otherwise do nothing (if enemies in this LZ then will have been sent to the combat unit management already)
        local tQuantumGateways = EntityCategoryFilterDown(M28UnitInfo.refCategoryQuantumGateway, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local oGateway
        local bNotAssistingGateway = true
        local bHaveRASGateway = false

        if M28Utilities.IsTableEmpty( tQuantumGateways) == false then
            for iUnit, oUnit in tQuantumGateways do
                oGateway = oUnit
                if not(EntityCategoryContains(categories.SERAPHIM, oUnit.UnitId)) then
                    bHaveRASGateway = true
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': oGateway='..(oGateway.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oGateway))..'; bHaveRASGateway='..tostring(bHaveRASGateway)) end
        if oGateway then
            if not(bHaveRASGateway) then
                --Do we have a T3+ 'other' factory type on the team, for a non-sera faction?
                local iLandSubteam = oGateway:GetAIBrain().M28LandSubteam
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of other faction types empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeOther]))..'; Reprs of this='..reprs(M28Team.tTeamData[iTeam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeOther])) end
                if M28Utilities.IsTableEmpty(M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeOther]) == false then
                    local bHaveNonSeraFactory = false
                    for iFaction, tSubtable in M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeOther] do
                        if not(iFaction == M28UnitInfo.refFactionSeraphim) and (tSubtable[3] or 0) > 0 then
                            bHaveNonSeraFactory = true
                            break
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished searching other factory types, bHaveNonSeraFactory='..tostring(bHaveNonSeraFactory or false)) end
                    if bHaveNonSeraFactory then
                        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                        local tNearbyFriendlyGateway = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryQuantumGateway - categories.SERAPHIM, tLZData[M28Map.subrefMidpoint], 250, 'Ally')
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby non sera quantum gateways empty='..tostring(M28Utilities.IsTableEmpty(tNearbyFriendlyGateway))) end
                        if M28Utilities.IsTableEmpty(tNearbyFriendlyGateway) == false then
                            for iUnit, oUnit in tNearbyFriendlyGateway do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering quantum gateway oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Terrain label='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oUnit:GetPosition()) or 'nil')..'; iPlateau='..(iPlateau or 'nil')) end
                                if oUnit:GetAIBrain().M28AI and NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oUnit:GetPosition()) == iPlateau then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have a non sera gateway to assist instead, oGateway='..oGateway.UnitId..M28UnitInfo.GetUnitLifetimeCount(oGateway)) end
                                    oGateway = oUnit
                                    break
                                end
                            end
                        end
                    end
                end
            end
            if (M28Map.bIsCampaignMap or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.05) and not(M28Conditions.HaveLowPower(iTeam)) and ((M28Map.bIsCampaignMap and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 80 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) or (not(M28Map.bIsCampaignMap) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < math.min(100, 40 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]))) then
                if (M28Map.bIsCampaignMap or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 100) and oGateway:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryRASSACU) < 50 then
                    bNotAssistingGateway = false
                    if bDebugMessages == true then LOG(sFunctionRef..': Will get every SACU to assist the gateway') end
                    for iUnit, oUnit in tRASSACU do
                        M28Orders.IssueTrackedGuard(oUnit, oGateway, false, 'RASQG', false)
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': oGateway='..(oGateway.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oGateway) or 'nil')..'; bNotAssistingGateway='..tostring(bNotAssistingGateway)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Have low power='..tostring(M28Conditions.HaveLowPower(iTeam))) end
        if bNotAssistingGateway then
            local tUnitsToAssist = {}
            --If building an experimental and dont have low mass then assist it
            if bDebugMessages == true then LOG(sFunctionRef..': Does team have low mass='..tostring(M28Conditions.TeamHasLowMass(iTeam))..'; Is table of engineers building experimentals empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]))..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone) end
            if not(M28Conditions.TeamHasLowMass(iTeam)) and not(M28Conditions.HaveLowPower(iTeam)) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]) == false then

                local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                local tExperimentalLevelUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryExperimentalLevel, tLZData[M28Map.subrefMidpoint], 100, 'Ally')
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of experimental level units empty='..tostring(M28Utilities.IsTableEmpty( tExperimentalLevelUnits))) end
                if M28Utilities.IsTableEmpty( tExperimentalLevelUnits) == false then
                    for iUnit, oUnit in tExperimentalLevelUnits do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering nearby experimental '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()) end
                        if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() < 1 then
                            table.insert(tUnitsToAssist, oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding unit to table of units to assist') end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Do we have any units to assist? is table empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToAssist))) end
            if M28Utilities.IsTableEmpty(tUnitsToAssist) then
                --If have upgrading unit then assist this
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of active upgrades empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]))) end
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then tUnitsToAssist = tLZTeamData[M28Map.subrefActiveUpgrades]
                else
                    --Assist shield if need to defend from arti
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of priority shields to assist empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]))..'; Defending against arti='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti])) end
                    if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]) == false then
                        tUnitsToAssist = tLZTeamData[M28Map.reftPriorityShieldsToAssist]
                    else
                        --otherwise assist an air factory if we have one
                        tUnitsToAssist = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                        if bDebugMessages == true then LOG(sFunctionRef..': Setting unit to assist to be an air factory, is tUnitsToAssist empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToAssist))) end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished saerching for potential units to assist, is table empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToAssist))) end
            if M28Utilities.IsTableEmpty(tUnitsToAssist) == false then
                local tStartPoint
                if oGateway then tStartPoint = oGateway:GetPosition()
                else tStartPoint = tLZData[M28Map.subrefMidpoint]
                end
                local oClosestUnitToAssist = M28Utilities.GetNearestUnit(tUnitsToAssist, tStartPoint)
                if bDebugMessages == true then LOG(sFunctionRef..': oClosestUnitToAssist='..(oClosestUnitToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestUnitToAssist) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oClosestUnitToAssist))) end
                if not(M28UnitInfo.IsUnitValid(oClosestUnitToAssist)) then M28Utilities.ErrorHandler('No unit to assist for RAS', true)
                else
                    for iUnit, oUnit in tRASSACU do
                        M28Orders.IssueTrackedGuard(oUnit, oClosestUnitToAssist, false, 'RASAs', false)
                        if bDebugMessages == true then LOG(sFunctionRef..': Telling RAS '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to assist unit') end
                    end
                end

            else
                --Othewrise clear orders if nothing to assist
                for iUnit, oUnit in tRASSACU do
                    if not(oUnit[M28UnitInfo.refbSpecialMicroActive]) and not(oUnit:IsUnitState('Moving')) and (oUnit:IsUnitState('Repairing') or oUnit:IsUnitState('Building') or oUnit:IsUnitState('Guarding')) then
                        M28Orders.IssueTrackedClearCommands(oUnit)
                    end
                end
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageCombatUnitsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableCombatUnits, iFriendlyBestMobileDFRange, iFriendlyBestMobileIndirectRange, bWantIndirectReinforcements, tUnavailableUnitsInThisLZ)
    --Handles logic for main combat units (direct and indirect fire mobile units) that are noted as available to the land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageCombatUnitsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then
        LOG(sFunctionRef..': start of code, iTeam='..iTeam..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Is table of available combat units empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))..'; iFriendlyBestMobileDFRange='..iFriendlyBestMobileDFRange..'; iFriendlyBestMobileIndirectRange='..iFriendlyBestMobileIndirectRange..'; Are there enemy units in this or adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; bWantIndirectReinforcements='..tostring(bWantIndirectReinforcements or false)..'; tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]='..tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]..'; subrefLZThreatAllyMobileIndirectByRange='..repru(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange])..'; subrefLZThreatAllyMobileDFByRange='..repru(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange])..'; Enemy mobile DF='..repru(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange])..'; Threat of tAvailableCombatUnits='..M28UnitInfo.GetCombatThreatRating(tAvailableCombatUnits, false, false, false)..'; subrefiAvailableMobileShieldThreat='..(tLZTeamData[M28Map.subrefiAvailableMobileShieldThreat] or 0)..'; LZ value='..tLZTeamData[M28Map.subrefLZTValue]..'; Time='..GetGameTimeSeconds())
        for iUnit, oUnit in tAvailableCombatUnits do
            LOG(sFunctionRef..': Threat of unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'='..M28UnitInfo.GetCombatThreatRating({ oUnit }, false, false, false))
        end
    end

    local bWantReinforcements = false

    --First record the range of enemy units, and which units in adjacent zones are nearest to us:
    UpdateBestEnemyRangesForThisLandZone(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    local iEnemyBestMobileDFRange, iEnemyBestStructureDFRange, iEnemyBestMobileIndirectRange = RecordClosestAdjacentEnemiesAndGetBestEnemyRange(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2) --Get a LZ up to 3 land zones away to retreat to (i.e. will pick rally point and then move 2 towards it)
    local tAmphibiousRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2, true)
    local iAngleTowardsBase = M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase])
    local iDistTowardsBase = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase])
    local tMoveTowardsBaseRetreatPoint = M28Utilities.MoveInDirection(tLZData[M28Map.subrefMidpoint], iAngleTowardsBase, math.min(50, iDistTowardsBase), true, false, M28Map.bIsCampaignMap)
    if bDebugMessages == true then LOG(sFunctionRef..': tMoveTowardsBaseRetreatPoint='..repru(tMoveTowardsBaseRetreatPoint)..'; iAngleTowardsBase='..iAngleTowardsBase..'; iDistTowardsBase from LZ midpoint='..iDistTowardsBase..'; Midpoint='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tMoveTowardsBaseRetreatPoint) or 'nil')..'; tLZData[M28Map.subrefLZIslandRef]='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')) end
    if tMoveTowardsBaseRetreatPoint then
        if not(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tMoveTowardsBaseRetreatPoint) == tLZData[M28Map.subrefLZIslandRef]) then
            tMoveTowardsBaseRetreatPoint = nil
        else
            local iAngleToRallyPoint = M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tRallyPoint)
            if bDebugMessages == true then LOG(sFunctionRef..': iAngleToRallyPoint='..iAngleToRallyPoint..'; Angle dif='..M28Utilities.GetAngleDifference(iAngleToRallyPoint, iAngleTowardsBase)..'; Dist between rally point and bsae='..M28Utilities.GetDistanceBetweenPositions(tRallyPoint, tLZTeamData[M28Map.reftClosestFriendlyBase])) end
            if M28Utilities.GetAngleDifference(iAngleToRallyPoint, iAngleTowardsBase) <= 20 then
                tMoveTowardsBaseRetreatPoint = nil
            elseif M28Utilities.GetDistanceBetweenPositions(tRallyPoint, tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 20 then
                tMoveTowardsBaseRetreatPoint = nil
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': tAmphibiousRallyPoint='..repru(tAmphibiousRallyPoint)..'; tRallyPoint='..repru(tRallyPoint)) end
    local iIndirectRunFigureNormal = 10
    local iIndirectRunFigureDeployedAdjust = 15
    local iIndirectRunFigureSynchronisation = 5
    local iIndirectDistanceInsideRangeThreshold

    local oClosestFriendlyUnitToAnEnemyFirebase --For simplicity will be the closest unit to the last firebase checked (where multiple firebases)
    local iClosestFriendlyUnitToAnEnemyFirebase = 100000

    local iFirebaseThreatAdjust = 0
    local iAdjacentFirebaseThreat = 0

    local iAvailableCombatUnitThreat = M28UnitInfo.GetCombatThreatRating(tAvailableCombatUnits, false, true)
    iAvailableCombatUnitThreat = iAvailableCombatUnitThreat + math.min(iAvailableCombatUnitThreat, tLZTeamData[M28Map.subrefiAvailableMobileShieldThreat])

    local bHaveSignificantCombatCloserToFirebase = false
    local iClosestFirebaseDist = 100000
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
        --Is the firebase not in range of a core LZ?
        local bFirebaseInCoreLZRange = false
        local oNearestFirebaseUnit
        local oOurNearestUnitToFirebase
        local tEnemyT2ArtiAndShields
        local iCurDist
        local iClosestDist
        local iCurFirebaseThreat
        local bIsAdjacent
        local iDistToFirebase

        for iEntry, tPlateauAndLZ in tLZTeamData[M28Map.subreftEnemyFirebasesInRange] do
            if M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][tPlateauAndLZ[2]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] then
                bFirebaseInCoreLZRange = true
                iFirebaseThreatAdjust = 0
                break
            else
                --Ignore firebase in the LZ we are already in
                if not(iLandZone == tPlateauAndLZ[2]) then
                    tEnemyT2ArtiAndShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryFixedShield, M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][tPlateauAndLZ[2]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits])
                    if M28Utilities.IsTableEmpty(tEnemyT2ArtiAndShields) == false then
                        iClosestDist = 100000
                        for iUnit, oUnit in tEnemyT2ArtiAndShields do
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oNearestFirebaseUnit = oUnit
                            end
                        end
                        iClosestDist = 100000
                        local tFirebaseMidpoint = M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][tPlateauAndLZ[2]][M28Map.subrefMidpoint]
                        for iUnit, oUnit in tAvailableCombatUnits do
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tFirebaseMidpoint)
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oOurNearestUnitToFirebase = oUnit
                                if iClosestDist < iClosestFriendlyUnitToAnEnemyFirebase then
                                    oClosestFriendlyUnitToAnEnemyFirebase = oUnit
                                    iClosestFriendlyUnitToAnEnemyFirebase = iClosestDist
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': oOurNearestUnitToFirebase='..oOurNearestUnitToFirebase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOurNearestUnitToFirebase)..'; oNearestFirebaseUnit='..oNearestFirebaseUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestFirebaseUnit)..'; Dist between them='..M28Utilities.GetDistanceBetweenPositions(oOurNearestUnitToFirebase:GetPosition(), oNearestFirebaseUnit:GetPosition())) end

                        if oOurNearestUnitToFirebase and oNearestFirebaseUnit then
                            iCurFirebaseThreat = 0
                            iDistToFirebase = M28Utilities.GetDistanceBetweenPositions(oOurNearestUnitToFirebase:GetPosition(), oNearestFirebaseUnit:GetPosition())
                            iClosestFirebaseDist = math.min(iClosestFirebaseDist, iDistToFirebase)
                            if iDistToFirebase <= 140 then
                                iCurFirebaseThreat = M28UnitInfo.GetCombatThreatRating(tEnemyT2ArtiAndShields, true, true)
                                if iCurFirebaseThreat > 0 then
                                    bIsAdjacent = false
                                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][tPlateauAndLZ[2]]][M28Map.subrefLZPath]) == false then

                                        --Include friendly units in LZs between here and the firebase
                                        if bDebugMessages == true then
                                            --LOG(sFunctionRef..': iLandZone='..reprs(iLandZone))
                                            --LOG(sFunctionRef..': tPlateauAndLZ[2]='..reprs(tPlateauAndLZ[2]))
                                            --LOG(sFunctionRef..': tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][tPlateauAndLZ[2]]='..reprs(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][tPlateauAndLZ[2]]))
                                            --LOG(sFunctionRef..': pathing='..reprs(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][tPlateauAndLZ[2]]][M28Map.subrefLZPath]))
                                            --LOG(sFunctionRef..': tLZData[M28Map.subrefLZPathingToOtherLandZones]='..reprs(tLZData[M28Map.subrefLZPathingToOtherLandZones]))
                                            LOG(sFunctionRef..': Will cycle through all LZs between LZ'..reprs(iLandZone or 'nil')..' and LZ'..reprs(tPlateauAndLZ[2] or 'nil')..' and factor in friendly threat; Entry in pathing table='..reprs(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][tPlateauAndLZ[2]] or 'nil')..'; reprs of pathing='..reprs(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][tPlateauAndLZ[2]]][M28Map.subrefLZPath])..'; tLZData[M28Map.subrefLZPathingToOtherLandZones]='..reprs(tLZData[M28Map.subrefLZPathingToOtherLandZones]))
                                        end

                                        for iEntry, iAdjacentLandZone in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                            if iAdjacentLandZone == tPlateauAndLZ[2] then
                                                bIsAdjacent = true
                                            end
                                        end
                                        for iEntry, iPathLZ in tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][tPlateauAndLZ[2]]][M28Map.subrefLZPath] do
                                            if not(iPathLZ == iLandZone) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Friendly LZ that will pass through to get to firebase='..iPathLZ..'; Friendly combat threat of this='..(M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTThreatAllyCombatTotal] or 'nil')) end
                                                iCurFirebaseThreat = iCurFirebaseThreat - (M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTThreatAllyCombatTotal] or 'nil')
                                                if not(bHaveSignificantCombatCloserToFirebase) and M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTThreatAllyCombatTotal] >= 4000 then
                                                    bHaveSignificantCombatCloserToFirebase = true
                                                end
                                            end
                                        end
                                    end
                                    if bIsAdjacent then
                                        --Track adjacent firebase threat so if we want to take this into account later we can; dont think we are double-counting this though so currently only using to affect decision on whether to automatically retreat
                                        iAdjacentFirebaseThreat = iAdjacentFirebaseThreat + math.max(iCurFirebaseThreat, 0)
                                    end
                                end
                            end
                            iFirebaseThreatAdjust = iFirebaseThreatAdjust + math.max(iCurFirebaseThreat, 0)
                        end
                    end
                else
                    iClosestFirebaseDist = 0
                end
            end
        end
    end

    --If enemy has a firebase, then retreat if we dont have enough threat to beat it and we dont have significant indirect force
    local bRunFromFirebase = false
    if iFirebaseThreatAdjust > 0 and not(bHaveSignificantCombatCloserToFirebase) and tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] < math.min(20000, iFirebaseThreatAdjust)  then
        --Retreat
        bRunFromFirebase = true
        if iClosestFirebaseDist <= 100 then
            local tFriendlyIndirect = EntityCategoryFilterDown(M28UnitInfo.refCategoryIndirect, tAvailableCombatUnits)
            if M28Utilities.IsTableEmpty( tFriendlyIndirect) == false then
                if table.getn(tFriendlyIndirect) >= 10 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Exception to decision to run from firebase') end
                    bRunFromFirebase = false
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': iFirebaseThreatAdjust='..iFirebaseThreatAdjust..'; bRunFromFirebase='..tostring(bRunFromFirebase)..'; tLZTeamData[M28Map.subreftEnemyFirebasesInRange]='..reprs(tLZTeamData[M28Map.subreftEnemyFirebasesInRange])..'; subrefiNearbyEnemyLongRangeThreat='..tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat]..'; Enemies in adj wZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])) end


    --If enemy has units in this or adjacent LZ, then decide what to do
    if (tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) and not(bRunFromFirebase) then
        local bEnemyHasNoDFUnits
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] then bEnemyHasNoDFUnits = false
        else
            bEnemyHasNoDFUnits = M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies])
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Checking for nearest enemy to midpoint, bEnemyHasNoDFUnits='..tostring(bEnemyHasNoDFUnits)..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))) end

        local oNearestEnemyToMidpoint
        local bConsiderAttackingACU = false
        local toEnemyACUsInZone = {}
        local oNearestEnemyStructureToMidpoint
        local iClosestDist = 100000
        local iClosestStructureDist = 100000
        local iCurDist
        local iEnemyBestDFRange = math.max(iEnemyBestMobileDFRange, iEnemyBestStructureDFRange)
        local bNearestEnemyNeedsManualAttack = false --If nearest enemy is below water with its base but still visible on the top then units wont fire at it unless given a specific attack order
        local tEnemyEngineers = {} --So can avoid getting in reclaim range, and consider targeting as a priority

        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
            tEnemyEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subrefTEnemyUnits])
            if not(tEnemyEngineers) then tEnemyEngineers = {} end
            for iUnit, oUnit in tLZTeamData[M28Map.subrefTEnemyUnits] do
                --Add ACUs as potential high priority targets if they are on land
                if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) and M28UnitInfo.CanSeeUnit(M28Team.GetFirstActiveM28Brain(iTeam), oUnit, true) then table.insert(toEnemyACUsInZone, oUnit) end
                iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                if iCurDist < iClosestDist then
                    iClosestDist = iCurDist
                    oNearestEnemyToMidpoint = oUnit
                end
                if iCurDist < iClosestStructureDist and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) and oUnit:GetFractionComplete() >= 0.5 then
                    iClosestStructureDist = iCurDist
                    oNearestEnemyStructureToMidpoint = oUnit
                end
            end
        end
        if M28Utilities.IsTableEmpty(toEnemyACUsInZone) == false and tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] >= 3000 then
            bConsiderAttackingACU = true
        end

        local bOnlyCheckForStructure = true
        if not(oNearestEnemyToMidpoint) then bOnlyCheckForStructure = false end



        function GetUnitToAttackNearestACU(oUnit)
            local oClosestACUToAttack
            local iClosestACU = 100000
            local iCurACUDist
            for iACU, oACU in toEnemyACUsInZone do
                iCurACUDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())
                if iCurACUDist < iClosestACU then
                    iClosestACU = iCurACUDist
                    oClosestACUToAttack = oACU
                end
            end

            if oUnit[M28UnitInfo.refiDFRange] - iClosestACU >= 5 then --ACU more than 5 inside our range - attack it
                M28Orders.IssueTrackedAttack(oUnit, oClosestACUToAttack, false, 'ACUEAt', false)
            else
                M28Orders.IssueTrackedMove(oUnit, oClosestACUToAttack:GetPosition(), (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.4, false, 'ACUEMv'..iLandZone, false)
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to search adjacent land zones for enemies closer to the midpoint; bOnlyCheckForStructure='..tostring(bOnlyCheckForStructure)..'; oNearestEnemyToMidpoint='..(oNearestEnemyToMidpoint.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint) or 'nil')..'; oNearestEnemyStructureToMidpoint='..(oNearestEnemyStructureToMidpoint.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyStructureToMidpoint) or 'nil')) end
        if not(oNearestEnemyToMidpoint) or not(oNearestEnemyStructureToMidpoint) then
            local iModifiedHighestEnemyValue
            if iAvailableCombatUnitThreat >= 300 then
                iModifiedHighestEnemyValue = (tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) + (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) + (tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)
                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                    iModifiedHighestEnemyValue = math.max(1, iModifiedHighestEnemyValue, (tAdjLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) + (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0))
                end
            end
            if iModifiedHighestEnemyValue then iModifiedHighestEnemyValue = iModifiedHighestEnemyValue * 0.75 end --dont worry about adjusting distances if have locations similar in value
            local iDistMod
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]))) end
                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                    if iModifiedHighestEnemyValue and iAvailableCombatUnitThreat >= 3000 and iModifiedHighestEnemyValue >= 1500 then --primarily want the logic for things like experimentals
                        iDistMod = math.max(1,3 - 2 * ((tAdjLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) + (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)) / iModifiedHighestEnemyValue) --i.e. no adjust for highest value zone, down to x3 (i.e. +200%) distance for 0 value structure zone
                        if iDistMod == 1 then iDistMod = nil end
                    else
                        iDistMod = nil
                    end
                    for iUnit, oUnit in tAdjLZTeamData[M28Map.subrefTEnemyUnits] do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then table.insert(tEnemyEngineers, oUnit) end --we might be controlling untis in an adjacent zone that have an enemy unit/engeiner near them
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurdist='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; iClosestDist='..iClosestDist..'; iClosestStructureDist='..iClosestStructureDist..'; iDistMod='..(iDistMod or 'nil')) end
                            if bOnlyCheckForStructure then
                                if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) and oUnit:GetFractionComplete() >= 0.5 then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                                    if iDistMod and not(EntityCategoryContains(M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryLandCombat * categories.EXPERIMENTAL, oUnit.UnitId)) then
                                        iCurDist = iCurDist * iDistMod
                                    end
                                    if iCurDist < iClosestStructureDist and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) then
                                        iClosestStructureDist = iCurDist
                                        oNearestEnemyStructureToMidpoint = oUnit
                                    end
                                end
                            else
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                                if iDistMod then iCurDist = iCurDist * iDistMod end
                                if iCurDist < iClosestDist then
                                    iClosestDist = iCurDist
                                    oNearestEnemyToMidpoint = oUnit
                                end
                                if iCurDist < iClosestStructureDist and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) and oUnit:GetFractionComplete() >= 0.5 then
                                    iClosestStructureDist = iCurDist
                                    oNearestEnemyStructureToMidpoint = oUnit
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Do we have a valid oNearestEnemyToMidpoint='..tostring(M28UnitInfo.IsUnitValid(oNearestEnemyToMidpoint))..'; Are there enemies in adjacnet WZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])..'; tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])) end

            if not(oNearestEnemyToMidpoint) and tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then
                --Consider adjacent water zone enemies (will only consider mobile - i.e. wont update nearest structure unless we're already considering the WZ for a nearest enemy to midpoint)
                local iCurWZ, iCurPond
                for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                    iCurWZ = tSubtable[M28Map.subrefAWZRef]
                    iCurPond = M28Map.tiPondByWaterZone[iCurWZ]
                    local tWZTeamData = M28Map.tPondDetails[iCurPond][M28Map.subrefPondWaterZones][iCurWZ][M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': iCurWZ='..(iCurWZ or 'nil')..'; iCurPond='..(iCurPond or 'nil')..'; tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..(tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')) end
                    if tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 or tWZTeamData[M28Map.subrefWZThreatEnemyAA] > 0 then
                        for iUnit, oUnit in tWZTeamData[M28Map.subrefTEnemyUnits] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to add oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; to nearest enemy to midpoint; Is it valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Is it underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; iClosestDist='..iClosestDist) end
                            if M28UnitInfo.IsUnitValid(oUnit) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) and not(EntityCategoryContains(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryHydro + M28UnitInfo.refCategoryLandScout, oUnit.UnitId)) then
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                                if iCurDist < iClosestDist then
                                    iClosestDist = iCurDist
                                    oNearestEnemyToMidpoint = oUnit
                                end
                                --Note - below effectively means are only considering structures in water if the WZ has combat units in it and there are no enemy units on land nearby (so isn't 100% accurate)
                                if iCurDist < iClosestStructureDist and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) and oUnit:GetFractionComplete() >= 0.5 then
                                    iClosestStructureDist = iCurDist
                                    oNearestEnemyStructureToMidpoint = oUnit
                                end
                            end
                        end
                        if oNearestEnemyToMidpoint then
                            --Check if need manual attack order
                            if EntityCategoryContains(categories.AMPHIBIOUS, oNearestEnemyToMidpoint.UnitId) then bNearestEnemyNeedsManualAttack = true end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished checking adjacent water zones for enemy units, iClosestDist='..iClosestDist..'; oNearestEnemyToMidpoint='..(oNearestEnemyToMidpoint.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint) or 'nil')) end
            end
            if not(oNearestEnemyToMidpoint) then
                if bDebugMessages == true then LOG(sFunctionRef..': LZ has flagged it has enemies here or in adjacent LZ but couldnt find any; iPlateau='..iPlateau..'; LZ='..iLandZone) end
                tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] = false
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for nearest enemy unit, is it valid='..tostring(M28UnitInfo.IsUnitValid(oNearestEnemyToMidpoint))) end
        if oNearestEnemyToMidpoint and M28Conditions.IsLocationInPlayableArea(oNearestEnemyToMidpoint:GetPosition()) then
            if tLZTeamData[M28Map.subrefLZbCoreBase] then
                --Adjust rally points for core base if nearby enemy in case we end up going closer to the enemy instead of furhter away
                if M28Utilities.GetDistanceBetweenPositions(tAmphibiousRallyPoint, tLZData[M28Map.subrefMidpoint]) <= 5 then
                    tAmphibiousRallyPoint = M28Utilities.MoveInDirection(tLZData[M28Map.subrefMidpoint], M28Utilities.GetAngleFromAToB(oNearestEnemyToMidpoint:GetPosition(), tLZData[M28Map.subrefMidpoint]), 40, true, false, true)
                end
                if M28Utilities.GetDistanceBetweenPositions(tRallyPoint, tLZData[M28Map.subrefMidpoint]) <= 5 then
                    tRallyPoint = M28Utilities.MoveInDirection(tLZData[M28Map.subrefMidpoint], M28Utilities.GetAngleFromAToB(oNearestEnemyToMidpoint:GetPosition(), tLZData[M28Map.subrefMidpoint]), 40, true, false, true)
                end
            end


            --Do we have shot blocked on non-skirmisher units, no indirect fire units, and have signficantly more threat than the enemy or are on an island beachhead? If so then move instead of attakc-moving when attacking
            local bMoveBlockedNotAttackMove = false
            if (iFriendlyBestMobileIndirectRange == 0 or tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 3) and (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 1.75 or tLZTeamData[M28Map.refbIslandBeachhead]) then
                bMoveBlockedNotAttackMove = true
            end

            local bConsiderSpecialMMLLogic = false
            local tMMLForSynchronisation = {}
            if (tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] or 0) > 0 then bConsiderSpecialMMLLogic = M28Conditions.DoWeWantToSynchroniseMMLShots(iPlateau, iLandZone, tLZData, tLZTeamData, iTeam, iFriendlyBestMobileIndirectRange, iEnemyBestDFRange) end

            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if should move blocked units, bMoveBlockedNotAttackMove='..tostring(bMoveBlockedNotAttackMove)..'; iFriendlyBestMobileIndirectRange='..(iFriendlyBestMobileIndirectRange or 'nil')..';  tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]='..(tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 'nil')..'; iFriendlyBestMobileDFRange='..(iFriendlyBestMobileDFRange or 'nil')..'; Enemy best DF range='..iEnemyBestDFRange..'; iFriendlyBestMobileIndirectRange='..(iFriendlyBestMobileIndirectRange or 'nil')..'; iEnemyBestStructureDFRange='..(iEnemyBestStructureDFRange or 'nil')..'; Enemy structure threat indirect='..(tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] or 'nil')..'; bEnemyHasNoDFUnits='..tostring(bEnemyHasNoDFUnits or false)..'; iEnemyBestDFRange='..(iEnemyBestDFRange or 'nil')..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] or 'nil')..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal]='..(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 'nil')) end
            --SCENARIO 1 - We outrange enemy DF units (mobile and fix), or have equal range but with significantly more threat at that range
            if ((tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) == 0 or iFriendlyBestMobileDFRange >= 100) and --No long range enemy threat (i.e. t2 arti); and
                    (iFirebaseThreatAdjust == 0 or (iFriendlyBestMobileDFRange >= 100 and iFirebaseThreatAdjust < 6000 and tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= 8000)) and --No enemy firebase or we have large threat that should be able to overwhelm it; and
                    ((iFriendlyBestMobileDFRange or 0) > (iEnemyBestDFRange or 0) or --we outrange enemy with our direct fire, or
                            ((iFriendlyBestMobileIndirectRange or 0) > (iEnemyBestDFRange or 0) and ((iEnemyBestStructureDFRange or 0) > 0 or (tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] or 0) > 0 or (tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] or 0) > 1.4 * (tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)))) then --we have indirect fire with better range than enemy direct fire, and the enemy has structures in this LZ such that we want to attack
                local bAttackWithSameRange = true
                if (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) == 0 and iFirebaseThreatAdjust == 0 and ((iFriendlyBestMobileDFRange or 0) > (iEnemyBestDFRange or 0) or ((iFriendlyBestMobileIndirectRange or 0) > (iEnemyBestDFRange or 0))) then
                    bAttackWithSameRange = false
                end
                if bDebugMessages == true then LOG(sFunctionRef..': In scenario 1, so we either outrange enemy, or we have significantly more threat at their best range - i.e. equal range, bAttackWithSameRange='..tostring(bAttackWithSameRange)) end
                local tOutrangedCombatUnits = {}
                local tUnitsToSupport = {}
                local bAttackWithOutrangedDFUnits = false
                if tLZTeamData[M28Map.subrefLZbCoreBase] and tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] then
                    if bDebugMessages == true then LOG(sFunctionRef..': Are in core base so want to attack with outranged units if enemy is in this zone, subrefbDangerousEnemiesInThisLZ='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])) end
                    bAttackWithOutrangedDFUnits = true
                elseif tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] > 1.3 * math.max(20, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]) then
                    bAttackWithOutrangedDFUnits = true
                    local iBestEnemyStructureRange = tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange]
                    --Change to false if we are likeyl to have outranged DF units and enemy has significant nearby threat
                    local bExpectToHaveOutrangedDF = false
                    for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                        if iThreat > 0 and iRange <= iEnemyBestDFRange then
                            bExpectToHaveOutrangedDF = true
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Our DF Threat '..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]..' exceeds enemy total combat threat '..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..' so want to attack with outranged DF units if this is also the case factoring in adjacent enemy zone threat, bExpectToHaveOutrangedDF='..tostring(bExpectToHaveOutrangedDF)) end
                    local iEnemyCombatThreat = tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        if iFirebaseThreatAdjust == 0 then
                            local tNearbyAdjacentEnemies = {}
                            local tOurDFAndT1ArtiUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandCombat, tAvailableCombatUnits)
                            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                local iAdjacentDistThreshold = 0
                                local iCurDist
                                for iUnit, oUnit in tOurDFAndT1ArtiUnits do
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                    if iCurDist > iAdjacentDistThreshold then iAdjacentDistThreshold = iCurDist end
                                end
                                iAdjacentDistThreshold = iAdjacentDistThreshold + 10
                                --Only include units in the threat calculation if they are close enough to this LZ, or we have a firebase threat adjust
                                if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] > 10 then
                                    iBestEnemyStructureRange = math.max(iBestEnemyStructureRange, (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0))
                                    local tPotentialEnemyUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryPD, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits])
                                    if M28Utilities.IsTableEmpty(tPotentialEnemyUnits) == false then
                                        for iUnit, oUnit in tPotentialEnemyUnits do
                                            if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) - math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0)) <= iAdjacentDistThreshold then
                                                table.insert(tNearbyAdjacentEnemies, oUnit)
                                            end
                                        end
                                    end
                                end
                            end
                            iEnemyCombatThreat = iEnemyCombatThreat + M28UnitInfo.GetCombatThreatRating(tNearbyAdjacentEnemies, false)
                        else
                            local bAdjustStructureThreat = false
                            if tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= 5000 then bAdjustStructureThreat = true end
                            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                --Only include 20% of enemy structure threat in adjacent zones if we have high threat value
                                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                iEnemyCombatThreat = iEnemyCombatThreat + tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]
                                if bAdjustStructureThreat and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will reduce adjacent threat by structure threat, tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]='..repru(tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange])) end
                                    for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                                        if iRange <= 65 then
                                            iEnemyCombatThreat = iEnemyCombatThreat - iThreat * 0.8
                                        end
                                    end
                                end
                            end
                        end

                        if iEnemyCombatThreat * 1.25 > tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] then
                            bAttackWithOutrangedDFUnits = false
                            --Dont charge into PD unless have overwhelming force
                        elseif iBestEnemyStructureRange > 0 and tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] < 8000 and (tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] > iEnemyCombatThreat * 0.15 or (iBestEnemyStructureRange < 50 and tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] <= 2000 and tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] > 0)) and iEnemyCombatThreat * 3 > tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] then
                            bAttackWithOutrangedDFUnits = false
                            if bDebugMessages == true then LOG(sFunctionRef..': Dont ahve overwhelming mobile DF threat and have some indirect fire forces so wont launch all out attack just yet') end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iEnemyCombatThreat after factoring in nearby zones='..iEnemyCombatThreat..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]..'; bAttackWithOutrangedDFUnits='..tostring(bAttackWithOutrangedDFUnits)..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]..'; iBestEnemyStructureRange='..iBestEnemyStructureRange) end
                    end
                end

                local bUpdateNearestUnit = false
                local bCheckIfNearestUnitVisible = false
                if M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToMidpoint:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) >= 10 then bCheckIfNearestUnitVisible = true end

                local tSkirmisherEnemies = {}
                for iUnit, oUnit in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                    --if bDebugMessages == true then LOG(sFunctionRef..': In scenario 1, including enemy unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' in skirmisher enemy table, is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                    table.insert(tSkirmisherEnemies, oUnit)
                end
                table.insert(tSkirmisherEnemies, oNearestEnemyToMidpoint)
                local bMoveToStopPDConstruction = false
                local bMoveTowardsEngineers = false
                if bDebugMessages == true then LOG(sFunctionRef..': In scenario 1, checking if enemy engineers, Is table of enemy engineers empty='..tostring(M28Utilities.IsTableEmpty(tEnemyEngineers))..'; enemy combat='..(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat) end
                if M28Utilities.IsTableEmpty(tEnemyEngineers) == false and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 100 and (iAvailableCombatUnitThreat or 0) >= math.min(40, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 3)  then
                    local tEnemyPD = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD, tLZTeamData[M28Map.subrefTEnemyUnits])
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy PD empty='..tostring(M28Utilities.IsTableEmpty(tEnemyPD))) end
                    if M28Utilities.IsTableEmpty(tEnemyPD) == false then
                        bMoveToStopPDConstruction = true
                        for iPD, oPD in tEnemyPD do
                            if oPD:GetFractionComplete() == 1 then
                                bMoveToStopPDConstruction = false
                                break
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': bMoveToStopPDConstruction before doublechecking threats='..tostring(bMoveToStopPDConstruction)) end
                        if bMoveToStopPDConstruction then
                            --Check we have significantly more threat if excluding under-construction PD
                            bMoveToStopPDConstruction = false
                            local iPDThreat = M28UnitInfo.GetCombatThreatRating(tEnemyPD, true)
                            if bDebugMessages == true then LOG(sFunctionRef..': iPDThreat='..iPDThreat) end
                            if (iAvailableCombatUnitThreat or 0) > 2 * tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] - iPDThreat then
                                bMoveToStopPDConstruction = true
                            end
                        end
                    else
                        --do we have engineers to attack instead?
                        if iAvailableCombatUnitThreat <= 400 then
                            bMoveTowardsEngineers = true
                        end
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Scenario 1 - will cycle through available combat units, is tSkirmisherEnemies empty='..tostring(M28Utilities.IsTableEmpty(tSkirmisherEnemies))..'; oNearestEnemyToMidpoint='..(oNearestEnemyToMidpoint.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint) or 'nil')) end
                for iUnit, oUnit in tAvailableCombatUnits do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit for scenario 1, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; iEnemyBestDFRange='..(iEnemyBestDFRange or 'nil')..'; bEnemyHasNoDFUnits='..tostring(bEnemyHasNoDFUnits or false)..'; Close to enemy unit (DF only) ='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], (oUnit[M28UnitInfo.refiDFRange] or 0) * 0.94, iTeam, false))..'; Was last shot blocked='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked] or false)..'; Is unit underwtaer='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; Can unit kite='..tostring(oUnit[M28UnitInfo.refbCanKite] or false)..'; Is table of enemy engineers empty='..tostring(M28Utilities.IsTableEmpty(tEnemyEngineers))) end

                    --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                    if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end

                    if oUnit[M28UnitInfo.refiDFRange] > iEnemyBestDFRange or (bAttackWithSameRange and oUnit[M28UnitInfo.refiDFRange] >= iEnemyBestDFRange) then
                        table.insert(tUnitsToSupport, oUnit)
                        --Consider kiting logic unless want to use shot blocked override logic
                        if bMoveBlockedNotAttackMove and (oUnit[M28UnitInfo.refbLastShotBlocked] or M28UnitInfo.IsUnitUnderwater(oUnit)) and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId)) then
                            M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'BlckM'..iLandZone)
                        else
                            --Experimental specific - attack ACU if in-range
                            local bUseNormalLogic = true
                            if bConsiderAttackingACU and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryFatboy, oUnit.UnitId) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), toEnemyACUsInZone, 6 + oUnit[M28UnitInfo.refiDFRange], iTeam, false, nil, nil, nil, nil, nil) then
                                GetUnitToAttackNearestACU(oUnit)
                                bUseNormalLogic = false
                            elseif bMoveTowardsEngineers and oUnit[M28UnitInfo.refiDFRange] > 0 and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId)) then
                                local oNearestEngineerToUnit = M28Utilities.GetNearestUnit(tEnemyEngineers, oUnit:GetPosition())
                                if oNearestEngineerToUnit then
                                    --Use normal logic if are almost in reclaim range of the engineer
                                    local iDistToEngineer = M28Utilities.GetDistanceBetweenPositions(oNearestEngineerToUnit:GetPosition(), oUnit:GetPosition())
                                    if bDebugMessages == true then LOG(sFunctionRef..': oNearestEngineerToUnit='..oNearestEngineerToUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEngineerToUnit)..'; iDistToEngineer='..iDistToEngineer..'; oUnit[M28UnitInfo.refiDFRange]='..oUnit[M28UnitInfo.refiDFRange] ..'; Eng build range='..(oNearestEngineerToUnit:GetBlueprint().Economy.MaxBuildDistance or 0)) end
                                    if not(iDistToEngineer <= math.min(oUnit[M28UnitInfo.refiDFRange] - 3, (oNearestEngineerToUnit:GetBlueprint().Economy.MaxBuildDistance or 0) + 5)) then
                                        --Move towards the engineer, or attack move if are close
                                        bUseNormalLogic = false
                                        if iDistToEngineer <= oUnit[M28UnitInfo.refiDFRange] - 2.5 then
                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEngineerToUnit:GetPosition(), math.min(4, oUnit[M28UnitInfo.refiDFRange] * 0.5), false, 'EnAMve'..iLandZone, false)
                                        else
                                            M28Orders.IssueTrackedMove(oUnit, oNearestEngineerToUnit:GetPosition(), math.min(4, oUnit[M28UnitInfo.refiDFRange]  * 0.5), false, 'EnMve'..iLandZone, false)
                                        end
                                    end
                                end
                            end
                            if bUseNormalLogic then
                                --Are we in range of any enemy or cant kite?
                                --CloseToEnemyUnit(tStartPosition,      tUnitsToCheck,         iDistThreshold,             iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure)                                                                                                                                                                                     CloseToEnemyUnit(tStartPosition,      tUnitsToCheck,                                        iDistThreshold,             iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure)
                                if (bEnemyHasNoDFUnits and (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= 1500 or M28Utilities.IsTableEmpty(tEnemyEngineers))) or not(oUnit[M28UnitInfo.refbCanKite]) or (EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId) and not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tSkirmisherEnemies, oUnit[M28UnitInfo.refiDFRange], iTeam, false,                  nil,                    oUnit,                              oUnit                                   ,   math.min(oUnit[M28UnitInfo.refiDFRange], math.max(oUnit[M28UnitInfo.refiDFRange] - 3,  iEnemyBestDFRange + 5))))) or ((not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId)) and (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= 1500 or M28Utilities.IsTableEmpty(tEnemyEngineers) or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tEnemyEngineers, math.min(15, oUnit[M28UnitInfo.refiDFRange] - 4.5), iTeam, false, nil, nil))) and  not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange] * 0.94, iTeam, false,                   nil,                    nil,                                oUnit                                       , math.min(oUnit[M28UnitInfo.refiDFRange] * 0.94, math.max(oUnit[M28UnitInfo.refiDFRange] * 0.94 - 4,  iEnemyBestDFRange + 4)))))) then
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef..': Not in range of enemy yet (or we cant), and we outrange enemy; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..oUnit[M28UnitInfo.refiDFRange]..'; oNearestEnemyToMidpoint='..oNearestEnemyToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint)..'; oNearestEnemyToMidpoint DF range='..(oNearestEnemyToMidpoint[M28UnitInfo.refiDFRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oNearestEnemyToMidpoint:GetPosition())..'; Enemy last recorded position='..repru(oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; LZ midpoint position='..repru(tLZData[M28Map.subrefMidpoint])..'; Is closest enemy unit from last check valid='..tostring(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]))..'; Closeest unit from last check='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or 'nil')..'; Do we have a Sera sniperbot='..tostring(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher * categories.SERAPHIM, oUnit.UnitId)))
                                        if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                                            LOG(sFunctionRef..': Distance to the closest enemy from check='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())..'; Is unit visible='..tostring(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], true))..'; Is unit T1 mobile land='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryMobileLand * categories.TECH1 - categories.COMMAND, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId)))
                                        end
                                    end
                                    --Not in range yet, so attack move to the nearest enemy
                                    if bNearestEnemyNeedsManualAttack then
                                        M28Orders.IssueTrackedAttack(oUnit, oNearestEnemyToMidpoint, false, 'UnderWA', false)
                                    else
                                        --Seraphim sniperbots - issue manual attack as with attack-move we still move closer - decided to try out more generalised for all skirmishers
                                        if EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId) and M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and not(EntityCategoryContains(M28UnitInfo.refCategoryMobileLand * categories.TECH1 - categories.COMMAND, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId)) and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], true) and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()) < oUnit[M28UnitInfo.refiDFRange] then
                                            M28Orders.IssueTrackedAttack(oUnit, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], false, 'InRngEn', false)
                                        else
                                            --Attackmove (unless we have far more threat in this zone and arent a megalith or fatboy)
                                            if bMoveToStopPDConstruction or (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > 5000 and tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 10 and not((oUnit[M28UnitInfo.refiDFRange] or 0) >= 64 or EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryFatboy, oUnit.UnitID))) then
                                                M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'KMve'..iLandZone, false)
                                            else
                                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'KAMve'..iLandZone)
                                            end
                                        end
                                    end
                                else
                                    --Enemy has DF units and they are already in our range
                                    if bNearestEnemyNeedsManualAttack then
                                        if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                            if M28Utilities.GetDistanceBetweenPositions(tAmphibiousRallyPoint, oUnit:GetPosition()) <= 10 then
                                                M28Orders.IssueTrackedAttack(oUnit, oNearestEnemyToMidpoint, false, 'UnderWARA', false)
                                            else
                                                M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AKRetrU'..iLandZone)
                                            end
                                        else
                                            if M28Utilities.GetDistanceBetweenPositions(tRallyPoint, oUnit:GetPosition()) <= 10 then
                                                M28Orders.IssueTrackedAttack(oUnit, oNearestEnemyToMidpoint, false, 'UnderWARB', false)
                                            else
                                                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'KRetrU'..iLandZone)
                                            end
                                        end
                                    elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                        --If the angle towards the rally point is similar to the angle towards the enemy then instead run from the nearest enemy
                                        if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tAmphibiousRallyPoint)) <= 70 then
                                            local tTemporaryRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), 8, true, false, M28Map.bIsCampaignMap)
                                            if M28Utilities.IsTableEmpty(tTemporaryRetreatLocation) == false and NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, tTemporaryRetreatLocation) == iPlateau then
                                                M28Orders.IssueTrackedMove(oUnit, tTemporaryRetreatLocation, 6, false, 'AKRetNE'..iLandZone)
                                            else
                                                M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AKRetFA'..iLandZone)
                                            end
                                        else
                                            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AKRetr'..iLandZone)
                                        end

                                    else
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef..': is refoClosestEnemyFromLastCloseToEnemyUnitCheck valid='..tostring(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])))
                                            if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                                                LOG(sFunctionRef..': Angle from unit to nearest enemy='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())..'; Angle to rally point='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)..'; Angle dif='..M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)))
                                            end
                                        end
                                        if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)) <= 70 then
                                            local tTemporaryRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), 8, true, false, M28Map.bIsCampaignMap)
                                            if bDebugMessages == true then LOG(sFunctionRef..': tTemporaryRetreatLocation='..repru(tTemporaryRetreatLocation)..'; Land label='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tTemporaryRetreatLocation) or 'nil')..'; Island ref='..(tLZData[M28Map.subrefLZIslandRef] or 'nil'))
                                                M28Utilities.DrawLocation(tTemporaryRetreatLocation)
                                            end
                                            if M28Utilities.IsTableEmpty(tTemporaryRetreatLocation) == false and NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tTemporaryRetreatLocation) == tLZData[M28Map.subrefLZIslandRef] then
                                                M28Orders.IssueTrackedMove(oUnit, tTemporaryRetreatLocation, 4, false, 'KRetNE'..iLandZone)
                                            else
                                                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'KRetFA'..iLandZone)
                                            end
                                        else
                                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'KRetr'..iLandZone)
                                        end
                                    end
                                    --If enemy is able to shoot us then get DF support
                                    if not(bAttackWithOutrangedDFUnits) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 4, iTeam, true) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy is close to unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so want to attack with outranged DF units') end
                                        bAttackWithOutrangedDFUnits = true
                                    end
                                end
                            end
                        end
                    else
                        if oUnit[M28UnitInfo.refiDFRange] > 0 then
                            --We dont outrange the enemy, but we do have other units that do

                            --Skirmishers - Still retreat if are in range of enemy, even if we dont outraneg them, as may e.g. be other units that we do outrange
                            if EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we are in range of an enemy unit for a skirmisher as it doesnt have enough DF to outrange enemy DF; bEnemyHasNoDFUnits='..tostring(bEnemyHasNoDFUnits)..'; Is close to enemy='..tostring(not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange] - math.max(2, math.min(8, oUnit[M28UnitInfo.refiDFRange] * 0.1)), iTeam, false)))..'; bAttackWithOutrangedDFUnits='..tostring(bAttackWithOutrangedDFUnits)) end
                                if bAttackWithOutrangedDFUnits then
                                    if bEnemyHasNoDFUnits or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange] - math.max(2, math.min(8, oUnit[M28UnitInfo.refiDFRange] * 0.1)), iTeam, false)) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Not in range of enemy yet, and we outrange enemy; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..oUnit[M28UnitInfo.refiDFRange]..'; oNearestEnemyToMidpoint='..oNearestEnemyToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint)..'; oNearestEnemyToMidpoint DF range='..(oNearestEnemyToMidpoint[M28UnitInfo.refiDFRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oNearestEnemyToMidpoint:GetPosition())..'; Enemy last recorded position='..repru(oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; LZ midpoint position='..repru(tLZData[M28Map.subrefMidpoint])) end
                                        --Not in range yet, so attack move to the nearest enemy
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SK1AMve'..iLandZone)
                                    else
                                        --Enemy has DF units and they are already in our range so retreat
                                        if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ASK1Retr'..iLandZone)
                                        else
                                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'SK1Retr'..iLandZone)
                                        end

                                    end
                                else
                                    --Only attack with skirmishers if wont get in range of enemy unit
                                    if bEnemyHasNoDFUnits or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 8, iTeam, true)) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Not in range of enemy yet, and we outrange enemy; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..oUnit[M28UnitInfo.refiDFRange]..'; oNearestEnemyToMidpoint='..oNearestEnemyToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint)..'; oNearestEnemyToMidpoint DF range='..(oNearestEnemyToMidpoint[M28UnitInfo.refiDFRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oNearestEnemyToMidpoint:GetPosition())..'; Enemy last recorded position='..repru(oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; LZ midpoint position='..repru(tLZData[M28Map.subrefMidpoint])) end
                                        --Not in range yet, so attack move to the nearest enemy
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SK2AMve'..iLandZone)
                                    else
                                        --Enemy has DF units and they are already in our range so retreat
                                        if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ASK2Retr'..iLandZone)
                                        else
                                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'SK2Retr'..iLandZone)
                                        end

                                    end
                                end
                            else
                                table.insert(tOutrangedCombatUnits, oUnit)
                            end
                        elseif oUnit[M28UnitInfo.refiIndirectRange] > 0 then

                            if oUnit[M28UnitInfo.refiIndirectRange] > iEnemyBestDFRange then
                                table.insert(tUnitsToSupport, oUnit)
                                if bConsiderSpecialMMLLogic and EntityCategoryContains(M28UnitInfo.refCategoryMML, oUnit.UnitId) then
                                    table.insert(tMMLForSynchronisation, oUnit)
                                else
                                    iIndirectDistanceInsideRangeThreshold = iIndirectRunFigureNormal
                                    if oUnit[M28UnitInfo.refbWeaponUnpacks] then iIndirectDistanceInsideRangeThreshold = iIndirectDistanceInsideRangeThreshold + iIndirectRunFigureDeployedAdjust end


                                    if bDebugMessages == true then
                                        LOG(sFunctionRef..': Have Indirect unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that outranges the enemy (our IF range='..oUnit[M28UnitInfo.refiIndirectRange]..'; Enemy best DF range='..iEnemyBestDFRange..'), WIll list every unit in the nearest DF enemies and their distance to us; our position='..repru(oUnit:GetPosition()))
                                        for iEnemy, oEnemy in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                                            LOG(sFunctionRef..': oEnemy '..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..' is '..M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())..'; distance based on last known position='..M28Utilities.GetDistanceBetweenPositions(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; oEnemy DF range='..(oEnemy[M28UnitInfo.refiDFRange] or 'nil')..'; Enemy Indirect range='..(oEnemy[M28UnitInfo.refiIndirectRange] or 'nil'))
                                        end
                                    end
                                    --CloseToEnemyUnit(tStartPosition,      tUnitsToCheck,                              iDistThreshold,                                                                                                                                                          iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure)
                                    if not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], math.max(oUnit[M28UnitInfo.refiIndirectRange] - iIndirectDistanceInsideRangeThreshold, math.min(iEnemyBestDFRange + 10, oUnit[M28UnitInfo.refiIndirectRange] - 2)), iTeam, false                  , nil,                  nil,                                oUnit, math.min(iEnemyBestDFRange + 4.5, oUnit[M28UnitInfo.refiIndirectRange] - 2))) then
                                        --Issue specific attack if there is a structure in range due to issue where MMLs dont fire at certain buildings (such as PD) that are in range until getting close
                                        if bDebugMessages == true then
                                            if oNearestEnemyStructureToMidpoint then
                                                LOG(sFunctionRef..': Not too close, will attack structure if it is within our range, oNearestEnemyStructureToMidpoint='..(oNearestEnemyStructureToMidpoint.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyStructureToMidpoint) or 'nil')..'; Dist to this='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyStructureToMidpoint:GetPosition())..'; Dist between actual position and last known position='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyStructureToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oNearestEnemyStructureToMidpoint:GetPosition()))
                                            else
                                                LOG(sFunctionRef..': Not too close but dont have a nearest enemy structure to midpoint so will just to attack move (or gorund attack in some cases)')
                                            end
                                        end
                                        if (oNearestEnemyStructureToMidpoint and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyStructureToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) < oUnit[M28UnitInfo.refiIndirectRange]) then
                                            M28Orders.IssueTrackedAttack(oUnit, oNearestEnemyStructureToMidpoint, false, 'ISAtc'..iLandZone, false)
                                        elseif M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()) < oUnit[M28UnitInfo.refiIndirectRange] then
                                            M28Orders.IssueTrackedAttack(oUnit, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], false, 'INSAtc'..iLandZone, false)
                                        else
                                            --If have aoe attack and nearest enemy is in range and we havent fired recently and the nearest enemy isnt moving, but we have temporarily lost intel of it, then ground fire it
                                            if (oUnit[M28UnitInfo.refiIndirectAOE] or 0) > 0 and oUnit[M28UnitInfo.refiTimeBetweenIFShots] and M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:IsUnitState('Moving')) and not(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], true)) and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or -1) > 1 + oUnit[M28UnitInfo.refiTimeBetweenIFShots] * 1.2 and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()) <= (oUnit[M28UnitInfo.refiIndirectRange] or 0) then
                                                M28Orders.IssueTrackedGroundAttack(oUnit, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), math.min(1, oUnit[M28UnitInfo.refiIndirectAOE] * 0.5), false, 'IHidAtc', false)
                                            else
                                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(15, iIndirectDistanceInsideRangeThreshold), false, 'IKAMve'..iLandZone)
                                            end
                                        end
                                    else
                                        --Retreat IF units (will only have IF units if are at this point) temporarily from enemy units, unless we are a T1-T2 indirect fire unit that hasnt fired for a while and enemy isn't in our range yet
                                        if (oUnit[M28UnitInfo.refiIndirectAOE] or 0) > 0 and oUnit[M28UnitInfo.refiTimeBetweenIFShots] and M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or -1) > 1 + oUnit[M28UnitInfo.refiTimeBetweenIFShots] * 1.2 and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()) > (oUnit[M28UnitInfo.refiIndirectRange] or 0) then

                                            --Ground fire near the enemy unit
                                            --MoveInDirection(tStart, iAngle, iDistance, bKeepInMapBounds, bTravelUnderwater, bKeepInCampaignPlayableArea)
                                            local tGroundFireLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()), oUnit[M28UnitInfo.refiIndirectRange] - 2, true, false, M28Map.bIsCampaignMap)
                                            M28Orders.IssueTrackedGroundAttack(oUnit, tGroundFireLocation, 2, false, 'IFKiAG'..iLandZone, false, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])
                                        elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AIKRetr'..iLandZone)
                                        else
                                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'IKRetr'..iLandZone)
                                        end
                                    end
                                end
                            else
                                --Treat the same as outranged DF units
                                table.insert(tOutrangedCombatUnits, oUnit)
                            end
                        else
                            M28Utilities.ErrorHandler('Have a unit without DF or indirect range, so will retreat with it')
                            if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AUnkRetr'..iLandZone)
                            else
                                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'UnkRetr'..iLandZone)
                            end
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tOutrangedCombatUnits) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have outranged combat units, bAttackWithOutrangedDFUnits='..tostring(bAttackWithOutrangedDFUnits or false)) end
                    if bAttackWithOutrangedDFUnits then
                        for iUnit, oUnit in tOutrangedCombatUnits do
                            if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end

                            if bMoveBlockedNotAttackMove and (oUnit[M28UnitInfo.refbLastShotBlocked] or M28UnitInfo.IsUnitUnderwater(oUnit)) and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId)) then
                                M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'OBlckM'..iLandZone)
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                            else
                                if bConsiderAttackingACU and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryFatboy, oUnit.UnitId) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), toEnemyACUsInZone, 6 + oUnit[M28UnitInfo.refiDFRange], iTeam, false, nil, nil, nil, nil, nil) then
                                    GetUnitToAttackNearestACU(oUnit)
                                    --Attackmove (unless we have far more threat in this zone)
                                else
                                    oUnit[refoSREnemyTarget] = oNearestEnemyToMidpoint
                                    oUnit[refiTimeOfSREnemyTarget] = GetGameTimeSeconds()
                                    if tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > 5000 and tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 10 and not((oUnit[M28UnitInfo.refiDFRange] or 0) >= 64 or EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryFatboy, oUnit.UnitID)) then
                                        M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SRDFM'..iLandZone, false)
                                    else
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SRDFA'..iLandZone)
                                    end
                                end
                            end
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of units to support empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToSupport))) end
                        if M28Utilities.IsTableEmpty(tUnitsToSupport) == false then
                            --Short range DF units can stay back and provide support - stay inbetween our long range DF units and the rally point

                            local iCurDist
                            local iClosestDist = 100000
                            local oClosestUnit
                            local iDistToRetreat = 10
                            local bNearestEnemyIsExperimental = false
                            if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oNearestEnemyToMidpoint.UnitId) then
                                bNearestEnemyIsExperimental = true
                            end


                            for iSRUnit, oSRUnit in tOutrangedCombatUnits do
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oSRUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                                iClosestDist = 100000
                                for iLRUnit, oLRUnit in tUnitsToSupport do
                                    iCurDist = M28Utilities.GetRoughDistanceBetweenPositions(oSRUnit:GetPosition(), oLRUnit:GetPosition())
                                    if iCurDist < iClosestDist then
                                        iClosestDist = iCurDist
                                        oClosestUnit = oLRUnit
                                    end
                                end
                                if bNearestEnemyIsExperimental and not(EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oSRUnit.UnitId)) then iDistToRetreat = 18
                                else iDistToRetreat = 10
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': oSRUnit='..oSRUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSRUnit)..'; oSRUnit[M28UnitInfo.refbCanKite]='..tostring(oSRUnit[M28UnitInfo.refbCanKite] or false)..'; iClosestDist='..iClosestDist..'; oClosestUnit='..(oClosestUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestUnit))..'; do we have an amphibious oSRUnit='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oSRUnit.UnitId))..'; iDistToRetreat='..iDistToRetreat) end
                                if bConsiderAttackingACU and not(oSRUnit[M28UnitInfo.refbLastShotBlocked]) and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryFatboy, oSRUnit.UnitId) and M28Conditions.CloseToEnemyUnit(oSRUnit:GetPosition(), toEnemyACUsInZone, 6 + oSRUnit[M28UnitInfo.refiDFRange], iTeam, false, nil, nil, nil, nil, nil) then
                                    GetUnitToAttackNearestACU(oSRUnit)
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oSRUnit.UnitId) then
                                    if oSRUnit[M28UnitInfo.refbCanKite] then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want unit to move to position '..repru(M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), tAmphibiousRallyPoint), 5, true, false, true))..'; cur position='..repru(oSRUnit:GetPosition())..'; Last orders='..reprs(oSRUnit[M28Orders.reftiLastOrders])) end
                                        M28Orders.IssueTrackedMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), tAmphibiousRallyPoint), iDistToRetreat, true, false, true), 5, false, 'ASRSup'..iLandZone)
                                    else
                                        M28Orders.IssueTrackedAttackMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), tAmphibiousRallyPoint), iDistToRetreat, true, false, true), 5, false, 'AASRSup'..iLandZone)
                                    end

                                else
                                    if oSRUnit[M28UnitInfo.refbCanKite] then
                                        M28Orders.IssueTrackedMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), tRallyPoint), iDistToRetreat, true, false, true), 4, false, 'SRSup'..iLandZone)
                                    else
                                        M28Orders.IssueTrackedAttackMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), tRallyPoint), iDistToRetreat, true, false, true), 4, false, 'SRASup'..iLandZone)
                                    end
                                end
                            end
                        else
                            M28Utilities.ErrorHandler('We somehow think we outrange the enemy with DF units, but have no DF units with a long range')
                        end
                    end
                end

                if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 1.5 > iAvailableCombatUnitThreat then
                    bWantReinforcements = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Want reinforcements as enemy combat DF exceeds our combat rating, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Our combat units rating='..iAvailableCombatUnitThreat) end
                end

                if bUpdateNearestUnit then
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                        if aiBrain then
                            M28Team.UpdateUnitLastKnownPosition(aiBrain, oNearestEnemyToMidpoint, true)
                        end
                    else
                        M28Utilities.ErrorHandler('No active M28 brain')
                    end
                end
            else
                --SCENARIO 2 - we dont outrange enemy with DF, but have slightly more threat than them, or have nowhere left to run
                local bAttackWithEverything = false
                if tLZTeamData[M28Map.subrefLZbCoreBase] and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false or M28UnitInfo.GetCombatThreatRating(tAvailableCombatUnits) >= 2500) then
                    --Attack with everything if enemy has any units in core zone, or close to core zone
                    if bDebugMessages == true then LOG(sFunctionRef..': Core base, so attack if enemies here, is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))) end
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                        bAttackWithEverything = true
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': No enemies in this zone, distance of nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToMidpoint:GetPosition(), tLZData[M28Map.subrefMidpoint])..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]..'; Is nearest structure to midpoint valid='..tostring(M28UnitInfo.IsUnitValid(oNearestEnemyStructureToMidpoint))) end

                        if oNearestEnemyToMidpoint then
                            local iDistToNearestEnemy
                            iDistToNearestEnemy = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToMidpoint:GetPosition(), tLZData[M28Map.subrefMidpoint])
                            if iDistToNearestEnemy <= 80 or (iDistToNearestEnemy <= 120 and tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] <= 300) or (iDistToNearestEnemy <= 130 and EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oNearestEnemyToMidpoint.UnitId)) then
                                --Attack with everything unless nearest enemy unit is a structure and we have indirect threat in this zone or that zone that outranges it

                                bAttackWithEverything = true
                            elseif oNearestEnemyStructureToMidpoint and M28Utilities.GetDistanceBetweenPositions(oNearestEnemyStructureToMidpoint:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= 160 and iFriendlyBestMobileIndirectRange >= 50 then
                                bAttackWithEverything = true
                            end
                            if bDebugMessages == true and oNearestEnemyStructureToMidpoint then LOG(sFunctionRef..': oNearestEnemyStructureToMidpoint='..oNearestEnemyStructureToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyStructureToMidpoint)..'; Distance to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyStructureToMidpoint:GetPosition(), tLZData[M28Map.subrefMidpoint])..'; IF range='..iFriendlyBestMobileIndirectRange..'; bAttackWithEverything='..tostring(bAttackWithEverything)) end
                        end
                        if not(bAttackWithEverything) then
                            --Still attack if we have significant threat
                            if table.getn(tAvailableCombatUnits) >= 60 then bAttackWithEverything = true end
                        end
                    end
                else
                    --Are we close to a core zone and enemy has a structure threat in this zone and we haev indirect fire?
                    if bDebugMessages == true and oNearestEnemyStructureToMidpoint then LOG(sFunctionRef..': Non core zone, oNearestEnemyStructureToMidpoint'..oNearestEnemyStructureToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyStructureToMidpoint)..'; Dist to closest friendly base from this zone midpoint='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase])..'; Enemy structure value='..tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] >= 100) end
                    if oNearestEnemyStructureToMidpoint and iFriendlyBestMobileIndirectRange >= 50 and tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] >= 100 and M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 175 then
                        bAttackWithEverything = true
                    end
                end
                local tOurDFAndT1ArtiUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandCombat, tAvailableCombatUnits)
                local bConsolidateAtMidpoint = false
                local iOurCombatThreat
                if M28Utilities.IsTableEmpty(tOurDFAndT1ArtiUnits) == false then
                    iOurCombatThreat = M28UnitInfo.GetCombatThreatRating(tOurDFAndT1ArtiUnits, false)
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false then
                        if M28Map.iMapSize > 256 then
                            iOurCombatThreat = iOurCombatThreat + M28UnitInfo.GetCombatThreatRating(tLZTeamData[M28Map.subrefAlliedACU], false) * 0.9
                        else
                            iOurCombatThreat = iOurCombatThreat + M28UnitInfo.GetCombatThreatRating(tLZTeamData[M28Map.subrefAlliedACU], false)
                        end
                    end
                    if M28Utilities.IsTableEmpty(tUnavailableUnitsInThisLZ) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..'; Combat threat before including unavailable units='..iOurCombatThreat..'; Threat of unavailable units in this LZ='..M28UnitInfo.GetCombatThreatRating(tUnavailableUnitsInThisLZ, false)) end
                        iOurCombatThreat = iOurCombatThreat + M28UnitInfo.GetCombatThreatRating(tUnavailableUnitsInThisLZ, false)
                    end


                    --Check the threat of our available combat units vs threat of enemy combat units
                    local iEnemyCombatThreat = tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] + iFirebaseThreatAdjust + tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat]
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        if iFirebaseThreatAdjust == 0 then
                            local tNearbyAdjacentEnemies = {}

                            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                local iAdjacentDistThreshold = 0
                                local iCurDist
                                local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                                for iUnit, oUnit in tOurDFAndT1ArtiUnits do
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                    if iCurDist > iAdjacentDistThreshold then iAdjacentDistThreshold = iCurDist end
                                end
                                iAdjacentDistThreshold = iAdjacentDistThreshold + 10
                                --Only include units in the threat calculation if they are close enough to this LZ, or we have a firebase threat adjust
                                if tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] > 10 then
                                    local tPotentialEnemyUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryPD, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits])
                                    if M28Utilities.IsTableEmpty(tPotentialEnemyUnits) == false then
                                        for iUnit, oUnit in tPotentialEnemyUnits do
                                            if oUnit:GetFractionComplete() >= 0.95 then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to include enemy unit in nearby adjacent enemies, dist to this LZ midpoint='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])..'; Combat range='..math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0))..'; iAdjacentDistThreshold='..iAdjacentDistThreshold) end
                                                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) - math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0)) <= iAdjacentDistThreshold then
                                                    table.insert(tNearbyAdjacentEnemies, oUnit)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            iEnemyCombatThreat = iEnemyCombatThreat + M28UnitInfo.GetCombatThreatRating(tNearbyAdjacentEnemies, false)
                        else
                            local bAdjustStructureThreat = false
                            if tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= 5000 then bAdjustStructureThreat = true end

                            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                iEnemyCombatThreat = iEnemyCombatThreat + tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]
                                if bAdjustStructureThreat and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will reduce threat by structure threat, tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]='..repru(tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange])) end
                                    for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                                        if iRange <= 65 then
                                            iEnemyCombatThreat = iEnemyCombatThreat - iThreat * 0.8
                                        end
                                    end
                                end
                            end
                        end
                    end
                    local iOurDFAndT1ArtiUnits = table.getn(tOurDFAndT1ArtiUnits)
                    if not(bAttackWithEverything) and iOurDFAndT1ArtiUnits >= 125 and iOurDFAndT1ArtiUnits - table.getn(tLZTeamData[M28Map.subrefTEnemyUnits]) >= 50 then bAttackWithEverything = true end
                    if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to attack with everything - pre firebase and beachhead adjust bAttackWithEverything='..tostring(bAttackWithEverything)..'; iOurCombatThreat='..iOurCombatThreat..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; iFirebaseThreatAdjust='..iFirebaseThreatAdjust..'; bHaveSignificantCombatCloserToFirebase='..tostring(bHaveSignificantCombatCloserToFirebase)..'; tLZTeamData[M28Map.subrefLZTValue]='..tLZTeamData[M28Map.subrefLZTValue]..'; Have enough threat to attack='..tostring(M28Conditions.HaveEnoughThreatToAttack(tLZTeamData, iOurCombatThreat, iEnemyCombatThreat, iFirebaseThreatAdjust, bHaveSignificantCombatCloserToFirebase, iTeam))..'; oNearestEnemyToMidpoint='..oNearestEnemyToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint)..'; Is brain civilian='..tostring(M28Conditions.IsCivilianBrain(oNearestEnemyToMidpoint:GetAIBrain()))) end
                    if not(bAttackWithEverything) and (not(EntityCategoryContains(M28UnitInfo.refCategoryPD, oNearestEnemyToMidpoint.UnitId)) or not(M28Conditions.IsCivilianBrain(oNearestEnemyToMidpoint:GetAIBrain()))) and M28Conditions.HaveEnoughThreatToAttack(tLZTeamData, iOurCombatThreat, iEnemyCombatThreat, iFirebaseThreatAdjust, bHaveSignificantCombatCloserToFirebase, iTeam) then
                        --Extra check if have a firebase - only want to include friendly units that are near our closest unit to enemy firebase
                        if iClosestFriendlyUnitToAnEnemyFirebase <= 170 and iFirebaseThreatAdjust > 0 then
                            --Get new combat threat based on allied mobile DF and indirect fire units around this unit
                            local iSearchRange = math.max(40, math.min(140, 15 + table.getn(tOurDFAndT1ArtiUnits)))

                            local iNearbyCombatThreat = math.min(iOurCombatThreat, M28UnitInfo.GetCombatThreatRating(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains][1]:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat, oClosestFriendlyUnitToAnEnemyFirebase:GetPosition(), iSearchRange, 'Ally'), false))
                            if bDebugMessages == true then LOG(sFunctionRef..': Nearby combat threat='..iNearbyCombatThreat..'; iEnemyCombatThreat='..iEnemyCombatThreat) end
                            if iNearbyCombatThreat > iEnemyCombatThreat * 1.5 or (iNearbyCombatThreat > iEnemyCombatThreat * 1.15 and iNearbyCombatThreat >= 20000) or (iNearbyCombatThreat > iEnemyCombatThreat and bHaveSignificantCombatCloserToFirebase) then
                                bAttackWithEverything = true
                            else
                                bAttackWithEverything = false
                                bConsolidateAtMidpoint = true
                            end
                        else
                            bAttackWithEverything = true
                        end


                    end
                    if not(bAttackWithEverything) and tLZTeamData[M28Map.refbIslandBeachhead] then
                        --May have units nearby underwater that want to include
                        local iSearchRange = math.max(40, math.min(140, 15 + table.getn(tOurDFAndT1ArtiUnits)))

                        local oClosestFriendlyToEnemy
                        local iCurDist
                        local iClosestDist = 100000
                        for iUnit, oUnit in tAvailableCombatUnits do
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oClosestFriendlyToEnemy = oUnit
                            end
                        end
                        local iNearbyCombatThreat = math.max(iOurCombatThreat, M28UnitInfo.GetCombatThreatRating(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains][1]:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat, oClosestFriendlyToEnemy:GetPosition(), iSearchRange, 'Ally'), false))
                        if iNearbyCombatThreat > iEnemyCombatThreat then
                            bAttackWithEverything = true
                        elseif iNearbyCombatThreat > 1.2 * tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] and tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] then
                            bAttackWithEverything = true
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Island beachhead Nearby combat threat='..iNearbyCombatThreat..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; bAttackWithEverythign='..tostring(bAttackWithEverything)..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])) end
                    end

                    if iOurCombatThreat < iEnemyCombatThreat * 1.4 or not(bAttackWithEverything) then
                        bWantReinforcements = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Want reinforcements as iOurCombatThreat='..iOurCombatThreat..'; iEnemyCombatThreat='..iEnemyCombatThreat) end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': We dont outrange enemy, considering if we have much more threat than them, iEnemyCombatThreat='..iEnemyCombatThreat..'; iOurCombatThreat='..iOurCombatThreat..'; bWantReinforcements='..tostring(bWantReinforcements)..'; bAttackWithEverything='..tostring(bAttackWithEverything)..'; iClosestFriendlyUnitToAnEnemyFirebase='..iClosestFriendlyUnitToAnEnemyFirebase..'; iFirebaseThreatAdjust='..iFirebaseThreatAdjust) end
                else
                    if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                        bWantReinforcements = true
                        if bDebugMessages == true then LOG(sFunctionRef..': We have no friendly units in this LZ but enemy has units here or adjacent LZ so want reinforcements. iFriendlyBestMobileIndirectRange='..iFriendlyBestMobileIndirectRange..'; Is there a valid enemy structure to midpoint='..tostring(M28UnitInfo.IsUnitValid(oNearestEnemyStructureToMidpoint))) end
                    end
                    if iFriendlyBestMobileIndirectRange == 0 or not(oNearestEnemyStructureToMidpoint) then
                        bAttackWithEverything = false
                    end
                end
                if not(bAttackWithEverything) and oNearestEnemyToMidpoint and (tLZTeamData[M28Map.subrefLZbCoreBase] or tLZTeamData[M28Map.subrefLZCoreExpansion]) then
                    --Is enemy almost in range of the midpoint for this zone such that we want to attack even though we will probably lose?

                    if M28Utilities.GetDistanceBetweenPositions(       tLZData[M28Map.subrefMidpoint], oNearestEnemyToMidpoint:GetPosition()) <= 15 + math.max((oNearestEnemyToMidpoint[M28UnitInfo.refiIndirectRange] or 0), (oNearestEnemyToMidpoint[M28UnitInfo.refiDFRange] or 0)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy unit is almost in range of our midpoint') end
                        bAttackWithEverything = true
                        --CloseToEnemyUnit(tStartPosition,                  tUnitsToCheck,                              iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure)
                    elseif M28Conditions.CloseToEnemyUnit(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftoNearestDFEnemies],    10,             iTeam, true                  , nil,                  nil,                                nil,                                       nil) then
                        bAttackWithEverything = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy DF units are almost in range of our midpoint') end
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Dont outrange enemy, bAttackWithEverything='..tostring(bAttackWithEverything)..'; Is table of ACUs in the LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]))) end
                local bUpdateNearestUnit = false
                local bCheckIfNearestUnitVisible = bUpdateNearestUnit
                if not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToMidpoint:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) >= 10 then
                    bCheckIfNearestUnitVisible = true
                end

                if bAttackWithEverything then
                    local bMoveToStopPDConstruction = false
                    if bDebugMessages == true then LOG(sFunctionRef..': Seeing if we have enough threat to try and stop PD being built, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; iAvailableCombatUnitThreat='..(iAvailableCombatUnitThreat or 'nil')) end
                    if M28Utilities.IsTableEmpty(tEnemyEngineers) == false and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 100 and (iAvailableCombatUnitThreat or 0) >= math.min(40, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 3)  then
                        local tEnemyPD = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD, tLZTeamData[M28Map.subrefTEnemyUnits])
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy PD empty='..tostring(M28Utilities.IsTableEmpty(tEnemyPD))) end
                        if M28Utilities.IsTableEmpty(tEnemyPD) == false then
                            bMoveToStopPDConstruction = true
                            for iPD, oPD in tEnemyPD do
                                if oPD:GetFractionComplete() == 1 then
                                    bMoveToStopPDConstruction = false
                                    break
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': bMoveToStopPDConstruction before doublechecking threats='..tostring(bMoveToStopPDConstruction)) end
                            if bMoveToStopPDConstruction then
                                --Check we have significantly more threat if excluding under-construction PD
                                bMoveToStopPDConstruction = false
                                local iPDThreat = M28UnitInfo.GetCombatThreatRating(tEnemyPD, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': iPDThreat='..iPDThreat) end
                                if (iAvailableCombatUnitThreat or 0) > 2 * tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] - iPDThreat then
                                    bMoveToStopPDConstruction = true
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Will attack with everything, oNearestEnemyToMidpoint='..oNearestEnemyToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oNearestEnemyToMidpoint))..'; oNearestEnemyToMidpoint position='..repru(oNearestEnemyToMidpoint:GetPosition())..'; Last known position='..repru(oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; bMoveToStopPDConstruction='..tostring(bMoveToStopPDConstruction or false)) end
                    local bMoveTowardsEngineers = false
                    if M28Utilities.IsTableEmpty(tEnemyEngineers) == false and iAvailableCombatUnitThreat <= 400 and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 100 and (iAvailableCombatUnitThreat or 0) >= math.min(40, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 3)  then
                        bMoveTowardsEngineers = true
                    end

                    for iUnit, oUnit in tAvailableCombatUnits do
                        --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                        if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                        if bDebugMessages == true then LOG(sFunctionRef..': Attacking with everything, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                        if oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                            if oUnit[M28UnitInfo.refiIndirectRange] >= iEnemyBestDFRange then
                                if bConsiderSpecialMMLLogic and EntityCategoryContains(M28UnitInfo.refCategoryMML, oUnit.UnitId) then table.insert(tMMLForSynchronisation, oUnit)
                                else
                                    iIndirectDistanceInsideRangeThreshold = iIndirectRunFigureNormal
                                    if oUnit[M28UnitInfo.refbWeaponUnpacks] then iIndirectDistanceInsideRangeThreshold = iIndirectDistanceInsideRangeThreshold + iIndirectRunFigureDeployedAdjust end

                                    if not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], math.max(oUnit[M28UnitInfo.refiIndirectRange] - iIndirectDistanceInsideRangeThreshold, math.min(iEnemyBestDFRange + 10, oUnit[M28UnitInfo.refiIndirectRange] - 2)), iTeam, false)) then
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(15, iIndirectDistanceInsideRangeThreshold), false, 'I2KAMve'..iLandZone)
                                    else
                                        --Retreat temporarily from enemy units
                                        if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AI2KRetr'..iLandZone)
                                        else
                                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'I2KRetr'..iLandZone)
                                        end
                                    end
                                end
                            else
                                --Treat the same as outranged DF units
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'I2AWE'..iLandZone)
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId) then
                            --Still retreat if are in range of enemy, even if we dont outraneg them, as may e.g. be other units that we do outrange
                            if bEnemyHasNoDFUnits or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange] - math.max(2, oUnit[M28UnitInfo.refiDFRange] * 0.06), iTeam, false)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Not in range of enemy yet, and we outrange enemy; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..oUnit[M28UnitInfo.refiDFRange]..'; oNearestEnemyToMidpoint='..oNearestEnemyToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint)..'; oNearestEnemyToMidpoint DF range='..(oNearestEnemyToMidpoint[M28UnitInfo.refiDFRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oNearestEnemyToMidpoint:GetPosition())..'; Enemy last recorded position='..repru(oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; LZ midpoint position='..repru(tLZData[M28Map.subrefMidpoint])) end
                                --Not in range yet, so attack move to the nearest enemy
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SKAMve'..iLandZone)
                            else
                                --Enemy has DF units and they are already in our range so retreat
                                if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                    M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ASKRetr'..iLandZone)
                                else
                                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'SKRetr'..iLandZone)
                                end

                            end
                        else
                            if bMoveBlockedNotAttackMove and (oUnit[M28UnitInfo.refbLastShotBlocked] or M28UnitInfo.IsUnitUnderwater(oUnit)) and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId)) then
                                M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'BAWE'..iLandZone)
                            else
                                if bConsiderAttackingACU and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryFatboy, oUnit.UnitId) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), toEnemyACUsInZone, 6 + oUnit[M28UnitInfo.refiDFRange], iTeam, false, nil, nil, nil, nil, nil) then
                                    GetUnitToAttackNearestACU(oUnit)

                                    --Fatboy and megalith - want to be more cautious than normal units but less so than skirmishers
                                elseif (oUnit[M28UnitInfo.refiDFRange] or 0) >= 64 and EntityCategoryContains(M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryMegalith, oUnit.UnitID) then
                                    --Attackmove unless enemy threat is minimal in this zone and dont have notable neemies in range using getunitsaroundpoint
                                    if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 1500 and M28Utilities.IsTableEmpty(oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryNavalSurface - categories.TECH1 - categories.TECH2 * categories.MOBILE * categories.LAND + categories.COMMAND, oUnit:GetPosition(), (oUnit[M28UnitInfo.refiDFRange] or 0), 'Enemy')) then
                                        M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'FBMWE'..iLandZone, false)
                                    else
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'FBAWE'..iLandZone)
                                    end

                                    --Attackmove (unless we have far more threat in this zone)
                                else
                                    local bUseNormalLogic = true
                                    if bMoveTowardsEngineers and oUnit[M28UnitInfo.refiDFRange] > 0 and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId)) then
                                        local oNearestEngineerToUnit = M28Utilities.GetNearestUnit(tEnemyEngineers, oUnit:GetPosition())
                                        if oNearestEngineerToUnit then
                                            --Use normal logic if are almost in reclaim range of the engineer
                                            local iDistToEngineer = M28Utilities.GetDistanceBetweenPositions(oNearestEngineerToUnit:GetPosition(), oUnit:GetPosition())
                                            if bDebugMessages == true then LOG(sFunctionRef..': oNearestEngineerToUnit='..oNearestEngineerToUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEngineerToUnit)..'; iDistToEngineer='..iDistToEngineer..'; oUnit[M28UnitInfo.refiDFRange]='..oUnit[M28UnitInfo.refiDFRange] ..'; Eng build range='..(oNearestEngineerToUnit:GetBlueprint().Economy.MaxBuildDistance or 0)) end
                                            if not(iDistToEngineer <= math.min(oUnit[M28UnitInfo.refiDFRange] - 3, (oNearestEngineerToUnit:GetBlueprint().Economy.MaxBuildDistance or 0) + 5)) then
                                                --Move towards the engineer, or attack move if are close
                                                bUseNormalLogic = false
                                                if iDistToEngineer <= oUnit[M28UnitInfo.refiDFRange] - 2.5 then
                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEngineerToUnit:GetPosition(), math.min(4, oUnit[M28UnitInfo.refiDFRange] * 0.5), false, 'EnS2AMve'..iLandZone, false)
                                                else
                                                    M28Orders.IssueTrackedMove(oUnit, oNearestEngineerToUnit:GetPosition(), math.min(4, oUnit[M28UnitInfo.refiDFRange]  * 0.5), false, 'EnS2Mve'..iLandZone, false)
                                                end
                                            end
                                        end
                                    end
                                    if bUseNormalLogic then
                                        if (bMoveToStopPDConstruction and not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tEnemyEngineers, math.min(15, oUnit[M28UnitInfo.refiDFRange] - 4.5), iTeam, false, nil, nil))) or (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > 5000 and not((oUnit[M28UnitInfo.refiDFRange] or 0) >= 64 or EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitID)) and
                                                ((tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 6) or
                                                        --If lots of T1 arti want to keep moving with experimentals/other units or theyll get slaughtered
                                                        (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 1.1 and EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and (tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] >= 400 or EntityCategoryContains(M28UnitInfo.refCategoryIndirect + M28UnitInfo.refCategorySkirmisher, oNearestEnemyToMidpoint.UnitId))))) then

                                            M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'MWE'..iLandZone, false)
                                        else
                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'AWE'..iLandZone)
                                        end
                                    end
                                end
                            end
                        end
                    end
                else
                    --SCENARIO 3 - Enemy outranges us and we dont ahve enough threat / high enough priority location to defend so want to retreat; exception to this if enemy has an experimental unit and it is in the same LZ as us, in which case want to attack with any units that are within 10 of being in range of it
                    --Also exceptio nif we have an experimental unit that cant kite, in which case it will attack-move to the rally point
                    local tNearbyEnemyExperimentals
                    local bConsiderAttackingExperimental = false
                    if oNearestEnemyToMidpoint then
                        tNearbyEnemyExperimentals = EntityCategoryFilterDown(categories.EXPERIMENTAL, tLZTeamData[M28Map.reftoNearestDFEnemies])
                        if M28Utilities.IsTableEmpty(tNearbyEnemyExperimentals) == false then
                            bConsiderAttackingExperimental = true
                        end
                    end

                    local sRetreatMessage = 'GenRetr'

                    --Rescue ACU - move slightly infront of ACU relative to our closest base instead of retreating
                    if tLZTeamData[M28Map.refbACUInTrouble] and oNearestEnemyToMidpoint and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false then
                        local oACUToProtect
                        local iLowestHealthACU = 100000
                        for iACU, oACU in tLZTeamData[M28Map.subrefAlliedACU] do
                            if oACU:GetHealth() < iLowestHealthACU then
                                iLowestHealthACU = oACU:GetHealth()
                                oACUToProtect = oACU
                            end
                        end
                        local iDistInfrontOfACUWanted = math.min(20, 5 + table.getn(tAvailableCombatUnits) * 0.25)
                        local tProtectiveMovePoint = M28Utilities.MoveInDirection(oACUToProtect:GetPosition(), M28Utilities.GetAngleFromAToB(tLZTeamData[M28Map.reftClosestFriendlyBase], oACUToProtect:GetPosition()), iDistInfrontOfACUWanted, true, false, M28Map.bIsCampaignMap)
                        local iAltPlateau, iAltLandZone
                        if tProtectiveMovePoint then iAltPlateau, iAltLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tProtectiveMovePoint) end
                        if not(iAltPlateau == iPlateau) then
                            --GetPositionAtOrNearTargetInPathingGroup(tStartPos,                 tTargetPos,            iDistanceFromTargetToStart, iAngleAdjust, oPathingUnit, bMoveCloserBeforeFurtherIfBlocked, bCheckIfExistingTargetIsBetter, iMinDistanceFromExistingCommandTarget)
                            tProtectiveMovePoint = M28Map.GetPositionAtOrNearTargetInPathingGroup(tProtectiveMovePoint,         oACUToProtect:GetPosition(),        iDistInfrontOfACUWanted,  0,    oACUToProtect,       true,                              false,                           nil)
                            if not(tProtectiveMovePoint) then tProtectiveMovePoint = oACUToProtect:GetPosition() end
                        end
                        local iACUDistToAlliedBase = M28Utilities.GetDistanceBetweenPositions(oACUToProtect:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to try and protect ACU, iACUDistToAlliedBase='..iACUDistToAlliedBase..'; tProtectiveMovePoint='..repru(tProtectiveMovePoint)..'; ACU position='..repru(oACUToProtect:GetPosition())) end
                        for iUnit, oUnit in tAvailableCombatUnits do
                            --If further from allied base than ACU then move to the move point, otherwise attack-move
                            if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) > iACUDistToAlliedBase then
                                M28Orders.IssueTrackedMove(oUnit, tProtectiveMovePoint, 3, false, 'RetPrACUM', false)
                            else
                                M28Orders.IssueTrackedAttackMove(oUnit, tProtectiveMovePoint, 3, false, 'RetPrACUA', false)
                            end
                        end
                    else
                        if bConsolidateAtMidpoint then
                            if oClosestFriendlyUnitToAnEnemyFirebase then
                                tRallyPoint = M28Utilities.MoveInDirection(oClosestFriendlyUnitToAnEnemyFirebase:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestFriendlyUnitToAnEnemyFirebase:GetPosition(), tLZData[M28Map.subrefMidpoint]), math.min(M28Utilities.GetDistanceBetweenPositions(oClosestFriendlyUnitToAnEnemyFirebase:GetPosition(), tRallyPoint), 15), true, false, true)
                                local iAltPlateau, iAltLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tRallyPoint)
                                if not(iAltPlateau == iPlateau) then
                                    tRallyPoint = M28Map.GetPositionAtOrNearTargetInPathingGroup(oClosestFriendlyUnitToAnEnemyFirebase:GetPosition(), tRallyPoint, 0, 0, oClosestFriendlyUnitToAnEnemyFirebase, false, false, nil)
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Will try and consolidate based on the closest unit to enemy firebase, tRallyPoint adjusted for this='..repru(tRallyPoint)) end
                            else
                                tRallyPoint = {tLZData[M28Map.subrefMidpoint][1], tLZData[M28Map.subrefMidpoint][2], tLZData[M28Map.subrefMidpoint][3]}
                            end
                            sRetreatMessage = 'ConsRP'
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': We are outranged by enemy and dont have enough threat to press the attack, will either retreat to prev LZ, or this LZ midpoint; bConsolidateAtMidpoint='..tostring(bConsolidateAtMidpoint)..'; bConsiderAttackingExperimental='..tostring(bConsiderAttackingExperimental)) end

                        for iUnit, oUnit in tAvailableCombatUnits do
                            --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                            if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end

                            --Only retreat units from this LZ
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; will only retreat with unit if it is from this LZ, iLandZone='..iLandZone..'; Unit assigned zone='..(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] or 'nil')) end
                            if oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone then
                                --Shot not blocked - consider attackign ACU with experimentals
                                if bConsiderAttackingACU and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryFatboy, oUnit.UnitId) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), toEnemyACUsInZone, 6 + oUnit[M28UnitInfo.refiDFRange], iTeam, false, nil, nil, nil, nil, nil) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Experimental - attack nearest ACU') end
                                    GetUnitToAttackNearestACU(oUnit)

                                elseif bConsiderAttackingExperimental and oUnit[M28UnitInfo.refiDFRange] > 0 and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tNearbyEnemyExperimentals, 10, iTeam, true) then
                                    --move to nearest enemy experimental if we arent in range of it yet but a friendly unit is, and we are an experimental level unit or it is a fatboy
                                    local bMoveTowardsExperimental = false
                                    --Want to move instead of attackmove if we are an experimental (or up against a fatboy) and aren't already in range (by a reasonable margin if against a fatboy)
                                    if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oUnit.UnitId) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFatboy, tNearbyEnemyExperimentals)) == false then
                                        local oNearestEnemyExp
                                        local iClosestEnemyExpDist = 100000
                                        local iCurExpDist
                                        for iExperimental, oExperimental in tNearbyEnemyExperimentals do
                                            iCurExpDist = M28Utilities.GetDistanceBetweenPositions(oExperimental:GetPosition(), oUnit:GetPosition())
                                            if iCurExpDist < iClosestEnemyExpDist then
                                                iClosestEnemyExpDist = iCurExpDist
                                                oNearestEnemyExp = oExperimental
                                            end
                                        end
                                        if iClosestEnemyExpDist > oUnit[M28UnitInfo.refiDFRange] - 3 then
                                            bMoveTowardsExperimental = true
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to advance to enemy experimental, bMoveTowardsExperimental='..tostring(bMoveTowardsExperimental)) end
                                    if bMoveTowardsExperimental then
                                        M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'ExpM'..iLandZone)
                                    else
                                        --Attackmove towards the experimental
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'ExpA'..iLandZone)
                                    end
                                else
                                    if not(bConsolidateAtMidpoint) and EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                        --If moving to the rally point would take us closer to the enemy than moving towards our base then move towards base instead
                                        if bDebugMessages == true then LOG(sFunctionRef..': Amphibious unit and we dont want to consolidate at midpoint, CanKite='..tostring(oUnit[M28UnitInfo.refbCanKite] or false)) end
                                        if not(oUnit[M28UnitInfo.refbCanKite]) and EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then
                                            M28Orders.IssueTrackedAggressiveMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ExKA'..sRetreatMessage..iLandZone)
                                        else
                                            local bMoveTowardsBaseInstead = false
                                            local iAngleToBase
                                            if tMoveTowardsBaseRetreatPoint then --If this is not nil then it means the rally point will take us a different angle to the nearest friendly base, which might cause us to move closer/within range of enemy units
                                                local iAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oNearestEnemyToMidpoint:GetPosition())
                                                iAngleToBase = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])

                                                if 180 - M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToBase) <= 45 then
                                                    bMoveTowardsBaseInstead = true
                                                end
                                            end
                                            if bMoveTowardsBaseInstead then --see below for similar code if making changes here
                                                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMoveTowardsBaseRetreatPoint) <= 12 or M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tMoveTowardsBaseRetreatPoint), iAngleToBase) >= 45 then
                                                    M28Orders.IssueTrackedMove(oUnit, tLZTeamData[M28Map.reftClosestFriendlyBase], 6, false, 'MTBBA'..sRetreatMessage..iLandZone)
                                                else
                                                    M28Orders.IssueTrackedMove(oUnit, tMoveTowardsBaseRetreatPoint, 6, false, 'MTBNA'..sRetreatMessage..iLandZone)
                                                end
                                            else
                                                M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'A'..sRetreatMessage..iLandZone)
                                            end

                                        end
                                    else
                                        if not(oUnit[M28UnitInfo.refbCanKite]) and EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then
                                            M28Orders.IssueTrackedAggressiveMove(oUnit, tRallyPoint, 6, false, 'ExKG'..sRetreatMessage..iLandZone)
                                        else
                                            local bMoveTowardsBaseInstead = false
                                            local iAngleToBase
                                            if tMoveTowardsBaseRetreatPoint then --If this is not nil then it means the rally point will take us a different angle to the nearest friendly base, which might cause us to move closer/within range of enemy units
                                                local iAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oNearestEnemyToMidpoint:GetPosition())
                                                iAngleToBase = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                                                if 180 - M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToBase) <= 45 then
                                                    bMoveTowardsBaseInstead = true
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': iAngleToNearestEnemy='..iAngleToNearestEnemy..'; iAngleToBase='..iAngleToBase..'; Angle dif between angle to nearest enemy and angle to base='..M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToBase)..'; bMoveTowardsBaseInstead='..tostring(bMoveTowardsBaseInstead)) end
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': bMoveTowardsBaseInstead='..tostring(bMoveTowardsBaseInstead)) end
                                            if bMoveTowardsBaseInstead then --see above for similar code if making changes here
                                                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMoveTowardsBaseRetreatPoint) <= 12 or M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tMoveTowardsBaseRetreatPoint), iAngleToBase) >= 45 then
                                                    M28Orders.IssueTrackedMove(oUnit, tLZTeamData[M28Map.reftClosestFriendlyBase], 6, false, 'MTBB'..sRetreatMessage..iLandZone)
                                                else
                                                    M28Orders.IssueTrackedMove(oUnit, tMoveTowardsBaseRetreatPoint, 6, false, 'MTBN'..sRetreatMessage..iLandZone)
                                                end
                                            else
                                                if bDebugMessages == true then
                                                    LOG(sFunctionRef..': Will retreat towards rally point, tRallyPoint='..repru(tRallyPoint)..'; Unit position='..repru(oUnit:GetPosition())..'; Unit special micro='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive] or false)..'; last order position='..repru(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]))
                                                    M28Utilities.DrawLocation(tRallyPoint)
                                                end
                                                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, sRetreatMessage..iLandZone)
                                            end
                                        end
                                    end
                                end
                            else
                                --Unit is from a different zone - need to change the value of its assignment so it is considered for orders by the zone that it is part of
                                oUnit[refiCurrentAssignmentValue] = 0
                            end
                        end
                    end
                end

                if bUpdateNearestUnit then
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                        if aiBrain then
                            M28Team.UpdateUnitLastKnownPosition(aiBrain, oNearestEnemyToMidpoint, true)
                        end
                    else
                        M28Utilities.ErrorHandler('No active M28 brain')
                    end
                end
            end
            --MML synchronisation logic
            if bConsiderSpecialMMLLogic and M28Utilities.IsTableEmpty(tMMLForSynchronisation) == false then
                --Get table of enemy shields and TMD to consider targeting
                local tTMDAndShields = {}
                function IncludeTMDAndShieldsInZone(iAdjLZ)
                    local tAdjLZTeamData
                    if iAdjLZ == iLandZone then tAdjLZTeamData = tLZTeamData else tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam] end
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                        local tZoneTMDAndShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryTMD + M28UnitInfo.refCategoryFixedShield, tAdjLZTeamData[M28Map.subrefTEnemyUnits])
                        if M28Utilities.IsTableEmpty(tZoneTMDAndShields) == false then
                            for iTMDOrShield, oTMDOrShield in tZoneTMDAndShields do
                                if oTMDOrShield:GetFractionComplete() >= 0.3 and M28UnitInfo.IsUnitValid(oTMDOrShield) and not(oTMDOrShield:IsUnitState('Attached')) then
                                    table.insert(tTMDAndShields, oTMDOrShield)
                                end
                            end
                        end
                    end
                end
                IncludeTMDAndShieldsInZone(iLandZone)
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        IncludeTMDAndShieldsInZone(iAdjLZ)
                    end
                end

                --Consider orders for each MML
                local oClosestPotentialTarget
                local iClosestPotentialTarget
                local iCurTargetDist
                local tMMLWithNearbyTargets = {}
                if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through each MML for synchronisation and get a target for it, is tTMDAndShields empty='..tostring(M28Utilities.IsTableEmpty(tTMDAndShields))) end
                for iUnit, oUnit in tMMLForSynchronisation do
                    if not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], math.max(oUnit[M28UnitInfo.refiIndirectRange] - iIndirectRunFigureSynchronisation, math.min(iEnemyBestDFRange + 5, oUnit[M28UnitInfo.refiIndirectRange] - 2)), iTeam, false)) then
                        if M28Utilities.IsTableEmpty(tTMDAndShields) then --redundancy - hopefully only scenario we get here is if there is 1 part-complete TMD/shield that is <30% complete
                            M28Orders.IssueTrackedAggressiveMove(oUnit, (oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or oNearestEnemyToMidpoint:GetPosition()), math.max(15, (iIndirectDistanceInsideRangeThreshold or 15)), false, 'I2KAMve'..iLandZone)
                        else
                            --Get the closest TMD/shield to this MML, and then decide whether to attack it or not (for performance reasons stop as soon as we have a target within TML range
                            iClosestPotentialTarget = 100000
                            for iTarget, oTarget in tTMDAndShields do
                                iCurTargetDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTarget:GetPosition())
                                if iCurTargetDist < iClosestPotentialTarget then
                                    iClosestPotentialTarget = iCurTargetDist
                                    oClosestPotentialTarget = oTarget
                                    if iClosestPotentialTarget < oUnit[M28UnitInfo.refiIndirectRange] then break end
                                end
                            end
                            if not(oClosestPotentialTarget) then
                                M28Utilities.ErrorHandler('Somehow dont have a target for MML')
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(15, iIndirectDistanceInsideRangeThreshold), false, 'I2KAMve'..iLandZone)
                            else
                                if iClosestPotentialTarget - 5 > oUnit[M28UnitInfo.refiIndirectRange] then
                                    --Still a bit of distance until we are in range
                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oClosestPotentialTarget:GetPosition(), (oUnit[M28UnitInfo.refiIndirectAOE] or 0), false, 'MMLSchAM'..iLandZone)
                                else
                                    --Can attack the unit itself
                                    M28Orders.IssueTrackedGroundAttack(oUnit, oClosestPotentialTarget:GetPosition(), (oUnit[M28UnitInfo.refiIndirectAOE] or 0), false, 'MMLSchGA', false)
                                    table.insert(tMMLWithNearbyTargets, oUnit)
                                end
                            end
                        end
                    else
                        --Retreat temporarily from enemy units
                        if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'MMLASKRetr'..iLandZone)
                        else
                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'MMLSKRetr'..iLandZone)
                        end
                    end
                end
                --Do we have any MML that have targets in-range or almost in range?
                if bDebugMessages == true then LOG(sFunctionRef..': Is tMMLWithNearbyTargets empty='..tostring(M28Utilities.IsTableEmpty(tMMLWithNearbyTargets))) end
                if M28Utilities.IsTableEmpty(tMMLWithNearbyTargets) == false then
                    local iMMLWithTargets = table.getn(tMMLWithNearbyTargets)
                    if bDebugMessages == true then LOG(sFunctionRef..': iMMLWithTargets='..iMMLWithTargets) end
                    if iMMLWithTargets >= 4 then
                        local iMMLJustFiredOrReadyToFire = 0
                        local iMMLNotFiredForAges = 0
                        local iMMLReloading = 0

                        local iTimeUntilReadyToFire
                        local iTotalTimeUntilReadyToFire = 0
                        local iMinTimeUntilReady = 100000
                        local iMaxTimeUntilReady = -100000
                        local tiTimeUntilReadyToFire = {}
                        for iUnit, oUnit in tMMLWithNearbyTargets do
                            iTimeUntilReadyToFire = oUnit[M28UnitInfo.refiTimeBetweenIFShots] - (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or -100))
                            if iTimeUntilReadyToFire <= math.min(-7, -oUnit[M28UnitInfo.refiTimeBetweenIFShots] - 1.5) then
                                iMMLNotFiredForAges = iMMLNotFiredForAges + 1
                            elseif iTimeUntilReadyToFire >= 1.01 then
                                iMMLReloading = iMMLReloading + 1
                            else
                                iMMLJustFiredOrReadyToFire = iMMLJustFiredOrReadyToFire + 1
                            end
                            if iTimeUntilReadyToFire < iMinTimeUntilReady then iMinTimeUntilReady = iTimeUntilReadyToFire end
                            if iTimeUntilReadyToFire > iMaxTimeUntilReady then iMaxTimeUntilReady = iTimeUntilReadyToFire end
                            iTotalTimeUntilReadyToFire = iTotalTimeUntilReadyToFire + iTimeUntilReadyToFire
                            table.insert(tiTimeUntilReadyToFire, iTimeUntilReadyToFire)
                            if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTimeUntilReadyToFire='..iTimeUntilReadyToFire..'; oUnit[M28UnitInfo.refiTimeBetweenIFShots]='..oUnit[M28UnitInfo.refiTimeBetweenIFShots]..'; oUnit[M28UnitInfo.refiLastWeaponEvent]='..(oUnit[M28UnitInfo.refiLastWeaponEvent] or 'nil')..'; Cur time='..GetGameTimeSeconds()) end
                        end
                        local iAverageTimeUntilReadyToFire = iTotalTimeUntilReadyToFire / iMMLWithTargets
                        local iMMLWithin1OfAverage = 0
                        for iEntry, iTime in tiTimeUntilReadyToFire do
                            if math.abs(iTime - iAverageTimeUntilReadyToFire) < 1 then
                                iMMLWithin1OfAverage = iMMLWithin1OfAverage + 1
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iMMLJustFiredOrReadyToFire='..iMMLJustFiredOrReadyToFire..'; iMMLNotFiredForAges='..iMMLNotFiredForAges..'; iMMLWithTargets='..iMMLWithTargets..'; iMMLReloading='..iMMLReloading..'; iMMLWithin1OfAverage='..iMMLWithin1OfAverage..'; iAverageTimeUntilReadyToFire='..iAverageTimeUntilReadyToFire..'; iMaxTimeUntilReady='..iMaxTimeUntilReady..'; iMinTimeUntilReady='..iMinTimeUntilReady) end
                        if iMMLJustFiredOrReadyToFire + iMMLNotFiredForAges >= iMMLWithTargets * 0.75 or iMMLNotFiredForAges >= iMMLWithTargets * 0.25 or iMMLWithin1OfAverage >= iMMLWithTargets * 0.8 or (iMaxTimeUntilReady - iMinTimeUntilReady) <= 1.4 then
                            --Dont want to synchronise as either already synchronised or have lots of MML that havent fired in a while
                            if bDebugMessages == true then LOG(sFunctionRef..': Will enable all MML weapons') end
                            for iUnit, oUnit in tMMLWithNearbyTargets do
                                M28UnitInfo.EnableUnitWeapon(oUnit) --In addition to separate logic that will enable, as want to enable asap once we decide we want to fire)
                            end
                        else
                            --Want to synchronise shots, disable the weapons (they shoudl be reenabled each cycle)
                            if bDebugMessages == true then LOG(sFunctionRef..': Will disable all MML weapons until they are better synchronised, time='..GetGameTimeSeconds()) end
                            for iUnit, oUnit in tMMLWithNearbyTargets do
                                M28UnitInfo.DisableUnitWeapon(oUnit)
                            end
                        end
                    end
                end
            end
        end
    end

    if bRunFromFirebase or (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] > math.max(100, tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal])) then
        for iUnit, oUnit in tAvailableCombatUnits do --Only retreat units from this LZ
            if oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone then
                --If we have recently been given a short range target, or are almost in range of the target, then we may have moved into this zone temporarily, in which case continue with attacking the target
                if bDebugMessages == true then LOG(sFunctionRef..': is oUnit[refoSREnemyTarget] valid='..tostring(M28UnitInfo.IsUnitValid(oUnit[refoSREnemyTarget]))..'; refiTimeOfSREnemyTarget='..(oUnit[refiTimeOfSREnemyTarget] or 'nil')..'; unit df range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; time='..GetGameTimeSeconds()) end
                if M28UnitInfo.IsUnitValid(oUnit[refoSREnemyTarget]) and oUnit[refiTimeOfSREnemyTarget] and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId)) and (GetGameTimeSeconds() - oUnit[refiTimeOfSREnemyTarget] <= 20 or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[refoSREnemyTarget]:GetPosition()) <= (oUnit[M28UnitInfo.refiDFRange] or 0) + 10) then
                    if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnit.UnitId) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[refoSREnemyTarget]:GetPosition()) <= (oUnit[M28UnitInfo.refiDFRange] or 0) - 10 then
                        M28Orders.IssueTrackedAggressiveMove(oUnit, oUnit[refoSREnemyTarget]:GetPosition(), 6, false, 'SRHistAT'..iLandZone)
                    else
                        M28Orders.IssueTrackedMove(oUnit, oUnit[refoSREnemyTarget]:GetPosition(), 6, false, 'SRHistMT'..iLandZone)
                    end
                elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                    M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AFBRetr'..iLandZone)
                else
                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'FBRetr'..iLandZone)
                end
            end
        end
    elseif not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) then --Done via separate if condition instead of else as we might set this to false if we couldnt find a nearest enemy in the above logic
        --Split units available to reinforce into DF and indirect fire units
        local tDFUnits = {}
        local tIndirectUnits = {}
        for iUnit, oUnit in tAvailableCombatUnits do
            if oUnit[M28UnitInfo.refiDFRange] > 0 then
                table.insert(tDFUnits, oUnit)
            elseif oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                table.insert(tIndirectUnits, oUnit)
            else
                M28Utilities.ErrorHandler('Combat unit with no DF or indirect range')
            end
        end

        --Indirect special 'bombardment' type logic against nearby different plateaus
        if M28Utilities.IsTableEmpty(tIndirectUnits) == false and M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]) then
            local tOrderPosition = tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]:GetPosition()
            for iUnit, oUnit in tIndirectUnits do
                --Note - issue on maps like air wars - the range factors in height so if the target plateau is very far away it can lead to strange results
                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOrderPosition) > oUnit[M28UnitInfo.refiIndirectRange] - 1 then
                    M28Orders.IssueTrackedAggressiveMove(oUnit, tOrderPosition, 3, false, 'InPlBom', false)
                else
                    M28Orders.IssueTrackedGroundAttack(oUnit, tOrderPosition, 3, false, 'InPlAGBm', false, tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere])
                end
            end
            tIndirectUnits = {}
        end

        --Do we have adjacent zones wanting reinforcements?
        local iIndirectLZToSupport
        local iDFLZToSupport
        --if M28Utilities.IsTableEmpty(tDFUnits) then iDFLZToSupport = -1 end --set to -1 so not nil so we can ignore checking the threat for indirect/direct respectively
        --(dont set the DFLZ to -1 yet, as we want to support a zone wanting DF units iwth indirect if we have spare indirect
        if M28Utilities.IsTableEmpty(tIndirectUnits) then iIndirectLZToSupport = -1 end

        local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)

        if bDebugMessages == true then LOG(sFunctionRef..': Dont have any enemy units in this LZ or adjacent LZ, so will consider supporting other land zones, is tDFUnits empty='..tostring(M28Utilities.IsTableEmpty(tDFUnits))..'; Is adjacent LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]))..'; subrefiNearbyEnemyLongRangeThreat='..tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat]) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent LZ iAdjLZ='..iAdjLZ..'; Does it want DF support='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport])..'; Does it want indirect support='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsIndirectSupport])) end
                if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMidpoint])) then
                    if not(iIndirectLZToSupport) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsIndirectSupport] then
                        iIndirectLZToSupport = iAdjLZ
                        if iDFLZToSupport or M28Utilities.IsTableEmpty(tDFUnits) then break end
                    end
                    if not(iDFLZToSupport) and (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport]) then
                        if bDebugMessages == true then LOG(sFunctionRef..': iAdjLZ '..iAdjLZ..' wants DF support so will support here') end
                        iDFLZToSupport = iAdjLZ
                        if  iIndirectLZToSupport then break end
                    end
                end
            end
        end
        if iIndirectLZToSupport and not(iDFLZToSupport) and M28Utilities.IsTableEmpty(tDFUnits) then iDFLZToSupport = -1 end

        if not(iIndirectLZToSupport) or not(iDFLZToSupport) then
            --Are there any further away LZs on this plateau that want support?
            local iClosestLZDFDist = 100000
            local iCurDist
            local iClosestLZIndirectDist = 100000
            local iClosestDFLZRef
            local iClosestIndirectLZRef
            if M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau] then
                for iOtherLZ, bWantsSupport in M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau] do
                    if bWantsSupport then
                        local tOtherLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ]
                        if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tOtherLZData[M28Map.subrefMidpoint])) then
                            if not(iDFLZToSupport) and tOtherLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport] then
                                --Redundancy - if we cant path using land units then treat distance as 10k + straight line distance, so we prioritise locations that are land pathable (although ideally wouldnt have any such zones anyway?)
                                iCurDist = (M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iOtherLZ) or 10000) --M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefMidpoint])
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to support iOtherLZ '..iOtherLZ..'; iCurDist='..iCurDist..'; iClosestLZDFDist='..iClosestLZDFDist..'; straight line dist from our start='..M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam][M28Map.reftClosestFriendlyBase], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefMidpoint])) end
                                if iCurDist >= 10000 and iCurDist < iClosestLZDFDist then iCurDist = iCurDist + M28Utilities.GetDistanceBetweenPositions(tOtherLZData[M28Map.subrefMidpoint], tLZData[M28Map.subrefMidpoint]) end
                                if iCurDist and iCurDist < iClosestLZDFDist then
                                    iClosestLZDFDist = iCurDist
                                    iClosestDFLZRef = iOtherLZ
                                end
                                if not(iIndirectLZToSupport) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsIndirectSupport] then
                                    if iCurDist and iCurDist < iClosestLZIndirectDist then
                                        iClosestLZIndirectDist = iCurDist
                                        iClosestIndirectLZRef = iOtherLZ
                                    end
                                end
                            elseif not(iIndirectLZToSupport) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsIndirectSupport] then
                                iCurDist = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iOtherLZ) --M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefMidpoint])
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to support witih indirect iOtherLZ '..iOtherLZ..'; iCurDist='..repru(iCurDist)..'; iClosestLZIndirectDist='..repru(iClosestLZIndirectDist)..'; straight line dist from our start='..M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam][M28Map.reftClosestFriendlyBase], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefMidpoint])) end
                                if iCurDist and iCurDist < iClosestLZIndirectDist then
                                    iClosestLZIndirectDist = iCurDist
                                    iClosestIndirectLZRef = iOtherLZ
                                end
                            end
                        end
                    end
                end
            end
            if not(iDFLZToSupport) then iDFLZToSupport = iClosestDFLZRef end
            --If still not found somewhere to support, check for nearby islands wanting support
            if bDebugMessages == true then LOG(sFunctionRef..': Checking for LZs to send DF units to support at time '..GetGameTimeSeconds()..' for LZ '..(iLandZone or 'nil')..' on island '..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..', pre island iDFLZToSupport='..(iDFLZToSupport or 'nil')..'; is pathing to other islands empty='..tostring(tLZData[M28Map.subrefLZPathingToOtherIslands] or false)) end
            if not(iDFLZToSupport) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
                --Do we have amphibious or hover units in our available units?
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of amphib combat empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryAmphibiousCombat, tDFUnits)))) end
                local tAmphibiousDFUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryAmphibiousCombat, tDFUnits)
                if M28Utilities.IsTableEmpty(tAmphibiousDFUnits) == false then
                    local bConsiderAttackingEnemyBase = false
                    --If enemy has long range threat then consider sending experimentals to attack their base
                    if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure]) == false then
                        local iAmphibiousCombatThreat = M28UnitInfo.GetCombatThreatRating(tAmphibiousDFUnits, false, false)
                        if bDebugMessages == true then LOG(sFunctionRef..': iAmphibiousCombatThreat='..iAmphibiousCombatThreat) end
                        if iAmphibiousCombatThreat >= 19000 then --Monkeylord is 20k
                            --Do we have at least as many land experimentals as the enemy? (otherwise we risk suiciding into their base)
                            local iEnemyExperimentalCount = 0
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
                                iEnemyExperimentalCount = table.getn(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals])
                            end
                            if iEnemyExperimentalCount > 0 then
                                local iFriendlyExperimentalCount = 0
                                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                    iFriendlyExperimentalCount = iFriendlyExperimentalCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandExperimental)
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': iFriendlyExperimentalCount='..iFriendlyExperimentalCount..'; iEnemyExperimentalCount='..iEnemyExperimentalCount) end
                                if iFriendlyExperimentalCount > iEnemyExperimentalCount then
                                    bConsiderAttackingEnemyBase = true
                                end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy has no land experimentals so will attack') end
                                bConsiderAttackingEnemyBase = true
                            end

                        end
                    end
                    local iDistanceThreshold
                    if bConsiderAttackingEnemyBase then
                        iDistanceThreshold = math.max(400, M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) * 1.25)
                    else
                        iDistanceThreshold = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) * 0.75
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': bConsiderAttackingEnemyBase='..tostring(bConsiderAttackingEnemyBase)..'; iDistanceThreshold='..iDistanceThreshold) end

                    for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering island '..tPathingData[M28Map.subrefIslandNumber]..'; tPathingData[M28Map.subrefIslandTravelDist]='..tPathingData[M28Map.subrefIslandTravelDist]..'; iDistanceThreshold='..iDistanceThreshold..'; Does LZ want support='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsSupport])..'; tPathingData[M28Map.subrefIslandClosestLZRef]='..tPathingData[M28Map.subrefIslandClosestLZRef]) end
                        if tPathingData[M28Map.subrefIslandTravelDist] > iDistanceThreshold then break end

                        if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsSupport] then
                            if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea( M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefMidpoint])) then
                                iDFLZToSupport = tPathingData[M28Map.subrefIslandClosestLZRef]
                                M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.refbIslandBeachhead] = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Will support the closeest LZ ref, iDFLZToSupport='..iDFLZToSupport) end
                                break
                            end
                        end
                    end
                end
            end

            if not(iIndirectLZToSupport) then
                iIndirectLZToSupport = iClosestIndirectLZRef
                if not(iIndirectLZToSupport) then
                    iIndirectLZToSupport = iDFLZToSupport
                end
            end


        end


        if iDFLZToSupport > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': Want to support LZ '..iDFLZToSupport..'; Will adjust DF to get via point if it is far away; midpoint of iDFToSupport='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iDFLZToSupport][M28Map.subrefMidpoint])..'; Midpoint of this LZ='..repru(tLZData[M28Map.subrefMidpoint])) end
            iDFLZToSupport = ReviseTargetLZIfFarAway(tLZData, iTeam, iPlateau, iLandZone, iDFLZToSupport, 2)
            if bDebugMessages == true then LOG(sFunctionRef..': iDFLZToSupport after revising target for far away LZ='..iDFLZToSupport..'; Midpoint of this zone='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iDFLZToSupport][M28Map.subrefMidpoint])) end

            for iUnit, oUnit in tDFUnits do
                M28Orders.IssueTrackedMove(oUnit, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iDFLZToSupport][M28Map.subrefMidpoint], 6, false, 'DFMovLZ'..iDFLZToSupport..';'..iLandZone)
            end
            tDFUnits = nil
        end
        if iIndirectLZToSupport > 0 then
            iIndirectLZToSupport = ReviseTargetLZIfFarAway(tLZData, iTeam, iPlateau, iLandZone, iIndirectLZToSupport, 2)
            for iUnit, oUnit in tIndirectUnits do
                M28Orders.IssueTrackedMove(oUnit, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iIndirectLZToSupport][M28Map.subrefMidpoint], 6, false, 'IFMovLZ'..iIndirectLZToSupport..';'..iLandZone)
            end
            tIndirectUnits = nil
        end
        local tRemainingLandUnits = {}
        if M28Utilities.IsTableEmpty(tDFUnits) == false then
            for iUnit, oUnit in tDFUnits do
                table.insert(tRemainingLandUnits, oUnit)
            end
        end
        if M28Utilities.IsTableEmpty(tIndirectUnits) == false then
            for iUnit, oUnit in tIndirectUnits do
                table.insert(tRemainingLandUnits, oUnit)
            end
        end
        if M28Utilities.IsTableEmpty(tRemainingLandUnits) == false then
            --Can we path to the enemy base with land? if so then send units to it

            if NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint]) and M28Conditions.IsLocationInPlayableArea(tLZTeamData[M28Map.reftClosestEnemyBase]) then
                if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZTeamData[M28Map.reftClosestEnemyBase])) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will send all land units to closest enemy base') end
                    for iUnit, oUnit in tRemainingLandUnits do
                        M28Orders.IssueTrackedMove(oUnit, tLZTeamData[M28Map.reftClosestEnemyBase], 6, false, 'MTDEnB'..iLandZone)
                    end
                    tRemainingLandUnits = nil
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Have remaining land units with nowhere to go, is pathing of closest enemy base same as pathing of this land zone? enemy base land label='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) or 'nil')..'; label of this zone='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint]) or 'nil')..'; Is table of units empty after considering sending to enemy base='..tostring(M28Utilities.IsTableEmpty(tRemainingLandUnits))) end
            if M28Utilities.IsTableEmpty(tRemainingLandUnits) == false then
                --Cant go to enemy base, so just follow land scouting path
                if bDebugMessages == true then LOG(sFunctionRef..': Follow land scouting path if we have one, is patrol path empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subreftPatrolPath]))) end
                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subreftPatrolPath]) == false then
                    --Patrol the land zone
                    for iUnit, oUnit in tRemainingLandUnits do
                        M28Orders.PatrolPath(oUnit, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subreftPatrolPath], false, 'SP')
                    end
                else
                    --Do nothing
                end
            end
        end
        --M28Orders.IssueTrackedMove(oUnit, tLZTeamData[M28Map.reftClosestEnemyBase], 6, false, 'MTDEnB'..iLandZone)
    else
        --If have got here then hopefully units have already been given orders
        if bDebugMessages == true then LOG(sFunctionRef..': Will assume units have received orders already so do nothing') end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code for iLandZOne '..iLandZone..', bWantReinforcements='..tostring(bWantReinforcements)..'; bWantIndirectReinforcements='..tostring(bWantIndirectReinforcements)) end
    local bWantDFReinforcements = bWantReinforcements
    if bWantReinforcements then
        --Do we want to get indirect fire instead of direct fire as an override?
        if tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] >= 400 then
            local iEnemyStructureThreatTotal = 0
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                    iEnemyStructureThreatTotal = iEnemyStructureThreatTotal + iThreat
                end
            end
            if tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] < tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] * 1.3 then
                --We have enough DF threat, if we want more indirect threat then no longer flag as wanting DF support and instead flag that we want indirect support
                if iEnemyStructureThreatTotal * 1.4 > math.max(50, tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]) then
                    local iDFRatio = tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] / math.max(1, tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal])
                    local iIndirectRatio = math.max(50, tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]) / math.max(iEnemyStructureThreatTotal, 1)
                    if iIndirectRatio < iDFRatio then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want more indirect units due to the ratio of indirect to DF units, iIndirectRatio='..iIndirectRatio..'; iDFRatio='..iDFRatio) end
                        bWantIndirectReinforcements = true
                        bWantDFReinforcements = false
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking override for reinforcement type, bWantDFReinforcements='..tostring(bWantDFReinforcements)..'; bWantIndirectReinforcements='..tostring(bWantIndirectReinforcements)..'; iEnemyStructureThreatTotal='..iEnemyStructureThreatTotal..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]) end
        end
    end
    if not(bWantIndirectReinforcements) and GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMD] or -100) <= 10 then
        if bDebugMessages == true then LOG(sFunctionRef..': It has been '..GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMD] or -100)..' since MML were firing near TMD so want more indirect fire so get more MML') end
        bWantIndirectReinforcements = true
    end
    if bWantDFReinforcements and not(bWantIndirectReinforcements) then
        --If we already have higher DF threat than enemy DF threat in this zone, then consider adjacent zones and whether we want some indirect fire threat here
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to change to requesting indirect units, tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]) end
        if tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] > tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] and tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] > tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] then
            local iNearbyEnemyMobileDFThreat = (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)
            local iNearbyEnemyStructureThreat = 0
            if tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] > 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                    iNearbyEnemyStructureThreat = iNearbyEnemyStructureThreat + iThreat
                end
            end
            local iNearbyAllyMobileDFThreat = (tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0)
            local iNearbyAllyMobileIndirectThreat = (tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] or 0)
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                iNearbyEnemyMobileDFThreat = iNearbyEnemyMobileDFThreat + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)
                if tAdjLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] > 0 and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                    for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                        iNearbyEnemyStructureThreat = iNearbyEnemyStructureThreat + iThreat
                    end
                end
                iNearbyAllyMobileDFThreat = iNearbyAllyMobileDFThreat + (tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0)
                iNearbyAllyMobileIndirectThreat = iNearbyAllyMobileIndirectThreat + (tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] or 0)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iNearbyEnemyMobileDFThreat='..iNearbyEnemyMobileDFThreat..'; iNearbyEnemyStructureThreat='..iNearbyEnemyStructureThreat..'; iNearbyAllyMobileDFThreat='..iNearbyAllyMobileDFThreat..'; iNearbyAllyMobileIndirectThreat='..iNearbyAllyMobileIndirectThreat) end
            if iNearbyEnemyMobileDFThreat < iNearbyAllyMobileDFThreat and iNearbyAllyMobileIndirectThreat < iNearbyEnemyStructureThreat then
                bWantIndirectReinforcements = true
            end
        end
    end

    --Enemy structure in nearby plateau that we can probably reach

    if bDebugMessages == true then LOG(sFunctionRef..': Checking if want to request indirect reinforcements for dif plateau threat, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; enemies in this or adjacent='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; bWantIndirectReinforcements='..tostring(bWantIndirectReinforcements)..'; Valid structure in other plateau='..tostring(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere])..'; Highest friendly land fac tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]) end
    if not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and not(bWantIndirectReinforcements) and M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3 then
        bWantIndirectReinforcements = M28Conditions.IsNearbyStructureThatWeCanReachWithIndirect(tLZData, tLZTeamData, iTeam)
    end
    UpdateIfLandZoneWantsSupport(tLZTeamData, iPlateau, iLandZone, iTeam, bWantDFReinforcements, bWantIndirectReinforcements)
    if bDebugMessages == true then LOG(sFunctionRef..': Just recorded if this LZ wants support, bWantDFReinforcements='..tostring(bWantDFReinforcements)..'; bWantIndirectReinforcements='..tostring(bWantIndirectReinforcements)..'; tLZTeamData[M28Map.subrefbLZWantsSupport] = '..tostring(tLZTeamData[M28Map.subrefbLZWantsSupport])..'; tLZTeamData[M28Map.subrefbLZWantsDFSupport]='..tostring(tLZTeamData[M28Map.subrefbLZWantsDFSupport])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RetreatOtherUnits(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tOtherUnitsToRetreat)
    local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2)
    local tAmphibiousRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2, true)
    for iUnit, oUnit in tOtherUnitsToRetreat do
        if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 10, false, 'AOtRet')
        else
            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 10, false, 'OtRet', false)
        end
    end
end

function RecordUnitAsReceivingLandZoneAssignment(oUnit, iPlateau, iLandZone, iCurLZValue)
    oUnit[refiCurrentAssignmentValue] = iCurLZValue --This is also updated for units that are part of a separate zone
    oUnit[refiCurrentAssignmentPlateauAndLZ] = {iPlateau, iLandZone}
    oUnit[refiTimeOfLastAssignment] = GetGameTimeSeconds()
    if oUnit[M28Navy.refiCurrentWZAssignmentValue] then
        oUnit[M28Navy.refiCurrentWZAssignmentValue] = nil
        oUnit[M28Navy.refiCurrentAssignmentWaterZone] = nil
    end
end

function ManageSpecificLandZone(aiBrain, iTeam, iPlateau, iLandZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageSpecificLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Record enemy threat
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]



    if bDebugMessages == true then LOG(sFunctionRef..': About to update threat for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; Is LZTeamData empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData))..'; Time='..GetGameTimeSeconds()) end
    RecordGroundThreatForLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone)
    RecordAirThreatForLandZone(tLZTeamData, iTeam, iPlateau, iLandZone)

    tLZTeamData[M28Map.subrefLZTAlliedCombatUnits] = {}
    tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield] = {}
    tLZTeamData[M28Map.refbLZWantsMobileShield] = false --will change later
    tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth] = {}
    tLZTeamData[M28Map.refbLZWantsMobileStealth] = false --will change later

    --Build location tracker
    tLZData[M28Map.subrefSegmentsConsideredThisTick] = 0

    local tEngineers, tScouts, tMobileShields, tMobileStealths, tOtherUnitsToRetreat, tRASSACU
    local iCurShield, iMaxShield
    local bLandZoneOrAdjHasUnitsWantingScout = false
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
    local bUpdateEnemyDataHere = true --Will handle this logic in logic for managing land zone units if htis is false
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        --Decide on what to do with units in this LZ
        tEngineers = {}
        tScouts = {}
        tMobileShields = {}
        tMobileStealths = {}
        tRASSACU = {}
        tOtherUnitsToRetreat = {} --Intended for e.g. fatboys and units with personal shield
        local bUseRASInCombat = false
        if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 then bUseRASInCombat = true end
        local tAvailableCombatUnits = {}
        local tUnavailableUnitsInThisLZ = {}
        local tTempOtherUnits = {}
        local tAvailableMAA = {}
        local iCurLZValue = tLZTeamData[M28Map.subrefLZTValue]

        local iOurBestDFRange = 0
        local iOurBestIndirectRange = 0
        local bIncludeUnit

        local iEnemyOmniCoverage = M28Conditions.GetEnemyOmniCoverageOfZone(iPlateau, iLandZone, iTeam)

        local iMobileShieldMassThreshold = 150 --When assigning mobile shields will also restrict further so e.g. seraphim mobile shields will have a higher threshold
        local iMobileShieldHigherMAAMassThreshold = 400 --for if we have MAA and enemy doesnt have much air threat
        local iMobileStealthMassThreshold = 200 --will get adjusted further
        local iMobileStealthHigherMassThreshold = 500 --i.e. wont stealth loyalists and titans
        local iUnitMassCost
        local iMobileStealthLowerThresholdCount = 0 --Used to avoid assigning too many mobile stealth at once to units not exceeding the higher mass threshold
        if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 600 and (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 2000 or tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0) then iMobileShieldHigherMAAMassThreshold = iMobileShieldMassThreshold end
        local bConsiderMobileShieldsForT2Arti = false
        if tLZTeamData[M28Map.subrefLZbCoreBase] and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false or (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) > 0) then
            bConsiderMobileShieldsForT2Arti = true
        end

        for iUnit, oUnit in tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do
            if oUnit:GetFractionComplete() >= 1 then
                if EntityCategoryContains(categories.MOBILE - M28UnitInfo.refCategoryScathis, oUnit.UnitId) then
                    if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                        table.insert(tEngineers, oUnit)
                        bLandZoneOrAdjHasUnitsWantingScout = true
                    elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) or oUnit[M28ACU.refbTreatingAsACU] then
                        --ACU logic - handled via M28ACU file, as amy not want to kite with it; acu is still stored in list of allied units for a land zone though
                        if bDebugMessages == true then LOG(sFunctionRef..': ACU is in list of allied units for iPlateau'..iPlateau..'; iLandZone='..iLandZone) end
                        bLandZoneOrAdjHasUnitsWantingScout = true
                        table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                        if iEnemyOmniCoverage <= 20 then
                            table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth], oUnit)
                        end

                        if not(oUnit[M28ACU.refbTreatingAsACU]) and oUnit:GetAIBrain().M28AI then ForkThread(M28ACU.ManageACU, oUnit:GetAIBrain(), oUnit) end --redundancy, wouldnt expect this to normally trigger
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit.UnitId) then
                        table.insert(tScouts, oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMobileLandShield, oUnit.UnitId) then
                        table.insert(tMobileShields, oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMobileLandStealth, oUnit.UnitId) then
                        table.insert(tMobileStealths, oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryRASSACU, oUnit.UnitId) and not(bUseRASInCombat) then
                        table.insert(tRASSACU, oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryMobileLand - categories.COMMAND, oUnit.UnitId) or (oUnit[M28UnitInfo.refiCombatRange] > 0 and EntityCategoryContains(categories.AMPHIBIOUS * categories.MOBILE - categories.AIR, oUnit.UnitId)) then
                        --Tanks, skirmishers, and indirect fire units - handled by main combat unit manager
                        bIncludeUnit = false
                        bLandZoneOrAdjHasUnitsWantingScout = true
                        --Is the unit available for use by this land zone?
                        if oUnit:GetFractionComplete() == 1 then
                            --Is the unit's priority lower than this?
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if have available combat unit, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[refiCurrentAssignmentValue]='..(oUnit[refiCurrentAssignmentValue] or 'nil')..'; oUnit[refiCurrentAssignmentPlateauAndLZ]='..repru(oUnit[refiCurrentAssignmentPlateauAndLZ])..'; iCurLZValue='..iCurLZValue) end
                            if (oUnit[refiCurrentAssignmentValue] or 0) < iCurLZValue or (oUnit[refiCurrentAssignmentPlateauAndLZ][1] == iPlateau and (oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone or (GetGameTimeSeconds() - (oUnit[refiTimeOfLastAssignment] or 0) >= 5))) then
                                --Is it a unit with a shield that wants to retreat so its shield can regen?
                                iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': iCurShield='..iCurShield..'; iMaxShield='..iMaxShield..'; Unit max health='..oUnit:GetMaxHealth()) end
                                if iMaxShield > 0 and iCurShield < iMaxShield * 0.35 and (iCurShield == 0 or iMaxShield > oUnit:GetMaxHealth() * 0.8 or iCurShield < iMaxShield * 0.05) then --Fatboy and in theory SACUs retreat when shield is low; titans etc. retreat when shield is almost gone
                                    table.insert(tOtherUnitsToRetreat, oUnit)
                                    RecordUnitAsReceivingLandZoneAssignment(oUnit, iPlateau, iLandZone, 100000)
                                else
                                    if EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId) then
                                        table.insert(tAvailableMAA, oUnit)
                                        bIncludeUnit =  true
                                    elseif ((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or (oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0) then
                                        table.insert(tAvailableCombatUnits, oUnit)
                                        table.insert(tLZTeamData[M28Map.subrefLZTAlliedCombatUnits], oUnit)
                                        if oUnit[M28UnitInfo.refiDFRange] > iOurBestDFRange then iOurBestDFRange = oUnit[M28UnitInfo.refiDFRange] end
                                        if oUnit[M28UnitInfo.refiIndirectRange] > iOurBestIndirectRange then iOurBestIndirectRange = oUnit[M28UnitInfo.refiIndirectRange] end
                                        bIncludeUnit = true
                                    end
                                    if bIncludeUnit then
                                        RecordUnitAsReceivingLandZoneAssignment(oUnit, iPlateau, iLandZone, iCurLZValue)
                                    end
                                end
                            else
                                table.insert(tUnavailableUnitsInThisLZ, oUnit)
                            end
                            iUnitMassCost = oUnit:GetBlueprint().Economy.BuildCostMass
                            if iUnitMassCost >= iMobileShieldMassThreshold and (iUnitMassCost >= iMobileShieldHigherMAAMassThreshold or iMobileShieldHigherMAAMassThreshold == iMobileShieldMassThreshold or not(EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId))) then
                                table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                            end
                            if iEnemyOmniCoverage <= 20 then
                                if iUnitMassCost >= iMobileStealthHigherMassThreshold then
                                    table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth], oUnit)
                                elseif iUnitMassCost >= iMobileStealthMassThreshold and EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryIndirect - categories.TECH1, oUnit.UnitId) then
                                    --Only say we want a mobile shield if the unit doesnt have one assigned
                                    iMobileStealthLowerThresholdCount = iMobileStealthLowerThresholdCount + 1

                                    if iMobileStealthLowerThresholdCount >= 3 or oUnit[refoAssignedMobileStealth] then
                                        iMobileStealthLowerThresholdCount = 0
                                        table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth], oUnit)
                                    end
                                end
                            end
                        end
                    elseif EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                        --Structure logic - handled separately e.g. via M28Factory for factories
                    else
                        --Unexpected unit type - could e.g. be a naval unit on a location thought to be a land zone; only flag as error if unit has no orders
                        table.insert(tTempOtherUnits, oUnit)
                        bLandZoneOrAdjHasUnitsWantingScout = true
                    end
                elseif bConsiderMobileShieldsForT2Arti and EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) and M28Utilities.IsTableEmpty(oUnit[M28Building.reftoShieldsProvidingCoverage]) then
                    table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of engineers empty='..tostring(M28Utilities.IsTableEmpty(tEngineers))..'; Is table of combat units just for this zone empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))) end

        --Mobile shield data:
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield]) == false then
            for iUnit, oUnit in tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield] do
                if oUnit[refoAssignedMobileShield] then
                    if not(M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileShield])) then
                        oUnit[refoAssignedMobileShield] = nil
                        tLZTeamData[M28Map.refbLZWantsMobileShield] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording that the land zone '..iLandZone..' wants mobile shields as a unit that had a mobile shield no longerh as a valid one') end
                    end
                else
                    tLZTeamData[M28Map.refbLZWantsMobileShield] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording that the land zone '..iLandZone..' wants mobile shields as it has a unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that doesnt have an assigned mobile shield yet') end
                end
            end
        end
        tLZTeamData[M28Map.subrefiAvailableMobileShieldThreat] = 0
        if M28Utilities.IsTableEmpty(tMobileShields) == false then
            tLZTeamData[M28Map.subrefiAvailableMobileShieldThreat] = M28UnitInfo.GetCombatThreatRating(tMobileShields, false, true)
            ManageMobileShieldsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tMobileShields)
        end
        --Mobile stealth data:
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth]) == false then

            for iUnit, oUnit in tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth] do
                if iEnemyOmniCoverage > 20 then
                    if M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileStealth]) then
                        oUnit[refoAssignedMobileStealth][refoMobileStealthTarget] = nil
                        oUnit[refoAssignedMobileStealth] = nil
                    end
                elseif oUnit[refoAssignedMobileStealth] then
                    if not(M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileStealth])) then
                        oUnit[refoAssignedMobileStealth] = nil
                        tLZTeamData[M28Map.refbLZWantsMobileStealth] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording that the land zone '..iLandZone..' wants mobile Stealths as a unit that had a mobile Stealth no longerh as a valid one') end
                    end
                else
                    tLZTeamData[M28Map.refbLZWantsMobileStealth] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording that the land zone '..iLandZone..' wants mobile Stealths as it has a unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that doesnt have an assigned mobile Stealth yet') end
                end
            end
            if iEnemyOmniCoverage > 20 then tLZTeamData[M28Map.refbLZWantsMobileStealth] = false end
        end

        if M28Utilities.IsTableEmpty(tMobileStealths) == false then
            ManageMobileStealthsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tMobileStealths)
        end

        local iCurDFThreat = 0
        local iCurIndirectThreat = 0
        local iCurMAAThreat = tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]
        local iMinIndirectRangeNeededForThreat = tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] + 1
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] do
                if iRange >= iMinIndirectRangeNeededForThreat then
                    iCurIndirectThreat = iCurIndirectThreat + iThreat
                end
            end
        end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                iCurDFThreat = iCurDFThreat + iThreat
            end
        end


        local bConsiderAdjacentDF = false
        local bConsiderAdjacentIndirect = false
        local bConsiderAdjacentMAA = false
        if bDebugMessages == true then LOG(sFunctionRef..': Setting whether we want to consider indirect threat, iCurIndirectThreat='..(iCurIndirectThreat or 'nil')..'; tLZTeamData[M28Map.subrefLZIndirectThreatWanted]='..(tLZTeamData[M28Map.subrefLZIndirectThreatWanted] or 'nil')) end
        if iCurIndirectThreat < tLZTeamData[M28Map.subrefLZIndirectThreatWanted] then bConsiderAdjacentIndirect = true end
        if iCurDFThreat < tLZTeamData[M28Map.subrefLZDFThreatWanted] then bConsiderAdjacentDF = true end
        if iCurMAAThreat < tLZTeamData[M28Map.subrefLZMAAThreatWanted] then bConsiderAdjacentMAA = true end




        --Add adjacent combat units if the land zone is lower priority than us and the adjacent LZ doesnt have DF units of a significant threat in it
        local iCurUnitThreat
        if bDebugMessages == true then LOG(sFunctionRef..': Will consider including adjacent combat units for LZ '..iLandZone..' with iCurLZValue='..iCurLZValue..'; is table of adjacent LZs empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]))..'; bConsiderAdjacentIndirect='..tostring(bConsiderAdjacentIndirect)..'; bConsiderAdjacentDF='..tostring(bConsiderAdjacentDF)) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false and (bConsiderAdjacentIndirect or bConsiderAdjacentDF) then
            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                local tAltLZTeam = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; Base LZ='..iLandZone..'; iAdjLZ='..iAdjLZ..'; LZTValue='..repru(tAltLZTeam[M28Map.subrefLZTValue])..'; Is table of allied combat units empty='..tostring(M28Utilities.IsTableEmpty(tAltLZTeam[M28Map.subrefLZTAlliedCombatUnits]))) end
                if not(bLandZoneOrAdjHasUnitsWantingScout) and M28Utilities.IsTableEmpty(tAltLZTeam[M28Map.subrefLZTAlliedCombatUnits]) == false then bLandZoneOrAdjHasUnitsWantingScout = true end
                if tAltLZTeam[M28Map.subrefLZTValue] < iCurLZValue and tAltLZTeam[M28Map.subrefLZThreatEnemyMobileDFTotal] <= 50 and M28Utilities.IsTableEmpty(tAltLZTeam[M28Map.subrefLZTAlliedCombatUnits]) == false then
                    for iUnit, oUnit in tAltLZTeam[M28Map.subrefLZTAlliedCombatUnits] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to add adjacent oUnit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' with cur assignment value '..(oUnit[refiCurrentAssignmentValue] or 0)..' and cur assignemnt LZ='..(oUnit[refiCurrentAssignmentPlateauAndLZ][2] or 'nil')) end
                        if not(oUnit.Dead) and ((oUnit[refiCurrentAssignmentValue] or 0) < iCurLZValue or (oUnit[refiCurrentAssignmentPlateauAndLZ][1] == iPlateau and oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iAdjLZ)) then
                            --Combat unit related
                            if (bConsiderAdjacentDF and oUnit[M28UnitInfo.refiDFRange] > 0) or (bConsiderAdjacentIndirect and oUnit[M28UnitInfo.refiIndirectRange] > 0) then
                                table.insert(tAvailableCombatUnits, oUnit)
                                RecordUnitAsReceivingLandZoneAssignment(oUnit, iPlateau, iLandZone, iCurLZValue)

                                iCurUnitThreat = nil
                                if oUnit[M28UnitInfo.refiDFRange] > 0 then
                                    if oUnit[M28UnitInfo.refiDFRange] > iOurBestDFRange then iOurBestDFRange = oUnit[M28UnitInfo.refiDFRange] end
                                    iCurUnitThreat = M28UnitInfo.GetCombatThreatRating({ oUnit })
                                    iCurDFThreat = iCurDFThreat + iCurUnitThreat
                                    if iCurDFThreat > tLZTeamData[M28Map.subrefLZDFThreatWanted] then
                                        bConsiderAdjacentDF = false
                                        if not(bConsiderAdjacentIndirect) and not(bConsiderAdjacentMAA) then break end
                                    end
                                end
                                if oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                                    if oUnit[M28UnitInfo.refiIndirectRange] > iOurBestIndirectRange then iOurBestIndirectRange = oUnit[M28UnitInfo.refiIndirectRange] end
                                    if oUnit[M28UnitInfo.refiIndirectRange] > iMinIndirectRangeNeededForThreat then
                                        if not(iCurUnitThreat) then iCurUnitThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }) end
                                        iCurIndirectThreat = iCurIndirectThreat + iCurUnitThreat
                                        if iCurIndirectThreat > tLZTeamData[M28Map.subrefLZIndirectThreatWanted] then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Just increased our indirect threat for oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurUnitThreat='..iCurUnitThreat..'; iCurIndirectThreat after increase='..iCurIndirectThreat..'; tLZTeamData[M28Map.subrefLZIndirectThreatWanted]='..(tLZTeamData[M28Map.subrefLZIndirectThreatWanted] or 'nil')) end
                                            bConsiderAdjacentIndirect = false
                                            if not(bConsiderAdjacentDF) and not(bConsiderAdjacentMAA) then break end
                                        end
                                    end
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId) then
                                table.insert(tAvailableMAA, oUnit)
                                RecordUnitAsReceivingLandZoneAssignment(oUnit, iPlateau, iLandZone, iCurLZValue)

                                iCurUnitThreat = M28UnitInfo.GetAirThreatLevel({ oUnit }, false, false, true)
                                iCurMAAThreat = iCurMAAThreat + iCurUnitThreat
                                if iCurMAAThreat > tLZTeamData[M28Map.subrefLZMAAThreatWanted] then
                                    bConsiderAdjacentMAA = false
                                    if not(bConsiderAdjacentIndirect) and not(bConsiderAdjacentDF) then break end
                                end
                            end
                        end
                    end
                    if not(bConsiderAdjacentDF) and not(bConsiderAdjacentIndirect) and not(bConsiderAdjacentMAA) then break end
                end
            end
        end

        if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
            if tLZData[M28Map.subrefbPacifistArea] then
                RetreatOtherUnits(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableCombatUnits)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': About to manage combat units in the LZ, iOurBestIndirectRange='..(iOurBestIndirectRange or 'nil')..'; bConsiderAdjacentIndirect='..tostring(bConsiderAdjacentIndirect or false)) end
                ManageCombatUnitsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableCombatUnits, iOurBestDFRange, iOurBestIndirectRange, bConsiderAdjacentIndirect, tUnavailableUnitsInThisLZ)
                bUpdateEnemyDataHere = false
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of MAA empty='..tostring(M28Utilities.IsTableEmpty(tAvailableMAA))..'; Is table of entity filtered dow nto MAA empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMAA, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))) end
        if M28Utilities.IsTableEmpty(tAvailableMAA) == false then
            if tLZData[M28Map.subrefbPacifistArea] then
                RetreatOtherUnits(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableMAA)
            else
                ManageMAAInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableMAA)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Will retreat other units if any, is table empty='..tostring(M28Utilities.IsTableEmpty(tOtherUnitsToRetreat))) end
        if M28Utilities.IsTableEmpty(tOtherUnitsToRetreat) == false then
            RetreatOtherUnits(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tOtherUnitsToRetreat)
        end
        if M28Utilities.IsTableEmpty(tRASSACU) == false then
            ManageRASSACUsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tRASSACU)
        end

        if M28Utilities.IsTableEmpty(tTempOtherUnits) == false then
            --If have temp other units then manage these
            local tNearestWZ
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                    local iNearestWZRef = tSubtable[M28Map.subrefAWZRef]
                    tNearestWZ = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iNearestWZRef]][M28Map.subrefPondWaterZones][iNearestWZRef][M28Map.subrefMidpoint]
                    break
                end
            end
            for iUnit, oUnit in tTempOtherUnits do
                M28Orders.UpdateRecordedOrders(oUnit)
                if oUnit[M28Orders.refiOrderCount] == 0 then
                    --Is this a naval unit?
                    if EntityCategoryContains(M28UnitInfo.refCategoryAllNavy, oUnit.UnitId) then
                        if not(tNearestWZ) then
                            M28Utilities.ErrorHandler('Have naval unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' in land zone with no orders and no adjacent WZ, will move randomly')

                            local tRandomTarget = oUnit:GetPosition()
                            local iRandX = math.random(10, 30)
                            if math.random(0,1) == 0 then iRandX = iRandX * -1 end
                            local iRandZ = math.random(10, 30)
                            if math.random(0,1) == 0 then iRandZ = iRandZ * -1 end
                            tRandomTarget[1] = tRandomTarget[1] + iRandX
                            tRandomTarget[3] = tRandomTarget[3] + iRandZ
                            tRandomTarget[2] = GetSurfaceHeight(tRandomTarget[1], tRandomTarget[3])

                            M28Orders.IssueTrackedMove(oUnit, tRandomTarget, 5, false, 'RandNM', false)
                        else
                            M28Orders.IssueTrackedMove(oUnit, tNearestWZ, 5, false, 'NavInLZBckup', false)
                        end
                    else
                        M28Utilities.ErrorHandler('Have non naval unit with no orders that is of an unrecognised category in LZ, Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; will move randomly')
                        local tRandomTarget = oUnit:GetPosition()
                        local iRandX = math.random(10, 30)
                        if math.random(0,1) == 0 then iRandX = iRandX * -1 end
                        local iRandZ = math.random(10, 30)
                        if math.random(0,1) == 0 then iRandZ = iRandZ * -1 end
                        tRandomTarget[1] = tRandomTarget[1] + iRandX
                        tRandomTarget[3] = tRandomTarget[3] + iRandZ
                        tRandomTarget[2] = GetSurfaceHeight(tRandomTarget[1], tRandomTarget[3])
                        M28Orders.IssueTrackedMove(oUnit, tRandomTarget, 5, false, 'RandLM', false)
                    end
                end
            end
        end
    else
        --No allied units - if this was flagged as an expansion LZ then clear the flag
        if tLZTeamData[M28Map.subrefLZCoreExpansion] then tLZTeamData[M28Map.subrefLZCoreExpansion] = nil end
    end
    --Update enemy ranges for this LZ and decide if this LZ still wants support, if we havent run our main combat management logic
    if bDebugMessages == true then LOG(sFunctionRef..': Will update enemy data for this LZ if are enemies in this LZ. bUpdateEnemyDataHere='..tostring(bUpdateEnemyDataHere or false)) end
    if bUpdateEnemyDataHere then
        UpdateBestEnemyRangesForThisLandZone(tLZData, tLZTeamData, iPlateau, iTeam)
        RecordClosestAdjacentEnemiesAndGetBestEnemyRange(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
        if bDebugMessages == true then LOG(sFunctionRef..': Updating if we want more DF or indirect units for this LZ, tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or false)..'; tLZTeamData[M28Map.subrefLZTValue]='..(tLZTeamData[M28Map.subrefLZTValue] or 'nil')..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal]='..tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal]) end
        local bWantDFSupport = false
        function UpdateDFSupportForEarlyGameEngineers()
            if not(bWantDFSupport) and GetGameTimeSeconds() <= 360 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefMexUnbuiltLocations]) == false and M28Utilities.IsTableEmpty(tEngineers) == false and M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) < M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZTeamData[M28Map.reftClosestFriendlyBase]) * 0.9 then
                bWantDFSupport = true
            end
        end
        if (tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and tLZTeamData[M28Map.subrefLZTValue] >= 200) or tLZData[M28Map.subrefbPacifistArea] then
            local bWantIndirectSupport = false
            if not(tLZData[M28Map.subrefbPacifistArea]) then
                if tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] > 0 then bWantIndirectSupport = true end
                if tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] > 0 or tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] > 0 then bWantDFSupport = true end
                --If havent flagged for any support but enemy has units in this LZ (presumably non-combat) and we have no combat units, then flag for support
                if not(bWantIndirectSupport) and not(bWantDFSupport) and tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] == 0 and tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] == 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.MOBILE * categories.LAND, tLZTeamData[M28Map.subrefTEnemyUnits])) == false then
                        bWantDFSupport = true
                    elseif M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.STRUCTURE, tLZTeamData[M28Map.subrefTEnemyUnits])) == false then
                        bWantIndirectSupport = true
                    end
                end
                --If enemy has PD in this or adjacent zone then flag we want indirect support
                if not(bWantIndirectSupport) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false and tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] <= math.min(2000 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech], tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] * 3) then
                    for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                        if tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] > 0 then bWantIndirectSupport = true break end
                    end
                    if not(bWantIndirectSupport) and GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMD] or -100) <= 10 then bWantIndirectSupport = true end
                end

                --Early game - flag that we want support if we have engineers and unclaimed mexes
                UpdateDFSupportForEarlyGameEngineers()
            end
            UpdateIfLandZoneWantsSupport(tLZTeamData, iPlateau, iLandZone, iTeam, bWantDFSupport, bWantIndirectSupport)
            if bDebugMessages == true then LOG(sFunctionRef..': Will update if this land zone wants some DF support='..tostring(bWantDFSupport)..'; bWantIndirectSupport='..tostring(bWantIndirectSupport)) end
        else
            local bWantIndirectSupport = false
            if bDebugMessages == true then LOG(sFunctionRef..': Are there enemis in this or adjacent LZ, for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Do we have a valid nearby structure in other plateau='..tostring( M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]))..'; Our highest land tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]..'; bWantDFSupport='..tostring(bWantDFSupport)) end
            if GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMD] or -100) <= 10 and not(tLZData[M28Map.subrefbPacifistArea]) then
                if bDebugMessages == true then LOG(sFunctionRef..': Have had MML firing recently near TMD so want more indirect fire support') end
                bWantIndirectSupport = true
            elseif not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and not(bWantIndirectSupport) and M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3 then
                bWantIndirectSupport = M28Conditions.IsNearbyStructureThatWeCanReachWithIndirect(tLZData, tLZTeamData, iTeam)
                if bDebugMessages == true then LOG(sFunctionRef..': bWantIndirectSupport after checking if nearby structure we can reach with indirect='..tostring(bWantIndirectSupport)) end
            end
            UpdateDFSupportForEarlyGameEngineers()
            UpdateIfLandZoneWantsSupport(tLZTeamData, iPlateau, iLandZone, iTeam, bWantDFSupport, bWantIndirectSupport)
        end
    end
    --Handle engineers and even if no engineers still decide what engineers we would want for hte LZ
    M28Engineer.ConsiderLandOrWaterZoneEngineerAssignment(tLZTeamData, iTeam, iPlateau, iLandZone, tEngineers) --Should update the land zone engineer requirements, even if tEngineers itself is empty

    ManageLandZoneScouts(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tScouts, bLandZoneOrAdjHasUnitsWantingScout)


    --Update visual based on omni
    if tLZTeamData[M28Map.refiOmniCoverage] > 30 then tLZTeamData[M28Map.refiTimeLastHadVisual] = GetGameTimeSeconds() end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Is unbuild locations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]))) end

    --Update BP wanted for adjacent zones - will just have a flag in the engineer assignment that sets subrefTbWantBP to true/false so commented out the below
    --[[tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted] = {[1]=0, [2]=0,[3]=0}
    tLZTeamData[M28Map.subrefTbWantBP] = false
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[M28Map.iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjLZ in M28Map.tAllPlateaus[M28Map.iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones] do
            for iTech = 1, 3, 1 do
                tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted] = math.max(tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted][iTech], (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][iTech] or 0))
            end
        end
    end
    for iTech = 1, 3, 1 do
        if tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted][iTech] > 0 or tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted][iTech] > 0 then
            tLZTeamData[M28Map.subrefTbWantBP] = true
        end
    end--]]
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AssignValuesToLandZones(iTeam)
    --Periodically cycles through every land zone and refreshes the unit details
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignValuesToLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
    if aiBrain then

        if bDebugMessages == true then
            LOG(sFunctionRef..': About to start the main loop for assigning values to land zones provided we have friendly M28 brains in the team '..iTeam..'; is table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))..'; will list out the plateau and LZ for each member of the team')
            local iStartPlateau, iStartLZ
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                iStartPlateau, iStartLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                LOG(sFunctionRef..': Brain '..oBrain.Nickname..' has start position '..repru(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])..' with iStartPlateau='..(iStartPlateau or 'nil')..' and iStartLZ='..(iStartLZ or 'nil'))
            end
        end
        local iCurValue
        local tFriendlyNonPDBuildings
        local bAdjacentToCoreFactory
        local iFriendlyBuildingValue
        local iCurCycleCount = 0
        local iZonesSinceWait = 0
        local iTotalLandZones = 0
        for iPlateau, tPlateauData in M28Map.tAllPlateaus do
            iTotalLandZones = iTotalLandZones + (tPlateauData[M28Map.subrefLandZoneCount] or 0)
        end
        local iZonesPerTick = math.max(1, math.floor(iTotalLandZones / 20))
        while M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false do
            iCurCycleCount = iCurCycleCount + 1 --used so we dont wait the first time, so we have recorded which zones are core zones
            local tiPlateauAndLZWithFriendlyStartPosition = {}
            local iBaseCategory
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iBrain='..iBrain..'; oBrain='..oBrain.Nickname..'; Army index='..oBrain:GetArmyIndex()..'; Player start point='..repru(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])..'; Plateau and LZ of this start point='..iPlateau..'-'..iLandZone) end
                if not(tiPlateauAndLZWithFriendlyStartPosition[iPlateau]) then tiPlateauAndLZWithFriendlyStartPosition[iPlateau] = {} end
                if (iLandZone or 0) > 0 then
                    tiPlateauAndLZWithFriendlyStartPosition[iPlateau][iLandZone] = true
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished recording the friendly start positions for each brain, tiPlateauAndLZWithFriendlyStartPosition='..repru(tiPlateauAndLZWithFriendlyStartPosition)) end
            iBaseCategory = categories.TECH3 * M28UnitInfo.refCategoryAllHQFactories + M28UnitInfo.refCategoryAirHQ * categories.TECH2
            --[[if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then iBaseCategory = categories.TECH3 * M28UnitInfo.refCategoryAllHQFactories + M28UnitInfo.refCategoryAirHQ * categories.TECH2
            elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 then iBaseCategory = M28UnitInfo.refCategoryAllHQFactories - categories.TECH1
            else iBaseCategory = M28UnitInfo.refCategoryAirFactory --Dont want to include t1 land facs since might be in a minor zone
            end--]]

            for iPlateau, tPlateauData in M28Map.tAllPlateaus do
                if M28Utilities.IsTableEmpty(tPlateauData[M28Map.subrefPlateauLandZones]) == false then

                    --tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
                    for iLandZone, tLandZoneData in tPlateauData[M28Map.subrefPlateauLandZones] do
                        iZonesSinceWait = iZonesSinceWait + 1
                        local tLZTeamData = tLandZoneData[M28Map.subrefLZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': About to refresh value of iPlateau='..iPlateau..'; iLandZone='..iLandZone..' for team '..iTeam) end
                        --Decide on value of the land zone ignoring distance:
                        --Treat each mex position as being worth 250 mass, value reclaim at 25% of the total value, and reflect the value of all non-PD in the area
                        iCurValue = tLandZoneData[M28Map.subrefLZMexCount] * 250 + (tLandZoneData[M28Map.subrefTotalMassReclaim] or 0) * 0.25
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                            tFriendlyNonPDBuildings = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryPD, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                            iFriendlyBuildingValue = M28UnitInfo.GetCombatThreatRating(tFriendlyNonPDBuildings, false, true)
                            iCurValue = iCurValue + iFriendlyBuildingValue
                        else
                            iFriendlyBuildingValue = 0
                        end

                        if tLZTeamData[M28Map.refbACUInTrouble] then
                            iCurValue = iCurValue + M28ACU.GetValueIncreaseForACUInTrouble(iTeam)
                        end

                        --Record the value
                        tLZTeamData[M28Map.subrefLZTValue] = iCurValue
                        tLZTeamData[M28Map.subrefLZSValue] = iFriendlyBuildingValue
                        tLZTeamData[M28Map.subrefLZbCoreBase] = nil

                        --Is this a core base land zone?
                        if bDebugMessages == true then LOG(sFunctionRef..': iCurValue based on this zone='..iCurValue..'; iFriendlyBuildingValue='..iFriendlyBuildingValue..'; Checking if we are a friendly land zone - tiPlateauAndLZWithFriendlyStartPosition='..repru(tiPlateauAndLZWithFriendlyStartPosition)..'; Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
                        if tiPlateauAndLZWithFriendlyStartPosition[iPlateau][iLandZone] or tLZTeamData[M28Map.subrefbCoreBaseOverride] then
                            tLZTeamData[M28Map.subrefLZbCoreBase] = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Core LZ='..iLandZone..' for plateau '..iPlateau..'; All adjacent zones='..repru(tLandZoneData[M28Map.subrefLZAdjacentLandZones])..'; tiPlateauAndLZWithFriendlyStartPosition[iPlateau][iLandZone]=nil='..tostring(tiPlateauAndLZWithFriendlyStartPosition[iPlateau][iLandZone] == nil)..'; tLZTeamData[M28Map.subrefbCoreBaseOverride]='..tostring(tLZTeamData[M28Map.subrefbCoreBaseOverride] or false)..'; Island ref='..(tLandZoneData[M28Map.subrefLZIslandRef] or 'nil')) end
                            --adjacent zones iwth lots of mexes in them and high mex count - consider treating as a core base
                        elseif tLandZoneData[M28Map.subrefLZMexCount] >= 4 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                            --Are we adjacent to a core zone and we contain a factory or high value unit? If so then treat us as a core LZ
                            bAdjacentToCoreFactory = false
                            if M28Utilities.IsTableEmpty(tLandZoneData[M28Map.subrefLZAdjacentLandZones]) == false then
                                for iEntry, iAdjLZ in tLandZoneData[M28Map.subrefLZAdjacentLandZones] do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we are adjacent to a core LZ, iAdjLZ='..iAdjLZ..'; Is AdjLZ a core LZ='..tostring(tPlateauData[M28Map.subrefPlateauLandZones][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase])) end
                                    if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] then
                                        bAdjacentToCoreFactory = true
                                        break
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': bAdjacentToCoreFactory='..tostring(bAdjacentToCoreFactory)..'; Is table of factory HQs empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(iBaseCategory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))) end
                                if bAdjacentToCoreFactory and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(iBaseCategory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Are adjacent to a core factory, and have iBaseCategory units in this zone, iLandZone='..iLandZone..'; iPlateau='..iPlateau) end
                                    tLZTeamData[M28Map.subrefLZbCoreBase] = true
                                end
                            end

                        end

                        if iZonesSinceWait >= iZonesPerTick and iCurCycleCount > 1 then --dont want to wait the first time, as on large maps can mean a delay in the ACU building
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitTicks(1)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                            iZonesSinceWait = 0
                        end
                    end
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1) --Needed to avoid infinite loop if are no LZs (e.g. on a water map)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    else
        M28Utilities.ErrorHandler('No active M28 brain')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageAllLandZones(aiBrain, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageAllLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iLastRefreshCount = (tLZRefreshCountByTeam[iTeam] or 1)
    local iCurRefreshCount = 0
    local iTicksToSpreadOver = 10
    local iRefreshThreshold = math.max(2, math.ceil(iLastRefreshCount * 0.95 / iTicksToSpreadOver))
    local iCurCycleRefreshCount = 0
    local iCurTicksWaited = 0

    if bDebugMessages == true then
        LOG(sFunctionRef..': Start of code, Time='..GetGameTimeSeconds()..'; If have an ACU will list its plateau and land zone. iRefreshThreshold='..iRefreshThreshold..'; iLastRefreshCount='..iLastRefreshCount..'; iTicksToSpreadOver='..iTicksToSpreadOver)
        local tOurACU = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
        if M28Utilities.IsTableEmpty(tOurACU) == false then
            local iACUPlateau, iACULZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tOurACU[1]:GetPosition(), true, tOurACU[1])
            LOG(sFunctionRef..': ACU is at plateau '..iACUPlateau..'; LZ='..iACULZ)
        end
        LOG(sFunctionRef..': Is plateau 12 LZ 2 empty of allies for team 2='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[12][M28Map.subrefPlateauLandZones][2][M28Map.subrefLZTeamData][2][M28Map.subreftoLZOrWZAlliedUnits])))
    end

    if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastRallyPointRefresh] or -100) >= 10 then
        RefreshLandRallyPoints(iTeam)
    end



    --Cycle through land zones
    local bAlwaysUpdateEnemyAirUnitPositions = M28Map.bIsCampaignMap --campaign map players are more likely to know when air attacks iwll attack and from where
    for iPlateau, tPlateauData in M28Map.tAllPlateaus do
        if M28Utilities.IsTableEmpty(tPlateauData[M28Map.subrefPlateauLandZones]) == false then
            if bDebugMessages == true then
                LOG(sFunctionRef..': About to cycle through every land zone in plateau '..iPlateau..'; subrefLandZoneCount='..tPlateauData[M28Map.subrefLandZoneCount])
                LOG(sFunctionRef..': Is plateau 12 LZ 2 empty of allies for team 2='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[12][M28Map.subrefPlateauLandZones][2][M28Map.subrefLZTeamData][2][M28Map.subreftoLZOrWZAlliedUnits])))
            end
            for iLandZone, tLandZoneDataByTeam in tPlateauData[M28Map.subrefPlateauLandZones] do
                local tLZTeamData = tLandZoneDataByTeam[M28Map.subrefLZTeamData][iTeam]
                if bDebugMessages == true then
                    LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Is table of enemey units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))..'; Is table of friendly units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))..'; GameTime='..GetGameTimeSeconds()..'; Is table of enemy air units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits])))
                end
                --First check all units in here are alive
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                    --UpdateUnitPositionsAndLandZone(aiBrain, tUnits,                               iTeam, iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
                    UpdateUnitPositionsAndLandZone(aiBrain, tLZTeamData[M28Map.subrefTEnemyUnits], iTeam, iPlateau,             iLandZone,          M28Map.bIsCampaignMap, false, tLZTeamData,  false,                      true)
                end
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) == false then
                    iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                    --Update air positions if we have units in the zone or has been a while to approximate a player being able to tell if enemy air force is still there
                    if bAlwaysUpdateEnemyAirUnitPositions or (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false or GetGameTimeSeconds() - (tLZTeamData[M28Map.refiTimeOfLastAirUpdate] or -100) >= 12 or (M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.reftLZEnemyAirUnits][1]) and M28UnitInfo.CanSeeUnit(aiBrain, tLZTeamData[M28Map.reftLZEnemyAirUnits][1], true)) or (tLZTeamData[M28Map.refiRadarCoverage] or 0) > 0) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Updating air unit positions in the zone') end
                        tLZTeamData[M28Map.refiTimeOfLastAirUpdate] = GetGameTimeSeconds()
                        --UpdateUnitPositionsAndLandZone(aiBrain, tUnits,                       iTeam, iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
                        UpdateUnitPositionsAndLandZone(aiBrain, tLZTeamData[M28Map.reftLZEnemyAirUnits], iTeam, iPlateau, iLandZone, false, true, tLZTeamData, false,                               true)
                    else
                        --UpdateUnitPositionsAndLandZone(aiBrain, tUnits,                           iTeam, iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
                        UpdateUnitPositionsAndLandZone(aiBrain, tLZTeamData[M28Map.reftLZEnemyAirUnits], iTeam, iPlateau, iLandZone,        M28Map.bIsCampaignMap, true, tLZTeamData,   false,                                  true)
                    end
                end
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                    iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                    UpdateUnitPositionsAndLandZone(aiBrain, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits], iTeam, iPlateau, iLandZone, false, false, tLZTeamData)
                end

                ManageSpecificLandZone(aiBrain, iTeam, iPlateau, iLandZone)
                iCurCycleRefreshCount = iCurCycleRefreshCount + 1

                if iCurCycleRefreshCount >= iRefreshThreshold then
                    iCurRefreshCount = iCurRefreshCount + iCurCycleRefreshCount
                    iCurCycleRefreshCount = 0
                    if iCurTicksWaited < iTicksToSpreadOver then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        iCurTicksWaited = iCurTicksWaited + 1
                    end
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Warning - no land zones found for plateau '..iPlateau) end
        end
    end
    iCurRefreshCount = iCurRefreshCount + iCurCycleRefreshCount
    tLZRefreshCountByTeam[iTeam] = iCurRefreshCount

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function LandZoneOverseer(iTeam)
    --Periodically cycles through every land zone and refreshes the unit details
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'LandZoneOverseer'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
    if aiBrain then

        if bDebugMessages == true then LOG(sFunctionRef..': About to start the main loop for land zones provided we have friendly M28 brains in the team '..iTeam..'; is table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end
        ForkThread(AssignValuesToLandZones, iTeam)

        local iWaitCount = 0
        while not(M28Map.bMapLandSetupComplete) or GetGameTimeSeconds() <= 4 do
            iWaitCount = iWaitCount + 1
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if iWaitCount >= 200 then M28Utilities.ErrorHandler('Have waited more than '..iWaitCount..' and map setup not complete, will proceed but likely AI wont work') break end
        end

        while M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false do
            if bDebugMessages == true then LOG(sFunctionRef..': Will call logic to refresh every unit in a land zone') end
            ForkThread(ManageAllLandZones, aiBrain, iTeam)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if aiBrain.M28IsDefeated and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': About to restart the loop for team '..iTeam..'; aiBrain referred to='..(aiBrain.Nickname or 'nil')..'; Is table of active m28 brains='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetLandZoneToRunTo(iTeam, iPlateau, iCurLandZone, sPathing, tOptionalStartPosition, tOptionalEnemyPositionToRunFrom)
    --Returns cur LZ if no LZ to run to, otherwise returns the land zone we think is best to run to from iCurLandZone
    --tOptionalStartPosition - if nil then will use midpoint of iCurLandZone
    --tOptionalEnemyPositionToRunFrom - if this is specified, then will pick al ocation based on angle from the start position to the location vs the start position angle to the enemy position to run to (so we run in the opposite direction to the enemy position if the opposite direction LZ is safe)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetLandZoneToRunTo'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': iTeam='..iTeam..'; iPlateau='..iPlateau..'; iCurLandZone='..iCurLandZone..'; sPathing='..sPathing..'; tOptionalStartPosition='..repru(tOptionalStartPosition)..'; tOptionalEnemyPositionToRunFrom='..repru(tOptionalEnemyPositionToRunFrom)) end

    local tLZShortlist = {}
    --See if we have any adjacent LZs with no enemy combat units in them - if so, then run here
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjacentLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefLZAdjacentLandZones] do
            if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjacentLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] == 0 then
                table.insert(tLZShortlist, iAdjacentLZ)
            end
        end
    end
    if M28Utilities.IsTableEmpty(tLZShortlist) then
        --Add each team start point on the same plateau
        local iPotentialPlateau, iPotentialLZ
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                iPotentialPlateau, iPotentialLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                if iPotentialPlateau == iPlateau and not(iPotentialLZ == iCurLandZone) then
                    table.insert(tLZShortlist, iPotentialLZ)
                end
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Getting LZ to run to from, iTeam='..iTeam..'; iPlateau='..iPlateau..'; iCurLandZone='..iCurLandZone..'; sPathing='..sPathing..'; tLZShortlist='..repru(tLZShortlist)) end
    if M28Utilities.IsTableEmpty(tLZShortlist) then
        --Nowhere to run to
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return iCurLandZone
    else
        local tStartPoint = (tOptionalStartPosition or M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefMidpoint])
        local iPreferredLZRef
        if tOptionalEnemyPositionToRunFrom then
            --Go to the angle furthest in angle away from the nearest enemy
            local iAngleToEnemy = M28Utilities.GetAngleFromAToB(tStartPoint, tOptionalEnemyPositionToRunFrom)
            local iCurAngleDif
            local iHighestAngleDif = 0
            for _, iPossibleLZ in tLZShortlist do
                iCurAngleDif = M28Utilities.GetAngleDifference(iAngleToEnemy, M28Utilities.GetAngleFromAToB(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefMidpoint]))
                if iCurAngleDif > iHighestAngleDif then
                    iHighestAngleDif = iCurAngleDif
                    iPreferredLZRef = iPossibleLZ
                end
            end
        else
            --dont have angle to nearest enemy so just pick the closest land zone

            local iClosestLZDistance = 100000
            local iClosestLZRef
            local iCurDist
            for _, iPossibleLZ in tLZShortlist do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering distance from tStartPoint to iPossibleLZ '..(iPossibleLZ or 'nil')..'; Midpoint of that LZ='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefMidpoint])..'; iCurDist='..(M28Utilities.GetTravelDistanceBetweenPositions(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefMidpoint], sPathing) or 'nil')) end
                iCurDist = M28Utilities.GetTravelDistanceBetweenPositions(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefMidpoint], sPathing)
                --Backup - if the built in pathfinding doesnt htink we can path there (e.g. we are by a cliff) then use straight line distance
                if not(iCurDist) then iCurDist = M28Utilities.GetDistanceBetweenPositions(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefMidpoint]) + 30 end

                if iCurDist < iClosestLZDistance then
                    iClosestLZDistance = iCurDist
                    iPreferredLZRef = iPossibleLZ
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return iPreferredLZRef
    end
end

function IsLandZonePathSafe(iPlateau, tLZData, iTeam, iPathingRef, bIslandPathing)
    --More performant version of IsItSafeToPathBetweenLandZones, to check if safe to path from the tLZData land zone to the tAltLZ land zone, based on iPathingRef for tLZData
    --bIslandPathing shoudl be true if are trying to path to an island (i.e. that a land unit cant get to), so the correct table references are used
    if bIslandPathing then
        for _, iLandZoneRef in tLZData[M28Map.subrefLZPathingToOtherIslands][iPathingRef][M28Map.subrefIslandLZPath] do
            --Are there any units in this LZ that are dangerous?
            if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZoneRef][iTeam][M28Map.subrefbDangerousEnemiesInThisLZ] then
                return false
            end
        end
    else
        if tLZData[M28Map.subrefLZPathingToOtherLandZones][iPathingRef][M28Map.subrefLZPath] then
            for _, iLandZoneRef in tLZData[M28Map.subrefLZPathingToOtherLandZones][iPathingRef][M28Map.subrefLZPath] do
                --Are there any units in this LZ that are dangerous?
                if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZoneRef][iTeam][M28Map.subrefbDangerousEnemiesInThisLZ] then
                    return false
                end
            end
        end
    end
    return true
end

--Below code should function but when used for engineers took way too long so redid using IsLandZonePathSafe - look to make use of the varaibles recorded for this to come up with a more performant approach to the below if want the below functionality
--[[function IsItSafeToPathBetweenLandZones(iTeam, iPlateau, iStartLandZone, iEndLandZone, sPathing)
    --Returns true if no enemy threats in any of the land zones that will path through (doesnt consider adjacent zones for performance reasons)
        --Only combat threats should be considered
        --WARNING - Very intensive function, use sparingly - in most cases referring to subrefLZPathingToOtherLandZones is better which will record 3 layers of adjacency to the current zone (more for core LZs)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsItSafeToPathBetweenLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tFullPath, iPathSize, iDistance = NavUtils.PathTo((sPathing or 'Land'), M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iStartLandZone][M28Map.subrefMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iEndLandZone][M28Map.subrefMidpoint], nil)
    if M28Utilities.IsTableEmpty(tFullPath) == false then
        local tLZConsidered = {}
        local iCurPlateau, iCurLZ
        for iPath, tPath in tFullPath do
            iCurPlateau, iCurLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tPath)
            if iCurPlateau and iCurLZ then
                if not(tLZConsidered[iCurLZ]) then
                    tLZConsidered[iCurLZ] = true
                    --Are there any units in this LZ that are dangerous?
                    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                        for iUnit, oUnit in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits] do
                            if ((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or (oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0) and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) then
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return false
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return true
end--]]

function DrawReclaimSegmentsInLandZone(iPlateau, iLandZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DrawReclaimSegmentsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local rCurRect
    if bDebugMessages == true then LOG(sFunctionRef..': About to draw reclaim segnemtns for iPlateau '..iPlateau..' iLandZone '..iLandZone..'; Table of reclaim segments='..repru(tLZData[M28Map.subrefReclaimSegments])) end

    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefReclaimSegments]) == false then
        for iCount, tSegmentXZ in tLZData[M28Map.subrefReclaimSegments] do
            rCurRect = M28Utilities.GetRectAroundLocation(M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][M28Map.refReclaimSegmentMidpoint], M28Map.iReclaimSegmentSizeX * 0.5)
            M28Utilities.DrawRectangle(rCurRect)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function UpdateRecordedAllPlayerOmni(oRadar, bDestroyed)
    local oBP = oRadar:GetBlueprint()
    local iRadarOmni =  (oBP.Intel.OmniRadius or 0)

    if iRadarOmni > 0 then
        local iMaxZoneDistance = iRadarOmni + 50

        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oRadar:GetPosition())
        if iPlateau and iLandZone then
            local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
            if tLZData then
                function UpdateOmniCoverageForZone(iCurPlateauOrPond, iCurLZOrWZ, bIsWaterZone)
                    local tCurLZOrWZData
                    if bIsWaterZone then
                        tCurLZOrWZData = M28Map.tPondDetails[iCurPlateauOrPond][M28Map.subrefPondWaterZones][iCurLZOrWZ]
                    else tCurLZOrWZData = M28Map.tAllPlateaus[iCurPlateauOrPond][M28Map.subrefPlateauLandZones][iCurLZOrWZ]
                    end

                    --Remove oRadar from the table of omni in this zone
                    if bDestroyed then
                        if M28Utilities.IsTableEmpty(tCurLZOrWZData[M28Map.reftoAllOmniRadar]) == false then
                            --Update the table
                            local iEntryCount = table.getn(tCurLZOrWZData[M28Map.reftoAllOmniRadar])
                            for iCurEntry = iEntryCount, 1, -1 do
                                local oUnit = tCurLZOrWZData[M28Map.reftoAllOmniRadar][iCurEntry]
                                if not(M28UnitInfo.IsUnitValid(oUnit)) or oUnit == oRadar then
                                    table.remove(tCurLZOrWZData[M28Map.reftoAllOmniRadar], iCurEntry)
                                end
                            end
                        end
                    else
                        local bAddToTable = true
                        if not(tCurLZOrWZData[M28Map.reftoAllOmniRadar]) then tCurLZOrWZData[M28Map.reftoAllOmniRadar] = {}
                        else
                            for iUnit, oUnit in tCurLZOrWZData[M28Map.reftoAllOmniRadar] do
                                if oUnit == oRadar then bAddToTable = false break end
                            end
                        end
                        if bAddToTable and iRadarOmni - M28Utilities.GetDistanceBetweenPositions(oRadar:GetPosition(), tCurLZOrWZData[M28Map.subrefMidpoint]) > 0 then
                            table.insert(tCurLZOrWZData[M28Map.reftoAllOmniRadar], oRadar)
                        end
                    end

                    local iBestOmniCoverage = 0
                    if M28Utilities.IsTableEmpty(tCurLZOrWZData[M28Map.reftoAllOmniRadar]) == false then
                        local iCurOmniCoverage
                        for iUnit, oUnit in tCurLZOrWZData[M28Map.reftoAllOmniRadar] do
                            iCurOmniCoverage = (oUnit:GetBlueprint().Intel.OmniRadius or 0)
                            if iCurOmniCoverage > iBestOmniCoverage  then
                                iCurOmniCoverage = math.max(0, iCurOmniCoverage - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tCurLZOrWZData[M28Map.subrefMidpoint]))
                                if iCurOmniCoverage > iBestOmniCoverage then
                                    iBestOmniCoverage = iCurOmniCoverage
                                end
                            end
                        end

                    end
                    tCurLZOrWZData[M28Map.refiAllOmniCoverage] = iBestOmniCoverage
                end

                UpdateOmniCoverageForZone(iPlateau, iLandZone, false)
                M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint])
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                    for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                        if tSubtable[M28Map.subrefiDistance] > iMaxZoneDistance then break end
                        UpdateOmniCoverageForZone(tSubtable[M28Map.subrefiPlateauOrPond], tSubtable[M28Map.subrefiLandOrWaterZoneRef], tSubtable[M28Map.subrefbIsWaterZone])
                    end
                end
            end
        end
    end
end

function UpdateRadarCoverageForDestroyedRadar(oRadar)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateRadarCoverageForDestroyedRadar'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --First update land zones
    if bDebugMessages == true then LOG(sFunctionRef..': oRadar has been destroyed, oRadar='..oRadar.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRadar)..'; Time='..GetGameTimeSeconds()..'; Is table of zones covered by team empty='..tostring(M28Utilities.IsTableEmpty(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam]))) end
    if M28Utilities.IsTableEmpty(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam]) == false then
        for iTeam, tRadarData in oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam] do
            --local aiBrain = oRadar:GetAIBrain()
            --local iTeam = aiBrain.M28Team
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            if aiBrain then
                for iEntry, tiPlateauAndLZ in tRadarData do
                    local tLZData = M28Map.tAllPlateaus[tiPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][tiPlateauAndLZ[2]]
                    if tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar] == oRadar then
                        tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar] = nil
                        tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] = 0
                        tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiOmniCoverage] = 0

                        local tNearbyRadar = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryRadar, tLZData[M28Map.subrefMidpoint], 600, 'Ally')
                        local iCurIntelRange
                        local iBestIntelRange = 0
                        local oBestRadar
                        local iCurDist
                        local oBP
                        local iCurOmniRange
                        local iBestOmniRange = 0
                        if M28Utilities.IsTableEmpty(tNearbyRadar) == false then
                            for iUnit, oUnit in tNearbyRadar do
                                oBP = oUnit:GetBlueprint()
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                iCurIntelRange = (oBP.Intel.RadarRadius or 0) - iCurDist
                                iCurOmniRange = (oBP.Intel.OmniRadius or 0) - iCurDist
                                if iCurIntelRange > iBestIntelRange then
                                    iBestIntelRange = iCurIntelRange
                                    oBestRadar = oUnit
                                end
                                if iCurOmniRange > iBestOmniRange then
                                    iBestOmniRange = iCurOmniRange
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering nearby radar units for P='..tiPlateauAndLZ[1]..'Z'..tiPlateauAndLZ[2]..'; Is table of nearby radar empty='..tostring(M28Utilities.IsTableEmpty(tNearbyRadar))..'; oBestRadar='..(oBestRadar.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBestRadar) or 'nil')) end
                        if oBestRadar then
                            tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar] = oBestRadar
                            tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] = iBestIntelRange
                            tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiOmniCoverage] = iBestOmniRange
                            if not(oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam]) then oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam] = {} end
                            if not(oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam]) then oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam] = {} end
                            table.insert(oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam], {tiPlateauAndLZ[1], tiPlateauAndLZ[2]})
                        end
                    end
                end
            end
        end
    end
    --Then update water zones:
    if M28Utilities.IsTableEmpty(oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam]) == false then
        for iTeam, tRadarData in oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam] do
            --local aiBrain = oRadar:GetAIBrain()
            --local iTeam = aiBrain.M28Team

            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            if aiBrain then
                local iPond
                for iEntry, iWaterZone in tRadarData do
                    iPond = M28Map.tiPondByWaterZone[iWaterZone]
                    local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
                    local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                    if tWZTeamData[M28Map.refoBestRadar] == oRadar then
                        tWZTeamData[M28Map.refoBestRadar] = nil
                        tWZTeamData[M28Map.refiRadarCoverage] = 0
                        tWZTeamData[M28Map.refiOmniCoverage] = 0
                        local tNearbyRadar = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryRadar, tWZData[M28Map.subrefMidpoint], 600, 'Ally')
                        local iCurIntelRange
                        local iBestIntelRange = 0
                        local oBestRadar
                        local iCurDist
                        local oBP
                        local iCurOmniRange
                        local iBestOmniRange = 0
                        if M28Utilities.IsTableEmpty(tNearbyRadar) == false then
                            for iUnit, oUnit in tNearbyRadar do
                                oBP = oUnit:GetBlueprint()
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tWZData[M28Map.subrefMidpoint])
                                iCurIntelRange = (oBP.Intel.RadarRadius or 0) - iCurDist
                                if iCurIntelRange > iBestIntelRange then
                                    iBestIntelRange = iCurIntelRange
                                    oBestRadar = oUnit
                                end
                                iCurOmniRange = (oBP.Intel.OmniRadius or 0) - iCurDist
                                if iCurOmniRange > iBestOmniRange then
                                    iBestOmniRange = iCurOmniRange
                                end
                            end
                        end
                        if oBestRadar then
                            tWZTeamData[M28Map.refoBestRadar] = oBestRadar
                            tWZTeamData[M28Map.refiRadarCoverage] = iBestIntelRange
                            tWZTeamData[M28Map.refiOmniCoverage] = iBestOmniRange
                            if not(oBestRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam]) then oBestRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam] = {} end
                            if not(oBestRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam]) then oBestRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam] = {} end
                            table.insert(oBestRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam], iWaterZone)
                        end
                    end
                end
            end
        end
    end
    --Then update enemy recorded omni range
    UpdateRecordedAllPlayerOmni(oRadar, true)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateZoneIntelForRadar(oRadar)
    --If just built radar then want to update all land zones for the team to indicate the intel coverage
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateZoneIntelForRadar'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iTeam = oRadar:GetAIBrain().M28Team
    if bDebugMessages == true then LOG(sFunctionRef..': Just built radar '..oRadar.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRadar)..' owned by '..oRadar:GetAIBrain().Nickname..' with M28Team '..iTeam..'; is the table of active m28 brains for this team empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))..'; Time='..GetGameTimeSeconds()) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        if not(oRadar['M28UpdatedIntel']) then
            oRadar['M28UpdatedIntel'] = true
            local oBP = oRadar:GetBlueprint()
            local iIntelRange = (oBP.Intel.RadarRadius or 0)
            local iCurIntelRange
            local iOmniRange = (oBP.Intel.OmniRadius or 0)
            if bDebugMessages == true then LOG(sFunctionRef..': Radar intel range='..iIntelRange) end
            if iIntelRange > 0 or iOmniRange > 0 then
                --Update land zones:
                local tPotentiallyObsoleteRadar = {}
                for iPlateau, tPlateauSubtable in M28Map.tAllPlateaus do
                    for iLandZone, tLZData in tPlateauSubtable[M28Map.subrefPlateauLandZones] do
                        if tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] < iIntelRange then
                            iCurIntelRange = iIntelRange - M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oRadar:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateau '..iPlateau..' Land zone '..iLandZone..'; iCurIntelRange factoring in distance='..iCurIntelRange..'; Distance='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oRadar:GetPosition())..'; LZ current radar coverage='..tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage]..'; tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar]='..(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar]) or 'nil')) end
                            if iCurIntelRange > tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] then
                                --First remove this plateau and LZ from the existing radar if there was one
                                if M28UnitInfo.IsUnitValid(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar]) then
                                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar][reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam]) == false then
                                        for iEntry, tiPlateauAndLZ in tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar][reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam] do
                                            if tiPlateauAndLZ[1] == iPlateau and tiPlateauAndLZ[2] == iLandZone then
                                                table.remove(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar][reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam], iEntry)
                                                break
                                            end
                                        end
                                    end
                                    table.insert(tPotentiallyObsoleteRadar, tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar])
                                    if bDebugMessages == true then LOG(sFunctionRef..': Added radar '..tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar].UnitId..M28UnitInfo.GetUnitLifetimeCount(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar])..' to potentially obsolete table') end
                                end
                                tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] = iCurIntelRange
                                tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar] = oRadar
                                if not(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam]) then oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam] = {} end
                                if not(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam]) then oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam] = {} end
                                table.insert(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam], {iPlateau, iLandZone})
                                if bDebugMessages == true then LOG(sFunctionRef..': Finished udpating for the new intel range, tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage]='..tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage]) end
                            end
                        end
                        if iOmniRange > (tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiOmniCoverage] or 0) then
                            tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiOmniCoverage] = math.max((tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiOmniCoverage] or 0), iOmniRange - M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oRadar:GetPosition()))
                        end
                    end
                end
                --Update water zones
                for iPond, tPondSubtable in M28Map.tPondDetails do
                    if M28Utilities.IsTableEmpty(tPondSubtable[M28Map.subrefPondWaterZones]) == false then
                        for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
                            local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                            if tWZTeamData[M28Map.refiRadarCoverage] < iIntelRange then
                                iCurIntelRange = iIntelRange - M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oRadar:GetPosition())
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering iPond '..iPond..' Water zone '..iWaterZone..'; iCurIntelRange factoring in distance='..iCurIntelRange..'; Distance='..M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oRadar:GetPosition())..'; WZ current radar coverage='..tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiRadarCoverage]) end
                                if iCurIntelRange > tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiRadarCoverage] then
                                    --First remove this WZ from the existing (worse) radar if there was one
                                    if M28UnitInfo.IsUnitValid(tWZTeamData[M28Map.refoBestRadar]) then
                                        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.refoBestRadar][M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam]) == false then
                                            for iEntry, iRecordedWaterZone in tWZTeamData[M28Map.refoBestRadar][M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam] do
                                                if iRecordedWaterZone == iWaterZone then
                                                    table.remove(tWZTeamData[M28Map.refoBestRadar][M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam], iEntry)
                                                    break
                                                end
                                            end
                                        end
                                    end
                                    --Now assign this WZ to this radar as providing the best coverage
                                    tWZTeamData[M28Map.refiRadarCoverage] = iCurIntelRange
                                    tWZTeamData[M28Map.refoBestRadar] = oRadar
                                    if not(oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam]) then oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam] = {} end
                                    if not(oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam]) then oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam] = {} end
                                    table.insert(oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam], iWaterZone)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished udpating for the new intel range, iWaterZone='..iWaterZone..'; tWZTeamData[M28Map.refiRadarCoverage]='..tWZTeamData[M28Map.refiRadarCoverage]) end
                                    table.insert(tPotentiallyObsoleteRadar, tWZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar])
                                end
                            end
                            if iOmniRange > (tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiOmniCoverage] or 0) then
                                tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiOmniCoverage] = math.max((tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiOmniCoverage] or 0), iOmniRange - M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oRadar:GetPosition()))
                            end
                        end
                    end
                end

                --Filter to obsolete radar and ctrl-K these (or record against the best radar if the best radar isn't constructed yet)
                if bDebugMessages == true then LOG(sFunctionRef..': Finished cycling through zones, is table of obsolete radar empty='..tostring(M28Utilities.IsTableEmpty(tPotentiallyObsoleteRadar))) end
                oRadar[reftoUnitsToKillOnCompletion] = nil
                if M28Utilities.IsTableEmpty(tPotentiallyObsoleteRadar) == false then
                    local tUniqueList = {}
                    local iUnitRef
                    local oBrain
                    for iUnit, oUnit in tPotentiallyObsoleteRadar do
                        oBrain = oUnit:GetAIBrain()
                        if oBrain.M28AI then
                            iUnitRef = oBrain:GetArmyIndex()..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Will add unit with ref incl ai index of '..iUnitRef..' to tUniqueList') end
                            if not(tUniqueList[iUnitRef]) then
                                tUniqueList[iUnitRef] = oUnit
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is tUniqueList empty='..tostring( M28Utilities.IsTableEmpty(tUniqueList))) end
                    if M28Utilities.IsTableEmpty(tUniqueList) == false then
                        local tUnitsToKill = {}
                        for iUnit, oUnit in tUniqueList do
                            local oBP = oUnit:GetBlueprint()
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with radar radius '..(oBP.Intel.RadarRadius or 0)..' vs iIntelRange='..iIntelRange) end
                            if (oBP.Intel.RadarRadius or 0) < math.max(1, iIntelRange) and (oBP.Intel.OmniRadius or 0) < math.max(1, iOmniRange) then
                                table.insert(tUnitsToKill, oUnit)
                            end
                        end
                        if M28Utilities.IsTableEmpty(tUnitsToKill) == false then
                            if oRadar:GetFractionComplete() < 1 then
                                oRadar[reftoUnitsToKillOnCompletion] = tUnitsToKill
                            else
                                local iTotalCount = table.getn(tUnitsToKill)
                                for iEntry = iTotalCount, 1, -1 do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Radar '..tUnitsToKill[iEntry].UnitId..M28UnitInfo.GetUnitLifetimeCount(tUnitsToKill[iEntry])..' has radar range of '..(tUnitsToKill[iEntry]:GetBlueprint().Intel.RadarRadius or 0)..' and is obsolete by oRadar '..oRadar.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRadar)..'; with iIntelRange='..iIntelRange) end
                                    M28Orders.IssueTrackedKillUnit(tUnitsToKill[iEntry])
                                end
                            end
                        end
                    end
                end
            end
            UpdateRecordedAllPlayerOmni(oRadar, false)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TrackWallSegment(oWall, bJustBuilt)
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oWall:GetPosition())
    if iLandZone > 0 then
        local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
        if bJustBuilt then
            local bAlreadyRecorded = false
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPlayerWallSegments]) == false then
                for iUnit, oUnit in tLZData[M28Map.subrefLZPlayerWallSegments] do
                    if oWall == oUnit then
                        bAlreadyRecorded = true
                        break
                    end
                end
            end
            if not(bAlreadyRecorded) then
                table.insert(tLZData[M28Map.subrefLZPlayerWallSegments], oWall)
            end
        else
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPlayerWallSegments]) == false then
                --Remove any old entries
                local iRevisedIndex = 1
                local iTableSize = table.getn(tLZData[M28Map.subrefLZPlayerWallSegments])

                for iOrigIndex=1, iTableSize do
                    if tLZData[M28Map.subrefLZPlayerWallSegments][iOrigIndex] then
                        if tLZData[M28Map.subrefLZPlayerWallSegments][iOrigIndex] == oWall or not(M28UnitInfo.IsUnitValid(tLZData[M28Map.subrefLZPlayerWallSegments][iOrigIndex])) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                            --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                            if (iOrigIndex ~= iRevisedIndex) then
                                tLZData[M28Map.subrefLZPlayerWallSegments][iRevisedIndex] = tLZData[M28Map.subrefLZPlayerWallSegments][iOrigIndex];
                                tLZData[M28Map.subrefLZPlayerWallSegments][iOrigIndex] = nil;
                            end
                            iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                        else
                            tLZData[M28Map.subrefLZPlayerWallSegments][iOrigIndex] = nil;
                        end
                    end
                end
            end
        end
    end
end

function RecordEnemyFirebase(iTeam, iPlateau, iLandZone)
    --Searches for all nearby land zones to iLandZone and flags that there is an enemy firebase nearby
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordEnemyFirebase'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; iTeam='..iTeam..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone) end

    if not(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau]) then M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau] = {} end
    M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone] = {[M28Team.subrefiNearbyPlateauAndLandZones] = {}, [M28Team.subrefbInRangeOfCoreLZ] = false}
    --Record any land zones in range of here
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
        for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
            local tAltLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefLZNumber]]
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iAltLZ='..tPathingData[M28Map.subrefLZNumber]..'; Dist from that LZ midpoint to the firebase LZ midpoint='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tAltLZData[M28Map.subrefMidpoint])) end
            if M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tAltLZData[M28Map.subrefMidpoint]) >= 163 then break end
            --The LZ is potentially within range of this firebase so record against that LZ
            if not(tAltLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftEnemyFirebasesInRange]) then tAltLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftEnemyFirebasesInRange] = {} end
            table.insert(tAltLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftEnemyFirebasesInRange], {iPlateau, iLandZone})

            --Also record against the base plateau and LZ all the alt LZs that we have been recorded against
            table.insert(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefiNearbyPlateauAndLandZones], {iPlateau, tPathingData[M28Map.subrefLZNumber]})

            --If it is a core LZ then record that (as will want to adjust our behaviour accordingly)
            if tAltLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] then
                M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefbInRangeOfCoreLZ] = true
            end
        end
    end
    --Also add to this LZ
    if not(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]) then tLZTeamData[M28Map.subreftEnemyFirebasesInRange] = {} end
    table.insert(tLZTeamData[M28Map.subreftEnemyFirebasesInRange], {iPlateau, iLandZone})
    --Also record against the base plateau and LZ all the alt LZs that we have been recorded against
    table.insert(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefiNearbyPlateauAndLandZones], {iPlateau, iLandZone})


    if bDebugMessages == true then LOG(sFunctionRef..': Finished recording for all LZ likely in range of the firebase, reprs of reftEnemyFirebaseByPlateauAndLZ for this plateau and LZ='..reprs(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RemoveEnemyFirebase(iTeam, iPlateau, iLandZone)
    --Goes through all land zones that recirded iLandZone as having a firebase in range of them, and removes this entry
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefiNearbyPlateauAndLandZones]) == false then
        for iEntry, tPlateauAndLZ in M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefiNearbyPlateauAndLandZones] do
            local tAltLZTeamData = M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][tPlateauAndLZ[2]][M28Map.subrefLZTeamData][iTeam]
            if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
                for iFirebase, tPlateauAndLZ in tAltLZTeamData[M28Map.subreftEnemyFirebasesInRange] do
                    if tPlateauAndLZ[1] == iPlateau and tPlateauAndLZ[2] == iLandZone then
                        table.remove(tAltLZTeamData[M28Map.subreftEnemyFirebasesInRange], iFirebase)
                        break
                    end
                end
            end
        end
    end
end

function ConsiderIfHaveEnemyFirebase(iTeam, oT2Arti)
    --Considers if hte land zone that oT2Arti is in has enough T2 arti threat to justify being a firebase
    --Idea is to only flag a firebase for something that MML are not expected to be able to break through - e.g. 3+ T2 arti; for smaller amounts the hope is that the arti can be overwhelmed
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderIfHaveEnemyFirebase'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oT2Arti:GetPosition())
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
    if (iLandZone or 0) > 0 then
        local bHaveFirebase = false
        local tAllT2Arti = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits])
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of all T2 arti for this zone empty='..tostring(M28Utilities.IsTableEmpty(tAllT2Arti))) end
        if M28Utilities.IsTableEmpty(tAllT2Arti) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Table size='.. table.getn(tAllT2Arti)) end
            if table.getn(tAllT2Arti) >= 3 then bHaveFirebase = true
            else
                local iTotalKills = 0
                for iUnit, oUnit in tAllT2Arti do
                    iTotalKills = iTotalKills + (oUnit.VetExperience or oUnit.Sync.totalMassKilled or 0)
                end
                if iTotalKills >= 2500 or (iTotalKills >= 1500 and table.getn(tAllT2Arti) == 1) then
                    bHaveFirebase = true
                end
            end
        end
        if bHaveFirebase then
            --If we dont have a firebase recorded already then record one
            if bDebugMessages == true then LOG(sFunctionRef..': Will record firebase if havent already, is it nil for this plateau and zone='..tostring(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone] == nil)) end
            if not(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone]) then
                RecordEnemyFirebase(iTeam, iPlateau, iLandZone)
            end
        elseif M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone] then
            --If we have recorded a firebase for this LZ then need to remove it
            RemoveEnemyFirebase(iTeam, iPlateau, iLandZone)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderIfAnyEnemyTeamsStillHaveFirebaseOnT2ArtiDeath(oT2Arti)
    local iBaseTeam = oT2Arti:GetAIBrain().M28Team
    for iTeam = 1, M28Team.iTotalTeamCount do
        if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 0 and not(iTeam == iBaseTeam) then
            ConsiderIfHaveEnemyFirebase(iTeam, oT2Arti)
            --update tracking of t2 arti to reflect it is dead
            M28Team.RecordEnemyT2ArtiAgainstNearbyZones(iTeam, oT2Arti, true)
        end
    end
end
