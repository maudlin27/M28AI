---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 09/12/2022 07:49
---
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local NavUtils = M28Utilities.NavUtils
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
--local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
--local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28Config = import('/mods/M28AI/lua/M28Config.lua')

--Global
tLZRefreshCountByTeam = {}
iTicksPerLandCycle = 11 --Set by ConsiderSlowdownForHighUnitCount; WaitTicks(11) is equivalent to WaitSeconds(1) i.e. will try and run logic for every unit over this amount of time; with high unit numbers will consider adjusting
--Land zone subteam data - see M28Map for main variables; threat specific values are included here

--Varaibles against specific units
reftiPlateauAndLZToMoveTo = 'M28LandPlatAndLZToMoveTo' --If tell a unit to mvoe to a LZ then will update this with the plateau and land zone wanted
refiCurrentAssignmentValue = 'M28LandAssignedValue' --when a combat unit is given an order for a land zone, the value of that land zone should be recorded
refiCurrentAssignmentPlateauAndLZ = 'M28LandAssignedPlatLZ' --returns {iPlateau, iLandZone} that the units orders have been coordinated by
refiTimeOfLastAssignment = 'M28LandLastAssignmenttime' --returns gametimeseconds that the unit was last assigned to the available units of a land zone
reftiRadarPlateauAndLandZonesCoveredByTeam = 'M28LandRadarLZs' --Returns talbes of {iPlateau, iLandZone} that the radar is providing the best radar coverage of
reftiRadarPlateauAndLandZonesCoveredByOmni = 'M28LandOmniLZs' --Returns talbes of {iPlateau, iLandZone} that the radar is providing some omni coverage of
refoSREnemyTarget = 'M28LndSRTrg' --If we have a SR unit told to target an enemy, this tracks it so we dont switch to retreat logic when we move into a new zone in pursuit
refiTimeOfSREnemyTarget = 'M28LndSRTTim' --Gametimeseconds
reftoUnitsToKillOnCompletion = 'M28RadCtrlK' --Table of units to ctrlk when this unit finishes construction
reftoAssignedMAAGuards = 'M28LAMAAGrd' --Table of MAA assigned to cover a unit (e.g. a fatboy)
refoAssignedUnitToGuard = 'M28LAMAAToG' --Unit that is being guarded/assisted (e.g. MAA assisting a fatboy)
iFatboyBaseMAACount = 5 --Number of MAA wanted as guards normally
iFatboySafeMAACount = 10 --Number of MAA wanted as guards if worried about restorer deathball/equivalent
refbFlaggedForPriorityScout = 'M28LndPrScFg' --true if we have flagged this unit wants a priority land scout
refiTimeLastBuiltLandScoutForUnit = 'M28LndTmLstBultLS' --Gametimeseconds that we last built a high priority land scout because of this unit
iIntelThresholdForPriorityScout = 30 --I.e. if have less than this radar coverage in a zone, then a skirmisher will consider flagging to ask for a priority scout
refbConsideredPotentialBPUpgrade = 'M28LndSCUbpUp'-- against SACU, true if we have included build power upgrade in ones we want

--See M28navy for sonar equivalent
refoAssignedMobileShield = 'M28LandAssignedMobileShield' --Gives the mobile shield assigned ot this unit
refoAssignedLandScout = 'M28ACULSc' --assigned land scout for the ACU or skirmisher/other unit requesting priority land scout
reftoAdditionalAssignedMobileShields = 'M28LandExtraMobS' --for units assigned multiple mobile shields (e.g. ACUs)
refoMobileShieldTarget = 'M28LandMobileShieldTarget' --the unit that the mobile shield is trying to protect
refoAssignedMobileStealth = 'M28LandAssignedMobileStealth' --If a mobile stealth is assigned to this unit, then returns the mobile stealth unit assigned
refoMobileStealthTarget = 'M28LandMobileStealthTarget' --Against mobile stleaht units, returns the unit the mobile stealth is trying to cover
refoLandScoutTarget = 'M28LndSTrg' --Against land scouts if assigned to follow a unit such as an ACU

function UpdateIfLandZoneWantsSupport(tLZTeamData, iPlateau, iLandZone, iTeam, bWantDFSupport, bWantIndirectSupport)
    tLZTeamData[M28Map.subrefbLZWantsSupport] = (bWantDFSupport or bWantIndirectSupport)
    tLZTeamData[M28Map.subrefbLZWantsDFSupport] = bWantDFSupport
    tLZTeamData[M28Map.subrefbLZWantsIndirectSupport] = bWantIndirectSupport
    if not(M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau]) then
        M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau] = {}
    end
    M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau][iLandZone] = tLZTeamData[M28Map.subrefbLZWantsSupport]
end


function GetUnitPlateauAndLandZoneOverride(oUnit)
    --Return true if have changed something
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnitPlateauAndLandZoneOverride'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iPossiblePlateau
    local iPossibleLZ
    local iBestPlateau
    local iBestLZ
    local bFoundAlternative

    if bDebugMessages == true then LOG(sFunctionRef..': Unit position='..repru(oUnit:GetPosition())..'; Reprs of unit assigned plateau and land zone by team='..reprs(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam])..'; Unit owner='..oUnit:GetAIBrain().Nickname..'; Unit owner team='..oUnit:GetAIBrain().M28Team..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; TIme='..GetGameTimeSeconds()) end

    --Dont override if we are an amphibious/hover unit that is showing as on water
    local iNavPlateau
    local iNavIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition())
    if not(iNavIsland) then
        iNavPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, oUnit:GetPosition())
        if iNavPlateau then
            if M28UnitInfo.GetUnitPathingType(oUnit) == M28Map.refPathingTypeHover then
                if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is on water and is amphibious or hover pathing, so makes sense that it doesnt have a valid land zone') end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return false
            end
        end
    end

    if M28Utilities.IsTableEmpty(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) == false then
        for iTeam, tTeamPlateauAndLZ in oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] do
            if tTeamPlateauAndLZ[2] > 0 then
                if iTeam == oUnit:GetAIBrain().M28Team and M28Utilities.IsTableEmpty(tTeamPlateauAndLZ) == false then
                    iBestPlateau = tTeamPlateauAndLZ[1]
                    iBestLZ = tTeamPlateauAndLZ[2]
                    break
                else
                    iPossiblePlateau = tTeamPlateauAndLZ[1]
                    iPossibleLZ = tTeamPlateauAndLZ[2]
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Just considered iTeam='..iTeam..'; tTeamPlateauAndLZ='..repru(tTeamPlateauAndLZ)..'; iBestPlateau='..(iBestPlateau or 'nil')..'; iBestLZ='..(iBestLZ or 'nil')..'; iPossiblePlateau='..(iPossiblePlateau or 'nil')..'; iPossibleLZ='..(iPossibleLZ or 'nil')) end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iBestPlateau='..(iBestPlateau or 'nil')..'; iBestLZ='..(iBestLZ or 'nil')..'; iPossiblePlateau='..(iPossiblePlateau or 'nil')..'; iPossibleLZ='..(iPossibleLZ or 'nil')) end
        if iBestPlateau and iBestLZ then
            M28Map.AddLocationToPlateauExceptions(oUnit:GetPosition(), iBestPlateau, iBestLZ)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        elseif iPossiblePlateau and iPossibleLZ then

            M28Map.AddLocationToPlateauExceptions(oUnit:GetPosition(), iPossiblePlateau, iPossibleLZ)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end
    else
        --If we look in a 2x2 box around the unit can we find a valid plateau?
        local iDistAdjust
        local tBasePosition = oUnit:GetPosition()

        for iBaseAdjust = 1, 3 do
            iDistAdjust = math.max(2, M28Map.iLandZoneSegmentSize) * iBaseAdjust
            local tLocationAdjust = {{-iDistAdjust,0}, {-iDistAdjust, -iDistAdjust}, {-iDistAdjust, iDistAdjust}, {0, -iDistAdjust}, {0, iDistAdjust}, {iDistAdjust, -iDistAdjust}, {iDistAdjust, 0}, {iDistAdjust,iDistAdjust}}
            if bDebugMessages == true then LOG(sFunctionRef..': Will look in a box around the unit to see if can find a valid plateau, iDistAdjust='..iDistAdjust) end
            for iEntry, tAdjustXZ in tLocationAdjust do
                iPossiblePlateau, iPossibleLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition({ tBasePosition[1] + tAdjustXZ[1], tBasePosition[2], tBasePosition[3] + tAdjustXZ[2] })
                if bDebugMessages == true then LOG(sFunctionRef..': Considering tBasePosition='..repru(tBasePosition)..'; tAdjustXZ='..repru(tAdjustXZ)..'; iPossiblePlateau='..(iPossiblePlateau or 'nil')..'; iPossibleLZ='..(iPossibleLZ or 'nil')..'; NavUtils plateau for this position='..(NavUtils.GetLabel(M28Map.refPathingTypeHover, { tBasePosition[1] + tAdjustXZ[1], tBasePosition[2], tBasePosition[3] + tAdjustXZ[2] }) or 'nil')) end
                if (iPossiblePlateau or 0) > 0 and (iPossibleLZ or 0) > 0 and M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones][iPossibleLZ] then
                    if bDebugMessages == true then LOG('Found a plateau override for oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at position '..repru(oUnit:GetPosition())..' and tAdjustXZ='..repru(tAdjustXZ)) end
                    bFoundAlternative = true
                    M28Map.AddLocationToPlateauExceptions(oUnit:GetPosition(), iPossiblePlateau, iPossibleLZ)
                    break
                end
            end
            if not(bFoundAlternative) then
                --Try in a 1x1 box around the unit to see if we can find a plateau that is land pathable, and if so, see if we can path to a land zone, and if so then update to record this as the closest land zone
                iDistAdjust = 1
                tLocationAdjust = {{0,0}, {-iDistAdjust,0}, {-iDistAdjust, -iDistAdjust}, {-iDistAdjust, iDistAdjust}, {0, -iDistAdjust}, {0, iDistAdjust}, {iDistAdjust, -iDistAdjust}, {iDistAdjust, 0}, {iDistAdjust,iDistAdjust}}
                if bDebugMessages == true then LOG(sFunctionRef..': Will look in a smaller radius box around the unit to see if can find a valid plateau, iDistAdjust='..iDistAdjust) end
                for iEntry, tAdjustXZ in tLocationAdjust do
                    local tAltLocation = { tBasePosition[1] + tAdjustXZ[1], tBasePosition[2], tBasePosition[3] + tAdjustXZ[2] }
                    iPossiblePlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tAltLocation)
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering tAltLocation='..repru(tAltLocation)..'; iPossiblePlateau='..(iPossiblePlateau or 'nil')..'; iPossibleLZ='..(iPossibleLZ or 'nil')..'; NavUtils land pathing label='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tAltLocation) or 'nil')..'; Is table of land zones for this plateau empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones]))) end
                    if (iPossiblePlateau or 0) > 0 and (NavUtils.GetLabel(M28Map.refPathingTypeLand, tAltLocation) or 0) > 0 then
                        --We have a plateau, but dont have a land zone for this position even though it is pathable by land - is there a land zone for this plateau nearby that can path here?
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering nearby LZs that might be able to path here, is table of LZs empty for plateau '..iPossiblePlateau..' = '..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones]))) end
                        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones]) == false then
                            local iClosestLZDist = 100000
                            local iClosestUnpathableLZDist = 100000
                            local iClosestUnpathableLZRef
                            local iCurLZDist
                            for iLandZone, tAltLZData in M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones] do
                                iCurLZDist = M28Utilities.GetDistanceBetweenPositions(tAltLocation, M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMidpoint])

                                if iCurLZDist < iClosestLZDist then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Can we path from alt location to midpoint of land zone '..iLandZone..' with iCurLZDist='..iCurLZDist..'='..tostring(NavUtils.CanPathTo(M28Map.refPathingTypeLand, tAltLocation, M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones][M28Map.subrefMidpoint]))) end
                                    if NavUtils.CanPathTo(M28Map.refPathingTypeLand, tAltLocation, M28Map.tAllPlateaus[iPossiblePlateau][M28Map.subrefPlateauLandZones][M28Map.subrefMidpoint]) then
                                        if iCurLZDist < iClosestLZDist then
                                            iClosestLZDist = iCurLZDist
                                            iPossibleLZ = iLandZone
                                        end
                                    elseif not(iPossibleLZ) and iCurLZDist < iClosestUnpathableLZDist then
                                        iClosestUnpathableLZDist = iCurLZDist
                                        iClosestUnpathableLZRef = iLandZone
                                    end
                                end
                            end
                            if not(iPossibleLZ) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Couldnt find any LZs that are actually pathable, closest unpaathable dist='..iClosestUnpathableLZDist..'; if this is within 50 then will use this') end
                                if iClosestUnpathableLZDist < 50 then
                                    iPossibleLZ = iClosestUnpathableLZRef
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Finsihed considering alternative entries in 1x1 box, iPossiblePlateau='..(iPossiblePlateau or 'nil')..'; iPossibleLZ='..(iPossibleLZ or 'nil')..'; If couldnt find anywhere will draw this units position in red; plateau if use hover pathing='..(NavUtils.GetLabel('Hover', oUnit:GetPosition()) or 'nil'))
                        if not(iPossibleLZ) then M28Utilities.DrawLocation(oUnit:GetPosition(), 2) end
                    end
                    if (iPossiblePlateau or 0) > 0 and (iPossibleLZ or 0) > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Identified a backup land zone override for oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at position '..repru(oUnit:GetPosition())..' and tAdjustXZ='..repru(tAdjustXZ)..'; will add to list of exceptions, iPossibleLZ='..(iPossibleLZ or 'nil')) end
                        bFoundAlternative = true
                        M28Map.AddLocationToPlateauExceptions(oUnit:GetPosition(), iPossiblePlateau, iPossibleLZ)
                        break
                    end
                end
            end
            if bFoundAlternative then break end
        end

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bFoundAlternative
end

function ConsiderAddingPlateauOverrideForUnit(oUnit)
    --If unit doesnt show as having a plateau, it isnt attached, and it is on land then have its current position assigned  to the most recent plateau
    --Note - other places will also call override, this isnt the only function
    --returns true if has added an override
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderAddingPlateauOverrideForUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bMadeChange = false
    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; Unit position='..repru(oUnit:GetPosition())..'; Map height='..M28Map.iMapWaterHeight) end
    if oUnit.IsUnitState and not(oUnit:IsUnitState('Attached')) and oUnit:GetPosition()[2] > M28Map.iMapWaterHeight then
        local iCurPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, oUnit:GetPosition())
        if bDebugMessages == true then LOG(sFunctionRef..': Unit plateau from NavUtils='..(iCurPlateau or 'nil')) end
        if (iCurPlateau or 0) <= 0 then
            bMadeChange = GetUnitPlateauAndLandZoneOverride(oUnit)
        else
            --Have a valid plateau but for some reason dont have a land zone?
            local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnit:GetPosition())
            if bDebugMessages == true then LOG(sFunctionRef..': iSegmentX-Z='..iSegmentX..'-'..iSegmentZ..'; tLandZoneBySegment[iSegmentX][iSegmentZ]='..(M28Map.tLandZoneBySegment[iSegmentX][iSegmentZ] or 'nil')) end
            if not(M28Map.tLandZoneBySegment[iSegmentX][iSegmentZ]) then
                --If units are dropped from a transport onto water then this can happen, so check that this isnt the case
                if GetTerrainHeight(oUnit:GetPosition()[1], oUnit:GetPosition()[3]) > M28Map.iMapWaterHeight then
                    bMadeChange = GetUnitPlateauAndLandZoneOverride(oUnit)
                    if bDebugMessages == true then LOG(sFunctionRef..': bMadeChange after checking unit plateau and LZ override='..tostring(bMadeChange)) end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Wont consider override for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' because it appears to be in a water zone') end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bMadeChange
end

function RemoveUnitFromListOfUnitsTravelingToLandZone(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RemoveUnitFromListOfUnitsTravelingToLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[reftiPlateauAndLZToMoveTo]='..repru(oUnit[reftiPlateauAndLZToMoveTo])) end
    if oUnit[reftiPlateauAndLZToMoveTo] then
        local sUnitTableRef
        if EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit.UnitId) then
            sUnitTableRef = M28Map.subrefTScoutsTravelingHere
        else
            M28Utilities.ErrorHandler('Need to add code for this unit category')
        end
        if sUnitTableRef then
            local iTargetPlateau = oUnit[reftiPlateauAndLZToMoveTo][1]
            local iTargetLandZone = oUnit[reftiPlateauAndLZToMoveTo][2]
            local tTravelingUnits = M28Map.tAllPlateaus[iTargetPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][sUnitTableRef]
            if M28Utilities.IsTableEmpty(tTravelingUnits) == false then
                for iTravelUnit, oTravelUnit in tTravelingUnits do
                    if oTravelUnit == oUnit then
                        table.remove(tTravelingUnits, iTravelUnit)
                        break
                    end
                end
            end
        end
        oUnit[reftiPlateauAndLZToMoveTo] = nil
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetUnitToTravelToLandZone(oUnit, iTargetPlateau, iTargetLandZone, subrefTScoutsTravelingHere)
    --Intended for non-engineer units (engineers are handled separately)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnitToTravelToLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    M28Navy.RemoveUnitFromAnyExistingLandOrWaterZoneItWasPreviouslyTravelingTo(oUnit, subrefTScoutsTravelingHere)

    oUnit[M28Navy.refiWZToMoveTo] = nil
    oUnit[reftiPlateauAndLZToMoveTo] = {iTargetPlateau, iTargetLandZone}
    local tLZData = M28Map.tAllPlateaus[iTargetPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
    --if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; iTargetPlateau='..iTargetPlateau..'; iTargetLandZone='..iTargetLandZone..'; Is tLZData empty='..tostring(M28Utilities.IsTableEmpty(tLZData))..'; Is tLZTeamData empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData))..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
    if not(tLZTeamData[subrefTScoutsTravelingHere]) then tLZTeamData[subrefTScoutsTravelingHere] = {} end
    table.insert(tLZTeamData[subrefTScoutsTravelingHere], oUnit)
    if bDebugMessages == true then LOG(sFunctionRef..': About to tell unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to go to iTargetPlateau='..iTargetPlateau..'; iTargetLandZone='..iTargetLandZone..'; midpoint of LZ='..repru(tLZData[M28Map.subrefMidpoint])) end
    M28Orders.IssueTrackedMove(oUnit, tLZData[M28Map.subrefMidpoint], 6, false, 'TLZ'..iTargetLandZone)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateUnitPositionsAndLandZone(aiBrain, tUnits, iTeam, iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
    --Similar to UpdateUnitPositionsAndWaterZone; Based on RemoveEntriesFromArrayAndAddToNewTableBasedOnCondition, but more complex as dont always want to add unit to a table
    --bUpdateTimeOfLastEnemyPositionCheck - if bUseLastKnownPosition is false and this is true, then updates subrefiTimeOfLastEnemyUnitPosUpdate
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateUnitPositionsAndLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iRevisedIndex = 1
    local iTableSize = table.getn(tUnits)
    local iActualPlateau, iActualLandZone
    local UpdateUnitLastKnownPosition = M28Team.UpdateUnitLastKnownPosition
    local bUseActualPositionIfEnemy = false
    local bUnitIsAttached
    if bUpdateTimeOfLastEnemyPositionCheck and not(bUseLastKnownPosition) then tLZTeamData[M28Map.subrefiTimeOfLastEnemyUnitPosUpdate] = GetGameTimeSeconds() end
    if not(bUseLastKnownPosition) or (bUseLastKnownPosition and (tLZTeamData[M28Map.refiRadarCoverage] or 0) >= 70) then bUseActualPositionIfEnemy = true end


    for iOrigIndex=1, iTableSize do
        if not(tUnits[iOrigIndex]) or tUnits[iOrigIndex].Dead then
            --Remove the entry
            tUnits[iOrigIndex] = nil
        else
            --Air units - first check inside the map area (to avoid too big a load on CPU trying to locate nearby valid zones and false error messages)
            if not(bAreAirUnits) or M28Conditions.IsLocationInMap(tUnits[iOrigIndex]:GetPosition()) then
                --Unit still valid, does it have the right plateau and land zone?
                bUnitIsAttached = tUnits[iOrigIndex]:IsUnitState('Attached')
                if bAreEnemyUnits or bUseLastKnownPosition then
                    UpdateUnitLastKnownPosition(aiBrain, tUnits[iOrigIndex], bUseActualPositionIfEnemy)
                end
                if bUseLastKnownPosition then
                    if bAreAirUnits or bUnitIsAttached then
                        iActualPlateau, iActualLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition( tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                    else
                        iActualPlateau, iActualLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], true, tUnits[iOrigIndex])
                    end
                else
                    --Cases where can use actual position (i.e. Allied unit or special use cases where a human will likely infer an enemy unit has moved):
                    if bUnitIsAttached or bAreAirUnits then
                        iActualPlateau, iActualLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition( tUnits[iOrigIndex]:GetPosition())
                    else
                        iActualPlateau, iActualLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tUnits[iOrigIndex]:GetPosition(), true, tUnits[iOrigIndex])
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iOrigIndex='..iOrigIndex..'; iActualPlateau='..(iActualPlateau or 'nil')..'; iActualLandZone='..(iActualLandZone or 'nil')..'; Unit='..tUnits[iOrigIndex].UnitId..M28UnitInfo.GetUnitLifetimeCount(tUnits[iOrigIndex])..'; bUnitIsAttached='..tostring(bUnitIsAttached)..'; bAreAirUnits='..tostring(bAreAirUnits or false)..'; Unit brain owner='..tUnits[iOrigIndex]:GetAIBrain().Nickname..'; Unit position='..repru(tUnits[iOrigIndex]:GetPosition())) end
                end

                if not(iActualPlateau > 0) then
                    if not(bAreAirUnits) and not(bUnitIsAttached) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Dont have a valid actual plateau so will use the recorded plateau and land zone') end
                        iActualPlateau = iRecordedPlateau
                        iActualLandZone = iRecordedLandZone
                        --Add location to table of pathing exceptions
                        if bUseLastKnownPosition then
                            M28Map.AddLocationToPlateauExceptions(tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iRecordedPlateau, iRecordedLandZone)
                        else
                            M28Map.AddLocationToPlateauExceptions(tUnits[iOrigIndex]:GetPosition(), iRecordedPlateau, iRecordedLandZone)
                        end
                    end
                end



                --Is the plateau and zone correct?
                if bDebugMessages == true then
                    LOG('Updating unit position for unit '..tUnits[iOrigIndex].UnitId..M28UnitInfo.GetUnitLifetimeCount(tUnits[iOrigIndex])..'; iRecordedPlateau='..iRecordedPlateau..'; iActualPlateau='..(iActualPlateau or 'nil')..';  iRecordedLandZone='..(iRecordedLandZone or 'nil')..'; iActualLandZone='..(iActualLandZone or 'nil')..'; Unit actual position='..repru(tUnits[iOrigIndex]:GetPosition())..'; Plateau ref using navutils of actual position='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tUnits[iOrigIndex]:GetPosition()) or 'nil')..'; Last known position='..repru(tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Hover nav utils of unit position='..(NavUtils.GetLabel(M28Map.refPathingTypeHover, tUnits[iOrigIndex]:GetPosition()) or 'nil'))
                    M28Utilities.DrawLocation(tUnits[iOrigIndex]:GetPosition())
                end
                --If the plateau has changed, and the new one has no valid location, then update the position to the actual position (due to issue with e.g. air units where if they fly over a cliff at the point intel is lost then it causes an error when trying to add them to another zone)
                if not(iRecordedPlateau == iActualPlateau) and bUseLastKnownPosition and (iActualLandZone or 0) > 0 then
                    local tRevisedPosition = tUnits[iOrigIndex]:GetPosition()
                    tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][iTeam] = {tRevisedPosition[1], tRevisedPosition[2], tRevisedPosition[3]}
                    iActualPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tRevisedPosition)
                end
            else
                --Air unit is outside the map bounds - treat the actual plateau as the recorded plateau - i.e. just keep the air unit against this zone until it comes back inside the map
                iActualPlateau = iRecordedPlateau
                iActualLandZone = iRecordedLandZone
            end
            if iRecordedPlateau == iActualPlateau and iRecordedLandZone == iActualLandZone then
                --No change needed for unit
                if (iOrigIndex ~= iRevisedIndex) then
                    tUnits[iRevisedIndex] = tUnits[iOrigIndex]
                    tUnits[iOrigIndex] = nil
                end
                iRevisedIndex = iRevisedIndex + 1
            else
                local oUnitToAdd = tUnits[iOrigIndex]
                --Want to remove the entry from this table, but then add it to the correct table
                oUnitToAdd[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam] = nil --Done here so we dont try and go through this table again when removing later on
                if iActualPlateau > 0 and iActualLandZone > 0 then
                    --AddUnitToLandZoneForBrain(aiBrain,        oUnit,      iPlateau,       iLandZone,      bIsEnemyAirUnit)
                    M28Team.AddUnitToLandZoneForBrain(aiBrain, oUnitToAdd, iActualPlateau, iActualLandZone, bAreAirUnits)
                    if bDebugMessages == true then LOG('Adding unit to land zone') end
                else
                    local iWaterZone
                    if iActualPlateau > 0 then
                        local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnitToAdd:GetPosition())
                        iWaterZone = M28Map.tWaterZoneBySegment[iSegmentX][iSegmentZ]
                    end
                    if bDebugMessages == true then LOG('Unit water zone='..(iWaterZone or 'nil')) end
                    if iWaterZone then
                        M28Team.AddUnitToWaterZoneForBrain(aiBrain, oUnitToAdd, iWaterZone, bAreAirUnits)
                    else
                        if bAreAirUnits then
                            --Get revised plateau/LZ
                            iActualPlateau, iActualLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnitToAdd:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': Air unit will record in either water or land zone, iActualPlateau='..(iActualPlateau or 'nil')..'; iActualLandZone='..(iActualLandZone or 'nil')) end
                            if iActualPlateau == 0 then
                                --Water zone
                                iWaterZone = iActualLandZone
                                M28Team.AddUnitToWaterZoneForBrain(aiBrain, oUnitToAdd, iWaterZone, bAreAirUnits)
                            else
                                M28Team.AddUnitToLandZoneForBrain(aiBrain, oUnitToAdd, iActualPlateau, iActualLandZone, bAreAirUnits)
                            end
                        else
                            --Not sure where to record unit so call main logic
                            M28Team.AssignUnitToLandZoneOrPond(aiBrain, oUnitToAdd, true)
                        end
                    end
                end

                tUnits[iOrigIndex] = nil
            end
        end
    end
    if iRevisedIndex < iTableSize then
        --table.setn(tUnits, iRevisedIndex - 1)
        for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
            --if bDebugMessages == true then LOG(sFunctionRef..': removing entry '..iRemovalEntry..' from iRecordedLandZone='..iRecordedLandZone..'; Entry being removed UnitId='..(tUnits[iRemovalEntry].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tUnits[iRemovalEntry]) or 'nil')..'; iTableSize='..iTableSize..'; iRevisedIndex='..iRevisedIndex) end
            table.remove(tUnits, iRemovalEntry)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iRevisedIndex='..iRevisedIndex..'; Is tUnits empty='..tostring(M28Utilities.IsTableEmpty(tUnits))..'; iiRecordedPlateau='..iRecordedPlateau..'; iRecordedLandZone='..iRecordedLandZone..'; GameTime='..GetGameTimeSeconds()..'; bUseLastKnownPosition='..tostring(bUseLastKnownPosition or false)..'; bUseActualPositionIfEnemy='..tostring(bUseActualPositionIfEnemy)..'; bUpdateTimeOfLastEnemyPositionCheck='..tostring(bUpdateTimeOfLastEnemyPositionCheck)) end
end

function RecordAirThreatForLandZone(tLZTeamData, iTeam, iPlateau, iLandZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAirThreatForLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                                                                --GetAirThreatLevel(tUnits,                                   bEnemyUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
    tLZTeamData[M28Map.refiEnemyAirToGroundThreat] = M28UnitInfo.GetAirThreatLevel(tLZTeamData[M28Map.reftLZEnemyAirUnits],     true,       false,              false,              true,               false,                  false)
    tLZTeamData[M28Map.refiEnemyAirAAThreat] = M28UnitInfo.GetAirThreatLevel(tLZTeamData[M28Map.reftLZEnemyAirUnits],           true,       true,               false,              false,              false,                   false)
    tLZTeamData[M28Map.refiEnemyAirOtherThreat] = M28UnitInfo.GetAirThreatLevel(tLZTeamData[M28Map.reftLZEnemyAirUnits],        true,       false,               false,              false,              true,                   true)

    if bDebugMessages == true then LOG(sFunctionRef..': Finished updating enemy air threat values for iTeam '..iTeam..' iPlateau '..iPlateau..'; iLandZOne '..iLandZone..'; AirToGround threat='.. tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Other air threat='..tLZTeamData[M28Map.refiEnemyAirOtherThreat]..'; Is table of enemy air units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]))) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordGroundThreatForLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone)
    --Records the different types of threat for the land zone

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordGroundThreatForLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Track team total threat - first remove the previous entry, then add in the new entry
    M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] - tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
    M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] - tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]
    M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] - tLZTeamData[M28Map.subrefLZThreatAllyMAA]
    M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] - tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at game time '..GetGameTimeSeconds()..' for iTeam='..iTeam..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))) end
    --local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) then
        tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] = nil
        tLZTeamData[M28Map.subrefThreatEnemyDFStructures] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] = 0
        tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] = false
        tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyShield] = 0
    else
        local tMobileUnits = EntityCategoryFilterDown(categories.MOBILE - M28UnitInfo.refCategoryScathis, tLZTeamData[M28Map.subrefTEnemyUnits])
        local tStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryScathis, tLZTeamData[M28Map.subrefTEnemyUnits])
        local tEnemiesExclShieldsAndFixedArti = EntityCategoryFilterDown(categories.MOBILE - M28UnitInfo.refCategoryMobileLandShield + categories.DIRECTFIRE, tLZTeamData[M28Map.subrefTEnemyUnits]) --(shield value gets added later based on the threat excl shields)
        local bHaveDangerousEnemies = false
        tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] = M28UnitInfo.GetCombatThreatRating(tEnemiesExclShieldsAndFixedArti, true)
        if bDebugMessages == true then
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                LOG(sFunctionRef..': Will list out every enemy unit in the zone and its threat, position, and the plateau and land zone of that position')
                for iUnit, oUnit in tLZTeamData[M28Map.subrefTEnemyUnits] do
                    local iUnitPlateau, iUnitZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                    LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has threat '..M28UnitInfo.GetCombatThreatRating({ oUnit }, true)..'; Position='..repru(oUnit:GetPosition())..'; Dist to midpoint='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])..'; iUnitPlateau='..(iUnitPlateau or 'nil')..'; iUnitZone='..(iUnitZone or 'nil'))
                end
            end
        end

        tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] = M28UnitInfo.GetCombatThreatRating(tStructures, true, false, true)
        tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] = M28UnitInfo.GetAirThreatLevel(tLZTeamData[M28Map.subrefTEnemyUnits], true, false, true, false, false, false)
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] = 0
        tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] = M28UnitInfo.GetMassCostOfUnits(tStructures)
        tLZTeamData[M28Map.subrefThreatEnemyDFStructures] = 0

        --Increase structure value for under construction experimentals
        local tExperimentals = EntityCategoryFilterDown(categories.EXPERIMENTAL * categories.MOBILE, tLZTeamData[M28Map.subrefTEnemyUnits])
        if M28Utilities.IsTableEmpty(tExperimentals) == false then
            for iUnit, oUnit in tExperimentals do
                if oUnit:GetFractionComplete() < 1 then
                    tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] = tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * oUnit:GetFractionComplete()
                    if bDebugMessages == true then LOG(sFunctionRef..': Have under construction experimental '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' in Plateau '..iPlateau..' Zone '..iZone..'; will increase threat for this, fraction complete='..oUnit:GetFractionComplete()..'; structure threat after increase='..tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]) end
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Plateau '..iPlateau..' LZ '..iLandZone..' has enemy units, Enemy combat total='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Is table of enemy structures empty='..tostring(M28Utilities.IsTableEmpty(tStructures))..'; Is tMobileUnits empty='..tostring(M28Utilities.IsTableEmpty(tMobileUnits))) end
        local iCurThreat
        if M28Utilities.IsTableEmpty(tMobileUnits) == false then
            for iUnit, oUnit in tMobileUnits do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Indirect range='..(oUnit[M28UnitInfo.refiIndirectRange] or 'nil')..'; Combat threat rating='..M28UnitInfo.GetCombatThreatRating({ oUnit }, true)) end
                if (oUnit[M28UnitInfo.refiDFRange] > 0 or oUnit[M28UnitInfo.refiIndirectRange]) and oUnit:GetFractionComplete() >= 0.9 then
                    iCurThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }, true)
                    if iCurThreat > 0 then
                        if oUnit[M28UnitInfo.refiDFRange] > 0 then
                            if not(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) then tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] = {} end
                            tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange][oUnit[M28UnitInfo.refiDFRange]] = (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange][oUnit[M28UnitInfo.refiDFRange]] or 0) + iCurThreat
                            if not(bHaveDangerousEnemies) and iCurThreat > 10 then bHaveDangerousEnemies = true end
                            tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] = tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] + iCurThreat
                        end
                        if oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                            if not(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange]) then tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] = {} end
                            tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange][oUnit[M28UnitInfo.refiIndirectRange]] = (tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange][oUnit[M28UnitInfo.refiIndirectRange]] or 0) + iCurThreat
                            tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] = tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] + iCurThreat
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Enemy mobile indirect range after updating all units='..repru(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange])..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]='..repru(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange])..'; subrefLZThreatEnemyMobileDFTotal='..(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 'nil')) end
        end
        if M28Utilities.IsTableEmpty(tStructures) == false then
            for iUnit, oUnit in tStructures do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; with DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')) end
                if oUnit[M28UnitInfo.refiDFRange] > 0 and oUnit:GetFractionComplete() >= 0.9 then
                    iCurThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Structure iCurThreat='..iCurThreat) end
                    if iCurThreat > 0 then
                        if not(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) then tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] = {} end
                        tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange][oUnit[M28UnitInfo.refiDFRange]] = (tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange][oUnit[M28UnitInfo.refiDFRange]] or 0) + iCurThreat
                        if not(bHaveDangerousEnemies) and iCurThreat > 10 then bHaveDangerousEnemies = true end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                    tLZTeamData[M28Map.subrefThreatEnemyDFStructures] = tLZTeamData[M28Map.subrefThreatEnemyDFStructures] + iThreat
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': LZ threats by range after updating for all structures='..repru(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange])) end
        end
        tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] = bHaveDangerousEnemies

        --Increase enemy threats for shield values
        local tShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryMobileLandShield, tLZTeamData[M28Map.subrefTEnemyUnits])
        tLZTeamData[M28Map.subrefLZThreatEnemyShield] = 0
        if M28Utilities.IsTableEmpty(tShields) == false then
            local iCurShield, iMaxShield
            local iThreatFactor
            for iUnit, oUnit in tShields do
                if oUnit:GetFractionComplete() >= 0.9 then
                    iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, true)
                    iThreatFactor = math.max(0.1, iCurShield /  iMaxShield)
                    tLZTeamData[M28Map.subrefLZThreatEnemyShield] = tLZTeamData[M28Map.subrefLZThreatEnemyShield] + iThreatFactor * (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
                end
            end
        end
        if tLZTeamData[M28Map.subrefLZThreatEnemyShield] >= 50 then
            local iMaxShieldRating
            if tLZTeamData[M28Map.subrefLZThreatEnemyShield] >= 4000 then
                iMaxShieldRating = math.min(3200 + (tLZTeamData[M28Map.subrefLZThreatEnemyShield] - 4000) * 0.4, 7000) --shields wont be able to cover everywhere, and more than one shield has lower value due to FAF anti-shield stacking
            else
                iMaxShieldRating = tLZTeamData[M28Map.subrefLZThreatEnemyShield] * 0.8
            end

            tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] = tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] + math.max(iMaxShieldRating * 0.1, math.min(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal], iMaxShieldRating))
            tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] = tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] + math.min(tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect], iMaxShieldRating)
            tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] = tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] + math.min(tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA], iMaxShieldRating)
            tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] = tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] + math.min(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal], iMaxShieldRating * 0.6)
            tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] = tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] + math.min(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal], iMaxShieldRating * 0.6)
        end

    end

    --Include long range threats
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of long range threats empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats]) == false then
        local tNearbyLongRangeThreats = {}
        for iUnit, oUnit in tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats] do
            if M28UnitInfo.IsUnitValid(oUnit) then
                if bDebugMessages == true then LOG(sFunctionRef..': Long range threat unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Dist to midpoint='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])..'; Unit range='..(oUnit[M28UnitInfo.refiCombatRange] or 0)) end
                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= (oUnit[M28UnitInfo.refiCombatRange] or 0) + 55 then
                    table.insert(tNearbyLongRangeThreats, oUnit)
                end
            end
        end
        if M28Utilities.IsTableEmpty(tNearbyLongRangeThreats) then tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] = 0
        else
            tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] = M28UnitInfo.GetCombatThreatRating(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats], true)
        end
    else
        tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] = 0
    end


    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) then
        tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyStructureIndirect] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyMAA] = 0
    else
        local tMobileUnits = EntityCategoryFilterDown(categories.MOBILE, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local tStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] = M28UnitInfo.GetCombatThreatRating(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits], false)
        tLZTeamData[M28Map.subrefLZThreatAllyStructureIndirect] = M28UnitInfo.GetCombatThreatRating(tStructures, false, false, true)
        tLZTeamData[M28Map.subrefLZThreatAllyMAA] = M28UnitInfo.GetAirThreatLevel(tMobileUnits, false, false, true, false, false, false)
        tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] = M28UnitInfo.GetAirThreatLevel(tStructures, false, false, true, false, false, false) + tLZTeamData[M28Map.subrefLZThreatAllyMAA]

        tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] = nil
        local iCurThreat
        if bDebugMessages == true then LOG(sFunctionRef..': Calculating threat by range for allied units, is tMobileUnits empty='..tostring(M28Utilities.IsTableEmpty(tMobileUnits))..'; is tStructures empty='..tostring(M28Utilities.IsTableEmpty(tStructures))) end
        if M28Utilities.IsTableEmpty(tMobileUnits) == false then
            for iUnit, oUnit in tMobileUnits do
                if oUnit:GetFractionComplete() >= 1 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; refiDFRange='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; IndirectRange='..(oUnit[M28UnitInfo.refiIndirectRange] or 'nil')..'; Unit combat rating='..M28UnitInfo.GetCombatThreatRating({ oUnit }, false)) end
                    if oUnit[M28UnitInfo.refiDFRange] > 0 or oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                        iCurThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }, false, nil, (oUnit[M28UnitInfo.refiDFRange] or 0) == 0)
                        if iCurThreat > 0 then
                            if oUnit[M28UnitInfo.refiDFRange] > 0 then
                                if not(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) then tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] = {} end
                                tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange][oUnit[M28UnitInfo.refiDFRange]] = (tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange][oUnit[M28UnitInfo.refiDFRange]] or 0) + iCurThreat
                            end
                            if oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                                if not(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange]) then tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] = {} end
                                tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange][oUnit[M28UnitInfo.refiIndirectRange]] = (tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange][oUnit[M28UnitInfo.refiIndirectRange]] or 0) + iCurThreat
                            end
                        end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tStructures) == false then
            for iUnit, oUnit in tStructures do
                if oUnit[M28UnitInfo.refiDFRange] > 0 and oUnit:GetFractionComplete() >= 1 then
                    iCurThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }, true)
                    if iCurThreat > 0 then
                        if not(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) then tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] = {} end
                        tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange][oUnit[M28UnitInfo.refiDFRange]] = (tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange][oUnit[M28UnitInfo.refiDFRange]] or 0) + iCurThreat
                    end
                end
            end
        end
        --Update total DF and indirect threat
        tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] = 0
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] = tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] + iThreat
            end
        end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] do
                tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] = tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] + iThreat
            end
        end

        M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] + tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
        M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] + tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]
        M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedMAAThreat] + tLZTeamData[M28Map.subrefLZThreatAllyMAA]
        M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] + tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]

    end

    --Add non-M28 teammate defences
    if M28Conditions.IsTableOfUnitsStillValid(tLZTeamData[M28Map.subreftoTeammateFixedDF]) then
        local iAlliedFixedDF = 0
        for iUnit, oUnit in tLZTeamData[M28Map.subreftoTeammateFixedDF] do
            iAlliedFixedDF = iAlliedFixedDF + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
        end
        tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] = tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] + iAlliedFixedDF
        if bDebugMessages == true then LOG(sFunctionRef..': Increasing combat threat for zone '..iLandZone..' for DF by '..iAlliedFixedDF) end
    end
    if M28Conditions.IsTableOfUnitsStillValid(tLZTeamData[M28Map.subreftoTeammateFixedAA]) then
        local iAlliedFixedAA = 0
        for iUnit, oUnit in tLZTeamData[M28Map.subreftoTeammateFixedAA] do
            iAlliedFixedAA = iAlliedFixedAA + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
        end
        tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] = tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] + iAlliedFixedAA
        if bDebugMessages == true then LOG(sFunctionRef..': Increasing AA allied threat for zone '..iLandZone..' by '..iAlliedFixedAA) end
    end
    local bNearbyEnemies = false

    if bDebugMessages == true then LOG(sFunctionRef..': Considering if enemy units in this or adjacent LZ, is table of enemy units for this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))..'; Adjacent LZs='..repru(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
        bNearbyEnemies = true
    else
        --, iPlateau, iLandZone
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones] do
                --NEED to flag as nearby enemies if any enemy units in the LZ, or else can cause problems where we try to attack a unit in an adjacent land zone, and then think there is no such unit due to this flag if it is only based on combat threat
                if bDebugMessages == true then LOG(sFunctionRef..': Enemy combat threat for adjacent LZ iAdjLZ='..iAdjLZ..'; threat='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal]) end
                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                    bNearbyEnemies = true
                    break
                end
            end
        end
    end

    --Calculate core DF and indirect wanted just for this LZ:
    if bNearbyEnemies then
        local iEnemyStructureThreat = 0
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                iEnemyStructureThreat = iEnemyStructureThreat + iThreat
            end
        end
        tLZTeamData[M28Map.subrefLZIndirectThreatWanted] = iEnemyStructureThreat * 2 + tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] * 2
        tLZTeamData[M28Map.subrefLZDFThreatWanted] = math.max(200, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 2)
    else
        tLZTeamData[M28Map.subrefLZDFThreatWanted] = 0
        tLZTeamData[M28Map.subrefLZIndirectThreatWanted] = 0
    end

    --If we have no friendly combat units and enemy has combat threat, then request less MAA, or none if we have no non-MAA/scout units
    if bDebugMessages == true then LOG(sFunctionRef..': Setting the MAA level wanted for iLandZone='..iLandZone..'; tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]='..tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tLZTeamData[M28Map.refiEnemyAirOtherThreat]='..tLZTeamData[M28Map.refiEnemyAirOtherThreat]..'; Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
    if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < 11 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= math.min(1500, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 0.9) or tLZTeamData[M28Map.subrefLZbCoreBase] then
        tLZTeamData[M28Map.subrefLZMAAThreatWanted] = math.max(tLZTeamData[M28Map.refiEnemyAirToGroundThreat] * 0.65 + tLZTeamData[M28Map.refiEnemyAirAAThreat] * 0.15 + tLZTeamData[M28Map.refiEnemyAirOtherThreat] * 0.15, tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] * 0.1)
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] <= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 and tLZTeamData[M28Map.subrefLZMAAThreatWanted] < 600 then tLZTeamData[M28Map.subrefLZMAAThreatWanted] = 600 end
    elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        local bHaveAlliedNonMAAOrScout = false
        local bHaveAlliedMAA = false
        for iUnit, oUnit in tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do
            if EntityCategoryContains(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryMAA - M28UnitInfo.refCategoryLandScout, oUnit.UnitId) then
                bHaveAlliedNonMAAOrScout = true
                break
            elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId) then
                bHaveAlliedMAA = true
            end
        end -- M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryMAA - M28UnitInfo.refCategoryLandScout, subreftoLZOrWZAlliedUnits
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveAlliedMAA='..tostring(bHaveAlliedMAA)..'; bHaveAlliedNonMAAOrScout='..tostring(bHaveAlliedNonMAAOrScout)) end
        if bHaveAlliedNonMAAOrScout or (bHaveAlliedMAA and tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0) then
            --SIgnificantly less MAA for dealing with non-air to ground threats
            if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                tLZTeamData[M28Map.subrefLZMAAThreatWanted] = math.max(tLZTeamData[M28Map.refiEnemyAirToGroundThreat], (tLZTeamData[M28Map.refiEnemyAirOtherThreat] + tLZTeamData[M28Map.refiEnemyAirAAThreat]) * 0.075, tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] * 0.2)
            else
                tLZTeamData[M28Map.subrefLZMAAThreatWanted] = math.max((tLZTeamData[M28Map.refiEnemyAirOtherThreat] + tLZTeamData[M28Map.refiEnemyAirAAThreat]) * 0.075, tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] * 0.1)
            end
        else
            tLZTeamData[M28Map.subrefLZMAAThreatWanted] = 0
        end
    else
        tLZTeamData[M28Map.subrefLZMAAThreatWanted] = 0
    end

    --Increase MAA wanted if we have ACU in the LZ
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false then
        local tiMAAByTechForACU = {100, 400, 1000}
        if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
            tLZTeamData[M28Map.subrefLZMAAThreatWanted] = tLZTeamData[M28Map.subrefLZMAAThreatWanted] + math.min(1600, tiMAAByTechForACU[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2)
        else
            tLZTeamData[M28Map.subrefLZMAAThreatWanted] = tLZTeamData[M28Map.subrefLZMAAThreatWanted] + tiMAAByTechForACU[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
        end
    end

    --Update if have enemies in adjacent WZ
    tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] = false
    tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = false
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
        local iAdjWZ, iPond
        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
            iAdjWZ = tSubtable[M28Map.subrefAWZRef]
            iPond = M28Map.tiPondByWaterZone[iAdjWZ]
            local tWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
            if (tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 20 and tWZTeamData[M28Map.subrefWZBestEnemyDFRange] > 0 then
                tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] = true
                tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = true
                break
            elseif M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = true
            end
        end
    end

    tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] = bNearbyEnemies
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]='..repru(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange])..'; bNearbyEnemies='..tostring(bNearbyEnemies)..'; Allied combat='..(tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 'nil')..'; tLZTeamData[M28Map.subrefLZMAAThreatWanted]='..tLZTeamData[M28Map.subrefLZMAAThreatWanted]..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tLZTeamData[M28Map.refiEnemyAirOtherThreat]='..tLZTeamData[M28Map.refiEnemyAirOtherThreat]) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RunFromEnemy(oUnitToRun, oEnemy, iTeam, iPlateau, iDistanceToRun)
    --NOTE: Used by waterzone logic as well for scouts to run

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RunFromEnemy'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iAngleFromEnemy = M28Utilities.GetAngleFromAToB(oEnemy:GetPosition(), oUnitToRun:GetPosition())
    --MoveInDirection(tStart, iAngle,           iDistance, bKeepInMapBounds, bTravelUnderwater, bKeepInCampaignPlayableArea)
    local tPotentialRunPosition = M28Utilities.MoveInDirection(oUnitToRun:GetPosition(), iAngleFromEnemy, iDistanceToRun, false,             false,              false)
    if not(M28Conditions.IsLocationInPlayableArea(tPotentialRunPosition)) then
        --Can we do half the distance
        tPotentialRunPosition = M28Utilities.MoveInDirection(oUnitToRun:GetPosition(), iAngleFromEnemy, iDistanceToRun, false,             false,              false)
        if not(M28Conditions.IsLocationInPlayableArea(tPotentialRunPosition)) then
            --Run to the closest rally point instead
            local iUnitPlateau, iUnitZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnitToRun:GetPosition())
            local tRallyPoint
            if (iUnitZone or 0) > 0 then
                local tLZOrWZData

                if iUnitPlateau == 0 then
                    tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iUnitZone]][M28Map.subrefPondWaterZones][iUnitZone]
                    tRallyPoint = M28Navy.GetNearestWaterRallyPoint(tLZOrWZData, iTeam, M28Map.tiPondByWaterZone[iUnitZone], iUnitZone)
                else
                    tLZOrWZData = M28Map.tAllPlateaus[iUnitPlateau][M28Map.subrefPlateauLandZones][iUnitZone]
                    tRallyPoint = GetNearestLandRallyPoint(tLZOrWZData, iTeam, iUnitPlateau, iUnitZone, 2, EntityCategoryContains(categories.HOVER + M28UnitInfo.refCategoryAmphibious, oUnitToRun.UnitId))
                end

            else
                --Run to the unit's brain's start position
                tRallyPoint = M28Map.PlayerStartPoints[oUnitToRun:GetAIBrain():GetArmyIndex()]
            end
            tPotentialRunPosition = {tRallyPoint[1], tRallyPoint[2], tRallyPoint[3]}
        end
    else
        --Are in the playable area; are we in the same plateau? if not then try and move further away by 5 and 10; if still not in same plateau then move back to start position
        local iCurPlateau, iCurLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tPotentialRunPosition)
        local iAlternativeCount = 0
        if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, oUnitToRun='..oUnitToRun.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToRun)..'; Time='..GetGameTimeSeconds()..'; Initial tPotentialRunPosition='..repru(tPotentialRunPosition)..'; iAngleFromEnemy='..iAngleFromEnemy..'; iCurPlateau='..(iCurPlateau or 'nil')..'; iPlateau='..(iPlateau or 'nil')) end
        while not(iCurPlateau == iPlateau) do
            iAlternativeCount = iAlternativeCount + 1
            if iAlternativeCount >= 3 then
                --Go to start instead
                tPotentialRunPosition = M28Map.PlayerStartPoints[oUnitToRun:GetAIBrain():GetArmyIndex()]
                break
            else
                iDistanceToRun = iDistanceToRun + 4
                tPotentialRunPosition = M28Utilities.MoveInDirection(oUnitToRun:GetPosition(), iAngleFromEnemy, iDistanceToRun, true, false, true)
                iCurPlateau, iCurLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tPotentialRunPosition)
            end
        end
    end



    M28Orders.IssueTrackedMove(oUnitToRun, tPotentialRunPosition, math.min(8, iDistanceToRun * 0.25), false, 'RunE'..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy))
    if bDebugMessages == true then LOG(sFunctionRef..': Just tried to give move order for oUnitToRun='..oUnitToRun.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToRun)..' from cur position '..repru(oUnitToRun:GetPosition())..' to position '..repru(tPotentialRunPosition)..' due to enemy '..(oEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEnemy) or 'nil')..' which is at last known position '..repru(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; iDistanceToRun='..(iDistanceToRun or 'nil')..'; Angle to run location='..M28Utilities.GetAngleFromAToB(oUnitToRun:GetPosition(), tPotentialRunPosition)..'; Angle from unit ot enemy='..M28Utilities.GetAngleFromAToB(oUnitToRun:GetPosition(), oEnemy:GetPosition())..'; Actual last order position='..repru(oUnitToRun[M28Orders.reftiLastOrders][oUnitToRun[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition])..'; Unit order count='..(oUnitToRun[M28Orders.refiOrderCount] or 'nil')..'; GameTime='..GetGameTimeSeconds()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageLandZoneScouts(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tScouts, bLandZoneContainsNonScouts)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageLandZoneScouts'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    tLZTeamData[M28Map.refbWantLandScout] = false
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want a land scout for iPlateau '..iPlateau..'; iLandZone='..iLandZone..'; bLandZoneContainsNonScouts='..tostring(bLandZoneContainsNonScouts or false)..'; Enemy combat threat='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Is table of land scouts traveling here empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTScoutsTravelingHere]))..'; Is table of scouts currently in this LZ empty='..tostring(M28Utilities.IsTableEmpty(tScouts))..'; Time='..GetGameTimeSeconds()) end

    --Refresh list of scouts traveling here
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTScoutsTravelingHere]) == false then
        local iTableSize = table.getn(tLZTeamData[M28Map.subrefTScoutsTravelingHere])
        for iCurEntry = iTableSize, 1, -1 do
            if not(M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.subrefTScoutsTravelingHere][iCurEntry])) then
                table.remove(tLZTeamData[M28Map.subrefTScoutsTravelingHere], iCurEntry)
            end
        end
    end

    if (bLandZoneContainsNonScouts or tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 2 or (GetGameTimeSeconds() <= 420 and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 3000 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] < 3)) and (tLZData[M28Map.subrefLZMexCount] > 0 or tLZData[M28Map.subrefLZTotalSegmentCount] > 30) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTScoutsTravelingHere]) then
        --Want a land scout for htis land zone, unless we already have one traveling here; if we have available land scouts then will change this flag back to false
        if not(tLZData[M28Map.subrefbPacifistArea]) and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmniVision]) then
            if not(M28Map.bIsCampaignMap) or M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then
                if not(tLZTeamData[M28Map.subrefLZbCoreBase]) or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    tLZTeamData[M28Map.refbWantLandScout] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; We want to get a scout for this LZ '..(iLandZone or 'nil')..' on plateau '..(iPlateau or 'nil')..' with island '..(tLZData[M28Map.subrefLZIslandRef] or 'nil')) end
                end
            end
        end
    end

    --Do we have any land scouts that are available? if so then assign to an adjacent land zone if the adjacent zone wants scouts (exception if we have LC1 scout which we want to assign to enemy base zone if its available)
    if M28Utilities.IsTableEmpty(tScouts) == false then
        tLZTeamData[M28Map.refiTimeLastHadVisual] = GetGameTimeSeconds()
        local tAvailableScouts = {}
        local bCheckForEnemies = false
        local tEnemyUnitTablesToConsider = {}
        --Check for neemies if there are any in this or adjacent land zone
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
            --if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 then
            table.insert(tEnemyUnitTablesToConsider, tLZTeamData[M28Map.subrefTEnemyUnits])
        end
        local bFriendlyCombatInAdjZone = false
        if tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= 50 then bFriendlyCombatInAdjZone = true end

        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Checking if enemies in iAdjLZ='..iAdjLZ..'; enemy combat total='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal]) end
                if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] > 0 then
                    table.insert(tEnemyUnitTablesToConsider, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits])
                end
                if not(bFriendlyCombatInAdjZone) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTThreatAllyCombatTotal] > 50 then
                    bFriendlyCombatInAdjZone = true
                end
            end
        end
        if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
            for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                local tAdjLZTeamData = M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam]
                if (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) > 0 then
                    table.insert(tEnemyUnitTablesToConsider, tAdjLZTeamData[M28Map.subrefTEnemyUnits])
                end
            end
        end
        if M28Utilities.IsTableEmpty(tEnemyUnitTablesToConsider) == false then bCheckForEnemies = true end

        local oEnemyToRunFrom
        local oPrevEnemyToRunFrom
        local iRunThreshold --If get this close to being in range of an enemy should try to run

        if tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= math.max(5000, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 4) then iRunThreshold = 15
        elseif tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= 200 then iRunThreshold = 17
        elseif bFriendlyCombatInAdjZone then iRunThreshold = 20
        else iRunThreshold = 27
        end

        local iAttackThreshold = 35
        if bDebugMessages == true then LOG(sFunctionRef..': About to consider orders for scouts in this LZ, size of tScouts='..table.getn(tScouts)..'; bCheckForEnemies='..tostring(bCheckForEnemies)..'; Enemy combat total='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]) end
        local oEnemyToConsiderAttacking
        local iEnemyToConsiderAttackingDist
        local bConsiderAttacking = false
        local iCurDist
        local bStandAlmostStill = false
        local iActualCurDist
        local iClosestDangerousEnemy
        local oClosestDangerousEnemy
        local toEscortScouts = {}
        for iScout, oScout in tScouts do
            if oScout:GetFractionComplete() == 1 then

                if bDebugMessages == true then LOG(sFunctionRef..': Considering scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..'; bCheckForEnemies='..tostring(bCheckForEnemies)) end
                if bCheckForEnemies then
                    iClosestDangerousEnemy = 10000
                    oEnemyToRunFrom = nil
                    if (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 40 or (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0) < 30) and EntityCategoryContains(M28UnitInfo.refCategoryCombatScout, oScout.UnitId) and (oScout[M28UnitInfo.refiDFRange] or 0) >= 12 then
                        bConsiderAttacking = true
                        iEnemyToConsiderAttackingDist = 100000
                    end
                    if bDebugMessages == true and oPrevEnemyToRunFrom then LOG(sFunctionRef..': oPrevEnemyToRunFrom='..oPrevEnemyToRunFrom.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPrevEnemyToRunFrom)..'; Dist to prev enemy='..M28Utilities.GetDistanceBetweenPositions(oPrevEnemyToRunFrom:GetPosition(), oScout:GetPosition())..'; Enemy range='..(oPrevEnemyToRunFrom[M28UnitInfo.refiDFRange] or 0)..'; Run threshold='..iRunThreshold..'; iLandZone='..iLandZone) end
                    if not(bConsiderAttacking) and oPrevEnemyToRunFrom and M28Utilities.GetDistanceBetweenPositions(oPrevEnemyToRunFrom:GetPosition(), oScout:GetPosition()) - (oPrevEnemyToRunFrom[M28UnitInfo.refiDFRange] or 0) <= iRunThreshold then
                        --Run from same enemy
                        oEnemyToRunFrom = oPrevEnemyToRunFrom
                    else
                        bStandAlmostStill = false
                        for iUnitTable, tUnitTable in tEnemyUnitTablesToConsider do
                            for iUnit, oUnit in tUnitTable do
                                if M28UnitInfo.IsUnitValid(oUnit) then

                                    if bDebugMessages == true then LOG(sFunctionRef..': Looking for enemy to run from for scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..', considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Unit position='..repru(oUnit:GetPosition())..'; Unit last known position='..repru(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Dist between last known position and scout='..M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition())..'; Actual dist using actual position='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oScout:GetPosition())..'; Is unit visible='..tostring(M28UnitInfo.CanSeeUnit(oScout:GetAIBrain(), oUnit))..'; Unit range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; iRunThreshold='..iRunThreshold..'; Is distance within run threshold='..tostring(M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0) <= iRunThreshold)..'; bConsiderAttacking='..tostring(bConsiderAttacking)..'; Unit df range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Unit build range='..(oUnit:GetBlueprint().Economy.MaxBuildDistance or 'nil')) end
                                    if bConsiderAttacking or (((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId)) and not(oUnit == oPrevEnemyToRunFrom)) then
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition())
                                        if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                                            iCurDist = iCurDist - (oUnit:GetBlueprint().Economy.MaxBuildDistance or 0)
                                        elseif (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then
                                            if EntityCategoryContains(M28UnitInfo.refCategoryLandScout - M28UnitInfo.refCategoryCombatScout, oUnit.UnitId) and iCurDist < oUnit[M28UnitInfo.refiDFRange] + 2 and (not(bFriendlyCombatInAdjZone) or M28UnitInfo.GetUnitHealthPercent(oScout) < 0.5) then
                                                --This means we should be far less likely to run from UEF and Aeon land scouts if we arent yet in range of them (and sometimes even if we are slightly in range)
                                                iCurDist = iCurDist - (oUnit[M28UnitInfo.refiDFRange] or 0)
                                            else
                                                iCurDist = iCurDist - (oUnit[M28UnitInfo.refiDFRange] or 0)
                                            end
                                        end
                                        if iCurDist < iClosestDangerousEnemy and (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout * categories.TECH3 - categories.SERAPHIM, oUnit.UnitId))  then
                                            oClosestDangerousEnemy = oUnit
                                            iClosestDangerousEnemy = iCurDist
                                        end
                                        if iCurDist <= iRunThreshold then
                                            oEnemyToRunFrom = oUnit
                                            if bConsiderAttacking and iCurDist >= 4 and EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) and iClosestDangerousEnemy > iRunThreshold then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Decent dist until we are in range of engineer so will look to stand almost still instead of retreating') end
                                                bStandAlmostStill = true
                                            else
                                                bStandAlmostStill = false
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Want to run from unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so will stop searching unless considering attacking, iClosestDangerousEnemy='..iClosestDangerousEnemy..'; iRunThreshold='..iRunThreshold..'; bConsiderAttacking='..tostring(bConsiderAttacking)) end
                                            if not(bConsiderAttacking) or iClosestDangerousEnemy < iRunThreshold then break end
                                        else
                                            --Adjust run threshold if enemy unit is moving, and facing towards us
                                            if iCurDist - 2 <= iRunThreshold and oUnit:IsUnitState('Moving') and M28Utilities.GetAngleDifference(M28UnitInfo.GetUnitFacingAngle(oUnit), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oScout:GetPosition())) <= 15 then
                                                oEnemyToRunFrom = oUnit
                                                bStandAlmostStill = false
                                                if bDebugMessages == true then LOG(sFunctionRef..': Want to run as unit is facing us and still relatively close, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so will stop searching') end
                                                if not(bConsiderAttacking) or iClosestDangerousEnemy < iRunThreshold then break end
                                            elseif bConsiderAttacking and ((oUnit[M28UnitInfo.refiDFRange] or 0) == 0 or EntityCategoryContains(M28UnitInfo.refCategoryLandScout * categories.TECH3 - categories.SERAPHIM, oUnit.UnitId)) and iCurDist < math.max(iAttackThreshold, iEnemyToConsiderAttackingDist) then
                                                oEnemyToConsiderAttacking = oUnit
                                                iEnemyToConsiderAttackingDist = iCurDist
                                                if bDebugMessages == true then LOG(sFunctionRef..': Want to consider attacking the unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' but will first check no units to run from') end
                                            else
                                                if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is too far away for us to run from it, will keep looking subject to considering if its close enough we should stand still instead, iCurDist='..iCurDist) end
                                                if not(oEnemyToRunFrom) then
                                                    --Try to approximate case where enemy has a unit that is approaching our scout, and we are moving away, only to move back again - a human player would know to only move the scout a small bit to allow intel to catchup on the enemy unit; so will approximate that by having hte scout 'retreat' but not by much, if the enemy near
                                                    iActualCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oScout:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0)
                                                    if iActualCurDist - 5 <= iRunThreshold and (iActualCurDist - 3.5 <= iRunThreshold or oUnit:IsUnitState('Moving')) then
                                                        oEnemyToRunFrom = oUnit
                                                        bStandAlmostStill = true
                                                    end
                                                end
                                            end
                                        end

                                        --Check if about to get in range of engineer that can reclaim us - have done +8 as lower values resulted in some cases in the engineer being able to reclaim the scout
                                    elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) <= 8 + (oUnit:GetBlueprint().Economy.MaxBuildDistance or 3) then
                                        oEnemyToRunFrom = oUnit
                                        break
                                    end
                                end
                            end
                        end
                    end
                    if bConsiderAttacking then
                        if iClosestDangerousEnemy - 8 <= iRunThreshold then oEnemyToConsiderAttacking = nil
                        elseif oEnemyToRunFrom and M28UnitInfo.GetCombatThreatRating({ oEnemyToRunFrom }, true) <= 11 and not(EntityCategoryContains(M28UnitInfo.refCategoryLandCombat, oEnemyToRunFrom.UnitId)) then
                            oEnemyToConsiderAttacking = oEnemyToRunFrom
                            if bDebugMessages == true then LOG(sFunctionRef..': Will consider attacking unit as closest dangerous enemy is still a bit from being in our range, iClosestDangerousEnemy='..iClosestDangerousEnemy) end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Do we have a valid enemy unit to run from='..tostring(M28UnitInfo.IsUnitValid(oEnemyToRunFrom))..'; ENemy ID if any='..(oEnemyToRunFrom.UnitId or 'nil')..'; oEnemyToConsiderAttacking='..(oEnemyToConsiderAttacking.UnitId or 'nil')..'; iClosestDangerousEnemy='..iClosestDangerousEnemy) end
                end
                if oEnemyToConsiderAttacking and M28UnitInfo.IsUnitValid(oEnemyToConsiderAttacking) then
                    tLZTeamData[M28Map.refbWantLandScout] = false
                    if bDebugMessages == true then LOG(sFunctionRef..': Have an enemy to attack with combat scout, oEnemyToConsiderAttacking='..oEnemyToConsiderAttacking.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToConsiderAttacking)) end
                    if M28Utilities.GetDistanceBetweenPositions(oEnemyToConsiderAttacking:GetPosition(), oScout:GetPosition()) >= 9 then
                        M28Orders.IssueTrackedAttackMove(oScout, oEnemyToConsiderAttacking:GetPosition(), 4, false, 'SelSA', false)
                    else
                        --Are too close so run away temporarily
                        RunFromEnemy(oScout, oEnemyToConsiderAttacking, iTeam, iPlateau, 16)
                    end
                    oPrevEnemyToRunFrom = nil --DOnt want to bypass checking enemy units incase there is a threatening one nearby
                elseif oEnemyToRunFrom then
                    tLZTeamData[M28Map.refbWantLandScout] = false
                    if bDebugMessages == true then LOG(sFunctionRef..': Want scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..' to run from oEnemyToRunFrom '..oEnemyToRunFrom.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToRunFrom)..' unless iti s a combat scout vs an engineer/mex in a low threat LZ in which case want it to attack the unit; LZ combat total='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Scout DF range='..(oScout[M28UnitInfo.refiDFRange] or 'nil')..'; Do we have a combat scout='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryCombatScout, oScout.UnitId))..'; Distance to nearest enemy='..M28Utilities.GetDistanceBetweenPositions(oEnemyToRunFrom:GetPosition(), oScout:GetPosition())..'; bStandAlmostStill='..tostring(bStandAlmostStill)) end
                    oPrevEnemyToRunFrom = oEnemyToRunFrom
                    if bStandAlmostStill then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and run from enemy but only a short way as want to almost stand still') end
                        RunFromEnemy(oScout, oEnemyToRunFrom, iTeam, iPlateau, 3)
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and run from the nearest enemy') end
                        RunFromEnemy(oScout, oEnemyToRunFrom, iTeam, iPlateau, 16)
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': No nearby enemy to run from, Considering if scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..' is available; reftiPlateauAndLZToMoveTo='..repru(oScout[reftiPlateauAndLZToMoveTo])) end
                    if oScout[reftiPlateauAndLZToMoveTo] then
                        --Make scout available if its target LZ is this LZ
                        if oScout[reftiPlateauAndLZToMoveTo][2] == iLandZone and oScout[reftiPlateauAndLZToMoveTo][1] == iPlateau then
                            --Clear this unit from list of traveling units, but dont make it available as want a slight delay, so want it to be available on the next cycle
                            if bDebugMessages == true then LOG(sFunctionRef..': Scout is traveling to this land zone and is here so will clear the trackers so next cycle it is shown as available') end
                            RemoveUnitFromListOfUnitsTravelingToLandZone(oScout)
                            tLZTeamData[M28Map.refbWantLandScout] = false
                        else
                            --Scout should be traveling to another land zone - if it has no orders then refresh them
                            if bDebugMessages == true then LOG(sFunctionRef..': Scout should travel to another land zone so order it to travel there') end
                            M28Orders.IssueTrackedMove(oScout, M28Map.tAllPlateaus[oScout[reftiPlateauAndLZToMoveTo][1]][M28Map.subrefPlateauLandZones][oScout[reftiPlateauAndLZToMoveTo][2]][M28Map.subrefMidpoint], 6, false, 'TLZ'..oScout[reftiPlateauAndLZToMoveTo][2])
                        end
                    elseif oScout[M28Navy.refiWZToMoveTo] then
                        --Scout should be traveling to another water zone - if it has no orders then refresh them
                        M28Orders.IssueTrackedMove(oScout, M28Map.tPondDetails[M28Map.tiPondByWaterZone[oScout[M28Navy.refiWZToMoveTo]]][M28Map.subrefPondWaterZones][oScout[M28Navy.refiWZToMoveTo]][M28Map.subrefMidpoint], 6, false, 'TWZ'..oScout[M28Navy.refiWZToMoveTo])
                        if bDebugMessages == true then LOG(sFunctionRef..': Scout should travel to a water zone '..oScout[M28Navy.refiWZToMoveTo]..' so will resend the order to ensure it is still moving there') end
                    else
                        --Scout has no nearby enemies to run from, and isnt traveling to a plateau, so it should be available for use
                        if bDebugMessages == true then LOG(sFunctionRef..': Dont want to run or attack with scout and it isnt already assigned to another LZ so will aadd to table of available scouts, oScout='..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)) end
                        if M28UnitInfo.GetUnitLifetimeCount(oScout) == 1 then
                            --Assign to enemy base if it is in the same island
                            local iEnemyBasePlateauOrZero, iEnemyBaseLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tLZTeamData[M28Map.reftClosestEnemyBase])
                            local bGoingToEnemyBase = false
                            if iEnemyBasePlateauOrZero == iPlateau and iEnemyBaseLZOrWZ then
                                local tEnemyBaseLZData = M28Map.tAllPlateaus[iEnemyBasePlateauOrZero][M28Map.subrefPlateauLandZones][iEnemyBaseLZOrWZ]
                                local tEnemyBaseLZTeamData = tEnemyBaseLZData[M28Map.subrefLZTeamData][iTeam]
                                if M28Utilities.IsTableEmpty(tEnemyBaseLZTeamData[M28Map.subrefTScoutsTravelingHere]) and NavUtils.GetLabel(M28Map.refPathingTypeLand,tLZTeamData[M28Map.reftClosestEnemyBase]) == tLZData[M28Map.subrefLZIslandRef] and (tEnemyBaseLZTeamData[M28Map.refbWantLandScout] or M28Utilities.IsTableEmpty(tEnemyBaseLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Dealing with first ever land scout so will have it prioritise enemy base for intel, iEnemyBasePlateauOrZero='..iEnemyBasePlateauOrZero..'; iEnemyBaseLZOrWZ='..iEnemyBaseLZOrWZ) end
                                    bGoingToEnemyBase = true
                                end
                            end
                            if bGoingToEnemyBase then
                                GetUnitToTravelToLandZone(oScout, iEnemyBasePlateauOrZero, iEnemyBaseLZOrWZ, M28Map.subrefTScoutsTravelingHere)
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Adding scout to table of available scouts; did enemy base zone want land csout='..tostring(M28Map.tAllPlateaus[iEnemyBasePlateauOrZero][M28Map.subrefPlateauLandZones][iEnemyBaseLZOrWZ][M28Map.subrefLZTeamData][iTeam][M28Map.refbWantLandScout] or false)..'; Was table of land scouts traveling there empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iEnemyBasePlateauOrZero][M28Map.subrefPlateauLandZones][iEnemyBaseLZOrWZ][M28Map.subrefLZTeamData][M28Map.subrefTScoutsTravelingHere]))) end
                                table.insert(tAvailableScouts, oScout)
                            end
                        else
                            if oScout[refoLandScoutTarget] and M28UnitInfo.IsUnitValid(oScout[refoLandScoutTarget]) then
                                table.insert(toEscortScouts, oScout)
                                if bDebugMessages == true then LOG(sFunctionRef..': Scout is escorting unit '..oScout[refoLandScoutTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout[refoLandScoutTarget])) end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Will add scout to table of available scouts') end
                                table.insert(tAvailableScouts, oScout)
                            end
                        end
                    end
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Is available scout table empty='..tostring(M28Utilities.IsTableEmpty(tAvailableScouts))) end

        if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
            function AssignLandScoutToUnit(oUnitToReceiveScout)
                oUnitToReceiveScout[refoAssignedLandScout] = tAvailableScouts[1]
                tAvailableScouts[1][refoLandScoutTarget] = oUnitToReceiveScout
                table.insert(toEscortScouts, tAvailableScouts[1])
                table.remove(tAvailableScouts, 1)
                if oUnitToReceiveScout[refbFlaggedForPriorityScout] then
                    oUnitToReceiveScout[refbFlaggedForPriorityScout] = false
                    oUnitToReceiveScout[refiTimeLastBuiltLandScoutForUnit] = nil
                    local iCurLandSubteam = oUnitToReceiveScout:GetAIBrain().M28LandSubteam
                    if M28Utilities.IsTableEmpty(M28Team.tLandSubteamData[iCurLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout]) == false then
                        for iEntry, oEntry in M28Team.tLandSubteamData[iCurLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout] do
                            if oEntry == oUnitToReceiveScout then
                                table.remove(M28Team.tLandSubteamData[iCurLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout], iEntry)
                                break
                            end
                        end
                    end
                    --Remove from LZTeamData
                    local tUnitLZData, tUnitLZTeamData = M28Map.GetLandOrWaterZoneData(oUnitToReceiveScout:GetPosition(), true, iTeam)
                    if M28Utilities.IsTableEmpty(tUnitLZTeamData[M28Map.reftoUnitsWantingPriorityScouts]) == false then
                        for iEntry, oEntry in tUnitLZTeamData[M28Map.reftoUnitsWantingPriorityScouts] do
                            if oEntry == oUnitToReceiveScout then
                                table.remove(tUnitLZTeamData[M28Map.reftoUnitsWantingPriorityScouts], iEntry)
                                break
                            end
                        end
                    end
                end
            end
            --If not a core zone and have ACU in this zone that lacks a decided scout, no nearby omni, and has an upgrade with decent df range (so guncom) then assign scout to it
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false and not(tLZTeamData[M28Map.subrefLZbCoreBase]) and tLZTeamData[M28Map.refiRadarCoverage] < math.min(300, math.max(200, M28UnitInfo.iT3RadarSize - 90)) then
                for iACU, oACU in tLZTeamData[M28Map.subrefAlliedACU] do
                    if not(M28UnitInfo.IsUnitValid(oACU[refoAssignedLandScout])) and (oACU[M28ACU.refiUpgradeCount] or 0) > 0 and oACU[M28UnitInfo.refiDFRange] >= 28 then
                        AssignLandScoutToUnit(oACU)
                        if M28Utilities.IsTableEmpty(tAvailableScouts) then break end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts]) == false and M28Utilities.IsTableEmpty(tAvailableScouts) == false then
                --Do same thing with units wanting priority land scout
                for iRecorded, oRecorded in tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts] do
                    AssignLandScoutToUnit(oRecorded)
                    if M28Utilities.IsTableEmpty(tAvailableScouts) then break end
                end
            end
            if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
                --First assign any available scouts to adjacent land zones wanting scouts
                --Early game - prioritise zones with combat threat if we only have one scout available
                local bPrioritiseLandZonesWithFriendlyCombat = false
                local tFirstPlateauOrLZIfWantCombat
                if table.getn(tAvailableScouts) == 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 and (GetGameTimeSeconds() <= 360 or tLZTeamData[M28Map.refiRadarCoverage] <= 100) then bPrioritiseLandZonesWithFriendlyCombat = true end

                if bDebugMessages == true then LOG(sFunctionRef..': Will first allocate scouts to any adjacent land zones that want a scout. Is table of adj zones empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]))) end
                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
                    local bDontCheckInPlayableArea = not(M28Map.bIsCampaignMap)
                    for _, iAdjLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Consideri niAdjLZ='..iAdjLZ..'; Does this LZ want land scout='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.refbWantLandScout] or false)..'; Is table of traveling scouts here empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTScoutsTravelingHere]))) end
                        local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                        if tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refbWantLandScout] and (bDontCheckInPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint])) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will send land scout '..tAvailableScouts[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tAvailableScouts[1])..' to go to adjacent land zone '..iAdjLZ..' in plateau '..iPlateau) end
                            if not(tAdjLZData[M28Map.subrefbPacifistArea]) then
                                if not(bPrioritiseLandZonesWithFriendlyCombat) or M28Utilities.IsTableEmpty(tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTAlliedCombatUnits]) == false then

                                    GetUnitToTravelToLandZone(tAvailableScouts[1], iPlateau, iAdjLZ, M28Map.subrefTScoutsTravelingHere)
                                    tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refbWantLandScout] = false
                                    table.remove(tAvailableScouts, 1)
                                    if M28Utilities.IsTableEmpty(tAvailableScouts) then break end
                                else
                                    --We want to prioritise an adjacent zone wanting scouts
                                    if not(tFirstPlateauOrLZIfWantCombat) then
                                        tFirstPlateauOrLZIfWantCombat = {iPlateau, iAdjLZ}
                                    end
                                end
                            end
                        end
                    end
                    if bPrioritiseLandZonesWithFriendlyCombat and M28Utilities.IsTableEmpty(tAvailableScouts) == false and tFirstPlateauOrLZIfWantCombat then
                        GetUnitToTravelToLandZone(tAvailableScouts[1], tFirstPlateauOrLZIfWantCombat[1], tFirstPlateauOrLZIfWantCombat[2], M28Map.subrefTScoutsTravelingHere)
                        M28Map.tAllPlateaus[tFirstPlateauOrLZIfWantCombat[1]][M28Map.subrefPlateauLandZones][tFirstPlateauOrLZIfWantCombat[2]][M28Map.subrefLZTeamData][iTeam][M28Map.refbWantLandScout] = false
                        table.remove(tAvailableScouts, 1)
                    end
                end
                --Now assign any remaining available scouts to adjacent water zones wanting scouts (if any)
                if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                        local tAmphibiousOrHoverScouts = EntityCategoryFilterDown(M28UnitInfo.refCategoryAmphibious + categories.HOVER, tAvailableScouts)
                        if M28Utilities.IsTableEmpty(tAmphibiousOrHoverScouts) == false then
                            local iPond, iAdjWZ
                            for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                                iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                                iPond = M28Map.tiPondByWaterZone[iAdjWZ]
                                local tAdjWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
                                if tAdjWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refbWantLandScout] then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering tAmphibiousOrHoverScouts, size of table='..table.getn(tAmphibiousOrHoverScouts)) end
                                    M28Navy.GetUnitToTravelToWaterZone(tAmphibiousOrHoverScouts[1], iPond, iAdjWZ, M28Map.subrefTScoutsTravelingHere)
                                    M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.refbWantLandScout] = false
                                    local iAvailableScoutRef
                                    for iUnit, oUnit in tAvailableScouts do
                                        if oUnit == tAmphibiousOrHoverScouts[1] then
                                            iAvailableScoutRef = iUnit
                                            break
                                        end
                                    end
                                    table.remove(tAmphibiousOrHoverScouts, 1)
                                    if iAvailableScoutRef then
                                        table.remove(tAvailableScouts, iAvailableScoutRef)
                                    end
                                    if M28Utilities.IsTableEmpty(tAmphibiousOrHoverScouts) then
                                        break
                                    end
                                end
                            end
                        end
                    end

                    if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
                        tLZTeamData[M28Map.refbWantLandScout] = false
                        if table.getn(tAvailableScouts) > 1 then
                            --Look for further away zones in this island wanting land scouts
                            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                                for iEntry, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                                    local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                                    if tTeamTargetLZData[M28Map.refbWantLandScout] then
                                        --Consider assigning to priority units wanting land scouts as a backup to normal logic
                                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts]) == false then
                                            for iCurRecorded = table.getn(tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts]), 1, -1 do
                                                local oCurRecorded = tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts][iCurRecorded]
                                                if M28UnitInfo.IsUnitValid(oCurRecorded) then
                                                    if M28UnitInfo.IsUnitValid(oCurRecorded[refoAssignedLandScout]) then --redundancy
                                                        oCurRecorded[refbFlaggedForPriorityScout] = false
                                                        oCurRecorded[refiTimeLastBuiltLandScoutForUnit] = nil
                                                        table.remove(tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts], iCurRecorded)
                                                    else
                                                        AssignLandScoutToUnit(oCurRecorded)
                                                    end
                                                end
                                            end
                                        end

                                        if bDebugMessages == true then LOG(sFunctionRef..': Getting scout '..tAvailableScouts[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tAvailableScouts[1])..' to go from iLandZone '..iLandZone..'; to furhter away LZ='..tPathingDetails[M28Map.subrefLZNumber]) end
                                        GetUnitToTravelToLandZone(tAvailableScouts[1], iPlateau, tPathingDetails[M28Map.subrefLZNumber], M28Map.subrefTScoutsTravelingHere)
                                        tTeamTargetLZData[M28Map.refbWantLandScout] = false
                                        table.remove(tAvailableScouts, 1)
                                        if M28Utilities.IsTableEmpty(tAvailableScouts) then break end
                                    end
                                    --subrefLZNumber = 1 --Land zone reference number
                                    --subrefLZPath = 2 --against subrefLZPathingToOtherLandZones subtable, returns a table [x]=1,2,3...; which returns the land zone reference for each land zone that will go through on a path from these
                                    --subrefLZTravelDist = 3 --against subrefLZPathingToOtherLandZones subtable
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
                            --If we are here then we still have available land scouts; if we have ap atrol path then patrol; if we have a mex then go here, if we have an adjcent zone go here, otherwise move randomly if we have no orders
                            for iScout, oScout in tAvailableScouts do
                                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subreftPatrolPath]) == false then
                                    --Patrol the land zone
                                    M28Orders.PatrolPath(oScout, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subreftPatrolPath], false, 'SP')
                                else
                                    --Do nothing if scout is moving as maybe it landed on a segment just out of the zone it shoudl have been in
                                    if not(oScout:IsUnitState('Moving')) then
                                        M28Orders.UpdateRecordedOrders(oScout)
                                        if (oScout[M28Orders.refiOrderCount] or 0) == 0 then
                                            --Want ot get somewhere to move to as a backup
                                            if tLZData[M28Map.subrefLZMexCount] > 0 then
                                                M28Orders.IssueTrackedMove(oScout, tLZData[M28Map.subrefMidpoint], 5, false, 'BackupMid')
                                            else
                                                --Do we have an adjacent LZ? If so move here
                                                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
                                                    GetUnitToTravelToLandZone(tAvailableScouts[1], iPlateau, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones][1], M28Map.subrefTScoutsTravelingHere)
                                                else
                                                    --No adjacent LZs, and no mexes in this LZ, so just move randomly
                                                    M28Orders.IssueTrackedMove(oScout, M28Utilities.MoveInDirection(oScout:GetPosition(), math.random(1, 360), math.random(10, 30), true, false, true), 5, false, 'BackupRnd')
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(toEscortScouts) == false then
            local bRemoveAssignment = false
            for iScout, oScout in toEscortScouts do
                --If target is underwater and we are not amphibious/hover, then no longer assign
                if M28UnitInfo.IsUnitUnderwater(oScout[refoLandScoutTarget]) and not(EntityCategoryContains(M28UnitInfo.refCategoryAmphibious + categories.HOVER, oScout.UnitId)) then
                    oScout[refoLandScoutTarget][refoAssignedLandScout] = nil
                    oScout[refoLandScoutTarget] = nil
                else
                    M28Orders.IssueTrackedMove(oScout, M28Utilities.MoveInDirection(oScout[refoLandScoutTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(oScout[refoLandScoutTarget]:GetPosition(), oScout:GetPosition()), 8, true, false, true), 1.5, false, 'ScACU'..oScout[refoLandScoutTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout[refoLandScoutTarget]))
                end
            end
        end

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateBestEnemyRangesForThisLandZone(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateBestEnemyRangesForThisLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Update best range values for enemies and allies
    local iEnemyBestMobileDFRange = 0
    local iEnemyBestStructureDFRange = 0
    local iEnemyBestMobileIndirectRange = 0

    --First get range for this land zone
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) == false then
        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] do
            if iThreat > 20 then iEnemyBestMobileDFRange = math.max(iRange, iEnemyBestMobileDFRange) end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]='..repru(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange])..'; iEnemyBestMobileDFRange='..iEnemyBestMobileDFRange..'; Is table of enemy structure DF by range empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
            if iThreat > 20 then iEnemyBestStructureDFRange = math.max(iRange, iEnemyBestStructureDFRange) end
            if bDebugMessages == true then LOG(sFunctionRef..': iRange='..iRange..'; iThreat='..iThreat..'; iEnemyBestStructureDFRange after update='..iEnemyBestStructureDFRange) end
        end
    end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange]) == false then
        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] do
            if iThreat > 20 then iEnemyBestMobileIndirectRange = math.max(iRange, iEnemyBestMobileIndirectRange) end
        end
    end
    tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] = iEnemyBestMobileDFRange
    tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] = iEnemyBestStructureDFRange
    tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] = iEnemyBestMobileIndirectRange
    if bDebugMessages == true then LOG(sFunctionRef..': End of code for iLandZone '..iLandZone..'; tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]='..tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordClosestAdjacentEnemiesAndGetBestEnemyRange(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordClosestAdjacentEnemiesAndGetBestEnemyRange'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    tLZTeamData[M28Map.reftoNearestDFEnemies] = {}
    tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere] = nil
    local iEnemyBestMobileDFRange = 0
    local iEnemyBestStructureDFRange = 0
    local iEnemyBestMobileIndirectRange = 0
    tLZTeamData[M28Map.reftoAdjacentStructuresWithHighRange] = {}

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iTeam='..iTeam..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Enemies in this or adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
    if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] or tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
        local tNearestCombatEnemies = {}
        iEnemyBestMobileDFRange = (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0)
        iEnemyBestStructureDFRange = (tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0)
        iEnemyBestMobileIndirectRange = (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0)

        --Adjust the ranges to factor in adjacent land zones
        local iLowestDistUntilInRange = 10000
        local oLowestDFDistUntilInRange
        local tMidpoint = tLZData[M28Map.subrefMidpoint]
        local iCurDistUntilInRange
        local iEnemyPDThreshold
        if bDebugMessages == true then LOG(sFunctionRef..': Best mobile DF range for this zone only='..tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]..'; Mobile structure range='..tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange]..'; Mobile indirect='..tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange]..'; Is table of adjacent LZs empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]))) end
        function UpdateForAdjacentLandZone(tAltLZTeamData)
            iEnemyBestMobileDFRange = math.max(iEnemyBestMobileDFRange, tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange])
            iEnemyBestStructureDFRange = math.max(iEnemyBestStructureDFRange, tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange])
            --Record adjacent structures that have high (highest recorded or >=50) DF range
            iEnemyPDThreshold = math.min(50, math.max(     iEnemyBestMobileDFRange,iEnemyBestStructureDFRange))
            if (tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0) >= iEnemyPDThreshold and M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                local tEnemyStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD, tAltLZTeamData[M28Map.subrefTEnemyUnits])
                if M28Utilities.IsTableEmpty(tEnemyStructures) == false then
                    for iUnit, oUnit in tEnemyStructures do
                        if (oUnit[M28UnitInfo.refiDFRange] or 0) >= iEnemyPDThreshold then
                            table.insert(tLZTeamData[M28Map.reftoAdjacentStructuresWithHighRange], oUnit)
                        end
                    end
                end
            end
            iEnemyBestMobileIndirectRange = math.max(iEnemyBestMobileIndirectRange, tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange])
            local toNearbyExperimentalsAndDistUntilInRange = {}
            if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent LZ, Enemy mobile DF for this LZ='..tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]..'; Mobile structure range='..tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange]..'; Mobile indirect='..tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange]) end
            if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subrefTEnemyUnits]) == false and tAltLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 10 then
                for iUnit, oUnit in tAltLZTeamData[M28Map.subrefTEnemyUnits] do
                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit[M28UnitInfo.refiDFRange] > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) then
                        iCurDistUntilInRange = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tMidpoint) - oUnit[M28UnitInfo.refiDFRange]
                        if EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then table.insert(toNearbyExperimentalsAndDistUntilInRange, {oUnit, iCurDistUntilInRange}) end
                        if iCurDistUntilInRange < iLowestDistUntilInRange then
                            oLowestDFDistUntilInRange = oUnit
                            iLowestDistUntilInRange = iCurDistUntilInRange
                        end
                    end
                end
            end
            if oLowestDFDistUntilInRange  then
                table.insert(tLZTeamData[M28Map.reftoNearestDFEnemies], oLowestDFDistUntilInRange)
            end
            --Include experimentals that are almost the closest unit (so our 'choose manual attack' logic works better)
            if M28Utilities.IsTableEmpty(toNearbyExperimentalsAndDistUntilInRange) == false then
                for iEntry, tExpSubtable in toNearbyExperimentalsAndDistUntilInRange do
                    if not(tExpSubtable[1] == oLowestDFDistUntilInRange) and tExpSubtable[2] - 20 <= math.max(5, iLowestDistUntilInRange) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding further away experimental from adjacnet zone into table of nearest enemy DF units, Expeirmental unit='..tExpSubtable[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tExpSubtable[1])) end
                        table.insert(tLZTeamData[M28Map.reftoNearestDFEnemies], tExpSubtable[1])
                    end
                end
            end
        end
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for iEntry, iAdjLandZone in tLZData[M28Map.subrefLZAdjacentLandZones] do
                iLowestDistUntilInRange = 10000
                oLowestDFDistUntilInRange = nil
                UpdateForAdjacentLandZone(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLandZone][M28Map.subrefLZTeamData][iTeam])
            end
        end

        --Factor in non-adjacent zones that still have segments close enough to threaten this zone
        if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
            for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                UpdateForAdjacentLandZone(M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam])
            end
        end

        --Factor in adjacent water zones
        if bDebugMessages == true then LOG(sFunctionRef..': Is tLZData[M28Map.subrefAdjacentWaterZones] empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
        if tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
            local iAdjWZ, iPond
            for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                iPond = M28Map.tiPondByWaterZone[iAdjWZ]
                local tWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjWZ='..iAdjWZ..' for iPond='..iPond..'; Enemy Combat total='..(tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)..'; Is Nearest combat enemies empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]))) end
                if (tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 20 and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]) == false then
                    iEnemyBestMobileDFRange = math.max(iEnemyBestMobileDFRange, (tWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0))
                    iLowestDistUntilInRange = 10000
                    oLowestDFDistUntilInRange = nil

                    for iUnit, oUnit in tWZTeamData[M28Map.reftoNearestCombatEnemies] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0)) end
                        if M28UnitInfo.IsUnitValid(oUnit) and (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then
                            iCurDistUntilInRange = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tMidpoint) - oUnit[M28UnitInfo.refiDFRange]
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurDistUntilInRange='..iCurDistUntilInRange) end
                            if iCurDistUntilInRange < iLowestDistUntilInRange then
                                oLowestDFDistUntilInRange = oUnit
                                iLowestDistUntilInRange = iCurDistUntilInRange
                            end
                        end
                    end
                    if oLowestDFDistUntilInRange  then
                        table.insert(tLZTeamData[M28Map.reftoNearestDFEnemies], oLowestDFDistUntilInRange)
                    end
                end
            end
        end

        --Add all units from this zone into reftoNearestDFEnemies
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] then
            for iUnit, oUnit in tLZTeamData[M28Map.subrefTEnemyUnits] do
                if oUnit[M28UnitInfo.refiDFRange] > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) then
                    table.insert(tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit)
                end
            end
        end
    end

    --Record nearest enemy structure if this land zone is large enough and has no enemies (for performance reasons - dont want to risk doing this calculation on tiny zones/mini plateaus near an enemy base), and currently planned use is only for indirect fire units as a backup target
    tLZTeamData[M28Map.refbEnemiesInNearbyPlateau] = false
    if bDebugMessages == true then LOG(sFunctionRef..': Will check for nearby enemy structures if no enemies in this LZ, iPlateau='..iPlateau..'; iLandZOne='..iLandZone..'; Enemies in this or adj LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Total segment count='..tLZData[M28Map.subrefLZTotalSegmentCount]..'; Segment size='..M28Map.iLandZoneSegmentSize..'; is table of other land and water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]))) end
    if not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and tLZData[M28Map.subrefLZTotalSegmentCount] >= 150 / M28Map.iLandZoneSegmentSize then
        M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint])
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
            local iClosestEnemyDist = 10000
            local oClosestEnemy
            local iCurDist
            for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateauOrPond='..tSubtable[M28Map.subrefiPlateauOrPond]..'; Is water zone='..tostring(tSubtable[M28Map.subrefbIsWaterZone])..'; Distance='..tSubtable[M28Map.subrefiDistance]..'; iEntry='..iEntry) end
                if tSubtable[M28Map.subrefiDistance] >= 170 and (iEntry >= 7 or tSubtable[M28Map.subrefiDistance] >= 320) then break end
                if not(iPlateau == tSubtable[M28Map.subrefiPlateauOrPond]) and not(tSubtable[M28Map.subrefbIsWaterZone]) then
                    --Have a nearby land zone in a different plateau, check if there are enemy units in this LZ and (if so) if any of them are structures
                    local tAdjLZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                    if not(tAdjLZData[M28Map.subrefbPacifistArea]) then
                        local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]))) end
                        if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                            tLZTeamData[M28Map.refbEnemiesInNearbyPlateau] = true
                            local tEnemyStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tAdjLZTeamData[M28Map.subrefTEnemyUnits])
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy structures empty='..tostring(M28Utilities.IsTableEmpty(tEnemyStructures))) end
                            if M28Utilities.IsTableEmpty(tEnemyStructures) == false then
                                for iUnit, oUnit in tEnemyStructures do
                                    if M28UnitInfo.IsUnitValid(oUnit) then
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit:GetPosition())
                                        if iCurDist <= iClosestEnemyDist then
                                            oClosestEnemy = oUnit
                                            iClosestEnemyDist = iCurDist
                                            if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..iCurDist..'; this is the closest unit for now, will cycle through any remaining') end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for enemy structure in nearby different plateau, oClosestEnemy='..(oClosestEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestEnemy) or 'nli')) end
            tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere] = oClosestEnemy
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iEnemyBestMobileDFRange='..iEnemyBestMobileDFRange..'; iEnemyBestStructureDFRange='..iEnemyBestStructureDFRange..'; iEnemyBestMobileIndirectRange='..iEnemyBestMobileIndirectRange) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iEnemyBestMobileDFRange, iEnemyBestStructureDFRange, iEnemyBestMobileIndirectRange
end

function ReviseTargetLZIfFarAway(tLZData, iTeam, iPlateau, iStartLandZone, iTargetLandZone, iMaxLZTowardsRally)
    --If we want to move to a rally point but it is more than iMaxLZTowardsRally land zones away, then go to the iMaxLZTowardsRally'th entry
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReviseTargetLZIfFarAway'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iNewTargetLZ = iTargetLandZone
    if not(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]) then
        M28Map.ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iPlateau, iStartLandZone, iTargetLandZone, tLZData[M28Map.subrefMidpoint])
    end
    if iMaxLZTowardsRally and tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone] then
        if bDebugMessages == true then
            LOG(sFunctionRef..': WIll consider revising the '..iMaxLZTowardsRally..' entry along the path; repru of the path='..repru(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath])..'; Position in the path='..tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone])
            local tPath = {}
            table.insert(tPath, tLZData[M28Map.subrefMidpoint])
            for iEntry, iZone in tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath] do
                table.insert(tPath, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iZone][M28Map.subrefMidpoint])
            end
            M28Utilities.DrawPath(tPath)
        end
        --Change closest LZ to run to to be 2 along the path from cur LZ to the target LZ
        for iEntry, iLZPointInPath in tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath] do
            if iEntry >= iMaxLZTowardsRally then
                if bDebugMessages == true then LOG(sFunctionRef..': Were going to move to iTargetLandZone='..iTargetLandZone..' from LZ'..iStartLandZone..' but it is at least iMaxLZTowardsRally='..iMaxLZTowardsRally..' LZ away so will move to iEntry LZ which is '..iLZPointInPath..'; Total paht size='..table.getn(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath])) end
                iNewTargetLZ = iLZPointInPath
                break
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iNewTargetLZ
end

function GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, iMaxLZTowardsRally, bAmphibiousPathing)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNearestLandRallyPoint'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Gets the location of the nearest rally point; if bAmphibiousPathing is true then will consider other islands, otherwise will only consider current island

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau]) == false then
        local iCurDist
        local iClosestDist = 100000
        local iClosestLZRef
        local iBaseIsland = tLZData[M28Map.subrefLZIslandRef]
        local iClosestAmphibDist = 100000
        local iClosestAmphibLZRef
        local iSecondClosestDist = 100000
        local iSecondClosestLZRef

        if bDebugMessages == true then LOG(sFunctionRef..': have potential land zones to consider for plateau '..iPlateau..'; bAmphibiousPathing='..tostring(bAmphibiousPathing or false)) end
        for iEntry, iAltLZ in M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau] do
            if bDebugMessages == true then LOG(sFunctionRef..': Looking for rally point for iPlateau '..iPlateau..'; iLandZone '..iLandZone..'; Considering iAltLZ='..iAltLZ..'; Travel distance to here='..(M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iAltLZ) or 'nil')) end
            if iAltLZ == iLandZone then
                if not(iClosestLZRef) then
                    iClosestLZRef = iAltLZ
                    --break
                end
            else
                if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAltLZ][M28Map.subrefLZIslandRef] == iBaseIsland then
                    iCurDist = (M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iAltLZ) or iClosestDist + 1)  --M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAltLZ][M28Map.subrefMidpoint], tLZData[M28Map.subrefMidpoint])
                    if iCurDist < iClosestDist then
                        iSecondClosestLZRef = iClosestLZRef
                        iSecondClosestDist = iClosestDist
                        iClosestDist = iCurDist
                        iClosestLZRef = iAltLZ
                        if bDebugMessages == true then LOG(sFunctionRef..': Have a new closestLZRef that is on same island, iBaseIsland='..iBaseIsland..'; iClosestLZRef='..iClosestLZRef..'; iClosestDist='..iClosestDist) end
                    elseif iCurDist < iSecondClosestDist then
                        iSecondClosestDist = iCurDist
                        iSecondClosestLZRef = iAltLZ
                    end
                elseif bAmphibiousPathing and not(iClosestLZRef) then
                    iCurDist = M28Utilities.GetDistanceBetweenPositions( M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAltLZ][M28Map.subrefMidpoint], tLZData[M28Map.subrefMidpoint])
                    if iCurDist < iClosestAmphibDist then
                        iClosestAmphibDist = iCurDist
                        iClosestAmphibLZRef = iAltLZ
                        if bDebugMessages == true then LOG(sFunctionRef..': Have a new closetsAmphibLZRef, iClosestAmphibDist='..iClosestAmphibDist..'; iClosestAmphibLZRef='..iClosestAmphibLZRef) end
                    end
                end
            end
        end
        if not(iClosestLZRef) then
            if bAmphibiousPathing and iClosestAmphibLZRef then iClosestLZRef = iClosestAmphibLZRef
            else
                iClosestLZRef = iLandZone
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Dont have iClosestLZRef, bAmphibiousPathing='..tostring(bAmphibiousPathing or false)..'; iClosestAmphibLZRef='..(iClosestAmphibLZRef or 'nil')..'; iClosestLZRef after updating for amphibious or setting to cur land zone='..iClosestLZRef) end
        else
            iClosestAmphibLZRef = nil
        end
        if iClosestLZRef == iLandZone then
            --Do nothing - wont find a closer one
        else
            --Do we have a path to this rally point from the current land zone? If so move 2 along the path
            if iClosestAmphibLZRef then
                --Do nothign - will just want to go straight to the amphibious LZ
            else
                local tZonesToConsider = {iClosestLZRef}
                if iSecondClosestLZRef then table.insert(tZonesToConsider, iSecondClosestLZRef) end
                for _, iTargetLZRef in tZonesToConsider do
                    if not(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLZRef]) then
                        M28Map.ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iPlateau, iLandZone, iTargetLZRef, tLZData[M28Map.subrefMidpoint])
                        if not(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLZRef]) then
                            M28Utilities.ErrorHandler('Dont have pathing recorded for iTargetLZRef='..iTargetLZRef..'; iPlateau='..iPlateau..'; iBaesLZ='..iLandZone..'; iClosestLZRef='..iClosestLZRef..' even after checking to update pathing, if logs are enabled will draw midpoint of LZ')
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint])..'; subrefLZTotalSegmentCount for closest LZref='..(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLZRef][M28Map.subrefLZTotalSegmentCount] or 'nil')..'; Will draw midpoint in red, and hten draw the base LZ in gold and the closest LZ in cyan')
                                M28Utilities.DrawLocation(tLZData[M28Map.subrefMidpoint], 2, 200)
                                M28Map.DrawSpecificLandZone(iPlateau, iLandZone, 4)
                                M28Map.DrawSpecificLandZone(iPlateau, iTargetLZRef, 6)
                            end
                        end
                    end
                end
                --Consider switching from closest to second closest if closest is dangerous and secondclosest is closer to our base;  this is to avoid scenario (covered in v113 changes) where we try moving to a LZ 2 away, and the first LZ to get there takes us closer to the enemy
                if iSecondClosestLZRef and tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef] and tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iSecondClosestLZRef] then
                    local iClosestFirstZone = tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef]][M28Map.subrefLZPath][1]
                    local tClosestFirstZoneLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestFirstZone]
                    local tClosestFirstZoneLZTeamData = tClosestFirstZoneLZData[M28Map.subrefLZTeamData][iTeam]
                    local iSecondClosestFirstZone = tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iSecondClosestLZRef]][M28Map.subrefLZPath][1]
                    local tSecondClosestFirstZoneLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iSecondClosestFirstZone]
                    local tSecondClosestFirstZoneLZTeamData = tSecondClosestFirstZoneLZData[M28Map.subrefLZTeamData][iTeam]
                    --Does the closest first zone closer to the enemy and has significantly more enemy combat threat than the second closest first zone?
                    if bDebugMessages == true then LOG(sFunctionRef..': iLandZone='..iLandZone..'; iPlateua='..iPlateau..'; First closest LZ='..iClosestFirstZone..'; Second closest first zone='..iSecondClosestFirstZone..'; ClosestFirstZoneModDist%='..(tClosestFirstZoneLZTeamData[M28Map.refiModDistancePercent] or 'nil')..'; Second closest='..(tSecondClosestFirstZoneLZTeamData[M28Map.refiModDistancePercent] or 'nil')..'; Closest net combat='..((tClosestFirstZoneLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) - (tClosestFirstZoneLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0))..'; Second closest net combat='.. ((tSecondClosestFirstZoneLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) - (tSecondClosestFirstZoneLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)..'; iSecondClosestLZRef='..(iSecondClosestLZRef or 'nil')..'; iSecondClosestDist='..iSecondClosestDist)) end
                    if iSecondClosestLZRef and tSecondClosestFirstZoneLZTeamData[M28Map.refiModDistancePercent] and tClosestFirstZoneLZTeamData[M28Map.refiModDistancePercent] > tSecondClosestFirstZoneLZTeamData[M28Map.refiModDistancePercent] and tClosestFirstZoneLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > tClosestFirstZoneLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] * 0.8 and tClosestFirstZoneLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] - tClosestFirstZoneLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > 1.2 * (tSecondClosestFirstZoneLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] - tSecondClosestFirstZoneLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Switching rally point so will treat second closest as the actual closest') end
                        iClosestLZRef = iSecondClosestLZRef
                        iClosestDist = iSecondClosestDist
                    end
                end



                if iMaxLZTowardsRally and tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef] then
                    if (iClosestDist <= 250 or iClosestAmphibDist <= 250) then iMaxLZTowardsRally = iMaxLZTowardsRally + 1 end
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': WIll consider changing to the '..iMaxLZTowardsRally..' entry along the path to get to zone '..iClosestLZRef..'; repru of the path='..repru(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef]][M28Map.subrefLZPath])..'; Position in the path='..tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef]..'; tLZData[M28Map.subrefLZPathingToOtherLZEntryRef]='..repru(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef])..'; iClosestLZRef='..iClosestLZRef..'; Full listing of repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones]='..repru(repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZPathingToOtherLandZones]))..'; Dist to end destination (straight line)='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef][M28Map.subrefMidpoint]))
                        local tPath = {}
                        table.insert(tPath, tLZData[M28Map.subrefMidpoint])
                        for iEntry, iZone in tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef]][M28Map.subrefLZPath] do
                            table.insert(tPath, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iZone][M28Map.subrefMidpoint])
                            if bDebugMessages == true then LOG(sFunctionRef..': Dist from path entry iZone '..iZone..' to the target='..M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iZone][M28Map.subrefMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef][M28Map.subrefMidpoint])) end
                        end
                        M28Utilities.DrawPath(tPath)
                        if bDebugMessages == true then LOG(sFunctionRef..': repru of tPath if going the full path='..repru(tPath)) end
                    end
                    local tTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef]
                    local iAngleToTargetLZ = M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tTargetLZData[M28Map.subrefMidpoint])
                    local bKeepLooking
                    local iStraightLineDistToTarget = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tTargetLZData[M28Map.subrefMidpoint])
                    --Change closest LZ to run to to be 2 along the path from cur LZ to the target LZ
                    for iEntry, iLZPointInPath in tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZRef]][M28Map.subrefLZPath] do
                        if iEntry >= iMaxLZTowardsRally then
                            if iLZPointInPath == iClosestLZRef then break else
                                --Consider moving to iMaxLZTowardsRally + 1 entry if not much further away; consider just going to the end point if this would be in a very different angle to the original location as well
                                local tPathLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZPointInPath]
                                if bDebugMessages == true then LOG(sFunctionRef..': iEntry='..iEntry..'; iMaxLZTowardsRally='..iMaxLZTowardsRally..'; iLZPointInPath='..iLZPointInPath..'; iClosestDist before='..iClosestDist..'; iClosestAmphibDist before='..(iClosestAmphibDist or 'nil')..'; Angle to along path LZ='..M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tPathLZData[M28Map.subrefMidpoint])..'; Angle to end LZ wanted='..iAngleToTargetLZ..'; angle dif='..M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tPathLZData[M28Map.subrefMidpoint]), iAngleToTargetLZ)) end
                                if iEntry >= iMaxLZTowardsRally + 3 then
                                    iClosestLZRef = iLZPointInPath
                                    break
                                else
                                    bKeepLooking = false
                                    if M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tPathLZData[M28Map.subrefMidpoint]), iAngleToTargetLZ) >= 45 then
                                        bKeepLooking = true
                                    elseif iStraightLineDistToTarget - M28Utilities.GetDistanceBetweenPositions(tPathLZData[M28Map.subrefMidpoint], tTargetLZData[M28Map.subrefMidpoint]) < math.min(150, iEntry * 40) then
                                        --Quite a big angle dif, so consider moving up to 2 further along path
                                        bKeepLooking = true
                                    end
                                    if not(bKeepLooking) then
                                        iClosestLZRef = iLZPointInPath
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iMaxLZTowardsRally='..(iMaxLZTowardsRally or 'nil')..'; iClosestLZRef='..iClosestLZRef) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return {M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef][M28Map.subrefMidpoint][1], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef][M28Map.subrefMidpoint][2], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZRef][M28Map.subrefMidpoint][3]}
    else
        if not(M28Map.bIsCampaignMap) or M28Conditions.IsLocationInPlayableArea(M28Map.PlayerStartPoints[M28Team.GetFirstActiveM28Brain(iTeam):GetArmyIndex()]) then
            --If dealing with plateau with 3+ zones then might not have set any to have a rally point
            M28Utilities.ErrorHandler('No rally point for P'..(iPlateau or 'nil')..' LZ'..(iLandZone or 'nil')..' for team '..iTeam..'; will return current midpoint', true)
            if bDebugMessages == true then
                LOG(sFunctionRef..': Will draw specific land zone in gold, midpoint='..repru(tLZData[M28Map.subrefMidpoint])..'; Closest friendly base='..repru(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.reftClosestFriendlyBase])..'; iTeam='..iTeam)
                M28Map.DrawSpecificLandZone(iPlateau, iLandZone, 4)
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return {tLZData[M28Map.subrefMidpoint][1], tLZData[M28Map.subrefMidpoint][2], tLZData[M28Map.subrefMidpoint][3]}
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshLandRallyPoints(iTeam, iPlateau)
    --For now just has core bases and core expansion points as rally points, may adjust htis in the future
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshLandRallyPoints'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    

    if not(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau]) then M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau] = {} end
    M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau] = {}
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones]) == false then
        local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
        local iHighestSValue = 0
        local iLZWithHighestSValue
        local tiDangerousCoreBaseRefs = {}
        local iNetCombatValue
        local iMaxZoneCount = (M28Map.tAllPlateaus[iPlateau][M28Map.subrefLandZoneCount] or 0)

        for iLandZone, tLZData in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones] do
            if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then
                if bDebugMessages == true then LOG(sFunctionRef..': considering if we want zone '..iLandZone..' in iPlateau='..iPlateau..' to be a rally point, is core base='..tostring(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] or false)..'; is core expansion='..tostring(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZCoreExpansion] or false)..'; iMaxZoneCount='..iMaxZoneCount) end
                local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                if tLZTeamData[M28Map.subrefLZbCoreBase] or (tLZTeamData[M28Map.subrefLZSValue] >= 200 and (tLZTeamData[M28Map.subrefLZCoreExpansion] or (not(iLZWithHighestSValue) and tLZTeamData[M28Map.subrefLZSValue] >= 1000)) or (iMaxZoneCount <= 2 and (tLZTeamData[M28Map.subrefLZCoreExpansion] or (tLZData[M28Map.subrefLZMexCount] or 0) > 0))) then
                    if tLZTeamData[M28Map.subrefLZSValue] >= iHighestSValue then
                        iHighestSValue = tLZTeamData[M28Map.subrefLZSValue]
                        iLZWithHighestSValue = iLandZone
                    end
                    --Dont have as rally if enemy has T2 arti nearby
                    if iMaxZoneCount > 1 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) and (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) == 0 then
                        iNetCombatValue = (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) - (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)
                        if iNetCombatValue < 0 or (tLZTeamData[M28Map.subrefLZbCoreBase] and (iNetCombatValue <= 200 or  (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) < (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0) * 1.25)) then
                            table.insert(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau], iLandZone)
                        elseif tLZTeamData[M28Map.subrefLZbCoreBase] then
                            table.insert(tiDangerousCoreBaseRefs, iLandZone)
                        end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau]) then
            if iLZWithHighestSValue then table.insert(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau], iLZWithHighestSValue)
            elseif M28Utilities.IsTableEmpty(tiDangerousCoreBaseRefs) == false then
                for iEntry, iLandZone in tiDangerousCoreBaseRefs do
                    table.insert(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau], iLandZone)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, iLZOrWZToSupport, iMAAFactorAdjust, bWaterZone, tHoverMAAToAdvance)
    --Assigns MAA to the land zone up to the level at which the LZ doesnt want more MAA support, but increases the MAA wanted by the land zone by iMAAFactorAdjust (or 1 if not specified)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SendMAAToSupportLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tAltLZOrWZData
    local tAltTeamLZOrWZData
    local tTargetPosition
    local iPond
    local iMAAThreatWanted, iAllyGroundAA
    if bWaterZone then
        iPond = M28Map.tiPondByWaterZone[iLZOrWZToSupport]
        tAltLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iLZOrWZToSupport]
        tAltTeamLZOrWZData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
        tTargetPosition = tAltLZOrWZData[M28Map.subrefMidpoint]
        iMAAThreatWanted = tAltTeamLZOrWZData[M28Map.subrefWZMAAThreatWanted]
        iAllyGroundAA = tAltTeamLZOrWZData[M28Map.subrefWZThreatAlliedAA]
    else
        tAltLZOrWZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZOrWZToSupport]
        tAltTeamLZOrWZData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
        tTargetPosition = tAltLZOrWZData[M28Map.subrefMidpoint]
        iMAAThreatWanted = tAltTeamLZOrWZData[M28Map.subrefLZMAAThreatWanted]
        iAllyGroundAA = tAltTeamLZOrWZData[M28Map.subrefLZThreatAllyGroundAA]
    end

    local tDistToTargetByRef = {}
    if not(iMAAThreatWanted) or not(iAllyGroundAA) then
        M28Utilities.ErrorHandler('Have nil MAA or AllyGroundAA threat for iLZOrWZToSupport='..(iLZOrWZToSupport or 'nil')..'; see log for more info')
        LOG(sFunctionRef..': MAA iTeam='..(iTeam or 'nil')..'; iPlateau='..(iPlateau or 'nil')..'; iLZOrWZToSupport='..(iLZOrWZToSupport or 'nil')..'; tAltTeamLZOrWZData[M28Map.subrefLZMAAThreatWanted]='..(tAltTeamLZOrWZData[M28Map.subrefLZMAAThreatWanted] or 'nil')..'; tAltTeamLZOrWZData[M28Map.subrefLZThreatAllyGroundAA]='..(tAltTeamLZOrWZData[M28Map.subrefLZThreatAllyGroundAA] or 'nil')..'; reprs of teamLZData='..reprs(tAltTeamLZOrWZData))
    else
        iMAAThreatWanted = iMAAThreatWanted * (iMAAFactorAdjust or 1) - iAllyGroundAA

        for iUnit, oUnit in (tHoverMAAToAdvance or tMAAToAdvance) do
            tDistToTargetByRef[iUnit] = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetPosition)
        end
        local tbRemovedMAAReferencesByRef = {}
        for iUnitRef, iDistance in M28Utilities.SortTableByValue(tDistToTargetByRef, false) do
            if bDebugMessages == true then LOG(sFunctionRef..': About to issue order to move for iUnitRef='..iUnitRef..'; tMAAToAdvance[iUnitRef]='..(tMAAToAdvance[iUnitRef].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tMAAToAdvance[iUnitRef]) or 'nil')..' to go to tTargetPosition='..repru(tTargetPosition)) end
            M28Orders.IssueTrackedMove(tMAAToAdvance[iUnitRef], tTargetPosition, 10, false, 'MVELZ'..iLZOrWZToSupport)
            iMAAThreatWanted = iMAAThreatWanted - M28UnitInfo.GetAirThreatLevel({ tMAAToAdvance[iUnitRef] }, false, false, true, false, false, false)
            tbRemovedMAAReferencesByRef[iUnitRef] = true
            if iMAAThreatWanted < 0 then break end
        end
        if M28Utilities.IsTableEmpty(tbRemovedMAAReferencesByRef) == false then
            --Remove any MAA that have given orders from tMAAToAdvance:
            if M28Utilities.IsTableEmpty(tHoverMAAToAdvance) then
                local iRevisedIndex = 1
                local iTableSize = table.getn(tMAAToAdvance)

                for iOrigIndex=1, iTableSize do
                    if tMAAToAdvance[iOrigIndex] then
                        if not(tbRemovedMAAReferencesByRef[iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                            --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                            if (iOrigIndex ~= iRevisedIndex) then
                                tMAAToAdvance[iRevisedIndex] = tMAAToAdvance[iOrigIndex];
                                tMAAToAdvance[iOrigIndex] = nil;
                            end
                            iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                        else
                            tMAAToAdvance[iOrigIndex] = nil;
                        end
                    end
                end
                if iRevisedIndex < iTableSize then
                    --table.setn(tMAAToAdvance, iRevisedIndex - 1)
                    for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
                        table.remove(tMAAToAdvance, iRemovalEntry)
                    end
                end
            else
                --Need to remove from both the hover MAA table, and the main MAA table
                local iRevisedIndex = 1
                local iTableSize = table.getn(tHoverMAAToAdvance)


                for iOrigIndex=1, iTableSize do
                    if tHoverMAAToAdvance[iOrigIndex] then
                        if not(tbRemovedMAAReferencesByRef[iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                            --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                            if (iOrigIndex ~= iRevisedIndex) then
                                tHoverMAAToAdvance[iRevisedIndex] = tHoverMAAToAdvance[iOrigIndex];
                                tHoverMAAToAdvance[iOrigIndex] = nil;
                            end
                            iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                        else
                            --Want to remove the unit - also remove from the original MAA table
                            for iUnit, oUnit in tMAAToAdvance do
                                if oUnit == tHoverMAAToAdvance[iOrigIndex] then
                                    table.remove(tMAAToAdvance, iUnit)
                                    break
                                end
                            end
                            tHoverMAAToAdvance[iOrigIndex] = nil;
                        end
                    end
                end
                if iRevisedIndex < iTableSize then
                    --table.setn(tHoverMAAToAdvance, iRevisedIndex - 1)
                    for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
                        table.remove(tHoverMAAToAdvance, iRemovalEntry)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function StealthUnitsInLandZone(tTeamTargetLZData, tStealthsToAssign, bAssignAllStealths)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'StealthUnitsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --local tTargetLandZone = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][iTeam]
    local bNoUnitsWantingStealthing = true
    if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileStealth]) then
        M28Utilities.ErrorHandler('Are trying to send mobile Stealths to support a land zone that has no allied combat units in it and no units wanting Stealthing')
    else
        if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileStealth]) == false then
            for iTarget, oTarget in tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileStealth] do
                if not(oTarget[refoAssignedMobileStealth]) then
                    if M28Utilities.IsTableEmpty(tStealthsToAssign) then
                        bNoUnitsWantingStealthing = false
                        break
                    else
                        --Assign the closest mobile Stealth
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iStealth, oStealth in tStealthsToAssign do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iStealth='..iStealth..'; Stealth unit='..oStealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth)) end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oStealth:GetPosition(), oTarget:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iStealth
                            end
                            break
                        end
                        tStealthsToAssign[iClosestRef][refoMobileStealthTarget] = oTarget
                        oTarget[refoAssignedMobileStealth] = tStealthsToAssign[iClosestRef]
                        MoveToStealthTarget(tStealthsToAssign[iClosestRef], tTeamTargetLZData[M28Map.reftClosestEnemyBase])
                        table.remove(tStealthsToAssign, iClosestRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have just removed Stealth with iClosestRef='..iClosestRef..' from the table of tStealthsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; size of table='..table.getn(tStealthsToAssign)) end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tStealthsToAssign) == false and bAssignAllStealths then
            bNoUnitsWantingStealthing = true
            --No units that want Stealthing - e.g. we might be telling mobile Stealths to defend here temporarily; dont assign the Stealths, instead just give them orders so they are still of some use
            if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) == false then
                for iTarget, oTarget in tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits] do
                    if not(oTarget[refoAssignedMobileStealth]) then --redundancy
                        --Assign the closest mobile Stealth
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iStealth, oStealth in tStealthsToAssign do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iStealth='..iStealth..'; Stealth unit='..oStealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth)) end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oStealth:GetPosition(), oTarget:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iStealth
                            end
                            break
                        end
                        --Dont record the Stealth as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoStealthtarget works
                        tStealthsToAssign[iClosestRef][refoMobileStealthTarget] = oTarget
                        MoveToStealthTarget(tStealthsToAssign[iClosestRef], tTeamTargetLZData[M28Map.reftClosestEnemyBase])
                        tStealthsToAssign[iClosestRef][refoMobileStealthTarget] = nil
                        table.remove(tStealthsToAssign, iClosestRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Backup Stealth assignment - Have removed Stealth with iClosestRef='..iClosestRef..' from the table of tStealthsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; size of table='..table.getn(tStealthsToAssign)) end
                        if M28Utilities.IsTableEmpty(tStealthsToAssign) then break end
                    end
                end

                --Do we still have spare mobile Stealths?
                if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                    --Get closest unit to enemy base and assign all remaining Stealths temporarily here
                    local iCurDist
                    local iClosestDist = 100000
                    local oClosestToEnemyBase

                    for iTarget, oTarget in tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits] do
                        if M28UnitInfo.IsUnitValid(oTarget) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), tTeamTargetLZData[M28Map.reftClosestEnemyBase])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oClosestToEnemyBase = oTarget
                            end
                        end
                    end
                    if oClosestToEnemyBase then
                        local tEnemyBase = tTeamTargetLZData[M28Map.reftClosestEnemyBase]
                        for iStealth, oStealth in tStealthsToAssign do
                            --Dont record the Stealth as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoStealthtarget works
                            if bDebugMessages == true then LOG(sFunctionRef..': About to tell Stealth '..(oStealth.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oStealth) or 'nil')..' to move towards oClosestToEnemyBase='..(oClosestToEnemyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase) or 'nil')) end
                            oStealth[refoMobileStealthTarget] = oClosestToEnemyBase
                            MoveToStealthTarget(oStealth, tEnemyBase)
                            oStealth[refoMobileStealthTarget] = nil
                            if bDebugMessages == true then LOG(sFunctionRef..': Backup Stealth assignment - have told Stealth '..oStealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth)..' to go to the closest enemy in this LZ to enemy base='..oClosestToEnemyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase)) end
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': No friendly units close to enemy base - assuming this is termpoary due to unit being destroyed')
                    end
                end
            end
        end
    end
    if bNoUnitsWantingStealthing then
        --Flag that this LZ no longer wants mobile Stealths
        tTeamTargetLZData[M28Map.refbLZWantsMobileStealth] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordMobileShieldAgainstTarget(oShield, oTarget)
    oShield[refoMobileShieldTarget] = oTarget
    if EntityCategoryContains(categories.COMMAND, oTarget.UnitId) then
        local iEnemyNovaxCount = M28Team.tTeamData[oTarget:GetAIBrain().M28Team][M28Team.refiEnemyNovaxCount]
        local bAssignAsExtraShield = false
        if iEnemyNovaxCount > 0 then
            local iExistingExtraShields = 0
            if M28Conditions.IsTableOfUnitsStillValid(oTarget[reftoAdditionalAssignedMobileShields]) then
                iExistingExtraShields = table.getn(oTarget[reftoAdditionalAssignedMobileShields])
            end
            if iExistingExtraShields <= math.min(iEnemyNovaxCount, 4) and (iExistingExtraShields <= 2 or M28UnitInfo.GetUnitHealthPercent(oTarget) < 1) then
                bAssignAsExtraShield = true
            end
        end
        if bAssignAsExtraShield then
            if not(oTarget[reftoAdditionalAssignedMobileShields]) then oTarget[reftoAdditionalAssignedMobileShields] = {} end
            table.insert(oTarget[reftoAdditionalAssignedMobileShields], oShield)
        else
            oTarget[refoAssignedMobileShield] = oShield
        end
    else
        oTarget[refoAssignedMobileShield] = oShield
    end
end

function ClearCurrentShieldTarget(oShield)
    if oShield[refoMobileShieldTarget] then
        if M28Utilities.IsTableEmpty(oShield[refoMobileShieldTarget][reftoAdditionalAssignedMobileShields]) == false then
            for iCurShield = table.getn(oShield[refoMobileShieldTarget][reftoAdditionalAssignedMobileShields]), 1, -1 do
                local oCurShield = oShield[refoMobileShieldTarget][reftoAdditionalAssignedMobileShields][iCurShield]
                if oCurShield == oShield then
                    table.remove(oShield[refoMobileShieldTarget][reftoAdditionalAssignedMobileShields], iCurShield)
                end
            end
        end
        if oShield[refoMobileShieldTarget][refoAssignedMobileShield] == oShield then
            oShield[refoMobileShieldTarget][refoAssignedMobileShield] = nil
        end
        oShield[refoMobileShieldTarget] = nil
    end
end

function ShieldUnitsInLandZone(tTeamTargetLZData, tShieldsToAssign, bAssignAllShields)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ShieldUnitsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --local tTargetLandZone = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][iTeam]
    local bNoUnitsWantingShielding = true
    if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]) and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefAlliedACU]) then
        M28Utilities.ErrorHandler('Are trying to send mobile shields to support a land zone that has no allied combat units in it and no units wanting shielding')
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of units wanting mobile shield empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]))) end
        if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]) == false then
            --Prioritise t2 arti if have enemy t2 arti in zone
            function AssignClosestMobileShieldToTarget(oTarget)
                --Returns false if should abort
                if not(oTarget[refoAssignedMobileShield]) then
                    if M28Utilities.IsTableEmpty(tShieldsToAssign) then
                        bNoUnitsWantingShielding = false
                        return false
                    else
                        --Assign the closest mobile shield
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iShield, oShield in tShieldsToAssign do
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oTarget:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iShield='..iShield..'; Shield unit='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; iCurDist='..iCurDist..'; iClosestDist='..iClosestDist..'; oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)) end
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iShield
                            end
                        end
                        RecordMobileShieldAgainstTarget(tShieldsToAssign[iClosestRef], oTarget)

                        MoveToShieldTarget(tShieldsToAssign[iClosestRef], tTeamTargetLZData[M28Map.reftClosestEnemyBase])
                        table.remove(tShieldsToAssign, iClosestRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have just removed shield with iClosestRef='..iClosestRef..' from the table of tShieldsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; size of table='..table.getn(tShieldsToAssign)) end
                        return not(M28Utilities.IsTableEmpty(tShieldsToAssign))
                    end
                end
            end
            local tUnitsToPrioritiseForShielding = {}
            if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
                tUnitsToPrioritiseForShielding = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield])
            end
            if M28Conditions.IsTableOfUnitsStillValid(tTeamTargetLZData[M28Map.subrefAlliedACU]) then
                local iCurHealthPercent
                if not(tUnitsToPrioritiseForShielding) then tUnitsToPrioritiseForShielding = {} end
                for iACU, oACU in tTeamTargetLZData[M28Map.subrefAlliedACU] do
                    iCurHealthPercent = M28UnitInfo.GetUnitHealthPercent(oACU)
                    if iCurHealthPercent <= 0.6 or (iCurHealthPercent <= 0.98 and GetGameTimeSeconds() - (oACU[M28ACU.refiTimeLastWantedToRun] or -100) <= 5) or M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refiEnemyNovaxCount] > 0 then
                        table.insert(tUnitsToPrioritiseForShielding, oACU)
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tUnitsToPrioritiseForShielding) == false then
                for iTarget, oTarget in tUnitsToPrioritiseForShielding do
                    if AssignClosestMobileShieldToTarget(oTarget) == false then break end
                end
            end
            if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]) == false and M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                for iTarget, oTarget in tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield] do
                    if AssignClosestMobileShieldToTarget(oTarget) == false then break end
                end
            end
        end
        if (M28Utilities.IsTableEmpty(tShieldsToAssign) == false or M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefAlliedACU]) == false) and bAssignAllShields then
            bNoUnitsWantingShielding = true
            --No units that want shielding - e.g. we might be telling mobile shields to defend here temporarily; dont assign the shields, instead just give them orders so they are still of some use
            local tPotentialShieldTargets = {}
            if tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits] then tPotentialShieldTargets = tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits] end
            if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefAlliedACU]) == false then
                for iACU, oACU in tTeamTargetLZData[M28Map.subrefAlliedACU] do
                    table.insert(tPotentialShieldTargets, oACU)
                end
            end

            if M28Utilities.IsTableEmpty(tPotentialShieldTargets) == false then
                for iTarget, oTarget in tPotentialShieldTargets do
                    if not(oTarget[refoAssignedMobileShield]) then --redundancy
                        --Assign the closest mobile shield
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iShield, oShield in tShieldsToAssign do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iShield='..iShield..'; Shield unit='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)) end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oTarget:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iShield
                            end
                            break
                        end
                        if iClosestRef then
                            --Dont record the shield as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoshieldtarget works
                            tShieldsToAssign[iClosestRef][refoMobileShieldTarget] = oTarget
                            MoveToShieldTarget(tShieldsToAssign[iClosestRef], tTeamTargetLZData[M28Map.reftClosestEnemyBase])
                            tShieldsToAssign[iClosestRef][refoMobileShieldTarget] = nil
                            table.remove(tShieldsToAssign, iClosestRef)
                            if bDebugMessages == true then LOG(sFunctionRef..': Backup shield assignment - Have removed shield with iClosestRef='..iClosestRef..' from the table of tShieldsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; size of table='..table.getn(tShieldsToAssign)) end
                            if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                        else
                            tShieldsToAssign = {}
                        end
                    end
                end

                --Do we still have spare mobile shields?
                if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                    --Get closest unit to enemy base and assign all remaining shields temporarily here
                    local iCurDist
                    local iClosestDist = 100000
                    local oClosestToEnemyBase

                    for iTarget, oTarget in tPotentialShieldTargets do
                        if M28UnitInfo.IsUnitValid(oTarget) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), tTeamTargetLZData[M28Map.reftClosestEnemyBase])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oClosestToEnemyBase = oTarget
                            end
                        end
                    end
                    if oClosestToEnemyBase then
                        local tEnemyBase = tTeamTargetLZData[M28Map.reftClosestEnemyBase]
                        for iShield, oShield in tShieldsToAssign do
                            --Dont record the shield as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoshieldtarget works
                            if bDebugMessages == true then LOG(sFunctionRef..': About to tell shield '..(oShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oShield) or 'nil')..' to move towards oClosestToEnemyBase='..(oClosestToEnemyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase) or 'nil')) end
                            oShield[refoMobileShieldTarget] = oClosestToEnemyBase
                            MoveToShieldTarget(oShield, tEnemyBase)
                            oShield[refoMobileShieldTarget] = nil
                            if bDebugMessages == true then LOG(sFunctionRef..': Backup shield assignment - have told shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' to go to the closest enemy in this LZ to enemy base='..oClosestToEnemyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase)) end
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': No friendly units close to enemy base - assuming this is termpoary due to unit being destroyed')
                    end
                end
            end
        end
    end
    if bNoUnitsWantingShielding then
        --Flag that this LZ no longer wants mobile shields
        tTeamTargetLZData[M28Map.refbLZWantsMobileShield] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MoveToShieldTarget(oShield, tEnemyBase, tOptionalShieldLZTeamData, tOptionalEnemyDFUnits, tOptionalRallyPoint)
    --If tOptionalShieldLZTeamData is specified, then will check if safe to try and shield the unit
    if EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oShield.UnitId) then M28Utilities.ErrorHandler('Fatboy is being given orders as though it is a shielded unit') end
    local bMoveToUnit = true
    if tOptionalShieldLZTeamData and tOptionalEnemyDFUnits and tOptionalRallyPoint and (tOptionalShieldLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) >= 180 then
        local iDistToShieldTarget = M28Utilities.GetDistanceBetweenPositions(oShield[refoMobileShieldTarget]:GetPosition(), oShield:GetPosition())
        if iDistToShieldTarget >= 50 then
            local tShieldTargetLZData, tShieldTargetLZTeamData = M28Map.GetLandOrWaterZoneData(oShield[refoMobileShieldTarget]:GetPosition(), true, oShield:GetAIBrain().M28Team)
            if not(tShieldTargetLZTeamData ==  tOptionalShieldLZTeamData) then
                if M28Utilities.GetDistanceBetweenPositions(oShield[refoMobileShieldTarget]:GetPosition(), tOptionalRallyPoint) >= M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), tOptionalRallyPoint) then
                    --Are we almost in range of an enemy unit in this zone?
                    if M28Utilities.IsTableEmpty(tOptionalEnemyDFUnits) == false then
                        if M28Conditions.CloseToEnemyUnit(oShield:GetPosition(), tOptionalEnemyDFUnits, 5, oShield:GetAIBrain().M28Team, true) then
                            --LOG('MoveToShieldTarget: Shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' is in a dangerous zone and target '..oShield[refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield[refoMobileShieldTarget])..' is far away so will retreat; Does shield have active micro='..tostring(oShield[M28UnitInfo.refbSpecialMicroActive] or false)..'; Closest friendly base='..repru(tOptionalShieldLZTeamData[M28Map.reftClosestFriendlyBase]))
                            --M28Utilities.DrawLocation(oShield:GetPosition())
                            bMoveToUnit = false
                            --IssueTrackedMove(oUnit, tOrderPosition,                       iDistanceToReissueOrder, bAddToExistingQueue, sOptionalOrderDesc,                                                                                       bOverrideMicroOrder)
                            M28Orders.IssueTrackedMove(oShield, tOptionalRallyPoint, 5, false,                'ShBl'..oShield[refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield[refoMobileShieldTarget]), false)
                        end
                    end

                end
            end
        end

    end
    if bMoveToUnit then

        local oBP = oShield:GetBlueprint()
        --Decide whether to move towards the unit's target if the unit is moving (so e.g. if we are retreating we are less likely to block the retreating unit)
        local bGivenOrderForRetreating = false
        local tTargetFirstOrder = oShield[refoMobileShieldTarget][M28Orders.reftiLastOrders][1]
        if tTargetFirstOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueMove then
            local iDistToEnemyBaseFromUnit = M28Utilities.GetDistanceBetweenPositions(oShield[refoMobileShieldTarget]:GetPosition(), tEnemyBase)
            local iDistToEnemyBaseFromMoveTarget = M28Utilities.GetDistanceBetweenPositions(tTargetFirstOrder[M28Orders.subreftOrderPosition], tEnemyBase)
            if iDistToEnemyBaseFromMoveTarget > iDistToEnemyBaseFromUnit then
                --We are likely retreating
                bGivenOrderForRetreating = true
                local iShieldRadius = oBP.Defense.Shield.ShieldSize * 0.5
                local iShieldDistanceWanted = math.max(5, oBP.Defense.Shield.ShieldSize * 0.5)
                local iTargetSpeed = (oShield[refoMobileShieldTarget]:GetBlueprint().Physics.MaxSpeed or 0)
                local iDistWithinShieldAlready = iShieldRadius - M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oShield[refoMobileShieldTarget]:GetPosition())
                if iDistWithinShieldAlready >= 1 or iTargetSpeed + 1 + iDistWithinShieldAlready >= iShieldRadius then --More than 1 inside shield range or are likely to run into shield
                    iShieldDistanceWanted = iShieldDistanceWanted + math.max(iDistWithinShieldAlready, iTargetSpeed)
                end

                M28Orders.IssueTrackedMove(oShield, M28Utilities.MoveInDirection(oShield[refoMobileShieldTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(oShield[refoMobileShieldTarget]:GetPosition(), tTargetFirstOrder[M28Orders.subreftOrderPosition]), iShieldDistanceWanted, true, false, true), math.min(3, iShieldDistanceWanted - 1, iShieldRadius - 1), false, 'ShRU'..oShield[refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield[refoMobileShieldTarget]))
            end
        end
        if not(bGivenOrderForRetreating) then
            local iShieldDistanceWanted = math.max(3, oBP.Defense.Shield.ShieldSize * 0.5 - 1 - oBP.Physics.MaxSpeed - (oShield[refoMobileShieldTarget]:GetBlueprint().Physics.MaxSpeed or 0))
            M28Orders.IssueTrackedMove(oShield, M28Utilities.MoveInDirection(oShield[refoMobileShieldTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(tEnemyBase,oShield[refoMobileShieldTarget]:GetPosition()), iShieldDistanceWanted, true, false, true), math.min(5, iShieldDistanceWanted - 1), false, 'ShU'..oShield[refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield[refoMobileShieldTarget]))
        end
    end
end

function MoveToStealthTarget(oStealth, tEnemyBase, tOptionalStealthLZTeamData, tOptionalEnemyDFUnits, tOptionalRallyPoint)
    local bMoveToUnit = true
    if tOptionalStealthLZTeamData and tOptionalEnemyDFUnits and tOptionalRallyPoint and (tOptionalStealthLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) >= 180 then
        local iDistToStealthTarget = M28Utilities.GetDistanceBetweenPositions(oStealth[refoMobileStealthTarget]:GetPosition(), oStealth:GetPosition())
        if iDistToStealthTarget >= 50 then
            local tStealthTargetLZData, tStealthTargetLZTeamData = M28Map.GetLandOrWaterZoneData(oStealth[refoMobileStealthTarget]:GetPosition(), true, oStealth:GetAIBrain().M28Team)
            if not(tStealthTargetLZTeamData ==  tOptionalStealthLZTeamData) then
                if M28Utilities.GetDistanceBetweenPositions(oStealth[refoMobileStealthTarget]:GetPosition(), tOptionalRallyPoint) >= M28Utilities.GetDistanceBetweenPositions(oStealth:GetPosition(), tOptionalRallyPoint) then
                    --Are we almost in range of an enemy unit in this zone?
                    if M28Utilities.IsTableEmpty(tOptionalEnemyDFUnits) == false then
                        if M28Conditions.CloseToEnemyUnit(oStealth:GetPosition(), tOptionalEnemyDFUnits, 5, oStealth:GetAIBrain().M28Team, true) then
                            --LOG('MoveToStealthTarget: Stealth '..oStealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth)..' is in a dangerous zone and target '..oStealth[refoMobileStealthTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth[refoMobileStealthTarget])..' is far away so will retreat; Does Stealth have active micro='..tostring(oStealth[M28UnitInfo.refbSpecialMicroActive] or false)..'; Closest friendly base='..repru(tOptionalStealthLZTeamData[M28Map.reftClosestFriendlyBase]))
                            --M28Utilities.DrawLocation(oStealth:GetPosition())
                            bMoveToUnit = false
                            --IssueTrackedMove(oUnit, tOrderPosition,                       iDistanceToReissueOrder, bAddToExistingQueue, sOptionalOrderDesc,                                                                                       bOverrideMicroOrder)
                            M28Orders.IssueTrackedMove(oStealth, tOptionalRallyPoint, 5, false,                'StBl'..oStealth[refoMobileStealthTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth[refoMobileStealthTarget]), false)
                        end
                    end

                end
            end
        end

    end
    if bMoveToUnit then
        local oBP = oStealth:GetBlueprint()
        local iStealthDistanceWanted = math.max(8, oBP.Intel.RadarStealthFieldRadius - 1 - oBP.Physics.MaxSpeed - (oStealth[refoMobileStealthTarget]:GetBlueprint().Physics.MaxSpeed or 0))
        M28Orders.IssueTrackedMove(oStealth, M28Utilities.MoveInDirection(oStealth[refoMobileStealthTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(tEnemyBase,oStealth[refoMobileStealthTarget]:GetPosition()), iStealthDistanceWanted, true, false, true), math.min(5, iStealthDistanceWanted - 1), false, 'StU'..oStealth[refoMobileStealthTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth[refoMobileStealthTarget]))
    end
end

function ManageMobileShieldsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tMobileShields)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMobileShieldsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Size of tMobileShields='..table.getn(tMobileShields)) end

    local iCurShield, iMaxShield
    local tShieldsToRetreat = {}
    local tShieldsToAssign = {}
    local tEnemyBase = tLZTeamData[M28Map.reftClosestEnemyBase]
    if M28Utilities.IsTableEmpty(tEnemyBase) then
        M28Utilities.ErrorHandler('Couldnt find enemy base, will try backup approach')
        local iCurDist
        local iClosestDist = 100000
        local oClosestBrain
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestBrain = oBrain
            end
        end
        tEnemyBase = M28Map.PlayerStartPoints[oClosestBrain:GetArmyIndex()]
    end
    local tEnemyDFUnits
    local tRallyPoint
    if (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 200 then
        tEnemyDFUnits = EntityCategoryFilterDown(categories.DIRECTFIRE, tLZTeamData[M28Map.subrefTEnemyUnits])
        tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 1, false)
    end
    local tOriginallyAssignedMobileShields = {}

    for iUnit, oUnit in tMobileShields do
        iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, false)
        if bDebugMessages == true then LOG(sFunctionRef..': Considering what to do with unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurShield='..iCurShield..'; iMaxShield='..iMaxShield) end
        if not(oUnit[M28UnitInfo.refbEasyBrain]) and iCurShield < iMaxShield * 0.5 then
            --Retreat
            table.insert(tShieldsToRetreat, oUnit)
        elseif oUnit[refoMobileShieldTarget] and M28UnitInfo.IsUnitValid(oUnit[refoMobileShieldTarget]) then
            table.insert(tOriginallyAssignedMobileShields, oUnit)
            --[[
            --make sure we are behind the target
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and get shield '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to move behind the shield target '..oUnit[refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[refoMobileShieldTarget])..'; Unit position='..repru(oUnit:GetPosition())..'; Target last order position='..repru(oUnit[refoMobileShieldTarget][M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition])) end
            MoveToShieldTarget(oUnit, tEnemyBase, tLZTeamData, tEnemyDFUnits, tRallyPoint)--]]
        else
            table.insert(tShieldsToAssign, oUnit)
        end
    end
    if M28Utilities.IsTableEmpty(tShieldsToRetreat) == false then
        local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2)
        local tAmphibiousRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2, true)
        if bDebugMessages == true then LOG(sFunctionRef..': Will give orders to retreat, size of tShieldsToRetreat='..table.getn(tShieldsToRetreat)) end
        for iUnit, oUnit in tShieldsToRetreat do
            if bDebugMessages == true then
                local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, false)
                LOG(sFunctionRef..': About to tell unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to run due to a low shield. iCurShield='..(iCurShield or 'nil')..'; iMaxShield='..(iMaxShield or 'nil')..'; Unit paused='..tostring(oUnit[M28UnitInfo.refbPaused])..'; Are power stalling='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; Team Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; % stored E='..oUnit:GetAIBrain():GetEconomyStoredRatio('ENERGY')..'; Gross energy='..oUnit:GetAIBrain()[import('/mods/M28AI/lua/AI/M28Economy.lua').refiGrossEnergyBaseIncome]..'; oUnit.MyShield.IsOn==nil='..tostring(oUnit.MyShield.IsOn == nil))
            end
            ClearCurrentShieldTarget(oUnit)

            if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ASRun'..iLandZone)
            else
                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'SRun'..iLandZone)
            end
        end
    end
    if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
        --Assign available shields to units in this zone wanting shielding
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield]) == false then
            ShieldUnitsInLandZone(tLZTeamData, tShieldsToAssign)
        end
        if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then


            --Cycle through every land zone and record priority ones to shield
            if bDebugMessages == true then LOG(sFunctionRef..': Will give orders to tShieldsToAssign, size of table='..table.getn(tShieldsToAssign)) end
            local tiClosestLZWithNearbyThreat = {}
            local iClosestLZWithNoThreat
            local iClosestLZNotWantingShieldButWithUnits
            local iClosestLZWithAnyCombatUnits
            local tiAllOtherLZWantingShields = {}
            if tLZTeamData[M28Map.subrefbLZWantsSupport] and not(tLZTeamData[M28Map.refbLZWantsMobileShield]) and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedCombatUnits]) == false or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false) then iClosestLZNotWantingShieldButWithUnits = iLandZone end
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                for iEntry, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                    local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': iLandZone='..iLandZone..'; Considering other land zone '..tPathingDetails[M28Map.subrefLZNumber]..'; Other land zone DF threat='..(tTeamTargetLZData[M28Map.subrefLZThreatAllyMobileDFTotal] or 'nil')..'; Does this zone want mobile shields='..tostring(tTeamTargetLZData[M28Map.refbLZWantsMobileShield] or false)) end
                    if tTeamTargetLZData[M28Map.refbLZWantsMobileShield] then
                        if tTeamTargetLZData[M28Map.refiEnemyAirToGroundThreat] > 0 or tTeamTargetLZData[M28Map.subrefTThreatEnemyCombatTotal] >= 40 then
                            ShieldUnitsInLandZone(tTeamTargetLZData, tShieldsToAssign)
                            if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                        else
                            if M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefTEnemyUnits]) == false or tTeamTargetLZData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                                table.insert(tiClosestLZWithNearbyThreat, tPathingDetails[M28Map.subrefLZNumber])
                            else
                                table.insert(tiAllOtherLZWantingShields, tPathingDetails[M28Map.subrefLZNumber])
                                if not(iClosestLZWithNoThreat) then iClosestLZWithNoThreat = tPathingDetails[M28Map.subrefLZNumber] end
                            end
                        end
                    elseif not(iClosestLZNotWantingShieldButWithUnits) then
                        if tTeamTargetLZData[M28Map.subrefbLZWantsSupport] and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) == false then
                            iClosestLZNotWantingShieldButWithUnits = tPathingDetails[M28Map.subrefLZNumber]
                        end
                        if not(iClosestLZWithAnyCombatUnits) and (M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) == false or M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefAlliedACU]) == false) then
                            iClosestLZWithAnyCombatUnits = tPathingDetails[M28Map.subrefLZNumber]
                        end
                    end

                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking other zones we can path to for units wanting shielding, is tShieldsToAssign empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; Is M28Utilities.IsTableEmpty(tiClosestLZWithNearbyThreat) empty='..tostring(M28Utilities.IsTableEmpty(tiClosestLZWithNearbyThreat))) end
            if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                if M28Utilities.IsTableEmpty(tiClosestLZWithNearbyThreat) == false then
                    for _, iTargetLZ in  tiClosestLZWithNearbyThreat do
                        local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLZ][M28Map.subrefLZTeamData][iTeam]
                        ShieldUnitsInLandZone(tTeamTargetLZData, tShieldsToAssign)
                        if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                    end
                end
                if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                    if iClosestLZWithNoThreat then
                        local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZWithNoThreat][M28Map.subrefLZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Have mobile shields to assign, closest LZ='..iClosestLZWithNoThreat..'; DOes this LZ want mobile shields='..tostring(tTeamTargetLZData[M28Map.refbLZWantsMobileShield] or false)..'; is table of units wanting shielding empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]))) end
                        ShieldUnitsInLandZone(tTeamTargetLZData, tShieldsToAssign)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is tShieldsToAssign empty after checking for closest LZ with no threat='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; iClosestLZNotWantingShieldButWithUnits='..(iClosestLZNotWantingShieldButWithUnits or 'nil')) end
                    if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                        if M28Utilities.IsTableEmpty(tiAllOtherLZWantingShields) == false then
                            for iEntry, iZone in tiAllOtherLZWantingShields do
                                if not(iZone ==iClosestLZWithNoThreat) then
                                    local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZWithNoThreat][M28Map.subrefLZTeamData][iTeam]
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have mobile shields to assign, considering zone that wants shielding, iZone='..iZone..'; DOes this LZ want mobile shields='..tostring(tTeamTargetLZData[M28Map.refbLZWantsMobileShield] or false)..'; is table of units wanting shielding empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]))) end
                                    ShieldUnitsInLandZone(tTeamTargetLZData, tShieldsToAssign)
                                    if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': Still have shields to assign after considering all zones with adjacent enemy threats, so will flag that we failed to have shield targets for plateau '..iPlateau..'; For reference, the current land zone considering this is '..iLandZone..'; Time='..GetGameTimeSeconds()) end
                            if tLZData[M28Map.subrefLZIslandRef] then M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoShieldTargetsByIsland][tLZData[M28Map.subrefLZIslandRef]] = GetGameTimeSeconds() end
                            --Dont have any land zones that want a mobile shield, but we have mobile shields - find the closest LZ  that wants DF or IF support and has DF or IF units, and send them here; if that's this LZ, then have them go to the unit closest to the enemy in this LZ, but without assigning them
                            if iClosestLZNotWantingShieldButWithUnits or iClosestLZWithAnyCombatUnits then
                                local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][(iClosestLZNotWantingShieldButWithUnits or iClosestLZWithAnyCombatUnits)][M28Map.subrefLZTeamData][iTeam]
                                if bDebugMessages == true then LOG(sFunctionRef..': Have mobile shields to assign, closest LZ with friendly combat units that wants more units='..(iClosestLZNotWantingShieldButWithUnits or 'nil')..'; iClosestLZWithAnyCombatUnits='..(iClosestLZWithAnyCombatUnits or 'nil')..'; DOes this LZ want mobile shields='..tostring(tTeamTargetLZData[M28Map.refbLZWantsMobileShield] or false)..'; is table of units wanting shielding empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileShield]))) end
                                ShieldUnitsInLandZone(tTeamTargetLZData, tShieldsToAssign, true)
                            end
                            if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                                --cant find any land zones with friendly combat units so have nowhere to assign mobile shields; will send them all to the nearest rally point instead
                                local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2)
                                local tAmphibiousRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2, true)
                                for iUnit, oUnit in tShieldsToAssign do
                                    if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                        M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ASBckup'..iLandZone)
                                    else
                                        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'ShBckup'..iLandZone)
                                    end
                                end

                            end
                        end

                    end
                end
            end
        end
    end

    --Do we have any units in the zone without a shield, who are closer to the nearest enemy base than our current units? If so then assign a mobile shield already assigned to one of these units
    if M28Utilities.IsTableEmpty(tOriginallyAssignedMobileShields) == false then
        --First consider reassigning 1 shield if there are nearby enemy DF units and we have a unit closer to them than a current defended shield target
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield]) == false then
            local bHaveACUInZoneWithNoDFEnemies = false
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.COMMAND, tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield])) == false then bHaveACUInZoneWithNoDFEnemies = true end
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false or bHaveACUInZoneWithNoDFEnemies then
                local iClosestDistToEnemy = 10000
                local oClosestUnitWantingShieldToEnemy, iCurDist
                local bIncludeIndirect = true --v89 - changed to always include
                --if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false or (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] and GetGameTimeSeconds() - tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] <= 15) or (tLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0) > 0 then bIncludeIndirect = true end
                --Get closest enemy DF unit to our midpoint
                local oClosestEnemyToMidpoint
                local iClosestEnemyDist = 10000
                if not(bHaveACUInZoneWithNoDFEnemies) then
                    for iUnit, oUnit in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit:GetPosition())
                        if iCurDist < iClosestEnemyDist then
                            iClosestEnemyDist = iCurDist
                            oClosestEnemyToMidpoint = oUnit
                        end
                    end
                end

                if oClosestEnemyToMidpoint or bHaveACUInZoneWithNoDFEnemies then
                    local tComparisonPosition
                    if bHaveACUInZoneWithNoDFEnemies then tComparisonPosition = tLZTeamData[M28Map.reftClosestEnemyBase] else tComparisonPosition =  oClosestEnemyToMidpoint:GetPosition() end
                    local bWantToShieldACU = false

                    for iUnit, oUnit in tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield] do
                        if not(M28UnitInfo.IsUnitValid(oClosestUnitWantingShieldToEnemy[refoAssignedMobileShield])) and ((oUnit[M28UnitInfo.refiDFRange] or 0) > 12 or (bIncludeIndirect and (oUnit[M28UnitInfo.refiIndirectRange] or 0) > 12)) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tComparisonPosition)
                            if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then iCurDist = iCurDist / 1000 end
                            if iCurDist < iClosestDistToEnemy then
                                iClosestDistToEnemy = iCurDist
                                oClosestUnitWantingShieldToEnemy = oUnit
                            end
                        end
                    end
                    if oClosestUnitWantingShieldToEnemy then
                        if EntityCategoryContains(categories.COMMAND, oClosestUnitWantingShieldToEnemy.UnitId) then
                            bWantToShieldACU = true
                        end
                        local iFurthestShieldedDistToEnemy = 0
                        local oFurthestShieldToEnemy

                        if not(bWantToShieldACU) then
                            --Get the closest unit being shielded already (ignoring ACUs being shielded)
                            for iShield, oShield in tOriginallyAssignedMobileShields do

                                if not(EntityCategoryContains(categories.COMMAND, oShield[refoMobileShieldTarget].UnitId)) then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield[refoMobileShieldTarget]:GetPosition(), oClosestEnemyToMidpoint:GetPosition())
                                    if iCurDist > iFurthestShieldedDistToEnemy then
                                        iFurthestShieldedDistToEnemy = iCurDist
                                        oFurthestShieldToEnemy = oShield
                                    end
                                end
                            end
                        else
                            --Want the closest shield to the ACU
                            iFurthestShieldedDistToEnemy = 10000
                            for iShield, oShield in tOriginallyAssignedMobileShields do
                                if not(EntityCategoryContains(categories.COMMAND, oShield[refoMobileShieldTarget].UnitId)) then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oClosestUnitWantingShieldToEnemy:GetPosition())
                                    if iCurDist <     iFurthestShieldedDistToEnemy then
                                        iFurthestShieldedDistToEnemy = iCurDist
                                        oFurthestShieldToEnemy = oShield
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to reassign furthest away shield to closest shield for P'..iPlateau..'Z'..iLandZone..', iFurthestShieldedDistToEnemy='..iFurthestShieldedDistToEnemy..'; iClosestDistToEnemy='..iClosestDistToEnemy..'; oFurthestShieldToEnemy='..(oFurthestShieldToEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oFurthestShieldToEnemy) or 'nil')..'; oClosestUnitWantingShieldToEnemy='..(oClosestUnitWantingShieldToEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestUnitWantingShieldToEnemy) or 'nil')..'; Does closest unit have a valid assigned shield='..tostring(M28UnitInfo.IsUnitValid(oClosestUnitWantingShieldToEnemy[refoAssignedMobileShield]))) end
                        if oFurthestShieldToEnemy and (bWantToShieldACU or iFurthestShieldedDistToEnemy - iClosestDistToEnemy >= 3) then
                            --Switch shields
                            if bDebugMessages == true then LOG(sFunctionRef..': Will switch shields, old target='..(oFurthestShieldToEnemy[refoMobileShieldTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oFurthestShieldToEnemy[refoMobileShieldTarget]) or 'nil')..'; bWantToShieldACU='..tostring(bWantToShieldACU)) end
                            ClearCurrentShieldTarget(oFurthestShieldToEnemy)
                            RecordMobileShieldAgainstTarget(oFurthestShieldToEnemy, oClosestUnitWantingShieldToEnemy)
                        end
                    end
                end
            end
        end
        --Now move all shields to their designated unit to guard
        for iShield, oShield in tOriginallyAssignedMobileShields do
            --make sure we are behind the target
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and get shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' to move behind the shield target '..oShield[refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield[refoMobileShieldTarget])..'; Shield position='..repru(oShield:GetPosition())..'; Target last order position='..repru(oShield[refoMobileShieldTarget][M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition])) end
            MoveToShieldTarget(oShield, tEnemyBase, tLZTeamData, tEnemyDFUnits, tRallyPoint)
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageMobileStealthsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tMobileStealths, iEnemyOmniCoverage)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMobileStealthsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then
        local iEnemyOmniCoverage = M28Conditions.GetEnemyOmniCoverageOfZone(iPlateau, iLandZone, iTeam)
        LOG(sFunctionRef..': Start of code, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Size of tMobileStealths='..table.getn(tMobileStealths)..'; iEnemyOmniCoverage='..iEnemyOmniCoverage)
    end

    local tStealthsToAssign = {}
    local tEnemyBase = tLZTeamData[M28Map.reftClosestEnemyBase]
    if M28Utilities.IsTableEmpty(tEnemyBase) then
        M28Utilities.ErrorHandler('Couldnt find enemy base, will try backup approach')
        local iCurDist
        local iClosestDist = 100000
        local oClosestBrain
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestBrain = oBrain
            end
        end
        tEnemyBase = M28Map.PlayerStartPoints[oClosestBrain:GetArmyIndex()]
    end
    local tEnemyDFUnits
    local tRallyPoint
    if (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 200 then
        tEnemyDFUnits = EntityCategoryFilterDown(categories.DIRECTFIRE, tLZTeamData[M28Map.subrefTEnemyUnits])
        tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 1, false)
    end

    local tOriginallyAssignedMobileStealths = {}

    --If enemy has omni coverage and we dont have units wanting mobile stealth in this zone, then clear any mobile stealths
    if iEnemyOmniCoverage >= 40 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth]) then
        for iUnit, oUnit in tMobileStealths do
            if oUnit[refoMobileStealthTarget] then
                if oUnit[refoMobileStealthTarget][refoAssignedMobileStealth] then oUnit[refoMobileStealthTarget][refoAssignedMobileStealth] = nil end
                oUnit[refoMobileStealthTarget] = nil
            end
            table.insert(tStealthsToAssign, oUnit)
        end
    else
        for iUnit, oUnit in tMobileStealths do
            if oUnit[refoMobileStealthTarget] and M28UnitInfo.IsUnitValid(oUnit[refoMobileStealthTarget]) then
                table.insert(tOriginallyAssignedMobileStealths, oUnit)

            else
                table.insert(tStealthsToAssign, oUnit)
            end
        end
    end


    if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
        --Stealth units in this zone first
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth]) == false then
            StealthUnitsInLandZone(tLZTeamData, tStealthsToAssign)
        end
        if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
            --Cycle through every land zone and record priority ones to Stealth
            if bDebugMessages == true then LOG(sFunctionRef..': Will give orders to tStealthsToAssign, size of table='..table.getn(tStealthsToAssign)) end
            local tiClosestLZWithNearbyThreat = {}
            local iClosestLZWithNoThreat
            local iClosestLZNotWantingStealthButWithUnits
            local iClosestLZWithAnyCombatUnits
            if tLZTeamData[M28Map.subrefbLZWantsSupport] and not(tLZTeamData[M28Map.refbLZWantsMobileStealth]) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedCombatUnits]) == false then iClosestLZNotWantingStealthButWithUnits = iLandZone end
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                for iEntry, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                    local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                    if tTeamTargetLZData[M28Map.refbLZWantsMobileStealth] then
                        if tTeamTargetLZData[M28Map.refiEnemyAirToGroundThreat] > 0 or tTeamTargetLZData[M28Map.subrefTThreatEnemyCombatTotal] >= 40 then
                            StealthUnitsInLandZone(tTeamTargetLZData, tStealthsToAssign)
                            if M28Utilities.IsTableEmpty(tStealthsToAssign) then break end
                        elseif M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefTEnemyUnits]) == false or tTeamTargetLZData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                            table.insert(tiClosestLZWithNearbyThreat, tPathingDetails[M28Map.subrefLZNumber])
                        elseif not(iClosestLZWithNoThreat) then iClosestLZWithNoThreat = tPathingDetails[M28Map.subrefLZNumber]
                        end
                    elseif not(iClosestLZNotWantingStealthButWithUnits) then
                        if tTeamTargetLZData[M28Map.subrefbLZWantsSupport] and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) == false then iClosestLZNotWantingStealthButWithUnits = tPathingDetails[M28Map.subrefLZNumber] end
                        if not(iClosestLZWithAnyCombatUnits) and M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.subrefLZTAlliedCombatUnits]) == false then iClosestLZWithAnyCombatUnits = tPathingDetails[M28Map.subrefLZNumber] end
                    end

                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking other zones we can path to for units wanting Stealthing, is tStealthsToAssign empty='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; Is M28Utilities.IsTableEmpty(tiClosestLZWithNearbyThreat) empty='..tostring(M28Utilities.IsTableEmpty(tiClosestLZWithNearbyThreat))) end
            if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                if M28Utilities.IsTableEmpty(tiClosestLZWithNearbyThreat) == false then
                    for _, iTargetLZ in  tiClosestLZWithNearbyThreat do
                        local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLZ][M28Map.subrefLZTeamData][iTeam]
                        StealthUnitsInLandZone(tTeamTargetLZData, tStealthsToAssign)
                        if M28Utilities.IsTableEmpty(tStealthsToAssign) then break end
                    end
                end
                if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                    if iClosestLZWithNoThreat then
                        local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZWithNoThreat][M28Map.subrefLZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Have mobile Stealths to assign, closest LZ='..iClosestLZWithNoThreat..'; DOes this LZ want mobile Stealths='..tostring(tTeamTargetLZData[M28Map.refbLZWantsMobileStealth] or false)..'; is table of units wanting Stealthing empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileStealth]))) end
                        StealthUnitsInLandZone(tTeamTargetLZData, tStealthsToAssign)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is tStealthsToAssign empty after checking for closest LZ with no threat='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; iClosestLZNotWantingStealthButWithUnits='..(iClosestLZNotWantingStealthButWithUnits or 'nil')) end
                    if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                        M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoStealthTargetsByPlateau][iPlateau] = GetGameTimeSeconds()
                        --Dont have any land zones that want a mobile Stealth, but we have mobile Stealths - find the closest LZ  that wants DF or IF support and has DF or IF units, and send them here; if that's this LZ, then have them go to the unit closest to the enemy in this LZ, but without assigning them
                        if iClosestLZNotWantingStealthButWithUnits or iClosestLZWithAnyCombatUnits then
                            local tTeamTargetLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][(iClosestLZNotWantingStealthButWithUnits or iClosestLZWithAnyCombatUnits)][M28Map.subrefLZTeamData][iTeam]
                            if bDebugMessages == true then LOG(sFunctionRef..': Have mobile Stealths to assign, closest LZ with friendly combat units that wants more units='..(iClosestLZNotWantingStealthButWithUnits or 'nil')..'; iClosestLZWithAnyCombatUnits='..(iClosestLZWithAnyCombatUnits or 'nil')..'; DOes this LZ want mobile Stealths='..tostring(tTeamTargetLZData[M28Map.refbLZWantsMobileStealth] or false)..'; is table of units wanting Stealthing empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetLZData[M28Map.reftoLZUnitsWantingMobileStealth]))) end
                            StealthUnitsInLandZone(tTeamTargetLZData, tStealthsToAssign, true)
                        end
                        if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                            --No targets for mobile stealth
                            if bDebugMessages == true then LOG(sFunctionRef..': couldnt find any land zones with friendly combat units so have nowhere to assign mobile Stealths; will send them all to the nearest rally point instead') end
                            local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2)
                            for iUnit, oUnit in tStealthsToAssign do
                                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'StBckup'..iLandZone)
                            end

                        end

                    end
                end
            end
        end
    end

    if M28Utilities.IsTableEmpty(tOriginallyAssignedMobileStealths) == false then
        --First consider reassigning 1 Stealth if there are nearby enemy DF units and we have a unit closer to them than a current defended Stealth target
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth]) == false and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
            local iClosestDistToEnemy = 10000
            local oClosestUnitWantingStealthToEnemy, iCurDist
            local bIncludeIndirect = true --v89 - changed to always include
            --if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false or (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrStealth] and GetGameTimeSeconds() - tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrStealth] <= 15) or (tLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0) > 0 then bIncludeIndirect = true end
            --Get closest enemy DF unit to our midpoint
            local oClosestEnemyToMidpoint
            local iClosestEnemyDist = 10000
            for iUnit, oUnit in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit:GetPosition())
                if iCurDist < iClosestEnemyDist then
                    iClosestEnemyDist = iCurDist
                    oClosestEnemyToMidpoint = oUnit
                end
            end

            if oClosestEnemyToMidpoint then
                for iUnit, oUnit in tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth] do
                    if not(M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileStealth])) and ((oUnit[M28UnitInfo.refiDFRange] or 0) > 12 or (bIncludeIndirect and (oUnit[M28UnitInfo.refiIndirectRange] or 0) > 12)) then
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestEnemyToMidpoint:GetPosition())
                        if iCurDist < iClosestDistToEnemy then
                            iClosestDistToEnemy = iCurDist
                            oClosestUnitWantingStealthToEnemy = oUnit
                        end
                    end
                end
                if oClosestUnitWantingStealthToEnemy then
                    --Get the closest unit being Stealthed already (ignoring ACUs being Stealthed)
                    local iFurthestStealthedDistToEnemy = 0
                    local oFurthestStealthToEnemy


                    for iStealth, oStealth in tOriginallyAssignedMobileStealths do

                        if not(EntityCategoryContains(categories.COMMAND + categories.EXPERIMENTAL, oStealth[refoMobileStealthTarget].UnitId)) then --never reassign an ACU or experimental mobile stealth
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oStealth[refoMobileStealthTarget]:GetPosition(), oClosestEnemyToMidpoint:GetPosition())
                            if iCurDist > iFurthestStealthedDistToEnemy then
                                iFurthestStealthedDistToEnemy = iCurDist
                                oFurthestStealthToEnemy = oStealth
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to reassign furthest away Stealth to closest Stealth for P'..iPlateau..'Z'..iLandZone..', iFurthestStealthedDistToEnemy='..iFurthestStealthedDistToEnemy..'; iClosestDistToEnemy='..iClosestDistToEnemy..'; oFurthestStealthToEnemy='..(oFurthestStealthToEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oFurthestStealthToEnemy) or 'nil')..'; oClosestUnitWantingStealthToEnemy='..(oClosestUnitWantingStealthToEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestUnitWantingStealthToEnemy) or 'nil')) end
                    if iFurthestStealthedDistToEnemy and iFurthestStealthedDistToEnemy - iClosestDistToEnemy >= 3 then
                        --Switch Stealths
                        if bDebugMessages == true then LOG(sFunctionRef..': Will switch Stealths, old target='..oFurthestStealthToEnemy[refoMobileStealthTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oFurthestStealthToEnemy[refoMobileStealthTarget])) end
                        oFurthestStealthToEnemy[refoMobileStealthTarget][refoAssignedMobileStealth] = nil
                        oFurthestStealthToEnemy[refoMobileStealthTarget] = oClosestUnitWantingStealthToEnemy
                        oClosestUnitWantingStealthToEnemy[refoAssignedMobileStealth] = oFurthestStealthToEnemy
                    end
                end
            end
        end
        --Now move all Stealths to their designated unit to guard
        for iStealth, oStealth in tOriginallyAssignedMobileStealths do
            --make sure we are behind the target
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and get Stealth '..oStealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth)..' to move behind the Stealth target '..oStealth[refoMobileStealthTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth[refoMobileStealthTarget])..'; Stealth position='..repru(oStealth:GetPosition())..'; Target last order position='..repru(oStealth[refoMobileStealthTarget][M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition])) end
            MoveToStealthTarget(oStealth, tEnemyBase, tLZTeamData, tEnemyDFUnits, tRallyPoint)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageMAAInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableMAA)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMAAInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2) --Get a LZ up to 3 land zones away to retreat to (i.e. will pick rally point and then move 2 towards it)
    local tAmphibiousRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2, true)

    --First split the MAA into those that need to run (due to being in range of DF units) and those that can advance
    local tMAAToAdvance = {}
    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, is table of nearest DF enemies empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]))..'; P='..iPlateau..'; Zone='..iLandZone) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) then
        --No DF enemies so treat all MAA as being available
        tMAAToAdvance = tAvailableMAA
        if bDebugMessages == true then LOG(sFunctionRef..': No DF enemies so will consider advancing with all MAA') end
    else
        local iRunThreshold = 14
        if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
            iRunThreshold = 10
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false then
                iRunThreshold = 7
            end
        end
        local bMovingTowardsEnemy, iAngleToRally, iAngleToNearestUnit, bAmphibiousUnit
        local bCampaignMap = M28Map.bIsCampaignMap
        if bDebugMessages == true then
            LOG(sFunctionRef..': Will list out every unit in reftoNearestDFEnemies')
            for iUnit, oUnit in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                LOG(sFunctionRef..': Enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
            end
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                    LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; Is table of DF enemies empty='..tostring(M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftoNearestDFEnemies])))
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                        for iUnit, oUnit in tAdjLZTeamData[M28Map.reftoNearestDFEnemies] do
                            LOG(sFunctionRef..': Adj LZ enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iRunThreshold='..iRunThreshold..'; Enemy air to ground threat='..(tLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 'nil')) end
        for iUnit, oUnit in tAvailableMAA do
            --Run if within 14 of being in range of enemy direct fire
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if friendly unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is in range of an enemy unit, is close to enemy='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], iRunThreshold, iTeam, true                    , nil,                  nil,                                oUnit))) end
            --CloseToEnemyUnit(tStartPosition, tUnitsToCheck,                           iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
            if M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], iRunThreshold, iTeam, true                    , nil,                  nil,                                oUnit) then
                if bDebugMessages == true then
                    LOG(sFunctionRef..': MAA '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is too close to DF enemy, iRunThreshold='..iRunThreshold..'; will run back; will list out enemy units and distance to us in a moment')
                    for iEnemy, oEnemy in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                        LOG('oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; DF r ange='..(oEnemy[M28UnitInfo.refiDFRange] or 'nil')..'; Dist to this MAA unit='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Actual distance using actual position='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemy:GetPosition()))
                    end
                end
                --Does moving towards the rally point take us closer to the enemy?
                bMovingTowardsEnemy = false
                bAmphibiousUnit = EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId)
                local tTempRetreatLocation
                if oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] then
                    local tCurRallyPoint
                    if bAmphibiousUnit then
                        tCurRallyPoint = tAmphibiousRallyPoint
                    else
                        tCurRallyPoint = tRallyPoint
                    end
                    iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)
                    iAngleToNearestUnit = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())
                    if M28Utilities.GetAngleDifference(iAngleToRally, iAngleToNearestUnit) <= 45 then
                        bMovingTowardsEnemy = true
                        --Can we move in the opposite direction to the enemy?
                        tTempRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToNearestUnit + 180, 20, true, false, bCampaignMap)
                        if M28Utilities.IsTableEmpty(tTempRetreatLocation) == false then
                            if not(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tTempRetreatLocation) == tLZData[M28Map.subrefLZIslandRef]) then
                                tTempRetreatLocation = nil
                            end
                        end

                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': MAA will retreat') end
                if M28Utilities.IsTableEmpty(tTempRetreatLocation) == false then
                    M28Orders.IssueTrackedMove(oUnit, tTempRetreatLocation, 6, 'ORun'..iLandZone)
                elseif bAmphibiousUnit then
                    M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ARun'..iLandZone)
                else
                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'Run'..iLandZone)
                end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Will treat MAA as not in danger and consider advancing with it') end
                table.insert(tMAAToAdvance, oUnit)
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of tMAAToAdvance empty='..tostring(M28Utilities.IsTableEmpty(tMAAToAdvance))) end


    --If enemy has air units in this zone then send the MAA to advance units towards it, but avoid enemy land units
    if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Number of MAA units to advance='..table.getn(tMAAToAdvance)..'; Is table of enemy air units for this LZ '..iLandZone..' empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]))) end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) == false then
            --Move towards the nearest enemy air unit to the LZ midpoint
            local oNearestEnemyToMidpoint
            local iClosestDist = 100000
            local iCurDist
            --Get closest enemy air unit
            for iUnit, oUnit in tLZTeamData[M28Map.reftLZEnemyAirUnits] do
                iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                if iCurDist < iClosestDist then
                    iClosestDist = iCurDist
                    oNearestEnemyToMidpoint = oUnit
                end
            end

            --Move towards the air unit
            local tOrderPosition = oNearestEnemyToMidpoint:GetPosition()
            if bDebugMessages == true then
                LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..' Will order every MAA to move to oNearestEnemyToMidpoint='..oNearestEnemyToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint)..' at position '..repru(oNearestEnemyToMidpoint:GetPosition()))
                M28Utilities.DrawLocation(tOrderPosition)
            end
            local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2, false)

            for iUnit, oUnit in tMAAToAdvance do
                --Below is redundant so commented out, as already doing close to enemy check above
                --CloseToEnemyUnit(tStartPosition,       tUnitsToCheck,              iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                --[[if M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 6, iTeam, true,               nil,                        nil,                                nil,                                    nil,                                    false) then
                    M28Orders.IssueTrackedAggressiveMove(oUnit, tRallyPoint, 7, false, 'MmaAR' )
                else--]]
                M28Orders.IssueTrackedMove(oUnit, tOrderPosition, 7, false, 'MNA')
                --end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will do reprs of orders of the first unit in tMAAToAdvance, '..tMAAToAdvance[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tMAAToAdvance[1])..': '..reprs(tMAAToAdvance[1][M28Orders.reftiLastOrders])) end

        else
            --Enemy doesnt have any air units, so consider if there are other land zones we want to support with MAA
            local tLZToReinforceModDistance = {}
            local iCurModDist
            local bSignificantAdjacentDanger = false
            local iMinCombatIfSignifDanger = 0
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                --If there are enemies in an adjacent LZ, then be more cautious with where to send MAA
                if tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] > 0 then
                    bSignificantAdjacentDanger = true
                elseif tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                    local iEnemyThreat = math.max(0, (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) - (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0))
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                            local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                            iEnemyThreat = iEnemyThreat + math.max(0, (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) - (tAdjLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0))
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iEnemyThreat (i.e. net adjacent combat threat)='..iEnemyThreat..'; This zone ally MAA='..tLZTeamData[M28Map.subrefLZThreatAllyMAA]) end
                    if iEnemyThreat > math.min(800, (tLZTeamData[M28Map.subrefLZThreatAllyMAA] or 0) * 0.04) then
                        bSignificantAdjacentDanger = true
                        iMinCombatIfSignifDanger = math.min(iEnemyThreat * 0.2, (tLZTeamData[M28Map.subrefLZThreatAllyMAA] or 0) * 0.1, 800)
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': About to consider all other adjacent land zones to iLandZone '..iLandZone..', reprs of tLZData[M28Map.subrefLZPathingToOtherLandZones]='..reprs(tLZData[M28Map.subrefLZPathingToOtherLandZones])..'; Size of tMAAToAdvance='..table.getn(tMAAToAdvance)..'; bSignificantAdjacentDanger='..tostring(bSignificantAdjacentDanger)..'; iMinCombatIfSignifDanger='..iMinCombatIfSignifDanger) end
                for iEntry, tPathDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                    local tAltTeamLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to send MAA to assist alt LZ '..tPathDetails[M28Map.subrefLZNumber]..'; tAltTeamLZData[M28Map.subrefLZMAAThreatWanted]='..tAltTeamLZData[M28Map.subrefLZMAAThreatWanted]..'; tAltTeamLZData[M28Map.subrefLZThreatAllyGroundAA]='..tAltTeamLZData[M28Map.subrefLZThreatAllyGroundAA]..'; Air to ground threat in this alt LZ='..tAltTeamLZData[M28Map.refiEnemyAirToGroundThreat]) end
                    if tAltTeamLZData[M28Map.subrefLZMAAThreatWanted] > tAltTeamLZData[M28Map.subrefLZThreatAllyGroundAA] then
                        if not(bSignificantAdjacentDanger) or (tLZTeamData[M28Map.subrefLZSValue] > 30 or tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > math.min(iMinCombatIfSignifDanger, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal])) then
                            iCurModDist = tPathDetails[M28Map.subrefLZTravelDist]
                            if tAltTeamLZData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                                iCurModDist = iCurModDist - 200
                                if tAltTeamLZData[M28Map.subrefLZTThreatAllyCombatTotal] > 0 then iCurModDist = iCurModDist - 35 end
                            elseif (tAltTeamLZData[M28Map.refiEnemyAirOtherThreat] + tLZTeamData[M28Map.refiEnemyAirAAThreat]) > 45 then iCurModDist = iCurModDist - 100
                            end
                            if M28Utilities.IsTableEmpty(tAltTeamLZData[M28Map.subreftoLZOrWZAlliedUnits]) then iCurModDist = iCurModDist + 100 end
                            if tAltTeamLZData[M28Map.subrefTThreatEnemyCombatTotal] > 6 then
                                iCurModDist = iCurModDist + 50
                                if tAltTeamLZData[M28Map.subrefLZTThreatAllyCombatTotal] == 0 then
                                    iCurModDist = iCurModDist + 150
                                elseif tAltTeamLZData[M28Map.subrefTThreatEnemyCombatTotal] > tAltTeamLZData[M28Map.subrefLZTThreatAllyCombatTotal] then
                                    iCurModDist = iCurModDist + 75
                                end
                                --tAltTeamLZData[M28Map.subrefTThreatEnemyCombatTotal] > subrefLZTThreatAllyCombatTotal
                            end
                            tLZToReinforceModDistance[tPathDetails[M28Map.subrefLZNumber]] = iCurModDist
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tLZToReinforceModDistance) == false then
                    for iLZ, iModDist in M28Utilities.SortTableByValue(tLZToReinforceModDistance, false) do
                        if bDebugMessages == true then LOG(sFunctionRef..': About to send MAA to support zone '..iLZ..'; iModDist='..iModDist..'; size of tMAAToAdvance='..table.getn(tMAAToAdvance)) end
                        SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, iLZ)
                        if M28Utilities.IsTableEmpty(tMAAToAdvance) then
                            break
                        end
                    end
                end

                if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': Still ahve MAA left over, will consider ot her zones to advance to') end
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                        for iEntry, tPathDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                            local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                            if not(tAltLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tAltLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false and tAltLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < tAltLZTeamData[M28Map.subrefLZTValue] * 0.1 then
                                if bDebugMessages == true then LOG(sFunctionRef..': sending MAA to support other LZ='..tPathDetails[M28Map.subrefLZNumber]..'; Size of MAA to advance before sending='..table.getn(tMAAToAdvance)) end
                                SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, tPathDetails[M28Map.subrefLZNumber])
                                if M28Utilities.IsTableEmpty(tMAAToAdvance) then break end
                            end
                        end
                    end
                end
            end



            --Do we have any MAA remaining after sending MAA to any LZ wanting support?
            if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                --Is there an adjacent water zone that wants MAA support?
                if bDebugMessages == true then LOG(sFunctionRef..': Checking if have adjacent water zones, in which case will see if any of them want MAA; is table of adj water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                    local tHoverMAA = EntityCategoryFilterDown(categories.HOVER, tMAAToAdvance)
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of hover MAA empty='..tostring(M28Utilities.IsTableEmpty(tHoverMAA))) end
                    if M28Utilities.IsTableEmpty(tHoverMAA) == false then
                        local iPond, iAdjWZ
                        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                            iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                            iPond = M28Map.tiPondByWaterZone[iAdjWZ]
                            local tAltWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjWZ='..iAdjWZ..'; iPond='..iPond..'; MAA threat wanted='..tAltWZTeamData[M28Map.subrefWZMAAThreatWanted]) end
                            if tAltWZTeamData[M28Map.subrefWZMAAThreatWanted] > math.max(50, tAltWZTeamData[M28Map.subrefWZThreatAlliedAA]) then
                                --Only consider if either no enemy threat, or we have an allied combat threat
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy combat total='..tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Ally combat total='..tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]) end
                                if tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < 10 or tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] > 10 then
                                    SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, iAdjWZ, nil, true, tHoverMAA)
                                    if M28Utilities.IsTableEmpty(tHoverMAA) then break end
                                end
                            end
                        end


                        --Do we still have hover MAA available and have high priority water zoens wanting MAA?
                        if M28Utilities.IsTableEmpty(tHoverMAA) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': Checking list of centrally flagged WZ to see if they want MAA, is table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau]))..'; repru of M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau]='..repru(M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau])) end
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau]) == false then
                                local iDistThreshold = math.max(250, M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase])) * 0.8
                                local iThresholdAdjust
                                for iAdjWZ, bWantsSupport in M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau] do
                                    --If waterzone isn't too far from us then support it (based on simple straight line)
                                    iPond = M28Map.tiPondByWaterZone[iAdjWZ]
                                    local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
                                    iThresholdAdjust = 0
                                    if tAltWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZMAAThreatWanted] >= 2000 and tAltWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefLZTThreatAllyCombatTotal] >= 12000 then iThresholdAdjust = 100 end
                                    if bDebugMessages == true then
                                        --[[if not(iAdjWZ) then LOG('iAdjWZ is nil') end
                                        if not(iDistThreshold) then LOG('iDistThreshold is nil') end
                                        LOG('tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint]))
                                        LOG('tAltWZData[M28Map.subrefMidpoint]='..repru(tAltWZData[M28Map.subrefMidpoint])..'; iAdjWZ='..iAdjWZ..'; iPond='..(iPond or 'nil'))--]]
                                        LOG(sFunctionRef..': Considering WZ further away flagged as wanting MAA, iAdjWZ='..iAdjWZ..'; iDistThreshold='..iDistThreshold..'; Dist to WZ='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tAltWZData[M28Map.subrefMidpoint])..'; iThresholdAdjust='..iThresholdAdjust)
                                    end
                                    if M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tAltWZData[M28Map.subrefMidpoint]) <= iDistThreshold + iThresholdAdjust then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and send MAA to this water zone') end
                                        SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, iAdjWZ, nil, true, tHoverMAA)
                                        if M28Utilities.IsTableEmpty(tHoverMAA) then break end
                                    end
                                end
                            end
                            --Consider sending MAA to all zones (i.e. land and water, and other islands)
                            M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint])
                            if M28Utilities.IsTableEmpty(tHoverMAA) == false and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                                local iZoneMAAWanted
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering sending MAA to further away islands') end
                                for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                                    local tAltLZOrWZData, tAltLZOrWZTeamData
                                    if tSubtable[M28Map.subrefbIsWaterZone] then
                                        tAltLZOrWZData = M28Map.tPondDetails[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                        tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                                        iZoneMAAWanted = tAltLZOrWZTeamData[M28Map.subrefWZMAAThreatWanted]
                                    else
                                        if tSubtable[M28Map.subrefiPlateauOrPond] == iPlateau then
                                            tAltLZOrWZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                            tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                                            iZoneMAAWanted = tAltLZOrWZTeamData[M28Map.subrefLZMAAThreatWanted]
                                        else
                                            iZoneMAAWanted = 0
                                        end
                                    end
                                    if iZoneMAAWanted >= 5 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': About to send MAA to support LZ or WZ ref='..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..'; Is water zone='..tostring(tSubtable[M28Map.subrefbIsWaterZone])..'; iZoneMAAWanted='..iZoneMAAWanted..'; iPlateau='..iPlateau..'; Is table of tHoverMAA empty='..tostring(M28Utilities.IsTableEmpty(tHoverMAA))) end
                                        SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, tSubtable[M28Map.subrefiLandOrWaterZoneRef], 1.5, tSubtable[M28Map.subrefbIsWaterZone], tHoverMAA)
                                        if M28Utilities.IsTableEmpty(tHoverMAA) then break end
                                    end
                                end
                            end
                        end
                    end
                end


                --If sitll have MAA available, then send to existing land zones with a greater factor
                if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                    local iMAALZToSupport
                    local iHighestAirValue = 0
                    local iHighestAirLZ
                    local iCurAirValue
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                        for iEntry, tPathDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering which adjacent LZ has the biggest air threat for leftover MAA, cur entry=LZ'..tPathDetails[M28Map.subrefLZNumber]..'; MAA threat wanted='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZMAAThreatWanted]..'; GroundAA have already='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatAllyGroundAA]..'; Enemy air to ground threat='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.refiEnemyAirToGroundThreat]..'; Air othre threat='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.refiEnemyAirOtherThreat]..'; Is table of enemy air empty for this alt LZ='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.reftLZEnemyAirUnits]))..' iHighestAirValue so far='..iHighestAirValue) end
                            if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZMAAThreatWanted] > M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatAllyGroundAA] then
                                local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                                iCurAirValue = tAltLZTeamData[M28Map.subrefLZMAAThreatWanted] * 0.01 + tAltLZTeamData[M28Map.refiEnemyAirToGroundThreat] + (tAltLZTeamData[M28Map.refiEnemyAirOtherThreat] + tAltLZTeamData[M28Map.refiEnemyAirAAThreat]) * 0.1
                                if iCurAirValue > iHighestAirValue then
                                    iHighestAirValue = iCurAirValue
                                    iHighestAirLZ = tPathDetails[M28Map.subrefLZNumber]
                                end
                            end
                        end
                    end
                    iMAALZToSupport = iHighestAirLZ


                    if bDebugMessages == true then LOG(sFunctionRef..': Do any adjacent zones want support? iMAALZToSupport='..(iMAALZToSupport or 'nil')) end
                    if iMAALZToSupport then
                        local tTargetPosition = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iMAALZToSupport][M28Map.subrefMidpoint]
                        for iUnit, oUnit in tMAAToAdvance do
                            M28Orders.IssueTrackedMove(oUnit, tTargetPosition, 10, false, 'MVBLZ'..iMAALZToSupport)
                        end
                    end
                    if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then --Go back through each LZ assigning 3 times what it would normally want in MAA
                        local iFactorAdjust
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                            if iMinCombatIfSignifDanger == 0 then iMinCombatIfSignifDanger = 10 end
                            for iEntry, tPathDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                                local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                                if (not(tAltLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) or tAltLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > iMinCombatIfSignifDanger or tAltLZTeamData[M28Map.subrefLZSValue] > 10) then
                                    iFactorAdjust = 2
                                    if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then iFactorAdjust = 3 end
                                    SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, tPathDetails[M28Map.subrefLZNumber], iFactorAdjust)
                                end
                            end
                        end
                    end
                end
            end

            if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Still have spare MAA, tLZData[M28Map.subrefLZIslandRef]='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iPlateau='..(iPlateau or 'nil')) end
                --Only flag that we have no MAA targets for a core base if we have 10+ MAA, including T2+ MAA, with no target
                local bEnoughMAAInZone = false
                if tLZTeamData[M28Map.subrefLZbCoreBase] then
                    local tT2PlusMAAToAdvance = EntityCategoryFilterDown(categories.TECH2 + categories.TECH3, tMAAToAdvance)
                    if table.getn(tT2PlusMAAToAdvance) >= 8 then
                        bEnoughMAAInZone = true
                    end
                elseif tLZTeamData[M28Map.subrefLZCoreExpansion] then
                    if table.getn(tMAAToAdvance) >= 2 then
                        bEnoughMAAInZone = true
                    end
                else
                    bEnoughMAAInZone = true
                end
                if bEnoughMAAInZone then
                    if not(tLZData[M28Map.subrefLZIslandRef]) then tLZData[M28Map.subrefLZIslandRef] = NavUtils.GetLabel(M28Map.refPathingTypeHover, tLZData[M28Map.subrefMidpoint]) end
                    if tLZData[M28Map.subrefLZIslandRef] then
                        if not(M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoMAATargetsByIsland]) then M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoMAATargetsByIsland] = {} end
                        M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoMAATargetsByIsland][tLZData[M28Map.subrefLZIslandRef]] = GetGameTimeSeconds()
                    end
                end
                --Go to rally point instead
                for iUnit, oUnit in tMAAToAdvance do
                    if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                        M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 10, false, 'ABRtr'..iLandZone)
                    else
                        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 10, false, 'BRtr'..iLandZone)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageRASSACUsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tSACUs)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageRASSACUsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Manages SACUs to be assigned engineer type duties (wont always be RAS SACUs - e.g. might be LOUD where we want SACUs to build experimentals
    --Gameender duty - have RAS SACUs assist with building a gameender/t3 arti/novax in the zone and associated shielding, if we have an active template
    local bProceed = true
    if bDebugMessages == true then LOG(sFunctionRef..': Start of RAS code, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Time='..GetGameTimeSeconds()..'; Time since last wanted SACU for exp='..(GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeLastWantSACUForExp] or 0))) end
    function BuildCategoryWithSACUs(iCategoryWanted, iOptionalFactionWanted, toSACUByFaction)
        --toSACUByFaction - only needed if iOptionalFactionWanted is specified
        local oPrimaryEngineer
        if iOptionalFactionWanted then
            oPrimaryEngineer = toSACUByFaction[iOptionalFactionWanted][1]
        else
            oPrimaryEngineer = tSACUs[1]
        end

        if oPrimaryEngineer then
            local aiBrain = oPrimaryEngineer:GetAIBrain()
            local sBlueprint, tBuildLocation = M28Engineer.GetBlueprintAndLocationToBuild(aiBrain, oPrimaryEngineer, M28Engineer.refActionBuildExperimental, iCategoryWanted, 100, nil, nil,                                false,                          nil,                nil,                                false, tLZData, tLZTeamData)

            --Update SACU table to remove any of the desired faction who can be given other orders
            if bDebugMessages == true then LOG(sFunctionRef..': sBlueprint='..(sBlueprint or 'nil')..'; tBuildLocation='..repru(tBuildLocation or {})..'; oPrimaryEngineer='..(oPrimaryEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oPrimaryEngineer) or 'nil')) end
            if sBlueprint and tBuildLocation then
                local toBuilders
                if iOptionalFactionWanted then
                    for iCurEntry = table.getn(tSACUs), 1, -1 do
                        if M28UnitInfo.GetUnitFaction(tSACUs[iCurEntry]) == iOptionalFactionWanted then
                            table.remove(tSACUs, iCurEntry)
                        end
                    end
                    toBuilders = toSACUByFaction[iOptionalFactionWanted]
                else
                    toBuilders = tSACUs
                end

                --Build with all the SACUs wanted
                if M28Utilities.IsTableEmpty(toBuilders) == false then
                    bProceed = false
                    if iOptionalFactionWanted and M28Utilities.IsTableEmpty(tSACUs) == false then bProceed = true end
                    for iSACU, oSACU in toBuilders do
                        local tMoveLocation = M28Engineer.GetLocationToMoveForConstruction(oSACU, tBuildLocation, sBlueprint, 0, false)
                        if tMoveLocation then
                            if bDebugMessages == true then LOG(sFunctionRef..': Telling oSACU '..oSACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSACU)..' to move to '..repru(tMoveLocation)..' and then build '..sBlueprint..' at location '..repru(tBuildLocation)) end
                            M28Orders.IssueTrackedMoveAndBuild(oSACU, tBuildLocation, sBlueprint, tMoveLocation, 1, false, 'SACUExpMBld')
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Telling engineer '..oSACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSACU)..' to build '..sBlueprint..' at build location '..repru(tBuildLocation)) end
                            M28Orders.IssueTrackedBuild(oSACU, tBuildLocation, sBlueprint, false, 'SACUExpBld')
                        end
                        --M28Engineer.TrackEngineerAction(oSACU, M28Engineer.refActionBuildExperimental, true, 1, nil, nil, false)
                    end
                end
            end
        end
    end

    --If have any SACUs without RAS upgrade that could get it, then get RAS upgrade, provided no enemies in the zone
    if not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and tLZTeamData[M28Map.refiEnemyAirToGroundThreat] then
        local tSACUsToUpgrade = {}
        local tSACUsUpgrading = {}
        local bFlaggedForBuildPower = false --If we have flagged an SACU to get a build power upgrade, then wont flag any more this cycle
        local bWantBuildPower = false
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.6 and (GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] or 0)) <= 5 or not(M28Conditions.HaveLowPower(iTeam)) then
            bWantBuildPower = true
        end
        local sBestBuildPowerEnhancement
        local iBestBuildPowerRate
        for iSACU = table.getn(tSACUs), 1, -1 do
            local oSACU = tSACUs[iSACU]
            if oSACU:IsUnitState('Upgrading') then
                table.insert(tSACUsUpgrading, oSACU)
                table.remove(tSACUs, iSACU)
            elseif oSACU[M28UnitInfo.refbSpecialMicroActive] and oSACU:IsUnitState('Moving') then
                --Do nothing - e.g. SACU might be rolling off of factory, or dodging a shot
            else
                if oSACU[M28ACU.reftPreferredUpgrades] == nil or (bWantBuildPower and not(oSACU[refbConsideredPotentialBPUpgrade])) then
                    --Check if can get RAS upgrade
                    local tbSlotsInUse = {}
                    oSACU[M28ACU.reftPreferredUpgrades] = {}
                    if bWantBuildPower then
                        sBestBuildPowerEnhancement = nil
                        iBestBuildPowerRate = (oSACU:GetBlueprint().Economy.BuildRate or 0)
                    end
                    local tUpgradesAvailable = oSACU:GetBlueprint().Enhancements
                    if M28Utilities.IsTableEmpty(tUpgradesAvailable) == false then
                        local iBestEcoRate = 0
                        local sBestEcoEnhancement, iCurEcoRate
                        for sEnhancement, tEnhancement in tUpgradesAvailable do
                            if oSACU:HasEnhancement(sEnhancement) then
                                tbSlotsInUse[tEnhancement.Slot] = true
                                iCurEcoRate = (tEnhancement.ProductionPerSecondEnergy or 0) / 100 + (tEnhancement.ProductionPerSecondMass or 0)
                                if iCurEcoRate > iBestEcoRate then
                                    iBestEcoRate = iCurEcoRate
                                end
                                if bWantBuildPower and (tEnhancement.NewBuildRate or 0) > iBestBuildPowerRate then
                                    iBestBuildPowerRate = tEnhancement.NewBuildRate
                                end
                            elseif not(tEnhancement.Prerequisite) or (oSACU:HasEnhancement(tEnhancement.Prerequisite)) then
                                iCurEcoRate = (tEnhancement.ProductionPerSecondEnergy or 0) / 100 + (tEnhancement.ProductionPerSecondMass or 0)
                                if iCurEcoRate > iBestEcoRate then
                                    iBestEcoRate = iCurEcoRate
                                    sBestEcoEnhancement = sEnhancement
                                end
                                if bWantBuildPower and (tEnhancement.NewBuildRate or 0) > iBestBuildPowerRate then
                                    iBestBuildPowerRate = tEnhancement.NewBuildRate
                                    sBestBuildPowerEnhancement = sEnhancement
                                end
                            end
                        end
                        if sBestEcoEnhancement then
                            table.insert(oSACU[M28ACU.reftPreferredUpgrades], sBestEcoEnhancement)
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': bWantBuildPower='..tostring(bWantBuildPower)..'; sBestBuildPowerEnhancement='..(sBestBuildPowerEnhancement or 'nil')) end
                        if bWantBuildPower then
                            oSACU[refbConsideredPotentialBPUpgrade] = true
                            if sBestBuildPowerEnhancement and (not(sBestEcoEnhancement) or not(tUpgradesAvailable[sBestBuildPowerEnhancement].Slot == tUpgradesAvailable[sBestEcoEnhancement].Slot)) and not(tbSlotsInUse[tUpgradesAvailable[sBestBuildPowerEnhancement].Slot]) then
                                table.insert(oSACU[M28ACU.reftPreferredUpgrades], sBestBuildPowerEnhancement)
                                bWantBuildPower = false
                                if bDebugMessages == true then LOG(sFunctionRef..': Included build power enhancement in table of upgrades for the SACU') end
                            end
                        end
                    end

                    if M28Utilities.IsTableEmpty(oSACU[M28ACU.reftPreferredUpgrades]) == false then
                        M28ACU.RemovePreferredUpgradesThatWeAlreadyHave(oSACU, oSACU:GetBlueprint())
                        if M28Utilities.IsTableEmpty(oSACU[M28ACU.reftPreferredUpgrades]) == false then
                            --Get upgrade wanted
                            table.insert(tSACUsToUpgrade, oSACU)
                            table.remove(tSACUs, iSACU)
                        end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tSACUsUpgrading) == false then
            local bLeaveOneSACU = false
            if ((tLZTeamData[M28Map.subrefiTimeLastWantSACUForExp] or tLZTeamData[M28Map.subrefiTimeLastWantSACUForSMD]) and GetGameTimeSeconds() - math.max((tLZTeamData[M28Map.subrefiTimeLastWantSACUForExp] or 0), tLZTeamData[M28Map.subrefiTimeLastWantSACUForSMD] or 0) <= 3) then
                bLeaveOneSACU = true
            end

            --First add any SACUsToUpgrade back to main table
            if M28Utilities.IsTableEmpty(tSACUsToUpgrade) == false then
                for iSACU, oSACU in tSACUsToUpgrade do
                    table.insert(tSACUs, oSACU)
                end
            end
            --Assist with all SACUs (or all but one)
            local oSACUToAssist = tSACUsUpgrading[1]
            bProceed = bLeaveOneSACU
            for iSACU = table.getn(tSACUs), 1, -1 do
                local oSACU = tSACUs[iSACU]
                if bLeaveOneSACU then
                    bLeaveOneSACU = false
                else
                    M28Orders.IssueTrackedGuard(oSACU, oSACUToAssist, false, 'SACUUpgrAs', false)
                    table.remove(tSACUs, iSACU)
                end
            end
        elseif M28Utilities.IsTableEmpty(tSACUsToUpgrade) == false then
            for iSACU, oSACU in tSACUsToUpgrade do
                if not(oSACU[M28UnitInfo.refbSpecialMicroActive]) then
                    M28Orders.IssueTrackedEnhancement(oSACU, oSACU[M28ACU.reftPreferredUpgrades][1], false, 'SACURasUpgr')
                    break
                end
            end
        end
        if M28Utilities.IsTableEmpty(tSACUs) then bProceed = false end
    end
    --M28Orders.IssueTrackedEnhancement(oACU, sUpgradeToGet, false, 'ACUUpg')
    local bWantExperimentalAnyway = false
    if (M28Team.tTeamData[iTeam][M28Team.refiLowestUnitCapAdjustmentLevel] or 5) <= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.5 and not(M28Conditions.HaveLowPower(iTeam)) then
        bWantExperimentalAnyway = true
    end
    if bDebugMessages == true then LOG(sFunctionRef..': About to consider if we want to get SMD or experimental due to restrictions on what can be built by engineers, bProceed='..tostring(bProceed)..'; Time since last wanted SACU for exp or engi='..(GetGameTimeSeconds() - math.max((tLZTeamData[M28Map.subrefiTimeLastWantSACUForExp] or 0), tLZTeamData[M28Map.subrefiTimeLastWantSACUForSMD] or 0))..'; bWantExperimentalAnyway='..tostring(bWantExperimentalAnyway)) end
    if bProceed and (bWantExperimentalAnyway or  ((tLZTeamData[M28Map.subrefiTimeLastWantSACUForExp] or tLZTeamData[M28Map.subrefiTimeLastWantSACUForSMD]) and GetGameTimeSeconds() - math.max((tLZTeamData[M28Map.subrefiTimeLastWantSACUForExp] or 0), tLZTeamData[M28Map.subrefiTimeLastWantSACUForSMD] or 0) <= math.max(5, (iTicksPerLandCycle-1)*0.1))) then
        local bBuildingSMD = false
        if tLZTeamData[M28Map.subrefiTimeLastWantSACUForSMD] and GetGameTimeSeconds() - tLZTeamData[M28Map.subrefiTimeLastWantSACUForSMD] <= math.max(5, (iTicksPerLandCycle-1)*0.1) and (M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] == 0 or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false) then
            local iSMDBPWanted, bAssistSMD, oSMDToShield, oShieldToAssist = M28Engineer.GetBPToAssignToSMD(iPlateau, iLandZone, iTeam, tLZTeamData, tLZTeamData[M28Map.subrefLZbCoreBase], M28Conditions.TeamHasLowMass(iTeam), M28Conditions.HaveLowPower(iTeam))
            if bDebugMessages == true then LOG(sFunctionRef..': Deciding if want to use RAS SACUs to build SMD, iSMDBPWanted='..iSMDBPWanted..'; bAssistSMD='..tostring(bAssistSMD)..'; oSMDToShield='..(oSMDToShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oSMDToShield) or 'nil')..'; oShieldToAssist='..(oShieldToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oShieldToAssist) or 'nil')) end
            if iSMDBPWanted > 0 and M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategorySMD, true) == 0 and not(bAssistSMD) and not(oSMDToShield) and not(oShieldToAssist) then
                bBuildingSMD = true
                BuildCategoryWithSACUs(M28UnitInfo.refCategorySMD)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bBuildingSMD='..tostring(bBuildingSMD)..'; Time since last wanted SMD='..GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeLastWantSACUForSMD] or 0)) end
        if not(bBuildingSMD) and (bWantExperimentalAnyway or tLZTeamData[M28Map.subrefiTimeLastWantSACUForExp] and GetGameTimeSeconds() - tLZTeamData[M28Map.subrefiTimeLastWantSACUForExp] <= math.max(5, (iTicksPerLandCycle-1)*0.1)) then
            --First check we have no experimental level units under construction in this zone
            if bDebugMessages == true then LOG(sFunctionRef..': Number of exp under construction in LZ='..M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryExperimentalLevel, true)) end
            if M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryExperimentalLevel, true) == 0 then
                local tbEngineersOfFactionOrNilIfAlreadyAssigned = {}
                local aiBrain
                local toSACUByFaction = {}
                local iCurFaction
                for iSACU, oSACU in tSACUs do
                    iCurFaction = M28UnitInfo.GetUnitFaction(oSACU)
                    tbEngineersOfFactionOrNilIfAlreadyAssigned[iCurFaction] = true
                    if not(aiBrain) then aiBrain = oSACU:GetAIBrain() end
                    if not(toSACUByFaction[iCurFaction]) then toSACUByFaction[iCurFaction] = {} end
                    table.insert(toSACUByFaction[iCurFaction], oSACU)
                end
                local iCategoryWanted, iFactionWanted = M28Engineer.DecideOnExperimentalToBuild(M28Engineer.refActionBuildExperimental, aiBrain, tbEngineersOfFactionOrNilIfAlreadyAssigned, tLZData, tLZTeamData, iPlateau, iLandZone)
                if bDebugMessages == true then LOG(sFunctionRef..': is iCategoryWanted nil='..tostring(iCategoryWanted == nil)..'; is iFactionWanted nil='..tostring(iFactionWanted == nil)) end
                if iCategoryWanted then
                    if iCategoryWanted == M28Engineer.refActionManageGameEnderTemplate then
                        --Need to assign unit to GETemplate
                        bProceed = false
                        for iSACU, oSACU in tSACUs do
                            M28Engineer.AssignEngineerToGameEnderTemplate(oSACU, tLZData, tLZTeamData, iPlateau, iLandZone)
                        end
                    else
                        BuildCategoryWithSACUs(iCategoryWanted, iFactionWanted, toSACUByFaction)
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we should proceed with considering assigning SACUs to GE template, bProceed='..tostring(bProceed)..'; Is table of active GE templates for this zone empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates]))) end
    if bProceed and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates]) == false then
        for iTemplate, tSubtable in tLZTeamData[M28Map.reftActiveGameEnderTemplates] do
            if not(tSubtable[M28Map.subrefGEbDontNeedEngineers]) then
                for iSACU, oSACU in tSACUs do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering SACU assignment to GE template, oSACU='..oSACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSACU)..'; oSACU[M28Building.reftArtiTemplateRefs]='..repru(oSACU[M28Building.reftArtiTemplateRefs])..'; oSACU[M28UnitInfo.refbSpecialMicroActive]='..tostring(oSACU[M28UnitInfo.refbSpecialMicroActive] or false)) end
                    if M28Utilities.IsTableEmpty(oSACU[M28Building.reftArtiTemplateRefs]) then
                        if not(oSACU[M28UnitInfo.refbSpecialMicroActive]) then
                            M28Engineer.AssignEngineerToGameEnderTemplate(oSACU, tLZData, tLZTeamData, iPlateau, iLandZone)
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': RAS SACUs are assigned to gameender duty for iTemplate ref='..iTemplate) end
                bProceed = false
                break
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': FInished going through if want to help active GE template, bProceed='..tostring(bProceed)) end
    if bProceed then
        --Defending against arti - if have a gameender then first consider if have part-complete shield that want to construct
        local oShieldToAssist
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) == false and M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] then
            local tGameEndersForShielding = EntityCategoryFilterDown(M28UnitInfo.refCategoryGameEnder, tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection])
            if M28Utilities.IsTableEmpty(tGameEndersForShielding) == false then
                local oGameEnderToCover
                for iGameEnder, oGameEnder in tGameEndersForShielding do
                    if M28Utilities.IsTableEmpty(oGameEnder[M28Building.reftoSpecialAssignedShields]) == false then
                        oGameEnderToCover = oGameEnder
                        break
                    end
                end
                if oGameEnderToCover then
                    --How much shielding do we have
                    local iNearestCompleteShield = 0
                    local oNearestCompleteShield
                    local iActiveShields = 0
                    local iCurShield, iMaxShield
                    for iShield, oShield in oGameEnderToCover[M28Building.reftoSpecialAssignedShields] do
                        if oShield:GetFractionComplete() < 1 and oShield:GetFractionComplete() > iNearestCompleteShield then
                            iNearestCompleteShield = oShield:GetFractionComplete()
                            oNearestCompleteShield = oShield
                        else
                            iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                            if iCurShield > 0 then iActiveShields = iActiveShields + 1 end
                        end
                    end
                    if iActiveShields > 1 or (iActiveShields == 1 and iNearestCompleteShield >= 0.75) then
                        --Do nothing
                    else
                        oShieldToAssist = oNearestCompleteShield
                    end
                end
            end

        end

        --Defending against arti - if have T3 arti or gameender then want to assist the shield with RAS SACUs (in addition to any engineers that are assisting it)
        if not(oShieldToAssist) then
            local tPriorityUnitsToShield
            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with zone '..iLandZone..'; at time '..GetGameTimeSeconds()..'; DefendAgainstArti='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti])) end
            if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] and (M28Team.tTeamData[iTeam][M28Team.refiEnemyT3ArtiCount] > 0 or M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] >= 2) then
                local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                if aiBrain.GetUnitsAroundPoint then
                    tPriorityUnitsToShield = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryGameEnder, tLZData[M28Map.subrefMidpoint], 250, 'Ally')
                    if M28Utilities.IsTableEmpty(tPriorityUnitsToShield) then
                        tPriorityUnitsToShield = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedT3Arti, tLZData[M28Map.subrefMidpoint], 150, 'Ally')
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of priority units to shield empty='..tostring(M28Utilities.IsTableEmpty(tPriorityUnitsToShield))) end
            if M28Utilities.IsTableEmpty(tPriorityUnitsToShield) == false then
                --Get closest of these that has a shield that is damaged
                local iCurDist
                local iClosestDist = 100000
                local iCurShield, iMaxShield
                local bAssistEvenIfNotDamaged = true
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.4 then bAssistEvenIfNotDamaged = false end
                for iUnit, oUnit in tPriorityUnitsToShield do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering priority unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction compelte='..oUnit:GetFractionComplete()..'; Does it have a shield providing coverage='..tostring(M28UnitInfo.IsUnitValid(oUnit[M28Building.refoPriorityShieldProvidingCoverage]))) end
                    if oUnit:GetFractionComplete() >= 0.35 then
                        if M28UnitInfo.IsUnitValid(oUnit[M28Building.refoPriorityShieldProvidingCoverage]) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit[M28Building.refoPriorityShieldProvidingCoverage]:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': Shield='..oUnit[M28Building.refoPriorityShieldProvidingCoverage].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28Building.refoPriorityShieldProvidingCoverage])..'; iCurDist='..iCurDist..'; iCloestDist='..iClosestDist) end
                            if iCurDist < iClosestDist then
                                --Is the shield still active?
                                iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit[M28Building.refoPriorityShieldProvidingCoverage], true)
                                if bDebugMessages == true then LOG(sFunctionRef..': iCurShield='..iCurShield) end
                                if (iCurShield > 0 and (bAssistEvenIfNotDamaged or iCurShield < iMaxShield or GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeLastDamaged] or - 100) <= 25)) or (oUnit[M28Building.refoPriorityShieldProvidingCoverage]:GetFractionComplete() < 1 and (not(oUnit[M28Engineer.refbDontIncludeAsPartCompleteBuildingForConstruction]) or oUnit[M28Building.refoPriorityShieldProvidingCoverage]:GetFractionComplete() <= 0.75)) then
                                    iClosestDist = iCurDist
                                    oShieldToAssist = oUnit[M28Building.refoPriorityShieldProvidingCoverage]
                                end
                            end
                        end
                    end
                end
            end
        end
        if oShieldToAssist then
            if bDebugMessages == true then LOG(sFunctionRef..': Have priority shield to assist') end
            if oShieldToAssist:GetFractionComplete() == 1 then
                for iUnit, oUnit in tSACUs do
                    M28Orders.IssueTrackedGuard(oUnit, oShieldToAssist, false, 'RASAGS', false)
                end
            else
                for iUnit, oUnit in tSACUs do
                    M28Orders.IssueTrackedRepair(oUnit, oShieldToAssist, false, 'RASRS', false)
                end
            end
        else
            local tUnitsToAssist = {}
            --If overflowing mass then search for under construction experimentals in the zone
            local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)
            if not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.65 then
                --If have under construction experimental in this zone then assist it
                local tExpInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryExperimentalLevel, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if M28Utilities.IsTableEmpty(tExpInZone) == false then
                    for iExp, oExp in tExpInZone do
                        if oExp:GetFractionComplete() < 1 then
                            table.insert(tUnitsToAssist, oExp)
                        end
                    end
                end
            end

            --If have mass stored then find the nearest quantum gatway and assist it for now, otherwise do nothing (if enemies in this LZ then will have been sent to the combat unit management already)
            local tQuantumGateways = EntityCategoryFilterDown(M28UnitInfo.refCategoryQuantumGateway, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            local oGateway
            local bNotAssistingGateway = true
            local bHaveRASGateway = false
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of quantum gateways empty='..tostring(M28Utilities.IsTableEmpty( tQuantumGateways))) end
            if M28Utilities.IsTableEmpty( tQuantumGateways) == false then
                for iUnit, oUnit in tQuantumGateways do
                    oGateway = oUnit
                    if not(EntityCategoryContains(categories.SERAPHIM, oUnit.UnitId)) then
                        bHaveRASGateway = true
                        break
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': oGateway='..(oGateway.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oGateway))..'; bHaveRASGateway='..tostring(bHaveRASGateway)) end
            if oGateway then
                if not(bHaveRASGateway) then
                    --Do we have a T3+ 'other' factory type on the team, for a non-sera faction?
                    local iLandSubteam = oGateway:GetAIBrain().M28LandSubteam
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of other faction types empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeOther]))..'; Reprs of this='..reprs(M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeOther])) end
                    if M28Utilities.IsTableEmpty(M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeOther]) == false then
                        local bHaveNonSeraFactory = false
                        for iFaction, tSubtable in M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeOther] do
                            if not(iFaction == M28UnitInfo.refFactionSeraphim) and (tSubtable[3] or 0) > 0 then
                                bHaveNonSeraFactory = true
                                break
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished searching other factory types, bHaveNonSeraFactory='..tostring(bHaveNonSeraFactory or false)) end
                        if bHaveNonSeraFactory then
                            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                            if aiBrain.GetUnitsAroundPoint then
                                local tNearbyFriendlyGateway = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryQuantumGateway - categories.SERAPHIM, tLZData[M28Map.subrefMidpoint], 250, 'Ally')
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby non sera quantum gateways empty='..tostring(M28Utilities.IsTableEmpty(tNearbyFriendlyGateway))) end
                                if M28Utilities.IsTableEmpty(tNearbyFriendlyGateway) == false then
                                    for iUnit, oUnit in tNearbyFriendlyGateway do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering quantum gateway oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Terrain label='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oUnit:GetPosition()) or 'nil')..'; iPlateau='..(iPlateau or 'nil')) end
                                        if oUnit:GetAIBrain().M28AI and NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oUnit:GetPosition()) == iPlateau then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Have a non sera gateway to assist instead, oGateway='..oGateway.UnitId..M28UnitInfo.GetUnitLifetimeCount(oGateway)) end
                                            oGateway = oUnit
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                if (M28Map.bIsCampaignMap or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.05) and not(M28Conditions.HaveLowPower(iTeam)) and ((M28Map.bIsCampaignMap and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 80 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) or (not(M28Map.bIsCampaignMap) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < math.min(100, 40 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]))) then
                    if (M28Map.bIsCampaignMap or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 100) and oGateway:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryRASSACU) < 50 then
                        bNotAssistingGateway = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Will get every SACU to assist the gateway') end
                        table.insert(tUnitsToAssist, oGateway)
                        --[[for iUnit, oUnit in tSACUs do
                            M28Orders.IssueTrackedGuard(oUnit, oGateway, false, 'RASQG', false)
                        end--]]
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': oGateway='..(oGateway.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oGateway) or 'nil')..'; bNotAssistingGateway='..tostring(bNotAssistingGateway)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Have low power='..tostring(M28Conditions.HaveLowPower(iTeam))) end
            if bNotAssistingGateway then
                --If low power and have under construction pgen then assist this
                if bDebugMessages == true then LOG(sFunctionRef..': Does team have low mass='..tostring(M28Conditions.TeamHasLowMass(iTeam))..'; Is table of engineers building experimentals empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]))..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Time since close to unit cap='..(GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] or 0))) end
                if bHaveLowPower then
                    local tPowerInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryPower * categories.TECH3, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tPowerInZone) == false then
                        for iPgen, oPgen in tPowerInZone do
                            if oPgen:GetFractionComplete() < 1 then
                                table.insert(tUnitsToAssist, oPgen)
                            end
                        end
                    end
                end
                --If building an experimental and dont have low mass then assist it
                if M28Utilities.IsTableEmpty(tUnitsToAssist) and (not(M28Conditions.TeamHasLowMass(iTeam)) or (GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] or 0) <= 60)) and not(bHaveLowPower) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]) == false then

                    local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                    if aiBrain.GetUnitsAroundPoint then
                        local tExperimentalLevelUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryExperimentalLevel, tLZData[M28Map.subrefMidpoint], 100, 'Ally')
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of experimental level units empty='..tostring(M28Utilities.IsTableEmpty( tExperimentalLevelUnits))) end
                        if M28Utilities.IsTableEmpty( tExperimentalLevelUnits) == false then
                            for iUnit, oUnit in tExperimentalLevelUnits do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering nearby experimental '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()) end
                                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() < 1 then
                                    table.insert(tUnitsToAssist, oUnit)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Adding unit to table of units to assist') end
                                end
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Do we have any units to assist? is table empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToAssist))) end
                if M28Utilities.IsTableEmpty(tUnitsToAssist) then
                    --If have upgrading unit then assist this
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of active upgrades empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoActiveUpgrades]))) end
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoActiveUpgrades]) == false then tUnitsToAssist = tLZTeamData[M28Map.subreftoActiveUpgrades]
                    else
                        --Assist shield if need to defend from arti
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of priority shields to assist empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]))..'; Defending against arti='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti])) end
                        if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]) == false and (M28Team.tTeamData[iTeam][M28Team.refiEnemyT3ArtiCount] > 0 or M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] >= 2) then
                            tUnitsToAssist = tLZTeamData[M28Map.reftPriorityShieldsToAssist]
                        else
                            --otherwise assist an air factory if we have one
                            tUnitsToAssist = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                            if bDebugMessages == true then LOG(sFunctionRef..': Setting unit to assist to be an air factory, is tUnitsToAssist empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToAssist))) end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished saerching for potential units to assist, is table empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToAssist))) end
            if M28Utilities.IsTableEmpty(tUnitsToAssist) == false then
                local tStartPoint
                if oGateway then tStartPoint = oGateway:GetPosition()
                else tStartPoint = tLZData[M28Map.subrefMidpoint]
                end
                local oClosestUnitToAssist = M28Utilities.GetNearestUnit(tUnitsToAssist, tStartPoint)
                if bDebugMessages == true then LOG(sFunctionRef..': oClosestUnitToAssist='..(oClosestUnitToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestUnitToAssist) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oClosestUnitToAssist))) end
                if not(M28UnitInfo.IsUnitValid(oClosestUnitToAssist)) then M28Utilities.ErrorHandler('No unit to assist for RAS', true)
                else
                    for iUnit, oUnit in tSACUs do
                        M28Orders.IssueTrackedGuard(oUnit, oClosestUnitToAssist, false, 'RASAs', false)
                        if bDebugMessages == true then LOG(sFunctionRef..': Telling RAS '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to assist unit') end
                    end
                end

            else
                --Othewrise clear orders if nothing to assist
                for iUnit, oUnit in tSACUs do
                    if not(oUnit[M28UnitInfo.refbSpecialMicroActive]) and not(oUnit:IsUnitState('Moving')) and (oUnit:IsUnitState('Repairing') or oUnit:IsUnitState('Building') or oUnit:IsUnitState('Guarding')) then
                        M28Orders.IssueTrackedClearCommands(oUnit)
                    end
                end
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetNearestEnemyInOtherPlateau(iPlateau, tLZData, iTeam, bGetIndirectThreatInstead)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNearestEnemyInOtherPlateau'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint]) --redundancy
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
        local iClosestEnemyDist = 10000
        local oClosestEnemy
        local iCurDist
        local iEnemyIFThreat = 0
        local iEnemyBestRange = 0
        for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateauOrPond='..tSubtable[M28Map.subrefiPlateauOrPond]..'; Is water zone='..tostring(tSubtable[M28Map.subrefbIsWaterZone])..'; Distance='..tSubtable[M28Map.subrefiDistance]..'; iEntry='..iEntry) end
            if tSubtable[M28Map.subrefiDistance] >= 170 and (iEntry >= 7 or tSubtable[M28Map.subrefiDistance] >= 320 or (bGetIndirectThreatInstead and tSubtable[M28Map.subrefiDistance] >= 200)) then break end
            if not(iPlateau == tSubtable[M28Map.subrefiPlateauOrPond]) and not(tSubtable[M28Map.subrefbIsWaterZone]) then --water zones dont track indirect fire threat, and in any event battleships and cruisers outrange t2 arti and mobile t3 arti (which is what this might be used for)
                --Have a nearby land zone in a different plateau, check if there are enemy units in this LZ and (if so) if any of them are structures
                local tAdjLZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                if not(tAdjLZData[M28Map.subrefbPacifistArea]) then
                    local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]))) end
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                        if bGetIndirectThreatInstead then
                            iEnemyIFThreat = iEnemyIFThreat + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] or 0) + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)
                            iEnemyBestRange = math.max(iEnemyBestRange, (tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0))
                        else
                            for iUnit, oUnit in tAdjLZTeamData[M28Map.subrefTEnemyUnits] do
                                if M28UnitInfo.IsUnitValid(oUnit) then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit:GetPosition())
                                    if iCurDist <= iClosestEnemyDist then
                                        oClosestEnemy = oUnit
                                        iClosestEnemyDist = iCurDist
                                        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..iCurDist..'; this is the closest unit for now, will cycle through any remaining') end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for enemy units in nearby different plateau, oClosestEnemy='..(oClosestEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestEnemy) or 'nli')..'; iEnemyIFThreat='..iEnemyIFThreat..'; bGetIndirectThreatInstead='..tostring(bGetIndirectThreatInstead or false)) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        if bGetIndirectThreatInstead then return iEnemyIFThreat, iEnemyBestRange
        else
            return oClosestEnemy
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function BackupUnitTowardsRallyIfAvailable(oUnit, tRallyPoint, iIslandPlateauOrPondRef, sOrderDesc, bAmphibiousAndUsingPlateauRef, iDefaultDistOverride, iMaxAngleDifForMovingBackwardsOverride, bUsingPondRef)
    --iDefaultDistOverride - if specified, then doesnt require a backup dist to move back, and will use this if no backup dist is available
    --iMaxAngleDifForMovingBackwardsOverride - Overrides the maximum angle difference allowed to move backwards in a straight line for the unit instead of moving to tRallyPoint; if this is exceeded, then will try and move to the rally point instead

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'BackupUnitTowardsRallyIfAvailable'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28UnitInfo.IsUnitValid(oUnit) then
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit position='..repru(oUnit:GetPosition())..'; tRallyPoint='..repru(tRallyPoint)..'; iIslandPlateauOrPondRef='..iIslandPlateauOrPondRef..'; sOrderDesc='..sOrderDesc..'; bAmphibiousAndUsingPlateauRef='..tostring(bAmphibiousAndUsingPlateauRef)..'; iDefaultDistOverride='..(iDefaultDistOverride or 'nil')..'; iMaxAngleDifForMovingBackwardsOverride='..(iMaxAngleDifForMovingBackwardsOverride or 'nil')..'; Time='..GetGameTimeSeconds()) end
        local iBackupDist = 0
        local iMaxAngleDifference = iMaxAngleDifForMovingBackwardsOverride or 35
        local bValidTowardsLocation = false
        if oUnit[M28UnitInfo.refbCanKite] then
            iBackupDist = (oUnit:GetBlueprint().Physics.BackUpDistance or 0)
        end

        if iBackupDist >= 6 or iDefaultDistOverride then


            local iDistToMove
            if iDefaultDistOverride and iBackupDist >= 3 then iDistToMove = math.min(iBackupDist - 1, iDefaultDistOverride)
            elseif not(iDefaultDistOverride) then
                iDistToMove = math.min(iBackupDist - 1, 20)
                if iBackupDist >= 12 and iBackupDist < 20 then iDistToMove = iDistToMove - 1.5 end
            else iDistToMove = iDefaultDistOverride
            end
            local iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)
            local iCurUnitFacingDirection = M28UnitInfo.GetUnitFacingAngle(oUnit)
            local iMoveBackwardsAngle = iCurUnitFacingDirection - 180
            if iMoveBackwardsAngle < 0 then iMoveBackwardsAngle = iMoveBackwardsAngle + 360 end
            local tPotentialMoveLocation
            local iAngleDif = M28Utilities.GetAngleDifference(iAngleToRally, iMoveBackwardsAngle)
            local iAngleActuallyMoving

            if bDebugMessages == true then LOG(sFunctionRef..': Checking whether to move directly backwards, iAngleToRally='..iAngleToRally..'; iMoveBackwardsAngle='..iMoveBackwardsAngle..'; iAngleDif='..iAngleDif..'; iMaxAngleDifference='..iMaxAngleDifference..' Approx Speed (X and Z velocity times 10) = '..M28UnitInfo.GetUnitSpeed(oUnit)) end
            function CheckIfValidLocation()
                if bAmphibiousAndUsingPlateauRef then
                    if NavUtils.GetLabel(M28Map.refPathingTypeHover, tPotentialMoveLocation) == iIslandPlateauOrPondRef then
                        bValidTowardsLocation = true
                    end
                elseif not(bUsingPondRef) then
                    if NavUtils.GetLabel(M28Map.refPathingTypeLand, tPotentialMoveLocation) == iIslandPlateauOrPondRef then
                        bValidTowardsLocation = true
                    end
                else
                    if NavUtils.GetLabel(M28Map.refPathingTypeNavy, tPotentialMoveLocation) == iIslandPlateauOrPondRef then
                        bValidTowardsLocation = true
                    end
                end
            end
            if iAngleDif >= 3 and iAngleDif <= iMaxAngleDifference then
                local iMaxAngleAdjust = math.min(iAngleDif, 5)
                if iMoveBackwardsAngle > iAngleToRally then iMaxAngleAdjust = -iMaxAngleAdjust end
                tPotentialMoveLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), iMoveBackwardsAngle + iMaxAngleAdjust, iDistToMove, true, false)
                CheckIfValidLocation()
                iAngleActuallyMoving = iMoveBackwardsAngle
            end
            --else
            if not(bValidTowardsLocation) then
                tPotentialMoveLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToRally, iDistToMove, true, false)
                CheckIfValidLocation()
                iAngleActuallyMoving = iAngleToRally
            end
            if tPotentialMoveLocation and bValidTowardsLocation then
                --If arent already moving in this direction then stop for 1 tick, as backing up doesnt work properly otherwise
                local tLastOrder = oUnit[M28Orders.reftiLastOrders][1]
                if bDebugMessages == true then LOG(sFunctionRef..': iAngleToRally='..iAngleToRally..'; iDistToMove='..iDistToMove..'; bValidTowardsLocation='..tostring(bValidTowardsLocation or false)..'; Unit state='..M28UnitInfo.GetUnitState(oUnit))
                    if tLastOrder and tLastOrder[M28Orders.subreftOrderPosition] then LOG(sFunctionRef..': Angle dif between destination and last move order='..M28Utilities.GetAngleDifference(iAngleActuallyMoving, M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLastOrder[M28Orders.subreftOrderPosition]))) end
                end
                if (tLastOrder and not(tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueMove and M28Utilities.GetAngleDifference(iAngleActuallyMoving, M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLastOrder[M28Orders.subreftOrderPosition])) < 15)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will clear unit orders and wait a bit, unit approx speed='..M28UnitInfo.GetUnitSpeed(oUnit)) end
                    local iTotalTimeWaited = 0
                    M28Orders.IssueTrackedClearCommands(oUnit)
                    while M28UnitInfo.IsUnitValid(oUnit) and M28UnitInfo.GetUnitSpeed(oUnit) >= 0.75 and iTotalTimeWaited <= 9 do
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        iTotalTimeWaited = iTotalTimeWaited + 1
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        if bDebugMessages == true then LOG(sFunctionRef..': Speed after waiting 1 tick='..M28UnitInfo.GetUnitSpeed(oUnit)..'; iTotalTimeWaited in ticks='..iTotalTimeWaited) end
                    end

                    --Ticks to wait:
                    --With no 'move 5 degrees towards rally' logic: 3 tick delay meant this only worked sometimes, and failed in one case with a fatboy; 4-7 tick delay failed initially when fatboy was moving forwards but didn't have issues after that, 8 ticks worked more reliably; velocity when 8 ticks worked: X-0.10995483398438 Y0 Z0.13614654541016; with 5 degree logic also still neededed to wait 8 ticks instead of 4 to move backwards
                    --With 5 degree logic, when velocity slowed to iTotalVelocity=0.073184967041016 was no need to wait any ticks to move ackwards
                    --Therefore will try waiting 1 tick until speed is sub-1 (speed being total velocity * 10); when did this, with a speed threshold of 1, it failed with fatboy; speed of 0.73837280273438 was ok

                end
            M28Orders.IssueTrackedMove(oUnit, tPotentialMoveLocation, math.min(iDistToMove * 0.5, 5), false, sOrderDesc..'T', false)
            end
        end
        if not(bValidTowardsLocation) then
            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 5, false, sOrderDesc..'R', false)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageCombatUnitsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableCombatUnits, iFriendlyBestMobileDFRange, iFriendlyBestMobileIndirectRange, bWantIndirectReinforcements, tUnavailableUnitsInThisLZ, bDelayOrdersForHover, bHaveCombatUnitsFromAdjZone)
    --Handles logic for main combat units (direct and indirect fire mobile units) that are noted as available to the land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageCombatUnitsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then
        LOG(sFunctionRef..': start of code, iTeam='..iTeam..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Is table of available combat units empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))..'; iFriendlyBestMobileDFRange='..iFriendlyBestMobileDFRange..'; iFriendlyBestMobileIndirectRange='..iFriendlyBestMobileIndirectRange..'; Are there enemy units in this or adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; bWantIndirectReinforcements='..tostring(bWantIndirectReinforcements or false)..'; tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]='..tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]..'; subrefLZThreatAllyMobileIndirectByRange='..repru(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange])..'; subrefLZThreatAllyMobileDFByRange='..repru(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange])..'; Enemy mobile DF='..repru(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange])..'; Threat of tAvailableCombatUnits='..M28UnitInfo.GetCombatThreatRating(tAvailableCombatUnits, false, false, false)..'; subrefiAvailableMobileShieldThreat='..(tLZTeamData[M28Map.subrefiAvailableMobileShieldThreat] or 0)..'; LZ value='..tLZTeamData[M28Map.subrefLZTValue]..'; Time='..GetGameTimeSeconds())
        for iUnit, oUnit in tAvailableCombatUnits do
            LOG(sFunctionRef..': Threat of unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'='..M28UnitInfo.GetCombatThreatRating({ oUnit }, false, false, false))
        end
    end

    function ProceedWithUnitOrder(oUnit, bWeOutrangeEnemy)
        if bDelayOrdersForHover and EntityCategoryContains(categories.HOVER, oUnit.UnitId) then
            if bWeOutrangeEnemy then
                if GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastHoverLandCombatOrder] or -10) <= 6 then
                    return false
                end
            else
                if GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastHoverLandCombatOrder] or -10) <= 8 then
                    return false
                end
            end
            oUnit[M28UnitInfo.refiTimeOfLastHoverLandCombatOrder] = GetGameTimeSeconds()
        end
        return true
    end
    local iCurTime = math.floor(GetGameTimeSeconds())
    function IgnoreOrderDueToStuckUnit(oUnit)
        if oUnit[M28UnitInfo.refbUnitStuckAlternating] then
            if (not(oUnit[M28UnitInfo.refbEasyBrain]) or EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnit.UnitId)) and oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition] and M28Utilities.GetDistanceBetweenPositions(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition], oUnit:GetPosition()) >= 15 then
                if oUnit[M28Orders.reftiLastOrders][1][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueGroundAttack then
                    --We wont reach destination with a ground attack so need new orders
                    return false
                else
                    --Do nothing - want unit to reach its destination before it gets new orders
                    return true
                end
            end
        end
    end

    local bWantReinforcements = false

    --First record the range of enemy units, and which units in adjacent zones are nearest to us:
    UpdateBestEnemyRangesForThisLandZone(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    local iEnemyBestMobileDFRange, iEnemyBestStructureDFRange, iEnemyBestMobileIndirectRange = RecordClosestAdjacentEnemiesAndGetBestEnemyRange(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2) --Get a LZ up to 3 land zones away to retreat to (i.e. will pick rally point and then move 2 towards it)
    local tAmphibiousRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2, true)
    local iAngleTowardsBase = M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase])
    local iDistTowardsBase = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase])
    local tMoveTowardsBaseRetreatPoint = M28Utilities.MoveInDirection(tLZData[M28Map.subrefMidpoint], iAngleTowardsBase, math.min(50, iDistTowardsBase), true, false, M28Map.bIsCampaignMap)
    if bDebugMessages == true then LOG(sFunctionRef..': tMoveTowardsBaseRetreatPoint='..repru(tMoveTowardsBaseRetreatPoint)..'; iAngleTowardsBase='..iAngleTowardsBase..'; iDistTowardsBase from LZ midpoint='..iDistTowardsBase..'; Midpoint='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tMoveTowardsBaseRetreatPoint) or 'nil')..'; tLZData[M28Map.subrefLZIslandRef]='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')) end
    if tMoveTowardsBaseRetreatPoint then
        if not(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tMoveTowardsBaseRetreatPoint) == tLZData[M28Map.subrefLZIslandRef]) then
            tMoveTowardsBaseRetreatPoint = nil
        else
            local iAngleToRallyPoint = M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tRallyPoint)
            if bDebugMessages == true then LOG(sFunctionRef..': iAngleToRallyPoint='..iAngleToRallyPoint..'; Angle dif='..M28Utilities.GetAngleDifference(iAngleToRallyPoint, iAngleTowardsBase)..'; Dist between rally point and bsae='..M28Utilities.GetDistanceBetweenPositions(tRallyPoint, tLZTeamData[M28Map.reftClosestFriendlyBase])) end
            if M28Utilities.GetAngleDifference(iAngleToRallyPoint, iAngleTowardsBase) <= 20 then
                tMoveTowardsBaseRetreatPoint = nil
            elseif M28Utilities.GetDistanceBetweenPositions(tRallyPoint, tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 20 then
                tMoveTowardsBaseRetreatPoint = nil
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': tAmphibiousRallyPoint='..repru(tAmphibiousRallyPoint)..'; tRallyPoint='..repru(tRallyPoint)) end
    local iIndirectRunFigureNormal = 10
    local iIndirectRunFigureDeployedAdjust = 15
    local iIndirectRunFigureSynchronisation = 11
    local iIndirectDistanceInsideRangeThreshold

    local oClosestFriendlyUnitToAnEnemyFirebase --For simplicity will be the closest unit to the last firebase checked (where multiple firebases)
    local iClosestFriendlyUnitToAnEnemyFirebase = 100000

    local iFirebaseThreatAdjust = 0
    local iFirebaseCloseCombatThreat = 0
    local iAdjacentFirebaseThreat = 0

    local iAvailableCombatUnitThreat = M28UnitInfo.GetMassCostOfUnits(tAvailableCombatUnits)
    iAvailableCombatUnitThreat = iAvailableCombatUnitThreat + math.min(iAvailableCombatUnitThreat, tLZTeamData[M28Map.subrefiAvailableMobileShieldThreat])



    local bHaveSignificantCombatCloserToFirebase = false
    local iClosestFirebaseDist = 100000
    local oClosestUnitFromAllFirebases
    local oNearestFirebaseUnit
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
        --Is the firebase not in range of a core LZ?
        local bFirebaseInCoreLZRange = false
        local oOurNearestUnitToFirebase
        local tEnemyT2ArtiAndShields
        local iCurDist
        local iClosestDist
        local iCurFirebaseThreat
        local bIsAdjacent
        local iDistToFirebase
        local iClosestDistFromAllFirebases = 100000

        for iEntry, tPlateauAndLZ in tLZTeamData[M28Map.subreftEnemyFirebasesInRange] do
            if M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][tPlateauAndLZ[2]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] then
                bFirebaseInCoreLZRange = true
                iFirebaseThreatAdjust = 0
                break
            else
                --Ignore firebase in the LZ we are already in
                if not(iLandZone == tPlateauAndLZ[2]) then
                    local tFirebaseLZData = M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][tPlateauAndLZ[2]]
                    local tFirebaseLZTeamData = tFirebaseLZData[M28Map.subrefLZTeamData][iTeam]
                    tEnemyT2ArtiAndShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryFixedShield, tFirebaseLZTeamData[M28Map.subrefTEnemyUnits])
                    if M28Utilities.IsTableEmpty(tEnemyT2ArtiAndShields) == false then
                        iClosestDist = 100000
                        for iUnit, oUnit in tEnemyT2ArtiAndShields do
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oNearestFirebaseUnit = oUnit
                                if iCurDist < iClosestDistFromAllFirebases then
                                    oClosestUnitFromAllFirebases = oUnit
                                end
                            end
                        end
                        iClosestDist = 100000
                        local tFirebaseMidpoint = tFirebaseLZData[M28Map.subrefMidpoint]
                        for iUnit, oUnit in tAvailableCombatUnits do
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tFirebaseMidpoint)
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oOurNearestUnitToFirebase = oUnit
                                if iClosestDist < iClosestFriendlyUnitToAnEnemyFirebase then
                                    oClosestFriendlyUnitToAnEnemyFirebase = oUnit
                                    iClosestFriendlyUnitToAnEnemyFirebase = iClosestDist
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': oOurNearestUnitToFirebase='..oOurNearestUnitToFirebase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOurNearestUnitToFirebase)..'; oNearestFirebaseUnit='..oNearestFirebaseUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestFirebaseUnit)..'; Dist between them='..M28Utilities.GetDistanceBetweenPositions(oOurNearestUnitToFirebase:GetPosition(), oNearestFirebaseUnit:GetPosition())) end

                        if oOurNearestUnitToFirebase and oNearestFirebaseUnit then
                            iCurFirebaseThreat = 0
                            iDistToFirebase = M28Utilities.GetDistanceBetweenPositions(oOurNearestUnitToFirebase:GetPosition(), oNearestFirebaseUnit:GetPosition())
                            iClosestFirebaseDist = math.min(iClosestFirebaseDist, iDistToFirebase)
                            if iDistToFirebase <= 140 then
                                iCurFirebaseThreat = M28UnitInfo.GetMassCostOfUnits(tEnemyT2ArtiAndShields)
                                if iCurFirebaseThreat > 0 then
                                    iFirebaseCloseCombatThreat = tFirebaseLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] + math.min(tFirebaseLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 1.5, (tFirebaseLZTeamData[M28Map.subrefLZThreatEnemyShield] or 0)) --combat total excludes shields and t2 arti
                                    bIsAdjacent = false
                                    if M28Utilities.IsTableEmpty(tFirebaseLZData[M28Map.subrefLZPath]) == false then

                                        --Include friendly units in LZs between here and the firebase
                                        if bDebugMessages == true then
                                            --LOG(sFunctionRef..': iLandZone='..reprs(iLandZone))
                                            --LOG(sFunctionRef..': tPlateauAndLZ[2]='..reprs(tPlateauAndLZ[2]))
                                            --LOG(sFunctionRef..': tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][tPlateauAndLZ[2]]='..reprs(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][tPlateauAndLZ[2]]))
                                            --LOG(sFunctionRef..': pathing='..reprs(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][tPlateauAndLZ[2]]][M28Map.subrefLZPath]))
                                            --LOG(sFunctionRef..': tLZData[M28Map.subrefLZPathingToOtherLandZones]='..reprs(tLZData[M28Map.subrefLZPathingToOtherLandZones]))
                                            LOG(sFunctionRef..': Will cycle through all LZs between LZ'..reprs(iLandZone or 'nil')..' and LZ'..reprs(tPlateauAndLZ[2] or 'nil')..' and factor in friendly threat; Entry in pathing table='..reprs(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][tPlateauAndLZ[2]] or 'nil')..'; reprs of pathing='..reprs(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][tPlateauAndLZ[2]]][M28Map.subrefLZPath])..'; tLZData[M28Map.subrefLZPathingToOtherLandZones]='..reprs(tLZData[M28Map.subrefLZPathingToOtherLandZones]))
                                        end

                                        for iEntry, iAdjacentLandZone in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                            if iAdjacentLandZone == tPlateauAndLZ[2] then
                                                bIsAdjacent = true
                                            end
                                        end
                                        for iEntry, iPathLZ in tFirebaseLZData[M28Map.subrefLZPath] do
                                            if not(iPathLZ == iLandZone) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Friendly LZ that will pass through to get to firebase='..iPathLZ..'; Friendly combat threat of this='..(M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTThreatAllyCombatTotal] or 'nil')) end
                                                local tOtherFirebaseZoneTeamData = M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefLZTeamData][iTeam]
                                                iCurFirebaseThreat = iCurFirebaseThreat - (tOtherFirebaseZoneTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)
                                                iFirebaseCloseCombatThreat = iFirebaseCloseCombatThreat + (tOtherFirebaseZoneTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) - (tOtherFirebaseZoneTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)
                                                if not(bHaveSignificantCombatCloserToFirebase) and M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTThreatAllyCombatTotal] >= 4000 then
                                                    bHaveSignificantCombatCloserToFirebase = true
                                                end
                                            end
                                        end
                                    end
                                    if bIsAdjacent then
                                        --Track adjacent firebase threat so if we want to take this into account later we can; dont think we are double-counting this though so currently only using to affect decision on whether to automatically retreat
                                        iAdjacentFirebaseThreat = iAdjacentFirebaseThreat + math.max(iCurFirebaseThreat, 0)
                                    end
                                end
                            end
                            iFirebaseThreatAdjust = iFirebaseThreatAdjust + math.max(iCurFirebaseThreat, 0)
                        end
                    end
                else
                    iClosestFirebaseDist = 0
                end
            end
        end
    end

    --If enemy has a firebase, then retreat if we dont have enough threat to beat it and we dont have significant indirect force
    local bRunFromFirebase = false
    if bDebugMessages == true then LOG(sFunctionRef..': If enemy has nearby firebase will check if we have enough units to try and attack it, iFirebaseThreatAdjust='..iFirebaseThreatAdjust..'; bHaveSignificantCombatCloserToFirebase='..tostring(bHaveSignificantCombatCloserToFirebase or false)..'; iFirebaseCloseCombatThreat='..iFirebaseCloseCombatThreat) end
    if iFirebaseThreatAdjust > 0 and not(bHaveSignificantCombatCloserToFirebase) then
        if iAvailableCombatUnitThreat < math.min(20000, iFirebaseThreatAdjust) or (iAvailableCombatUnitThreat < iFirebaseThreatAdjust * 2) then
            --Retreat by default then check if have enough threat to attack
            bRunFromFirebase = true
            --Exception if we have fatboys or megaliths in which case compare to enemy long range threat as well
            if iAvailableCombatUnitThreat >= 8000 then
                local tFriendlyExperimental = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental, tAvailableCombatUnits)
                if bDebugMessages == true then LOG(sFunctionRef..': Will consider running from firebase, is table of firendly experimentals empty='..tostring(M28Utilities.IsTableEmpty(tFriendlyExperimental))) end
                if M28Utilities.IsTableEmpty(tFriendlyExperimental) == false then
                    local iLRExpThreat = 0
                    local bHaveDamagedFatboys = false
                    local bHaveFatboys = false
                    local iSRExpThreat = 0
                    local bHaveSRExpNearFirebaseUnit = false
                    for iUnit, oUnit in tFriendlyExperimental do
                        if (oUnit[M28UnitInfo.refiCombatRange] or 0) >= 60 then
                            local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, false)
                            if iMaxShield > 0 then
                                bHaveFatboys = true
                                if iCurShield > 0 then
                                    iLRExpThreat = iLRExpThreat + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * iCurShield / iMaxShield
                                    if iCurShield < iMaxShield * 0.7 then bHaveDamagedFatboys = true end
                                else bHaveDamagedFatboys = true
                                end
                            else
                                iLRExpThreat = iLRExpThreat + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * M28UnitInfo.GetUnitHealthPercent(oUnit)
                            end
                        end
                        --Include megalith in both LR and SR threats
                        if (oUnit[M28UnitInfo.refiDFRange] or 0) <= 80 and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) then
                            iSRExpThreat = iSRExpThreat + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * M28UnitInfo.GetUnitHealthPercent(oUnit)
                            if not(bHaveSRExpNearFirebaseUnit) and oClosestUnitFromAllFirebases and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestUnitFromAllFirebases:GetPosition()) <= oUnit[M28UnitInfo.refiCombatRange] + 10 then
                                bHaveSRExpNearFirebaseUnit = true
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iLRExpThreat='..iLRExpThreat..'; iSRExpThreat='..iSRExpThreat..'; bHaveSRExpNearFirebaseUnit='..tostring(bHaveSRExpNearFirebaseUnit or false)) end
                    if bHaveSRExpNearFirebaseUnit and (iAvailableCombatUnitThreat >= iFirebaseCloseCombatThreat * 0.8 or iSRExpThreat >= 8000) then
                        bRunFromFirebase = false
                    elseif iLRExpThreat > 0 then
                        local iEnemyT2ArtiThreat = 0
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
                            --Treat T2 arti as being worth twice their mass cost since we may be dealing with a fatboy
                            iEnemyT2ArtiThreat = M28UnitInfo.GetMassCostOfUnits(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits])
                            if bHaveFatboys then iEnemyT2ArtiThreat = iEnemyT2ArtiThreat * 1.25 end
                            if bHaveDamagedFatboys then iEnemyT2ArtiThreat = iEnemyT2ArtiThreat * 1.25 end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iLRExpThreat='..iLRExpThreat..'; tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat]='..tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat]..'; iEnemyT2ArtiThreat='..iEnemyT2ArtiThreat..'; bHaveFatboys='..tostring(bHaveFatboys or false)..'; iFirebaseCloseCombatThreat='..iFirebaseCloseCombatThreat) end
                        if iLRExpThreat > tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] + iEnemyT2ArtiThreat or (not(bHaveDamagedFatboys) and math.max(iAvailableCombatUnitThreat, iLRExpThreat) >= iFirebaseCloseCombatThreat * 2) then
                            bRunFromFirebase = false
                        end
                    end
                    if bRunFromFirebase and iSRExpThreat > 0 then
                        if iSRExpThreat > math.max(8000, iFirebaseCloseCombatThreat * 3) or ((iClosestFirebaseDist <= 80 or bHaveSignificantCombatCloserToFirebase) and iSRExpThreat >= math.max(7000, iFirebaseCloseCombatThreat * 2)) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have enough short range experimental threat to press the attack') end
                            bRunFromFirebase = false
                        end
                    end
                end
            end
            if bRunFromFirebase and iClosestFirebaseDist <= 100 then
                local tFriendlyIndirect = EntityCategoryFilterDown(M28UnitInfo.refCategoryIndirect, tAvailableCombatUnits)
                if M28Utilities.IsTableEmpty( tFriendlyIndirect) == false then
                    local iFriendlyIndirect = table.getn(tFriendlyIndirect)
                    if bDebugMessages == true then LOG(sFunctionRef..': Friendly indirect of all tech level='..iFriendlyIndirect) end
                    if iFriendlyIndirect >= 20 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Exception to decision to run from firebase') end
                        bRunFromFirebase = false
                        --if the firebase is close to a core base or we have MMLs in this zone or other zones that have recently damaged it then consider attacking anyway
                    else
                        local tFriendlyT2PlusIndirect = EntityCategoryFilterDown(categories.ALLUNITS - categories.TECH1, tFriendlyIndirect)
                        if M28Utilities.IsTableEmpty(tFriendlyT2PlusIndirect) == false then
                            iFriendlyIndirect = table.getn(tFriendlyT2PlusIndirect)
                            if iFriendlyIndirect >= 2 and M28UnitInfo.IsUnitValid(oClosestUnitFromAllFirebases) then
                                local iFirebasePlateau, iFirebaseZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oClosestUnitFromAllFirebases:GetPosition())
                                if (iFirebaseZone or 0) > 0 and (iFirebasePlateau or 0) > 0 then
                                    --If firebase direct fire range
                                    local tFirebaseLZTeamData = M28Map.tAllPlateaus[iFirebasePlateau][M28Map.subrefPlateauLandZones][iFirebaseZone][M28Map.subrefLZTeamData][iTeam]
                                    --Check enemy doesnt have ravager/equivalent that makes MML bad, or (if they do) that we have lots of T3+ MML
                                    if math.max((tFirebaseLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0), tFirebaseLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0) < 60 or iFriendlyIndirect >= 15 then

                                        if bDebugMessages == true then LOG(sFunctionRef..': Time since last had MML in this zone firing near TMD or shield='..(GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -30))..'; Dist from nearest firebase unit to base='..M28Utilities.GetDistanceBetweenPositions(oClosestUnitFromAllFirebases:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])..'; Time since firebase zone had a shield or TMD face a missile='..(GetGameTimeSeconds() - (tFirebaseLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -30))) end
                                        --If have MMLs that have recently damaged the firebase shields or been intercepted by TMD, consider if we have enough MMLs to overwhelm the firebase
                                        if GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -30) <= 30 or GetGameTimeSeconds() - (tFirebaseLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -10) <= 30 or (oClosestUnitFromAllFirebases and M28Utilities.GetDistanceBetweenPositions(oClosestUnitFromAllFirebases:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 200) then
                                            local iEnemyTMDCount = 0
                                            local iEnemyT2ArtiCount = 0
                                            local iOurMMLCount = 0
                                            local iOurNonMMLCount = 0
                                            local tOurMML = EntityCategoryFilterDown(M28UnitInfo.refCategoryMML, tFriendlyT2PlusIndirect)
                                            if M28Utilities.IsTableEmpty(tOurMML) == false then
                                                iOurMMLCount = table.getn(tOurMML)
                                            end
                                            iOurNonMMLCount = iFriendlyIndirect - iOurMMLCount
                                            if M28Utilities.IsTableEmpty(tFirebaseLZTeamData[M28Map.subreftoEnemyTMD]) == false then
                                                iEnemyTMDCount = table.getn(tFirebaseLZTeamData[M28Map.subreftoEnemyTMD])
                                            end
                                            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
                                                iEnemyT2ArtiCount = table.getn(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits])
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': iEnemyTMDCount='..iEnemyTMDCount..'; iOurMMLCount='..iOurMMLCount..'; iOurNonMMLCount='..iOurNonMMLCount..'; iEnemyT2ArtiCount='..iEnemyT2ArtiCount..'; Enemy shield threat='..(tFirebaseLZTeamData[M28Map.subrefLZThreatEnemyShield] or 0)) end
                                            if iEnemyT2ArtiCount == 0 or (iEnemyT2ArtiCount * 1.5 + (tFirebaseLZTeamData[M28Map.subrefLZThreatEnemyShield] or 0) / 1000 < (iOurNonMMLCount + math.max(0,(iOurMMLCount - iEnemyTMDCount)))) then
                                                bRunFromFirebase = false
                                                if bDebugMessages == true then LOG(sFunctionRef..': WIll try and attack firebase') end
                                            end
                                            if bRunFromFirebase and iOurMMLCount > 0 and M28Utilities.IsTableEmpty( tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                                --Revise MML count to factor in all adjacent zones
                                                local tThisZoneMML = EntityCategoryFilterDown(M28UnitInfo.refCategoryMML, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                                local iAltMMLCount = 0
                                                if M28Utilities.IsTableEmpty(tThisZoneMML) == false then
                                                    iAltMMLCount = table.getn(tThisZoneMML)
                                                end
                                                for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                                        tThisZoneMML = EntityCategoryFilterDown(M28UnitInfo.refCategoryMML, tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                                        if M28Utilities.IsTableEmpty(tThisZoneMML) == false then
                                                            iAltMMLCount = iAltMMLCount + table.getn(tThisZoneMML)
                                                        end
                                                    end
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': iAltMMLCount='..iAltMMLCount..'; iOurMMLCount='..iOurMMLCount..'; iEnemyT2ArtiCount='..iEnemyT2ArtiCount..'; Enemy shield threat='..(tFirebaseLZTeamData[M28Map.subrefLZThreatEnemyShield] or 0)..'; iEnemyTMDCount='..iEnemyTMDCount) end
                                                if iAltMMLCount > iOurMMLCount then
                                                    if (iEnemyT2ArtiCount * 1.5 + (tFirebaseLZTeamData[M28Map.subrefLZThreatEnemyShield] or 0) / 1000 < (iOurNonMMLCount + math.max(0,(iAltMMLCount - iEnemyTMDCount)))) then
                                                        bRunFromFirebase = false
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Hvae enough MML to attack') end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                if bRunFromFirebase then
                    if iAvailableCombatUnitThreat >= math.max(12000, iFirebaseCloseCombatThreat * 3) or (bHaveSignificantCombatCloserToFirebase and  iAvailableCombatUnitThreat >= math.max(7000, iFirebaseCloseCombatThreat * 2)) then
                        bRunFromFirebase = false

                    end
                end
            end
        end
    end

    --Flag that we are attacking this firebase so other zones can also attack it instead of running if they are in scenario 1
    if oClosestUnitFromAllFirebases and (iFriendlyBestMobileIndirectRange or 0) > math.max(tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0, tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0) then
        local tClosestFirebaseTeamData = M28Map.GetLandOrWaterZoneData(oClosestUnitFromAllFirebases:GetPosition(), true, iTeam)
        if tClosestFirebaseTeamData then
            if bDebugMessages == true then LOG(sFunctionRef..': Time since we last had a zone wanting to attack this firebase zone='..(tClosestFirebaseTeamData[M28Map.refiTimeOfLastIndirectFirebaseAttack] or 'nil')) end
            if bRunFromFirebase == false then
                tClosestFirebaseTeamData[M28Map.refiTimeOfLastIndirectFirebaseAttack] = GetGameTimeSeconds()
            elseif GetGameTimeSeconds() - (tClosestFirebaseTeamData[M28Map.refiTimeOfLastIndirectFirebaseAttack] or -100) <= 3 then
                bRunFromFirebase = false
            end
        end
    end

    local bRunFromEnemyAir = false
    if iFirebaseThreatAdjust == 0 and tLZTeamData[M28Map.refiModDistancePercent] <= 0.75 and tLZTeamData[M28Map.subrefLZMAAThreatWanted] >= 50 and not(M28Team.tAirSubteamData[ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].M28AirSubteam][M28Team.refbHaveAirControl]) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 400 then
        local iNetEnemyAirToGroundThreat = tLZTeamData[M28Map.refiEnemyAirToGroundThreat] - tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] * 2 - tLZTeamData[M28Map.subrefLZThreatAllyMAA] * 4
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                iNetEnemyAirToGroundThreat = iNetEnemyAirToGroundThreat + math.max(0, tLZTeamData[M28Map.refiEnemyAirToGroundThreat] - tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] * 2) - tLZTeamData[M28Map.subrefLZThreatAllyMAA] * 4
            end
        end
        if iNetEnemyAirToGroundThreat >= math.max(200, iAvailableCombatUnitThreat * 0.1) then
            bRunFromEnemyAir = true
            --If in enemy base/threatening enemy buildings then dont run
            local iNearbyEnemyBuildingValue = 0
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                local tNearbyEnemyBuildings = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryPD, tLZTeamData[M28Map.subrefTEnemyUnits])
                iNearbyEnemyBuildingValue = M28UnitInfo.GetMassCostOfUnits(tNearbyEnemyBuildings)
            end
            if iNearbyEnemyBuildingValue >= math.min(2000, iAvailableCombatUnitThreat * 0.2) then
                bRunFromEnemyAir = false
            end
        end
    end

    local bSuicideIntoFatboyOrACU = false
    local oClosestFatboyOrACUInIslandToSuicideInto
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets]) == false then
        local iCurACUDist
        local iClosestACUDist = 150 --Wont try and suicide if are further away than this
        for iACU, oACU in M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets] do
            if M28UnitInfo.IsUnitValid(oACU) and not(M28UnitInfo.IsUnitUnderwater(oACU)) and not(oACU:IsUnitState('Attached')) then
                --Require enemy health to be < 2*our available combat threat, or sub-1k
                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to charge into enemy ACU, ACU health='..oACU:GetHealth()..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; Dist to LZ midpoint='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZData[M28Map.subrefMidpoint])) end
                if oACU:GetHealth() < math.max(1000, iAvailableCombatUnitThreat * 2) then
                    iCurACUDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                    if iCurACUDist <= iClosestACUDist then
                        oClosestFatboyOrACUInIslandToSuicideInto = oACU
                        bSuicideIntoFatboyOrACU = true
                        iClosestACUDist = iCurACUDist
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished considering if there is an ACU we should try and snipe, bSuicideIntoFatboyOrACU='..tostring(bSuicideIntoFatboyOrACU)..'; oClosestFatboyOrACUInIslandToSuicideInto='..(oClosestFatboyOrACUInIslandToSuicideInto.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestFatboyOrACUInIslandToSuicideInto) or 'nil')..'; Time='..GetGameTimeSeconds()) end
    end
    if not(oClosestFatboyOrACUInIslandToSuicideInto) and iAvailableCombatUnitThreat >= 5000 and iFriendlyBestMobileDFRange > 15 and tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] >= 1000 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats]) == false then
        local tEnemyFatboy = EntityCategoryFilterDown(M28UnitInfo.refCategoryFatboy, tLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats])
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy fatboy empty='..tostring(M28Utilities.IsTableEmpty(tEnemyFatboy))) end
        if M28Utilities.IsTableEmpty(tEnemyFatboy) == false then
            local iClosestDistToMidpoint = 100000
            local iCurDist
            for iUnit, oUnit in tEnemyFatboy do
                if M28UnitInfo.IsUnitValid(oUnit) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Fatboy='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; land label='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition()) or 'nil')..'; LZ island ref='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..'; Dist to midpoint='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])) end
                    if NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition()) == tLZData[M28Map.subrefLZIslandRef] then
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                        if iCurDist < iClosestDistToMidpoint then
                            iClosestDistToMidpoint = iCurDist
                            oClosestFatboyOrACUInIslandToSuicideInto = oUnit
                        end
                    end
                end
            end
            if oClosestFatboyOrACUInIslandToSuicideInto then
                --Cycle through available DF units (if we have any)
                local tT3PlusDF = EntityCategoryFilterDown(categories.DIRECTFIRE - categories.TECH1 - categories.TECH2, tAvailableCombatUnits)
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of T3PlusDF units empty='..tostring(M28Utilities.IsTableEmpty(tT3PlusDF))) end
                if M28Utilities.IsTableEmpty(tT3PlusDF) == false then
                    local oClosestFriendlyDFUnitToFatboy = M28Utilities.GetNearestUnit(tT3PlusDF, oClosestFatboyOrACUInIslandToSuicideInto:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': oClosestFriendlyDFUnitToFatboy='..(oClosestFriendlyDFUnitToFatboy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestFriendlyDFUnitToFatboy) or 'nil')..'; oClosestFatboyOrACUInIslandToSuicideInto='..oClosestFatboyOrACUInIslandToSuicideInto.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestFatboyOrACUInIslandToSuicideInto)..'; Dist between them='..M28Utilities.GetDistanceBetweenPositions(oClosestFriendlyDFUnitToFatboy:GetPosition(), oClosestFatboyOrACUInIslandToSuicideInto:GetPosition())..'; oClosestFriendlyDFUnitToFatboy='..(oClosestFriendlyDFUnitToFatboy[M28UnitInfo.refiDFRange] or 'nil')) end
                    if oClosestFriendlyDFUnitToFatboy and M28Utilities.GetDistanceBetweenPositions(oClosestFriendlyDFUnitToFatboy:GetPosition(), oClosestFatboyOrACUInIslandToSuicideInto:GetPosition()) <= math.max(25 + iFriendlyBestMobileDFRange, 35 + (oClosestFriendlyDFUnitToFatboy[M28UnitInfo.refiDFRange] or 0)) then
                        bSuicideIntoFatboyOrACU = true
                    end
                end
            end
        end


    end

    local bGivenCombatUnitsOrders = false

    if bDebugMessages == true then LOG(sFunctionRef..': iFirebaseThreatAdjust='..iFirebaseThreatAdjust..'; bRunFromFirebase='..tostring(bRunFromFirebase)..'; tLZTeamData[M28Map.subreftEnemyFirebasesInRange]='..reprs(tLZTeamData[M28Map.subreftEnemyFirebasesInRange])..'; subrefiNearbyEnemyLongRangeThreat='..tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat]..'; Enemies in adj wZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])..'; iFirebaseCloseCombatThreat='..iFirebaseCloseCombatThreat..'; bRunFromEnemyAir='..tostring(bRunFromEnemyAir)..'; bSuicideIntoFatboyOrACU='..tostring(bSuicideIntoFatboyOrACU)) end
    --If we have a fatboy in our available combat units, then do getunitsaroundpoint to check for signficant threats that might not be in an adjacent zone, and then add them as direct fire units against this zone so they get incorporated into checks for nearby enemies
    local tUnitsNearFatboyInFurtherAwayZones
    local iVisibleDFMassInFatboyRange = 0
    if iFriendlyBestMobileDFRange >= 90 then
        --Get fatboy closest to enemy base
        local tFriendlyFatboys = EntityCategoryFilterDown(M28UnitInfo.refCategoryFatboy, tAvailableCombatUnits)
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of friendly fatboys empty='..tostring(M28Utilities.IsTableEmpty(tFriendlyFatboys))) end
        if M28Utilities.IsTableEmpty(tFriendlyFatboys) == false then
            local oClosestFatboyToEnemy
            if not(tFriendlyFatboys[2]) then
                oClosestFatboyToEnemy = tFriendlyFatboys[1]
            else
                oClosestFatboyToEnemy = M28Utilities.GetNearestUnit(tFriendlyFatboys, tLZTeamData[M28Map.reftClosestEnemyBase])
            end
            if bDebugMessages == true then LOG(sFunctionRef..': oClosestFatboyToEnemy='..oClosestFatboyToEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestFatboyToEnemy)) end
            if oClosestFatboyToEnemy then
                local tAllDangerousCombatNearFatboy = oClosestFatboyToEnemy:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryDestroyer + M28UnitInfo.refCategoryBattleship + M28UnitInfo.refCategoryBattlecruiser, oClosestFatboyToEnemy:GetPosition(), (oClosestFatboyToEnemy[M28UnitInfo.refiDFRange] or 0), 'Enemy')
                if bDebugMessages == true then LOG(sFunctionRef..': is tAllDangerousCombatNearFatboy empty='..tostring(M28Utilities.IsTableEmpty(tAllDangerousCombatNearFatboy))..'; Fatboy range='..(oClosestFatboyToEnemy[M28UnitInfo.refiDFRange] or 0)) end
                if M28Utilities.IsTableEmpty(tAllDangerousCombatNearFatboy) == false then
                    iVisibleDFMassInFatboyRange = M28UnitInfo.GetMassCostOfUnits(tAllDangerousCombatNearFatboy)
                    local tbAdjacentLZ = {}
                    tUnitsNearFatboyInFurtherAwayZones = {}
                    for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        tbAdjacentLZ[iAdjLZ] = true
                    end
                    tbAdjacentLZ[iLandZone] = true
                    for iEnemy, oEnemy in tAllDangerousCombatNearFatboy do
                        if bDebugMessages == true and M28UnitInfo.IsUnitValid(oEnemy) then LOG(sFunctionRef..': Have dangerous enemy '..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; Assigned plateau and LZ='..repru(oEnemy[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam])..'; Adjacent LZs='..repru(tbAdjacentLZ)..'; Assigned WZ='..(oEnemy[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] or 'nil')) end
                        if not(tbAdjacentLZ[oEnemy[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]]) or not(oEnemy[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] == iPlateau) then
                            if M28UnitInfo.IsUnitValid(oEnemy) then
                                if oEnemy[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] then tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] = true
                                elseif oEnemy[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] then tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = true
                                end
                                table.insert(tLZTeamData[M28Map.reftoNearestDFEnemies], oEnemy)
                                table.insert(tUnitsNearFatboyInFurtherAwayZones, oEnemy)
                                if bDebugMessages == true then LOG(sFunctionRef..': Adding enemy to table of nearest DF units and to units near fatboy in further away zones') end
                            end
                        end
                    end
                end
            end
        end
    end

    local bIgnoreEnemiesInThisZone = false
    local tbAdjacentZoneEnemiesToIgnoreByZone = {}
    local bConsiderEnemiesInAtLeastOneAdjacentZone = true
    --Only consider if we have a fairly large force for our tech level; in which case will only send a small part of our army to deal with the enemy
    if iAvailableCombatUnitThreat >= 300 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] then
        --Consider this zone first (no point ignoring enemies in adj zone if wont be ignoring in this zone); no cap as we will just send a smaller (but still large enough) force to deal with enemy threats if ignoring
        if iAvailableCombatUnitThreat >= tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 10 and iAvailableCombatUnitThreat >= (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] + tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]) * 6 then
            bIgnoreEnemiesInThisZone = true
            --Record which units in adjacent zones we should ignore
            bConsiderEnemiesInAtLeastOneAdjacentZone = false
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                if iAvailableCombatUnitThreat >= (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 10 and iAvailableCombatUnitThreat >= (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] + (tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0)) * 6 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Ignoring iAdjLZ='..iAdjLZ..' due to it having too low a threat, enemy combat total for adj LZ='..(tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)) end
                    tbAdjacentZoneEnemiesToIgnoreByZone[iAdjLZ] = true
                else
                    bConsiderEnemiesInAtLeastOneAdjacentZone = true
                end
            end
        end
    end

    --If enemy has units in this or adjacent LZ, then decide what to do
    if (tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) and (bSuicideIntoFatboyOrACU or not(bRunFromFirebase) and not(bRunFromEnemyAir)) then
        --Cloaked units - flag we want spy plane if we have any land experimentals
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if have nearby cloaked enemy units if we have a large threat, iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; Is table of cloaked enemy units empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits]))..'; iVisibleDFMassInFatboyRange='..iVisibleDFMassInFatboyRange) end
        if iAvailableCombatUnitThreat >= 10000 and M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits]) then
            local tFriendlyLandExperimentals = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental, tAvailableCombatUnits)
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of friendly land experimentals empty='..tostring(M28Utilities.IsTableEmpty(tFriendlyLandExperimentals))) end
            if M28Utilities.IsTableEmpty(tFriendlyLandExperimentals) == false then
                local toExperimentalsNearCloakedUnit = {}
                for iCloaked, oCloaked in M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits] do
                    for iExperimental, oExperimental in tFriendlyLandExperimentals do
                        if bDebugMessages == true then LOG(sFunctionRef..': oExperimental='..oExperimental.UnitId..M28UnitInfo.GetUnitLifetimeCount(oExperimental)..'; oCloaked='..oCloaked.UnitId..M28UnitInfo.GetUnitLifetimeCount(oCloaked)..'; Dist from experimental to cloaked='..M28Utilities.GetDistanceBetweenPositions(oExperimental:GetPosition(), oCloaked:GetPosition())) end
                        if M28Utilities.GetDistanceBetweenPositions(oExperimental:GetPosition(), oCloaked:GetPosition()) <= 80 then
                            table.insert(toExperimentalsNearCloakedUnit, oExperimental)
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Is toExperimentalsNearCloakedUnit empty='..tostring(M28Utilities.IsTableEmpty(toExperimentalsNearCloakedUnit))) end
                if M28Utilities.IsTableEmpty(toExperimentalsNearCloakedUnit) == false then
                    for iUnit, oUnit in toExperimentalsNearCloakedUnit do
                        M28Air.AddUnitWantingPriorityScout(oUnit)
                    end
                end
            end
        end

        local bEnemyHasNoDFUnits
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] then bEnemyHasNoDFUnits = false
        else
            bEnemyHasNoDFUnits = M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies])
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Checking for nearest enemy to midpoint, bEnemyHasNoDFUnits='..tostring(bEnemyHasNoDFUnits)..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))) end

        local oNearestEnemyToFriendlyBase
        local bConsiderAttackingACU = false
        local toEnemyACUsInZone = {}
        local oNearestEnemyStructureToMidpoint
        local iClosestDist = 100000
        local iClosestStructureDist = 100000
        local iCurDist
        local iEnemyBestDFRange = math.max(iEnemyBestMobileDFRange, iEnemyBestStructureDFRange)
        local bNotCloseToAdjacentPD = false
        --If enemy DF structures are in an adjacent zone then only include their range for this decision if they are near enough
        if (tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0) < iEnemyBestStructureDFRange and iEnemyBestStructureDFRange > iEnemyBestMobileDFRange and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoAdjacentStructuresWithHighRange]) == false then
            --Adjacent structures are providing the best enemy DF range; would we outrange the enemy if it wasnt for these?
            if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false and math.max((iFriendlyBestMobileDFRange or 0), (iFriendlyBestMobileIndirectRange or 0)) > math.max(iEnemyBestMobileDFRange, (tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0)) then
                --Get enemy longer range PD in adjacent zone closest to this zone midpoint, so can see if it is almost in range of any allied units
                local oClosestPD
                for iUnit, oUnit in tLZTeamData[M28Map.reftoAdjacentStructuresWithHighRange] do
                    if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then --redundancy
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) - oUnit[M28UnitInfo.refiDFRange]
                        if iCurDist < iClosestDist then
                            iClosestDist = iCurDist
                            oClosestPD = oUnit
                        end
                    end
                end
                bNotCloseToAdjacentPD = true
                if oClosestPD and iClosestDist <= 200 then
                    local iThreshold = 10 --If within 10 of being in range then recognise the range on the unit
                    for iUnit, oUnit in tAvailableCombatUnits do
                        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestPD:GetPosition()) - oClosestPD[M28UnitInfo.refiDFRange] - iThreshold <= 0 then
                            bNotCloseToAdjacentPD = false
                            break
                        end
                    end
                end
                if bNotCloseToAdjacentPD then
                    iEnemyBestStructureDFRange =     (tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0)
                    iEnemyBestDFRange = math.max(iEnemyBestMobileDFRange, iEnemyBestStructureDFRange)
                    if bDebugMessages == true then LOG(sFunctionRef..': Closest PD is far enough away from our units that we can ignore its range when deciding what scenario we are in, oClosestPD='..(oClosestPD.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestPD) or 'nil')..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iEnemyBestDFRange after update='..iEnemyBestDFRange..'; Time='..GetGameTimeSeconds()) end
                end
                iClosestDist = 100000
            end

        end


        local bNearestEnemyNeedsManualAttack = false --If nearest enemy is below water with its base but still visible on the top then units wont fire at it unless given a specific attack order
        local tEnemyEngineers = {} --So can avoid getting in reclaim range, and consider targeting as a priority
        local tSkirmisherEnemies = {}

        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefMidpoint]) then
                --Got an error in coop so put in below as a redundancy in case had no midpoint (but couldve been another reason)
                M28Utilities.ErrorHandler('Dont have midpoint for P'..iPlateau..'Z'..iLandZone..'; will try and rerecord')
                M28Map.RecordMidpointAndOtherDataForZone(iPlateau, iLandZone, tLZData)
            end
            tEnemyEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subrefTEnemyUnits])
            if not(tEnemyEngineers) then tEnemyEngineers = {} end
            for iUnit, oUnit in tLZTeamData[M28Map.subrefTEnemyUnits] do
                --Add ACUs as potential high priority targets if they are on land
                if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) and M28UnitInfo.CanSeeUnit(M28Team.GetFirstActiveM28Brain(iTeam), oUnit) then
                    table.insert(toEnemyACUsInZone, oUnit)
                    if not(oNearestEnemyToFriendlyBase) then oNearestEnemyToFriendlyBase = oUnit iClosestDist = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], (oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or oUnit:GetPosition())) end
                end
                if not(bIgnoreEnemiesInThisZone) then
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], (oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or oUnit:GetPosition()))
                    if iCurDist < iClosestDist then
                        iClosestDist = iCurDist
                        oNearestEnemyToFriendlyBase = oUnit
                    end
                    if iCurDist < iClosestStructureDist and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) and oUnit:GetFractionComplete() >= 0.5 then
                        iClosestStructureDist = iCurDist
                        oNearestEnemyStructureToMidpoint = oUnit
                    end
                    if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then table.insert(tSkirmisherEnemies, oUnit) end
                end
            end
        end
        if M28Utilities.IsTableEmpty(toEnemyACUsInZone) == false and tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] >= 3000 then
            bConsiderAttackingACU = true
        end

        local bOnlyCheckForStructure = true
        if not(oNearestEnemyToFriendlyBase) then bOnlyCheckForStructure = false end



        function GetUnitToAttackNearestACU(oUnit)
            local oClosestACUToAttack
            local iClosestACU = 100000
            local iCurACUDist
            for iACU, oACU in toEnemyACUsInZone do
                iCurACUDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())
                if iCurACUDist < iClosestACU then
                    iClosestACU = iCurACUDist
                    oClosestACUToAttack = oACU
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' should do attack order on ACU or move to it, iClosestACU='..iClosestACU..'; oUnit[M28UnitInfo.refiDFRange]='..oUnit[M28UnitInfo.refiDFRange]..'; oUnit[M28UnitInfo.refbLastShotBlocked]='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked] or false)..'; Do we expect shot to be blocked='..tostring(M28Logic.IsShotBlocked(oUnit, oClosestACUToAttack))) end

            if oUnit[M28UnitInfo.refiDFRange] - iClosestACU >= 5 and (not(oUnit[M28UnitInfo.refbLastShotBlocked]) and (not(EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oUnit.UnitId)) or not(M28Logic.IsShotBlocked(oUnit, oClosestACUToAttack)))) then --ACU more than 5 inside our range - attack it unless our shot is blocked
                M28Orders.IssueTrackedAttack(oUnit, oClosestACUToAttack, false, 'ACUEAt', false)
            else
                M28Orders.IssueTrackedMove(oUnit, oClosestACUToAttack:GetPosition(), (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.4, false, 'ACUEMv'..iLandZone, false)
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to search adjacent land zones for enemies closer to the midpoint; bOnlyCheckForStructure='..tostring(bOnlyCheckForStructure)..'; oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase) or 'nil')..'; oNearestEnemyStructureToMidpoint='..(oNearestEnemyStructureToMidpoint.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyStructureToMidpoint) or 'nil')) end
        local bEnemyHasFixedShieldsInThisOrAdjacentZone = false
        if (tLZTeamData[M28Map.subrefLZThreatEnemyShield] or 0) > 0 then bEnemyHasFixedShieldsInThisOrAdjacentZone = true end

        if bHaveCombatUnitsFromAdjZone or not(oNearestEnemyToFriendlyBase) or not(oNearestEnemyStructureToMidpoint) or (bIgnoreEnemiesInThisZone and bConsiderEnemiesInAtLeastOneAdjacentZone) then
            local iModifiedHighestEnemyValue
            if iAvailableCombatUnitThreat >= 300 then
                iModifiedHighestEnemyValue = (tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) + (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) + (tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)
                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                    iModifiedHighestEnemyValue = math.max(1, iModifiedHighestEnemyValue, (tAdjLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) + (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0))
                end
            end
            if iModifiedHighestEnemyValue then iModifiedHighestEnemyValue = iModifiedHighestEnemyValue * 0.75 end --dont worry about adjusting distances if have locations similar in value
            if bDebugMessages == true then LOG(sFunctionRef..': iModifiedHighestEnemyValue='..(iModifiedHighestEnemyValue or 'nil')) end
            local iDistMod
            function UpdateForUnitsInAdjacentZone(tAdjLZTeamData)
                if iModifiedHighestEnemyValue and iAvailableCombatUnitThreat >= 3000 and iModifiedHighestEnemyValue >= 1500 and (iModifiedHighestEnemyValue >= 5000 or (tAdjLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) < 1800) then --primarily want the logic for things like experimentals
                    iDistMod = math.max(1,3 - 2 * ((tAdjLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) + (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)) / iModifiedHighestEnemyValue) --i.e. no adjust for highest value zone, down to x3 (i.e. +200%) distance for 0 value structure zone
                    if iDistMod == 1 then iDistMod = nil end
                else
                    iDistMod = nil
                end
                for iUnit, oUnit in tAdjLZTeamData[M28Map.subrefTEnemyUnits] do
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                            table.insert(tEnemyEngineers, oUnit)
                        elseif (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then
                            table.insert(tSkirmisherEnemies, oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': recording in tSkirmisherEnemies the enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                        end --we might be controlling untis in an adjacent zone that have an enemy unit/engeiner near them
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurdist='..M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; iClosestDist='..iClosestDist..'; iClosestStructureDist='..iClosestStructureDist..'; iDistMod='..(iDistMod or 'nil')..'; bOnlyCheckForStructure='..tostring(bOnlyCheckForStructure)) end
                        if bOnlyCheckForStructure then
                            if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) and oUnit:GetFractionComplete() >= 0.5 then
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                                if iDistMod and not(EntityCategoryContains(M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryLandCombat * categories.EXPERIMENTAL, oUnit.UnitId)) then
                                    iCurDist = iCurDist * iDistMod
                                end
                                if iCurDist < iClosestStructureDist and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) then
                                    iClosestStructureDist = iCurDist
                                    oNearestEnemyStructureToMidpoint = oUnit
                                end
                            end
                        else
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                            if iDistMod then iCurDist = iCurDist * iDistMod end
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oNearestEnemyToFriendlyBase = oUnit
                            end
                            if iCurDist < iClosestStructureDist and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) and oUnit:GetFractionComplete() >= 0.5 then
                                iClosestStructureDist = iCurDist
                                oNearestEnemyStructureToMidpoint = oUnit
                            end
                        end
                    end
                end
                if not(bEnemyHasFixedShieldsInThisOrAdjacentZone) and (tAdjLZTeamData[M28Map.subrefLZThreatEnemyShield] or 0) > 0 then bEnemyHasFixedShieldsInThisOrAdjacentZone = true end
            end
            function GetCombatThreatFromAdjacentZone(tAdjLZTeamData, bAdjustStructureThreat)
                local iAdjCombatThreat = math.max((tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 0.5, (tAdjLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0) + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0))
                if bAdjustStructureThreat and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will reduce adjacent threat by structure threat, tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]='..repru(tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange])) end
                    for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                        if iRange <= 65 then
                            iAdjCombatThreat = iAdjCombatThreat - iThreat * 0.8
                        end
                    end
                end
                return iAdjCombatThreat
            end
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]))..'; tbAdjacentZoneEnemiesToIgnoreByZone='..tostring(tbAdjacentZoneEnemiesToIgnoreByZone[iAdjLZ] or false)) end
                    if not(tbAdjacentZoneEnemiesToIgnoreByZone[iAdjLZ]) then
                        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                            UpdateForUnitsInAdjacentZone(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam])
                        end
                    end
                end
            end
            if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
                for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                    UpdateForUnitsInAdjacentZone(M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam])
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Do we have a valid oNearestEnemyToFriendlyBase='..tostring(M28UnitInfo.IsUnitValid(oNearestEnemyToFriendlyBase))..'; Are there enemies in adjacnet WZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])..'; tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])) end

            if not(oNearestEnemyToFriendlyBase) and tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                --Consider adjacent water zone enemies (will only consider mobile - i.e. wont update nearest structure unless we're already considering the WZ for a nearest enemy to midpoint)
                local iCurWZ, iCurPond
                for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                    iCurWZ = tSubtable[M28Map.subrefAWZRef]
                    iCurPond = M28Map.tiPondByWaterZone[iCurWZ]
                    local tWZTeamData = M28Map.tPondDetails[iCurPond][M28Map.subrefPondWaterZones][iCurWZ][M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': iCurWZ='..(iCurWZ or 'nil')..'; iCurPond='..(iCurPond or 'nil')..'; tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..(tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')) end
                    if tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 or tWZTeamData[M28Map.subrefWZThreatEnemyAA] > 0 then
                        for iUnit, oUnit in tWZTeamData[M28Map.subrefTEnemyUnits] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to add oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; to nearest enemy to midpoint; Is it valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Is it underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; iClosestDist='..iClosestDist) end
                            if M28UnitInfo.IsUnitValid(oUnit) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) and not(EntityCategoryContains(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryHydro + M28UnitInfo.refCategoryLandScout, oUnit.UnitId)) then
                                --Do based on dist to zone midpoint instead of closest friendly base, since it coudl be really far away from this zone (but closer to our base)
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                                if iCurDist < iClosestDist then
                                    iClosestDist = iCurDist
                                    oNearestEnemyToFriendlyBase = oUnit
                                end
                                --Note - below effectively means are only considering structures in water if the WZ has combat units in it and there are no enemy units on land nearby (so isn't 100% accurate)
                                if iCurDist < iClosestStructureDist and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) and oUnit:GetFractionComplete() >= 0.5 then
                                    iClosestStructureDist = iCurDist
                                    oNearestEnemyStructureToMidpoint = oUnit
                                end
                            end
                        end
                        if oNearestEnemyToFriendlyBase then
                            --Check if need manual attack order
                            if EntityCategoryContains(M28UnitInfo.refCategoryAmphibious, oNearestEnemyToFriendlyBase.UnitId) then bNearestEnemyNeedsManualAttack = true end
                        end
                    end
                end
                if not(oNearestEnemyToFriendlyBase) and bSuicideIntoFatboyOrACU and oClosestFatboyOrACUInIslandToSuicideInto then oNearestEnemyToFriendlyBase = oClosestFatboyOrACUInIslandToSuicideInto end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished checking adjacent water zones for enemy units, iClosestDist='..iClosestDist..'; oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase) or 'nil')) end
            end
            if not(oNearestEnemyToFriendlyBase) and M28Utilities.IsTableEmpty(tUnitsNearFatboyInFurtherAwayZones) == false then
                for iUnit, oUnit in tUnitsNearFatboyInFurtherAwayZones do
                    --Do based on dist to this midpoint instead of closest friendly base since not dealing with units in this zone
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                    if iCurDist < iClosestDist then
                        iClosestDist = iCurDist
                        oNearestEnemyToFriendlyBase = oUnit
                    end
                end
            end
            if not(oNearestEnemyToFriendlyBase) then
                if not(bIgnoreEnemiesInThisZone) or bConsiderEnemiesInAtLeastOneAdjacentZone then
                    if bDebugMessages == true then LOG(sFunctionRef..': LZ has flagged it has enemies here or in adjacent LZ but couldnt find any; iPlateau='..iPlateau..'; LZ='..iLandZone) end
                    tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] = false
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for nearest enemy unit, is it valid='..tostring(M28UnitInfo.IsUnitValid(oNearestEnemyToFriendlyBase))) end
        function AddUnitFromAdjacentZoneToTableIfCloseEnough(tAdjLZTeamData, tNearbyAdjacentEnemies, iAdjacentDistThreshold, iStructureFurtherDistAdjust, iAngleFromClosestFriendlyUnitToMidpoint)
            --Only include units in the threat calculation if they are close enough to this LZ, or we have a firebase threat adjust
            if tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 10 then
                iEnemyBestStructureDFRange = math.max(iEnemyBestStructureDFRange, (tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0))
                local tPotentialEnemyUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryPD, tAdjLZTeamData[M28Map.subrefTEnemyUnits])
                if M28Utilities.IsTableEmpty(tPotentialEnemyUnits) == false then
                    local iDistUntilInRange
                    local bAdd = false
                    for iUnit, oUnit in tPotentialEnemyUnits do
                        bAdd = false
                        if oUnit:GetFractionComplete() >= 0.95 and M28UnitInfo.IsUnitValid(oUnit) then
                            iDistUntilInRange = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) - math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0))
                            if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) then
                                if iDistUntilInRange  <= iAdjacentDistThreshold + iStructureFurtherDistAdjust then
                                    if iDistUntilInRange <= 20 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': PD is almost within its DF range of the midpoint of target zone, oUnit[M28UnitInfo.refiDFRange]='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; iDistUntilInRange='..iDistUntilInRange) end
                                        bAdd = true
                                    elseif iDistUntilInRange * 2 <= math.min(40, iAdjacentDistThreshold + iStructureFurtherDistAdjust) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': PD is within half of the target range even after applying structure dist adj, iAdjacentDistThreshold + iStructureFurtherDistAdjust='..iAdjacentDistThreshold + iStructureFurtherDistAdjust) end
                                        bAdd = true
                                    elseif M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]), iAngleFromClosestFriendlyUnitToMidpoint) <= 50 then
                                        bAdd = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': Angle dif is low enough that we are including PD, angle dif='..M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]), iAngleFromClosestFriendlyUnitToMidpoint)) end
                                    end
                                end
                            else
                                if iDistUntilInRange  <= iAdjacentDistThreshold then
                                    bAdd = true
                                end
                            end
                            if bAdd then
                                if bDebugMessages == true then
                                    LOG(sFunctionRef..': Adding enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to adjacent enemies, iDistUntilInRange='..iDistUntilInRange)
                                    LOG('threat of this unit='..M28UnitInfo.GetCombatThreatRating({oUnit}, true)..'; Fraction complete='..oUnit:GetFractionComplete()..'; iDistUntilInRange of midpoint='..iDistUntilInRange..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Angle to midpoint='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])..'; iAngleFromClosestFriendlyUnitToMidpoint='..(iAngleFromClosestFriendlyUnitToMidpoint or 'nil'))
                                end
                                table.insert(tNearbyAdjacentEnemies, oUnit)
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': AddUnitFromAdjacentZoneToTableIfCloseEnough - Threat of all enemy units='..M28UnitInfo.GetCombatThreatRating(tAdjLZTeamData[M28Map.subrefTEnemyUnits], true)..'; Threat of tPotentialEnemyUnits='..M28UnitInfo.GetCombatThreatRating(tPotentialEnemyUnits, true)..'; Threat of tNearbyAdjacentEnemies (which includes cumulative htreat of other adj zones before this one)='..M28UnitInfo.GetCombatThreatRating(tNearbyAdjacentEnemies, true)) end
            end
        end

        function GetManualAttackTargetIfWantManualAttack(oUnit, oOptionalPrimaryTarget)
            local oManualAttackTarget
            if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack - Considering if want oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to pick a target for a manual attack, unit DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Is table of nearby enemy units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]))..'; Can we see nearest enemy to midpoint='..tostring(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oNearestEnemyToFriendlyBase))..'; Dist to nearest enemy='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition())..'; Is unit shot blocked='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked] or false)..'; refiTimeOfLastUnblockedShot='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or 0)) end
            --ACU snipe target that are in range of
            if bSuicideIntoFatboyOrACU and oClosestFatboyOrACUInIslandToSuicideInto and ((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or ((oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0 and EntityCategoryContains(M28UnitInfo.refCategoryLandCombat, oUnit.UnitId))) then
                --Are we almost 5 within range of the ACU/fatboy target, and it is an ACU (as for a fatboy t might be good to get close so we are under the shield)? if so then have as manual attack target
                if bDebugMessages == true then LOG(sFunctionRef..': Dist to oClosestFatboyOrACUInIslandToSuicideInto='..M28Utilities.GetDistanceBetweenPositions(oClosestFatboyOrACUInIslandToSuicideInto:GetPosition(), oUnit:GetPosition())..'; Combat range='..oUnit[M28UnitInfo.refiCombatRange]) end
                if M28Utilities.GetDistanceBetweenPositions(oClosestFatboyOrACUInIslandToSuicideInto:GetPosition(), oUnit:GetPosition()) < (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) - 5 then
                    return oClosestFatboyOrACUInIslandToSuicideInto
                end
            end

            --Note - in some cases the nearest enemy unit to the midpoint may be much further away than our units, if our units are from an adjacent zone or have just entered the cur zone, therefore if dealing with an experimental friendly unit want to do more detailed check of all nearby enemy units
            if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), (oOptionalPrimaryTarget or oNearestEnemyToFriendlyBase)) then --and (EntityCategoryContains(categories.EXPERIMENTAL + categories.TECH3, oUnit.UnitId) or M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition()) < (oUnit[M28UnitInfo.refiDFRange] or 0)) then
                --Nearest enemy is inside our range, is there another high value target that we should target?
                if EntityCategoryContains(categories.TECH3 + categories.EXPERIMENTAL, oUnit.UnitId) then

                    local iCategoryToSearch = M28UnitInfo.refCategoryLandExperimental + categories.COMMAND
                    --Ythotha - also consider enemy T3 land combat to try and avoid it constantly changing targets

                    --Below is if wanted to generalise, however concerned about riks of overkill
                    --[[
                    local iCategoryToSearch = M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategoryPD
                    local iUnitTechLevel = M28UnitInfo.GetUnitTechLevel(oUnit)
                    if iUnitTechLevel == 2 then
                        iCategoryToSearch = iCategoryToSearch - categories.TECH1
                    elseif iUnitTechLevel == 3 then
                        iCategoryToSearch = iCategoryToSearch - categories.TECH1 - categories.TECH2
                    elseif iUnitTechLevel == 4 then
                        iCategoryToSearch = iCategoryToSearch * categories.EXPERIMENTAL
                    end--]]
                    local tNearbyEnemiesOfCategory = EntityCategoryFilterDown(iCategoryToSearch, tLZTeamData[M28Map.reftoNearestDFEnemies])
                    local iClosestEnemyOfCategory = 10000
                    local iCurDistOfCategory
                    local iCurHealth
                    local iLowestHealth = 10000000
                    if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack - Is tNearbyEnemiesOfCategory empty='..tostring(M28Utilities.IsTableEmpty(tNearbyEnemiesOfCategory))) end
                    if M28Utilities.IsTableEmpty(tNearbyEnemiesOfCategory) == false then

                        for iEnemy, oEnemy in tNearbyEnemiesOfCategory do
                            if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack - Considering oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; Is this the same as nearest enemy to midpoint='..tostring(oEnemy == oNearestEnemyToFriendlyBase)..'; Fraction complete='..oEnemy:GetFractionComplete()) end
                            if oEnemy:GetFractionComplete() == 1 then
                                iCurHealth = oEnemy:GetHealth()
                                if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack -  Considering if we want to manually attack enemy unit '..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; iCurHelath='..iCurHealth..'; iLowestHealth='..iLowestHealth..'; Can see unit='..tostring(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemy))..'; Distance ot unit='..M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())..'; iCurHealth < iLowestHealth ='..tostring(iCurHealth < iLowestHealth )..'; Both conditions='..tostring(iCurHealth < iLowestHealth and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemy, true))) end
                                if iCurHealth < iLowestHealth and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemy) then
                                    iCurDistOfCategory = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())
                                    iClosestEnemyOfCategory = math.min(iClosestEnemyOfCategory, iCurDistOfCategory)
                                    if iCurDistOfCategory <= oUnit[M28UnitInfo.refiDFRange] + 2 then
                                        iLowestHealth = iCurHealth
                                        oManualAttackTarget = oEnemy
                                        if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack - Setting manual attack target to this enemy') end
                                    elseif bDebugMessages == true then LOG(sFunctionRef..': Enemy is too far away')
                                    end
                                elseif bDebugMessages == true then LOG(sFunctionRef..': Enemy is too high health or we cant see it')
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack -  Finished searhcing for oManualAttackTarget='..(oManualAttackTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oManualAttackTarget) or 'nil')) end

                    --non-kiting experimental specific (i.e. GC, Ythotha, Megalith) - if are in a dif zone to the assigned zone then do getunitsaroundpoint to check no enemy experimentals or ACUs almost within range
                    if not(oManualAttackTarget) then
                        if not(oUnit[M28UnitInfo.refbCanKite]) and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oUnit.UnitId) and not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                            local tNearbyEnemyExperimentals = oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryLandExperimental + categories.COMMAND, oUnit:GetPosition(), oUnit[M28UnitInfo.refiDFRange] + 2, 'Enemy')
                            if M28Utilities.IsTableEmpty(tNearbyEnemyExperimentals) == false then
                                for iEnemy, oEnemy in tNearbyEnemyExperimentals do
                                    if oEnemy:GetFractionComplete() == 1 then
                                        iCurHealth = oEnemy:GetHealth()
                                        if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack exp backup search -  Considering if we want to manually attack enemy unit '..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; iCurHelath='..iCurHealth..'; iLowestHealth='..iLowestHealth..'; Can see unit='..tostring(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemy))..'; Distance ot unit='..M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())..'; iCurHealth < iLowestHealth ='..tostring(iCurHealth < iLowestHealth )..'; Both conditions='..tostring(iCurHealth < iLowestHealth and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemy, true))) end
                                        if iCurHealth < iLowestHealth and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemy) then
                                            iCurDistOfCategory = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())
                                            iClosestEnemyOfCategory = math.min(iClosestEnemyOfCategory, iCurDistOfCategory)
                                            if iCurDistOfCategory <= oUnit[M28UnitInfo.refiDFRange] + 2 then
                                                iLowestHealth = iCurHealth
                                                oManualAttackTarget = oEnemy
                                                if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack exp backup search - Setting manual attack target to this enemy') end
                                            elseif bDebugMessages == true then LOG(sFunctionRef..': exp backup Enemy is too far away')
                                            end
                                        elseif bDebugMessages == true then LOG(sFunctionRef..': exp backup Enemy is too high health or we cant see it')
                                        end
                                    end
                                end
                            end
                        end

                        --Consider targeting T3 land for ythotha - will do by doing attack move
                        if not(oManualAttackTarget) and iClosestEnemyOfCategory >= math.max(oUnit[M28UnitInfo.refiDFRange] + 10, 70) and EntityCategoryContains(M28UnitInfo.refCategoryYthotha, oUnit.UnitId) then
                            --If we alreayd have a target that is in range then stick with this if we are near it
                            local iCurAngleDif
                            local iClosestAngleDif = 1000
                            local iYthothaAngle = M28UnitInfo.GetUnitFacingAngle(oUnit)

                            local oExistingAttackTarget = oUnit[M28Orders.reftiLastOrders][M28Orders.refiOrderCount][M28Orders.subrefoOrderUnitTarget]
                            if M28UnitInfo.IsUnitValid(oExistingAttackTarget) and M28Utilities.GetDistanceBetweenPositions(oExistingAttackTarget:GetPosition(), oUnit:GetPosition()) <= oUnit[M28UnitInfo.refiDFRange] + 1 then
                                --Record closest angle dif and reduce by 15 so we wont switch targets to another unit if it wouldnt be that much of an improvement
                                iClosestAngleDif = math.max(0, M28Utilities.GetAngleDifference(iYthothaAngle, M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oExistingAttackTarget:GetPosition())) - 15)
                            end
                            if iClosestAngleDif > 30 then --i.e. 45+ angle dif since we reduce it by 15 in the above step
                                local tOtherPriorityTargets = EntityCategoryFilterDown(M28UnitInfo.refCategoryDFTank * categories.TECH3 - M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryT3PD, tLZTeamData[M28Map.reftoNearestDFEnemies])
                                if bDebugMessages == true then LOG(sFunctionRef..': Is tOtherPriorityTargets empty='..tostring(M28Utilities.IsTableEmpty(  tOtherPriorityTargets))) end
                                if M28Utilities.IsTableEmpty(  tOtherPriorityTargets) == false then
                                    for iEnemy, oEnemy in tOtherPriorityTargets do
                                        if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack - Considering ythotha t3 oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; Is this the same as nearest enemy to midpoint='..tostring(oEnemy == oNearestEnemyToFriendlyBase)..'; Fraction complete='..oEnemy:GetFractionComplete()..'; Unit max health='..oEnemy:GetMaxHealth()..'; Can see unit='..tostring(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemy))..'; Dist to us='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemy:GetPosition())..'; Angle dif='..M28Utilities.GetAngleDifference(iYthothaAngle, M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oEnemy:GetPosition()))..'; Closest dif='..iClosestAngleDif) end
                                        if oEnemy:GetFractionComplete() == 1 then
                                            if oEnemy:GetMaxHealth() >= 2000 and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemy) then
                                                iCurDistOfCategory = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())
                                                iClosestEnemyOfCategory = math.min(iClosestEnemyOfCategory, iCurDistOfCategory)
                                                if iCurDistOfCategory <= oUnit[M28UnitInfo.refiDFRange] then
                                                    iCurAngleDif = M28Utilities.GetAngleDifference(iYthothaAngle, M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oEnemy:GetPosition()))
                                                    if iCurAngleDif < iClosestAngleDif then
                                                        iClosestAngleDif = iCurAngleDif
                                                        oManualAttackTarget = oEnemy
                                                        if bDebugMessages == true then LOG(sFunctionRef..': GetManualAttackTargetIfWantManualAttack - Setting ythotha manual attack target to this enemy') end
                                                    end

                                                elseif bDebugMessages == true then LOG(sFunctionRef..': Enemy is too far away for ythotha to target')
                                                end
                                            end
                                        end
                                    end
                                end
                            elseif bDebugMessages == true then LOG(sFunctionRef..': Will stick with existing manual attack target')
                            end
                        end
                    end
                    if oManualAttackTarget then
                        --Is nearest enemy to midpoitn a better target?
                        if not(oManualAttackTarget == oNearestEnemyToFriendlyBase) and EntityCategoryContains(iCategoryToSearch, oNearestEnemyToFriendlyBase.UnitId) and oNearestEnemyToFriendlyBase:GetFractionComplete() == 1 then
                            if oNearestEnemyToFriendlyBase:GetHealth() < iLowestHealth and M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition()) <= oUnit[M28UnitInfo.refiDFRange] + 2 then
                                if M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oNearestEnemyToFriendlyBase) then
                                    oManualAttackTarget = oNearestEnemyToFriendlyBase
                                else
                                    oManualAttackTarget = nil
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..':GetManualAttackTargetIfWantManualAttack - Finished checking if nearest enemy to midpoint is better target, oManualAttackTarget='..(oManualAttackTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oManualAttackTarget) or 'nil')..'; Nearest enemy to midpoint health='.. oNearestEnemyToFriendlyBase:GetHealth()) end
                        end
                        --Include T3 land for manual attack targets for ythotha
                    end
                end
            end
            return oManualAttackTarget
        end

        function DoManualAttack(oUnit, oTargetToManuallyAttack, sOrderDesc)
            if oUnit.UnitId == 'xsl0401' and EntityCategoryContains(M28UnitInfo.refCategoryLandCombat * categories.TECH3, oTargetToManuallyAttack.UnitId) and M28Utilities.GetDistanceBetweenPositions(oTargetToManuallyAttack:GetPosition(), oUnit:GetPosition()) <= oUnit[M28UnitInfo.refiCombatRange] then
                local tTargetLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28UnitInfo.GetUnitFacingAngle(oUnit), 6, true)
                M28Orders.IssueTrackedAggressiveMove(oUnit, tTargetLocation, math.min(20, oUnit[M28UnitInfo.refiCombatRange]), false, sOrderDesc..'YAM', false)
            else
                M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, sOrderDesc, false)
            end
        end

        local iEnemyNearbyCombatThreatIfRelevant
        function GetEnemyCombatThreatInAdjacentZones()
            if not(iEnemyNearbyCombatThreatIfRelevant) then
                local iCurAndAdjCombat = math.max((tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 0.5, (tLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0) + (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0))
                if bDebugMessages == true then LOG(sFunctionRef..': Getting enemy combat threat, threat in this zone='..iCurAndAdjCombat) end

                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]))..'; Enemy combat='..(tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)..'; Enemy DF Structure='..(tAdjLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0)..'; Enemy DF Mobile='..(tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)) end
                        iCurAndAdjCombat = iCurAndAdjCombat + math.max((tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 0.5, (tAdjLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0) + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0))
                    end
                end
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                    iCurAndAdjCombat = math.max(iCurAndAdjCombat, M28UnitInfo.GetCombatThreatRating(tLZTeamData[M28Map.reftoNearestDFEnemies], true))
                end
                iEnemyNearbyCombatThreatIfRelevant = iCurAndAdjCombat
                if bDebugMessages == true then LOG(sFunctionRef..': Setting iEnemyNearbyCombatThreatIfRelevant=iCurAndAdjCombat='..(iCurAndAdjCombat or 'nil')) end
            end
            return iEnemyNearbyCombatThreatIfRelevant
        end

        if oNearestEnemyToFriendlyBase and M28Conditions.IsLocationInPlayableArea(oNearestEnemyToFriendlyBase:GetPosition()) then
            if tLZTeamData[M28Map.subrefLZbCoreBase] then
                --Adjust rally points for core base if nearby enemy in case we end up going closer to the enemy instead of furhter away
                if M28Utilities.GetDistanceBetweenPositions(tAmphibiousRallyPoint, tLZData[M28Map.subrefMidpoint]) <= 5 then
                    tAmphibiousRallyPoint = M28Utilities.MoveInDirection(tLZData[M28Map.subrefMidpoint], M28Utilities.GetAngleFromAToB(oNearestEnemyToFriendlyBase:GetPosition(), tLZData[M28Map.subrefMidpoint]), 40, true, false, true)
                end
                if M28Utilities.GetDistanceBetweenPositions(tRallyPoint, tLZData[M28Map.subrefMidpoint]) <= 5 then
                    tRallyPoint = M28Utilities.MoveInDirection(tLZData[M28Map.subrefMidpoint], M28Utilities.GetAngleFromAToB(oNearestEnemyToFriendlyBase:GetPosition(), tLZData[M28Map.subrefMidpoint]), 40, true, false, true)
                end
            end


            --Do we have shot blocked on non-skirmisher units, no indirect fire units, and have signficantly more threat than the enemy or are on an island beachhead? If so then move instead of attakc-moving when attacking
            local bMoveBlockedNotAttackMove = false
            if (iFriendlyBestMobileIndirectRange == 0 or iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 3) and (iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 1.75 or tLZTeamData[M28Map.refbIslandBeachhead]) then
                bMoveBlockedNotAttackMove = true
            end

            local bConsiderSpecialMMLLogic = false --if true then will consider synchronising MML shots and adjusting who they will target from the default
            local tMMLForSynchronisation = {}
            local bOnlyRetreatIndirectIfEnemyDFAlmostInRange = false --if true (e.g. dealing with t2 arti and dont want T3 mobile arti to run from low level enemy threats) then indirect fire units should only run from nearest enemy if it is almost in range of them
            if iFriendlyBestMobileIndirectRange > 0 then
                local iAvailableMMLThreat = 0
                local tFriendlyMML = EntityCategoryFilterDown(M28UnitInfo.refCategoryMML, tAvailableCombatUnits)
                if M28Utilities.IsTableEmpty(tFriendlyMML) == false then
                    iAvailableMMLThreat = M28UnitInfo.GetMassCostOfUnits(tFriendlyMML)
                end

                bConsiderSpecialMMLLogic = M28Conditions.DoWeWantToSynchroniseMMLShots(iPlateau, iLandZone, tLZData, tLZTeamData, iTeam, iFriendlyBestMobileIndirectRange, iEnemyBestDFRange, iAvailableMMLThreat, oClosestUnitFromAllFirebases)
                if iAvailableCombatUnitThreat >= 2500 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false and iFriendlyBestMobileIndirectRange >= 40 then
                    --How much available DF threat do we have?
                    local iRoughAvailableDFThreat = 0
                    for iUnit, oUnit in tAvailableCombatUnits do
                        if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and EntityCategoryContains(M28UnitInfo.refCategoryLandCombat - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) then
                            iRoughAvailableDFThreat = iRoughAvailableDFThreat + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
                            if iRoughAvailableDFThreat >= 1000 then
                                bOnlyRetreatIndirectIfEnemyDFAlmostInRange = true
                                break
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iRoughAvailableDFThreat (to max of 1k)='..iRoughAvailableDFThreat..'; bOnlyRetreatIndirectIfEnemyDFAlmostInRange='..tostring(bOnlyRetreatIndirectIfEnemyDFAlmostInRange)) end
                end
            end

            local bAreInScenario1 = false
            local iDFRangeOverrideForScenario1
            local bAttackWithSameRange = false
            if ((tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) == 0 or iFriendlyBestMobileDFRange >= 100) and --No long range enemy threat (i.e. t2 arti); and
                    (iFirebaseThreatAdjust == 0 or (iFriendlyBestMobileDFRange >= 100 and iFirebaseThreatAdjust < 6000 and tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= 8000) or (not(bRunFromFirebase) and (iFriendlyBestMobileDFRange >= 60 or iFriendlyBestMobileIndirectRange >= 60))) and --No enemy firebase or we have large threat that should be able to overwhelm it; and
                    ((iFriendlyBestMobileDFRange or 0) > (iEnemyBestDFRange or 0) or --we outrange enemy with our direct fire, or
                            ((iFriendlyBestMobileIndirectRange or 0) > (iEnemyBestDFRange or 0) and ((iEnemyBestStructureDFRange or 0) > 0 or (tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] or 0) > 0 or (tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] or 0) > 1.4 * (tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)))) then --we have indirect fire with better range than enemy direct fire, and the enemy has structures in this LZ such that we want to attack

                bAreInScenario1 = true
                if (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) > 0 or iFirebaseThreatAdjust > 0 then
                    bAttackWithSameRange = true
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Normal scenario 1 criteria satisfied') end
            elseif iFirebaseThreatAdjust == 0 and (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) == 0 and (iFriendlyBestMobileDFRange or 0) >= math.max(10, (iEnemyBestDFRange or 0) - 3) then
                if  iFriendlyBestMobileDFRange > (oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0) and iFriendlyBestMobileDFRange >= iEnemyBestDFRange then --e.g. gattling bots vs hoplites
                    bAreInScenario1 = true
                    bAttackWithSameRange = true
                    if bDebugMessages == true then LOG(sFunctionRef..': We outrange nearest enemy unit and have equivalent DF range overall so will act as though in scenario 1') end
                elseif not(EntityCategoryContains(M28UnitInfo.refCategoryStructure, oNearestEnemyToFriendlyBase.UnitId)) then --i.e. nearest enemy is a mobile enemy with (likely) the same or slightly better range than us
                    --Do we have significantly more threat than enemy at the highest range?
                    local iEnemyBestRangeDFThreat = 0
                    local iOurBestRangeDFThreat = 0
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
                        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                            if iRange >= iFriendlyBestMobileDFRange then
                                iOurBestRangeDFThreat = iThreat
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) == false then
                        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] do
                            if iRange >= iFriendlyBestMobileDFRange then
                                iEnemyBestRangeDFThreat = iThreat
                            end
                        end
                    end
                    --Consider enemy LR threat in adjacent zones if we might have enough threat
                    if iOurBestRangeDFThreat > 1.5 * iEnemyBestRangeDFThreat then
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) == false then
                                    for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] do
                                        if iRange >= iFriendlyBestMobileDFRange then
                                            iEnemyBestRangeDFThreat = iEnemyBestRangeDFThreat + iThreat
                                        end
                                    end
                                end
                            end
                        end
                        if iOurBestRangeDFThreat > 1.5 * iEnemyBestRangeDFThreat then
                            bAreInScenario1 = true
                            if bDebugMessages == true then LOG(sFunctionRef..': We have significantly more threat than enemy at the longer rnage so will act as though are in scenario 1 so we just attack with our longer ranged units') end
                            iDFRangeOverrideForScenario1 = iFriendlyBestMobileDFRange
                            bAttackWithSameRange = true
                        end
                    end
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if should move blocked units, bMoveBlockedNotAttackMove='..tostring(bMoveBlockedNotAttackMove)..'; iFriendlyBestMobileIndirectRange='..(iFriendlyBestMobileIndirectRange or 'nil')..';  tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; Enemy DF structure='..(tLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0)..'; Enemy DF mobile='..(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)..'; tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]='..(tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 'nil')..'; iFriendlyBestMobileDFRange='..(iFriendlyBestMobileDFRange or 'nil')..'; Enemy best DF range='..iEnemyBestDFRange..'; iFriendlyBestMobileIndirectRange='..(iFriendlyBestMobileIndirectRange or 'nil')..'; iEnemyBestStructureDFRange='..(iEnemyBestStructureDFRange or 'nil')..'; Enemy structure threat indirect='..(tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] or 'nil')..'; bEnemyHasNoDFUnits='..tostring(bEnemyHasNoDFUnits or false)..'; iEnemyBestDFRange='..(iEnemyBestDFRange or 'nil')..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] or 'nil')..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal]='..(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 'nil')..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; subrefiNearbyEnemyLongRangeThreat='..(tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0)..'; bAreInScenario1='..tostring(bAreInScenario1)) end
            --SCENARIO 1 - We outrange enemy DF units (mobile and fix), or have equal range but with either significantly more threat at that range, or nearest enemy lacks that range
            if bAreInScenario1 then
                --ARE IN SCENARIO 1
                if bDebugMessages == true then LOG(sFunctionRef..': In scenario 1, so we either outrange enemy, or we have significantly more threat at their best range - i.e. equal range, bAttackWithSameRange='..tostring(bAttackWithSameRange)) end
                local tOutrangedCombatUnits = {}
                local tUnitsToSupport = {}
                local bAttackWithOutrangedDFUnits = false
                local iAngleThresholdForRally --i.e. what angle dif need between us and nearest enemy to just retreat in opposite direction instead of going to rally
                local iSkirmisherDistToNearestEnemy
                local bNearestEnemyIsACU = false
                if EntityCategoryContains(categories.COMMAND, oNearestEnemyToFriendlyBase.UnitId) then
                    bNearestEnemyIsACU = true
                end
                if bDebugMessages == true then LOG(sFunctionRef..': About to consider whether to attack with outranged units, is this core base='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])..'; are there dangerous enemies in this LZ='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])..'; Our mobile DF threat='..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]..'; Enemy combat total for this zone='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; Enemy threat in adj zones='..GetEnemyCombatThreatInAdjacentZones()) end
                if tLZTeamData[M28Map.subrefLZbCoreBase] and tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] then
                    if bDebugMessages == true then LOG(sFunctionRef..': Are in core base so want to attack with outranged units if enemy is in this zone, subrefbDangerousEnemiesInThisLZ='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])) end
                    bAttackWithOutrangedDFUnits = true
                elseif (tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] > 1.3 * math.max(20, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 0.5, tLZTeamData[M28Map.subrefThreatEnemyDFStructures] + tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]) and iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 1.1) then
                    bAttackWithOutrangedDFUnits = true

                    --Change to false if we are likeyl to have outranged DF units and enemy has significant nearby threat
                    local bExpectToHaveOutrangedDF = false
                    for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                        if iThreat > 0 and iRange <= iEnemyBestDFRange then
                            bExpectToHaveOutrangedDF = true
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Our DF Threat '..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]..' exceeds enemy total combat threat '..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..' so want to attack with outranged DF units if this is also the case factoring in adjacent enemy zone threat, bExpectToHaveOutrangedDF='..tostring(bExpectToHaveOutrangedDF)) end
                    local iEnemyCombatThreat = math.max(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 0.5, tLZTeamData[M28Map.subrefThreatEnemyDFStructures] + tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]) --we end up only including nearby enemy threats in adj zones, not all adj zone threats
                    local bAdjustStructureThreat = false

                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        if iFirebaseThreatAdjust == 0 then
                            local tNearbyAdjacentEnemies = {}
                            local tOurDFAndT1ArtiUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandCombat, tAvailableCombatUnits)
                            local iAdjacentDistThreshold = 0
                            local iCurDist
                            local iMinDist = 1000
                            local oClosestFriendlyUnit
                            --If dealing with PD, then will only include as a 'close enough' threat if the dist is closer than mobile units, factoring in range
                            for iUnit, oUnit in tOurDFAndT1ArtiUnits do
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                if iCurDist > iAdjacentDistThreshold then iAdjacentDistThreshold = iCurDist end
                                if iCurDist < iMinDist then
                                    iMinDist = iCurDist
                                    oClosestFriendlyUnit = oUnit
                                end
                            end
                            local iAngleFromClosestFriendlyUnit = 0
                            if oClosestFriendlyUnit then iAngleFromClosestFriendlyUnit = M28Utilities.GetAngleFromAToB(oClosestFriendlyUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) end
                            iAdjacentDistThreshold = iAdjacentDistThreshold + 20
                            local iStructureUnitDistThresholdAdjust = math.max(-30, -iAdjacentDistThreshold + 15)
                            if iAdjacentDistThreshold + iStructureUnitDistThresholdAdjust > iMinDist + 10 then
                                iStructureUnitDistThresholdAdjust = iMinDist + 10 - iAdjacentDistThreshold
                            end
                            if iEnemyBestStructureDFRange >= 50 then iAdjacentDistThreshold = math.max(iAdjacentDistThreshold + math.max(0, 5 + iEnemyBestStructureDFRange - (iFriendlyBestMobileDFRange or 0)), 35) end
                            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                if not(tbAdjacentZoneEnemiesToIgnoreByZone[iAdjLZ]) then
                                    AddUnitFromAdjacentZoneToTableIfCloseEnough(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam], tNearbyAdjacentEnemies, iAdjacentDistThreshold, iStructureUnitDistThresholdAdjust, iAngleFromClosestFriendlyUnit)
                                end
                            end
                            if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
                                for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                                    AddUnitFromAdjacentZoneToTableIfCloseEnough(M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam], tNearbyAdjacentEnemies, iAdjacentDistThreshold, iStructureUnitDistThresholdAdjust, iAngleFromClosestFriendlyUnit)
                                end
                            end
                            if M28Utilities.IsTableEmpty(tUnitsNearFatboyInFurtherAwayZones) == false then
                                for iEnemy, oEnemy in tUnitsNearFatboyInFurtherAwayZones do
                                    table.insert(tNearbyAdjacentEnemies, oEnemy)
                                end
                            end
                            iEnemyCombatThreat = iEnemyCombatThreat + M28UnitInfo.GetCombatThreatRating(tNearbyAdjacentEnemies, false)
                        else
                            if tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= 5000 then bAdjustStructureThreat = true end
                            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                --Only include 20% of enemy structure threat in adjacent zones if we have high threat value
                                if not(tbAdjacentZoneEnemiesToIgnoreByZone[iAdjLZ]) then
                                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                    iEnemyCombatThreat = iEnemyCombatThreat + math.max((tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)*0.5, (tAdjLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0) + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0))
                                    if bAdjustStructureThreat and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will reduce adjacent threat by structure threat, tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]='..repru(tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange])) end
                                        for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                                            if iRange <= 65 then
                                                iEnemyCombatThreat = iEnemyCombatThreat - iThreat * 0.8
                                            end
                                        end
                                    end
                                end
                            end
                            if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
                                for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                                    iEnemyCombatThreat = iEnemyCombatThreat + GetCombatThreatFromAdjacentZone(M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam], bAdjustStructureThreat)
                                end
                            end
                        end
                    else
                        if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
                            for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                                iEnemyCombatThreat = iEnemyCombatThreat + GetCombatThreatFromAdjacentZone(M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam], bAdjustStructureThreat)
                            end
                        end
                    end

                    if iEnemyCombatThreat > tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or (iEnemyCombatThreat * 1.25 > tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] and (iEnemyCombatThreat > GetEnemyCombatThreatInAdjacentZones() * 0.8 or tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] <= 5000 or (iFriendlyBestMobileDFRange >= 60 and iEnemyBestDFRange < 60) or tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] >= tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] * 0.75)) then
                        bAttackWithOutrangedDFUnits = false
                        --Dont charge into PD unless have overwhelming force
                    elseif iEnemyBestStructureDFRange > 0 and tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] < 5000 and (tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] > iEnemyCombatThreat * 0.15 or (iEnemyBestStructureDFRange < 50 and tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] <= 2000 and tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] > 0)) and iEnemyCombatThreat * 3 > tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] then
                        bAttackWithOutrangedDFUnits = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Dont ahve overwhelming mobile DF threat and have some indirect fire forces so wont launch all out attack just yet') end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iEnemyCombatThreat after factoring in nearby zones='..iEnemyCombatThreat..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]..'; bAttackWithOutrangedDFUnits='..tostring(bAttackWithOutrangedDFUnits)..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]..'; iEnemyBestStructureDFRange='..iEnemyBestStructureDFRange) end
                end


                local bUpdateNearestUnit = false
                local bCheckIfNearestUnitVisible = false
                if M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) >= 10 then bCheckIfNearestUnitVisible = true end

                table.insert(tSkirmisherEnemies, oNearestEnemyToFriendlyBase)
                local bMoveToStopPDConstruction = false
                local bMoveTowardsEngineers = false
                if bDebugMessages == true then LOG(sFunctionRef..': In scenario 1, checking if enemy engineers, Is table of enemy engineers empty='..tostring(M28Utilities.IsTableEmpty(tEnemyEngineers))..'; enemy combat='..(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat) end
                if M28Utilities.IsTableEmpty(tEnemyEngineers) == false and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 100 and (iAvailableCombatUnitThreat or 0) >= math.min(40, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 3) and iAvailableCombatUnitThreat <= 1500 and GetEnemyCombatThreatInAdjacentZones() <= 500  then
                    local tEnemyPD = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD, tLZTeamData[M28Map.subrefTEnemyUnits])
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy PD empty='..tostring(M28Utilities.IsTableEmpty(tEnemyPD))) end
                    if M28Utilities.IsTableEmpty(tEnemyPD) == false then
                        bMoveToStopPDConstruction = true
                        for iPD, oPD in tEnemyPD do
                            if oPD:GetFractionComplete() == 1 then
                                bMoveToStopPDConstruction = false
                                break
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': bMoveToStopPDConstruction before doublechecking threats='..tostring(bMoveToStopPDConstruction)) end
                        if bMoveToStopPDConstruction then
                            --Check we have significantly more threat if excluding under-construction PD
                            bMoveToStopPDConstruction = false
                            local iPDThreat = M28UnitInfo.GetCombatThreatRating(tEnemyPD, true)
                            if bDebugMessages == true then LOG(sFunctionRef..': iPDThreat='..iPDThreat) end
                            if (iAvailableCombatUnitThreat or 0) > 2 * tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] - iPDThreat and iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() then
                                bMoveToStopPDConstruction = true
                            end
                        end
                    else
                        --do we have engineers to attack instead?
                        if iAvailableCombatUnitThreat <= 400 and iAvailableCombatUnitThreat <= 300 then
                            bMoveTowardsEngineers = true
                        end
                    end
                end

                --local bCheckIfNearLocationToAvoid = not(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftiLocationsToAvoid]))


                if bDebugMessages == true then LOG(sFunctionRef..': Scenario 1 - will cycle through available combat units, is tSkirmisherEnemies empty='..tostring(M28Utilities.IsTableEmpty(tSkirmisherEnemies))..'; oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase) or 'nil')) end
                bGivenCombatUnitsOrders = true
                local bFiringAtNegligibleThreatInLRExperimentalRange = false --used for megalith and fatboy so won't attack-move towards enemy
                for iUnit, oUnit in tAvailableCombatUnits do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit for scenario 1, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; iEnemyBestDFRange='..(iEnemyBestDFRange or 'nil')..'; bEnemyHasNoDFUnits='..tostring(bEnemyHasNoDFUnits or false)..'; Close to enemy unit (DF only) ='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], (oUnit[M28UnitInfo.refiDFRange] or 0) * 0.94, iTeam, false))..'; Was last shot blocked='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked] or false)..'; Is unit underwtaer='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; Can unit kite='..tostring(oUnit[M28UnitInfo.refbCanKite] or false)..'; Is table of enemy engineers empty='..tostring(M28Utilities.IsTableEmpty(tEnemyEngineers))..'; Time since last weapon event='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0)..'; Time between DF shots='..(oUnit[M28UnitInfo.refiTimeBetweenDFShots] or 'nil')..'; IF range='..(oUnit[M28UnitInfo.refiIndirectRange] or 0)) end

                    --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                    if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end

                    --if bCheckIfNearLocationToAvoid and EntityCategoryContains(categories.TECH1 + categories.TECH2 - categories.COMMAND, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbSpecialMicroActive]) and M28Conditions.HaveSentOrderToRunAwayFromLocationToAvoid(oUnit, tLZTeamData[M28Map.reftiLocationsToAvoid], 4) then
                    --if bDebugMessages == true then LOG(sFunctionRef..': Told unit to avoid a location to avoid') end
                    if oUnit[M28UnitInfo.refiDFRange] > iEnemyBestDFRange or (bAttackWithSameRange and oUnit[M28UnitInfo.refiDFRange] >= iEnemyBestDFRange) or (iDFRangeOverrideForScenario1 and (oUnit[M28UnitInfo.refiDFRange] or 0) >= iDFRangeOverrideForScenario1) then
                        table.insert(tUnitsToSupport, oUnit)
                        if ProceedWithUnitOrder(oUnit, true) then
                            --Consider kiting logic unless want to use shot blocked override logic
                            if bMoveBlockedNotAttackMove and ((oUnit[M28UnitInfo.refbLastShotBlocked] and (not(oUnit[M28UnitInfo.refiDFMinRange]) or oUnit[M28UnitInfo.refiDFRange] <= 120)) or M28UnitInfo.IsUnitUnderwater(oUnit)) and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) then
                                M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'BlckM'..iLandZone)
                            else
                                --Easy mode logic?
                                if oUnit[M28UnitInfo.refbEasyBrain] then
                                    --Attack-move to nearest enemy
                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                        M28Orders.IssueTrackedAttackMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'EsyLRAM'..iLandZone)
                                    end
                                else
                                    --Experimental specific - attack ACU if in-range
                                    local bUseNormalLogic = true
                                    if bConsiderAttackingACU and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), toEnemyACUsInZone, 6 + oUnit[M28UnitInfo.refiDFRange], iTeam, false, nil, nil, nil, nil, nil) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to attack ACU with our experimental') end
                                        GetUnitToAttackNearestACU(oUnit)
                                        bUseNormalLogic = false
                                    elseif bMoveTowardsEngineers and oUnit[M28UnitInfo.refiDFRange] > 0 and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + categories.EXPERIMENTAL + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) then
                                        local oNearestEngineerToUnit = M28Utilities.GetNearestUnit(tEnemyEngineers, oUnit:GetPosition())
                                        if oNearestEngineerToUnit then
                                            --Use normal logic if are almost in reclaim range of the engineer
                                            local iDistToEngineer = M28Utilities.GetDistanceBetweenPositions(oNearestEngineerToUnit:GetPosition(), oUnit:GetPosition())
                                            if bDebugMessages == true then LOG(sFunctionRef..': oNearestEngineerToUnit='..oNearestEngineerToUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEngineerToUnit)..'; iDistToEngineer='..iDistToEngineer..'; oUnit[M28UnitInfo.refiDFRange]='..oUnit[M28UnitInfo.refiDFRange] ..'; Eng build range='..(oNearestEngineerToUnit:GetBlueprint().Economy.MaxBuildDistance or 0)) end
                                            if not(iDistToEngineer <= math.min(oUnit[M28UnitInfo.refiDFRange] - 3, (oNearestEngineerToUnit:GetBlueprint().Economy.MaxBuildDistance or 0) + 5)) then
                                                --Move towards the engineer, or attack move if are close
                                                bUseNormalLogic = false
                                                if iDistToEngineer <= oUnit[M28UnitInfo.refiDFRange] - 2.5 then
                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEngineerToUnit:GetPosition(), math.min(4, oUnit[M28UnitInfo.refiDFRange] * 0.5), false, 'EnAMve'..iLandZone, false)
                                                else
                                                    M28Orders.IssueTrackedMove(oUnit, oNearestEngineerToUnit:GetPosition(), math.min(4, oUnit[M28UnitInfo.refiDFRange]  * 0.5), false, 'EnMve'..iLandZone, false)
                                                end
                                            end
                                        end
                                    end
                                    if bUseNormalLogic then
                                        --Experimental specific - update the bFiringAtNegligibleThreatInLRExperimentalRange flag
                                        bFiringAtNegligibleThreatInLRExperimentalRange = false
                                        --Note - iVisibleDFMassInFatboyRange uses getunitsaroundpoint so wont factor in memory; therefore want to use more accurate method to avoid fatboy charging towards a monkeylord that recently fired at us
                                        if (oUnit[M28UnitInfo.refiDFRange] or 0) >= 60 and EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and (iVisibleDFMassInFatboyRange <= 3000 or not(EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId))) then
                                            --Only consider if we have fired in the last 10s (otherwise it doesnt matter)
                                            if oUnit[M28UnitInfo.refiLastWeaponEvent] and GetGameTimeSeconds() - oUnit[M28UnitInfo.refiLastWeaponEvent] <= 10 then
                                                --Get accurate measure of enemy threat within our range
                                                bFiringAtNegligibleThreatInLRExperimentalRange = M28Conditions.HaveSignificantEnemyThreatWithinRange(tLZData, tLZTeamData, iPlateau, iTeam, oUnit[M28UnitInfo.refiDFRange] + 3, oUnit:GetPosition(), 1500, M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryT2PlusPD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryNavalSurface - categories.TECH1 + categories.COMMAND, tUnitsNearFatboyInFurtherAwayZones)
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': bFiringAtNegligibleThreatInLRExperimentalRange='..tostring(bFiringAtNegligibleThreatInLRExperimentalRange)..'; Time since we last fired weapon='..(GetGameTimeSeconds() - oUnit[M28UnitInfo.refiLastWeaponEvent] or 0)..'; Have significant enemy threat within range='..tostring(M28Conditions.HaveSignificantEnemyThreatWithinRange(tLZData, tLZTeamData, iPlateau, iTeam, oUnit[M28UnitInfo.refiDFRange] + 3, oUnit:GetPosition(), 1500, M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryT2PlusPD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryNavalSurface - categories.TECH1 + categories.COMMAND, tUnitsNearFatboyInFurtherAwayZones))) end
                                        end

                                        --Are we in range of any enemy or cant kite?
                                        --CloseToEnemyUnit(tStartPosition,      tUnitsToCheck,         iDistThreshold,             iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure)                                                                                                                                                                                     CloseToEnemyUnit(tStartPosition,      tUnitsToCheck,                                        iDistThreshold,             iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure)
                                        if bDebugMessages == true then LOG(sFunctionRef..': About to check if we are about to be in range of the enemy and so want to do a kiting retreat, our DF range='..oUnit[M28UnitInfo.refiDFRange]..'; iEnemyBestDFRange='..iEnemyBestDFRange..'; Expected threshold for close to enemy='..math.min(oUnit[M28UnitInfo.refiDFRange], math.max(oUnit[M28UnitInfo.refiDFRange] - 3,  iEnemyBestDFRange + oUnit:GetBlueprint().Physics.MaxSpeed + 2))) end
                                        --Fatboy special logic if fatboy not in water - although default logic works fori t, want to do a more detailed check that looks into further away zones for nearby enemies
                                        if (oUnit[M28UnitInfo.refiDFRange] or 0) >= 100 and not(bFiringAtNegligibleThreatInLRExperimentalRange) and oUnit[M28UnitInfo.refbCanKite] and iVisibleDFMassInFatboyRange >= 3000 then
                                            --First make sure the fatboy is closer to enemy base than the closest friendly base is (otherwise we risk 'retreating' to a base that takes us closer to the enemy)
                                            if (iVisibleDFMassInFatboyRange >= 6000 or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits])) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase]) < M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], tLZTeamData[M28Map.reftClosestEnemyBase]) then
                                                bUseNormalLogic = false
                                                --Want to do kiting retreat towards nearest friendly base, or (if in a significantly different direction to the nearest enemy unit and mod dist is low
                                                local tBaseRally
                                                local iBackupDist = (oUnit:GetBlueprint().Physics.BackUpDistance or 0)
                                                local bCanPathToBase = false
                                                if iPlateau == NavUtils.GetLabel(M28Map.refPathingTypeHover, tLZTeamData[M28Map.reftClosestFriendlyBase]) then
                                                    --Are we amphibious, or on the same island as the closest base?
                                                    if EntityCategoryContains(M28UnitInfo.refCategoryAmphibious + categories.HOVER, oUnit.UnitId) or NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition()) == tLZData[M28Map.subrefLZIslandRef] then
                                                        bCanPathToBase = true
                                                    end
                                                end

                                                if bCanPathToBase then
                                                    tBaseRally = {tLZTeamData[M28Map.reftClosestFriendlyBase][1], tLZTeamData[M28Map.reftClosestFriendlyBase][2], tLZTeamData[M28Map.reftClosestFriendlyBase][3]}
                                                else
                                                    tBaseRally = {tRallyPoint[1], tRallyPoint[2], tRallyPoint[3]}
                                                end

                                                local tFatboyRetreatLocation
                                                local iCurDistToBackup = math.max(0, iBackupDist - 1)
                                                if iBackupDist >= 3 then
                                                    local iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tBaseRally)

                                                    --Further check - consider angle to enemy unit nearest midpoint, and also angle to nearest enemy base
                                                    local iAngleToRetreat
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering fatboy kiting retreat location, LZData mod dist%='.. tLZTeamData[M28Map.refiModDistancePercent]..'; iAngleToRally='..iAngleToRally..'; Angle to nearest enemy to midpoint='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Angle to nearest enemy base='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase])..'; Dist to closest friendly base='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])) end
                                                    --if bDebugMessages == true then LOG(sFunctionRef..': Considering fatboy kiting retreat location, LZData mod dist%='.. tLZTeamData[M28Map.refiModDistancePercent]..'; iAngleToRally='..iAngleToRally..'; Angle to nearest enemy to midpoint='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Angle to nearest enemy base='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase])..'; Dist to closest friendly base='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]))
                                                    if tLZTeamData[M28Map.refiModDistancePercent] >= 0.4 then
                                                        iAngleToRetreat = iAngleToRally
                                                    else
                                                        local iAngleToNearestEnemy
                                                        if oNearestEnemyToFriendlyBase then
                                                            iAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                                                        else
                                                            iAngleToNearestEnemy = iAngleToNearestEnemy - 180 --redundancy
                                                        end

                                                        if M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToRally) <= 100 then
                                                            local iAngleToNearestEnemyBase = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase])
                                                            if M28Utilities.GetAngleDifference(iAngleToRally, iAngleToNearestEnemyBase) <= 115 or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 60 then
                                                                --Moving towards the rally point isn't htat much of a dif from moving to the closest enemy or from moving to the closest enemy base, and our mod dist is already fairly low, so we may well be moving towards danger with the nearest base being overrun
                                                                iAngleToRetreat = iAngleToNearestEnemy - 180
                                                            end
                                                        end
                                                        if not(iAngleToRetreat) then iAngleToRetreat = iAngleToRally end
                                                    end


                                                    while iCurDistToBackup >= 2 do
                                                        tFatboyRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToRetreat, iCurDistToBackup, true, true, false)
                                                        if tFatboyRetreatLocation and NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover,tFatboyRetreatLocation) == iPlateau then
                                                            break
                                                        else
                                                            iCurDistToBackup = iCurDistToBackup - 2
                                                        end
                                                    end
                                                    if iCurDistToBackup < 2 then
                                                        tFatboyRetreatLocation = tBaseRally
                                                    end
                                                else --redundancy
                                                    tFatboyRetreatLocation = tBaseRally
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': Giving kiting retreat order to fatboy, iCurDistToBackup='..iCurDistToBackup) end
                                                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tFatboyRetreatLocation, iPlateau, 'FatbKit', true, nil, 60)
                                                --M28Orders.IssueTrackedMove(oUnit, tFatboyRetreatLocation, math.min(math.max(1, iCurDistToBackup - 3), 8), false, 'FatbKit', false)
                                            end
                                        end
                                        --Finished considering fatboy specific logic (if relevant), iwll now proceed with normal logic for all units (and fatboy if we didnt give it specific orders)
                                        if bUseNormalLogic then
                                            oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] = false --will be replaced by making it nil if we do the closest unit check

                                            --CloseToEnemyUnit(tStartPosition,      tUnitsToCheck,      iDistThreshold,              iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                                            if bFiringAtNegligibleThreatInLRExperimentalRange or (bEnemyHasNoDFUnits and (iAvailableCombatUnitThreat >= 1500 or M28Utilities.IsTableEmpty(tEnemyEngineers))) or
                                                    not(oUnit[M28UnitInfo.refbCanKite]) or
                                                    (EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) and not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tSkirmisherEnemies, oUnit[M28UnitInfo.refiDFRange], iTeam, false,                  nil,                    oUnit,                              oUnit                                   ,   math.min(oUnit[M28UnitInfo.refiDFRange], math.max(oUnit[M28UnitInfo.refiDFRange] - 3,  iEnemyBestDFRange + oUnit:GetBlueprint().Physics.MaxSpeed + 2))))) or
                                                    ((not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) and (iAvailableCombatUnitThreat >= 1500 or M28Utilities.IsTableEmpty(tEnemyEngineers) or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tEnemyEngineers, math.min(15, oUnit[M28UnitInfo.refiDFRange] - 4.5), iTeam, false, nil, nil))) and  not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange] * 0.94, iTeam, false,                   nil,                    nil,                                oUnit                                       , math.min(oUnit[M28UnitInfo.refiDFRange] * 0.94, math.max(oUnit[M28UnitInfo.refiDFRange] * 0.94 - 4,  iEnemyBestDFRange + 4)))))) then

                                                if bDebugMessages == true then
                                                    LOG(sFunctionRef..': Not in range of enemy yet or we cant kite, and we outrange enemy; bFiringAtNegligibleThreatInLRExperimentalRange='..tostring(bFiringAtNegligibleThreatInLRExperimentalRange)..'; bEnemyHasNoDFUnits='..tostring(bEnemyHasNoDFUnits)..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..oUnit[M28UnitInfo.refiDFRange]..'; oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..'; oNearestEnemyToFriendlyBase DF range='..(oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oNearestEnemyToFriendlyBase:GetPosition())..'; Enemy last recorded position='..repru(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; LZ midpoint position='..repru(tLZData[M28Map.subrefMidpoint])..'; Is closest enemy unit from last check valid='..tostring(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]))..'; Closeest unit from last check='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or 'nil')..'; Do we have a Sera sniperbot='..tostring(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher * categories.SERAPHIM, oUnit.UnitId))..'; bNearestEnemyNeedsManualAttack='..tostring(bNearestEnemyNeedsManualAttack))
                                                    if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                                                        LOG(sFunctionRef..': Distance to the closest enemy from check='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())..'; Is unit visible='..tostring(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]))..'; Is unit T1 mobile land='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryMobileLand * categories.TECH1 - categories.COMMAND, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId)))
                                                    end
                                                end

                                                --Megalith - consider moving backwards if enemy in range and we outrange enemy
                                                if not(bFiringAtNegligibleThreatInLRExperimentalRange) and not(oUnit[M28UnitInfo.refbCanKite]) and EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then

                                                    if iAvailableCombatUnitThreat < GetEnemyCombatThreatInAdjacentZones() * 8 and ((not(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], (oUnit[M28UnitInfo.refiDFRange] or 0) - 1, iTeam, false, nil, nil, oUnit)) or (M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]))) and EntityCategoryContains(categories.TECH3 + categories.EXPERIMENTAL - M28UnitInfo.refCategoryStructure, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId) then
                                                        local iDistToNearestEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition())
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to do kiting retreat with megalith, iDistToNearestEnemy='..iDistToNearestEnemy) end
                                                        --If 3 inside our range, or just inside our range but enemy is moving towards us, then consider kiting
                                                        if iDistToNearestEnemy < oUnit[M28UnitInfo.refiDFRange] - 3 or (iDistToNearestEnemy < oUnit[M28UnitInfo.refiDFRange] and oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:IsUnitState('Moving') and M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), M28UnitInfo.GetUnitFacingAngle(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) <= 45) then
                                                            --Are we in range of the enemy? If so then stop microing back in case it risks hurting our DPS, and so we can focus down the lowest health enemy experimental; exception if no enemy exps, in which case retreating might help us get closer to friendly units
                                                            --Have put a weapon event <=6s to try and cover the scenario where megalith is trying to retreat back but all the enemy units have gotten bheind it and it ends up unable to fire (havent actually seen in practice, so is a preemptive change)
                                                            if iDistToNearestEnemy >= (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 0) or (EntityCategoryContains(categories.TECH3, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId) and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0) <= 6 and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.EXPERIMENTAL, tLZTeamData[M28Map.reftoNearestDFEnemies])))) then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Want to do megalith retreat micro') end
                                                                if M28Micro.MegalithRetreatMicro(oUnit, tAmphibiousRallyPoint, tLZTeamData[M28Map.reftClosestFriendlyBase]) then
                                                                    bUseNormalLogic = false
                                                                end
                                                            end
                                                        end
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if we should do kiting retreat with megalith, iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; Enemy combat threat='..GetEnemyCombatThreatInAdjacentZones()..'; Is closest enemy from last close to enemy check valid='..tostring(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]))..'; bUseNormalLogic='..tostring(bUseNormalLogic)) end
                                                end
                                                if bUseNormalLogic then

                                                    --Non-kiting units (e.g. megalith) - consider manual attack if multiple potential targets
                                                    local oTargetToManuallyAttack
                                                    if bNearestEnemyNeedsManualAttack then --i.e. amphibious unit that is in a water zone, so wont get targeted normally
                                                        oTargetToManuallyAttack = oNearestEnemyToFriendlyBase
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Want manual attack on nearest enemy') end
                                                    elseif not(oUnit[M28UnitInfo.refbCanKite]) then
                                                        oTargetToManuallyAttack = GetManualAttackTargetIfWantManualAttack(oUnit)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': We cant kite so checking if we want a target to manually attack, oTargetToManuallyAttack='..(oTargetToManuallyAttack.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTargetToManuallyAttack) or 'nil')) end
                                                    end

                                                    --Not in range yet, so attack move to the nearest enemy (unless bFiringAtNegligibleThreatInLRExperimentalRange is true)
                                                    if oTargetToManuallyAttack then
                                                        --ythotha - attack move infront of ythotha
                                                        DoManualAttack(oUnit, oTargetToManuallyAttack, 'NKManA')
                                                    else
                                                        --Skirmishers - if enemy is almost in range of us then consider an attack-move order slightly away from them; if they are inside our range and we have far more threat then instead consider a manual attack order
                                                        if not(bFiringAtNegligibleThreatInLRExperimentalRange) and EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) and M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                                                            --If we lack land scout in this zone and lack good intel coverage then flag the skirmisher for a priority land scout
                                                            if tLZTeamData[M28Map.refiRadarCoverage] < iIntelThresholdForPriorityScout then
                                                                if M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmniVision] then --redundancy
                                                                    tLZTeamData[M28Map.refbWantLandScout] = false
                                                                    tLZTeamData[M28Map.refiRadarCoverage] = 1000
                                                                else
                                                                    tLZTeamData[M28Map.refbWantLandScout] = true
                                                                    ConsiderPriorityLandScoutFlag(oUnit)
                                                                end
                                                            end

                                                            iSkirmisherDistToNearestEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition())
                                                            if bDebugMessages == true then LOG(sFunctionRef..': have got a skirmisher unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..', will check if close to the closest enemy unit, Dist to it='..iSkirmisherDistToNearestEnemy..'; Enemy unit range='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 'nil')..'; Our DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Dif between their facing and angle to us='..M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), M28UnitInfo.GetUnitFacingAngle(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]))..'; Their unit state='..M28UnitInfo.GetUnitState(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; Nearby enemy combat threat='..GetEnemyCombatThreatInAdjacentZones()) end
                                                            if iSkirmisherDistToNearestEnemy < (oUnit[M28UnitInfo.refiDFRange] or 0) and iSkirmisherDistToNearestEnemy > math.min((oUnit[M28UnitInfo.refiDFRange] or 0) - 3, (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 0) + 10) and not(EntityCategoryContains(M28UnitInfo.refCategoryMobileLand * categories.TECH1 - categories.COMMAND, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId)) and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 8 then
                                                                M28Orders.IssueTrackedAttack(oUnit, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], false, 'InRngEn', false)
                                                                bUseNormalLogic = false
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Will issue an attack order on the target') end
                                                                --Angle dif - even at 30.9 angle dif we ended up getting too close, so changed to 32.5
                                                            elseif iSkirmisherDistToNearestEnemy <= (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 0) + 11 and (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 0) >= (oUnit[M28UnitInfo.refiDFRange] or 0) - 11 and (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:IsUnitState('Moving') or oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:IsUnitState('Attacking')) and (iSkirmisherDistToNearestEnemy <= (oUnit[M28UnitInfo.refiDFRange] or 0) - 1 and M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), M28UnitInfo.GetUnitFacingAngle(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) <= 60 or M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), M28UnitInfo.GetUnitFacingAngle(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) <= 32.5) then
                                                                --move slightly in the rally point direction
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Want to consider retreating slightly as nearest enemy is getting close to being in range and is facing towards us, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or 'nil')..' with range ='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiDFRange] or 'nil')..' and dist '..(iSkirmisherDistToNearestEnemy or 'nil')..'; our skirmisher range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Dif between closest unit facing direction and angle to us='..(M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), M28UnitInfo.GetUnitFacingAngle(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) or 'nil')) end
                                                                bUseNormalLogic = false
                                                                --tried 1.5 first, then 3; 3 ended up causing the units to stay too far away so would fire much less, 1.5 means they often do a mini-turn
                                                                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                                M28Orders.IssueTrackedMove(oUnit, M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), 2, true, false, false), 1, false, 'KStpM'..iLandZone)
                                                                --queue up attack-move after this in case we switch zones and end up idling for a while
                                                                M28Orders.IssueTrackedAggressiveMove(oUnit, M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), 5, true, false, false), 1, true, 'KStpM'..iLandZone)
                                                            end
                                                        end
                                                        --Attackmove (unless we have far more threat in this zone and arent a megalith); note that oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] is false if we havent done a close to check yet
                                                        if bUseNormalLogic then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Will attack move unless we have significantly more threat, iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; GetEnemyCombatThreatInAdjacentZones='..GetEnemyCombatThreatInAdjacentZones()..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or 'nil')..'; iVisibleDFMassInFatboyRange='..(iVisibleDFMassInFatboyRange or 'nil')..'; (oUnit[M28UnitInfo.refiDFMinRange]='..(oUnit[M28UnitInfo.refiDFMinRange] or 0)..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]..'; oUnit[M28UnitInfo.refiDFRange]='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Is unit a fatboy='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId))..'; Ignore due to being stuck='..tostring(IgnoreOrderDueToStuckUnit(oUnit) or false)..'; Main fatboy conditions='..tostring(((oUnit[M28UnitInfo.refiDFRange] or 0) >= 90 and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId) and iVisibleDFMassInFatboyRange <= 2000 and tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] <= 4000))..'; Min range condition='..tostring((oUnit[M28UnitInfo.refiDFRange] <= 120 and (oUnit[M28UnitInfo.refiDFMinRange] or 0) <= 30))..'; Fatboy category and range condition='..tostring((oUnit[M28UnitInfo.refiDFRange] or 0) >= 90 and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId))..'; Fatboy Threat conditions='..tostring(iVisibleDFMassInFatboyRange <= 2000 and tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] <= 4000)..'; Fatboy range condition='..tostring((oUnit[M28UnitInfo.refiDFRange] or 0) >= 90)..'; Fatboy category condition='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId))..'; bMoveToStopPDConstruction='..tostring(bMoveToStopPDConstruction)..'; bFiringAtNegligibleThreatInLRExperimentalRange='..tostring(bFiringAtNegligibleThreatInLRExperimentalRange)..'; Subset1 test='..tostring((iAvailableCombatUnitThreat > 1000 and ((iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 4 and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) and ((oUnit[M28UnitInfo.refiDFRange] or 0) < 64) or not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or (EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and EntityCategoryContains(categories.TECH1 + categories.TECH2, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId))))))..'; Subpart2 test='..tostring(((oUnit[M28UnitInfo.refiDFRange] or 0) >= 90 and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId) and iVisibleDFMassInFatboyRange <= 2000 and tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] <= 4000))..'; Subpart1+2 test='..tostring((((bMoveToStopPDConstruction or (iAvailableCombatUnitThreat > 1000 and ((iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 4 and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) and ((oUnit[M28UnitInfo.refiDFRange] or 0) < 64) or not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or (EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and EntityCategoryContains(categories.TECH1 + categories.TECH2, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId))))) or ((oUnit[M28UnitInfo.refiDFRange] or 0) >= 90 and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId) and iVisibleDFMassInFatboyRange <= 2000 and tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] <= 4000))) and (oUnit[M28UnitInfo.refiDFRange] <= 120 and (oUnit[M28UnitInfo.refiDFMinRange] or 0) <= 30)))..'; Is oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] false='..tostring(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] == false)..'; Close to nearest DF enemies='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange], iTeam, false, nil, oUnit, nil, math.min(oUnit[M28UnitInfo.refiDFRange], math.max(oUnit[M28UnitInfo.refiDFRange] - 3,  iEnemyBestDFRange + oUnit:GetBlueprint().Physics.MaxSpeed + 2))))..'; New subpart 1b='..tostring(((not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] == false)) or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange], iTeam, false, nil, oUnit, nil, math.min(oUnit[M28UnitInfo.refiDFRange], math.max(oUnit[M28UnitInfo.refiDFRange] - 3,  iEnemyBestDFRange + oUnit:GetBlueprint().Physics.MaxSpeed + 2))))))..'; oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] second check=false?='..tostring(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] == false)..'; 1b subsection i='..tostring(not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] == false))) end
                                                            if (bFiringAtNegligibleThreatInLRExperimentalRange or (((bMoveToStopPDConstruction or (iAvailableCombatUnitThreat > 1000 and ((iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 4 and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) and ((oUnit[M28UnitInfo.refiDFRange] or 0) < 64) or ((not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] == false)) or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange], iTeam, false, nil, oUnit, oUnit, math.min(oUnit[M28UnitInfo.refiDFRange], math.max(oUnit[M28UnitInfo.refiDFRange] - 3,  iEnemyBestDFRange + oUnit:GetBlueprint().Physics.MaxSpeed + 2))))) or (EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and EntityCategoryContains(categories.TECH1 + categories.TECH2, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId))))) or ((oUnit[M28UnitInfo.refiDFRange] or 0) >= 90 and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId) and iVisibleDFMassInFatboyRange <= 2000 and tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] <= 4000))) and (oUnit[M28UnitInfo.refiDFRange] <= 120 and (oUnit[M28UnitInfo.refiDFMinRange] or 0) <= 30))) then
                                                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will give a move order') end
                                                                    M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'KMve'..iLandZone, false)
                                                                end
                                                            else
                                                                if not(oUnit.UnitId == 'xnl0403') or DontHaveJerichoAttackTarget(oUnit) then
                                                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Will give an aggressive move order') end
                                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'KAMve'..iLandZone)
                                                                    end
                                                                    --Dont need else here as jerichoattacktarget gives order if it applies
                                                                end
                                                            end
                                                        end
                                                    end
                                                    --If we cant kite and enemy is close to us, then flag we want SR support
                                                    if not(bAttackWithOutrangedDFUnits) and not(oUnit[M28UnitInfo.refbCanKite]) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 4, iTeam, true) then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy is close to our unit which cant kite, our unit= '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so want to attack with outranged DF units') end
                                                        bAttackWithOutrangedDFUnits = true
                                                    end
                                                end
                                            else
                                                --Enemy has DF units and they are already in our range, and we can kite
                                                if bNearestEnemyNeedsManualAttack then
                                                    if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                                        if M28Utilities.GetDistanceBetweenPositions(tAmphibiousRallyPoint, oUnit:GetPosition()) <= 10 then
                                                            local oTargetToManuallyAttack = GetManualAttackTargetIfWantManualAttack(oUnit) or oNearestEnemyToFriendlyBase
                                                            DoManualAttack(oUnit, oTargetToManuallyAttack, 'UnderWARA')
                                                            --M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'UnderWARA', false)
                                                        else
                                                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                            ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tAmphibiousRallyPoint, tLZData[M28Map.subrefLZIslandRef], 'AKRetrU'..iLandZone)
                                                            --M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AKRetrU'..iLandZone)
                                                        end
                                                    else
                                                        if M28Utilities.GetDistanceBetweenPositions(tRallyPoint, oUnit:GetPosition()) <= 10 then
                                                            local oTargetToManuallyAttack = GetManualAttackTargetIfWantManualAttack(oUnit) or oNearestEnemyToFriendlyBase
                                                            DoManualAttack(oUnit, oTargetToManuallyAttack, 'UnderWARB')
                                                            --M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'UnderWARB', false)
                                                        else
                                                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                            ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tRallyPoint, tLZData[M28Map.subrefLZIslandRef],'KRetrU'..iLandZone)
                                                            --M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'KRetrU'..iLandZone)
                                                        end
                                                    end
                                                elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                                    --If the angle towards the rally point is similar to the angle towards the enemy then instead run from the nearest enemy
                                                    if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tAmphibiousRallyPoint)) <= 70 then
                                                        oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                        local iBackupDist = (oUnit:GetBlueprint().Physics.BackUpDistance or 0)
                                                        local tTemporaryRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), (iBackupDist or 9) - 1, true, false, M28Map.bIsCampaignMap)
                                                        if M28Utilities.IsTableEmpty(tTemporaryRetreatLocation) == false and NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, tTemporaryRetreatLocation) == iPlateau then
                                                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                            ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tTemporaryRetreatLocation, iPlateau, 'AKRetNE'..iLandZone, true, math.min(iBackupDist, 9))
                                                            --M28Orders.IssueTrackedMove(oUnit, tTemporaryRetreatLocation, 6, false, 'AKRetNE'..iLandZone)
                                                        else
                                                            ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tAmphibiousRallyPoint, iPlateau, 'AKRetFA', true, math.min(iBackupDist, 9))
                                                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                            --M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AKRetFA'..iLandZone)
                                                        end
                                                    else
                                                        oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                        ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tAmphibiousRallyPoint, tLZData[M28Map.subrefLZIslandRef], 'AKRetr'..iLandZone)
                                                        --M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AKRetr'..iLandZone)
                                                    end


                                                else
                                                    if EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) then iAngleThresholdForRally = 100 else iAngleThresholdForRally = 70 end
                                                    if bDebugMessages == true then
                                                        LOG(sFunctionRef..': is refoClosestEnemyFromLastCloseToEnemyUnitCheck valid='..tostring(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])))
                                                        if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                                                            LOG(sFunctionRef..': Angle from unit to nearest enemy='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())..'; Angle to rally point='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)..'; Angle dif='..M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint))..'; iAngleThresholdForRally='..iAngleThresholdForRally)
                                                        end
                                                    end

                                                    if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)) <= iAngleThresholdForRally then
                                                        local tTemporaryRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), 8, true, false, M28Map.bIsCampaignMap)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': tTemporaryRetreatLocation='..repru(tTemporaryRetreatLocation)..'; Land label='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tTemporaryRetreatLocation) or 'nil')..'; Island ref='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..'; Unit position='..repru(oUnit:GetPosition()))
                                                            M28Utilities.DrawLocation(tTemporaryRetreatLocation)
                                                        end
                                                        if M28Utilities.IsTableEmpty(tTemporaryRetreatLocation) == false and NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tTemporaryRetreatLocation) == tLZData[M28Map.subrefLZIslandRef] then
                                                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                            M28Orders.IssueTrackedMove(oUnit, tTemporaryRetreatLocation, 4, false, 'KRetNE'..iLandZone)
                                                        else
                                                            ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tRallyPoint, tLZData[M28Map.subrefLZIslandRef], 'KRetFA')
                                                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                            --M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'KRetFA'..iLandZone)
                                                        end
                                                    else
                                                        oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                        ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tRallyPoint, tLZData[M28Map.subrefLZIslandRef], 'KRetr'..iLandZone)
                                                        --M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'KRetr'..iLandZone)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Will move unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to rally point (kiting retreat), rallypoint='..repru(tRallyPoint)..'; unit position='..repru(oUnit:GetPosition())) end
                                                    end
                                                end
                                                --If enemy is able to shoot us then get DF support (unless its an ACU shooting us, in which case want an overwhelming threat to attack)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if enemy is able to shoot our unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Are we close to nearest DF enemies='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 4, iTeam, true))) end
                                                if not(bAttackWithOutrangedDFUnits) and (not(bNearestEnemyIsACU) or iAvailableCombatUnitThreat >= 2000) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 4, iTeam, true, nil, nil, oUnit) and (iAvailableCombatUnitThreat >= 2000 or not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or not(EntityCategoryContains(categories.COMMAND, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId))) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy is close to unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so want to attack with outranged DF units') end
                                                    bAttackWithOutrangedDFUnits = true
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    else
                        if ProceedWithUnitOrder(oUnit) then
                            if oUnit[M28UnitInfo.refiDFRange] > 0 and ((oUnit[M28UnitInfo.refiIndirectRange] or 0) <= (oUnit[M28UnitInfo.refiDFRange] or 0)) then
                                --We dont outrange the enemy, but we do have other units that do

                                --Skirmishers - Still retreat if are in range of enemy, even if we dont outraneg them, as may e.g. be other units that we do outrange
                                if EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbEasyBrain]) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we are in range of an enemy unit for a skirmisher as it doesnt have enough DF to outrange enemy DF; bEnemyHasNoDFUnits='..tostring(bEnemyHasNoDFUnits)..'; Is close to enemy='..tostring(not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange] - math.max(2, math.min(8, oUnit[M28UnitInfo.refiDFRange] * 0.1)), iTeam, false)))..'; bAttackWithOutrangedDFUnits='..tostring(bAttackWithOutrangedDFUnits)) end
                                    if bAttackWithOutrangedDFUnits then
                                        if bEnemyHasNoDFUnits or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange] - math.max(2, math.min(8, oUnit[M28UnitInfo.refiDFRange] * 0.1)), iTeam, false)) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Not in range of enemy yet, and we outrange enemy; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..oUnit[M28UnitInfo.refiDFRange]..'; oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..'; oNearestEnemyToFriendlyBase DF range='..(oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oNearestEnemyToFriendlyBase:GetPosition())..'; Enemy last recorded position='..repru(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; LZ midpoint position='..repru(tLZData[M28Map.subrefMidpoint])) end
                                            --Not in range yet, so attack move to the nearest enemy
                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SK1AMve'..iLandZone)
                                        else
                                            --Enemy has DF units and they are already in our range so retreat
                                            if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ASK1Retr'..iLandZone)
                                            else
                                                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'SK1Retr'..iLandZone)
                                            end

                                        end
                                    else
                                        --Only attack with skirmishers if wont get in range of enemy unit
                                        if bEnemyHasNoDFUnits or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tSkirmisherEnemies, 8, iTeam, true)) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Not in range of enemy yet, and we outrange enemy; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..oUnit[M28UnitInfo.refiDFRange]..'; oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..'; oNearestEnemyToFriendlyBase DF range='..(oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oNearestEnemyToFriendlyBase:GetPosition())..'; Enemy last recorded position='..repru(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; LZ midpoint position='..repru(tLZData[M28Map.subrefMidpoint])) end
                                            --Not in range yet, so attack move to the nearest enemy
                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SK2AMve'..iLandZone)
                                        else
                                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy has DF units in our range so will retreat to the rally point') end
                                            --Enemy has DF units and they are already in our range so retreat
                                            if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ASK2Retr'..iLandZone)
                                            else
                                                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'SK2Retr'..iLandZone)
                                            end

                                        end
                                    end
                                else
                                    table.insert(tOutrangedCombatUnits, oUnit)
                                end
                            elseif oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                                if oUnit[M28UnitInfo.refiIndirectRange] > iEnemyBestDFRange then
                                    table.insert(tUnitsToSupport, oUnit)
                                    if oUnit[M28UnitInfo.refbEasyBrain] then
                                        --Attackmove to nearest enemy
                                        if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                            M28Orders.IssueTrackedAttackMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'EsyIFAM'..iLandZone)
                                        end
                                    else
                                        if (bConsiderSpecialMMLLogic or bEnemyHasFixedShieldsInThisOrAdjacentZone) and EntityCategoryContains(M28UnitInfo.refCategoryMML, oUnit.UnitId) then
                                            table.insert(tMMLForSynchronisation, oUnit)
                                        else
                                            iIndirectDistanceInsideRangeThreshold = iIndirectRunFigureNormal
                                            if oUnit[M28UnitInfo.refbWeaponUnpacks] then iIndirectDistanceInsideRangeThreshold = iIndirectDistanceInsideRangeThreshold + iIndirectRunFigureDeployedAdjust end
                                            if bOnlyRetreatIndirectIfEnemyDFAlmostInRange then iIndirectDistanceInsideRangeThreshold = math.max(iIndirectDistanceInsideRangeThreshold + 10, ((oUnit[M28UnitInfo.refiIndirectRange] or 0) - iEnemyBestDFRange)) end


                                            if bDebugMessages == true then
                                                LOG(sFunctionRef..': Have Indirect unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that outranges the enemy (our IF range='..oUnit[M28UnitInfo.refiIndirectRange]..'; Enemy best DF range='..iEnemyBestDFRange..'), WIll list every unit in the nearest DF enemies and their distance to us; our position='..repru(oUnit:GetPosition())..'; Do we have a valid shield assigned='..tostring(oUnit[refoAssignedMobileShield] or false))
                                                for iEnemy, oEnemy in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                                                    LOG(sFunctionRef..': oEnemy '..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..' is '..M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())..'; distance based on last known position='..M28Utilities.GetDistanceBetweenPositions(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; oEnemy DF range='..(oEnemy[M28UnitInfo.refiDFRange] or 'nil')..'; Enemy Indirect range='..(oEnemy[M28UnitInfo.refiIndirectRange] or 'nil'))
                                                end
                                            end
                                            local iDistThreshold
                                            if bOnlyRetreatIndirectIfEnemyDFAlmostInRange then
                                                iDistThreshold = math.max(oUnit[M28UnitInfo.refiIndirectRange] - iIndirectDistanceInsideRangeThreshold, math.min(iEnemyBestDFRange + 5, oUnit[M28UnitInfo.refiIndirectRange] - 2))
                                                if M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileShield]) then iDistThreshold = iDistThreshold - 5 end
                                            else
                                                iDistThreshold = math.max(oUnit[M28UnitInfo.refiIndirectRange] - iIndirectDistanceInsideRangeThreshold, math.min(iEnemyBestDFRange + 10, oUnit[M28UnitInfo.refiIndirectRange] - 2))
                                                if M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileShield]) then iDistThreshold = iDistThreshold - 5 end
                                            end
                                            --CloseToEnemyUnit(tStartPosition,      tUnitsToCheck,                              iDistThreshold,                                                                                                                                                          iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure)
                                            if not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], iDistThreshold, iTeam, false                  , nil,                  nil,                                oUnit, math.min(iEnemyBestDFRange + 4.5, oUnit[M28UnitInfo.refiIndirectRange] - 2))) then
                                                --Issue specific attack if there is a structure in range due to issue where MMLs dont fire at certain buildings (such as PD) that are in range until getting close
                                                if bDebugMessages == true then
                                                    if oNearestEnemyStructureToMidpoint then
                                                        LOG(sFunctionRef..': Not too close, will attack structure if it is within our range, oNearestEnemyStructureToMidpoint='..(oNearestEnemyStructureToMidpoint.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyStructureToMidpoint) or 'nil')..'; Dist to this='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyStructureToMidpoint:GetPosition())..'; Dist between actual position and last known position='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyStructureToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oNearestEnemyStructureToMidpoint:GetPosition()))
                                                    else
                                                        LOG(sFunctionRef..': Not too close but dont have a nearest enemy structure to midpoint so will just to attack move (or gorund attack in some cases)')
                                                    end
                                                end
                                                if (oNearestEnemyStructureToMidpoint and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyStructureToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) < oUnit[M28UnitInfo.refiIndirectRange]) then
                                                    M28Orders.IssueTrackedAttack(oUnit, oNearestEnemyStructureToMidpoint, false, 'ISAtc'..iLandZone, false)
                                                elseif M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()) < oUnit[M28UnitInfo.refiIndirectRange] then
                                                    M28Orders.IssueTrackedAttack(oUnit, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], false, 'INSAtc'..iLandZone, false)
                                                else
                                                    --If have aoe attack and nearest enemy is in range and we havent fired recently and the nearest enemy isnt moving, but we have temporarily lost intel of it, then ground fire it
                                                    if (oUnit[M28UnitInfo.refiIndirectAOE] or 0) > 0 and oUnit[M28UnitInfo.refiTimeBetweenIFShots] and M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:IsUnitState('Moving')) and not(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or -1) > 1 + oUnit[M28UnitInfo.refiTimeBetweenIFShots] * 1.2 and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()) <= (oUnit[M28UnitInfo.refiIndirectRange] or 0) then
                                                        M28Orders.IssueTrackedGroundAttack(oUnit, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), math.min(1, oUnit[M28UnitInfo.refiIndirectAOE] * 0.5), false, 'IHidAtc', false)
                                                    else
                                                        if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(15, iIndirectDistanceInsideRangeThreshold), false, 'IKAMve'..iLandZone)
                                                        end
                                                    end
                                                end
                                            else
                                                --Retreat IF units (will only have IF units if are at this point) temporarily from enemy units, unless we are a T1-T2 indirect fire unit that hasnt fired for a while and enemy isn't in our range yet
                                                local iCurDistToDFEnemy = 1000
                                                if oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] then iCurDistToDFEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()) end
                                                local bTemporaryKiting = false

                                                if (oUnit[M28UnitInfo.refiIndirectAOE] or 0) > 0 and oUnit[M28UnitInfo.refiTimeBetweenIFShots] and M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or -1) > 1 + oUnit[M28UnitInfo.refiTimeBetweenIFShots] * 1.2 and iCurDistToDFEnemy > (oUnit[M28UnitInfo.refiIndirectRange] or 0) then

                                                    --Ground fire near the enemy unit
                                                    --MoveInDirection(tStart, iAngle, iDistance, bKeepInMapBounds, bTravelUnderwater, bKeepInCampaignPlayableArea)
                                                    local tGroundFireLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()), oUnit[M28UnitInfo.refiIndirectRange] - 2, true, false, M28Map.bIsCampaignMap)
                                                    M28Orders.IssueTrackedGroundAttack(oUnit, tGroundFireLocation, 2, false, 'IFKiAG'..iLandZone, false, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])
                                                elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                    if (oUnit[M28UnitInfo.refbWeaponUnpacks] or not(oUnit[M28UnitInfo.refbCanKite])) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tAmphibiousRallyPoint) <= 13 then
                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AIKRetr'..iLandZone)
                                                    else
                                                        M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AIKRetr'..iLandZone)
                                                    end
                                                else
                                                    if iCurDistToDFEnemy <= math.max((oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiCombatRange] or 0) + 8, (oUnit[M28UnitInfo.refiCombatRange] or 0) - 10) then
                                                        local tTemporaryRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), 8, true, false, M28Map.bIsCampaignMap)
                                                        if tTemporaryRetreatLocation and NavUtils.GetLabel(M28Map.refPathingTypeLand, tTemporaryRetreatLocation) == tLZData[M28Map.subrefLZIslandRef] then
                                                            bTemporaryKiting = true
                                                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                            M28Orders.IssueTrackedMove(oUnit, tTemporaryRetreatLocation, 6, false, 'IKEnRetr'..iLandZone)
                                                        end
                                                    end
                                                    if not(bTemporaryKiting) then
                                                        if (oUnit[M28UnitInfo.refbWeaponUnpacks] or not(oUnit[M28UnitInfo.refbCanKite])) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint) <= 13 then
                                                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                            M28Orders.IssueTrackedAggressiveMove(oUnit, tRallyPoint, 6, false, 'IKRetr'..iLandZone)
                                                        else
                                                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'IKRetr'..iLandZone)
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                else
                                    --Treat the same as outranged DF units
                                    table.insert(tOutrangedCombatUnits, oUnit)
                                end
                            else
                                M28Utilities.ErrorHandler('Have a unit without DF or indirect range, so will retreat with it')
                                if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                    M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AUnkRetr'..iLandZone)
                                else
                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'UnkRetr'..iLandZone)
                                end
                            end
                        elseif (oUnit[M28UnitInfo.refiIndirectRange] or 0) > iEnemyBestDFRange then
                            table.insert(tUnitsToSupport, oUnit)
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tOutrangedCombatUnits) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have outranged combat units, bAttackWithOutrangedDFUnits='..tostring(bAttackWithOutrangedDFUnits or false)) end
                    --Consider still attacking if we have a large threat for our outranged combat units
                    if not(bAttackWithOutrangedDFUnits) then
                        if bSuicideIntoFatboyOrACU and oClosestFatboyOrACUInIslandToSuicideInto then bAttackWithOutrangedDFUnits = true end
                        if not(bAttackWithOutrangedDFUnits) and iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 1.3 then
                            local iOutrangedThreat = M28UnitInfo.GetCombatThreatRating(tOutrangedCombatUnits, false, false)
                            local iLRThreat = iAvailableCombatUnitThreat - iOutrangedThreat
                            if iOutrangedThreat > 4 * GetEnemyCombatThreatInAdjacentZones() or (iOutrangedThreat > GetEnemyCombatThreatInAdjacentZones() * 1.15 and iOutrangedThreat >= math.min(2000, iLRThreat * 3.5) and (iOutrangedThreat > 2 * iLRThreat or iOutrangedThreat > math.max(5000, iLRThreat)))  then
                                if bDebugMessages == true then LOG(sFunctionRef..': We have enough short range threat to attack with it') end
                                bAttackWithOutrangedDFUnits = true
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Revisited decision on whether to attack depending on threat of outranged combat units vs overall threat, iOutrangedThreat='..iOutrangedThreat..'; iLRThreat='..iLRThreat..'; bAttackWithOutrangedDFUnits='..tostring(bAttackWithOutrangedDFUnits or false)) end
                        end
                    end
                    if bAttackWithOutrangedDFUnits then
                        for iUnit, oUnit in tOutrangedCombatUnits do
                            if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end

                            if bMoveBlockedNotAttackMove and (oUnit[M28UnitInfo.refbLastShotBlocked] or M28UnitInfo.IsUnitUnderwater(oUnit)) and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) then
                                M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'OBlckM'..iLandZone)
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                            else
                                if oUnit[M28UnitInfo.refbEasyBrain] then
                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                        M28Orders.IssueTrackedAttackMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'EsySRAM'..iLandZone)
                                    end
                                else
                                    if bConsiderAttackingACU and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), toEnemyACUsInZone, 6 + oUnit[M28UnitInfo.refiDFRange], iTeam, false, nil, nil, nil, nil, nil) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to attack ACU with experimental') end
                                        GetUnitToAttackNearestACU(oUnit)
                                        --Attackmove (unless we have far more threat in this zone)
                                    else
                                        local oTargetToManuallyAttack = GetManualAttackTargetIfWantManualAttack(oUnit)
                                        oUnit[refoSREnemyTarget] = oTargetToManuallyAttack or oNearestEnemyToFriendlyBase
                                        oUnit[refiTimeOfSREnemyTarget] = GetGameTimeSeconds()
                                        if oTargetToManuallyAttack then
                                            DoManualAttack(oUnit, oTargetToManuallyAttack, 'SRManA')
                                            --M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'SRManA', false)
                                        elseif iAvailableCombatUnitThreat > 5000 and iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 8 and not((oUnit[M28UnitInfo.refiDFRange] or 0) >= 64 or EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Want to move unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to SREnemy target='..(oUnit[refoSREnemyTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit[refoSREnemyTarget]) or 'nil')) end
                                            if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                M28Orders.IssueTrackedMove(oUnit, oUnit[refoSREnemyTarget][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SRDFM'..iLandZone, false)
                                            end
                                        else
                                            --Exception - experimentals that are in range of enemy PD
                                            if EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and not(EntityCategoryContains(M28UnitInfo.refCategoryStructure * categories.TECH2 + categories.TECH3 + categories.COMMAND - M28UnitInfo.refCategoryEngineer, oNearestEnemyToFriendlyBase.UnitId)) and GetEnemyCombatThreatInAdjacentZones() >= 5000 then
                                                --Want to try and find nearby enemy high value units
                                                if bDebugMessages == true then LOG(sFunctionRef..': Dealing with experimental '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so will look for high value enemuy threats nearby to target') end
                                                if EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and not(EntityCategoryContains(M28UnitInfo.refCategoryStructure * categories.TECH2 + categories.TECH3 + categories.COMMAND - M28UnitInfo.refCategoryEngineer, oNearestEnemyToFriendlyBase.UnitId)) and GetEnemyCombatThreatInAdjacentZones() >= 5000 then
                                                    local tNearbyHighValueUnits = oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryExperimentalLevel + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryStructure * categories.TECH3 - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryPD, oUnit:GetPosition(), (oUnit[M28UnitInfo.refiDFRange] or 20) + 15, 'Enemy')
                                                    if M28Utilities.IsTableEmpty(tNearbyHighValueUnits) == false then
                                                        oTargetToManuallyAttack = M28Utilities.GetNearestUnit(tNearbyHighValueUnits, oUnit:GetPosition())
                                                    end
                                                    if oTargetToManuallyAttack and not(oTargetToManuallyAttack:IsUnitState('Attached')) and not(M28UnitInfo.IsUnitUnderwater(oTargetToManuallyAttack)) then
                                                        if M28Utilities.GetDistanceBetweenPositions(oTargetToManuallyAttack:GetPosition(), oUnit:GetPosition()) <= (oUnit[M28UnitInfo.refiDFRange] or 0) + 1 then
                                                            DoManualAttack(oUnit, oTargetToManuallyAttack, 'SRManX')
                                                            --M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'SRManA', false)
                                                        else
                                                            M28Orders.IssueTrackedMove(oUnit, oTargetToManuallyAttack:GetPosition(), 10, 'SRxpTO', false)
                                                        end
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Targeting oTargetToManuallyAttack='..oTargetToManuallyAttack.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTargetToManuallyAttack)) end
                                                    else
                                                        if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oUnit[refoSREnemyTarget][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SRDFEA'..iLandZone)
                                                        end
                                                    end
                                                else
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Targeting nearest SR enemy target via attack move, target='..oUnit[refoSREnemyTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[refoSREnemyTarget])) end
                                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oUnit[refoSREnemyTarget][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SRDFExA'..iLandZone)
                                                    end
                                                end
                                            else
                                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oUnit[refoSREnemyTarget][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SRDFA'..iLandZone)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    else
                        --Arent attacking enemy with SR units so just want to be nearby to be ready to support
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of units to support empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToSupport))) end
                        if M28Utilities.IsTableEmpty(tUnitsToSupport) == false then
                            --Short range DF units can stay back and provide support - stay inbetween our long range DF units and the rally point

                            local iCurDist
                            local iClosestDist = 100000
                            local oClosestUnit
                            local iDistToRetreat = 10
                            local bNearestEnemyIsExperimental = false
                            if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oNearestEnemyToFriendlyBase.UnitId) then
                                bNearestEnemyIsExperimental = true
                            end

                            local tNearbyEnemyDFExperimentals = {}
                            local bEnemyHasNearbyExperimentals = false
                            if oNearestEnemyToFriendlyBase and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                                tNearbyEnemyDFExperimentals = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental, tLZTeamData[M28Map.reftoNearestDFEnemies])
                                if M28Utilities.IsTableEmpty(tNearbyEnemyDFExperimentals) == false then
                                    bEnemyHasNearbyExperimentals = true
                                end
                            end

                            for iSRUnit, oSRUnit in tOutrangedCombatUnits do
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oSRUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                                iClosestDist = 100000
                                for iLRUnit, oLRUnit in tUnitsToSupport do
                                    iCurDist = M28Utilities.GetRoughDistanceBetweenPositions(oSRUnit:GetPosition(), oLRUnit:GetPosition())
                                    if iCurDist < iClosestDist then
                                        iClosestDist = iCurDist
                                        oClosestUnit = oLRUnit
                                    end
                                end
                                if bNearestEnemyIsACU then iDistToRetreat = 20
                                elseif bNearestEnemyIsExperimental and not(EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oSRUnit.UnitId)) then iDistToRetreat = 18
                                else iDistToRetreat = 10
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': oSRUnit='..oSRUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSRUnit)..'; oSRUnit[M28UnitInfo.refbCanKite]='..tostring(oSRUnit[M28UnitInfo.refbCanKite] or false)..'; iClosestDist='..iClosestDist..'; oClosestUnit='..(oClosestUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestUnit))..'; do we have an amphibious oSRUnit='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oSRUnit.UnitId))..'; iDistToRetreat='..iDistToRetreat) end
                                if oSRUnit[M28UnitInfo.refbEasyBrain] then
                                    oSRUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                    M28Orders.IssueTrackedAttackMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), tRallyPoint), iDistToRetreat, true, false, true), 4, false, 'SReASup'..iLandZone)
                                else
                                    if bConsiderAttackingACU and not(oSRUnit[M28UnitInfo.refbLastShotBlocked]) and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryAbsolver, oSRUnit.UnitId) and M28Conditions.CloseToEnemyUnit(oSRUnit:GetPosition(), toEnemyACUsInZone, 6 + oSRUnit[M28UnitInfo.refiDFRange], iTeam, false, nil, nil, nil, nil, nil) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have an experimental we want to attack enemy ACU with') end
                                        GetUnitToAttackNearestACU(oSRUnit)
                                        --Non-fatboy experimental - if we are almost in range of enemy experimental unit then attack
                                    elseif bEnemyHasNearbyExperimentals and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryLandCombat * categories.TECH3 - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryAbsolver, oSRUnit.UnitId) and M28Conditions.CloseToEnemyUnit(oSRUnit:GetPosition(), tNearbyEnemyDFExperimentals, 5, iTeam, true, math.min(oSRUnit[M28UnitInfo.refiDFRange] or 20) - 5, oSRUnit, oSRUnit) then

                                        --Consider manual attack target
                                        local oTargetToManuallyAttack = GetManualAttackTargetIfWantManualAttack(oSRUnit, oSRUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or oNearestEnemyToFriendlyBase

                                        --Consider moving instead of attacking if not well within range
                                        if bDebugMessages == true then LOG(sFunctionRef..': SR unit Want to attack or move towards enemy manual attack target, dist to target='..M28Utilities.GetDistanceBetweenPositions(oTargetToManuallyAttack:GetPosition(), oSRUnit:GetPosition())..'; Our DF range='..oSRUnit[M28UnitInfo.refiDFRange]..'; oTargetToManuallyAttack='..(oTargetToManuallyAttack.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTargetToManuallyAttack) or 'nil')) end
                                        if M28Utilities.GetDistanceBetweenPositions(oTargetToManuallyAttack:GetPosition(), oSRUnit:GetPosition()) > oSRUnit[M28UnitInfo.refiDFRange] - 5 then
                                            M28Orders.IssueTrackedMove(oSRUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'ExpSRM'..iLandZone)
                                        else
                                            DoManualAttack(oSRUnit, oTargetToManuallyAttack, 'ExpSRA')
                                        end

                                    elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oSRUnit.UnitId) then
                                        if oSRUnit[M28UnitInfo.refbCanKite] then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Want unit to move to position '..repru(M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), tAmphibiousRallyPoint), 5, true, false, true))..'; cur position='..repru(oSRUnit:GetPosition())..'; Last orders='..reprs(oSRUnit[M28Orders.reftiLastOrders])) end
                                            if not(IgnoreOrderDueToStuckUnit(oSRUnit)) then
                                                M28Orders.IssueTrackedMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), tAmphibiousRallyPoint), iDistToRetreat, true, false, true), 5, false, 'ASRSup'..iLandZone)
                                            end
                                        else
                                            if not(IgnoreOrderDueToStuckUnit(oSRUnit)) then
                                                M28Orders.IssueTrackedAttackMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), tAmphibiousRallyPoint), iDistToRetreat, true, false, true), 5, false, 'AASRSup'..iLandZone)
                                            end
                                        end

                                    else
                                        if oSRUnit[M28UnitInfo.refbCanKite] then
                                            if not(IgnoreOrderDueToStuckUnit(oSRUnit)) then
                                                M28Orders.IssueTrackedMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), tRallyPoint), iDistToRetreat, true, false, true), 4, false, 'SRSup'..iLandZone)
                                            end
                                        else
                                            if not(IgnoreOrderDueToStuckUnit(oSRUnit)) then
                                                M28Orders.IssueTrackedAttackMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), tRallyPoint), iDistToRetreat, true, false, true), 4, false, 'SRASup'..iLandZone)
                                            end
                                        end
                                    end
                                end
                            end
                        else
                            M28Utilities.ErrorHandler('We somehow think we outrange the enemy with DF units, but have no DF units with a long range, P'..iPlateau..'Z'..iLandZone)
                        end
                    end
                end

                if math.max(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]* 0.7,tLZTeamData[M28Map.subrefThreatEnemyDFStructures] + tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal])  * 1.5 > iAvailableCombatUnitThreat then
                    bWantReinforcements = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Want reinforcements as enemy combat DF exceeds our combat rating, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Our combat units rating='..iAvailableCombatUnitThreat) end
                end

                if bUpdateNearestUnit then
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                        if aiBrain then
                            M28Team.UpdateUnitLastKnownPosition(aiBrain, oNearestEnemyToFriendlyBase, true)
                        end
                    else
                        M28Utilities.ErrorHandler('No active M28 brain')
                    end
                end
            else
                --SCENARIO 2 - we dont outrange enemy with DF, but have slightly more threat than them, or have nowhere left to run
                local bAttackWithEverything = false
                if bSuicideIntoFatboyOrACU and oClosestFatboyOrACUInIslandToSuicideInto then bAttackWithEverything = true
                elseif tLZTeamData[M28Map.subrefLZbCoreBase] and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false or M28UnitInfo.GetCombatThreatRating(tAvailableCombatUnits) >= 2500) then
                    --Attack with everything if enemy has any units in core zone, or close to core zone
                    if bDebugMessages == true then LOG(sFunctionRef..': Core base, so attack if enemies here, is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))) end
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                        bAttackWithEverything = true
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': No enemies in this zone, distance of nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), tLZData[M28Map.subrefMidpoint])..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]..'; Is nearest structure to midpoint valid='..tostring(M28UnitInfo.IsUnitValid(oNearestEnemyStructureToMidpoint))) end

                        if oNearestEnemyToFriendlyBase then
                            local iDistToNearestEnemy
                            iDistToNearestEnemy = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), tLZData[M28Map.subrefMidpoint])
                            if iDistToNearestEnemy <= 80 or (iDistToNearestEnemy <= 120 and tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] <= 300) or (iDistToNearestEnemy <= 130 and EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oNearestEnemyToFriendlyBase.UnitId)) then
                                --Attack with everything unless nearest enemy unit is a structure and we have indirect threat in this zone or that zone that outranges it

                                bAttackWithEverything = true
                            elseif oNearestEnemyStructureToMidpoint and M28Utilities.GetDistanceBetweenPositions(oNearestEnemyStructureToMidpoint:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= 160 and iFriendlyBestMobileIndirectRange >= 50 then
                                bAttackWithEverything = true
                            end
                            if bDebugMessages == true and oNearestEnemyStructureToMidpoint then LOG(sFunctionRef..': oNearestEnemyStructureToMidpoint='..oNearestEnemyStructureToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyStructureToMidpoint)..'; Distance to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyStructureToMidpoint:GetPosition(), tLZData[M28Map.subrefMidpoint])..'; IF range='..iFriendlyBestMobileIndirectRange..'; bAttackWithEverything='..tostring(bAttackWithEverything)) end
                        end
                        if not(bAttackWithEverything) then
                            --Still attack if we have significant threat
                            if table.getn(tAvailableCombatUnits) >= 60 then bAttackWithEverything = true end
                        end
                    end
                else
                    --Are we close to a core zone and enemy has a structure threat in this zone and we haev indirect fire?
                    if bDebugMessages == true and oNearestEnemyStructureToMidpoint then LOG(sFunctionRef..': Non core zone, oNearestEnemyStructureToMidpoint'..oNearestEnemyStructureToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyStructureToMidpoint)..'; Dist to closest friendly base from this zone midpoint='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase])..'; Enemy structure value='..tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] >= 100) end
                    if oNearestEnemyStructureToMidpoint and iFriendlyBestMobileIndirectRange >= 50 and tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] >= 100 and M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 175 then
                        bAttackWithEverything = true
                    end
                end
                local tOurDFAndT1ArtiUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandCombat, tAvailableCombatUnits)
                local bConsolidateAtMidpoint = false
                local iOurCombatThreat
                local tbFriendlyACUsConsidered = {}
                local bHaveACUInTroubleAndRecentlyInCombat = false
                if tLZTeamData[M28Map.refbACUInTrouble] and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false then
                    for iACU, oACU in tLZTeamData[M28Map.subrefAlliedACU] do
                        if GetGameTimeSeconds() - (oACU[M28UnitInfo.refiLastWeaponEvent] or 0) <= 10 then
                            bHaveACUInTroubleAndRecentlyInCombat = true
                            break
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tOurDFAndT1ArtiUnits) == false then
                    iOurCombatThreat = M28UnitInfo.GetCombatThreatRating(tOurDFAndT1ArtiUnits, false)
                    function IncreaseCombatThreatForACU(oACU, iFarAwayFactorOverride)
                        if not(tbFriendlyACUsConsidered[oACU.EntityId]) and M28UnitInfo.IsUnitValid(oACU) then
                            tbFriendlyACUsConsidered[oACU.EntityId] = true
                            if (not(oACU:IsUnitState('Upgrading')) and GetGameTimeSeconds() - (oACU[M28ACU.refiTimeLastWantedToRun] or -100) >= 10) or (tLZTeamData[M28Map.subrefLZbCoreBase] and (GetGameTimeSeconds() - (oACU[M28UnitInfo.refiLastWeaponEvent] or 0) <= 15)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have ACU that isnt upgrading, and doesnt want to run, in this zone, so will include unless far behind; altenratively ACU is in core base and recently fired its weapon') end
                                local iACUFactor = 1
                                if M28Map.iMapSize > 256 then iACUFactor = 0.9 end
                                if iEnemyBestStructureDFRange >= 50 then iACUFactor = 0.5 end
                                local iCurACUFactor
                                iCurACUFactor = iACUFactor
                                if not(M28Conditions.CloseToEnemyUnit(oACU:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], (oACU[M28UnitInfo.refiDFRange] or 0) + 6, iTeam, false, nil, nil, oACU, nil, false)) or (oACU:IsUnitState('Building') or oACU:IsUnitState('Repairing')) then
                                    --If it has been a while since the ACU last fired its gun then treat it as not being in combat
                                    if bDebugMessages == true then LOG(sFunctionRef..': ACU isnt close to nearest enemy, if last weapon event more than 5s then will reduce ACU value, time since last weapon event='..GetGameTimeSeconds() - (oACU[M28Events.refiLastWeaponEvent] or -100)) end
                                    if GetGameTimeSeconds() - (oACU[M28Events.refiLastWeaponEvent] or -100) >= 5 then
                                        iCurACUFactor = iCurACUFactor * (iFarAwayFactorOverride or 0.25)
                                        --Reduce even further if ACU is quite far away
                                        if not(M28UnitInfo.IsUnitValid(oACU[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) or M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oACU[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()) >= 15 + (oACU[M28UnitInfo.refiDFRange] or 0) then
                                            iCurACUFactor = iCurACUFactor * 0.3 --i.e. apply almost no value to the ACU
                                        end
                                    end
                                end
                                iOurCombatThreat = iOurCombatThreat + M28UnitInfo.GetCombatThreatRating({ oACU}, false) * iCurACUFactor
                                if bDebugMessages == true then LOG(sFunctionRef..': iACUFactor='..iACUFactor..'; iCurACUFactor='..iCurACUFactor..'; Threat of ACU='..M28UnitInfo.GetCombatThreatRating({ oACU }, false) * iACUFactor..'; Closest enemy unit to ACU='..(oACU[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oACU[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or 'nil')..'; Close to enemy DF units='..tostring(M28Conditions.CloseToEnemyUnit(oACU:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], (oACU[M28UnitInfo.refiDFRange] or 0) + 6, iTeam, false)))
                                    if oACU[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] then
                                        LOG(sFunctionRef..': Dist form ACU to nearest enemy='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oACU[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition()))
                                    end
                                end
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false then
                        for iACU, oACU in tLZTeamData[M28Map.subrefAlliedACU] do
                            IncreaseCombatThreatForACU(oACU)
                        end
                    end
                    if M28Utilities.IsTableEmpty(tUnavailableUnitsInThisLZ) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..'; Combat threat before including unavailable units='..iOurCombatThreat..'; Threat of unavailable units in this LZ='..M28UnitInfo.GetCombatThreatRating(tUnavailableUnitsInThisLZ, false)) end
                        iOurCombatThreat = iOurCombatThreat + M28UnitInfo.GetCombatThreatRating(tUnavailableUnitsInThisLZ, false)
                    end


                    --Check the threat of our available combat units vs threat of enemy combat units
                    local iEnemyCombatThreat = math.max(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 0.5, tLZTeamData[M28Map.subrefThreatEnemyDFStructures] + tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]) + iFirebaseThreatAdjust + tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat]
                    local bAdjustStructureThreat = false
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        if iFirebaseThreatAdjust == 0 then
                            local oClosestFriendlyUnit
                            local tNearbyAdjacentEnemies = {}
                            local iAdjacentDistThreshold = 0
                            local iCurDist
                            local iMinDist = 10000
                            for iUnit, oUnit in tOurDFAndT1ArtiUnits do
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                if iCurDist > iAdjacentDistThreshold then
                                    iAdjacentDistThreshold = iCurDist
                                end
                                if iCurDist < iMinDist then
                                    iMinDist = iCurDist
                                    oClosestFriendlyUnit = oUnit
                                end
                            end
                            local iAngleFromClosestFriendlyUnit = 0
                            if oClosestFriendlyUnit then iAngleFromClosestFriendlyUnit = M28Utilities.GetAngleFromAToB(oClosestFriendlyUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) end
                            if M28Map.iMapSize >= 1024 then
                                iAdjacentDistThreshold = iAdjacentDistThreshold + 20
                            elseif M28Team.iPlayersAtGameStart > 4 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] >= 2 then
                                iAdjacentDistThreshold = iAdjacentDistThreshold + 10
                            --1v1 - be even more aggressive
                            elseif M28Team.iPlayersAtGameStart <= 2 and M28Map.iMapSize <= 512 then
                                iAdjacentDistThreshold = iAdjacentDistThreshold - 5
                            end
                            --If dealing with PD, then will only include as a 'close enough' threat if the dist is closer than mobile units, factoring in range
                            if iEnemyBestStructureDFRange >= 50 then iAdjacentDistThreshold = math.max(iAdjacentDistThreshold + math.max(0, 5 + iEnemyBestStructureDFRange - (iFriendlyBestMobileDFRange or 0)), 35) end
                            local iStructureUnitDistThresholdAdjust = math.max(-30, -iAdjacentDistThreshold + 15)
                            if iAdjacentDistThreshold + iStructureUnitDistThresholdAdjust > iMinDist + 10 then
                                iStructureUnitDistThresholdAdjust = iMinDist + 10 - iAdjacentDistThreshold
                            end
                            local tbZonesConsidered = {}
                            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                --Only include units in the threat calculation if they are close enough to this LZ, or we have a firebase threat adjust
                                if bDebugMessages == true then LOG(sFunctionRef..': Will consider adding enemy units in iAdjLZ='..iAdjLZ..' if they are close enough to this zone midpoint, iAdjacentDistThreshold='..iAdjacentDistThreshold..'; iStructureUnitDistThresholdAdjust='..iStructureUnitDistThresholdAdjust) end
                                --If dealing with a core base or an ACU that is in combat then include friendly ACUs
                                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefAlliedACU]) == false then
                                    if not(bHaveACUInTroubleAndRecentlyInCombat) and tAdjLZTeamData[M28Map.refbACUInTrouble] and (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) > 0 then
                                        for iACU, oACU in tAdjLZTeamData[M28Map.subrefAlliedACU] do
                                            if GetGameTimeSeconds() - (oACU[M28UnitInfo.refiLastWeaponEvent] or 0) <= 10 then
                                                bHaveACUInTroubleAndRecentlyInCombat = true
                                                break
                                            end
                                        end
                                    end
                                    for iACU, oACU in tAdjLZTeamData[M28Map.subrefAlliedACU] do
                                        if bDebugMessages == true then LOG(sFunctionRef..': About to consider whether to incrase threat for friendly ACU in adjacent zone') end
                                        IncreaseCombatThreatForACU(oACU, 0.1)
                                    end
                                end
                                AddUnitFromAdjacentZoneToTableIfCloseEnough(tAdjLZTeamData, tNearbyAdjacentEnemies, iAdjacentDistThreshold, iStructureUnitDistThresholdAdjust, iAngleFromClosestFriendlyUnit)
                                tbZonesConsidered[iAdjLZ] = true
                            end
                            if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
                                for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                                    if not(tbZonesConsidered[tPlateauAndZone[2]]) or not(tPlateauAndZone[1] == iPlateau) then --redundancy, in theory shoudlnt be possible for adjacent zone to be recorded as dangerous nearby zone
                                        AddUnitFromAdjacentZoneToTableIfCloseEnough(M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam], tNearbyAdjacentEnemies, iAdjacentDistThreshold, iStructureUnitDistThresholdAdjust, iAngleFromClosestFriendlyUnit)
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iAdjacentDistThreshold='..iAdjacentDistThreshold..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; iEnemyBestStructureDFRange='..iEnemyBestStructureDFRange..'; Combat threat of nearby adjacent enemies to add to this='..M28UnitInfo.GetCombatThreatRating(tNearbyAdjacentEnemies, false)..'; Threat of DF units in adjacent enemies='..M28UnitInfo.GetCombatThreatRating(EntityCategoryFilterDown(categories.DIRECTFIRE, tNearbyAdjacentEnemies))) end
                            if M28Utilities.IsTableEmpty(tNearbyAdjacentEnemies) == false then
                                iEnemyCombatThreat = iEnemyCombatThreat + math.max(M28UnitInfo.GetCombatThreatRating(tNearbyAdjacentEnemies, false) * 0.5, M28UnitInfo.GetCombatThreatRating(EntityCategoryFilterDown(categories.DIRECTFIRE, tNearbyAdjacentEnemies), false))
                            end
                        else
                            if iAvailableCombatUnitThreat >= 5000 then bAdjustStructureThreat = true end

                            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                iEnemyCombatThreat = iEnemyCombatThreat + GetCombatThreatFromAdjacentZone(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam], bAdjustStructureThreat)
                            end
                            if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
                                for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                                    iEnemyCombatThreat = iEnemyCombatThreat + GetCombatThreatFromAdjacentZone(M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam], bAdjustStructureThreat)
                                end
                            end
                        end
                    else
                        if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
                            for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                                iEnemyCombatThreat = iEnemyCombatThreat + GetCombatThreatFromAdjacentZone(M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam], bAdjustStructureThreat)
                            end
                        end
                    end
                    local iOurDFAndT1ArtiUnits = table.getn(tOurDFAndT1ArtiUnits)
                    if not(bAttackWithEverything) and iOurDFAndT1ArtiUnits >= 125 and iOurDFAndT1ArtiUnits - table.getn(tLZTeamData[M28Map.subrefTEnemyUnits]) >= 50 then bAttackWithEverything = true end
                    if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to attack with everything - pre firebase and beachhead adjust bAttackWithEverything='..tostring(bAttackWithEverything)..'; iOurCombatThreat='..iOurCombatThreat..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; iFirebaseThreatAdjust='..iFirebaseThreatAdjust..'; bHaveSignificantCombatCloserToFirebase='..tostring(bHaveSignificantCombatCloserToFirebase)..'; tLZTeamData[M28Map.subrefLZTValue]='..tLZTeamData[M28Map.subrefLZTValue]..'; Have enough threat to attack='..tostring(M28Conditions.HaveEnoughThreatToAttack(iPlateau, iLandZone, tLZData, tLZTeamData, iOurCombatThreat, iEnemyCombatThreat, iFirebaseThreatAdjust, bHaveSignificantCombatCloserToFirebase, iTeam))..'; oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..'; Is brain civilian='..tostring(M28Conditions.IsCivilianBrain(oNearestEnemyToFriendlyBase:GetAIBrain()))..'; iClosestFriendlyUnitToAnEnemyFirebase='..(iClosestFriendlyUnitToAnEnemyFirebase or 'nil')..'; iFirebaseThreatAdjust='..(iFirebaseThreatAdjust or 'nil')) end
                    if not(bAttackWithEverything) and (not(EntityCategoryContains(M28UnitInfo.refCategoryPD, oNearestEnemyToFriendlyBase.UnitId)) or not(M28Conditions.IsCivilianBrain(oNearestEnemyToFriendlyBase:GetAIBrain()))) then
                        if M28Conditions.HaveEnoughThreatToAttack(iPlateau, iLandZone, tLZData, tLZTeamData, iOurCombatThreat, iEnemyCombatThreat, iFirebaseThreatAdjust, bHaveSignificantCombatCloserToFirebase, iTeam) then
                            --Extra check if have a firebase - only want to include friendly units that are near our closest unit to enemy firebase
                            if iClosestFriendlyUnitToAnEnemyFirebase <= 170 and iFirebaseThreatAdjust > 0 then
                                --Get new combat threat based on allied mobile DF and indirect fire units around this unit
                                local iSearchRange = math.max(40, math.min(140, 15 + table.getn(tOurDFAndT1ArtiUnits)))

                                local iNearbyCombatThreat = math.min(iOurCombatThreat, M28UnitInfo.GetCombatThreatRating(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains][1]:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat, oClosestFriendlyUnitToAnEnemyFirebase:GetPosition(), iSearchRange, 'Ally'), false))
                                if bDebugMessages == true then LOG(sFunctionRef..': Nearby combat threat='..iNearbyCombatThreat..'; iEnemyCombatThreat='..iEnemyCombatThreat) end
                                if iNearbyCombatThreat > iEnemyCombatThreat * 1.5 or (iNearbyCombatThreat > iEnemyCombatThreat * 1.15 and iNearbyCombatThreat >= 20000) or (iNearbyCombatThreat > iEnemyCombatThreat and bHaveSignificantCombatCloserToFirebase) then
                                    bAttackWithEverything = true
                                else
                                    bAttackWithEverything = false
                                    bConsolidateAtMidpoint = true
                                end
                            else
                                bAttackWithEverything = true
                            end
                        end
                        --NOTE: We have "suicide into mex logic" later on; however htis also does a similar thing but is intended to mean units like microbots will be more aggressive early on to target engis and mexes
                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to try attacking exposed enemy unit, iOurCombatThreat='..iOurCombatThreat..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; iFirebaseThreatAdjust='..iFirebaseThreatAdjust..'; oNearestEnemyToFriendlyBase.UnitId='..oNearestEnemyToFriendlyBase.UnitId..'; is table of shields covering empty='..tostring(M28Utilities.IsTableEmpty(oNearestEnemyToFriendlyBase[M28Building.reftoShieldsProvidingCoverage]))) end
                        if not(bAttackWithEverything) and iOurCombatThreat > 0 and iOurCombatThreat <= 3500 and iEnemyCombatThreat <= 5000 and (iFirebaseThreatAdjust == 0 or (EntityCategoryContains(M28UnitInfo.refCategoryStructure, oNearestEnemyToFriendlyBase.UnitId) and M28Utilities.IsTableEmpty(oNearestEnemyToFriendlyBase[M28Building.reftoShieldsProvidingCoverage])) and (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) == 0 and oNearestEnemyToFriendlyBase and EntityCategoryContains(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryStructure - categories.DIRECTFIRE, oNearestEnemyToFriendlyBase.UnitId)) then
                            local iDistToNearestEnemyDFUnitLessRange = 10000
                            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                                local iCurDistLessRange
                                for iEnemy, oEnemy in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                                    iCurDistLessRange = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), tLZData[M28Map.subrefMidpoint]) - (oEnemy[M28UnitInfo.refiDFRange] or 0)
                                    if iCurDistLessRange < iDistToNearestEnemyDFUnitLessRange then iDistToNearestEnemyDFUnitLessRange = iCurDistLessRange end
                                end
                            end
                            local iDistToNearestEnemy = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oNearestEnemyToFriendlyBase:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': iDistToNearestEnemy='..iDistToNearestEnemy..'; iDistToNearestEnemyDFUnitLessRange='..iDistToNearestEnemyDFUnitLessRange) end
                            if iDistToNearestEnemyDFUnitLessRange > iDistToNearestEnemy + 25 then
                                --Good chance we can attack the enemy engi/mex before we die
                                bAttackWithEverything = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Will try and attack nearest enemy unit') end
                            end
                        end
                    end
                    if not(bAttackWithEverything) and tLZTeamData[M28Map.refbIslandBeachhead] then
                        --May have units nearby underwater that want to include
                        local iSearchRange = math.max(40, math.min(140, 15 + table.getn(tOurDFAndT1ArtiUnits)))

                        local oClosestFriendlyToEnemy
                        local iCurDist
                        local iClosestDist = 100000
                        for iUnit, oUnit in tAvailableCombatUnits do
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oClosestFriendlyToEnemy = oUnit
                            end
                        end
                        local iNearbyCombatThreat = math.max(iOurCombatThreat, M28UnitInfo.GetCombatThreatRating(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains][1]:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat, oClosestFriendlyToEnemy:GetPosition(), iSearchRange, 'Ally'), false))
                        if iNearbyCombatThreat > iEnemyCombatThreat then
                            bAttackWithEverything = true
                        elseif iNearbyCombatThreat > 1.2 * math.max(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 0.5, tLZTeamData[M28Map.subrefThreatEnemyDFStructures] + tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]) and tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] then
                            bAttackWithEverything = true
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Island beachhead Nearby combat threat='..iNearbyCombatThreat..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; tLZTeamData[M28Map.subrefThreatEnemyDFStructures]='..tLZTeamData[M28Map.subrefThreatEnemyDFStructures]..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]..'; bAttackWithEverythign='..tostring(bAttackWithEverything)..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])) end
                    end
                    --Dont have a massive army - consider staying if enemy has mexes in this zone and we have more threat than enemy threat that is just in this zone
                    if not(bAttackWithEverything) and iOurCombatThreat < 10000 and iOurCombatThreat > (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) and tLZData[M28Map.subrefLZMexCount] > 0 and tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] > 10 then
                        local bCouldDoSomeDamage = false
                        local tEnemyBuildings = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryPD - M28UnitInfo.refCategoryStructureAA - M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subrefTEnemyUnits])
                        if M28Utilities.IsTableEmpty(tEnemyBuildings) == false then
                            for iUnit, oUnit in tEnemyBuildings do
                                if oUnit:GetFractionComplete() == 1 then
                                    bCouldDoSomeDamage = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will consider being more aggressive as enemy has buildings we could try and kill even if overall we might be outnumbered soon') end
                                    break
                                end
                            end
                        end
                        if bCouldDoSomeDamage then
                            --Would our retreat path take us somewhere dangerous? in which case stay and attack
                            local tAdjacentZoneRally = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 1, false)
                            if M28Utilities.IsTableEmpty(tAdjacentZoneRally) then
                                bAttackWithEverything = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Nowhere to retreat so will attack to try and do some damage') end
                            else
                                local tAdjacentRallyData, tAdjacentRallyTeamData = M28Map.GetLandOrWaterZoneData(tAdjacentZoneRally, true, iTeam)
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy combat in adj rally point zone='..tAdjacentRallyTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; iOurCombatThreat='..iOurCombatThreat) end
                                if tAdjacentRallyTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 0.4 * iOurCombatThreat then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Is dangerous to retreat so might as well attack and try and do some damage') end
                                    bAttackWithEverything = true
                                end
                            end
                        end
                    end

                    if iOurCombatThreat < iEnemyCombatThreat * 1.4 or not(bAttackWithEverything) then
                        bWantReinforcements = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Want reinforcements as iOurCombatThreat='..iOurCombatThreat..'; iEnemyCombatThreat='..iEnemyCombatThreat) end
                    end

                    --Attack with everythign if ACU is in trouble and in combat
                    if bHaveACUInTroubleAndRecentlyInCombat then
                        bAttackWithEverything = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Will attack with everything as ACU is in trouble') end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': We dont outrange enemy, considering if we have much more threat than them, iEnemyCombatThreat='..iEnemyCombatThreat..'; iOurCombatThreat='..iOurCombatThreat..'; bWantReinforcements='..tostring(bWantReinforcements)..'; bAttackWithEverything='..tostring(bAttackWithEverything)..'; iClosestFriendlyUnitToAnEnemyFirebase='..iClosestFriendlyUnitToAnEnemyFirebase..'; iFirebaseThreatAdjust='..iFirebaseThreatAdjust..'; bHaveACUInTroubleAndRecentlyInCombat='..tostring(bHaveACUInTroubleAndRecentlyInCombat or false)) end
                else
                    if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                        bWantReinforcements = true
                        if bDebugMessages == true then LOG(sFunctionRef..': We have no friendly units in this LZ but enemy has units here or adjacent LZ so want reinforcements. iFriendlyBestMobileIndirectRange='..iFriendlyBestMobileIndirectRange..'; Is there a valid enemy structure to midpoint='..tostring(M28UnitInfo.IsUnitValid(oNearestEnemyStructureToMidpoint))) end
                    end
                    if iFriendlyBestMobileIndirectRange == 0 or not(oNearestEnemyStructureToMidpoint) then
                        bAttackWithEverything = false
                    end
                end
                local bSuicideUnitsNearAMex = false
                local tNearbyMexes
                if not(bAttackWithEverything) and oNearestEnemyToFriendlyBase then
                    if (tLZTeamData[M28Map.subrefLZbCoreBase] or tLZTeamData[M28Map.subrefLZCoreExpansion]) then
                        --Is enemy almost in range of the midpoint for this zone such that we want to attack even though we will probably lose?

                        if M28Utilities.GetDistanceBetweenPositions(       tLZData[M28Map.subrefMidpoint], oNearestEnemyToFriendlyBase:GetPosition()) <= 15 + math.max((oNearestEnemyToFriendlyBase[M28UnitInfo.refiIndirectRange] or 0), (oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0)) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy unit is almost in range of our midpoint') end
                            bAttackWithEverything = true
                            --CloseToEnemyUnit(tStartPosition,                  tUnitsToCheck,                              iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure)
                        elseif M28Conditions.CloseToEnemyUnit(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftoNearestDFEnemies],    10,             iTeam, true                  , nil,                  nil,                                nil,                                       nil) then
                            bAttackWithEverything = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy DF units are almost in range of our midpoint') end
                        end
                    end
                    --Suicide into mex logic
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to suicide mex, iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; EnemyMobileDFTotal='..(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)..'; Ally mobile DF total='..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]..'; Ally mobile IF total='..tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]..'; Enemy best structure DF range='..(tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0)..'; Mex count='..tLZData[M28Map.subrefLZMexCount]..'; Enemy structure mass='..(tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0)..'; Is table of enemy mexes empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tLZTeamData[M28Map.subrefTEnemyUnits])))) end
                    if not(bAttackWithEverything) then
                        if tLZData[M28Map.subrefLZMexCount] > 0 and iAvailableCombatUnitThreat >= math.min(100, (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)) and (tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) > 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                            tNearbyMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tLZTeamData[M28Map.subrefTEnemyUnits])
                            if M28Utilities.IsTableEmpty(tNearbyMexes) == false then
                                if iAvailableCombatUnitThreat >= (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) and tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] + tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] > (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) and (tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0) == 0 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will try attacking with everything as we may be able to kill some mexes as weh ave more threat than enemy in this zone specifically') end
                                    bAttackWithEverything = true
                                else
                                    --Do we have units close enough to mexes that they could probably try and kill it even if enemy has a stronger force overall?
                                    bSuicideUnitsNearAMex = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': when retreating we will consider still attacking with units that are near a mex') end
                                end
                            end
                        end
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Dont outrange enemy, bAttackWithEverything='..tostring(bAttackWithEverything)..'; Is table of ACUs in the LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]))) end
                local bUpdateNearestUnit = false
                local bCheckIfNearestUnitVisible = bUpdateNearestUnit
                if not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) >= 10 then
                    bCheckIfNearestUnitVisible = true
                end

                if bAttackWithEverything then
                    local bMoveToStopPDConstruction = false
                    if bDebugMessages == true then LOG(sFunctionRef..': Seeing if we have enough threat to try and stop PD being built, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; iAvailableCombatUnitThreat='..(iAvailableCombatUnitThreat or 'nil')) end
                    if M28Utilities.IsTableEmpty(tEnemyEngineers) == false and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 100 and (iAvailableCombatUnitThreat or 0) >= math.min(40, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 3) and GetEnemyCombatThreatInAdjacentZones() <= 500  then
                        local tEnemyPD = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD, tLZTeamData[M28Map.subrefTEnemyUnits])
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy PD empty='..tostring(M28Utilities.IsTableEmpty(tEnemyPD))) end
                        if M28Utilities.IsTableEmpty(tEnemyPD) == false then
                            bMoveToStopPDConstruction = true
                            for iPD, oPD in tEnemyPD do
                                if oPD:GetFractionComplete() == 1 then
                                    bMoveToStopPDConstruction = false
                                    break
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': bMoveToStopPDConstruction before doublechecking threats='..tostring(bMoveToStopPDConstruction)) end
                            if bMoveToStopPDConstruction then
                                --Check we have significantly more threat if excluding under-construction PD
                                bMoveToStopPDConstruction = false
                                local iPDThreat = M28UnitInfo.GetCombatThreatRating(tEnemyPD, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': iPDThreat='..iPDThreat) end
                                if (iAvailableCombatUnitThreat or 0) > 2 * tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] - iPDThreat and (iAvailableCombatUnitThreat or 0) >= GetEnemyCombatThreatInAdjacentZones() then
                                    bMoveToStopPDConstruction = true
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Will attack with everything, oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oNearestEnemyToFriendlyBase))..'; oNearestEnemyToFriendlyBase position='..repru(oNearestEnemyToFriendlyBase:GetPosition())..'; Last known position='..repru(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; bMoveToStopPDConstruction='..tostring(bMoveToStopPDConstruction or false)) end
                    local bMoveTowardsEngineers = false
                    if M28Utilities.IsTableEmpty(tEnemyEngineers) == false and iAvailableCombatUnitThreat <= 400 and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 100 and (iAvailableCombatUnitThreat or 0) >= math.min(40, tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 3) and GetEnemyCombatThreatInAdjacentZones() <= 500 then
                        bMoveTowardsEngineers = true
                    end
                    local bFiringAtNegligibleThreatInLRExperimentalRange = false
                    --local bCheckIfNearLocationToAvoid = not(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftiLocationsToAvoid]))

                    bGivenCombatUnitsOrders = true
                    for iUnit, oUnit in tAvailableCombatUnits do
                        --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                        if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                        if bDebugMessages == true then LOG(sFunctionRef..': Attacking with everything, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Special micro active='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive] or false)) end
                        if ProceedWithUnitOrder(oUnit) then
                            if oUnit[M28UnitInfo.refbEasyBrain] then
                                if bMoveBlockedNotAttackMove and (oUnit[M28UnitInfo.refbLastShotBlocked] or M28UnitInfo.IsUnitUnderwater(oUnit)) and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) then
                                    M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'BAesWE'..iLandZone)
                                else
                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'AWes'..iLandZone)
                                end
                            else
                                --if bCheckIfNearLocationToAvoid and EntityCategoryContains(categories.TECH1 + categories.TECH2 - categories.COMMAND, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbSpecialMicroActive]) and M28Conditions.HaveSentOrderToRunAwayFromLocationToAvoid(oUnit, tLZTeamData[M28Map.reftiLocationsToAvoid], 4) then
                                --if bDebugMessages == true then LOG(sFunctionRef..': Unit will run away from location to avoid') end
                                if oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                                    if oUnit[M28UnitInfo.refiIndirectRange] >= iEnemyBestDFRange then
                                        if bConsiderSpecialMMLLogic and EntityCategoryContains(M28UnitInfo.refCategoryMML, oUnit.UnitId) then table.insert(tMMLForSynchronisation, oUnit)
                                        else
                                            iIndirectDistanceInsideRangeThreshold = iIndirectRunFigureNormal
                                            if oUnit[M28UnitInfo.refbWeaponUnpacks] then iIndirectDistanceInsideRangeThreshold = iIndirectDistanceInsideRangeThreshold + iIndirectRunFigureDeployedAdjust end
                                            if bOnlyRetreatIndirectIfEnemyDFAlmostInRange then iIndirectDistanceInsideRangeThreshold = math.max(iIndirectDistanceInsideRangeThreshold + 10, ((oUnit[M28UnitInfo.refiIndirectRange] or 0) - iEnemyBestDFRange)) end

                                            local iDistThreshold
                                            if bOnlyRetreatIndirectIfEnemyDFAlmostInRange then
                                                iDistThreshold = math.max(oUnit[M28UnitInfo.refiIndirectRange] - iIndirectDistanceInsideRangeThreshold, math.min(iEnemyBestDFRange + 5, oUnit[M28UnitInfo.refiIndirectRange] - 2))
                                                if M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileShield]) then iDistThreshold = iDistThreshold - 5 end
                                            else
                                                iDistThreshold = math.max(oUnit[M28UnitInfo.refiIndirectRange] - iIndirectDistanceInsideRangeThreshold, math.min(iEnemyBestDFRange + 10, oUnit[M28UnitInfo.refiIndirectRange] - 2))
                                                if M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileShield]) then iDistThreshold = iDistThreshold - 5 end
                                            end

                                            if not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], iDistThreshold, iTeam, false)) then
                                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(15, iIndirectDistanceInsideRangeThreshold), false, 'I2KAMve'..iLandZone)
                                                end
                                            else
                                                --Retreat temporarily from enemy units
                                                if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                    M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AI2KRetr'..iLandZone)
                                                else
                                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'I2KRetr'..iLandZone)
                                                end
                                            end
                                        end
                                    else
                                        --Treat the same as outranged DF units
                                        if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'I2AWE'..iLandZone)
                                        end
                                    end
                                elseif EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) then
                                    --Still retreat if are in range of enemy, even if we dont outraneg them, as may e.g. be other units that we do outrange
                                    if bEnemyHasNoDFUnits or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange] - math.max(2, oUnit[M28UnitInfo.refiDFRange] * 0.06), iTeam, false)) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Not in range of enemy yet, and we outrange enemy; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..oUnit[M28UnitInfo.refiDFRange]..'; oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..'; oNearestEnemyToFriendlyBase DF range='..(oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oNearestEnemyToFriendlyBase:GetPosition())..'; Enemy last recorded position='..repru(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; LZ midpoint position='..repru(tLZData[M28Map.subrefMidpoint])) end
                                        --Not in range yet, so attack move to the nearest enemy
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SKAMve'..iLandZone)
                                    else
                                        --Enemy has DF units and they are already in our range so retreat
                                        if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ASKRetr'..iLandZone)
                                        else
                                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'SKRetr'..iLandZone)
                                        end

                                    end
                                else
                                    if bSuicideIntoFatboyOrACU and oClosestFatboyOrACUInIslandToSuicideInto then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will move to nearest fatboy='..oClosestFatboyOrACUInIslandToSuicideInto.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestFatboyOrACUInIslandToSuicideInto)..' with unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                        M28Orders.IssueTrackedMove(oUnit, oClosestFatboyOrACUInIslandToSuicideInto:GetPosition(), 6, false, 'SuicFB'..iLandZone)
                                    elseif bMoveBlockedNotAttackMove and (oUnit[M28UnitInfo.refbLastShotBlocked] or M28UnitInfo.IsUnitUnderwater(oUnit)) and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) then
                                        M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'BAWE'..iLandZone)
                                    else
                                        if bConsiderAttackingACU and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), toEnemyACUsInZone, 6 + oUnit[M28UnitInfo.refiDFRange], iTeam, false, nil, nil, nil, nil, nil) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will attack ACU with experimental') end
                                            GetUnitToAttackNearestACU(oUnit)

                                            --Fatboy and megalith - want to be more cautious than normal units but less so than skirmishers
                                        elseif (oUnit[M28UnitInfo.refiDFRange] or 0) >= 64 and EntityCategoryContains(M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryMegalith, oUnit.UnitId) then
                                            --Attackmove unless enemy threat is minimal in this zone and dont have notable neemies in range using getunitsaroundpoint
                                            bFiringAtNegligibleThreatInLRExperimentalRange = false
                                            --Note - iVisibleDFMassInFatboyRange uses getunitsaroundpoint so wont factor in memory; therefore want to use more accurate method to avoid fatboy charging towards a monkeylord that recently fired at us
                                            if (oUnit[M28UnitInfo.refiDFRange] or 0) >= 60 and EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and (iVisibleDFMassInFatboyRange <= 3000 or not(EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId))) then
                                                --Only consider if we have fired in the last 10s (otherwise it doesnt matter)
                                                if oUnit[M28UnitInfo.refiLastWeaponEvent] and GetGameTimeSeconds() - oUnit[M28UnitInfo.refiLastWeaponEvent] <= 10 then
                                                    --Get accurate measure of enemy threat within our range
                                                    bFiringAtNegligibleThreatInLRExperimentalRange = M28Conditions.HaveSignificantEnemyThreatWithinRange(tLZData, tLZTeamData, iPlateau, iTeam, oUnit[M28UnitInfo.refiDFRange] + 3, oUnit:GetPosition(), 1500, M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryT2PlusPD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryNavalSurface - categories.TECH1 + categories.COMMAND, tUnitsNearFatboyInFurtherAwayZones)
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': Scen2 bFiringAtNegligibleThreatInLRExperimentalRange='..tostring(bFiringAtNegligibleThreatInLRExperimentalRange)..'; Time since we last fired weapon='..(GetGameTimeSeconds() - oUnit[M28UnitInfo.refiLastWeaponEvent] or 0)..'; Have significant enemy threat within range='..tostring(M28Conditions.HaveSignificantEnemyThreatWithinRange(tLZData, tLZTeamData, iPlateau, iTeam, oUnit[M28UnitInfo.refiDFRange] + 3, oUnit:GetPosition(), 1500, M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryT2PlusPD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryNavalSurface - categories.TECH1 + categories.COMMAND, tUnitsNearFatboyInFurtherAwayZones))) end
                                            end

                                            if bFiringAtNegligibleThreatInLRExperimentalRange or (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 1500 and GetEnemyCombatThreatInAdjacentZones() <= 6000 and M28Utilities.IsTableEmpty(oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryNavalSurface - categories.TECH1 - categories.TECH2 * categories.MOBILE * categories.LAND + categories.COMMAND, oUnit:GetPosition(), (oUnit[M28UnitInfo.refiDFRange] or 0), 'Enemy'))) then
                                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                    M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'FBMWE'..iLandZone, false)
                                                end
                                            else
                                                local oTargetToManuallyAttack = GetManualAttackTargetIfWantManualAttack(oUnit)
                                                if oTargetToManuallyAttack and not(oTargetToManuallyAttack == oNearestEnemyToFriendlyBase) then
                                                    DoManualAttack(oUnit, oTargetToManuallyAttack, 'Sc2LRManA')
                                                    --M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'Sc2LRManA', false)
                                                else
                                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'FBAWE'..iLandZone)
                                                    end
                                                end
                                            end

                                            --Attackmove (unless we have far more threat in this zone)
                                        else
                                            local bUseNormalLogic = true
                                            if bMoveTowardsEngineers and oUnit[M28UnitInfo.refiDFRange] > 0 and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) then
                                                local oNearestEngineerToUnit = M28Utilities.GetNearestUnit(tEnemyEngineers, oUnit:GetPosition())
                                                if oNearestEngineerToUnit then
                                                    --Use normal logic if are almost in reclaim range of the engineer
                                                    local iDistToEngineer = M28Utilities.GetDistanceBetweenPositions(oNearestEngineerToUnit:GetPosition(), oUnit:GetPosition())
                                                    if bDebugMessages == true then LOG(sFunctionRef..': oNearestEngineerToUnit='..oNearestEngineerToUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEngineerToUnit)..'; iDistToEngineer='..iDistToEngineer..'; oUnit[M28UnitInfo.refiDFRange]='..oUnit[M28UnitInfo.refiDFRange] ..'; Eng build range='..(oNearestEngineerToUnit:GetBlueprint().Economy.MaxBuildDistance or 0)) end
                                                    if not(iDistToEngineer <= math.min(oUnit[M28UnitInfo.refiDFRange] - 3, (oNearestEngineerToUnit:GetBlueprint().Economy.MaxBuildDistance or 0) + 5)) then
                                                        --Move towards the engineer, or attack move if are close
                                                        bUseNormalLogic = false
                                                        if iDistToEngineer <= oUnit[M28UnitInfo.refiDFRange] - 2.5 then
                                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEngineerToUnit:GetPosition(), math.min(4, oUnit[M28UnitInfo.refiDFRange] * 0.5), false, 'EnS2AMve'..iLandZone, false)
                                                        else
                                                            M28Orders.IssueTrackedMove(oUnit, oNearestEngineerToUnit:GetPosition(), math.min(4, oUnit[M28UnitInfo.refiDFRange]  * 0.5), false, 'EnS2Mve'..iLandZone, false)
                                                        end
                                                    end
                                                end
                                            end
                                            if bUseNormalLogic then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to move or attack move to target (or in some cases do manuyal attack), iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; GetEnemyCombatThreatInAdjacentZones='..GetEnemyCombatThreatInAdjacentZones()..'; Enemy indirect threat='..(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 'nil')..'; oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase))..'; tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat]='..(tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 'nil')..'; Unit DF threat='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Can unit kite='..tostring(oUnit[M28UnitInfo.refbCanKite])) end
                                                if  ((bMoveToStopPDConstruction and not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tEnemyEngineers, math.min(15, oUnit[M28UnitInfo.refiDFRange] - 4.5), iTeam, false, nil, nil))) or ((iAvailableCombatUnitThreat > 5000 or EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategoryFatboy, oUnit.UnitId)) and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)))) and
                                                        ((iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 5) or
                                                                --If lots of T1 arti want to keep moving with experimentals/other units or theyll get slaughtered; similarly if lots of low order spam and nothing significant in range then keep moving; also keep moving if we have more threat than all enemy nearby units
                                                                (iAvailableCombatUnitThreat > math.max(800, GetEnemyCombatThreatInAdjacentZones() * 0.8) and tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] > 500 and (oUnit[M28UnitInfo.refiDFRange] or 0) > 0) or
                                                                (iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() and EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and (iAvailableCombatUnitThreat > GetEnemyCombatThreatInAdjacentZones() * 1.4 or tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] > 0 or EntityCategoryContains(M28UnitInfo.refCategoryIndirect + M28UnitInfo.refCategorySkirmisher, oNearestEnemyToFriendlyBase.UnitId) or M28Utilities.IsTableEmpty(oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryExperimentalLevel + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryStructure * categories.TECH3 - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryPD, oUnit:GetPosition(), (oUnit[M28UnitInfo.refiDFRange] or 20), 'Enemy')))) or
                                                                --Below to try and e.g. stop megalith attack-moving when enemy has nearby ravagers
                                                                (not(oUnit[M28UnitInfo.refbCanKite]) and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategoryFatboy, oUnit.UnitId)) and tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] > 500) then

                                                    --If have experimental unit and closest enemy unit to midpoint isn't a priority then consider alternative targets
                                                    local oTargetToManuallyAttack = GetManualAttackTargetIfWantManualAttack(oUnit, oNearestEnemyToFriendlyBase)
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will move instead of attack move subject to manual attack overrides, Do we have a target to manually attack? oTargetToManuallyAttack='..(oTargetToManuallyAttack.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTargetToManuallyAttack) or 'nil')..'; oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase) or 'nil')) end
                                                    if oTargetToManuallyAttack and not(oTargetToManuallyAttack == oNearestEnemyToFriendlyBase) then
                                                        DoManualAttack(oUnit, oTargetToManuallyAttack, 'Sc3ManA')
                                                        --M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'Sc3ManA', false)
                                                    else
                                                        if EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and not(EntityCategoryContains(M28UnitInfo.refCategoryStructure * categories.TECH2 + categories.TECH3 + categories.COMMAND - M28UnitInfo.refCategoryEngineer, oNearestEnemyToFriendlyBase.UnitId)) and GetEnemyCombatThreatInAdjacentZones() >= 5000 then
                                                            --Want to try and find nearby enemy high value units
                                                            local iSearchHigherThreshold = 50
                                                            if (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) > 1000 then iSearchHigherThreshold = 73 end
                                                            local tNearbyHighValueUnits = oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryExperimentalLevel + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryStructure * categories.TECH3 - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryPD, oUnit:GetPosition(), math.max((oUnit[M28UnitInfo.refiDFRange] or 20) + 15, iSearchHigherThreshold), 'Enemy')
                                                            if M28Utilities.IsTableEmpty(tNearbyHighValueUnits) == false then
                                                                oTargetToManuallyAttack = M28Utilities.GetNearestUnit(tNearbyHighValueUnits, oUnit:GetPosition())
                                                            end
                                                            if oTargetToManuallyAttack and not(oTargetToManuallyAttack:IsUnitState('Attached')) and not(M28UnitInfo.IsUnitUnderwater(oTargetToManuallyAttack)) then
                                                                if M28Utilities.GetDistanceBetweenPositions(oTargetToManuallyAttack:GetPosition(), oUnit:GetPosition()) <= (oUnit[M28UnitInfo.refiDFRange] or 0) + 1 then
                                                                    DoManualAttack(oUnit, oTargetToManuallyAttack, 'Sc4ManX')
                                                                    --M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'Sc4ManA', false)
                                                                else
                                                                    M28Orders.IssueTrackedMove(oUnit, oTargetToManuallyAttack:GetPosition(), 10, 'MExpTO', false)
                                                                end
                                                            else
                                                                --Do same as below
                                                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                                    M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'MExpWE'..iLandZone, false)
                                                                end
                                                            end
                                                        else
                                                            if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                                M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'MWE'..iLandZone, false)
                                                            end
                                                        end
                                                    end
                                                else
                                                    local oTargetToManuallyAttack = GetManualAttackTargetIfWantManualAttack(oUnit)
                                                    if oTargetToManuallyAttack and not(oTargetToManuallyAttack == oNearestEnemyToFriendlyBase) then
                                                        DoManualAttack(oUnit, oTargetToManuallyAttack, 'Sc2ManA')
                                                        --M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'Sc2ManA', false)
                                                    else
                                                        if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'AWE'..iLandZone)
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                else
                    --SCENARIO 3 - Enemy outranges us and we dont ahve enough threat / high enough priority location to defend so want to retreat; exception to this if enemy has an experimental unit and it is in the same LZ as us, in which case want to attack with any units that are within 10 of being in range of it
                    --Also exceptio nif we have an experimental unit that cant kite, in which case it will attack-move to the rally point
                    local tNearbyEnemyExperimentals
                    local bConsiderAttackingExperimental = false
                    if oNearestEnemyToFriendlyBase then
                        tNearbyEnemyExperimentals = EntityCategoryFilterDown(categories.EXPERIMENTAL, tLZTeamData[M28Map.reftoNearestDFEnemies])
                        if M28Utilities.IsTableEmpty(tNearbyEnemyExperimentals) == false then
                            bConsiderAttackingExperimental = true
                        end
                    end

                    local sRetreatMessage = 'GenRetr'

                    --Rescue ACU - move slightly infront of ACU relative to our closest base instead of retreating
                    if tLZTeamData[M28Map.refbACUInTrouble] and oNearestEnemyToFriendlyBase and M28Conditions.IsTableOfUnitsStillValid(tLZTeamData[M28Map.subrefAlliedACU]) then
                        local oACUToProtect
                        local iLowestHealthACU = 100000
                        for iACU, oACU in tLZTeamData[M28Map.subrefAlliedACU] do
                            if M28UnitInfo.IsUnitValid(oACU) and oACU:GetHealth() < iLowestHealthACU then
                                iLowestHealthACU = oACU:GetHealth()
                                oACUToProtect = oACU
                            end
                        end
                        if oACUToProtect then --Redundancy
                            local iDistInfrontOfACUWanted = math.min(20, 5 + table.getn(tAvailableCombatUnits) * 0.25)
                            local tProtectiveMovePoint = M28Utilities.MoveInDirection(oACUToProtect:GetPosition(), M28Utilities.GetAngleFromAToB(tLZTeamData[M28Map.reftClosestFriendlyBase], oACUToProtect:GetPosition()), iDistInfrontOfACUWanted, true, false, M28Map.bIsCampaignMap)
                            local iAltPlateau, iAltLandZone
                            if tProtectiveMovePoint then iAltPlateau, iAltLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tProtectiveMovePoint) end
                            if not(iAltPlateau == iPlateau) then
                                --GetPositionAtOrNearTargetInPathingGroup(tStartPos,                 tTargetPos,            iDistanceFromTargetToStart, iAngleAdjust, oPathingUnit, bMoveCloserBeforeFurtherIfBlocked, bCheckIfExistingTargetIsBetter, iMinDistanceFromExistingCommandTarget)
                                tProtectiveMovePoint = M28Map.GetPositionAtOrNearTargetInPathingGroup(tProtectiveMovePoint,         oACUToProtect:GetPosition(),        iDistInfrontOfACUWanted,  0,    oACUToProtect,       true,                              false,                           nil)
                                if not(tProtectiveMovePoint) then tProtectiveMovePoint = oACUToProtect:GetPosition() end
                            end
                            local iACUDistToAlliedBase = M28Utilities.GetDistanceBetweenPositions(oACUToProtect:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to try and protect ACU, iACUDistToAlliedBase='..iACUDistToAlliedBase..'; tProtectiveMovePoint='..repru(tProtectiveMovePoint)..'; ACU position='..repru(oACUToProtect:GetPosition())) end
                            bGivenCombatUnitsOrders = true
                            for iUnit, oUnit in tAvailableCombatUnits do
                                --If further from allied base than ACU then move to the move point, otherwise attack-move
                                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) > iACUDistToAlliedBase then
                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                    M28Orders.IssueTrackedMove(oUnit, tProtectiveMovePoint, 3, false, 'RetPrACUM', false)
                                else
                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                    M28Orders.IssueTrackedAttackMove(oUnit, tProtectiveMovePoint, 3, false, 'RetPrACUA', false)
                                end
                            end
                        else
                            M28Utilities.ErrorHandler('Thought we would be protecting an ACU but no ACU to protect')
                        end
                    else

                        if bConsolidateAtMidpoint then
                            if oClosestFriendlyUnitToAnEnemyFirebase then
                                tRallyPoint = M28Utilities.MoveInDirection(oClosestFriendlyUnitToAnEnemyFirebase:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestFriendlyUnitToAnEnemyFirebase:GetPosition(), tLZData[M28Map.subrefMidpoint]), math.min(M28Utilities.GetDistanceBetweenPositions(oClosestFriendlyUnitToAnEnemyFirebase:GetPosition(), tRallyPoint), 15), true, false, true)
                                local iAltPlateau, iAltLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tRallyPoint)
                                if not(iAltPlateau == iPlateau) then
                                    tRallyPoint = M28Map.GetPositionAtOrNearTargetInPathingGroup(oClosestFriendlyUnitToAnEnemyFirebase:GetPosition(), tRallyPoint, 0, 0, oClosestFriendlyUnitToAnEnemyFirebase, false, false, nil)
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Will try and consolidate based on the closest unit to enemy firebase, tRallyPoint adjusted for this='..repru(tRallyPoint)) end
                            else
                                tRallyPoint = {tLZData[M28Map.subrefMidpoint][1], tLZData[M28Map.subrefMidpoint][2], tLZData[M28Map.subrefMidpoint][3]}
                            end
                            sRetreatMessage = 'ConsRP'
                        end
                        if M28Map.bIsCampaignMap and not(M28Conditions.IsLocationInPlayableArea(tRallyPoint)) then
                            --If closest friendly base is in playable area go here
                            if M28Conditions.IsLocationInPlayableArea(tLZTeamData[M28Map.reftClosestFriendlyBase]) then
                                tRallyPoint = {tLZTeamData[M28Map.reftClosestFriendlyBase][1], tLZTeamData[M28Map.reftClosestFriendlyBase][2], tLZTeamData[M28Map.reftClosestFriendlyBase][3]}
                            else
                                local tMoveTowardsBase = M28Utilities.MoveInDirection(tLZData[M28Map.subrefMidpoint], M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase]), 60, true, false, true)
                                if tMoveTowardsBase then
                                    tRallyPoint = tMoveTowardsBase
                                elseif M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then
                                    tRallyPoint = {tLZData[M28Map.subrefMidpoint][1], tLZData[M28Map.subrefMidpoint][2], tLZData[M28Map.subrefMidpoint][3]}
                                elseif oNearestEnemyToFriendlyBase then
                                    --Just go to the closest enemy unit
                                    tRallyPoint = oNearestEnemyToFriendlyBase:GetPosition()
                                end
                            end
                        end
                        local bUnitIsSuicidingIntoMex = false
                        local bConsiderAttackMoveIfClose = false
                        if M28Utilities.GetDistanceBetweenPositions(tRallyPoint, tLZData[M28Map.subrefMidpoint]) <= 20 then bConsiderAttackMoveIfClose = true end

                        if bDebugMessages == true then LOG(sFunctionRef..': We are outranged by enemy and dont have enough threat to press the attack, will either retreat to prev LZ, or this LZ midpoint; bConsolidateAtMidpoint='..tostring(bConsolidateAtMidpoint)..'; bConsiderAttackingExperimental='..tostring(bConsiderAttackingExperimental)..'; tRallyPoint='..repru(tRallyPoint)..'; bSuicideUnitsNearAMex='..tostring(bSuicideUnitsNearAMex)..'; Is table of nearby mexes empty='..tostring(M28Utilities.IsTableEmpty(tNearbyMexes))) end

                        --local bCheckIfNearLocationToAvoid = not(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftiLocationsToAvoid]))
                        bGivenCombatUnitsOrders = true
                        for iUnit, oUnit in tAvailableCombatUnits do
                            --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                            if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end

                            --Only retreat units from this LZ
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; will only retreat with unit if it is from this LZ, iLandZone='..iLandZone..'; Unit assigned zone='..(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] or 'nil')..'; Is special micro active='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive])) end

                            if oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone and ProceedWithUnitOrder(oUnit) then

                                --if bCheckIfNearLocationToAvoid and EntityCategoryContains(categories.TECH1 + categories.TECH2 - categories.COMMAND, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbSpecialMicroActive]) and M28Conditions.HaveSentOrderToRunAwayFromLocationToAvoid(oUnit, tLZTeamData[M28Map.reftiLocationsToAvoid], 4) then
                                --if bDebugMessages == true then LOG(sFunctionRef..': Unit will run away from location to avoid') end

                                --Shot not blocked - consider attackign ACU with experimentals
                                if bConsiderAttackingACU and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategorySkirmisher - M28UnitInfo.refCategoryFatboy - M28UnitInfo.refCategoryAbsolver, oUnit.UnitId) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), toEnemyACUsInZone, 6 + oUnit[M28UnitInfo.refiDFRange], iTeam, false, nil, nil, nil, nil, nil) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Experimental - attack nearest ACU') end
                                    GetUnitToAttackNearestACU(oUnit)
                                    --CloseToEnemyUnit(tStartPosition,       tUnitsToCheck, iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                                elseif bConsiderAttackingExperimental and oUnit[M28UnitInfo.refiDFRange] > 0 and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tNearbyEnemyExperimentals, 14, iTeam, true,                    nil,                    oUnit,                              oUnit) then
                                    --move to nearest enemy experimental if we arent in range of it yet but a friendly unit is, and we are an experimental level unit or it is a fatboy
                                    local bMoveTowardsExperimental = false
                                    --Want to move instead of attackmove if we are an experimental (or up against a fatboy) and aren't already in range (by a reasonable margin if against a fatboy)
                                    local oTargetToManuallyAttack = GetManualAttackTargetIfWantManualAttack(oUnit)
                                    if oTargetToManuallyAttack then
                                        --Consider moving instead of attacking if not well within range
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to attack or move towards enemy manual attack target, dist to target='..M28Utilities.GetDistanceBetweenPositions(oTargetToManuallyAttack:GetPosition(), oUnit:GetPosition())..'; Our DF range='..oUnit[M28UnitInfo.refiDFRange]) end
                                        local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oTargetToManuallyAttack:GetPosition(), oUnit:GetPosition())
                                        if iDistToTarget > oUnit[M28UnitInfo.refiDFRange] - 3 or (iDistToTarget > oUnit[M28UnitInfo.refiDFRange] - 8 and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId)) then
                                            M28Orders.IssueTrackedMove(oUnit, oTargetToManuallyAttack:GetPosition(), 6, false, 'ExpoM'..iLandZone)
                                        else
                                            DoManualAttack(oUnit, oTargetToManuallyAttack, 'ExpMA')
                                            --M28Orders.IssueTrackedAttack(oUnit, oTargetToManuallyAttack, false, 'ExpMA', false)
                                        end
                                    else
                                        local tTargetToMoveTowards

                                        if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oUnit.UnitId) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFatboy, tNearbyEnemyExperimentals)) == false then
                                            local oNearestEnemyExp
                                            local iClosestEnemyExpDist = 100000
                                            local iCurExpDist
                                            for iExperimental, oExperimental in tNearbyEnemyExperimentals do
                                                iCurExpDist = M28Utilities.GetDistanceBetweenPositions(oExperimental:GetPosition(), oUnit:GetPosition())
                                                if iCurExpDist < iClosestEnemyExpDist then
                                                    iClosestEnemyExpDist = iCurExpDist
                                                    oNearestEnemyExp = oExperimental
                                                end
                                            end
                                            if iClosestEnemyExpDist > oUnit[M28UnitInfo.refiDFRange] - 3 then
                                                bMoveTowardsExperimental = true
                                            end
                                            tTargetToMoveTowards = oNearestEnemyExp:GetPosition()
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will advance towards closest experimental='..(oNearestEnemyExp.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyExp) or 'nil')..'; iClosestEnemyExpDist='..iClosestEnemyExpDist..'; tTargetToMoveTowards='..repru(tTargetToMoveTowards)) end
                                        end
                                        if not(tTargetToMoveTowards) then tTargetToMoveTowards = {oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam][1], oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam][2], oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam][3]} end

                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to advance to enemy experimental, bMoveTowardsExperimental='..tostring(bMoveTowardsExperimental)) end
                                        if bMoveTowardsExperimental then
                                            M28Orders.IssueTrackedMove(oUnit, tTargetToMoveTowards, 6, false, 'ExpM'..iLandZone)
                                        else
                                            --Attackmove towards the experimental
                                            M28Orders.IssueTrackedAggressiveMove(oUnit, tTargetToMoveTowards, 6, false, 'ExpA'..iLandZone)
                                        end
                                    end
                                else
                                    if bSuicideUnitsNearAMex and M28Utilities.IsTableEmpty(tNearbyMexes) == false then
                                        bUnitIsSuicidingIntoMex = false
                                        if not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryT3MobileArtillery + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) then
                                            local iClosestMex = math.max(25, (oUnit[M28UnitInfo.refiCombatRange] or 0) + 15)
                                            local oClosestMex
                                            local iCurMexDist
                                            for iMex, oMex in tNearbyMexes do
                                                iCurMexDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oMex:GetPosition())
                                                if bDebugMessages == true then LOG(sFunctionRef..': Dist of oMex='..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)..' to unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'='..iCurMexDist) end
                                                if iCurMexDist < iClosestMex then
                                                    oClosestMex = oMex
                                                    iClosestMex = iCurMexDist
                                                end
                                            end
                                            if oClosestMex then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will suicide unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' into oClosestMex='..oClosestMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestMex)) end
                                                bUnitIsSuicidingIntoMex = true
                                                if iClosestMex <= oUnit[M28UnitInfo.refiCombatRange] + 2 then
                                                    M28Orders.IssueTrackedAttack(oUnit, oClosestMex, false, 'SuicMxAt')
                                                else
                                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                        M28Orders.IssueTrackedAttackMove(oUnit, oClosestMex:GetPosition(), 2, false, 'SuicMxAM')
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    if not(bUnitIsSuicidingIntoMex) then
                                        oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                        if not(bConsolidateAtMidpoint) and EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                            --If moving to the rally point would take us closer to the enemy than moving towards our base then move towards base instead
                                            if bDebugMessages == true then LOG(sFunctionRef..': Amphibious unit and we dont want to consolidate at midpoint, CanKite='..tostring(oUnit[M28UnitInfo.refbCanKite] or false)) end
                                            if not(oUnit[M28UnitInfo.refbCanKite]) and EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then
                                                M28Orders.IssueTrackedAggressiveMove(oUnit, tAmphibiousRallyPoint, 6, false, 'ExKA'..sRetreatMessage..iLandZone)
                                            else
                                                local bMoveTowardsBaseInstead = false
                                                local iAngleToBase
                                                if tMoveTowardsBaseRetreatPoint then --If this is not nil then it means the rally point will take us a different angle to the nearest friendly base, which might cause us to move closer/within range of enemy units
                                                    local iAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition())
                                                    iAngleToBase = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])

                                                    if 180 - M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToBase) <= 45 then
                                                        bMoveTowardsBaseInstead = true
                                                    end
                                                end
                                                if bMoveTowardsBaseInstead then --see below for similar code if making changes here
                                                    if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMoveTowardsBaseRetreatPoint) <= 12 or M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tMoveTowardsBaseRetreatPoint), iAngleToBase) >= 45 then
                                                        if (oUnit[M28UnitInfo.refbWeaponUnpacks] or not(oUnit[M28UnitInfo.refbCanKite])) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 13 then
                                                            M28Orders.IssueTrackedAggressiveMove(oUnit, tLZTeamData[M28Map.reftClosestFriendlyBase], 6, false, 'MTBBA'..sRetreatMessage..iLandZone)
                                                        else
                                                            if bConsiderAttackMoveIfClose and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 20 then
                                                                M28Orders.IssueTrackedAggressiveMove(oUnit, tLZTeamData[M28Map.reftClosestFriendlyBase], 6, false, 'MTBABA'..iLandZone)
                                                            else
                                                                M28Orders.IssueTrackedMove(oUnit, tLZTeamData[M28Map.reftClosestFriendlyBase], 6, false, 'MTBBA'..sRetreatMessage..iLandZone)
                                                            end
                                                        end

                                                    else
                                                        if (oUnit[M28UnitInfo.refbWeaponUnpacks] or not(oUnit[M28UnitInfo.refbCanKite])) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMoveTowardsBaseRetreatPoint) <= 13 then
                                                            M28Orders.IssueTrackedAggressiveMove(oUnit, tMoveTowardsBaseRetreatPoint, 6, false, 'MTBNA'..sRetreatMessage..iLandZone)
                                                        else
                                                            if bConsiderAttackMoveIfClose and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMoveTowardsBaseRetreatPoint) <= 20 then
                                                                M28Orders.IssueTrackedAggressiveMove(oUnit, tMoveTowardsBaseRetreatPoint, 6, false, 'MTBABA'..iLandZone)
                                                            else
                                                                M28Orders.IssueTrackedMove(oUnit, tMoveTowardsBaseRetreatPoint, 6, false, 'MTBNA'..sRetreatMessage..iLandZone)
                                                            end
                                                        end
                                                    end
                                                else
                                                    if (oUnit[M28UnitInfo.refbWeaponUnpacks] or not(oUnit[M28UnitInfo.refbCanKite])) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tAmphibiousRallyPoint) <= 13 then
                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, tAmphibiousRallyPoint, 6, false, 'A'..sRetreatMessage..iLandZone)
                                                    else
                                                        if bConsiderAttackMoveIfClose and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tAmphibiousRallyPoint) <= 20 then
                                                            M28Orders.IssueTrackedAggressiveMove(oUnit, tAmphibiousRallyPoint, 6, false, 'RA'..sRetreatMessage..iLandZone)
                                                        else
                                                            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'A'..sRetreatMessage..iLandZone)
                                                        end
                                                    end
                                                end

                                            end
                                        else
                                            if not(oUnit[M28UnitInfo.refbCanKite]) and EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then
                                                M28Orders.IssueTrackedAggressiveMove(oUnit, tRallyPoint, 6, false, 'ExKG'..sRetreatMessage..iLandZone)
                                            else
                                                local bMoveTowardsBaseInstead = false
                                                local iAngleToBase
                                                if tMoveTowardsBaseRetreatPoint then --If this is not nil then it means the rally point will take us a different angle to the nearest friendly base, which might cause us to move closer/within range of enemy units
                                                    local iAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition())
                                                    iAngleToBase = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                                                    if 180 - M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToBase) <= 45 then
                                                        bMoveTowardsBaseInstead = true
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': iAngleToNearestEnemy='..iAngleToNearestEnemy..'; iAngleToBase='..iAngleToBase..'; Angle dif between angle to nearest enemy and angle to base='..M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToBase)..'; bMoveTowardsBaseInstead='..tostring(bMoveTowardsBaseInstead)) end
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': bMoveTowardsBaseInstead='..tostring(bMoveTowardsBaseInstead)) end
                                                if bMoveTowardsBaseInstead then --see above for similar code if making changes here
                                                    if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMoveTowardsBaseRetreatPoint) <= 12 or M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tMoveTowardsBaseRetreatPoint), iAngleToBase) >= 45 then
                                                        if (oUnit[M28UnitInfo.refbWeaponUnpacks] or not(oUnit[M28UnitInfo.refbCanKite])) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 13 then
                                                            M28Orders.IssueTrackedAggressiveMove(oUnit, tLZTeamData[M28Map.reftClosestFriendlyBase], 6, false, 'MTBB'..sRetreatMessage..iLandZone)
                                                        else
                                                            M28Orders.IssueTrackedMove(oUnit, tLZTeamData[M28Map.reftClosestFriendlyBase], 6, false, 'MTBB'..sRetreatMessage..iLandZone)
                                                        end
                                                    else
                                                        if (oUnit[M28UnitInfo.refbWeaponUnpacks] or not(oUnit[M28UnitInfo.refbCanKite])) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMoveTowardsBaseRetreatPoint) <= 13 then
                                                            M28Orders.IssueTrackedAggressiveMove(oUnit, tMoveTowardsBaseRetreatPoint, 6, false, 'MTBN'..sRetreatMessage..iLandZone)
                                                        else
                                                            M28Orders.IssueTrackedMove(oUnit, tMoveTowardsBaseRetreatPoint, 6, false, 'MTBN'..sRetreatMessage..iLandZone)
                                                        end
                                                    end
                                                else
                                                    if bDebugMessages == true then
                                                        LOG(sFunctionRef..': Will retreat towards rally point, tRallyPoint='..repru(tRallyPoint)..'; Unit position='..repru(oUnit:GetPosition())..'; Unit special micro='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive] or false)..'; last order position='..repru(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]))
                                                        M28Utilities.DrawLocation(tRallyPoint)
                                                    end
                                                    if (oUnit[M28UnitInfo.refbWeaponUnpacks] or not(oUnit[M28UnitInfo.refbCanKite])) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint) <= 13 then
                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, tRallyPoint, 6, false, sRetreatMessage..iLandZone)
                                                    else
                                                        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, sRetreatMessage..iLandZone)
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            else
                                --Unit is from a different zone - need to change the value of its assignment so it is considered for orders by the zone that it is part of
                                oUnit[refiCurrentAssignmentValue] = 0
                            end
                        end
                    end
                end

                if bUpdateNearestUnit then
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                        if aiBrain then
                            M28Team.UpdateUnitLastKnownPosition(aiBrain, oNearestEnemyToFriendlyBase, true)
                        end
                    else
                        M28Utilities.ErrorHandler('No active M28 brain')
                    end
                end
            end
            --MML synchronisation logic
            if (bConsiderSpecialMMLLogic or bEnemyHasFixedShieldsInThisOrAdjacentZone) and M28Utilities.IsTableEmpty(tMMLForSynchronisation) == false then
                --Get table of enemy shields and TMD to consider targeting
                local tPriorityMMLTargets = {}
                local bConsiderMultipleTargets = false
                function IncludeTMDAndShieldsInZone(iAdjLZ, iOverridePlateau, iSearchCategory)
                    local tAdjLZTeamData
                    if iAdjLZ == iLandZone and not(iOverridePlateau) then tAdjLZTeamData = tLZTeamData else tAdjLZTeamData = M28Map.tAllPlateaus[(iOverridePlateau or iPlateau)][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam] end
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                        local tZoneTMDAndShields = EntityCategoryFilterDown(iSearchCategory, tAdjLZTeamData[M28Map.subrefTEnemyUnits])
                        if M28Utilities.IsTableEmpty(tZoneTMDAndShields) == false then
                            for iTMDOrShield, oTMDOrShield in tZoneTMDAndShields do
                                if oTMDOrShield:GetFractionComplete() >= 0.3 and M28UnitInfo.IsUnitValid(oTMDOrShield) and not(oTMDOrShield:IsUnitState('Attached')) and (oTMDOrShield:GetFractionComplete() >= 0.5 or (oTMDOrShield[M28UnitInfo.refiUnitMassCost] or 0) >= 300) then
                                    table.insert(tPriorityMMLTargets, oTMDOrShield)
                                end
                            end
                        end
                    end
                end

                local iPrioritySearchCategory = M28UnitInfo.refCategoryTMD + M28UnitInfo.refCategoryFixedShield
                local iMMLMassValue = M28UnitInfo.GetMassCostOfUnits(tMMLForSynchronisation)
                if iMMLMassValue >= 2000 then --have 10+ T2 MML equivalent so include t2 arti when searching
                    bConsiderMultipleTargets = true
                    iPrioritySearchCategory = iPrioritySearchCategory + M28UnitInfo.refCategoryFixedT2Arti
                    if iMMLMassValue >= 4000 then --Include T2 and T3 PD as well
                        iPrioritySearchCategory = iPrioritySearchCategory + M28UnitInfo.refCategoryT2PlusPD
                    end
                end
                IncludeTMDAndShieldsInZone(iLandZone, nil, iPrioritySearchCategory)
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        IncludeTMDAndShieldsInZone(iAdjLZ, nil, iPrioritySearchCategory)
                    end
                end
                if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
                    for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                        IncludeTMDAndShieldsInZone(tPlateauAndZone[2], tPlateauAndZone[1], iPrioritySearchCategory)
                    end
                end
                --Add upgrading enemy ACUs that are near this zone midpoint (will also have a check later on based on ACUs in this specific zone; benefit of below though is it covers adjacent zones)
                if M28Utilities.IsTableEmpty(tPriorityMMLTargets) or table.getn(tPriorityMMLTargets) <= iMMLMassValue / 1200 then
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) == false then
                        for iACU, oACU in M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs] do
                            if M28UnitInfo.IsUnitValid(oACU) and oACU:IsUnitState('Upgrading') and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= 120 then
                                table.insert(tPriorityMMLTargets, oACU)
                            end
                        end
                    end
                end


                --Consider orders for each MML
                local oClosestPotentialTarget
                local iClosestPotentialTarget
                local iCurTargetDist
                local tMMLWithNearbyTargets = {}
                local toAlreadyCoveredTargets = {}
                local tiAssignedInRangeThreatByEntity = {}
                local iDistThresholdForInRange = 5


                if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through each MML for synchronisation and get a target for it, is tPriorityMMLTargets empty='..tostring(M28Utilities.IsTableEmpty(tPriorityMMLTargets))) end
                local iDistThresholdFurtherAdjust
                local tPriorityEnemyScoutTargets = {}
                for iUnit, oUnit in tMMLForSynchronisation do
                    iDistThresholdFurtherAdjust = 0
                    if oUnit[M28UnitInfo.refiIndirectRange] - iEnemyBestDFRange >= 40 and oUnit[M28UnitInfo.refiIndirectRange] >= 55 then iDistThresholdFurtherAdjust = math.max(8, 20 - iIndirectRunFigureSynchronisation) end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is MML '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at position '..repru(oUnit:GetPosition())..' close to enemy DF units='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], iIndirectRunFigureSynchronisation + iDistThresholdFurtherAdjust, iTeam, true, math.min(30, oUnit[M28UnitInfo.refiIndirectRange] - iIndirectRunFigureSynchronisation * 2, math.max(25, iEnemyBestDFRange + 5)), nil,                        oUnit))..'; iDistThresholdFurtherAdjust='..iDistThresholdFurtherAdjust) end
                    --CloseToEnemyUnit(tStartPosition,      tUnitsToCheck,                                                   iDistThreshold,                 iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange,                                                                                        oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                    if not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], iIndirectRunFigureSynchronisation + iDistThresholdFurtherAdjust, iTeam, true, math.min(30, oUnit[M28UnitInfo.refiIndirectRange] - iIndirectRunFigureSynchronisation * 2, math.max(25, iEnemyBestDFRange + 5)), nil,                        oUnit)) then
                        if M28Utilities.IsTableEmpty(tPriorityMMLTargets) then --redundancy - hopefully only scenario we get here is if there is 1 part-complete TMD/shield that is <30% complete
                            M28Orders.IssueTrackedAggressiveMove(oUnit, (oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or oNearestEnemyToFriendlyBase:GetPosition()), math.max(15, (iIndirectDistanceInsideRangeThreshold or 15)), false, 'I2KAMve'..iLandZone)
                        else
                            --Get the closest TMD/shield to this MML, and then decide whether to attack it or not (for performance reasons stop as soon as we have a target within TML range
                            iClosestPotentialTarget = 100000
                            for iTarget, oTarget in tPriorityMMLTargets do
                                iCurTargetDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTarget:GetPosition())
                                if iCurTargetDist < iClosestPotentialTarget then
                                    iClosestPotentialTarget = iCurTargetDist
                                    oClosestPotentialTarget = oTarget
                                    if iClosestPotentialTarget < oUnit[M28UnitInfo.refiIndirectRange] then break end
                                end
                            end
                            if not(oClosestPotentialTarget) and M28Utilities.IsTableEmpty(toAlreadyCoveredTargets) == false then
                                for iTarget, oTarget in toAlreadyCoveredTargets do
                                    iCurTargetDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTarget:GetPosition())
                                    if iCurTargetDist < iClosestPotentialTarget then
                                        iClosestPotentialTarget = iCurTargetDist
                                        oClosestPotentialTarget = oTarget
                                        if iClosestPotentialTarget < oUnit[M28UnitInfo.refiIndirectRange] then break end
                                    end
                                end
                            end
                            if not(oClosestPotentialTarget) then
                                M28Utilities.ErrorHandler('Somehow dont have a target for MML')
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(15, iIndirectDistanceInsideRangeThreshold), false, 'I2KAMve'..iLandZone)
                            else
                                if iClosestPotentialTarget - iDistThresholdForInRange > oUnit[M28UnitInfo.refiIndirectRange] then
                                    --Still a bit of distance until we are in range; attack move if we are far away, but do a normal move if we are almost in range
                                    --First check if another target (e.g. upgrading ACU) we should focus fire on first though, if it's significnatly closer than the nearest shield or TMD
                                    local oInRangeUpgradingACU
                                    if M28Utilities.IsTableEmpty(toEnemyACUsInZone) == false and iClosestPotentialTarget - 10 > oUnit[M28UnitInfo.refiIndirectRange] then
                                        for iACU, oACU in toEnemyACUsInZone do
                                            if oACU:IsUnitState('Upgrading') and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition()) <= oUnit[M28UnitInfo.refiIndirectRange] then
                                                oInRangeUpgradingACU = oACU
                                                break
                                            end
                                        end
                                    end
                                    if oInRangeUpgradingACU then
                                        M28Orders.IssueTrackedGroundAttack(oUnit, oInRangeUpgradingACU:GetPosition(), (oUnit[M28UnitInfo.refiIndirectAOE] or 0), false, 'MMLSchACU', false)
                                        table.insert(tMMLWithNearbyTargets, oUnit)
                                    elseif iClosestPotentialTarget - 35 > oUnit[M28UnitInfo.refiIndirectRange] then
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oClosestPotentialTarget:GetPosition(), (oUnit[M28UnitInfo.refiIndirectAOE] or 0), false, 'MMLSchAM'..iLandZone)
                                    else
                                        M28Orders.IssueTrackedMove(oUnit, oClosestPotentialTarget:GetPosition(), (oUnit[M28UnitInfo.refiIndirectAOE] or 0), false, 'MMLSchM'..iLandZone)
                                    end
                                else
                                    if oClosestPotentialTarget[M28UnitInfo.refbHaveSeenUnitByTeam][iTeam] or not(EntityCategoryContains(M28UnitInfo.refCategoryTMD + M28UnitInfo.refCategoryStealthGenerator, oClosestPotentialTarget.UnitId)) then
                                        --Can attack the unit itself as either in range or almost in range
                                        M28Orders.IssueTrackedGroundAttack(oUnit, oClosestPotentialTarget:GetPosition(), (oUnit[M28UnitInfo.refiIndirectAOE] or 0), false, 'MMLSchGA', false)
                                    else
                                        --Enemy TMD that we dont have intel of
                                        tPriorityEnemyScoutTargets[oClosestPotentialTarget.EntityId] = oClosestPotentialTarget
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oClosestPotentialTarget:GetPosition(), (oUnit[M28UnitInfo.refiIndirectAOE] or 10) - 5, 'MMLNoVis')
                                    end
                                    table.insert(tMMLWithNearbyTargets, oUnit)
                                    if bConsiderMultipleTargets then
                                        tiAssignedInRangeThreatByEntity[oClosestPotentialTarget.EntityId] = (tiAssignedInRangeThreatByEntity[oClosestPotentialTarget.EntityId] or 0) + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
                                        if tiAssignedInRangeThreatByEntity[oClosestPotentialTarget.EntityId] >= math.max(1000, M28UnitInfo.GetUnitMaxHealthIncludingShield(oUnit) * oUnit:GetFractionComplete() * 0.4) then
                                            --Remove unit from the priority target table and add to the 'other' table
                                            for iEntry, oEntry in  tPriorityMMLTargets do
                                                if oEntry == oClosestPotentialTarget then
                                                    table.insert(toAlreadyCoveredTargets, oEntry)
                                                    table.remove(tPriorityMMLTargets, iEntry)
                                                    break
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    else
                        local bTemporaryKiting = false
                        if oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()) <= math.max(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiCombatRange] + 8, oUnit[M28UnitInfo.refiCombatRange] - 10) then
                            local tTemporaryRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), 8, true, false, M28Map.bIsCampaignMap)
                            if tTemporaryRetreatLocation and NavUtils.GetLabel(M28Map.refPathingTypeLand, tTemporaryRetreatLocation) == tLZData[M28Map.subrefLZIslandRef] then
                                bTemporaryKiting = true
                                M28Orders.IssueTrackedMove(oUnit, tTemporaryRetreatLocation, 6, false, 'MMLOpERetr'..iLandZone)
                            end
                        end

                        if bDebugMessages == true then LOG(sFunctionRef..': Will retreat MML') end
                        --Retreat temporarily from enemy units
                        if not(bTemporaryKiting) then
                            if EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'MMLASKRetr'..iLandZone)
                            else
                                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'MMLSKRetr'..iLandZone)
                            end
                        end
                    end
                end

                if M28Utilities.IsTableEmpty(tPriorityEnemyScoutTargets) == false then
                    local iAirSubteam = ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].M28AirSubteam
                    for iEnemy, oEnemy in tPriorityEnemyScoutTargets do
                        M28Air.AddUnitWantingPriorityScout(oEnemy, false, iAirSubteam)
                    end
                end

                --Do we have any MML that have targets in-range or almost in range? If so then consider synchronising their weapons (dont do this though if we only want to prioritise TMD and shields and dont want to synchronise)
                if bDebugMessages == true then LOG(sFunctionRef..': Is tMMLWithNearbyTargets empty='..tostring(M28Utilities.IsTableEmpty(tMMLWithNearbyTargets))) end
                if bConsiderSpecialMMLLogic and M28Utilities.IsTableEmpty(tMMLWithNearbyTargets) == false then
                    local iMMLWithTargets = table.getn(tMMLWithNearbyTargets)
                    if bDebugMessages == true then LOG(sFunctionRef..': iMMLWithTargets='..iMMLWithTargets) end
                    if iMMLWithTargets >= 4 then
                        local iMMLJustFiredOrReadyToFire = 0
                        local iMMLNotFiredForAges = 0
                        local iMMLReloading = 0

                        local iTimeUntilReadyToFire
                        local iTotalTimeUntilReadyToFire = 0
                        local iMinTimeUntilReady = 100000
                        local iMaxTimeUntilReady = -100000
                        local tiTimeUntilReadyToFire = {}
                        for iUnit, oUnit in tMMLWithNearbyTargets do
                            iTimeUntilReadyToFire = oUnit[M28UnitInfo.refiTimeBetweenIFShots] - (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or -100))
                            if iTimeUntilReadyToFire <= math.min(-7, -oUnit[M28UnitInfo.refiTimeBetweenIFShots] - 1.5) then
                                iMMLNotFiredForAges = iMMLNotFiredForAges + 1
                            elseif iTimeUntilReadyToFire >= 1.01 then
                                iMMLReloading = iMMLReloading + 1
                            else
                                iMMLJustFiredOrReadyToFire = iMMLJustFiredOrReadyToFire + 1
                            end
                            if iTimeUntilReadyToFire < iMinTimeUntilReady then iMinTimeUntilReady = iTimeUntilReadyToFire end
                            if iTimeUntilReadyToFire > iMaxTimeUntilReady then iMaxTimeUntilReady = iTimeUntilReadyToFire end
                            iTotalTimeUntilReadyToFire = iTotalTimeUntilReadyToFire + iTimeUntilReadyToFire
                            table.insert(tiTimeUntilReadyToFire, iTimeUntilReadyToFire)
                            if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTimeUntilReadyToFire='..iTimeUntilReadyToFire..'; oUnit[M28UnitInfo.refiTimeBetweenIFShots]='..oUnit[M28UnitInfo.refiTimeBetweenIFShots]..'; oUnit[M28UnitInfo.refiLastWeaponEvent]='..(oUnit[M28UnitInfo.refiLastWeaponEvent] or 'nil')..'; Cur time='..GetGameTimeSeconds()) end
                        end
                        local iAverageTimeUntilReadyToFire = iTotalTimeUntilReadyToFire / iMMLWithTargets
                        local iMMLWithin1OfAverage = 0
                        for iEntry, iTime in tiTimeUntilReadyToFire do
                            if math.abs(iTime - iAverageTimeUntilReadyToFire) < 1 then
                                iMMLWithin1OfAverage = iMMLWithin1OfAverage + 1
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iMMLJustFiredOrReadyToFire='..iMMLJustFiredOrReadyToFire..'; iMMLNotFiredForAges='..iMMLNotFiredForAges..'; iMMLWithTargets='..iMMLWithTargets..'; iMMLReloading='..iMMLReloading..'; iMMLWithin1OfAverage='..iMMLWithin1OfAverage..'; iAverageTimeUntilReadyToFire='..iAverageTimeUntilReadyToFire..'; iMaxTimeUntilReady='..iMaxTimeUntilReady..'; iMinTimeUntilReady='..iMinTimeUntilReady) end
                        if iMMLJustFiredOrReadyToFire + iMMLNotFiredForAges >= iMMLWithTargets * 0.75 or iMMLNotFiredForAges >= iMMLWithTargets * 0.25 or iMMLWithin1OfAverage >= iMMLWithTargets * 0.8 or (iMaxTimeUntilReady - iMinTimeUntilReady) <= 1.4 then
                            --Dont want to synchronise as either already synchronised or have lots of MML that havent fired in a while
                            if bDebugMessages == true then LOG(sFunctionRef..': Will enable all MML weapons') end
                            for iUnit, oUnit in tMMLWithNearbyTargets do
                                M28UnitInfo.EnableUnitWeapon(oUnit) --In addition to separate logic that will enable, as want to enable asap once we decide we want to fire)
                            end
                        else
                            --Want to synchronise shots, disable the weapons (they shoudl be reenabled each cycle)
                            if bDebugMessages == true then LOG(sFunctionRef..': Will disable all MML weapons until they are better synchronised, time='..GetGameTimeSeconds()) end
                            for iUnit, oUnit in tMMLWithNearbyTargets do
                                M28UnitInfo.DisableUnitWeapon(oUnit)
                            end
                        end
                    end
                end
            end
        else
            --We dont have a nearest enemy to midpoint - if this is because we are ignoring low threat enemies, then send a small number of our available combat units to deal with them
            if not(bGivenCombatUnitsOrders) and bIgnoreEnemiesInThisZone and not(bConsiderEnemiesInAtLeastOneAdjacentZone) then
                local oEnemyToFocusOn
                local iClosestEnemyToFocusOn = 100000
                local iCurEnemyToFocusOnDist

                local iMaxThreatToAssign =(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 6 + (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 3
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    for iEnemy, oEnemy in tLZTeamData[M28Map.subrefTEnemyUnits] do
                        iCurEnemyToFocusOnDist = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), tLZData[M28Map.subrefMidpoint])
                        if iCurEnemyToFocusOnDist < iClosestEnemyToFocusOn then
                            iClosestEnemyToFocusOn = iCurEnemyToFocusOnDist
                            oEnemyToFocusOn = oEnemy
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                        iMaxThreatToAssign = iMaxThreatToAssign + (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 6 + (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 3
                        if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                            for iEnemy, oEnemy in tAdjLZTeamData[M28Map.subrefTEnemyUnits] do
                                if M28UnitInfo.IsUnitValid(oEnemy) then
                                    iCurEnemyToFocusOnDist = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                    if iCurEnemyToFocusOnDist < iClosestEnemyToFocusOn then
                                        iClosestEnemyToFocusOn = iCurEnemyToFocusOnDist
                                        oEnemyToFocusOn = oEnemy
                                    end
                                end
                            end
                        end
                    end
                end
                if iMaxThreatToAssign > 0 then iMaxThreatToAssign = math.max(iMaxThreatToAssign, 60) end
                --T2+ indirect fire units - focus on nearby enemy T2 arti if there is any
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
                    for iCurUnit = table.getn(tAvailableCombatUnits), 1, -1 do
                        local oCurUnit = tAvailableCombatUnits[iCurUnit]
                        if (oCurUnit[M28UnitInfo.refiIndirectRange] or 0) >= 45 then
                            local oNearestT2Arti, iCurArtiDist
                            local iNearestT2Arti = 160 --Ignore T2 arti further away than this
                            for iT2Arti, oT2Arti in tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits] do
                                iCurArtiDist = M28Utilities.GetDistanceBetweenPositions(oT2Arti:GetPosition(), oCurUnit:GetPosition())
                                if iCurArtiDist <= iNearestT2Arti then
                                    iNearestT2Arti = iCurArtiDist
                                    oNearestT2Arti = oT2Arti
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Negligible enemy threat in this and adjacent zones but enemy has nearby t2 arti, oNearestT2Arti='..(oNearestT2Arti.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestT2Arti) or 'nil')..'; iNearestT2Arti='..iNearestT2Arti..'; IF unit='..oCurUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(iNearestT2Arti)..'; IF range='..(oCurUnit[M28UnitInfo.refiIndirectRange] or 0)) end
                            if oNearestT2Arti then
                                if iNearestT2Arti <= (oCurUnit[M28UnitInfo.refiIndirectRange] or 0) + 5 then
                                    M28Orders.IssueTrackedGroundAttack(oCurUnit, oNearestT2Arti:GetPosition(), 0.5, false, 'NegT2ArtAG', false, oNearestT2Arti)
                                else
                                    M28Orders.IssueTrackedAggressiveMove(oCurUnit, oNearestT2Arti:GetPosition(), 0.5, false, 'NegT2ArtAM', false)
                                end
                                table.remove(tAvailableCombatUnits, iCurUnit)
                            end
                        end
                    end
                end

                if oEnemyToFocusOn then
                    local iCurAssignedThreat = 0
                    for iCurUnit = table.getn(tAvailableCombatUnits), 1, -1 do
                        if tAvailableCombatUnits[iCurUnit][M28UnitInfo.refiUnitMassCost] <= iMaxThreatToAssign or ((tAvailableCombatUnits[iCurUnit][M28UnitInfo.refiDFRange] or 0) > 0 and (EntityCategoryContains(M28UnitInfo.refCategoryLandCombat - categories.EXPERIMENTAL, tAvailableCombatUnits[iCurUnit].UnitId) and M28UnitInfo.GetUnitLifetimeCount(tAvailableCombatUnits[iCurUnit]) > 3)) then
                            iCurAssignedThreat = iCurAssignedThreat + tAvailableCombatUnits[iCurUnit][M28UnitInfo.refiUnitMassCost]
                            M28Orders.IssueTrackedMove(tAvailableCombatUnits[iCurUnit], oEnemyToFocusOn:GetPosition(), 5, false, 'NegMZAC'..iLandZone, false)
                            if bDebugMessages == true then LOG(sFunctionRef..': Assigned available combat unit '..tAvailableCombatUnits[iCurUnit].UnitId..M28UnitInfo.GetUnitLifetimeCount(tAvailableCombatUnits[iCurUnit])..' to deal with threats in this and adjacent zones, iCurAssignedThreat='..iCurAssignedThreat..'; iMaxThreatToAssign='..iMaxThreatToAssign..'; oEnemyToFocusOn='..oEnemyToFocusOn.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToFocusOn)) end
                            table.remove(tAvailableCombatUnits, iCurUnit)
                            if iCurAssignedThreat >= iMaxThreatToAssign then break end
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to run from firebase or long range enemy threat, bRunFromFirebase='..tostring(bRunFromFirebase)..'; Nearby enemy long range threat='..(tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0)..'; Zone combat total='..(tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)..'; iAvailableCombatUnitThreat='..iAvailableCombatUnitThreat..'; bGivenCombatUnitsOrders='..tostring(bGivenCombatUnitsOrders)) end
    if not(bGivenCombatUnitsOrders) and M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
        if (not(bSuicideIntoFatboyOrACU) or not(oClosestFatboyOrACUInIslandToSuicideInto)) and (bRunFromFirebase or bRunFromEnemyAir or ((tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] > math.max(100, tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]) and tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] > iAvailableCombatUnitThreat * 2 and not(bIgnoreEnemiesInThisZone and not(bConsiderEnemiesInAtLeastOneAdjacentZone))))) then
            local bConsiderAttackMoveIfClose = false
            if M28Utilities.GetDistanceBetweenPositions(tRallyPoint, tLZData[M28Map.subrefMidpoint]) <= 30 then bConsiderAttackMoveIfClose = true end
            for iUnit, oUnit in tAvailableCombatUnits do --Only retreat units from this LZ
                if oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone then
                    --If we have recently been given a short range target, or are almost in range of the target, then we may have moved into this zone temporarily, in which case continue with attacking the target
                    if bDebugMessages == true then LOG(sFunctionRef..': is oUnit[refoSREnemyTarget] valid='..tostring(M28UnitInfo.IsUnitValid(oUnit[refoSREnemyTarget]))..'; refiTimeOfSREnemyTarget='..(oUnit[refiTimeOfSREnemyTarget] or 'nil')..'; unit df range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; time='..GetGameTimeSeconds()) end
                    if M28UnitInfo.IsUnitValid(oUnit[refoSREnemyTarget]) and oUnit[refiTimeOfSREnemyTarget] and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) and (GetGameTimeSeconds() - oUnit[refiTimeOfSREnemyTarget] <= 20 or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[refoSREnemyTarget]:GetPosition()) <= (oUnit[M28UnitInfo.refiDFRange] or 0) + 10) then
                        if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnit.UnitId) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[refoSREnemyTarget]:GetPosition()) <= (oUnit[M28UnitInfo.refiDFRange] or 0) - 10 then
                            M28Orders.IssueTrackedAggressiveMove(oUnit, oUnit[refoSREnemyTarget]:GetPosition(), 6, false, 'SRHistAT'..iLandZone)
                        else
                            M28Orders.IssueTrackedMove(oUnit, oUnit[refoSREnemyTarget]:GetPosition(), 6, false, 'SRHistMT'..iLandZone)
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                        if bConsiderAttackMoveIfClose and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tAmphibiousRallyPoint) <= 30 then
                            M28Orders.IssueTrackedAggressiveMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AFBARetr'..iLandZone)
                        else
                            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'AFBMRetr'..iLandZone)
                        end
                    else
                        if bConsiderAttackMoveIfClose and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint) <= 30 then
                            M28Orders.IssueTrackedAggressiveMove(oUnit, tRallyPoint, 6, false, 'FBARetr'..iLandZone)
                        else
                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'FBRetr'..iLandZone)
                        end
                    end
                else
                    --Clear unit assignment value so it is used by other zones
                    oUnit[refiCurrentAssignmentValue] = 0
                end
            end
        else --if not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) then --Done via separate if condition instead of else as we might set this to false if we couldnt find a nearest enemy in the above logic
            --Split units available to reinforce into DF and indirect fire units
            local tDFUnits = {}
            local tIndirectUnits = {}
            for iUnit, oUnit in tAvailableCombatUnits do
                if oUnit[M28UnitInfo.refiDFRange] > 0 then
                    table.insert(tDFUnits, oUnit)
                elseif oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                    table.insert(tIndirectUnits, oUnit)
                else
                    M28Utilities.ErrorHandler('Combat unit with no DF or indirect range')
                end
            end

            --DF units - suicide into fatboy if was one
            if M28Utilities.IsTableEmpty(tDFUnits) == false and bSuicideIntoFatboyOrACU and oClosestFatboyOrACUInIslandToSuicideInto then
                for iUnit, oUnit in tDFUnits do
                    M28Orders.IssueTrackedMove(oUnit, oClosestFatboyOrACUInIslandToSuicideInto:GetPosition(), 6, false, 'LRFBSuic'..iLandZone)
                end
                tDFUnits = {}
            end

            --Indirect special 'bombardment' type logic against nearby different plateaus
            if M28Utilities.IsTableEmpty(tIndirectUnits) == false then
                if M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]) then
                    local tOrderPosition = tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]:GetPosition()
                    for iUnit, oUnit in tIndirectUnits do
                        --Note - issue on maps like air wars - the range factors in height so if the target plateau is very far away it can lead to strange results
                        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOrderPosition) > oUnit[M28UnitInfo.refiIndirectRange] - 1 then
                            M28Orders.IssueTrackedAggressiveMove(oUnit, tOrderPosition, 3, false, 'InPlBom', false)
                        else
                            M28Orders.IssueTrackedGroundAttack(oUnit, tOrderPosition, 3, false, 'InPlAGBm', false, tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere])
                        end
                    end
                    tIndirectUnits = {}
                elseif tLZTeamData[M28Map.refbEnemiesInNearbyPlateau] and iFriendlyBestMobileIndirectRange > 0 then
                    --Check for mobile units within range
                    local oNearestEnemyMobileUnit = GetNearestEnemyInOtherPlateau(iPlateau, tLZData, iTeam)
                    if oNearestEnemyMobileUnit then
                        --Is this unit likely to be reachable by our best indirect fire range unit?
                        local tOrderPosition = oNearestEnemyMobileUnit:GetPosition()
                        local tPotentialFireFromPosition = M28Utilities.MoveInDirection(tOrderPosition, M28Utilities.GetAngleFromAToB(tOrderPosition, tLZData[M28Map.subrefMidpoint]), math.min(iFriendlyBestMobileIndirectRange, M28Utilities.GetDistanceBetweenPositions(tOrderPosition, tLZData[M28Map.subrefMidpoint])), true, false, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have enemy unit in nearby plateau, oNearestEnemyMobileUnit='..oNearestEnemyMobileUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyMobileUnit)..'; iOurBestIndirectRange='..iFriendlyBestMobileIndirectRange..'; tPotentialFireFromPosition='..repru(tPotentialFireFromPosition)..'; Island ref='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tPotentialFireFromPosition) or 'nil')..'; This LZ island ref='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')) end
                        if M28Utilities.IsTableEmpty(tPotentialFireFromPosition) == false and NavUtils.GetLabel(M28Map.refPathingTypeLand, tPotentialFireFromPosition) == (tLZData[M28Map.subrefLZIslandRef] or NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint])) then

                            for iUnit, oUnit in tIndirectUnits do
                                --Note - issue on maps like air wars - the range factors in height so if the target plateau is very far away it can lead to strange results
                                M28Orders.IssueTrackedAggressiveMove(oUnit, tOrderPosition, 3, false, 'InPlMBom', false)
                            end
                            tIndirectUnits = {}
                        end
                    end
                end
            end


            --Do we have adjacent zones wanting reinforcements?
            local iIndirectLZToSupport
            local iDFLZToSupport
            --if M28Utilities.IsTableEmpty(tDFUnits) then iDFLZToSupport = -1 end --set to -1 so not nil so we can ignore checking the threat for indirect/direct respectively
            --(dont set the DFLZ to -1 yet, as we want to support a zone wanting DF units iwth indirect if we have spare indirect
            if M28Utilities.IsTableEmpty(tIndirectUnits) then iIndirectLZToSupport = -1 end

            local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
            if bDebugMessages == true then LOG(sFunctionRef..': Dont have any enemy units in this LZ or adjacent LZ, so will consider supporting other land zones, is tDFUnits empty='..tostring(M28Utilities.IsTableEmpty(tDFUnits))..'; Is adjacent LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]))..'; subrefiNearbyEnemyLongRangeThreat='..tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat]) end
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                --If have T2 arti nearby then adjust iIndirectLZToSupport for the closest zone which has units flagging they had shots intercepted, if closer to the firebase than this zone
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false or oNearestFirebaseUnit then
                    if not(oNearestFirebaseUnit) then
                        local iClosestUnit = 10000
                        local iCurDist
                        for iUnit, oUnit in tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits] do
                            if M28UnitInfo.IsUnitValid(oUnit) then
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                if iCurDist < iClosestUnit then
                                    iClosestUnit = iCurDist
                                    oNearestFirebaseUnit = oUnit
                                end
                            end
                        end
                        if oNearestFirebaseUnit then
                            if iClosestUnit >= 10000 then iClosestUnit = M28Utilities.GetDistanceBetweenPositions(oNearestFirebaseUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) end
                            local iClosestZoneWithNoMMLIntercepts
                            local iClosestZoneWithMMLIntercepts
                            local iDistOfClosestNoMMLIntercept = iClosestUnit - 10 --no point moving to an adjacent zone unless it is noticeably closer to the firebase than this zone
                            local iDistOfClosestWithMMLIntercept = iClosestUnit - 10 --no point moving to an adjacent zone unless it is noticeably closer to the firebase than this zone
                            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oNearestFirebaseUnit:GetPosition(), tAdjLZData[M28Map.subrefMidpoint])
                                if iCurDist <= iDistOfClosestNoMMLIntercept or iCurDist <= iDistOfClosestWithMMLIntercept then
                                    local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                                    if GetGameTimeSeconds() - (tAdjLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -100) <= 30 then
                                        iDistOfClosestWithMMLIntercept = iCurDist
                                        iClosestZoneWithMMLIntercepts = iAdjLZ
                                    elseif iCurDist <= iDistOfClosestNoMMLIntercept and tLZTeamData[M28Map.subrefbLZWantsIndirectSupport] then
                                        iDistOfClosestNoMMLIntercept = iCurDist
                                        iClosestZoneWithNoMMLIntercepts = iAdjLZ
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': IF support will prioritise zones nearer to the enemy firebase or t2 arti, iClosestUnit='..iClosestUnit..'; iClosestZoneWithMMLIntercepts='..(iClosestZoneWithMMLIntercepts or 'nil')..'; iClosestZoneWithNoMMLIntercepts='..(iClosestZoneWithNoMMLIntercepts or 'nil')..'; iDistOfClosestWithMMLIntercept='..iDistOfClosestWithMMLIntercept..'; iDistOfClosestNoMMLIntercept='..iDistOfClosestNoMMLIntercept) end
                            if iClosestZoneWithMMLIntercepts then iIndirectLZToSupport = iClosestZoneWithMMLIntercepts
                            elseif iClosestZoneWithNoMMLIntercepts then iIndirectLZToSupport = iClosestZoneWithNoMMLIntercepts  end
                        end
                    end
                end

                local iEnemyStructureThresholdForNegligibleEnemies
                if bIgnoreEnemiesInThisZone and not(bConsiderEnemiesInAtLeastOneAdjacentZone) then
                    iEnemyStructureThresholdForNegligibleEnemies = math.min(1500, M28UnitInfo.GetMassCostOfUnits(tIndirectUnits) * 0.1)
                end
                for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent LZ iAdjLZ='..iAdjLZ..'; Does it want DF support='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport])..'; Does it want indirect support='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsIndirectSupport])) end
                    if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMidpoint])) then
                        if not(iIndirectLZToSupport) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsIndirectSupport] then
                            if tbAdjacentZoneEnemiesToIgnoreByZone[iAdjLZ] and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefThreatEnemyStructureTotalMass] < iEnemyStructureThresholdForNegligibleEnemies then
                                --Do nothing - dont want to support as we shouldve already sent units to deal with any enemies as part of above logic
                            else
                                iIndirectLZToSupport = iAdjLZ
                                if iDFLZToSupport or M28Utilities.IsTableEmpty(tDFUnits) then break end
                            end
                        end
                        if not(iDFLZToSupport) and (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport]) then
                            if tbAdjacentZoneEnemiesToIgnoreByZone[iAdjLZ] then
                                --Do nothing - dont want to support as we shouldve already sent units to deal with any enemies as part of above logic
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': iAdjLZ '..iAdjLZ..' wants DF support so will support here') end
                                iDFLZToSupport = iAdjLZ
                                if  iIndirectLZToSupport then break end
                            end
                        end
                    end
                end
            end

            if iIndirectLZToSupport and not(iDFLZToSupport) and M28Utilities.IsTableEmpty(tDFUnits) then iDFLZToSupport = -1 end
            if bDebugMessages == true then LOG(sFunctionRef..': iDFLZToSupport after initial check='..(iDFLZToSupport or 'nil')..'; iIndirectLZToSupport after initial check='..(iIndirectLZToSupport or 'nil')) end
            if not(iIndirectLZToSupport) or not(iDFLZToSupport) then
                --Are there any further away LZs on this plateau that want support?
                local iClosestLZDFDist = 100000
                local iCurDist
                local iClosestLZIndirectDist = 100000
                local iClosestDFLZRef
                local iClosestIndirectLZRef
                local iMinEnemyValueToAttack = iAvailableCombatUnitThreat * 0.1
                local tiIndirectLZWithNegligibleEnemies = {}
                local tiDFLZWithNegligibleEnemies = {}

                if M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau] then
                    local iIslandWanted = tLZData[M28Map.subrefLZIslandRef]
                    for iOtherLZ, bWantsSupport in M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau] do
                        if bWantsSupport and not(iOtherLZ == iLandZone) and not(tbAdjacentZoneEnemiesToIgnoreByZone[iOtherLZ]) then
                            local tOtherLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ]
                            if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tOtherLZData[M28Map.subrefMidpoint])) then
                                if iIslandWanted == tOtherLZData[M28Map.subrefLZIslandRef] then --If in dif island then want to leave for the amphibious logic later
                                    --Check not negligible value
                                    if (tOtherLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefThreatEnemyStructureTotalMass] or 0) + (tOtherLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] or 0) >= iMinEnemyValueToAttack then
                                        if not(iDFLZToSupport) and tOtherLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport] then
                                            --Redundancy - if we cant path using land units then treat distance as 10k + straight line distance, so we prioritise locations that are land pathable (although ideally wouldnt have any such zones anyway?)
                                            iCurDist = (M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iOtherLZ) or 10000) --M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefMidpoint])
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to support iOtherLZ '..iOtherLZ..'; iCurDist='..iCurDist..'; iClosestLZDFDist='..iClosestLZDFDist..'; straight line dist from our start='..M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam][M28Map.reftClosestFriendlyBase], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefMidpoint])) end
                                            if iCurDist >= 10000 and iCurDist < iClosestLZDFDist then iCurDist = iCurDist + M28Utilities.GetDistanceBetweenPositions(tOtherLZData[M28Map.subrefMidpoint], tLZData[M28Map.subrefMidpoint]) end
                                            if iCurDist and iCurDist < iClosestLZDFDist then
                                                iClosestLZDFDist = iCurDist
                                                iClosestDFLZRef = iOtherLZ
                                            end
                                            if not(iIndirectLZToSupport) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsIndirectSupport] then
                                                if iCurDist and iCurDist < iClosestLZIndirectDist then
                                                    iClosestLZIndirectDist = iCurDist
                                                    iClosestIndirectLZRef = iOtherLZ
                                                end
                                            end
                                        elseif not(iIndirectLZToSupport) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsIndirectSupport] then
                                            iCurDist = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iOtherLZ) --M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefMidpoint])
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to support witih indirect iOtherLZ '..iOtherLZ..'; iLandZone='..iLandZone..'; iCurDist='..repru(iCurDist)..'; iClosestLZIndirectDist='..repru(iClosestLZIndirectDist)..'; straight line dist from our start='..M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam][M28Map.reftClosestFriendlyBase], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefMidpoint])) end
                                            if iCurDist and iCurDist < iClosestLZIndirectDist then
                                                iClosestLZIndirectDist = iCurDist
                                                iClosestIndirectLZRef = iOtherLZ
                                            end
                                        end
                                    else
                                        if not(iDFLZToSupport) and tOtherLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport] then
                                            table.insert(tiDFLZWithNegligibleEnemies, iOtherLZ)
                                        end
                                        if not(iIndirectLZToSupport) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsIndirectSupport] then
                                            table.insert(tiIndirectLZWithNegligibleEnemies, iOtherLZ)
                                        end

                                    end
                                end
                            end
                        end
                    end
                end

                if not(iDFLZToSupport) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have no DFLZToSupport, so will set it to iClosestDFLZRef in case that isnt nil, iClosestDFLZRef='..(iClosestDFLZRef or 'nil')) end
                    iDFLZToSupport = iClosestDFLZRef
                end

                --If we have any negligible zones, then send some units to these first and remove them from the table of DF or IF units
                if M28Utilities.IsTableEmpty(tiDFLZWithNegligibleEnemies) == false and M28Utilities.IsTableEmpty(tDFUnits) == false then
                    --Cycle through each zone and assign DF units
                    local iMaxThreatToAssign, iCurAssignedThreat
                    for iEntry, iOtherLZ in tiDFLZWithNegligibleEnemies do
                        --Calc threat to assign
                        local tOtherLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ]
                        local tOtherLZTeamData = tOtherLZData[M28Map.subrefLZTeamData][iTeam]
                        iCurAssignedThreat = 0
                        iMaxThreatToAssign = ((tOtherLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 6 + (tOtherLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0)) * 3
                        for iCurDFUnit = table.getn(tDFUnits), 1, -1 do
                            if tDFUnits[iCurDFUnit][M28UnitInfo.refiUnitMassCost] < iMaxThreatToAssign or (EntityCategoryContains(M28UnitInfo.refCategoryLandCombat - categories.EXPERIMENTAL, tDFUnits[iCurDFUnit].UnitId) and M28UnitInfo.GetUnitLifetimeCount(tDFUnits[iCurDFUnit]) > 3) then
                                iCurAssignedThreat = iCurAssignedThreat + tDFUnits[iCurDFUnit][M28UnitInfo.refiUnitMassCost]
                                M28Orders.IssueTrackedMove(tDFUnits[iCurDFUnit], tOtherLZData[M28Map.subrefMidpoint], 5, false, 'NegZDF'..iLandZone..'To'..iOtherLZ, false)
                                if bDebugMessages == true then LOG(sFunctionRef..': Assigned DF unit '..tDFUnits[iCurDFUnit].UnitId..M28UnitInfo.GetUnitLifetimeCount(tDFUnits[iCurDFUnit])..' to the negligible threat zone '..iOtherLZ..'; iCurAssignedThreat='..iCurAssignedThreat..'; iMaxThreatToAssign='..iMaxThreatToAssign) end
                                table.remove(tDFUnits, iCurDFUnit)
                                if iCurAssignedThreat >= iMaxThreatToAssign then break end
                            end
                        end
                    end
                end

                if M28Utilities.IsTableEmpty(tiIndirectLZWithNegligibleEnemies) == false and M28Utilities.IsTableEmpty(tIndirectUnits) == false then
                    --Cycle through each zone and assign DF units
                    local iMaxThreatToAssign, iCurAssignedThreat
                    local bOnlyIncludeStructureThreat = not(M28Utilities.IsTableEmpty(tDFUnits)) --if we still have DF units available then we have already assigned enough DF units to handle the zone by themselves
                    for iEntry, iOtherLZ in tiIndirectLZWithNegligibleEnemies do
                        --Calc threat to assign
                        local tOtherLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ]
                        local tOtherLZTeamData = tOtherLZData[M28Map.subrefLZTeamData][iTeam]
                        iCurAssignedThreat = 0
                        if bOnlyIncludeStructureThreat then
                            iMaxThreatToAssign = (tOtherLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) * 5
                        else
                            iMaxThreatToAssign = ((tOtherLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 2 + (tOtherLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0)) * 5
                        end
                        for iCurUnit = table.getn(tIndirectUnits), 1, -1 do
                            if tIndirectUnits[iCurUnit][M28UnitInfo.refiUnitMassCost] < iMaxThreatToAssign then
                                iCurAssignedThreat = iCurAssignedThreat + tIndirectUnits[iCurUnit][M28UnitInfo.refiUnitMassCost]
                                M28Orders.IssueTrackedMove(tIndirectUnits[iCurUnit], tOtherLZData[M28Map.subrefMidpoint], 5, false, 'NegZIF'..iLandZone..'To'..iOtherLZ, false)
                                if bDebugMessages == true then LOG(sFunctionRef..': Assigned IF unit '..tIndirectUnits[iCurUnit].UnitId..M28UnitInfo.GetUnitLifetimeCount(tIndirectUnits[iCurUnit])..' to the negligible threat zone '..iOtherLZ..'; iCurAssignedThreat='..iCurAssignedThreat..'; iMaxThreatToAssign='..iMaxThreatToAssign) end
                                table.remove(tIndirectUnits, iCurUnit)
                                if iCurAssignedThreat >= iMaxThreatToAssign then break end
                            end
                        end
                    end
                end


                --If still not found somewhere to support, check for nearby islands wanting support
                if bDebugMessages == true then LOG(sFunctionRef..': Checking for LZs to send DF units to support at time '..GetGameTimeSeconds()..' for LZ '..(iLandZone or 'nil')..' on island '..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..', pre island iDFLZToSupport='..(iDFLZToSupport or 'nil')..'; is pathing to other islands empty='..tostring(tLZData[M28Map.subrefLZPathingToOtherIslands] or false)) end
                if not(iDFLZToSupport) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false and M28Utilities.IsTableEmpty(tDFUnits) == false then
                    --Do we have amphibious or hover units in our available units?
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of amphib combat empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryAmphibiousCombat, tDFUnits)))) end
                    local tAmphibiousDFUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryAmphibiousCombat, tDFUnits)
                    if M28Utilities.IsTableEmpty(tAmphibiousDFUnits) == false then
                        local bConsiderAttackingEnemyBase = false
                        --If enemy has long range threat then consider sending experimentals to attack their base
                        if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure]) == false then
                            local iAmphibiousCombatThreat = M28UnitInfo.GetCombatThreatRating(tAmphibiousDFUnits, false, false)
                            if bDebugMessages == true then LOG(sFunctionRef..': iAmphibiousCombatThreat='..iAmphibiousCombatThreat) end
                            if iAmphibiousCombatThreat >= 19000 then --Monkeylord is 20k
                                --Do we have at least as many land experimentals as the enemy? (otherwise we risk suiciding into their base)
                                local iEnemyExperimentalCount = 0
                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
                                    iEnemyExperimentalCount = table.getn(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals])
                                end
                                if iEnemyExperimentalCount > 0 then
                                    local iFriendlyExperimentalCount = 0
                                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                        iFriendlyExperimentalCount = iFriendlyExperimentalCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandExperimental)
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': iFriendlyExperimentalCount='..iFriendlyExperimentalCount..'; iEnemyExperimentalCount='..iEnemyExperimentalCount) end
                                    if iFriendlyExperimentalCount > iEnemyExperimentalCount then
                                        bConsiderAttackingEnemyBase = true
                                    end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy has no land experimentals so will attack') end
                                    bConsiderAttackingEnemyBase = true
                                end

                            end
                        end
                        local iDistanceThreshold
                        if bConsiderAttackingEnemyBase then
                            iDistanceThreshold = math.max(400, M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) * 1.25)
                        else
                            iDistanceThreshold = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) * 0.75
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': bConsiderAttackingEnemyBase='..tostring(bConsiderAttackingEnemyBase)..'; iDistanceThreshold='..iDistanceThreshold) end

                        for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering island '..tPathingData[M28Map.subrefIslandNumber]..'; tPathingData[M28Map.subrefIslandTravelDist]='..tPathingData[M28Map.subrefIslandTravelDist]..'; iDistanceThreshold='..iDistanceThreshold..'; Does LZ want support='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsSupport])..'; tPathingData[M28Map.subrefIslandClosestLZRef]='..tPathingData[M28Map.subrefIslandClosestLZRef]) end
                            if tPathingData[M28Map.subrefIslandTravelDist] > iDistanceThreshold then break end

                            if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsSupport] then
                                if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea( M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefMidpoint])) then
                                    iDFLZToSupport = tPathingData[M28Map.subrefIslandClosestLZRef]
                                    M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.refbIslandBeachhead] = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will support the closeest LZ ref, iDFLZToSupport='..iDFLZToSupport) end
                                    break
                                end
                            end
                        end
                    end
                end

                if not(iIndirectLZToSupport) then
                    iIndirectLZToSupport = (iClosestIndirectLZRef or iDFLZToSupport)
                end
            end

            if iDFLZToSupport > 0 and M28Utilities.IsTableEmpty(tDFUnits) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to support LZ '..iDFLZToSupport..'; Will adjust DF to get via point if it is far away; midpoint of iDFToSupport='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iDFLZToSupport][M28Map.subrefMidpoint])..'; Midpoint of this LZ='..repru(tLZData[M28Map.subrefMidpoint])) end
                iDFLZToSupport = ReviseTargetLZIfFarAway(tLZData, iTeam, iPlateau, iLandZone, iDFLZToSupport, 2)
                if bDebugMessages == true then LOG(sFunctionRef..': iDFLZToSupport after revising target for far away LZ='..iDFLZToSupport..'; Midpoint of this zone='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iDFLZToSupport][M28Map.subrefMidpoint])) end

                for iUnit, oUnit in tDFUnits do
                    --Remove assignment value if the unit isnt part of this zone
                    if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                        oUnit[refiCurrentAssignmentValue] = 0
                    else
                        --Attack-move if very long range (unless negligible nearby enemy threat)
                        if (oUnit[M28UnitInfo.refiDFRange] >= 60 and (not(oUnit[M28UnitInfo.refbLastShotBlocked]) or oUnit[M28UnitInfo.refiDFRange] >= 130)) or (oUnit[M28UnitInfo.refiDFMinRange] or 0) >= 20 then
                            --jericho - workaround for attackmove not working
                            if not(oUnit.UnitId == 'xnl0403') or DontHaveJerichoAttackTarget(oUnit) then
                                if GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0) <= 10 and M28Conditions.HaveSignificantEnemyThreatWithinRange(tLZData, tLZTeamData, iPlateau, iTeam, oUnit[M28UnitInfo.refiDFRange] + 3, oUnit:GetPosition(), 1500, M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryT2PlusPD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryNavalSurface - categories.TECH1 + categories.COMMAND, tUnitsNearFatboyInFurtherAwayZones) then
                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iDFLZToSupport][M28Map.subrefMidpoint], 6, false, 'DFAMvLZ'..iDFLZToSupport..';'..iLandZone)
                                    end
                                else
                                    --Negligible enemy threat so just move
                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                        M28Orders.IssueTrackedMove(oUnit, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iDFLZToSupport][M28Map.subrefMidpoint], 6, false, 'DFXMvLZ'..iDFLZToSupport..';'..iLandZone)
                                    end
                                end
                            end
                        else
                            if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                M28Orders.IssueTrackedMove(oUnit, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iDFLZToSupport][M28Map.subrefMidpoint], 6, false, 'DFMovLZ'..iDFLZToSupport..';'..iLandZone)
                            end
                        end
                    end
                end
                tDFUnits = nil
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Deciding where to send IF units, iIndirectLZToSupport='..(iIndirectLZToSupport or 'nil')..'; is table of IF units empty='..tostring(M28Utilities.IsTableEmpty(M28Utilities.IsTableEmpty(tIndirectUnits)))) end
            if iIndirectLZToSupport > 0 and M28Utilities.IsTableEmpty(tIndirectUnits) == false then
                iIndirectLZToSupport = ReviseTargetLZIfFarAway(tLZData, iTeam, iPlateau, iLandZone, iIndirectLZToSupport, 2)
                for iUnit, oUnit in tIndirectUnits do
                    if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is in a different zone to this so will set its asisgnment value to 0 so it can be assigned by that zone') end
                        oUnit[refiCurrentAssignmentValue] = 0
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Do we want to ignore orders due to having a stuck unit? oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Ignore due to stuck unit='..tostring(IgnoreOrderDueToStuckUnit(oUnit))) end
                        if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                            M28Orders.IssueTrackedMove(oUnit, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iIndirectLZToSupport][M28Map.subrefMidpoint], 6, false, 'IFMovLZ'..iIndirectLZToSupport..';'..iLandZone)
                        end
                    end
                end
                tIndirectUnits = nil
            end
            local tRemainingLandUnits = {}
            if M28Utilities.IsTableEmpty(tDFUnits) == false then
                for iUnit, oUnit in tDFUnits do
                    table.insert(tRemainingLandUnits, oUnit)
                end
            end
            if M28Utilities.IsTableEmpty(tIndirectUnits) == false then
                for iUnit, oUnit in tIndirectUnits do
                    table.insert(tRemainingLandUnits, oUnit)
                end
            end
            if M28Utilities.IsTableEmpty(tRemainingLandUnits) == false then
                --Search for a zone with enemy units and attack it, if there is one
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                    for iEntry, tSubtable in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                        local tCurZoneTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam]
                        if M28Utilities.IsTableEmpty(tCurZoneTeamData[M28Map.subrefTEnemyUnits]) == false then
                            local tCurLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefLZNumber]]
                            for iUnit, oUnit in tRemainingLandUnits do
                                if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                                    oUnit[refiCurrentAssignmentValue] = 0
                                else
                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                        M28Orders.IssueTrackedMove(oUnit, tCurLZData[M28Map.subrefMidpoint], 6, false, 'BkMvLZ'..tSubtable[M28Map.subrefLZNumber]..';'..iLandZone)
                                    end
                                end
                            end
                            tRemainingLandUnits = nil
                            break
                        end
                    end

                    if M28Utilities.IsTableEmpty(tRemainingLandUnits) == false then

                        if NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint]) then
                            if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZTeamData[M28Map.reftClosestEnemyBase])) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will send all land units to closest enemy base') end
                                for iUnit, oUnit in tRemainingLandUnits do
                                    if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                                        oUnit[refiCurrentAssignmentValue] = 0
                                    else
                                        if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                            M28Orders.IssueTrackedMove(oUnit, tLZTeamData[M28Map.reftClosestEnemyBase], 6, false, 'MTDEnB'..iLandZone)
                                        end
                                    end
                                end
                            end
                        end
                        if tRemainingLandUnits then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have remaining land units with nowhere to go, is pathing of closest enemy base same as pathing of this land zone? enemy base land label='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) or 'nil')..'; label of this zone='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint]) or 'nil')..'; Is table of units empty after considering sending to enemy base='..tostring(M28Utilities.IsTableEmpty(tRemainingLandUnits))) end
                            if M28Utilities.IsTableEmpty(tRemainingLandUnits) == false then
                                --Campaign specific - send to main enemy campaign base
                                if M28Map.bIsCampaignMap and M28Utilities.IsTableEmpty(M28Team.GetEnemyMainCampaignBase(iTeam)) == false and NavUtils.GetLabel(M28Map.refPathingTypeHover, M28Team.GetEnemyMainCampaignBase(iTeam)) == iPlateau then
                                    if NavUtils.GetLabel(M28Map.refPathingTypeLand, M28Team.GetEnemyMainCampaignBase(iTeam)) == tLZData[M28Map.subrefLZIslandRef] then
                                        for iUnit, oUnit in tRemainingLandUnits do
                                            if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                                                oUnit[refiCurrentAssignmentValue] = 0
                                            else
                                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                    M28Orders.IssueTrackedMove(oUnit, M28Team.GetEnemyMainCampaignBase(iTeam), 6, false, 'CmpEnB'..iLandZone)
                                                end
                                            end
                                        end
                                    else
                                        --Do we have any amphibious or hover units?
                                        local tbGivenIndexUnitOrder = {}
                                        for iUnit, oUnit in tRemainingLandUnits do
                                            if EntityCategoryContains(M28UnitInfo.refCategoryAmphibious + categories.HOVER, oUnit.UnitId) then
                                                if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                                                    oUnit[refiCurrentAssignmentValue] = 0
                                                else
                                                    tbGivenIndexUnitOrder[iUnit] = true
                                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                        M28Orders.IssueTrackedMove(oUnit, M28Team.GetEnemyMainCampaignBase(iTeam), 6, false, 'CmpHEnB'..iLandZone)
                                                    end
                                                end
                                            end
                                        end
                                        if M28Utilities.IsTableEmpty(tbGivenIndexUnitOrder) == false then
                                            for iCurUnit = table.getn(tRemainingLandUnits), 1, -1 do
                                                if tbGivenIndexUnitOrder[iCurUnit] then table.remove(tRemainingLandUnits, iCurUnit) end
                                            end
                                        end
                                    end
                                end
                                if M28Utilities.IsTableEmpty(tRemainingLandUnits) == false then
                                    --Can we path to the enemy base with land? if so then send units to it
                                    if NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint]) then
                                        if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZTeamData[M28Map.reftClosestEnemyBase])) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will send all land units to closest enemy base') end
                                            for iUnit, oUnit in tRemainingLandUnits do
                                                if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                                                    oUnit[refiCurrentAssignmentValue] = 0
                                                else
                                                    M28Orders.IssueTrackedMove(oUnit, tLZTeamData[M28Map.reftClosestEnemyBase], 6, false, 'MTDEnB'..iLandZone)
                                                end
                                            end
                                            tRemainingLandUnits = nil
                                        end
                                    end
                                    if tRemainingLandUnits then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have remaining land units with nowhere to go, is pathing of closest enemy base same as pathing of this land zone? enemy base land label='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) or 'nil')..'; label of this zone='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint]) or 'nil')..'; Is table of units empty after considering sending to enemy base='..tostring(M28Utilities.IsTableEmpty(tRemainingLandUnits))) end
                                        if M28Utilities.IsTableEmpty(tRemainingLandUnits) == false then
                                            --Cant go to enemy base, so just follow land scouting path
                                            if bDebugMessages == true then LOG(sFunctionRef..': Follow land scouting path if we have one, is patrol path empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subreftPatrolPath]))) end
                                            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subreftPatrolPath]) == false then
                                                --Patrol the land zone
                                                for iUnit, oUnit in tRemainingLandUnits do
                                                    if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                                                        oUnit[refiCurrentAssignmentValue] = 0
                                                    else
                                                        M28Orders.PatrolPath(oUnit, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subreftPatrolPath], false, 'SP')
                                                    end
                                                end
                                            else
                                                --Do nothing
                                            end
                                        end
                                    end
                                end
                                --M28Orders.IssueTrackedMove(oUnit, tLZTeamData[M28Map.reftClosestEnemyBase], 6, false, 'MTDEnB'..iLandZone)
                            end
                        end
                    end
                end
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code for iLandZOne '..iLandZone..', bWantReinforcements='..tostring(bWantReinforcements)..'; bWantIndirectReinforcements='..tostring(bWantIndirectReinforcements)) end
    local bWantDFReinforcements = bWantReinforcements
    if bWantReinforcements then
        --Do we want to get indirect fire instead of direct fire as an override?
        if tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] >= 400 then
            local iEnemyStructureThreatTotal = 0
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                    iEnemyStructureThreatTotal = iEnemyStructureThreatTotal + iThreat
                end
            end
            if tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] < tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] * 1.3 then
                --We have enough DF threat, if we want more indirect threat then no longer flag as wanting DF support and instead flag that we want indirect support
                if iEnemyStructureThreatTotal * 1.4 > math.max(50, tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]) then
                    local iDFRatio = tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] / math.max(1, tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal])
                    local iIndirectRatio = math.max(50, tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]) / math.max(iEnemyStructureThreatTotal, 1)
                    if iIndirectRatio < iDFRatio then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want more indirect units due to the ratio of indirect to DF units, iIndirectRatio='..iIndirectRatio..'; iDFRatio='..iDFRatio) end
                        bWantIndirectReinforcements = true
                        bWantDFReinforcements = false
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking override for reinforcement type, bWantDFReinforcements='..tostring(bWantDFReinforcements)..'; bWantIndirectReinforcements='..tostring(bWantIndirectReinforcements)..'; iEnemyStructureThreatTotal='..iEnemyStructureThreatTotal..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]) end
        end
    end
    if not(bWantIndirectReinforcements) and GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -100) <= 30 then
        if bDebugMessages == true then LOG(sFunctionRef..': It has been '..GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -100)..' since MML were firing near TMD so want more indirect fire so get more MML') end
        bWantIndirectReinforcements = true
    end
    if bWantDFReinforcements and not(bWantIndirectReinforcements) then
        --If we already have higher DF threat than enemy DF threat in this zone, then consider adjacent zones and whether we want some indirect fire threat here
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to change to requesting indirect units, tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]) end
        if tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] > tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] and tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] > tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] then
            local iNearbyEnemyMobileDFThreat = (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)
            local iNearbyEnemyStructureThreat = 0
            if tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] > 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                    iNearbyEnemyStructureThreat = iNearbyEnemyStructureThreat + iThreat
                end
            end
            local iNearbyAllyMobileDFThreat = (tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0)
            local iNearbyAllyMobileIndirectThreat = (tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] or 0)
            function UpdateForAdjacentLZ(tAdjLZTeamData)
                iNearbyEnemyMobileDFThreat = iNearbyEnemyMobileDFThreat + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)
                if tAdjLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] > 0 and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                    for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                        iNearbyEnemyStructureThreat = iNearbyEnemyStructureThreat + iThreat
                    end
                end
                iNearbyAllyMobileDFThreat = iNearbyAllyMobileDFThreat + (tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0)
                iNearbyAllyMobileIndirectThreat = iNearbyAllyMobileIndirectThreat + (tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] or 0)
            end
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                UpdateForAdjacentLZ(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam])
            end
            if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
                for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                    UpdateForAdjacentLZ(M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam])
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': iNearbyEnemyMobileDFThreat='..iNearbyEnemyMobileDFThreat..'; iNearbyEnemyStructureThreat='..iNearbyEnemyStructureThreat..'; iNearbyAllyMobileDFThreat='..iNearbyAllyMobileDFThreat..'; iNearbyAllyMobileIndirectThreat='..iNearbyAllyMobileIndirectThreat) end
            if iNearbyEnemyMobileDFThreat < iNearbyAllyMobileDFThreat and iNearbyAllyMobileIndirectThreat < iNearbyEnemyStructureThreat then
                bWantIndirectReinforcements = true
            end
        end
    end

    --Enemy structure in nearby plateau that we can probably reach

    if bDebugMessages == true then LOG(sFunctionRef..': Checking if want to request indirect reinforcements for dif plateau threat, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; enemies in this or adjacent='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; bWantIndirectReinforcements='..tostring(bWantIndirectReinforcements)..'; Valid structure in other plateau='..tostring(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere])..'; Highest friendly land fac tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]) end
    if not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and not(bWantIndirectReinforcements) and M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3 then
        bWantIndirectReinforcements = M28Conditions.IsNearbyStructureThatWeCanReachWithIndirect(tLZData, tLZTeamData, iTeam)
    end
    if not(bWantIndirectReinforcements) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and (tLZTeamData[M28Map.subrefLZbCoreBase] or tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][2] >= 3) then
        bWantIndirectReinforcements = true
    end

    UpdateIfLandZoneWantsSupport(tLZTeamData, iPlateau, iLandZone, iTeam, bWantDFReinforcements, bWantIndirectReinforcements)
    if bDebugMessages == true then LOG(sFunctionRef..': Just recorded if this LZ wants support, bWantDFReinforcements='..tostring(bWantDFReinforcements)..'; bWantIndirectReinforcements='..tostring(bWantIndirectReinforcements)..'; tLZTeamData[M28Map.subrefbLZWantsSupport] = '..tostring(tLZTeamData[M28Map.subrefbLZWantsSupport])..'; tLZTeamData[M28Map.subrefbLZWantsDFSupport]='..tostring(tLZTeamData[M28Map.subrefbLZWantsDFSupport])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RetreatOtherUnits(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tOtherUnitsToRetreat)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RetreatOtherUnits'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2)
    local tAmphibiousRallyPoint = GetNearestLandRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2, true)
    local iCurTime = math.floor(GetGameTimeSeconds())
    local bConsiderKitingRetreat = tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]
    local oNearestEnemyCombatToRallyPoint
    for iUnit, oUnit in tOtherUnitsToRetreat do
        oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
        --Fatboy (and megalith although wouldnt expect megalith to use this function) - consider retreating slowly instead of running around, and also retreating in opposite direction to the nearest enemy (instead of going to the rally point)
        if bDebugMessages == true then LOG(sFunctionRef..': Considering retreating unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bConsiderKitingRetreat='..tostring(bConsiderKitingRetreat or false)..'; Combat range='..(oUnit[M28UnitInfo.refiCombatRange] or 0)..'; Is a fatboy/mega='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryMegalith, oUnit.UnitId))) end
        if bConsiderKitingRetreat and (oUnit[M28UnitInfo.refiCombatRange] or 0) > 30 and EntityCategoryContains(M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryMegalith, oUnit.UnitId) then
            if not(oNearestEnemyCombatToRallyPoint) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                oNearestEnemyCombatToRallyPoint = M28Utilities.GetNearestUnit(tLZTeamData[M28Map.reftoNearestDFEnemies], tAmphibiousRallyPoint)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': oNearestEnemyCombatToRallyPoint='..(oNearestEnemyCombatToRallyPoint.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyCombatToRallyPoint) or 'nil')) end
            local bDoneKitingRetreat = false
            if oNearestEnemyCombatToRallyPoint then
                local iCurDist = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyCombatToRallyPoint:GetPosition(), oUnit:GetPosition())
                if iCurDist <= oUnit[M28UnitInfo.refiCombatRange] and iCurDist >= math.max(10, (oUnit[M28UnitInfo.refiCombatRange] or 0) - 5) then
                    --Want to consider retreating
                    local iBackupDist = (oUnit:GetBlueprint().Physics.BackUpDistance or 0)
                    if iBackupDist > 3 then
                        local iAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oNearestEnemyCombatToRallyPoint:GetPosition())
                        local iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tAmphibiousRallyPoint)
                        local tRetreatLocationToUse
                        if M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToRally) >= 145 then --i.e. 70 degree section where will go with rally point instead of opposite direction
                            tRetreatLocationToUse = {tAmphibiousRallyPoint[1], tAmphibiousRallyPoint[2], tAmphibiousRallyPoint[3]}
                        else
                            local tPotentialRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToNearestEnemy - 180, iBackupDist - 3, true, nil, M28Map.bIsCampaignMap)
                            if M28Utilities.IsTableEmpty(tPotentialRetreatLocation) == false and NavUtils.GetLabel(M28Map.refPathingTypeHover, tPotentialRetreatLocation) == iPlateau then
                                tRetreatLocationToUse = {tPotentialRetreatLocation[1], tPotentialRetreatLocation[2], tPotentialRetreatLocation[3]}
                            else
                                tRetreatLocationToUse = {tAmphibiousRallyPoint[1], tAmphibiousRallyPoint[2], tAmphibiousRallyPoint[3]}
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try backing up for fatboy or similar unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; tRetreatLocationToUse='..repru(tRetreatLocationToUse)..'; oNearestEnemyCombatToRallyPoint='..oNearestEnemyCombatToRallyPoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyCombatToRallyPoint)) end
                        bDoneKitingRetreat = true
                        ForkThread(BackupUnitTowardsRallyIfAvailable, oUnit, tRetreatLocationToUse, iPlateau, 'SpFBlsRetr', true, math.min(9, iBackupDist))
                        --M28Orders.IssueTrackedMove(oUnit, tRetreatLocationToUse, 3, false, 'SpFBlsRetr')
                    end
                end
            end
            if not(bDoneKitingRetreat) then
                M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 10, false, 'FMNoERetr')
            end
        elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 10, false, 'AOtRet')
        else
            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 10, false, 'OtRet', false)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordUnitAsReceivingLandZoneAssignment(oUnit, iPlateau, iLandZone, iCurLZValue)
    oUnit[refiCurrentAssignmentValue] = iCurLZValue --This is also updated for units that are part of a separate zone
    oUnit[refiCurrentAssignmentPlateauAndLZ] = {iPlateau, iLandZone}
    oUnit[refiTimeOfLastAssignment] = GetGameTimeSeconds()
    if oUnit[M28Navy.refiCurrentWZAssignmentValue] then
        oUnit[M28Navy.refiCurrentWZAssignmentValue] = nil
        oUnit[M28Navy.refiCurrentAssignmentWaterZone] = nil
    end
end

function ManageSpecificLandZone(aiBrain, iTeam, iPlateau, iLandZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageSpecificLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Record enemy threat
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]



    if bDebugMessages == true then LOG(sFunctionRef..': About to update threat for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; Is LZTeamData empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData))..'; Time='..GetGameTimeSeconds()) end
    RecordGroundThreatForLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone)
    RecordAirThreatForLandZone(tLZTeamData, iTeam, iPlateau, iLandZone)

    tLZTeamData[M28Map.subrefLZTAlliedCombatUnits] = {}
    tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield] = {}
    tLZTeamData[M28Map.refbLZWantsMobileShield] = false --will change later
    tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth] = {}
    tLZTeamData[M28Map.refbLZWantsMobileStealth] = false --will change later
    tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts] = nil --will change later

    --Build location tracker
    tLZData[M28Map.subrefSegmentsConsideredThisTick] = 0

    local tEngineers, tScouts, tMobileShields, tMobileStealths, tOtherUnitsToRetreat, tSACUs
    local iCurShield, iMaxShield
    local bLandZoneOrAdjHasUnitsWantingScout = false
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
    local bUpdateEnemyDataHere = true --Will handle this logic in logic for managing land zone units if htis is false

    local bAlliedUnitsHereOrInAdjacentZone = not(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))
    local bHaveCombatUnitsFromAdjZone = false
    if not(bAlliedUnitsHereOrInAdjacentZone) then
        for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
            local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
            bAlliedUnitsHereOrInAdjacentZone = M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if bAlliedUnitsHereOrInAdjacentZone then break end

        end
    end
    if bAlliedUnitsHereOrInAdjacentZone then
        --Decide on what to do with units in this LZ
        tEngineers = {}
        tScouts = {}
        tMobileShields = {}
        tMobileStealths = {}
        tSACUs = {}
        tOtherUnitsToRetreat = {} --Intended for e.g. fatboys and units with personal shield
        local bUseRASInCombat = false
        if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 then bUseRASInCombat = true end
        local tAvailableCombatUnits = {}
        local tUnavailableUnitsInThisLZ = {}
        local tTempOtherUnits = {}
        local tAvailableMAA = {}
        local iCurLZValue = tLZTeamData[M28Map.subrefLZTValue]

        local iOurBestDFRange = 0
        local iOurBestIndirectRange = 0
        local bIncludeUnit
        local iAvailableCombatCount = 0 --used to decide whether to only issue orders to hover units every 6s

        local iEnemyOmniCoverage = M28Conditions.GetEnemyOmniCoverageOfZone(iPlateau, iLandZone, iTeam)

        local iMobileShieldMassThreshold = 150 --When assigning mobile shields will also restrict further so e.g. seraphim mobile shields will have a higher threshold
        local iMobileShieldHigherMAAMassThreshold = 400 --for if we have MAA and enemy doesnt have much air threat
        local iMobileStealthMassThreshold = 200 --will get adjusted further
        local iMobileStealthHigherMassThreshold = 500 --i.e. wont stealth loyalists and titans
        local iUnitMassCost, iShieldPercentageAdjust, iCurHealthPercent
        local iMobileStealthLowerThresholdCount = 0 --Used to avoid assigning too many mobile stealth at once to units not exceeding the higher mass threshold
        if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 600 and (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 2000 or tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0) then iMobileShieldHigherMAAMassThreshold = iMobileShieldMassThreshold end
        local bConsiderMobileShieldsForT2Arti = false
        local bConsiderMobileShieldsForT2PD = false
        local tMAAGuardsToRetreat
        if tLZTeamData[M28Map.subrefLZbCoreBase] then
            if (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false or (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) > 0) then
                bConsiderMobileShieldsForT2Arti = true
                bConsiderMobileShieldsForT2PD = true
            elseif tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                bConsiderMobileShieldsForT2PD = true
            end

        end

        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            local bConsiderMobileShieldsForBuildings = false
            if M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] > 0 and tLZTeamData[M28Map.refiTimeOfNearbyEnemyNovax] and GetGameTimeSeconds() - tLZTeamData[M28Map.refiTimeOfNearbyEnemyNovax] <= 2 then bConsiderMobileShieldsForBuildings = true end
            local bCurUnitWantsMobileShield
            local iSACUCategory = categories.SUBCOMMANDER --[[M28UnitInfo.refCategoryRASSACU
            if (tLZTeamData[M28Map.subrefiTimeLastWantSACUForExp] or tLZTeamData[M28Map.subrefiTimeLastWantSACUForSMD]) and not(bUseRASInCombat) then iSACUCategory = iSACUCategory + categories.SUBCOMMANDER end--]]
            for iUnit, oUnit in tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with fraction complete '..oUnit:GetFractionComplete()..' owned by brain '..oUnit:GetAIBrain().Nickname..'; Special micro active='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive] or false)..'; Time until micro stopped='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] or 0)) end
                bCurUnitWantsMobileShield = false
                if oUnit[refbFlaggedForPriorityScout] then
                    if not(tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts]) then tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts] = {} end
                    table.insert(tLZTeamData[M28Map.reftoUnitsWantingPriorityScouts], oUnit)
                end
                if oUnit:GetFractionComplete() >= 1 then
                    if EntityCategoryContains(categories.MOBILE - M28UnitInfo.refCategoryScathis, oUnit.UnitId) then
                        if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                            table.insert(tEngineers, oUnit)
                            bLandZoneOrAdjHasUnitsWantingScout = true
                        elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) or oUnit[M28ACU.refbTreatingAsACU] then
                            --ACU logic - handled via M28ACU file, as amy not want to kite with it; acu is still stored in list of allied units for a land zone though
                            if bDebugMessages == true then LOG(sFunctionRef..': ACU is in list of allied units for iPlateau'..iPlateau..'; iLandZone='..iLandZone..'; Does ACU have valid mobile shield assigned='..tostring(M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileShield]))..'; Assigned shield='..(oUnit[refoAssignedMobileShield].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit[refoAssignedMobileShield]) or 'nil')) end
                            bLandZoneOrAdjHasUnitsWantingScout = true
                            bCurUnitWantsMobileShield = true
                            if not(oUnit[refoAssignedMobileShield]) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Adding ACU to table of units wanting mobile shield for this zone') end
                                table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                            elseif M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] > 0 then --when assigning a mobile shield, we should do it to this table first, and to refoAssignedMobileShield last; that way, the below should only be relevant if previously assigned mobile shields have died or retreated; although not perfect since it means a smaller number assigned, hopefully it will be close enough and avoids the risk of inconsistent conditions leading to an infinite cycle of shield assignment (if changing then need to do an M28Conditions function)
                                if not(M28Conditions.IsTableOfUnitsStillValid(oUnit[reftoAdditionalAssignedMobileShields])) then
                                    table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                                end
                            end
                            if iEnemyOmniCoverage <= 20 and (not(oUnit.HasEnhancement) or not((oUnit:HasEnhancement('StealthGenerator') or oUnit:HasEnhancement('CloakingGenerator')))) then
                                if not(oUnit[refoAssignedMobileStealth]) then
                                    table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth], oUnit)
                                end
                            end

                            if not(oUnit[M28ACU.refbTreatingAsACU]) and oUnit:GetAIBrain().M28AI then ForkThread(M28ACU.ManageACU, oUnit:GetAIBrain(), oUnit) end --redundancy, wouldnt expect this to normally trigger
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit.UnitId) then
                            table.insert(tScouts, oUnit)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMobileLandShield, oUnit.UnitId) then
                            table.insert(tMobileShields, oUnit)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMobileLandStealth, oUnit.UnitId) then
                            table.insert(tMobileStealths, oUnit)
                        elseif EntityCategoryContains(iSACUCategory, oUnit.UnitId) and not(bUseRASInCombat) then
                            --Only include for new orders if not already building something; otherwise do nothing with the unit (as hopefully we already have logic applying to it)
                            if not(oUnit:IsUnitState('Building') or oUnit:IsUnitState('Repairing')) and M28Utilities.IsTableEmpty(oUnit[M28Building.reftArtiTemplateRefs]) then
                                table.insert(tSACUs, oUnit)
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryMobileLand - categories.COMMAND, oUnit.UnitId) or (oUnit[M28UnitInfo.refiCombatRange] > 0 and EntityCategoryContains(M28UnitInfo.refCategoryAmphibious * categories.MOBILE - categories.AIR, oUnit.UnitId)) then
                            --Tanks, skirmishers, and indirect fire units - handled by main combat unit manager
                            bIncludeUnit = false
                            bLandZoneOrAdjHasUnitsWantingScout = true
                            --Is the unit available for use by this land zone?
                            if oUnit:GetFractionComplete() == 1 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Does unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' have a valid guard? Guard='..(oUnit[refoAssignedUnitToGuard].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit[refoAssignedUnitToGuard]) or 'nil')) end
                                if oUnit[refoAssignedUnitToGuard] and M28UnitInfo.IsUnitValid(oUnit[refoAssignedUnitToGuard]) and (EntityCategoryContains(M28UnitInfo.refCategoryAmphibious + categories.HOVER, oUnit.UnitId) or not(M28UnitInfo.IsUnitUnderwater(oUnit[refoAssignedUnitToGuard]))) then
                                    --Guard actually causes MAA to move a bit too far away so will just move towards the unit; currently are just using this for MAA covering a fatboy so moving directly to the unit means it works out well since they wont block the fatboy and will rotate instead to be to the fatboy's rear at all times
                                    --Temporarily run if we are in range of enemy units in the zone
                                    if (oUnit[M28UnitInfo.refiAARange] or 0) > 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 4, iTeam, true, nil, nil, nil, nil, false) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have MAA assigned to guard a unit but enemy DF are close so want to retreat to rally point') end
                                        table.insert(tOtherUnitsToRetreat, oUnit)
                                    else
                                        M28Orders.IssueTrackedMove(oUnit, oUnit[refoAssignedUnitToGuard]:GetPosition(), 3, false, 'SpecG', false)
                                    end
                                elseif oUnit[M28Engineer.refiAssignedAction] == M28Engineer.refActionLoadOntoTransport or oUnit:IsUnitState('Attached') then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Unit is either attached or abut to load into a transport so will ignore') end
                                    --M28Orders.IssueTrackedGuard(oUnit, oUnit[refoAssignedUnitToGuard], false, 'SpecG', false)
                                else
                                    --NOTE: If making changes to below line condition, then update simialr line in M28Team
                                    if oUnit[M28UnitInfo.refiCombatRange] > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId)) then table.insert(tLZTeamData[M28Map.subrefLZTAlliedCombatUnits], oUnit) end
                                    --Is the unit's priority lower than this?
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if have available combat unit, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[refiCurrentAssignmentValue]='..(oUnit[refiCurrentAssignmentValue] or 'nil')..'; oUnit[refiCurrentAssignmentPlateauAndLZ]='..repru(oUnit[refiCurrentAssignmentPlateauAndLZ])..'; iCurLZValue='..iCurLZValue..'; Unit mass cost='..(oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))..'; iMobileShieldMassThreshold='..iMobileShieldMassThreshold) end
                                    if (oUnit[refiCurrentAssignmentValue] or 0) < iCurLZValue or (oUnit[refiCurrentAssignmentPlateauAndLZ][1] == iPlateau and (oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone or (GetGameTimeSeconds() - (oUnit[refiTimeOfLastAssignment] or 0) >= 5))) then
                                        --Is it a unit with a shield that wants to retreat so its shield can regen?
                                        iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, true)
                                        iShieldPercentageAdjust = 0
                                        if iCurShield > 0 then
                                            iCurHealthPercent = M28UnitInfo.GetUnitHealthPercent(oUnit)
                                            if iCurHealthPercent < 0.7 and (iCurHealthPercent < 0.5 or EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId)) then
                                                if M28UnitInfo.GetUnitHealthPercent(oUnit) < 0.2 then iShieldPercentageAdjust = 0.25
                                                else iShieldPercentageAdjust = 0.15
                                                end
                                            elseif EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
                                                iShieldPercentageAdjust = 0.075
                                            end
                                        end

                                        if bDebugMessages == true then LOG(sFunctionRef..': iCurShield='..iCurShield..'; iMaxShield='..iMaxShield..'; Unit max health='..oUnit:GetMaxHealth()..'; Is team stalling energy='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; Team M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount]='..M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount]..'; Is unit paused='..tostring(oUnit[M28UnitInfo.refbPaused] or false)..'; Is shield enabled='..tostring(M28UnitInfo.IsUnitShieldEnabled(oUnit))..'; is oUnit[refbShieldIsDisabled] nil='..tostring(oUnit[M28UnitInfo.refbShieldIsDisabled] == nil)) end
                                        if not(oUnit[M28UnitInfo.refbEasyBrain]) and iMaxShield > 0 and iCurShield < iMaxShield * (0.35 + iShieldPercentageAdjust) and (iCurShield == 0 or iMaxShield > oUnit:GetMaxHealth() * 0.8 or iCurShield < iMaxShield * (iShieldPercentageAdjust + 0.05)) then --Fatboy and in theory SACUs retreat when shield is low; titans etc. retreat when shield is almost gone
                                            if bDebugMessages == true then LOG(sFunctionRef..': Added unit to table of units to retreat') end
                                            table.insert(tOtherUnitsToRetreat, oUnit)
                                            RecordUnitAsReceivingLandZoneAssignment(oUnit, iPlateau, iLandZone, 100000)
                                            --Redundancy for rare cases where a units shield can be disabled from a transfer
                                            if iCurShield == 0 and oUnit[M28UnitInfo.refbTransferredUnit] and not(oUnit[M28UnitInfo.refbPaused]) and (not(M28UnitInfo.IsUnitShieldEnabled(oUnit)) or oUnit[M28UnitInfo.refbShieldIsDisabled] == nil) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will enable shield for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                                M28UnitInfo.EnableUnitShield(oUnit)
                                            end
                                        else
                                            if EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId) then
                                                table.insert(tAvailableMAA, oUnit)
                                                bIncludeUnit =  true
                                            elseif ((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or (oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0) then
                                                table.insert(tAvailableCombatUnits, oUnit)
                                                iAvailableCombatCount = iAvailableCombatCount + 1
                                                if oUnit[M28UnitInfo.refiDFRange] > iOurBestDFRange and not(EntityCategoryContains(M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) then iOurBestDFRange = oUnit[M28UnitInfo.refiDFRange] end
                                                if oUnit[M28UnitInfo.refiIndirectRange] > iOurBestIndirectRange then iOurBestIndirectRange = oUnit[M28UnitInfo.refiIndirectRange] end
                                                bIncludeUnit = true
                                            end
                                            if bIncludeUnit then
                                                RecordUnitAsReceivingLandZoneAssignment(oUnit, iPlateau, iLandZone, iCurLZValue)
                                            end
                                        end
                                    else
                                        table.insert(tUnavailableUnitsInThisLZ, oUnit)
                                    end
                                    iUnitMassCost = (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
                                    if iUnitMassCost >= iMobileShieldMassThreshold and (iUnitMassCost >= iMobileShieldHigherMAAMassThreshold or iMobileShieldHigherMAAMassThreshold == iMobileShieldMassThreshold or not(EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId))) then
                                        bCurUnitWantsMobileShield = true
                                        if not(oUnit[refoAssignedMobileShield]) then
                                            table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Wnat mobile shield for unit') end
                                        end
                                    end
                                    if iEnemyOmniCoverage <= 20 and not(EntityCategoryContains(M28UnitInfo.refCategoryStealth, oUnit.UnitId)) then
                                        if iUnitMassCost >= iMobileStealthHigherMassThreshold then
                                            if not(oUnit[refoAssignedMobileStealth]) then
                                                table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth], oUnit)
                                            end
                                        elseif iUnitMassCost >= iMobileStealthMassThreshold and EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryIndirect + M28UnitInfo.refCategoryAbsolver - categories.TECH1, oUnit.UnitId) then
                                            --Only say we want a mobile shield if the unit doesnt have one assigned
                                            iMobileStealthLowerThresholdCount = iMobileStealthLowerThresholdCount + 1

                                            if iMobileStealthLowerThresholdCount >= 3 or oUnit[refoAssignedMobileStealth] then
                                                iMobileStealthLowerThresholdCount = 0
                                                if not(oUnit[refoAssignedMobileStealth]) then
                                                    table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth], oUnit)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        elseif EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                            --Structure logic - handled separately e.g. via M28Factory for factories
                        else
                            --Unexpected unit type - could e.g. be a naval unit on a location thought to be a land zone; only flag as error if unit has no orders
                            table.insert(tTempOtherUnits, oUnit)
                            bLandZoneOrAdjHasUnitsWantingScout = true
                        end
                    else
                        if bConsiderMobileShieldsForBuildings and M28Utilities.IsTableEmpty(oUnit[M28Building.reftoShieldsProvidingCoverage]) and EntityCategoryContains(M28UnitInfo.refCategoryPower - categories.TECH1 + M28UnitInfo.refCategoryEnergyStorage, oUnit.UnitId) then
                            bCurUnitWantsMobileShield = true
                            if not(oUnit[refoAssignedMobileShield]) then
                                table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                            end
                        elseif bConsiderMobileShieldsForT2Arti and EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) and M28Utilities.IsTableEmpty(oUnit[M28Building.reftoShieldsProvidingCoverage]) then
                            bCurUnitWantsMobileShield = true
                            if not(oUnit[refoAssignedMobileShield]) then
                                table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                            end
                        elseif bConsiderMobileShieldsForT2PD and EntityCategoryContains(M28UnitInfo.refCategoryT2PlusPD, oUnit.UnitId) and M28Utilities.IsTableEmpty(oUnit[M28Building.reftoShieldsProvidingCoverage]) then
                            bCurUnitWantsMobileShield = true
                            if not(oUnit[refoAssignedMobileShield]) then
                                table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                            end
                        end

                    end
                else
                    --Under construction unit
                    if bConsiderMobileShieldsForBuildings and M28Utilities.IsTableEmpty(oUnit[M28Building.reftoShieldsProvidingCoverage]) and EntityCategoryContains(M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryStructure * categories.EXPERIMENTAL + M28UnitInfo.refCategoryScathis, oUnit.UnitId) then
                        bCurUnitWantsMobileShield = true
                        if not(oUnit[refoAssignedMobileShield]) then
                            table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                        end
                    elseif (bConsiderMobileShieldsForT2PD or bConsiderMobileShieldsForT2Arti) and oUnit:GetFractionComplete() >= 0.2 then
                        if bConsiderMobileShieldsForT2Arti then
                            if EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) and M28Utilities.IsTableEmpty(oUnit[M28Building.reftoShieldsProvidingCoverage]) then
                                bCurUnitWantsMobileShield = true
                                if not(oUnit[refoAssignedMobileShield]) then
                                    table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                                end
                            end
                        end
                        if bConsiderMobileShieldsForT2PD then
                            if EntityCategoryContains(M28UnitInfo.refCategoryT2PlusPD, oUnit.UnitId) and M28Utilities.IsTableEmpty(oUnit[M28Building.reftoShieldsProvidingCoverage]) then
                                bCurUnitWantsMobileShield = true
                                if not(oUnit[refoAssignedMobileShield]) then
                                    table.insert(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield], oUnit)
                                end
                            end
                        end
                    end
                end
                if oUnit[refoAssignedMobileShield] and not(bCurUnitWantsMobileShield) and oUnit[refoAssignedMobileShield][refoMobileShieldTarget] == oUnit then
                    ClearCurrentShieldTarget(oUnit[refoAssignedMobileShield])
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of engineers empty='..tostring(M28Utilities.IsTableEmpty(tEngineers))..'; Is table of combat units just for this zone empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))) end

        --Mobile shield data:
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield]) == false then
            for iUnit, oUnit in tLZTeamData[M28Map.reftoLZUnitsWantingMobileShield] do
                if oUnit[refoAssignedMobileShield] then
                    if not(M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileShield])) then
                        oUnit[refoAssignedMobileShield] = nil
                        tLZTeamData[M28Map.refbLZWantsMobileShield] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording that the land zone '..iLandZone..' wants mobile shields as a unit that had a mobile shield no longerh as a valid one') end
                    end
                else
                    tLZTeamData[M28Map.refbLZWantsMobileShield] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording that the land zone '..iLandZone..' wants mobile shields as it has a unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that doesnt have an assigned mobile shield yet') end
                end
            end
        end
        tLZTeamData[M28Map.subrefiAvailableMobileShieldThreat] = 0
        if M28Utilities.IsTableEmpty(tMobileShields) == false then
            tLZTeamData[M28Map.subrefiAvailableMobileShieldThreat] = M28UnitInfo.GetMassCostOfUnits(tMobileShields)
            ManageMobileShieldsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tMobileShields)
        end
        --Mobile stealth data:
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth]) == false then

            for iUnit, oUnit in tLZTeamData[M28Map.reftoLZUnitsWantingMobileStealth] do
                if iEnemyOmniCoverage > 20 then
                    if M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileStealth]) then
                        oUnit[refoAssignedMobileStealth][refoMobileStealthTarget] = nil
                        oUnit[refoAssignedMobileStealth] = nil
                    end
                elseif oUnit[refoAssignedMobileStealth] then
                    if not(M28UnitInfo.IsUnitValid(oUnit[refoAssignedMobileStealth])) then
                        oUnit[refoAssignedMobileStealth] = nil
                        tLZTeamData[M28Map.refbLZWantsMobileStealth] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording that the land zone '..iLandZone..' wants mobile Stealths as a unit that had a mobile Stealth no longerh as a valid one') end
                    end
                else
                    tLZTeamData[M28Map.refbLZWantsMobileStealth] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording that the land zone '..iLandZone..' wants mobile Stealths as it has a unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that doesnt have an assigned mobile Stealth yet') end
                end
            end
            if iEnemyOmniCoverage > 20 then tLZTeamData[M28Map.refbLZWantsMobileStealth] = false end
        end

        if M28Utilities.IsTableEmpty(tMobileStealths) == false then
            ManageMobileStealthsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tMobileStealths, iEnemyOmniCoverage)
        end

        local iCurDFThreat = 0
        local iCurIndirectThreat = 0
        local iCurMAAThreat = tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]
        local iMinIndirectRangeNeededForThreat = tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] + 1
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] do
                if iRange >= iMinIndirectRangeNeededForThreat then
                    iCurIndirectThreat = iCurIndirectThreat + iThreat
                end
            end
        end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                iCurDFThreat = iCurDFThreat + iThreat
            end
        end


        local bConsiderAdjacentDF = false
        local bConsiderAdjacentIndirect = false
        local bConsiderAdjacentMAA = false
        if bDebugMessages == true then LOG(sFunctionRef..': Setting whether we want to consider indirect threat, iCurIndirectThreat='..(iCurIndirectThreat or 'nil')..'; tLZTeamData[M28Map.subrefLZIndirectThreatWanted]='..(tLZTeamData[M28Map.subrefLZIndirectThreatWanted] or 'nil')) end
        if iCurIndirectThreat < tLZTeamData[M28Map.subrefLZIndirectThreatWanted] then bConsiderAdjacentIndirect = true end
        if iCurDFThreat < tLZTeamData[M28Map.subrefLZDFThreatWanted] then bConsiderAdjacentDF = true end
        if iCurMAAThreat < tLZTeamData[M28Map.subrefLZMAAThreatWanted] and tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then bConsiderAdjacentMAA = true end




        --Add adjacent combat units if the land zone is lower priority than us and the adjacent LZ doesnt have DF units of a significant threat in it
        local iCurUnitThreat
        if bDebugMessages == true then LOG(sFunctionRef..': Will consider including adjacent combat units for LZ '..iLandZone..' with iCurLZValue='..iCurLZValue..'; is table of adjacent LZs empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]))..'; bConsiderAdjacentIndirect='..tostring(bConsiderAdjacentIndirect)..'; bConsiderAdjacentDF='..tostring(bConsiderAdjacentDF)) end
        local bConsiderGivingOrdersToUnits
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                local tAltLZTeam = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; Base LZ='..iLandZone..'; iAdjLZ='..iAdjLZ..'; LZTValue='..repru(tAltLZTeam[M28Map.subrefLZTValue])..'; Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tAltLZTeam[M28Map.subreftoLZOrWZAlliedUnits]))) end
                if not(bLandZoneOrAdjHasUnitsWantingScout) and M28Utilities.IsTableEmpty(tAltLZTeam[M28Map.subrefLZTAlliedCombatUnits]) == false then bLandZoneOrAdjHasUnitsWantingScout = true end
                --if (bConsiderAdjacentIndirect or bConsiderAdjacentDF) then
                bConsiderGivingOrdersToUnits = false
                if tAltLZTeam[M28Map.subrefLZTValue] < iCurLZValue and tAltLZTeam[M28Map.subrefLZThreatEnemyMobileDFTotal] <= 50 then bConsiderGivingOrdersToUnits = true end-- and M28Utilities.IsTableEmpty(tAltLZTeam[M28Map.subrefLZTAlliedCombatUnits]) == false then
                if M28Utilities.IsTableEmpty(tAltLZTeam[M28Map.subrefLZTAlliedCombatUnits]) == false then
                    for iUnit, oUnit in tAltLZTeam[M28Map.subrefLZTAlliedCombatUnits] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to add adjacent oUnit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' with cur assignment value '..(oUnit[refiCurrentAssignmentValue] or 0)..' and cur assignemnt LZ='..(oUnit[refiCurrentAssignmentPlateauAndLZ][2] or 'nil')) end
                        if not(oUnit.Dead) and ((oUnit[refiCurrentAssignmentValue] or 0) < iCurLZValue or (oUnit[refiCurrentAssignmentPlateauAndLZ][1] == iPlateau and oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone)) then
                            --Combat unit related
                            if not(bConsiderGivingOrdersToUnits) then
                                if oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone then
                                    oUnit[refiCurrentAssignmentValue] = -1
                                end
                            else
                                if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and not(bConsiderAdjacentDF) and oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone then
                                    oUnit[refiCurrentAssignmentValue] = -1
                                elseif (oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0 and not(bConsiderAdjacentIndirect) and oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone then
                                    oUnit[refiCurrentAssignmentValue] = -1
                                elseif (bConsiderAdjacentDF and oUnit[M28UnitInfo.refiDFRange] > 0) or (bConsiderAdjacentIndirect and oUnit[M28UnitInfo.refiIndirectRange] > 0) then
                                    bHaveCombatUnitsFromAdjZone = true
                                    table.insert(tAvailableCombatUnits, oUnit)
                                    iAvailableCombatCount = iAvailableCombatCount + 1
                                    RecordUnitAsReceivingLandZoneAssignment(oUnit, iPlateau, iLandZone, iCurLZValue)

                                    iCurUnitThreat = nil
                                    if oUnit[M28UnitInfo.refiDFRange] > 0 then
                                        if oUnit[M28UnitInfo.refiDFRange] > iOurBestDFRange and not(EntityCategoryContains(M28UnitInfo.refCategoryAbsolver, oUnit.UnitId)) then iOurBestDFRange = oUnit[M28UnitInfo.refiDFRange] end
                                        iCurUnitThreat = M28UnitInfo.GetCombatThreatRating({ oUnit })
                                        iCurDFThreat = iCurDFThreat + iCurUnitThreat
                                        if iCurDFThreat > tLZTeamData[M28Map.subrefLZDFThreatWanted] then
                                            bConsiderAdjacentDF = false
                                            --if not(bConsiderAdjacentIndirect) and not(bConsiderAdjacentMAA) then break end
                                        end
                                    end
                                    if oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                                        if oUnit[M28UnitInfo.refiIndirectRange] > iOurBestIndirectRange then iOurBestIndirectRange = oUnit[M28UnitInfo.refiIndirectRange] end
                                        if oUnit[M28UnitInfo.refiIndirectRange] > iMinIndirectRangeNeededForThreat then
                                            if not(iCurUnitThreat) then iCurUnitThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }) end
                                            iCurIndirectThreat = iCurIndirectThreat + iCurUnitThreat
                                            if iCurIndirectThreat > tLZTeamData[M28Map.subrefLZIndirectThreatWanted] then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Just increased our indirect threat for oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurUnitThreat='..iCurUnitThreat..'; iCurIndirectThreat after increase='..iCurIndirectThreat..'; tLZTeamData[M28Map.subrefLZIndirectThreatWanted]='..(tLZTeamData[M28Map.subrefLZIndirectThreatWanted] or 'nil')) end
                                                bConsiderAdjacentIndirect = false
                                                --if not(bConsiderAdjacentDF) and not(bConsiderAdjacentMAA) then break end
                                            end
                                        end
                                    end
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId) then
                                    if bConsiderAdjacentMAA then
                                        table.insert(tAvailableMAA, oUnit)
                                        RecordUnitAsReceivingLandZoneAssignment(oUnit, iPlateau, iLandZone, iCurLZValue)

                                        iCurUnitThreat = M28UnitInfo.GetAirThreatLevel({ oUnit }, false, false, true)
                                        iCurMAAThreat = iCurMAAThreat + iCurUnitThreat
                                        if iCurMAAThreat > tLZTeamData[M28Map.subrefLZMAAThreatWanted] then
                                            bConsiderAdjacentMAA = false
                                            --if not(bConsiderAdjacentIndirect) and not(bConsiderAdjacentDF) then break end
                                        end
                                    elseif oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone then
                                        oUnit[refiCurrentAssignmentValue] = -1
                                    end
                                end
                            end
                        end
                    end
                end
                --if not(bConsiderAdjacentDF) and not(bConsiderAdjacentIndirect) and not(bConsiderAdjacentMAA) then break end
            end
            --end
        end

        if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
            if tLZData[M28Map.subrefbPacifistArea] then
                RetreatOtherUnits(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableCombatUnits)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': About to manage combat units in the LZ, iOurBestIndirectRange='..(iOurBestIndirectRange or 'nil')..'; bConsiderAdjacentIndirect='..tostring(bConsiderAdjacentIndirect or false)..'; iAvailableCombatCount='..iAvailableCombatCount) end
                --ManageCombatUnitsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableCombatUnits, iFriendlyBestMobileDFRange, iFriendlyBestMobileIndirectRange, bWantIndirectReinforcements, tUnavailableUnitsInThisLZ, bDelayOrdersForHover, bHaveCombatUnitsFromAdjZone)
                ManageCombatUnitsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableCombatUnits, iOurBestDFRange, iOurBestIndirectRange, bConsiderAdjacentIndirect, tUnavailableUnitsInThisLZ, iAvailableCombatCount >= 30, bHaveCombatUnitsFromAdjZone)
                bUpdateEnemyDataHere = false
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of MAA empty='..tostring(M28Utilities.IsTableEmpty(tAvailableMAA))..'; Is table of entity filtered dow nto MAA empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMAA, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))) end
        if M28Utilities.IsTableEmpty(tAvailableMAA) == false then
            if tLZData[M28Map.subrefbPacifistArea] then
                RetreatOtherUnits(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableMAA)
            else
                ManageMAAInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableMAA)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Will retreat other units if any, is table empty='..tostring(M28Utilities.IsTableEmpty(tOtherUnitsToRetreat))) end
        if M28Utilities.IsTableEmpty(tOtherUnitsToRetreat) == false then
            RetreatOtherUnits(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tOtherUnitsToRetreat)
        end
        if M28Utilities.IsTableEmpty(tSACUs) == false then
            ManageRASSACUsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tSACUs)
        end

        if M28Utilities.IsTableEmpty(tTempOtherUnits) == false then
            --If have temp other units then manage these
            local tNearestWZ
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                    local iNearestWZRef = tSubtable[M28Map.subrefAWZRef]
                    tNearestWZ = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iNearestWZRef]][M28Map.subrefPondWaterZones][iNearestWZRef][M28Map.subrefMidpoint]
                    break
                end
            end
            for iUnit, oUnit in tTempOtherUnits do
                M28Orders.UpdateRecordedOrders(oUnit)
                if oUnit[M28Orders.refiOrderCount] == 0 then
                    --Is this a naval unit?
                    if EntityCategoryContains(M28UnitInfo.refCategoryAllNavy, oUnit.UnitId) then
                        if not(tNearestWZ) then
                            M28Utilities.ErrorHandler('Have naval unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' in land zone with no orders and no adjacent WZ, will move randomly')

                            local tRandomTarget = oUnit:GetPosition()
                            local iRandX = math.random(10, 30)
                            if math.random(0,1) == 0 then iRandX = iRandX * -1 end
                            local iRandZ = math.random(10, 30)
                            if math.random(0,1) == 0 then iRandZ = iRandZ * -1 end
                            tRandomTarget[1] = tRandomTarget[1] + iRandX
                            tRandomTarget[3] = tRandomTarget[3] + iRandZ
                            tRandomTarget[2] = GetSurfaceHeight(tRandomTarget[1], tRandomTarget[3])

                            M28Orders.IssueTrackedMove(oUnit, tRandomTarget, 5, false, 'RandNM', false)
                        else
                            M28Orders.IssueTrackedMove(oUnit, tNearestWZ, 5, false, 'NavInLZBckup', false)
                        end
                    else
                        M28Utilities.ErrorHandler('Have non naval unit with no orders that is of an unrecognised category in LZ, Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; will move randomly')
                        local tRandomTarget = oUnit:GetPosition()
                        local iRandX = math.random(10, 30)
                        if math.random(0,1) == 0 then iRandX = iRandX * -1 end
                        local iRandZ = math.random(10, 30)
                        if math.random(0,1) == 0 then iRandZ = iRandZ * -1 end
                        tRandomTarget[1] = tRandomTarget[1] + iRandX
                        tRandomTarget[3] = tRandomTarget[3] + iRandZ
                        tRandomTarget[2] = GetSurfaceHeight(tRandomTarget[1], tRandomTarget[3])
                        M28Orders.IssueTrackedMove(oUnit, tRandomTarget, 5, false, 'RandLM', false)
                    end
                end
            end
        end
    else
        --No allied units - if this was flagged as an expansion LZ then clear the flag
        if tLZTeamData[M28Map.subrefLZCoreExpansion] then tLZTeamData[M28Map.subrefLZCoreExpansion] = nil end
    end
    --Update enemy ranges for this LZ and decide if this LZ still wants support, if we havent run our main combat management logic
    if bDebugMessages == true then LOG(sFunctionRef..': Will update enemy data for this LZ if are enemies in this LZ. bUpdateEnemyDataHere='..tostring(bUpdateEnemyDataHere or false)) end
    if bUpdateEnemyDataHere then
        UpdateBestEnemyRangesForThisLandZone(tLZData, tLZTeamData, iPlateau, iTeam)
        RecordClosestAdjacentEnemiesAndGetBestEnemyRange(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
        if bDebugMessages == true then LOG(sFunctionRef..': Updating if we want more DF or indirect units for this LZ, tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or false)..'; tLZTeamData[M28Map.subrefLZTValue]='..(tLZTeamData[M28Map.subrefLZTValue] or 'nil')..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal]='..tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal]) end
        local bWantDFSupport = false
        function UpdateDFSupportForEarlyGameEngineers()
            if not(bWantDFSupport) and GetGameTimeSeconds() <= 360 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefMexUnbuiltLocations]) == false and M28Utilities.IsTableEmpty(tEngineers) == false and M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) < M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZTeamData[M28Map.reftClosestFriendlyBase]) * 0.9 then
                bWantDFSupport = true
            end
        end
        if (tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and tLZTeamData[M28Map.subrefLZTValue] >= 200) or tLZData[M28Map.subrefbPacifistArea] then
            local bWantIndirectSupport = false
            if not(tLZData[M28Map.subrefbPacifistArea]) then
                if tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] > 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy has a structure with a DF range so want indirect fire support') end
                    bWantIndirectSupport = true
                end
                if tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] > 0 or tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] > 0 then bWantDFSupport = true end
                --If havent flagged for any support but enemy has units in this LZ (presumably non-combat) and we have no combat units, then flag for support
                if not(bWantIndirectSupport) and not(bWantDFSupport) and tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] == 0 and tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] == 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.MOBILE * categories.LAND, tLZTeamData[M28Map.subrefTEnemyUnits])) == false then
                        bWantDFSupport = true
                    elseif M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.STRUCTURE, tLZTeamData[M28Map.subrefTEnemyUnits])) == false then
                        if bDebugMessages == true then
                            local tEnemyBuildings = EntityCategoryFilterDown(categories.STRUCTURE, tLZTeamData[M28Map.subrefTEnemyUnits])
                            for iBuilding, oBuilding in tEnemyBuildings do
                                LOG(sFunctionRef..': Flagging we want indirect due to enemy having buildings in this zone, enemy building iBuilding='..iBuilding..'; oBuilding='..oBuilding.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBuilding))
                            end
                        end
                        bWantIndirectSupport = true
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': bWantIndirectSupport after initial checks based on enemy units in the zone='..tostring(bWantIndirectSupport)) end
                --If enemy has PD in this or adjacent zone then flag we want indirect support
                if not(bWantIndirectSupport) then
                    if bDebugMessages == true then LOG(sFunctionRef..': We wouldnt normally want indirect fire support for this zone, but if MML have been firing near TMD or shield then will flag we want indirect support, time since last firing near TMD or shield='..GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -100)) end
                    if GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -100) <= 30 then bWantIndirectSupport = true end
                    if not(bWantIndirectSupport) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Not fired near TMD recently, checking we dont have too much IF in the zone before considering adjacent zone PD, tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='.. tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]) end
                        if tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] <= math.min(2000 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech], tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] * 3) then
                            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                local iAdjacentMobileDFThreat = 0
                                local iAdjacentPDOrStructureThreat = 0
                                for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                    local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                    iAdjacentMobileDFThreat = iAdjacentMobileDFThreat + (tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)
                                    if tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] > 0 then
                                        iAdjacentPDOrStructureThreat = iAdjacentPDOrStructureThreat + math.max((tAltLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0), tAltLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy has a DF building in an adjacent zone so want IF support, iAdjacentMobileDFThreat cumulative='..iAdjacentMobileDFThreat..'; Enemy PD threat='..tAltLZTeamData[M28Map.subrefThreatEnemyDFStructures]..'; iAdjacentPDOrStructureThreat='..iAdjacentPDOrStructureThreat..'; Enemy structure mass='..tAltLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]) end
                                        if iAdjacentMobileDFThreat >= 1000 and iAdjacentMobileDFThreat >= iAdjacentPDOrStructureThreat * 4 then
                                            --Dont build indirect fire just because of the PD Threat
                                        else
                                            bWantIndirectSupport = true break
                                        end
                                    end
                                end
                                if iAdjacentPDOrStructureThreat > 0 and iAdjacentPDOrStructureThreat > iAdjacentMobileDFThreat / 4 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Overall we want indirect fire due to level of PD threat') end
                                    bWantIndirectSupport = true
                                end
                            end
                        end
                        if not(bWantIndirectSupport) then
                            if tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] then
                                for iEntry, tPlateauAndZone in tLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                                    local tAdjLZTeamData = M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam]
                                    if tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] > 0 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy has a nearby firebase type zone so want IF support') end
                                        bWantIndirectSupport = true break
                                    end
                                end
                            end
                        end
                    end
                end

                --Early game - flag that we want support if we have engineers and unclaimed mexes
                UpdateDFSupportForEarlyGameEngineers()
            end
            UpdateIfLandZoneWantsSupport(tLZTeamData, iPlateau, iLandZone, iTeam, bWantDFSupport, bWantIndirectSupport)
            if bDebugMessages == true then LOG(sFunctionRef..': Will update if this land zone wants some DF support='..tostring(bWantDFSupport)..'; bWantIndirectSupport='..tostring(bWantIndirectSupport)) end
        else
            local bWantIndirectSupport = false
            if bDebugMessages == true then LOG(sFunctionRef..': Are there enemis in this or adjacent LZ, for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Do we have a valid nearby structure in other plateau='..tostring( M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]))..'; Our highest land tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]..'; bWantDFSupport='..tostring(bWantDFSupport)) end
            if GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -100) <= 30 and not(tLZData[M28Map.subrefbPacifistArea]) then
                if bDebugMessages == true then LOG(sFunctionRef..': Have had MML firing recently near TMD so want more indirect fire support') end
                bWantIndirectSupport = true
            elseif not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and not(bWantIndirectSupport) and M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.refoNearestStructureInOtherPlateauIfNoEnemiesHere]) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3 then
                bWantIndirectSupport = M28Conditions.IsNearbyStructureThatWeCanReachWithIndirect(tLZData, tLZTeamData, iTeam)
                if bDebugMessages == true then LOG(sFunctionRef..': bWantIndirectSupport after checking if nearby structure we can reach with indirect='..tostring(bWantIndirectSupport)) end
            end
            UpdateDFSupportForEarlyGameEngineers()
            UpdateIfLandZoneWantsSupport(tLZTeamData, iPlateau, iLandZone, iTeam, bWantDFSupport, bWantIndirectSupport)
        end
    end
    --Handle engineers and even if no engineers still decide what engineers we would want for hte LZ
    M28Engineer.ConsiderLandOrWaterZoneEngineerAssignment(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tEngineers) --Should update the land zone engineer requirements, even if tEngineers itself is empty

    ManageLandZoneScouts(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tScouts, bLandZoneOrAdjHasUnitsWantingScout)


    --Update visual based on omni
    if tLZTeamData[M28Map.refiOmniCoverage] > 30 then tLZTeamData[M28Map.refiTimeLastHadVisual] = GetGameTimeSeconds() end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Is unbuild locations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]))) end

    --Update BP wanted for adjacent zones - will just have a flag in the engineer assignment that sets subrefTbWantBP to true/false so commented out the below
    --[[tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted] = {[1]=0, [2]=0,[3]=0}
    tLZTeamData[M28Map.subrefTbWantBP] = false
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[M28Map.iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjLZ in M28Map.tAllPlateaus[M28Map.iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones] do
            for iTech = 1, 3, 1 do
                tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted] = math.max(tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted][iTech], (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][iTech] or 0))
            end
        end
    end
    for iTech = 1, 3, 1 do
        if tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted][iTech] > 0 or tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted][iTech] > 0 then
            tLZTeamData[M28Map.subrefTbWantBP] = true
        end
    end--]]
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AssignValuesToLandZones(iTeam)
    --Periodically cycles through every land zone and refreshes the unit details
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignValuesToLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
    if aiBrain then

        if bDebugMessages == true then
            LOG(sFunctionRef..': About to start the main loop for assigning values to land zones provided we have friendly M28 brains in the team '..iTeam..'; is table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))..'; will list out the plateau and LZ for each member of the team')
            local iStartPlateau, iStartLZ
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                iStartPlateau, iStartLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                LOG(sFunctionRef..': Brain '..oBrain.Nickname..' has start position '..repru(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])..' with iStartPlateau='..(iStartPlateau or 'nil')..' and iStartLZ='..(iStartLZ or 'nil'))
            end
        end
        local iCurValue
        local tFriendlyNonPDBuildings
        local bAdjacentToCoreFactory
        local iFriendlyBuildingValue
        local iCurCycleCount = 0
        local iZonesSinceWait = 0
        local iTotalLandZones = 0
        for iPlateau, tPlateauData in M28Map.tAllPlateaus do
            iTotalLandZones = iTotalLandZones + (tPlateauData[M28Map.subrefLandZoneCount] or 0)
        end
        local iZonesPerTick = math.max(1, math.floor(iTotalLandZones / 20))
        while M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false do
            iCurCycleCount = iCurCycleCount + 1 --used so we dont wait the first time, so we have recorded which zones are core zones
            local tiPlateauAndLZWithFriendlyStartPosition = {}
            local iBaseCategory
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                if iPlateau and iLandZone then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iBrain='..iBrain..'; oBrain='..oBrain.Nickname..'; Army index='..oBrain:GetArmyIndex()..'; Player start point='..repru(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])..'; Plateau and LZ of this start point='..iPlateau..'-'..iLandZone) end
                    if not(tiPlateauAndLZWithFriendlyStartPosition[iPlateau]) then tiPlateauAndLZWithFriendlyStartPosition[iPlateau] = {} end
                    if (iLandZone or 0) > 0 then
                        tiPlateauAndLZWithFriendlyStartPosition[iPlateau][iLandZone] = true
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished recording the friendly start positions for each brain, tiPlateauAndLZWithFriendlyStartPosition='..repru(tiPlateauAndLZWithFriendlyStartPosition)) end
            iBaseCategory = categories.TECH3 * M28UnitInfo.refCategoryAllHQFactories + M28UnitInfo.refCategoryAirHQ * categories.TECH2
            --[[if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then iBaseCategory = categories.TECH3 * M28UnitInfo.refCategoryAllHQFactories + M28UnitInfo.refCategoryAirHQ * categories.TECH2
            elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 then iBaseCategory = M28UnitInfo.refCategoryAllHQFactories - categories.TECH1
            else iBaseCategory = M28UnitInfo.refCategoryAirFactory --Dont want to include t1 land facs since might be in a minor zone
            end--]]

            for iPlateau, tPlateauData in M28Map.tAllPlateaus do
                if M28Utilities.IsTableEmpty(tPlateauData[M28Map.subrefPlateauLandZones]) == false then

                    --tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
                    for iLandZone, tLandZoneData in tPlateauData[M28Map.subrefPlateauLandZones] do
                        iZonesSinceWait = iZonesSinceWait + 1
                        local tLZTeamData = tLandZoneData[M28Map.subrefLZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': About to refresh value of iPlateau='..iPlateau..'; iLandZone='..iLandZone..' for team '..iTeam) end
                        --Decide on value of the land zone ignoring distance:
                        --Treat each mex position as being worth 250 mass, value reclaim at 25% of the total value, and reflect the value of all non-PD in the area
                        iCurValue = tLandZoneData[M28Map.subrefLZMexCount] * 250 + (tLandZoneData[M28Map.subrefTotalMassReclaim] or 0) * 0.25
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                            tFriendlyNonPDBuildings = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryPD, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                            iFriendlyBuildingValue = M28UnitInfo.GetMassCostOfUnits(tFriendlyNonPDBuildings)
                            iCurValue = iCurValue + iFriendlyBuildingValue
                        else
                            iFriendlyBuildingValue = 0
                        end

                        if tLZTeamData[M28Map.refbACUInTrouble] then
                            iCurValue = iCurValue + M28ACU.GetValueIncreaseForACUInTrouble(iTeam)
                        end

                        --Record the value
                        tLZTeamData[M28Map.subrefLZTValue] = iCurValue
                        tLZTeamData[M28Map.subrefLZSValue] = iFriendlyBuildingValue
                        tLZTeamData[M28Map.subrefLZbCoreBase] = nil

                        --Is this a core base land zone?
                        if bDebugMessages == true then LOG(sFunctionRef..': iCurValue based on this zone='..iCurValue..'; iFriendlyBuildingValue='..iFriendlyBuildingValue..'; Checking if we are a friendly land zone - tiPlateauAndLZWithFriendlyStartPosition='..repru(tiPlateauAndLZWithFriendlyStartPosition)..'; Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
                        if tiPlateauAndLZWithFriendlyStartPosition[iPlateau][iLandZone] or tLZTeamData[M28Map.subrefbCoreBaseOverride] then
                            tLZTeamData[M28Map.subrefLZbCoreBase] = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Core LZ='..iLandZone..' for plateau '..iPlateau..'; All adjacent zones='..repru(tLandZoneData[M28Map.subrefLZAdjacentLandZones])..'; tiPlateauAndLZWithFriendlyStartPosition[iPlateau][iLandZone]=nil='..tostring(tiPlateauAndLZWithFriendlyStartPosition[iPlateau][iLandZone] == nil)..'; tLZTeamData[M28Map.subrefbCoreBaseOverride]='..tostring(tLZTeamData[M28Map.subrefbCoreBaseOverride] or false)..'; Island ref='..(tLandZoneData[M28Map.subrefLZIslandRef] or 'nil')) end
                            if not(M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iPlateau]) then
                                if not(M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau]) then M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau] = {} end
                                M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iPlateau] = {}
                            end
                            M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iPlateau][iLandZone] = true
                            --adjacent zones iwth lots of mexes in them and high mex count - consider treating as a core base
                        elseif tLandZoneData[M28Map.subrefLZMexCount] >= 4 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                            --Are we adjacent to a core zone and we contain a factory or high value unit? If so then treat us as a core LZ
                            bAdjacentToCoreFactory = false
                            if M28Utilities.IsTableEmpty(tLandZoneData[M28Map.subrefLZAdjacentLandZones]) == false then
                                for iEntry, iAdjLZ in tLandZoneData[M28Map.subrefLZAdjacentLandZones] do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we are adjacent to a core LZ, iAdjLZ='..iAdjLZ..'; Is AdjLZ a core LZ='..tostring(tPlateauData[M28Map.subrefPlateauLandZones][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase])) end
                                    if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] then
                                        bAdjacentToCoreFactory = true
                                        break
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': bAdjacentToCoreFactory='..tostring(bAdjacentToCoreFactory)..'; Is table of factory HQs empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(iBaseCategory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))) end
                                if bAdjacentToCoreFactory and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(iBaseCategory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Are adjacent to a core factory, and have iBaseCategory units in this zone, iLandZone='..iLandZone..'; iPlateau='..iPlateau) end
                                    tLZTeamData[M28Map.subrefLZbCoreBase] = true
                                    if not(M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iPlateau]) then
                                        if not(M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau]) then M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau] = {} end
                                        M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iPlateau] = {}
                                    end
                                    M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iPlateau][iLandZone] = true
                                end
                            end

                        end

                        if iZonesSinceWait >= iZonesPerTick and iCurCycleCount > 1 then --dont want to wait the first time, as on large maps can mean a delay in the ACU building
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitTicks(1)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                            iZonesSinceWait = 0
                        end
                    end
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1) --Needed to avoid infinite loop if are no LZs (e.g. on a water map)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    else
        M28Utilities.ErrorHandler('No active M28 brain')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageAllLandZones(aiBrain, iTeam, bIgnoreMinorPlateaus, iCurMinorPlateauCycleRef)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageAllLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iLastRefreshCount = (tLZRefreshCountByTeam[iTeam] or 1)
    local iCurRefreshCount = 0
    local iTicksToSpreadOver = iTicksPerLandCycle --Default is 10, i.e. 1 second
    local iRefreshThreshold = math.max(2, math.ceil(iLastRefreshCount * 0.95 / iTicksToSpreadOver))
    local iCurCycleRefreshCount = 0
    local iCurTicksWaited = 0

    if bDebugMessages == true then
        LOG(sFunctionRef..': Start of code, Time='..GetGameTimeSeconds()..'; iTeam='..iTeam..'; If have an ACU will list its plateau and land zone. iRefreshThreshold='..iRefreshThreshold..'; iLastRefreshCount='..iLastRefreshCount..'; iTicksToSpreadOver='..iTicksToSpreadOver)
        local tOurACU = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
        if M28Utilities.IsTableEmpty(tOurACU) == false then
            local iACUPlateau, iACULZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tOurACU[1]:GetPosition(), true, tOurACU[1])
            LOG(sFunctionRef..': ACU is at plateau '..iACUPlateau..'; LZ='..iACULZ)
        end
    end

    --Cycle through land zones
    local bAlwaysUpdateEnemyAirUnitPositions = M28Map.bIsCampaignMap --campaign map players are more likely to know when air attacks iwll attack and from where
    for iPlateau, tPlateauData in M28Map.tAllPlateaus do
        if bIgnoreMinorPlateaus or not(tPlateauData[M28Map.subrefiMinorCycleRef]) or tPlateauData[M28Map.subrefiMinorCycleRef] == iCurMinorPlateauCycleRef then
            RefreshLandRallyPoints(iTeam, iPlateau)

            if M28Utilities.IsTableEmpty(tPlateauData[M28Map.subrefPlateauLandZones]) == false then
                if bDebugMessages == true then
                    LOG(sFunctionRef..': About to cycle through every land zone in plateau '..iPlateau..'; subrefLandZoneCount='..tPlateauData[M28Map.subrefLandZoneCount])
                end
                for iLandZone, tLandZoneDataByTeam in tPlateauData[M28Map.subrefPlateauLandZones] do
                    local tLZTeamData = tLandZoneDataByTeam[M28Map.subrefLZTeamData][iTeam]

                    if bDebugMessages == true then
                        LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Is table of enemey units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))..'; Is table of friendly units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))..'; GameTime='..GetGameTimeSeconds()..'; Is table of enemy air units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]))..'; iTeam='..iTeam)
                    end
                    --First check all units in here are alive
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                        iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                        --UpdateUnitPositionsAndLandZone(aiBrain, tUnits,                               iTeam, iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
                        UpdateUnitPositionsAndLandZone(aiBrain, tLZTeamData[M28Map.subrefTEnemyUnits], iTeam, iPlateau,             iLandZone,          M28Map.bIsCampaignMap, false, tLZTeamData,  false,                      true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Just ran updateunitpositions for enemy units in this zone') end
                    end
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) == false then
                        iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                        --Update air positions if we have units in the zone or has been a while to approximate a player being able to tell if enemy air force is still there
                        if bAlwaysUpdateEnemyAirUnitPositions or (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false or GetGameTimeSeconds() - (tLZTeamData[M28Map.refiTimeOfLastAirUpdate] or -100) >= 12 or (M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.reftLZEnemyAirUnits][1]) and M28UnitInfo.CanSeeUnit(aiBrain, tLZTeamData[M28Map.reftLZEnemyAirUnits][1])) or (tLZTeamData[M28Map.refiRadarCoverage] or 0) > 0) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Updating air unit positions in the zone') end
                            tLZTeamData[M28Map.refiTimeOfLastAirUpdate] = GetGameTimeSeconds()
                            --UpdateUnitPositionsAndLandZone(aiBrain, tUnits,                       iTeam, iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
                            UpdateUnitPositionsAndLandZone(aiBrain, tLZTeamData[M28Map.reftLZEnemyAirUnits], iTeam, iPlateau, iLandZone, false, true, tLZTeamData, false,                               true)
                        else
                            --UpdateUnitPositionsAndLandZone(aiBrain, tUnits,                           iTeam, iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
                            UpdateUnitPositionsAndLandZone(aiBrain, tLZTeamData[M28Map.reftLZEnemyAirUnits], iTeam, iPlateau, iLandZone,        M28Map.bIsCampaignMap, true, tLZTeamData,   false,                                  true)
                        end
                    end
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                        iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                        UpdateUnitPositionsAndLandZone(aiBrain, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits], iTeam, iPlateau, iLandZone, false, false, tLZTeamData)
                    end

                    ForkThread(ManageSpecificLandZone, aiBrain, iTeam, iPlateau, iLandZone)
                    iCurCycleRefreshCount = iCurCycleRefreshCount + 1

                    if iCurCycleRefreshCount >= iRefreshThreshold then
                        iCurRefreshCount = iCurRefreshCount + iCurCycleRefreshCount
                        iCurCycleRefreshCount = 0
                        if iCurTicksWaited < iTicksToSpreadOver then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitTicks(1)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                            iCurTicksWaited = iCurTicksWaited + 1
                            if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting 1 tick as reached iCurCycleRefreshCount='..iCurCycleRefreshCount) end
                        end
                    end
                end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Warning - no land zones found for plateau '..iPlateau) end
            end
        end
    end
    iCurRefreshCount = iCurRefreshCount + iCurCycleRefreshCount
    if bDebugMessages == true then LOG(sFunctionRef..': About to update refresh count now that completed loop, iCurRefreshCount='..(iCurRefreshCount or 'nil')..'; tLZRefreshCountByTeam[iTeam] before updating to reflect this='..(tLZRefreshCountByTeam[iTeam] or 'nil')) end
    tLZRefreshCountByTeam[iTeam] = iCurRefreshCount

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function LandZoneOverseer(iTeam)
    --Periodically cycles through every land zone and refreshes the unit details
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'LandZoneOverseer'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
    if aiBrain then
        if aiBrain.HostileCampaignAI and tonumber(ScenarioInfo.Options.CmpAIDelay) > GetGameTimeSeconds() + 1.1 then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(tonumber(ScenarioInfo.Options.CmpAIDelay) - GetGameTimeSeconds() -1.1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end

        if bDebugMessages == true then LOG(sFunctionRef..': About to start the main loop for land zones provided we have friendly M28 brains in the team '..iTeam..'; is table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end
        ForkThread(AssignValuesToLandZones, iTeam)

        local iWaitCount = 0
        while not(M28Map.bMapLandSetupComplete) or GetGameTimeSeconds() <= 4 or ((M28Utilities.bLoudModActive or M28Utilities.bSteamActive) and GetGameTimeSeconds() <= 6) do
            iWaitCount = iWaitCount + 1
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if iWaitCount >= 200 then M28Utilities.ErrorHandler('Have waited more than '..iWaitCount..' and map setup not complete, will proceed but likely AI wont work') break end
        end

        local iMinorCycleCount = 0
        while M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false do
            if ScenarioInfo.OpEnded and M28Map.bIsCampaignMap and GetGameTimeSeconds() <= 120 then
                while ScenarioInfo.OpEnded do
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(1)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                end
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) then break end
            end
            iMinorCycleCount = iMinorCycleCount + 1
            if iMinorCycleCount > 10 then iMinorCycleCount = 1 end
            if bDebugMessages == true then LOG(sFunctionRef..': Will call logic to refresh every unit in a land zone, iMinorCycleCount='..iMinorCycleCount) end
            ForkThread(ManageAllLandZones, aiBrain, iTeam, (GetGameTimeSeconds() <= 10 or M28Map.iPlateauCount <= 2000), iMinorCycleCount)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(iTicksPerLandCycle)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if aiBrain.M28IsDefeated and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': About to restart the loop for team '..iTeam..'; aiBrain referred to='..(aiBrain.Nickname or 'nil')..'; Is table of active m28 brains='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetLandZoneToRunTo(iTeam, iPlateau, iCurLandZone, sPathing, tOptionalStartPosition, tOptionalEnemyPositionToRunFrom)
    --Returns cur LZ if no LZ to run to, otherwise returns the land zone we think is best to run to from iCurLandZone
    --tOptionalStartPosition - if nil then will use midpoint of iCurLandZone
    --tOptionalEnemyPositionToRunFrom - if this is specified, then will pick al ocation based on angle from the start position to the location vs the start position angle to the enemy position to run to (so we run in the opposite direction to the enemy position if the opposite direction LZ is safe)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetLandZoneToRunTo'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': iTeam='..iTeam..'; iPlateau='..iPlateau..'; iCurLandZone='..iCurLandZone..'; sPathing='..sPathing..'; tOptionalStartPosition='..repru(tOptionalStartPosition)..'; tOptionalEnemyPositionToRunFrom='..repru(tOptionalEnemyPositionToRunFrom)) end

    local tLZShortlist = {}
    --See if we have any adjacent LZs with no enemy combat units in them - if so, then run here
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjacentLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefLZAdjacentLandZones] do
            if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjacentLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] == 0 then
                table.insert(tLZShortlist, iAdjacentLZ)
            end
        end
    end
    if M28Utilities.IsTableEmpty(tLZShortlist) then
        --Add each team start point on the same plateau
        local iPotentialPlateau, iPotentialLZ
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                iPotentialPlateau, iPotentialLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                if iPotentialPlateau == iPlateau and not(iPotentialLZ == iCurLandZone) then
                    table.insert(tLZShortlist, iPotentialLZ)
                end
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Getting LZ to run to from, iTeam='..iTeam..'; iPlateau='..iPlateau..'; iCurLandZone='..iCurLandZone..'; sPathing='..sPathing..'; tLZShortlist='..repru(tLZShortlist)) end
    if M28Utilities.IsTableEmpty(tLZShortlist) then
        --Nowhere to run to
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return iCurLandZone
    else
        local tStartPoint = (tOptionalStartPosition or M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefMidpoint])
        local iPreferredLZRef
        if tOptionalEnemyPositionToRunFrom then
            --Go to the angle furthest in angle away from the nearest enemy
            local iAngleToEnemy = M28Utilities.GetAngleFromAToB(tStartPoint, tOptionalEnemyPositionToRunFrom)
            local iCurAngleDif
            local iHighestAngleDif = 0
            for _, iPossibleLZ in tLZShortlist do
                iCurAngleDif = M28Utilities.GetAngleDifference(iAngleToEnemy, M28Utilities.GetAngleFromAToB(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefMidpoint]))
                if iCurAngleDif > iHighestAngleDif then
                    iHighestAngleDif = iCurAngleDif
                    iPreferredLZRef = iPossibleLZ
                end
            end
        else
            --dont have angle to nearest enemy so just pick the closest land zone

            local iClosestLZDistance = 100000
            local iClosestLZRef
            local iCurDist
            for _, iPossibleLZ in tLZShortlist do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering distance from tStartPoint to iPossibleLZ '..(iPossibleLZ or 'nil')..'; Midpoint of that LZ='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefMidpoint])..'; iCurDist='..(M28Utilities.GetTravelDistanceBetweenPositions(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefMidpoint], sPathing) or 'nil')) end
                iCurDist = M28Utilities.GetTravelDistanceBetweenPositions(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefMidpoint], sPathing)
                --Backup - if the built in pathfinding doesnt htink we can path there (e.g. we are by a cliff) then use straight line distance
                if not(iCurDist) then iCurDist = M28Utilities.GetDistanceBetweenPositions(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefMidpoint]) + 30 end

                if iCurDist < iClosestLZDistance then
                    iClosestLZDistance = iCurDist
                    iPreferredLZRef = iPossibleLZ
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return iPreferredLZRef
    end
end

function IsLandZonePathSafe(iPlateau, tLZData, iTeam, iPathingRef, bIslandPathing)
    --More performant version of IsItSafeToPathBetweenLandZones, to check if safe to path from the tLZData land zone to the tAltLZ land zone, based on iPathingRef for tLZData
    --bIslandPathing shoudl be true if are trying to path to an island (i.e. that a land unit cant get to), so the correct table references are used
    if bIslandPathing then
        for _, iLandZoneRef in tLZData[M28Map.subrefLZPathingToOtherIslands][iPathingRef][M28Map.subrefIslandLZPath] do
            --Are there any units in this LZ that are dangerous?
            if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZoneRef][iTeam][M28Map.subrefbDangerousEnemiesInThisLZ] then
                return false
            end
        end
    else
        if tLZData[M28Map.subrefLZPathingToOtherLandZones][iPathingRef][M28Map.subrefLZPath] then
            for _, iLandZoneRef in tLZData[M28Map.subrefLZPathingToOtherLandZones][iPathingRef][M28Map.subrefLZPath] do
                --Are there any units in this LZ that are dangerous?
                if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZoneRef][iTeam][M28Map.subrefbDangerousEnemiesInThisLZ] then
                    return false
                end
            end
        end
    end
    return true
end

--Below code should function but when used for engineers took way too long so redid using IsLandZonePathSafe - look to make use of the varaibles recorded for this to come up with a more performant approach to the below if want the below functionality
--[[function IsItSafeToPathBetweenLandZones(iTeam, iPlateau, iStartLandZone, iEndLandZone, sPathing)
    --Returns true if no enemy threats in any of the land zones that will path through (doesnt consider adjacent zones for performance reasons)
        --Only combat threats should be considered
        --WARNING - Very intensive function, use sparingly - in most cases referring to subrefLZPathingToOtherLandZones is better which will record 3 layers of adjacency to the current zone (more for core LZs)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsItSafeToPathBetweenLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tFullPath, iPathSize, iDistance = NavUtils.PathTo((sPathing or 'Land'), M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iStartLandZone][M28Map.subrefMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iEndLandZone][M28Map.subrefMidpoint], nil)
    if M28Utilities.IsTableEmpty(tFullPath) == false then
        local tLZConsidered = {}
        local iCurPlateau, iCurLZ
        for iPath, tPath in tFullPath do
            iCurPlateau, iCurLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tPath)
            if iCurPlateau and iCurLZ then
                if not(tLZConsidered[iCurLZ]) then
                    tLZConsidered[iCurLZ] = true
                    --Are there any units in this LZ that are dangerous?
                    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                        for iUnit, oUnit in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits] do
                            if ((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or (oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0) and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) then
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return false
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return true
end--]]

function DrawReclaimSegmentsInLandZone(iPlateau, iLandZone, bIncludeMassValues)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DrawReclaimSegmentsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local rCurRect
    if bDebugMessages == true then LOG(sFunctionRef..': About to draw reclaim segnemtns for iPlateau '..iPlateau..' iLandZone '..iLandZone..'; Table of reclaim segments='..repru(tLZData[M28Map.subrefReclaimSegments])) end

    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefReclaimSegments]) == false then
        for iCount, tSegmentXZ in tLZData[M28Map.subrefReclaimSegments] do
            rCurRect = M28Utilities.GetRectAroundLocation(M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][M28Map.refReclaimSegmentMidpoint], M28Map.iReclaimSegmentSizeX * 0.5)
            M28Utilities.DrawRectangle(rCurRect)
            if bIncludeMassValues then LOG(sFunctionRef..': Considering segment '..reprs(tSegmentXZ)..'; Total mass reclaim='..M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][M28Map.refReclaimTotalMass]..'; Signif mass reclaim='..M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][M28Map.refReclaimTotalSignificantMass]) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function UpdateRecordedAllPlayerOmni(oRadar, bDestroyed)
    local oBP = oRadar:GetBlueprint()
    local iRadarOmni =  (oBP.Intel.OmniRadius or 0)

    if iRadarOmni > 0 then
        local iMaxZoneDistance = iRadarOmni + 50

        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oRadar:GetPosition())
        if iPlateau and iLandZone then
            local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
            if tLZData then
                function UpdateOmniCoverageForZone(iCurPlateauOrPond, iCurLZOrWZ, bIsWaterZone)
                    local tCurLZOrWZData
                    if bIsWaterZone then
                        tCurLZOrWZData = M28Map.tPondDetails[iCurPlateauOrPond][M28Map.subrefPondWaterZones][iCurLZOrWZ]
                    else tCurLZOrWZData = M28Map.tAllPlateaus[iCurPlateauOrPond][M28Map.subrefPlateauLandZones][iCurLZOrWZ]
                    end

                    --Remove oRadar from the table of omni in this zone
                    if bDestroyed then
                        if M28Utilities.IsTableEmpty(tCurLZOrWZData[M28Map.reftoAllOmniRadar]) == false then
                            --Update the table
                            local iEntryCount = table.getn(tCurLZOrWZData[M28Map.reftoAllOmniRadar])
                            for iCurEntry = iEntryCount, 1, -1 do
                                local oUnit = tCurLZOrWZData[M28Map.reftoAllOmniRadar][iCurEntry]
                                if not(M28UnitInfo.IsUnitValid(oUnit)) or oUnit == oRadar then
                                    table.remove(tCurLZOrWZData[M28Map.reftoAllOmniRadar], iCurEntry)
                                end
                            end
                        end
                    else
                        local bAddToTable = true
                        if not(tCurLZOrWZData[M28Map.reftoAllOmniRadar]) then tCurLZOrWZData[M28Map.reftoAllOmniRadar] = {}
                        else
                            for iUnit, oUnit in tCurLZOrWZData[M28Map.reftoAllOmniRadar] do
                                if oUnit == oRadar then bAddToTable = false break end
                            end
                        end
                        if bAddToTable and iRadarOmni - M28Utilities.GetDistanceBetweenPositions(oRadar:GetPosition(), tCurLZOrWZData[M28Map.subrefMidpoint]) > 0 then
                            table.insert(tCurLZOrWZData[M28Map.reftoAllOmniRadar], oRadar)
                        end
                    end

                    local iBestOmniCoverage = 0
                    if M28Utilities.IsTableEmpty(tCurLZOrWZData[M28Map.reftoAllOmniRadar]) == false then
                        local iCurOmniCoverage
                        for iUnit, oUnit in tCurLZOrWZData[M28Map.reftoAllOmniRadar] do
                            iCurOmniCoverage = (oUnit:GetBlueprint().Intel.OmniRadius or 0)
                            if iCurOmniCoverage > iBestOmniCoverage  then
                                iCurOmniCoverage = math.max(0, iCurOmniCoverage - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tCurLZOrWZData[M28Map.subrefMidpoint]))
                                if iCurOmniCoverage > iBestOmniCoverage then
                                    iBestOmniCoverage = iCurOmniCoverage
                                end
                            end
                        end

                    end
                    tCurLZOrWZData[M28Map.refiAllOmniCoverage] = iBestOmniCoverage
                end

                UpdateOmniCoverageForZone(iPlateau, iLandZone, false)
                M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint])
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                    for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                        if tSubtable[M28Map.subrefiDistance] > iMaxZoneDistance then break end
                        UpdateOmniCoverageForZone(tSubtable[M28Map.subrefiPlateauOrPond], tSubtable[M28Map.subrefiLandOrWaterZoneRef], tSubtable[M28Map.subrefbIsWaterZone])
                    end
                end
            end
        end
    end
end

function UpdateRadarCoverageForDestroyedRadar(oRadar)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateRadarCoverageForDestroyedRadar'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --First update land zones
    if bDebugMessages == true then LOG(sFunctionRef..': oRadar has been destroyed, oRadar='..oRadar.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRadar)..'; Time='..GetGameTimeSeconds()..'; Is table of zones covered by team empty='..tostring(M28Utilities.IsTableEmpty(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam]))) end
    if M28Utilities.IsTableEmpty(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam]) == false then
        for iTeam, tRadarData in oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam] do
            --local aiBrain = oRadar:GetAIBrain()
            --local iTeam = aiBrain.M28Team
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            if aiBrain then
                for iEntry, tiPlateauAndLZ in tRadarData do
                    local tLZData = M28Map.tAllPlateaus[tiPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][tiPlateauAndLZ[2]]
                    if tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar] == oRadar then
                        tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar] = nil
                        tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] = 0
                        tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiOmniCoverage] = 0

                        local tNearbyRadar = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryRadar, tLZData[M28Map.subrefMidpoint], 600, 'Ally')
                        local iCurIntelRange
                        local iBestIntelRange = 0
                        local oBestRadar
                        local iCurDist
                        local oBP
                        local iCurOmniRange
                        local iBestOmniRange = 0
                        if M28Utilities.IsTableEmpty(tNearbyRadar) == false then
                            for iUnit, oUnit in tNearbyRadar do
                                oBP = oUnit:GetBlueprint()
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                iCurIntelRange = (oBP.Intel.RadarRadius or 0) - iCurDist
                                iCurOmniRange = (oBP.Intel.OmniRadius or 0) - iCurDist
                                if iCurIntelRange > iBestIntelRange then
                                    iBestIntelRange = iCurIntelRange
                                    oBestRadar = oUnit
                                end
                                if iCurOmniRange > iBestOmniRange then
                                    iBestOmniRange = iCurOmniRange
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering nearby radar units for P='..tiPlateauAndLZ[1]..'Z'..tiPlateauAndLZ[2]..'; Is table of nearby radar empty='..tostring(M28Utilities.IsTableEmpty(tNearbyRadar))..'; oBestRadar='..(oBestRadar.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBestRadar) or 'nil')) end
                        if oBestRadar then
                            tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar] = oBestRadar
                            tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] = iBestIntelRange
                            tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiOmniCoverage] = iBestOmniRange
                            if not(oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam]) then oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam] = {} end
                            if not(oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam]) then oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam] = {} end
                            table.insert(oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam], {tiPlateauAndLZ[1], tiPlateauAndLZ[2]})
                        end
                    end
                end
            end
        end
    end
    --Then update water zones:
    if M28Utilities.IsTableEmpty(oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam]) == false then
        for iTeam, tRadarData in oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam] do
            --local aiBrain = oRadar:GetAIBrain()
            --local iTeam = aiBrain.M28Team

            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            if aiBrain then
                local iPond
                for iEntry, iWaterZone in tRadarData do
                    iPond = M28Map.tiPondByWaterZone[iWaterZone]
                    local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
                    local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                    if tWZTeamData[M28Map.refoBestRadar] == oRadar then
                        tWZTeamData[M28Map.refoBestRadar] = nil
                        tWZTeamData[M28Map.refiRadarCoverage] = 0
                        tWZTeamData[M28Map.refiOmniCoverage] = 0
                        local tNearbyRadar = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryRadar, tWZData[M28Map.subrefMidpoint], 600, 'Ally')
                        local iCurIntelRange
                        local iBestIntelRange = 0
                        local oBestRadar
                        local iCurDist
                        local oBP
                        local iCurOmniRange
                        local iBestOmniRange = 0
                        if M28Utilities.IsTableEmpty(tNearbyRadar) == false then
                            for iUnit, oUnit in tNearbyRadar do
                                oBP = oUnit:GetBlueprint()
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tWZData[M28Map.subrefMidpoint])
                                iCurIntelRange = (oBP.Intel.RadarRadius or 0) - iCurDist
                                if iCurIntelRange > iBestIntelRange then
                                    iBestIntelRange = iCurIntelRange
                                    oBestRadar = oUnit
                                end
                                iCurOmniRange = (oBP.Intel.OmniRadius or 0) - iCurDist
                                if iCurOmniRange > iBestOmniRange then
                                    iBestOmniRange = iCurOmniRange
                                end
                            end
                        end
                        if oBestRadar then
                            tWZTeamData[M28Map.refoBestRadar] = oBestRadar
                            tWZTeamData[M28Map.refiRadarCoverage] = iBestIntelRange
                            tWZTeamData[M28Map.refiOmniCoverage] = iBestOmniRange
                            if not(oBestRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam]) then oBestRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam] = {} end
                            if not(oBestRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam]) then oBestRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam] = {} end
                            table.insert(oBestRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam], iWaterZone)
                        end
                    end
                end
            end
        end
    end
    --Then update enemy recorded omni range
    UpdateRecordedAllPlayerOmni(oRadar, true)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateZoneIntelForRadar(oRadar)
    --If just built radar then want to update all land zones for the team to indicate the intel coverage
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateZoneIntelForRadar'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iTeam = oRadar:GetAIBrain().M28Team
    if bDebugMessages == true then LOG(sFunctionRef..': Just built radar '..oRadar.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRadar)..' owned by '..oRadar:GetAIBrain().Nickname..' with M28Team '..iTeam..'; is the table of active m28 brains for this team empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))..'; Time='..GetGameTimeSeconds()) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        if not(oRadar['M28UpdatedIntel']) then
            oRadar['M28UpdatedIntel'] = true
            local oBP = oRadar:GetBlueprint()
            local iIntelRange = (oBP.Intel.RadarRadius or 0)
            local iCurIntelRange
            local iOmniRange = (oBP.Intel.OmniRadius or 0)
            if bDebugMessages == true then LOG(sFunctionRef..': Radar intel range='..iIntelRange) end
            if iIntelRange > 0 or iOmniRange > 0 then
                --Update land zones:
                local bImprovedIntelCoverageOfZone = false
                local tPotentiallyObsoleteRadar = {}
                for iPlateau, tPlateauSubtable in M28Map.tAllPlateaus do
                    for iLandZone, tLZData in tPlateauSubtable[M28Map.subrefPlateauLandZones] do
                        if tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] < iIntelRange then
                            iCurIntelRange = iIntelRange - M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oRadar:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateau '..iPlateau..' Land zone '..iLandZone..'; iCurIntelRange factoring in distance='..iCurIntelRange..'; Distance='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oRadar:GetPosition())..'; LZ current radar coverage='..tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage]..'; tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar]='..(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar]) or 'nil')) end
                            if iCurIntelRange > tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] then
                                if iCurIntelRange > iIntelThresholdForPriorityScout then bImprovedIntelCoverageOfZone = true end
                                --First remove this plateau and LZ from the existing radar if there was one
                                if M28UnitInfo.IsUnitValid(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar]) then
                                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar][reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam]) == false then
                                        for iEntry, tiPlateauAndLZ in tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar][reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam] do
                                            if tiPlateauAndLZ[1] == iPlateau and tiPlateauAndLZ[2] == iLandZone then
                                                table.remove(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar][reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam], iEntry)
                                                break
                                            end
                                        end
                                    end
                                    table.insert(tPotentiallyObsoleteRadar, tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar])
                                    if bDebugMessages == true then LOG(sFunctionRef..': Added radar '..tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar].UnitId..M28UnitInfo.GetUnitLifetimeCount(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar])..' to potentially obsolete table') end
                                end
                                tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] = iCurIntelRange
                                tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar] = oRadar
                                if not(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam]) then oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam] = {} end
                                if not(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam]) then oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam] = {} end
                                table.insert(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam], {iPlateau, iLandZone})
                                if bDebugMessages == true then LOG(sFunctionRef..': Finished udpating for the new intel range, tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage]='..tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage]) end
                            end
                        end
                        if iOmniRange > (tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiOmniCoverage] or 0) then
                            tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiOmniCoverage] = math.max((tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiOmniCoverage] or 0), iOmniRange - M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oRadar:GetPosition()))
                        end
                    end
                end
                --Update any units wanting priority land scouts in cae they now have good enough coverage
                local tiLandSubteams = {}
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    tiLandSubteams[oBrain.M28LandSubteam] = true
                end

                for iLandSubteam, _ in tiLandSubteams do
                    if M28Conditions.IsTableOfUnitsStillValid(M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout]) then
                        for iCurEntry = table.getn(M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout]), 1, -1 do
                            local oRecorded =  M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout][iCurEntry]
                            if oRecorded[refiCurrentAssignmentPlateauAndLZ][2] then
                                local tCurLZTeamData = M28Map.tAllPlateaus[oRecorded[refiCurrentAssignmentPlateauAndLZ][1]][M28Map.subrefPlateauLandZones][oRecorded[refiCurrentAssignmentPlateauAndLZ][2]][M28Map.subrefLZTeamData][iTeam]
                                if tCurLZTeamData[M28Map.refiRadarCoverage] >= iIntelThresholdForPriorityScout then
                                    oRecorded[refbFlaggedForPriorityScout] = nil
                                    oRecorded[refiTimeLastBuiltLandScoutForUnit] = nil
                                    table.remove(M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout], iCurEntry)
                                end
                            end
                        end
                    end
                end

                --Update water zones
                for iPond, tPondSubtable in M28Map.tPondDetails do
                    if M28Utilities.IsTableEmpty(tPondSubtable[M28Map.subrefPondWaterZones]) == false then
                        for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
                            local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                            if tWZTeamData[M28Map.refiRadarCoverage] < iIntelRange then
                                iCurIntelRange = iIntelRange - M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oRadar:GetPosition())
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering iPond '..iPond..' Water zone '..iWaterZone..'; iCurIntelRange factoring in distance='..iCurIntelRange..'; Distance='..M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oRadar:GetPosition())..'; WZ current radar coverage='..tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiRadarCoverage]) end
                                if iCurIntelRange > tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiRadarCoverage] then
                                    --First remove this WZ from the existing (worse) radar if there was one
                                    if M28UnitInfo.IsUnitValid(tWZTeamData[M28Map.refoBestRadar]) then
                                        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.refoBestRadar][M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam]) == false then
                                            for iEntry, iRecordedWaterZone in tWZTeamData[M28Map.refoBestRadar][M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam] do
                                                if iRecordedWaterZone == iWaterZone then
                                                    table.remove(tWZTeamData[M28Map.refoBestRadar][M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam], iEntry)
                                                    break
                                                end
                                            end
                                        end
                                    end
                                    --Now assign this WZ to this radar as providing the best coverage
                                    tWZTeamData[M28Map.refiRadarCoverage] = iCurIntelRange
                                    tWZTeamData[M28Map.refoBestRadar] = oRadar
                                    if not(oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam]) then oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam] = {} end
                                    if not(oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam]) then oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam] = {} end
                                    table.insert(oRadar[M28Navy.reftiRadarWaterZonesCoveredByTeam][iTeam], iWaterZone)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished udpating for the new intel range, iWaterZone='..iWaterZone..'; tWZTeamData[M28Map.refiRadarCoverage]='..tWZTeamData[M28Map.refiRadarCoverage]) end
                                    table.insert(tPotentiallyObsoleteRadar, tWZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar])
                                end
                            end
                            if iOmniRange > (tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiOmniCoverage] or 0) then
                                tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiOmniCoverage] = math.max((tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiOmniCoverage] or 0), iOmniRange - M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oRadar:GetPosition()))
                            end
                        end
                    end
                end

                --Filter to obsolete radar and ctrl-K these (or record against the best radar if the best radar isn't constructed yet)
                if bDebugMessages == true then LOG(sFunctionRef..': Finished cycling through zones, is table of obsolete radar empty='..tostring(M28Utilities.IsTableEmpty(tPotentiallyObsoleteRadar))) end
                oRadar[reftoUnitsToKillOnCompletion] = nil
                if M28Utilities.IsTableEmpty(tPotentiallyObsoleteRadar) == false then
                    local tUniqueList = {}
                    local iUnitRef
                    local oBrain
                    for iUnit, oUnit in tPotentiallyObsoleteRadar do
                        oBrain = oUnit:GetAIBrain()
                        if oBrain.M28AI then
                            iUnitRef = oBrain:GetArmyIndex()..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Will add unit with ref incl ai index of '..iUnitRef..' to tUniqueList') end
                            if not(tUniqueList[iUnitRef]) then
                                tUniqueList[iUnitRef] = oUnit
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is tUniqueList empty='..tostring( M28Utilities.IsTableEmpty(tUniqueList))) end
                    if M28Utilities.IsTableEmpty(tUniqueList) == false then
                        local tUnitsToKill = {}
                        for iUnit, oUnit in tUniqueList do
                            local oBP = oUnit:GetBlueprint()
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with radar radius '..(oBP.Intel.RadarRadius or 0)..' vs iIntelRange='..iIntelRange) end
                            if (oBP.Intel.RadarRadius or 0) < math.max(1, iIntelRange) and (oBP.Intel.OmniRadius or 0) < math.max(1, iOmniRange) then
                                if (not(oUnit[M28UnitInfo.refbCampaignTriggerAdded]) or not(M28Map.bIsCampaignMap)) then
                                    table.insert(tUnitsToKill, oUnit)
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(tUnitsToKill) == false then
                            if oRadar:GetFractionComplete() < 1 then
                                oRadar[reftoUnitsToKillOnCompletion] = tUnitsToKill
                            else
                                local iTotalCount = table.getn(tUnitsToKill)
                                for iEntry = iTotalCount, 1, -1 do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Radar '..tUnitsToKill[iEntry].UnitId..M28UnitInfo.GetUnitLifetimeCount(tUnitsToKill[iEntry])..' has radar range of '..(tUnitsToKill[iEntry]:GetBlueprint().Intel.RadarRadius or 0)..' and is obsolete by oRadar '..oRadar.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRadar)..'; with iIntelRange='..iIntelRange) end
                                    M28Orders.IssueTrackedKillUnit(tUnitsToKill[iEntry])
                                end
                            end
                        end
                    end
                end
            end
            UpdateRecordedAllPlayerOmni(oRadar, false)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TrackWallSegment(oWall, bJustBuilt)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TrackWallSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oWall:GetPosition())
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oWall='..(oWall.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oWall) or 'nil')..'; bJustBuilt='..tostring(bJustBuilt)..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; Time='..GetGameTimeSeconds()) end
    if iLandZone > 0 then
        local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
        if bJustBuilt then
            local bAlreadyRecorded = false
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPlayerWallSegments]) == false then
                for iUnit, oUnit in tLZData[M28Map.subrefLZPlayerWallSegments] do
                    if oWall == oUnit then
                        bAlreadyRecorded = true
                        break
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished considering whether to add wall, bAlreadyRecorded='..tostring(bAlreadyRecorded)) end
            if not(bAlreadyRecorded) then
                table.insert(tLZData[M28Map.subrefLZPlayerWallSegments], oWall)
            end
        else
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPlayerWallSegments]) == false then
                --Remove any old entries
                local iRevisedIndex = 1
                local iTableSize = table.getn(tLZData[M28Map.subrefLZPlayerWallSegments])
                if bDebugMessages == true then LOG(sFunctionRef..': Will remove wall from table, iTableSize='..iTableSize) end
                for iOrigIndex=1, iTableSize do
                    if tLZData[M28Map.subrefLZPlayerWallSegments][iOrigIndex] then
                        if not(tLZData[M28Map.subrefLZPlayerWallSegments][iOrigIndex] == oWall) and M28UnitInfo.IsUnitValid(tLZData[M28Map.subrefLZPlayerWallSegments][iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                            --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                            if (iOrigIndex ~= iRevisedIndex) then
                                tLZData[M28Map.subrefLZPlayerWallSegments][iRevisedIndex] = tLZData[M28Map.subrefLZPlayerWallSegments][iOrigIndex];
                                tLZData[M28Map.subrefLZPlayerWallSegments][iOrigIndex] = nil;
                            end
                            iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                        else
                            tLZData[M28Map.subrefLZPlayerWallSegments][iOrigIndex] = nil;
                        end
                    end
                end
                if iRevisedIndex < iTableSize then
                    --table.setn(tLZData[M28Map.subrefLZPlayerWallSegments], iRevisedIndex - 1)
                    for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
                        table.remove(tLZData[M28Map.subrefLZPlayerWallSegments], iRemovalEntry)
                    end
                end
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Finished removing, is table empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPlayerWallSegments])))
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPlayerWallSegments]) == false then
                        LOG(sFunctionRef..': Table size after removing='..table.getn(tLZData[M28Map.subrefLZPlayerWallSegments]))
                    end
                end
            end
        end
    end
end

function RecordEnemyFirebase(iTeam, iPlateau, iLandZone)
    --Searches for all nearby land zones to iLandZone and flags that there is an enemy firebase nearby
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordEnemyFirebase'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; iTeam='..iTeam..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone) end

    if not(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau]) then M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau] = {} end
    M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone] = {[M28Team.subrefiNearbyPlateauAndLandZones] = {}, [M28Team.subrefbInRangeOfCoreLZ] = false}
    --Record any land zones in range of here
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
        for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
            local tAltLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefLZNumber]]
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iAltLZ='..tPathingData[M28Map.subrefLZNumber]..'; Dist from that LZ midpoint to the firebase LZ midpoint='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tAltLZData[M28Map.subrefMidpoint])) end
            if M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tAltLZData[M28Map.subrefMidpoint]) >= 163 then break end
            --The LZ is potentially within range of this firebase so record against that LZ
            if not(tAltLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftEnemyFirebasesInRange]) then tAltLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftEnemyFirebasesInRange] = {} end
            table.insert(tAltLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftEnemyFirebasesInRange], {iPlateau, iLandZone})

            --Also record against the base plateau and LZ all the alt LZs that we have been recorded against
            table.insert(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefiNearbyPlateauAndLandZones], {iPlateau, tPathingData[M28Map.subrefLZNumber]})

            --If it is a core LZ then record that (as will want to adjust our behaviour accordingly)
            if tAltLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] then
                M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefbInRangeOfCoreLZ] = true
            end
        end
    end
    --Also add to this LZ
    if not(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]) then tLZTeamData[M28Map.subreftEnemyFirebasesInRange] = {} end
    table.insert(tLZTeamData[M28Map.subreftEnemyFirebasesInRange], {iPlateau, iLandZone})
    --Also record against the base plateau and LZ all the alt LZs that we have been recorded against
    table.insert(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefiNearbyPlateauAndLandZones], {iPlateau, iLandZone})


    if bDebugMessages == true then LOG(sFunctionRef..': Finished recording for all LZ likely in range of the firebase, reprs of reftEnemyFirebaseByPlateauAndLZ for this plateau and LZ='..reprs(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RemoveEnemyFirebase(iTeam, iPlateau, iLandZone)
    --Goes through all land zones that recirded iLandZone as having a firebase in range of them, and removes this entry
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefiNearbyPlateauAndLandZones]) == false then
        for iEntry, tPlateauAndLZ in M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone][M28Team.subrefiNearbyPlateauAndLandZones] do
            local tAltLZTeamData = M28Map.tAllPlateaus[tPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][tPlateauAndLZ[2]][M28Map.subrefLZTeamData][iTeam]
            if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
                for iFirebase, tPlateauAndLZ in tAltLZTeamData[M28Map.subreftEnemyFirebasesInRange] do
                    if tPlateauAndLZ[1] == iPlateau and tPlateauAndLZ[2] == iLandZone then
                        table.remove(tAltLZTeamData[M28Map.subreftEnemyFirebasesInRange], iFirebase)
                        break
                    end
                end
            end
        end
    end
end

function ConsiderIfHaveEnemyFirebase(iTeam, oT2Arti)
    --Considers if hte land zone that oT2Arti is in has enough T2 arti threat to justify being a firebase
    --Idea is to only flag a firebase for something that MML are not expected to be able to break through - e.g. 3+ T2 arti; for smaller amounts the hope is that the arti can be overwhelmed
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderIfHaveEnemyFirebase'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oT2Arti:GetPosition())
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
    if (iLandZone or 0) > 0 then
        local bHaveFirebase = false
        local tAllT2Arti = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits])
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of all T2 arti for this zone empty='..tostring(M28Utilities.IsTableEmpty(tAllT2Arti))) end
        if M28Utilities.IsTableEmpty(tAllT2Arti) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Table size='.. table.getn(tAllT2Arti)) end
            if table.getn(tAllT2Arti) >= 3 then bHaveFirebase = true
            else
                local iTotalKills = 0
                for iUnit, oUnit in tAllT2Arti do
                    iTotalKills = iTotalKills + (oUnit.VetExperience or oUnit.Sync.totalMassKilled or 0)
                end
                if iTotalKills >= 2500 or (iTotalKills >= 1500 and table.getn(tAllT2Arti) == 1) then
                    bHaveFirebase = true
                end
            end
        end
        if bHaveFirebase then
            --If we dont have a firebase recorded already then record one
            if bDebugMessages == true then LOG(sFunctionRef..': Will record firebase if havent already, is it nil for this plateau and zone='..tostring(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone] == nil)) end
            if not(M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone]) then
                RecordEnemyFirebase(iTeam, iPlateau, iLandZone)
            end
        elseif M28Team.tTeamData[iTeam][M28Team.reftEnemyFirebaseByPlateauAndLZ][iPlateau][iLandZone] then
            --If we have recorded a firebase for this LZ then need to remove it
            RemoveEnemyFirebase(iTeam, iPlateau, iLandZone)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderIfAnyEnemyTeamsStillHaveFirebaseOnT2ArtiDeath(oT2Arti)
    local iBaseTeam = oT2Arti:GetAIBrain().M28Team
    for iTeam = 1, M28Team.iTotalTeamCount do
        if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 0 and not(iTeam == iBaseTeam) then
            ConsiderIfHaveEnemyFirebase(iTeam, oT2Arti)
            --update tracking of t2 arti to reflect it is dead
            M28Team.RecordEnemyT2ArtiAgainstNearbyZones(iTeam, oT2Arti, true)
        end
    end
end

function ConsiderAssigningMAABodyguardToFatboy(oMAA, oFatboy)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderAssigningMAABodyguardToFatboy'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain = oMAA:GetAIBrain()
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oMAA='..oMAA.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMAA)..'; oFatboy='..oFatboy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFatboy)..'; Brain='..aiBrain.Nickname..'; Time='..GetGameTimeSeconds()) end
    if aiBrain.M28AI then
        local iExistingMAA = 0
        if not(M28Conditions.IsTableOfUnitsStillValid(oFatboy[reftoAssignedMAAGuards])) then
            oFatboy[reftoAssignedMAAGuards] = {}
        else
            iExistingMAA = table.getn(oFatboy[reftoAssignedMAAGuards])
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iExistingMAA='..iExistingMAA) end
        if iExistingMAA < iFatboySafeMAACount and (iExistingMAA < iFatboyBaseMAACount or (M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyAirToGroundThreat] >= 10000 and not(M28Conditions.TeamHasAirControl(aiBrain.M28Team)))) then
            table.insert(oFatboy[reftoAssignedMAAGuards], oMAA)
            oMAA[refoAssignedUnitToGuard] = oFatboy
            if bDebugMessages == true then LOG(sFunctionRef..': Assigned MAA to guard the fatboy') end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderAssigningMAABodyguardToACU(oMAA)
    local oACU = oMAA:GetAIBrain()[M28ACU.refoPrimaryACU]
    if M28UnitInfo.IsUnitValid(oACU) and not(M28Conditions.IsTableOfUnitsStillValid(oACU[reftoAssignedMAAGuards])) then
        --if enemy has T2+ air or air to ground threat then assign
        local iTeam = oMAA:GetAIBrain().M28Team
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 2 or (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] or 0) > 0 then
            --Want to assign
            if not(oACU[reftoAssignedMAAGuards]) then oACU[reftoAssignedMAAGuards] = {} end
            table.insert(oACU[reftoAssignedMAAGuards], oMAA)
            oMAA[refoAssignedUnitToGuard] = oACU
        end
    end
end

function DontHaveJerichoAttackTarget(oJericho)
    if not(oJericho[M28UnitInfo.refbEasyBrain]) then
        local aiBrain = oJericho:GetAIBrain()
        local tEnemiesInRange = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryMobileLand * categories.TECH3 + M28UnitInfo.refCategoryNavalSurface - categories.TECH1, oJericho:GetPosition(), oJericho[M28UnitInfo.refiDFRange], 'Enemy')
        local oUnitToTarget
        if M28Utilities.IsTableEmpty(tEnemiesInRange) == false then
            local iHighestValue = 0
            local iCurValue
            local iMinRange = (oJericho[M28UnitInfo.refiDFMinRange] or -10) + 10
            for iUnit, oUnit in tEnemiesInRange do
                --Non-attached on land near-built unit that isnt inside minimum range?
                if not(oUnit:IsUnitState('Attached')) and oUnit:GetFractionComplete() >= 0.5 and not(M28UnitInfo.IsUnitUnderwater(oUnit)) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oJericho:GetPosition()) >= iMinRange then
                    iCurValue = (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * oUnit:GetFractionComplete()
                    if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then iCurValue = iCurValue * 0.1 end
                    if iCurValue > iHighestValue then
                        if (M28UnitInfo.GetBuildingSize(oUnit.UnitId) or 0) <= 4 then iCurValue = iCurValue * 0.3 end
                        if iCurValue > iHighestValue then
                            iHighestValue = iCurValue
                            oUnitToTarget = oUnit
                        end
                    end
                end
            end
        end
        if oUnitToTarget then
            --consider target leading
            local tGroundTarget
            if (oJericho[M28UnitInfo.refiDFAOE] or 0) > 0 and EntityCategoryContains(categories.MOBILE, oUnitToTarget.UnitId) and oUnitToTarget:IsUnitState('Moving') then
                local iWeaponVelocity
                local oBP = oJericho:GetBlueprint()
                if oBP.Weapon then
                    for iCurWeapon, oCurWeapon in oBP.Weapon do
                        if oCurWeapon.DamageRadius == oJericho[M28UnitInfo.refiDFAOE] then
                            iWeaponVelocity = oCurWeapon.MuzzleVelocity
                            break
                        end
                    end
                end
                if (iWeaponVelocity or 0) > 0 then
                    local iDistToEnemy = M28Utilities.GetDistanceBetweenPositions(oUnitToTarget:GetPosition(), oJericho:GetPosition())
                    local iTimeToImpact = 0.5 + iDistToEnemy / iWeaponVelocity
                    local iCurFacingDirection = M28UnitInfo.GetUnitFacingAngle(oUnitToTarget)
                    local iDistToLead = iTimeToImpact * (oUnitToTarget:GetBlueprint().Physics.MaxSpeed or 0)
                    local tLeadingTarget = M28Utilities.MoveInDirection(oUnitToTarget:GetPosition(), iCurFacingDirection, iDistToLead, true, false, M28Map.bIsCampaignMap)
                    if tLeadingTarget and M28Utilities.GetDistanceBetweenPositions(tLeadingTarget, oJericho:GetPosition()) >= (oJericho[M28UnitInfo.refiDFMinRange] or 0) then
                        tGroundTarget = {tLeadingTarget[1], tLeadingTarget[2], tLeadingTarget[3]}
                    end
                end
            end

            if tGroundTarget then
                M28Orders.IssueTrackedGroundAttack(oJericho, tGroundTarget, 1, false, 'JerGrnd', false, oUnitToTarget)
            else
                M28Orders.IssueTrackedAttack(oJericho, oUnitToTarget, false, 'JetAtk', false)
            end
            return false
        end
    end
    return true
end

function GetFarAwayLandThreatOfLongRangeUnits(tStartPoint, iTeam, bMinorZoneAdjustment)
    local iLongRangeFurtherAwayThreat = 0
    local iPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tStartPoint)
    if iPlateau and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftLongRangeEnemyDFUnits]) == false then
        local tMobileLandLRThreat = EntityCategoryFilterDown(categories.MOBILE * categories.LAND, M28Team.tTeamData[iTeam][M28Team.reftLongRangeEnemyDFUnits])
        local iUnitBaseThreat, iDistToMidpoint, iUnitPlateau, iUnitLandZone
        if M28Utilities.IsTableEmpty(tMobileLandLRThreat) == false then
            local iDistThreshold = 750
            if bMinorZoneAdjustment then iDistThreshold = 625 end
            for iUnit, oUnit in tMobileLandLRThreat do
                if M28UnitInfo.IsUnitValid(oUnit) then
                    --Only consider powerful units - e.g. fatboy
                    iUnitBaseThreat = (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) --want mass value since fatboy could regain its shield at any point
                    if bMinorZoneAdjustment then iUnitBaseThreat = iUnitBaseThreat * oUnit:GetFractionComplete() end
                    if iUnitBaseThreat >= 1000 then
                        --Only include if it can path to this zone
                        if NavUtils.GetLabel(M28Map.refPathingTypeHover, oUnit:GetPosition()) == iPlateau then
                            iDistToMidpoint = M28Utilities.GetDistanceBetweenPositions(tStartPoint, oUnit:GetPosition())
                            if iDistToMidpoint <= iDistThreshold then
                                if iDistToMidpoint <= 150 and not(bMinorZoneAdjustment) then
                                    iLongRangeFurtherAwayThreat = iLongRangeFurtherAwayThreat + iUnitBaseThreat * 1.2
                                elseif iDistToMidpoint <= 200 then
                                    iLongRangeFurtherAwayThreat = iLongRangeFurtherAwayThreat + iUnitBaseThreat
                                elseif iDistToMidpoint <= 400 then
                                    iLongRangeFurtherAwayThreat = iLongRangeFurtherAwayThreat + iUnitBaseThreat * 0.75
                                elseif iDistToMidpoint <= 600 then
                                    iLongRangeFurtherAwayThreat = iLongRangeFurtherAwayThreat + iUnitBaseThreat * 0.5
                                else
                                    iLongRangeFurtherAwayThreat = iLongRangeFurtherAwayThreat + iUnitBaseThreat * 0.25
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    return iLongRangeFurtherAwayThreat
end

function ConsiderPriorityLandScoutFlag(oUnit)
    if not(M28UnitInfo.IsUnitValid(oUnit[refoAssignedLandScout])) then
        local bInTable = false
        local iLandSubteam = oUnit:GetAIBrain().M28LandSubteam
        if oUnit[refbFlaggedForPriorityScout] == nil then
            if M28Utilities.IsTableEmpty(M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout]) == false then
                for iRecorded, oRecorded in M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout] do
                    if oRecorded == oUnit then
                        bInTable = true
                        oUnit[refbFlaggedForPriorityScout] = true
                        break
                    end
                end
            end
        end

        if not(bInTable) then
            if not(M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout]) then M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout] = {} end
            table.insert(M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingLandScout], oUnit)
            oUnit[refbFlaggedForPriorityScout] = true
        end
    end
end


function LandSubteamOverseer(iLandSubteam)
    local iStartPlateau, iStartZone
    local oFirstBrain
    for iBrain, oBrain in M28Team.tLandSubteamData[iLandSubteam][M28Team.subreftoFriendlyM28Brains] do
        oFirstBrain = oBrain
        break
    end
    iStartPlateau, iStartZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(M28Map.GetPlayerStartPosition(oFirstBrain))
    local iTeam = oFirstBrain.M28Team
    --Wait ticks based on team to spread out between different seconds
    WaitTicks(iTeam)
    local tStartLZData = M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iStartZone]
    local tStartLZTeamData = tStartLZData[M28Map.subrefLZTeamData][iTeam]

    while M28Utilities.IsTableEmpty(M28Team.tLandSubteamData[iLandSubteam][M28Team.subreftoFriendlyM28Brains]) == false do
        ForkThread(CompareNearbyAlliedAndEnemyLandThreats, iTeam, iLandSubteam, iStartPlateau, tStartLZData, tStartLZTeamData)
        WaitSeconds(10)
    end
end

function CompareNearbyAlliedAndEnemyLandThreats(iTeam, iLandSubteam, iStartPlateau, tStartLZData, tStartLZTeamData)
    --Assesses enemy mobile land threat and MAA threat on same island as our start position
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CompareNearbyAlliedAndEnemyLandThreats'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iMaxModDistance = 0.6
    local iMaxTravelDist = M28Map.iMapSize * 0.75
    local bHaveTeammates = false
    if table.getn(M28Team.tLandSubteamData[iLandSubteam][M28Team.subreftoFriendlyM28Brains]) > 1 then bHaveTeammates = true end
    local iOurMobileDFThreat = tStartLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
    local iEnemyMobileDFThreat = tStartLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]
    local iEnemyGroundAAThreat = tStartLZTeamData[M28Map.subrefLZThreatEnemyGroundAA]
    local iCurLZ
    if M28Utilities.IsTableEmpty(tStartLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
        for iEntry, tPathingData in tStartLZData[M28Map.subrefLZPathingToOtherLandZones] do
            iCurLZ = tPathingData[M28Map.subrefLZNumber]
            local tCurLZData = M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iCurLZ]
            local tCurLZTeamData = tCurLZData[M28Map.subrefLZTeamData][iTeam]
            if tCurLZTeamData[M28Map.refiModDistancePercent] <= iMaxModDistance then
                iOurMobileDFThreat = iOurMobileDFThreat + tCurLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
                iEnemyMobileDFThreat = iEnemyMobileDFThreat + tCurLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]
                iEnemyGroundAAThreat = iEnemyGroundAAThreat + tCurLZTeamData[M28Map.subrefLZThreatEnemyGroundAA]
            else
                if not(bHaveTeammates) or tCurLZTeamData[M28Map.refiModDistancePercent] >= 0.9 or tPathingData[M28Map.subrefLZTravelDist] >= iMaxTravelDist then
                    break
                end
            end
        end
    end
    M28Team.tLandSubteamData[iLandSubteam][M28Team.refiAllyMobileDFThreatNearOurSide] = iOurMobileDFThreat
    M28Team.tLandSubteamData[iLandSubteam][M28Team.refiEnemyMobileDFThreatNearOurSide] = iEnemyMobileDFThreat
    M28Team.tLandSubteamData[iLandSubteam][M28Team.refiEnemyGroundAAThreatNearOurSide] = iEnemyGroundAAThreat

    --Decide if we want to prioritise production over ecoing temporarily
    local bPrioritiseProduction = false
    if iOurMobileDFThreat < iEnemyMobileDFThreat and M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] < math.max(iEnemyMobileDFThreat * 0.4, iEnemyGroundAAThreat * 2) then
        --Further restrictions if campaign map or low threat values
        local iEnemyPlayerCount = table.getn(M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains])
        if not(M28Map.bIsCampaignMap) and GetGameTimeSeconds() >= 600 / M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier] and (iEnemyMobileDFThreat > 2000 * iEnemyPlayerCount or iEnemyMobileDFThreat - iOurMobileDFThreat > 1000 + 1000*iEnemyPlayerCount) then
            bPrioritiseProduction = true
            if iEnemyMobileDFThreat <= 8000 + 2000 * iEnemyPlayerCount then
                if iEnemyMobileDFThreat < iOurMobileDFThreat + math.max(iOurMobileDFThreat * 0.25, 1500) then
                    bPrioritiseProduction = false
                end
            end
        end
    end

    local bPreviouslyPrioritising = M28Team.tLandSubteamData[iLandSubteam][M28Team.refbPrioritiseProduction]
    M28Team.tLandSubteamData[iLandSubteam][M28Team.refbPrioritiseProduction] = bPrioritiseProduction
    if bPrioritiseProduction and not(bPreviouslyPrioritising) then
        --Consider unpausing any paused land and air factories if are in a mass stall
        if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] then
            for iBrain, oBrain in M28Team.tLandSubteamData[iLandSubteam][M28Team.subreftoFriendlyM28Brains] do
                local tFactoriesToUnpause = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryAirFactory)
                if M28Utilities.IsTableEmpty(tFactoriesToUnpause) == false then
                    for iUnit, oUnit in tFactoriesToUnpause do
                        if oUnit[M28UnitInfo.refbPaused] then
                            M28UnitInfo.PauseOrUnpauseMassUsage(oUnit, false, iTeam)
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code for land subteam '..iLandSubteam..' on team '..iTeam..', iOurMobileDFThreat='..iOurMobileDFThreat..'; iEnemyMobileDFThreat='..iEnemyMobileDFThreat..'; ur gunship threat='..M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat]..'; iEnemyGroundAAThreat='..iEnemyGroundAAThreat..'; bPrioritiseProduction='..tostring(bPrioritiseProduction)..'; Gross mass inc on team='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Time='..GetGameTimeSeconds()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end